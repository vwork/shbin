#!/usr/bin/env node

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/vadzim/v/work/nerojs/node_modules/colors/lib/colors.js":[function(require,module,exports){
/*

The MIT License (MIT)

Original Library 
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var ansiStyles = colors.styles = require('./styles');
var defineProps = Object.defineProperties;

colors.supportsColor = require('./system/supports-colors');

if (typeof colors.enabled === "undefined") {
  colors.enabled = colors.supportsColor;
}

colors.stripColors = colors.strip = function(str){
  return ("" + str).replace(/\x1B\[\d+m/g, '');
};


var stylize = colors.stylize = function stylize (str, style) {
  return ansiStyles[style].open + str + ansiStyles[style].close;
}

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe,  '\\$&');
}

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function () {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function (key) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function () {
        return build(this._styles.concat(key));
      }
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = arguments;
  var argsLen = args.length;
  var str = argsLen !== 0 && String(arguments[0]);
  if (argsLen > 1) {
    for (var a = 1; a < argsLen; a++) {
      str += ' ' + args[a];
    }
  }

  if (!colors.enabled || !str) {
    return str;
  }

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
  }

  return str;
}

function applyTheme (theme) {
  for (var style in theme) {
    (function(style){
      colors[style] = function(str){
        return colors[theme[style]](str);
      };
    })(style)
  }
}

colors.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      colors.themes[theme] = require(theme);
      applyTheme(colors.themes[theme]);
      return colors.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function (name) {
    ret[name] = {
      get: function () {
        return build([name]);
      }
    };
  });
  return ret;
}

var sequencer = function sequencer (map, str) {
  var exploded = str.split(""), i = 0;
  exploded = exploded.map(map);
  return exploded.join("");
};

// custom formatter methods
colors.trap = require('./custom/trap');
colors.zalgo = require('./custom/zalgo');

// maps
colors.maps = {};
colors.maps.america = require('./maps/america');
colors.maps.zebra = require('./maps/zebra');
colors.maps.rainbow = require('./maps/rainbow');
colors.maps.random = require('./maps/random')

for (var map in colors.maps) {
  (function(map){
    colors[map] = function (str) {
      return sequencer(colors.maps[map], str);
    }
  })(map)
}

defineProps(colors, init());
},{"./custom/trap":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/custom/trap.js","./custom/zalgo":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/custom/zalgo.js","./maps/america":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/maps/america.js","./maps/rainbow":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/maps/rainbow.js","./maps/random":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/maps/random.js","./maps/zebra":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/maps/zebra.js","./styles":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/styles.js","./system/supports-colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/system/supports-colors.js"}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/custom/trap.js":[function(require,module,exports){
module['exports'] = function runTheTrap (text, options) {
  var result = "";
  text = text || "Run the trap, drop the bass";
  text = text.split('');
  var trap = {
    a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
    b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
    c: ["\u00a9", "\u023b", "\u03fe"],
    d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
    e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
    f: ["\u04fa"],
    g: ["\u0262"],
    h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
    i: ["\u0f0f"],
    j: ["\u0134"],
    k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
    l: ["\u0139"],
    m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
    n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
    o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
    p: ["\u01f7", "\u048e"],
    q: ["\u09cd"],
    r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
    s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
    t: ["\u0141", "\u0166", "\u0373"],
    u: ["\u01b1", "\u054d"],
    v: ["\u05d8"],
    w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
    x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
    y: ["\u00a5", "\u04b0", "\u04cb"],
    z: ["\u01b5", "\u0240"]
  }
  text.forEach(function(c){
    c = c.toLowerCase();
    var chars = trap[c] || [" "];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== "undefined") {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;

}

},{}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/custom/zalgo.js":[function(require,module,exports){
// please no
module['exports'] = function zalgo(text, options) {
  text = text || "   he is here   ";
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }
  

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] = options["up"] || true;
    options["mid"] = options["mid"] || true;
    options["down"] = options["down"] || true;
    options["size"] = options["size"] || "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.min = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.min = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text);
}

},{}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/extendStringPrototype.js":[function(require,module,exports){
var colors = require('./colors'),
    styles = require('./styles');

module['exports'] = function () {

  //
  // Extends prototype of native string object to allow for "foo".red syntax
  //
  var addProperty = function (color, func) {
    String.prototype.__defineGetter__(color, func);
  };

  var sequencer = function sequencer (map, str) {
      return function () {
        var exploded = this.split(""), i = 0;
        exploded = exploded.map(map);
        return exploded.join("");
      }
  };

  var stylize = function stylize (str, style) {
    return styles[style].open + str + styles[style].close;
  }

  addProperty('strip', function () {
    return colors.strip(this);
  });

  addProperty('stripColors', function () {
    return colors.strip(this);
  });

  addProperty("trap", function(){
    return colors.trap(this);
  });

  addProperty("zalgo", function(){
    return colors.zalgo(this);
  });

  addProperty("zebra", function(){
    return colors.zebra(this);
  });

  addProperty("rainbow", function(){
    return colors.rainbow(this);
  });

  addProperty("random", function(){
    return colors.random(this);
  });

  addProperty("america", function(){
    return colors.america(this);
  });

  //
  // Iterate through all default styles and colors
  //
  var x = Object.keys(colors.styles);
  x.forEach(function (style) {
    addProperty(style, function () {
      return stylize(this, style);
    });
  });

  function applyTheme(theme) {
    //
    // Remark: This is a list of methods that exist
    // on String that you should not overwrite.
    //
    var stringPrototypeBlacklist = [
      '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
      'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
      'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
      'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
    ];

    Object.keys(theme).forEach(function (prop) {
      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
        console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
      }
      else {
        if (typeof(theme[prop]) === 'string') {
          colors[prop] = colors[theme[prop]];
          addProperty(prop, function () {
            return colors[theme[prop]](this);
          });
        }
        else {
          addProperty(prop, function () {
            var ret = this;
            for (var t = 0; t < theme[prop].length; t++) {
              ret = exports[theme[prop][t]](ret);
            }
            return ret;
          });
        }
      }
    });
  }

  colors.setTheme = function (theme) {
    if (typeof theme === 'string') {
      try {
        colors.themes[theme] = require(theme);
        applyTheme(colors.themes[theme]);
        return colors.themes[theme];
      } catch (err) {
        console.log(err);
        return err;
      }
    } else {
      applyTheme(theme);
    }
  };

};
},{"./colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/colors.js","./styles":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/styles.js"}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/index.js":[function(require,module,exports){
var colors = require('./colors');
module['exports'] = colors;

// Remark: By default, colors will add style properties to String.prototype
//
// If you don't wish to extend String.prototype you can do this instead and native String will not be touched
//
//   var colors = require('colors/safe);
//   colors.red("foo")
//
//
var extendStringPrototype = require('./extendStringPrototype')();
},{"./colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/colors.js","./extendStringPrototype":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/extendStringPrototype.js"}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/maps/america.js":[function(require,module,exports){
var colors = require('../colors');

module['exports'] = (function() {
  return function (letter, i, exploded) {
    if(letter === " ") return letter;
    switch(i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter)
      case 2: return colors.blue(letter)
    }
  }
})();
},{"../colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/colors.js"}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/maps/rainbow.js":[function(require,module,exports){
var colors = require('../colors');

module['exports'] = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
})();


},{"../colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/colors.js"}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/maps/random.js":[function(require,module,exports){
var colors = require('../colors');

module['exports'] = (function () {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
  return function(letter, i, exploded) {
    return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
  };
})();
},{"../colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/colors.js"}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/maps/zebra.js":[function(require,module,exports){
var colors = require('../colors');

module['exports'] = function (letter, i, exploded) {
  return i % 2 === 0 ? letter : colors.inverse(letter);
};
},{"../colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/colors.js"}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/styles.js":[function(require,module,exports){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49]

};

Object.keys(codes).forEach(function (key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});
},{}],"/home/vadzim/v/work/nerojs/node_modules/colors/lib/system/supports-colors.js":[function(require,module,exports){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var argv = process.argv;

module.exports = (function () {
  if (argv.indexOf('--no-color') !== -1 ||
    argv.indexOf('--color=false') !== -1) {
    return false;
  }

  if (argv.indexOf('--color') !== -1 ||
    argv.indexOf('--color=true') !== -1 ||
    argv.indexOf('--color=always') !== -1) {
    return true;
  }

  if (process.stdout && !process.stdout.isTTY) {
    return false;
  }

  if (process.platform === 'win32') {
    return true;
  }

  if ('COLORTERM' in process.env) {
    return true;
  }

  if (process.env.TERM === 'dumb') {
    return false;
  }

  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    return true;
  }

  return false;
})();
},{}],"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/index.js":[function(require,module,exports){
/*!
 * cookie-parser
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var cookie = require('cookie');
var parse = require('./lib/parse');

/**
 * Parse Cookie header and populate `req.cookies`
 * with an object keyed by the cookie names.
 *
 * @param {String} [secret]
 * @param {Object} [options]
 * @return {Function}
 * @api public
 */

exports = module.exports = function cookieParser(secret, options){
  return function cookieParser(req, res, next) {
    if (req.cookies) return next();
    var cookies = req.headers.cookie;

    req.secret = secret;
    req.cookies = Object.create(null);
    req.signedCookies = Object.create(null);

    // no cookies
    if (!cookies) {
      return next();
    }

    req.cookies = cookie.parse(cookies, options);

    // parse signed cookies
    if (secret) {
      req.signedCookies = parse.signedCookies(req.cookies, secret);
      req.signedCookies = parse.JSONCookies(req.signedCookies);
    }

    // parse JSON cookies
    req.cookies = parse.JSONCookies(req.cookies);

    next();
  };
};

/**
 * Export parsing functions.
 */

exports.JSONCookie = parse.JSONCookie;
exports.JSONCookies = parse.JSONCookies;
exports.signedCookie = parse.signedCookie;
exports.signedCookies = parse.signedCookies;

},{"./lib/parse":"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/lib/parse.js","cookie":"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/node_modules/cookie/index.js"}],"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/lib/parse.js":[function(require,module,exports){
var signature = require('cookie-signature');

/**
 * Parse signed cookies, returning an object
 * containing the decoded key/value pairs,
 * while removing the signed key from `obj`.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

exports.signedCookies = function(obj, secret){
  var cookies = Object.keys(obj);
  var dec;
  var key;
  var ret = Object.create(null);
  var val;

  for (var i = 0; i < cookies.length; i++) {
    key = cookies[i];
    val = obj[key];
    dec = exports.signedCookie(val, secret);

    if (val !== dec) {
      ret[key] = dec;
      delete obj[key];
    }
  }

  return ret;
};

/**
 * Parse a signed cookie string, return the decoded value
 *
 * @param {String} str signed cookie string
 * @param {String} secret
 * @return {String} decoded value
 * @api private
 */

exports.signedCookie = function(str, secret){
  return str.substr(0, 2) === 's:'
    ? signature.unsign(str.slice(2), secret)
    : str;
};

/**
 * Parse JSON cookies.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

exports.JSONCookies = function(obj){
  var cookies = Object.keys(obj);
  var key;
  var val;

  for (var i = 0; i < cookies.length; i++) {
    key = cookies[i];
    val = exports.JSONCookie(obj[key]);

    if (val) {
      obj[key] = val;
    }
  }

  return obj;
};

/**
 * Parse JSON cookie string
 *
 * @param {String} str
 * @return {Object} Parsed object or null if not json cookie
 * @api private
 */

exports.JSONCookie = function(str) {
  if (!str || str.substr(0, 2) !== 'j:') return;

  try {
    return JSON.parse(str.slice(2));
  } catch (err) {
    // no op
  }
};

},{"cookie-signature":"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/node_modules/cookie-signature/index.js"}],"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/node_modules/cookie-signature/index.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var crypto = require('crypto');

/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String}
 * @api private
 */

exports.sign = function(val, secret){
  if ('string' != typeof val) throw new TypeError('cookie required');
  if ('string' != typeof secret) throw new TypeError('secret required');
  return val + '.' + crypto
    .createHmac('sha256', secret)
    .update(val)
    .digest('base64')
    .replace(/\=+$/, '');
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function(val, secret){
  if ('string' != typeof val) throw new TypeError('cookie required');
  if ('string' != typeof secret) throw new TypeError('secret required');
  var str = val.slice(0, val.lastIndexOf('.'))
    , mac = exports.sign(str, secret);
  
  return sha1(mac) == sha1(val) ? str : false;
};

/**
 * Private
 */

function sha1(str){
  return crypto.createHash('sha1').update(str).digest('hex');
}

},{"crypto":false}],"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/node_modules/cookie/index.js":[function(require,module,exports){

/// Serialize the a name value pair into a cookie string suitable for
/// http headers. An optional options object specified cookie parameters
///
/// serialize('foo', 'bar', { httpOnly: true })
///   => "foo=bar; httpOnly"
///
/// @param {String} name
/// @param {String} val
/// @param {Object} options
/// @return {String}
var serialize = function(name, val, opt){
    opt = opt || {};
    var enc = opt.encode || encode;
    var pairs = [name + '=' + enc(val)];

    if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
        pairs.push('Max-Age=' + maxAge);
    }

    if (opt.domain) pairs.push('Domain=' + opt.domain);
    if (opt.path) pairs.push('Path=' + opt.path);
    if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());
    if (opt.httpOnly) pairs.push('HttpOnly');
    if (opt.secure) pairs.push('Secure');

    return pairs.join('; ');
};

/// Parse the given cookie header string into an object
/// The object has the various cookies as keys(names) => values
/// @param {String} str
/// @return {Object}
var parse = function(str, opt) {
    opt = opt || {};
    var obj = {}
    var pairs = str.split(/; */);
    var dec = opt.decode || decode;

    pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf('=')

        // skip things that don't look like key=value
        if (eq_idx < 0) {
            return;
        }

        var key = pair.substr(0, eq_idx).trim()
        var val = pair.substr(++eq_idx, pair.length).trim();

        // quoted values
        if ('"' == val[0]) {
            val = val.slice(1, -1);
        }

        // only assign once
        if (undefined == obj[key]) {
            try {
                obj[key] = dec(val);
            } catch (e) {
                obj[key] = val;
            }
        }
    });

    return obj;
};

var encode = encodeURIComponent;
var decode = decodeURIComponent;

module.exports.serialize = serialize;
module.exports.parse = parse;

},{}],"/home/vadzim/v/work/nerojs/node_modules/csv/lib/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var generate, parse, stringify, transform;

generate = require('csv-generate');

parse = require('csv-parse');

transform = require('stream-transform');

stringify = require('csv-stringify');

module.exports.generate = generate;

module.exports.parse = parse;

module.exports.transform = transform;

module.exports.stringify = stringify;

},{"csv-generate":"/home/vadzim/v/work/nerojs/node_modules/csv/node_modules/csv-generate/lib/index.js","csv-parse":"/home/vadzim/v/work/nerojs/node_modules/csv/node_modules/csv-parse/lib/index.js","csv-stringify":"/home/vadzim/v/work/nerojs/node_modules/csv/node_modules/csv-stringify/lib/index.js","stream-transform":"/home/vadzim/v/work/nerojs/node_modules/csv/node_modules/stream-transform/lib/index.js"}],"/home/vadzim/v/work/nerojs/node_modules/csv/node_modules/csv-generate/lib/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Generator, stream, util;

stream = require('stream');

util = require('util');


/*

`generate([options])`: Generate random CSV data
================================================

This function is provided for conveniency in case you need to generate random CSV data.

Note, it is quite simple at the moment, more functionnalities could come later. Feel free
to ask for features and to participate by writting issues and preparing push requests.

Options may include

*   `duration`   
    Period to run in milliseconds, default to 4 minutes.
*   `columns`   
    Define the number of generated fields and the generation 
    method. If columns is an integer, it corresponds to the 
    number of fields. If it is an array, each element correspond 
    to a field. If the element is a function, the function will generate
    the field value, if it is a string, it call the registered 
    function of the same name.
*   `max_word_length`   
    Maximum number of characters per word.
*   `seed`   
    Generate idempotent random characters if a number provided
*   `length`   
    Number of lines to read.   
*   `objectMode`   
    Whether this stream should behave as a stream of objects. Meaning 
    that stream.read(n) returns a single value instead of a Buffer of 
    size n. Default=false   
*   `highWaterMark`   
    The maximum number of bytes to store in the internal buffer 
    before ceasing to read from the underlying resource. Default=16kb

Starting a generation:   

```coffee
generate = require 'csv-generate'
data = []
generator = generate columns: ['int', 'bool'], seed: 1, duration: 1000
generator.on 'readable', ->
  while(d = generator.read())
    data.push d
generator.on 'error', (err) ->
  console.log err.message
generator.on 'end', ->
  console.log data
```

The module is also accessible through the `csv` module:   

```coffee
csv = require 'csv'
csv.generate(seed: 1).pipe(csv.stringify).pipe(process.stdout)
```
 */

Generator = function(options) {
  var i, v, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _i, _len, _ref;
  this.options = options != null ? options : {};
  stream.Readable.call(this, this.options);
  this.options.count = 0;
  if ((_base = this.options).duration == null) {
    _base.duration = 4 * 60 * 1000;
  }
  if ((_base1 = this.options).columns == null) {
    _base1.columns = 8;
  }
  if ((_base2 = this.options).max_word_length == null) {
    _base2.max_word_length = 16;
  }
  if ((_base3 = this.options).fixed_size == null) {
    _base3.fixed_size = false;
  }
  if (this.fixed_size_buffer == null) {
    this.fixed_size_buffer = '';
  }
  if ((_base4 = this.options).start == null) {
    _base4.start = Date.now();
  }
  if ((_base5 = this.options).end == null) {
    _base5.end = null;
  }
  if ((_base6 = this.options).seed == null) {
    _base6.seed = false;
  }
  if ((_base7 = this.options).length == null) {
    _base7.length = -1;
  }
  if ((_base8 = this.options).delimiter == null) {
    _base8.delimiter = ',';
  }
  this.count_written = 0;
  this.count_created = 0;
  if (typeof this.options.columns === 'number') {
    this.options.columns = new Array(this.options.columns);
  }
  _ref = this.options.columns;
  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
    v = _ref[i];
    if (v == null) {
      v = 'ascii';
    }
    if (typeof v === 'string') {
      this.options.columns[i] = Generator[v];
    }
  }
  return this;
};

util.inherits(Generator, stream.Readable);


/*
`random`

Generate a random number between 0 and 1 with 2 decimals.
 */

Generator.prototype.random = function() {
  if (this.options.seed) {
    return this.options.seed = this.options.seed * Math.PI * 100 % 100 / 100;
  } else {
    return Math.random();
  }
};

Generator.prototype.end = function() {
  return this.push(null);
};

Generator.prototype._read = function(size) {
  var column, data, header, length, line, lineLength, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
  data = [];
  length = this.fixed_size_buffer.length;
  if (length) {
    data.push(this.fixed_size_buffer);
  }
  while (true) {
    if ((this.count_created === this.options.length) || (this.options.end && Date.now() > this.options.end)) {
      if (data.length) {
        if (this.options.objectMode) {
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            line = data[_i];
            this.count_written++;
            this.push(line);
          }
        } else {
          this.count_written++;
          this.push(data.join(''));
        }
      }
      return this.push(null);
    }
    line = [];
    _ref = this.options.columns;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      header = _ref[_j];
      line.push("" + (header(this)));
    }
    if (this.options.objectMode) {
      lineLength = 0;
      for (_k = 0, _len2 = line.length; _k < _len2; _k++) {
        column = line[_k];
        lineLength += column.length;
      }
    } else {
      line = "" + (this.count_created === 0 ? '' : '\n') + (line.join(this.options.delimiter));
      lineLength = line.length;
    }
    this.count_created++;
    if (length + lineLength > size) {
      if (this.options.objectMode) {
        data.push(line);
        for (_l = 0, _len3 = data.length; _l < _len3; _l++) {
          line = data[_l];
          this.count_written++;
          this.push(line);
        }
      } else {
        if (this.options.fixed_size) {
          this.fixed_size_buffer = line.substr(size - length);
          data.push(line.substr(0, size - length));
        } else {
          data.push(line);
        }
        this.count_written++;
        this.push(data.join(''));
      }
      break;
    }
    length += lineLength;
    data.push(line);
  }
};

Generator.ascii = function(gen) {
  var char, column, nb_chars, _i, _ref;
  column = [];
  for (nb_chars = _i = 0, _ref = Math.ceil(gen.random() * gen.options.max_word_length); 0 <= _ref ? _i < _ref : _i > _ref; nb_chars = 0 <= _ref ? ++_i : --_i) {
    char = Math.floor(gen.random() * 32);
    column.push(String.fromCharCode(char + (char < 16 ? 65 : 97 - 16)));
  }
  return column.join('');
};

Generator.int = function(gen) {
  return Math.floor(gen.random() * Math.pow(2, 52));
};

Generator.bool = function(gen) {
  return Math.floor(gen.random() * 2);
};


/*
`generate([options])`
`generate([options], callback)`
 */

module.exports = function() {
  var callback, data, generator, options;
  if (arguments.length === 2) {
    options = arguments[0];
    callback = arguments[1];
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      options = {};
      callback = arguments[0];
    } else {
      options = arguments[0];
    }
  } else if (arguments.length === 0) {
    options = {};
  }
  generator = new Generator(options);
  if (callback) {
    data = [];
    generator.on('readable', function() {
      var d, _results;
      _results = [];
      while (d = generator.read()) {
        _results.push(data.push(options.objectMode ? d : d.toString()));
      }
      return _results;
    });
    generator.on('error', callback);
    generator.on('end', function() {
      return callback(null, options.objectMode ? data : data.join(''));
    });
  }
  return generator;
};

module.exports.Generator = Generator;

},{"stream":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/csv/node_modules/csv-parse/lib/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Parser, stream, util;

stream = require('stream');

util = require('util');

module.exports = function() {
  var callback, called, chunks, data, options, parser;
  if (arguments.length === 3) {
    data = arguments[0];
    options = arguments[1];
    callback = arguments[2];
  } else if (arguments.length === 2) {
    if (typeof arguments[0] === 'string') {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
    if (typeof arguments[1] === 'function') {
      callback = arguments[1];
    } else {
      options = arguments[1];
    }
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = arguments[0];
    } else {
      options = arguments[0];
    }
  }
  if (options == null) {
    options = {};
  }
  parser = new Parser(options);
  if (data) {
    process.nextTick(function() {
      parser.write(data);
      return parser.end();
    });
  }
  if (callback) {
    called = false;
    chunks = options.objname ? {} : [];
    parser.on('readable', function() {
      var chunk, _results;
      _results = [];
      while (chunk = parser.read()) {
        if (options.objname) {
          _results.push(chunks[chunk[0]] = chunk[1]);
        } else {
          _results.push(chunks.push(chunk));
        }
      }
      return _results;
    });
    parser.on('error', function(err) {
      called = true;
      return callback(err);
    });
    parser.on('end', function() {
      if (!called) {
        return callback(null, chunks);
      }
    });
  }
  return parser;
};

Parser = function(options) {
  var _base, _base1, _base10, _base11, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _base9;
  if (options == null) {
    options = {};
  }
  options.objectMode = true;
  stream.Transform.call(this, options);
  this.options = options;
  if ((_base = this.options).rowDelimiter == null) {
    _base.rowDelimiter = null;
  }
  if ((_base1 = this.options).delimiter == null) {
    _base1.delimiter = ',';
  }
  if ((_base2 = this.options).quote == null) {
    _base2.quote = '"';
  }
  if ((_base3 = this.options).escape == null) {
    _base3.escape = '"';
  }
  if ((_base4 = this.options).columns == null) {
    _base4.columns = null;
  }
  if ((_base5 = this.options).comment == null) {
    _base5.comment = '';
  }
  if ((_base6 = this.options).objname == null) {
    _base6.objname = false;
  }
  if ((_base7 = this.options).trim == null) {
    _base7.trim = false;
  }
  if ((_base8 = this.options).ltrim == null) {
    _base8.ltrim = false;
  }
  if ((_base9 = this.options).rtrim == null) {
    _base9.rtrim = false;
  }
  if ((_base10 = this.options).auto_parse == null) {
    _base10.auto_parse = false;
  }
  if ((_base11 = this.options).skip_empty_lines == null) {
    _base11.skip_empty_lines = false;
  }
  this.lines = 0;
  this.buf = '';
  this.quoting = false;
  this.commenting = false;
  this.field = '';
  this.lastC = '';
  this.nextChar = null;
  this.closingQuote = 0;
  this.line = [];
  this.chunks = [];
  this.floatRegexp = /^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/;
  return this;
};

util.inherits(Parser, stream.Transform);

module.exports.Parser = Parser;

Parser.prototype._transform = function(chunk, encoding, callback) {
  var err;
  if (chunk instanceof Buffer) {
    chunk = chunk.toString();
  }
  try {
    this.__write(chunk, false);
    return callback();
  } catch (_error) {
    err = _error;
    return this.emit('error', err);
  }
};

Parser.prototype._flush = function(callback) {
  var err;
  try {
    this.__write('', true);
    if (this.quoting) {
      this.emit('error', new Error("Quoted field not terminated at line " + (this.lines + 1)));
      return;
    }
    if (this.field || this.lastC === this.options.delimiter || this.lastC === this.options.quote) {
      if (this.options.trim || this.options.rtrim) {
        this.field = this.field.trimRight();
      }
      this.line.push(this.field);
      this.field = '';
    }
    if (this.line.length > 0) {
      this.__push(this.line);
    }
    return callback();
  } catch (_error) {
    err = _error;
    return this.emit('error', err);
  }
};

Parser.prototype.__push = function(line) {
  var field, i, lineAsColumns, _i, _len;
  if (this.options.columns === true) {
    this.options.columns = line;
    return;
  } else if (typeof this.options.columns === 'function') {
    this.options.columns = this.options.columns(line);
    return;
  }
  if (this.options.columns != null) {
    lineAsColumns = {};
    for (i = _i = 0, _len = line.length; _i < _len; i = ++_i) {
      field = line[i];
      lineAsColumns[this.options.columns[i]] = field;
    }
    if (this.options.objname) {
      return this.push([lineAsColumns[this.options.objname], lineAsColumns]);
    } else {
      return this.push(lineAsColumns);
    }
  } else {
    return this.push(line);
  }
};

Parser.prototype.__write = function(chars, end, callback) {
  var areNextCharsRowDelimiters, char, delimLength, escapeIsQuote, i, isDelimiter, isEscape, isQuote, isRowDelimiter, l, ltrim, nextCharPos, rowDelimiter, rtrim, wasCommenting, _results;
  ltrim = this.options.trim || this.options.ltrim;
  rtrim = this.options.trim || this.options.rtrim;
  chars = this.buf + chars;
  l = chars.length;
  delimLength = this.options.rowDelimiter ? this.options.rowDelimiter.length : 0;
  i = 0;
  if (this.lines === 0 && 0xFEFF === chars.charCodeAt(0)) {
    i++;
  }
  while (i < l) {
    if ((i + delimLength >= l && chars.substr(i, this.options.rowDelimiter.length) !== this.options.rowDelimiter) && !end) {
      break;
    }
    if ((i + this.options.escape.length >= l && chars.substr(i, this.options.escape.length) === this.options.escape) && !end) {
      break;
    }
    char = this.nextChar ? this.nextChar : chars.charAt(i);
    this.lastC = char;
    this.nextChar = chars.charAt(i + 1);
    if (this.options.rowDelimiter == null) {
      if ((this.field === '') && (char === '\n' || char === '\r')) {
        rowDelimiter = char;
        nextCharPos = i + 1;
      } else if (this.nextChar === '\n' || this.nextChar === '\r') {
        rowDelimiter = this.nextChar;
        nextCharPos = i + 2;
      }
      if (rowDelimiter) {
        if (rowDelimiter === '\r' && chars.charAt(nextCharPos) === '\n') {
          rowDelimiter += '\n';
        }
        this.options.rowDelimiter = rowDelimiter;
        delimLength = this.options.rowDelimiter.length;
      }
    }
    if (char === this.options.escape) {
      escapeIsQuote = this.options.escape === this.options.quote;
      isEscape = this.nextChar === this.options.escape;
      isQuote = this.nextChar === this.options.quote;
      if (!(escapeIsQuote && !this.field && !this.quoting) && (isEscape || isQuote)) {
        i++;
        char = this.nextChar;
        this.nextChar = chars.charAt(i + 1);
        this.field += char;
        i++;
        continue;
      }
    }
    if (char === this.options.quote) {
      if (this.quoting) {
        areNextCharsRowDelimiters = this.options.rowDelimiter && chars.substr(i + 1, this.options.rowDelimiter.length) === this.options.rowDelimiter;
        if (!this.options.relax && this.nextChar && !areNextCharsRowDelimiters && this.nextChar !== this.options.delimiter && this.nextChar !== this.options.comment) {
          throw new Error("Invalid closing quote at line " + (this.lines + 1) + "; found " + (JSON.stringify(this.nextChar)) + " instead of delimiter " + (JSON.stringify(this.options.delimiter)));
        }
        this.quoting = false;
        this.closingQuote = i;
        i++;
        continue;
      } else if (!this.field) {
        this.quoting = true;
        i++;
        continue;
      } else if (this.field && !this.options.relax) {
        throw new Error("Invalid opening quote at line " + (this.lines + 1));
      }
    }
    isDelimiter = char === this.options.delimiter;
    isRowDelimiter = this.options.rowDelimiter && chars.substr(i, this.options.rowDelimiter.length) === this.options.rowDelimiter;
    if (!this.commenting && !this.quoting && char === this.options.comment) {
      this.commenting = true;
    } else if (this.commenting && isRowDelimiter) {
      wasCommenting = true;
      this.commenting = false;
    }
    if (!this.commenting && !this.quoting && (isDelimiter || isRowDelimiter)) {
      if (isRowDelimiter && this.line.length === 0 && this.field === '') {
        if (wasCommenting || this.options.skip_empty_lines) {
          i += this.options.rowDelimiter.length;
          this.nextChar = chars.charAt(i);
          continue;
        }
      }
      if (rtrim) {
        if (this.closingQuote) {
          this.field = this.field.substr(0, this.closingQuote);
        } else {
          this.field = this.field.trimRight();
        }
      }
      if (this.options.auto_parse && this.floatRegexp.test(this.field)) {
        this.line.push(parseFloat(this.field));
      } else {
        this.line.push(this.field);
      }
      this.closingQuote = 0;
      this.field = '';
      if (isRowDelimiter) {
        this.__push(this.line);
        this.lines++;
        this.line = [];
        i += this.options.rowDelimiter.length;
        this.nextChar = chars.charAt(i);
        continue;
      }
    } else if (!this.commenting && !this.quoting && (char === ' ' || char === '\t')) {
      if (!(ltrim && !this.field)) {
        this.field += char;
      }
    } else if (!this.commenting) {
      this.field += char;
    }
    i++;
  }
  this.buf = '';
  _results = [];
  while (i < l) {
    this.buf += chars.charAt(i);
    _results.push(i++);
  }
  return _results;
};

},{"stream":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/csv/node_modules/csv-stringify/lib/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var Stringifier, stream, util;

stream = require('stream');

util = require('util');

module.exports = function() {
  var callback, chunks, data, options, stringifier;
  if (arguments.length === 3) {
    data = arguments[0];
    options = arguments[1];
    callback = arguments[2];
  } else if (arguments.length === 2) {
    if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
    if (typeof arguments[1] === 'function') {
      callback = arguments[1];
    } else {
      options = arguments[1];
    }
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = arguments[0];
    } else if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
  }
  if (options == null) {
    options = {};
  }
  stringifier = new Stringifier(options);
  if (data) {
    process.nextTick(function() {
      var d, _i, _len;
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        d = data[_i];
        stringifier.write(d);
      }
      return stringifier.end();
    });
  }
  if (callback) {
    chunks = [];
    stringifier.on('readable', function() {
      var chunk, _results;
      _results = [];
      while (chunk = stringifier.read()) {
        _results.push(chunks.push(chunk));
      }
      return _results;
    });
    stringifier.on('error', function(err) {
      return callback(err);
    });
    stringifier.on('finish', function() {
      return callback(null, chunks.join(''));
    });
  }
  return stringifier;
};

Stringifier = function(options) {
  var _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _base9;
  if (options == null) {
    options = {};
  }
  stream.Transform.call(this, options);
  this.options = options;
  if ((_base = this.options).delimiter == null) {
    _base.delimiter = ',';
  }
  if ((_base1 = this.options).quote == null) {
    _base1.quote = '"';
  }
  if ((_base2 = this.options).quoted == null) {
    _base2.quoted = false;
  }
  if ((_base3 = this.options).quotedString == null) {
    _base3.quotedString = false;
  }
  if ((_base4 = this.options).eof == null) {
    _base4.eof = true;
  }
  if ((_base5 = this.options).escape == null) {
    _base5.escape = '"';
  }
  if ((_base6 = this.options).columns == null) {
    _base6.columns = null;
  }
  if ((_base7 = this.options).header == null) {
    _base7.header = false;
  }
  if ((_base8 = this.options).lineBreaks == null) {
    _base8.lineBreaks = null;
  }
  if ((_base9 = this.options).rowDelimiter == null) {
    _base9.rowDelimiter = '\n';
  }
  if (this.countWriten == null) {
    this.countWriten = 0;
  }
  switch (this.options.rowDelimiter) {
    case 'auto':
      this.options.rowDelimiter = null;
      break;
    case 'unix':
      this.options.rowDelimiter = "\n";
      break;
    case 'mac':
      this.options.rowDelimiter = "\r";
      break;
    case 'windows':
      this.options.rowDelimiter = "\r\n";
      break;
    case 'unicode':
      this.options.rowDelimiter = "\u2028";
  }
  return this;
};

util.inherits(Stringifier, stream.Transform);

module.exports.Stringifier = Stringifier;

Stringifier.prototype.headers = function() {
  var k, label, labels;
  if (!this.options.header) {
    return;
  }
  if (!this.options.columns) {
    return;
  }
  labels = this.options.columns;
  if (typeof labels === 'object') {
    labels = (function() {
      var _results;
      _results = [];
      for (k in labels) {
        label = labels[k];
        _results.push(label);
      }
      return _results;
    })();
  }
  if (this.options.eof) {
    labels = this.stringify(labels) + this.options.rowDelimiter;
  } else {
    labels = this.stringify(labels);
  }
  return stream.Transform.prototype.write.call(this, labels);
};

Stringifier.prototype.end = function(chunk, encoding, callback) {
  if (this.countWriten === 0) {
    this.headers();
  }
  return stream.Transform.prototype.end.apply(this, arguments);
};

Stringifier.prototype.write = function(chunk, encoding, callback) {
  var e, preserve, _base;
  if (chunk == null) {
    return;
  }
  preserve = typeof chunk !== 'object';
  if (!preserve) {
    if (this.countWriten === 0 && !Array.isArray(chunk)) {
      if ((_base = this.options).columns == null) {
        _base.columns = Object.keys(chunk);
      }
    }
    try {
      this.emit('record', chunk, this.countWriten);
    } catch (_error) {
      e = _error;
      return this.emit('error', e);
    }
    if (this.options.eof) {
      chunk = this.stringify(chunk) + this.options.rowDelimiter;
    } else {
      chunk = this.stringify(chunk);
      if (this.options.header || this.countWriten) {
        chunk = this.options.rowDelimiter + chunk;
      }
    }
  }
  if (typeof chunk === 'number') {
    chunk = "" + chunk;
  }
  if (this.countWriten === 0) {
    this.headers();
  }
  if (!preserve) {
    this.countWriten++;
  }
  return stream.Transform.prototype.write.call(this, chunk, encoding, callback);
};

Stringifier.prototype._transform = function(chunk, encoding, callback) {
  this.push(chunk);
  return callback();
};

Stringifier.prototype.stringify = function(line) {
  var column, columns, containsLinebreak, containsQuote, containsdelimiter, delimiter, escape, field, i, newLine, quote, regexp, _i, _j, _line, _ref, _ref1;
  if (typeof line !== 'object') {
    return line;
  }
  columns = this.options.columns;
  if (typeof columns === 'object' && columns !== null && !Array.isArray(columns)) {
    columns = Object.keys(columns);
  }
  delimiter = this.options.delimiter;
  quote = this.options.quote;
  escape = this.options.escape;
  if (!Array.isArray(line)) {
    _line = [];
    if (columns) {
      for (i = _i = 0, _ref = columns.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        column = columns[i];
        _line[i] = typeof line[column] === 'undefined' || line[column] === null ? '' : line[column];
      }
    } else {
      for (column in line) {
        _line.push(line[column]);
      }
    }
    line = _line;
    _line = null;
  } else if (columns) {
    line.splice(columns.length);
  }
  if (Array.isArray(line)) {
    newLine = '';
    for (i = _j = 0, _ref1 = line.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      field = line[i];
      if (typeof field === 'string') {

      } else if (typeof field === 'number') {
        field = '' + field;
      } else if (typeof field === 'boolean') {
        field = field ? '1' : '';
      } else if (field instanceof Date) {
        field = '' + field.getTime();
      }
      if (field) {
        containsdelimiter = field.indexOf(delimiter) >= 0;
        containsQuote = field.indexOf(quote) >= 0;
        containsLinebreak = field.indexOf('\r') >= 0 || field.indexOf('\n') >= 0;
        if (containsQuote) {
          regexp = new RegExp(quote, 'g');
          field = field.replace(regexp, escape + quote);
        }
        if (containsQuote || containsdelimiter || containsLinebreak || this.options.quoted || (this.options.quotedString && typeof line[i] === 'string')) {
          field = quote + field + quote;
        }
        newLine += field;
      } else if (this.options.quotedEmpty || ((this.options.quotedEmpty == null) && line[i] === '' && this.options.quotedString)) {
        newLine += quote + quote;
      }
      if (i !== line.length - 1) {
        newLine += delimiter;
      }
    }
    line = newLine;
  }
  return line;
};

},{"stream":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/csv/node_modules/stream-transform/lib/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Transformer, stream, util,
  __slice = [].slice;

stream = require('stream');

util = require('util');

module.exports = function() {
  var argument, callback, data, error, i, k, options, result, transform, type, udf, v, _i, _len;
  options = {};
  for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {
    argument = arguments[i];
    type = typeof argument;
    if (argument === null) {
      type = 'null';
    } else if (type === 'object' && Array.isArray(argument)) {
      type = 'array';
    }
    if (i === 0) {
      if (type === 'function') {
        udf = argument;
      } else if (type !== null) {
        data = argument;
      }
      continue;
    }
    if (type === 'object') {
      for (k in argument) {
        v = argument[k];
        options[k] = v;
      }
    } else if (type === 'function') {
      if (i === arguments.length - 1) {
        callback = argument;
      } else {
        udf = argument;
      }
    } else if (type !== 'null') {
      throw new Error('Invalid arguments');
    }
  }
  transform = new Transformer(options, udf);
  error = false;
  if (data) {
    process.nextTick(function() {
      var row, _j, _len1;
      for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
        row = data[_j];
        if (error) {
          break;
        }
        transform.write(row);
      }
      return transform.end();
    });
  }
  if (callback) {
    result = [];
    transform.on('readable', function() {
      var r, _results;
      _results = [];
      while ((r = transform.read())) {
        _results.push(result.push(r));
      }
      return _results;
    });
    transform.on('error', function(err) {
      error = true;
      return callback(err);
    });
    transform.on('end', function() {
      if (!error) {
        return callback(null, result);
      }
    });
  }
  return transform;
};

Transformer = function(options, transform) {
  var _base;
  this.options = options != null ? options : {};
  this.transform = transform;
  this.options.objectMode = true;
  if ((_base = this.options).parallel == null) {
    _base.parallel = 100;
  }
  stream.Transform.call(this, this.options);
  this.running = 0;
  this.started = 0;
  this.finished = 0;
  return this;
};

util.inherits(Transformer, stream.Transform);

module.exports.Transformer = Transformer;

Transformer.prototype._transform = function(chunk, encoding, cb) {
  var err;
  this.started++;
  this.running++;
  if (this.running < this.options.parallel) {
    cb();
    cb = null;
  }
  try {
    if (this.transform.length === 2) {
      return this.transform.call(null, chunk, (function(_this) {
        return function() {
          var chunks, err;
          err = arguments[0], chunks = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          return _this._done(err, chunks, cb);
        };
      })(this));
    } else {
      return this._done(null, [this.transform.call(null, chunk)], cb);
    }
  } catch (_error) {
    err = _error;
    return this._done(err);
  }
};

Transformer.prototype._flush = function(cb) {
  this._ending = function() {
    if (this.running === 0) {
      return cb();
    }
  };
  return this._ending();
};

Transformer.prototype._done = function(err, chunks, cb) {
  var chunk, _i, _len;
  this.running--;
  if (err) {
    return this.emit('error', err);
  }
  this.finished++;
  for (_i = 0, _len = chunks.length; _i < _len; _i++) {
    chunk = chunks[_i];
    if (typeof chunk === 'number') {
      chunk = "" + chunk;
    }
    if (chunk != null) {
      this.push(chunk);
    }
  }
  if (cb) {
    cb();
  }
  if (this._ending) {
    return this._ending();
  }
};

},{"stream":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/glob/common.js":[function(require,module,exports){
exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.isAbsolute = process.platform === "win32" ? absWin : absUnix
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = require("path")
var minimatch = require("minimatch")
var Minimatch = minimatch.Minimatch

function absWin (p) {
  if (absUnix(p)) return true
  // pull off the device/UNC bit from a windows path.
  // from node's lib/path.js
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
  var result = splitDeviceRe.exec(p)
  var device = result[1] || ''
  var isUnc = device && device.charAt(1) !== ':'
  var isAbsolute = !!result[2] || isUnc // UNC paths are always absolute

  return isAbsolute
}

function absUnix (p) {
  return p.charAt(0) === "/" || p === ""
}

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}


function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.pattern = pattern
  self.strict = options.strict !== false
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = options.cwd
    self.changedCwd = path.resolve(options.cwd) !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  self.nomount = !!options.nomount

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        return !(/\/$/.test(e))
      })
    }
  }

  self.found = all
}

function mark (self, p) {
  var c = self.cache[p]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      self.statCache[m] = self.statCache[p]
      self.cache[m] = self.cache[p]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === "/") {
    abs = path.join(self.root, f)
  } else if (exports.isAbsolute(f)) {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  }
  return abs
}

},{"minimatch":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/minimatch.js","path":false}],"/home/vadzim/v/work/nerojs/node_modules/glob/glob.js":[function(require,module,exports){
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = require("fs")
var minimatch = require("minimatch")
var Minimatch = minimatch.Minimatch
var inherits = require("inherits")
var EE = require("events").EventEmitter
var path = require("path")
var assert = require("assert")
var globSync = require("./sync.js")
var common = require("./common.js")
var alphasort = common.alphasort
var isAbsolute = common.isAbsolute
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = require("inflight")
var util = require("util")

var once = require("once")

function glob (pattern, options, cb) {
  if (typeof options === "function") cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

glob.hasMagic = function (pattern, options_) {
  var options = util._extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set
  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === "function") {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === "function") {
    cb = once(cb)
    this.on("error", cb)
    this.on("end", function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  var n = this.minimatch.set.length
  this._processing = 0
  this.matches = new Array(n)

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }

  function done () {
    --self._processing
    if (self._processing <= 0)
      self._finish()
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  //console.error('FINISH', this.matches)
  common.finish(this)
  this.emit("end", this.found)
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit("abort")
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit("pause")
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit("resume")
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error("PROCESS %d", this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === "string") {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's "absolute" like /foo/bar,
      // or "relative" like "../baz"
      prefix = pattern.slice(0, n).join("/")
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = "."
  else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = "/" + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}


Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === "."

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== "." || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === "/" && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== "/")
        e = prefix + "/" + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (!this.matches[index][e]) {
    if (this.paused) {
      this._emitQueue.push([index, e])
      return
    }

    if (this.nodir) {
      var c = this.cache[this._makeAbs(e)]
      if (c === 'DIR' || Array.isArray(c))
        return
    }

    this.matches[index][e] = true
    if (!this.stat && !this.mark)
      return this.emit("match", e)

    var self = this
    this._stat(this._makeAbs(e), function (er, c, st) {
      self.emit("stat", e, st)
      self.emit("match", e)
    })
  }
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  var lstatkey = "lstat\0" + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er)
      return cb()

    var isSym = lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight("readdir\0"+abs+"\0"+inGlobStar, cb)
  if (!cb)
    return

  //console.error("RD %j %j", +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries.sort(alphasort), cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === "/")
        e = abs + e
      else
        e = abs + "/" + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case "ENOTDIR": // totally normal. means it *does* exist.
      this.cache[f] = 'FILE'
      break

    case "ENOENT": // not terribly unusual
    case "ELOOP":
    case "ENAMETOOLONG":
    case "UNKNOWN":
      this.cache[f] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[f] = false
      if (this.strict) return this.emit("error", er)
      if (!this.silent) console.error("glob error", er)
      break
  }
  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error("pgs2", prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === "." && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error("ps2", prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    if (prefix.charAt(0) === "/") {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
    }
  }

  if (process.platform === "win32")
    prefix = prefix.replace(/\\/g, "/")

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = f
  if (f.charAt(0) === "/")
    abs = path.join(this.root, f)
  else if (this.changedCwd)
    abs = path.resolve(this.cwd, f)


  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, f)) {
    var c = this.cache[f]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but not how we need it
    if (abs.slice(-1) === "/" && c !== 'DIR')
      return cb()

    return cb(null, c)
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else
      return cb(null, stat.isDirectory() ? 'DIR' : 'FILE', stat)
  }

  var self = this
  var statcb = inflight("stat\0" + abs, statcb_)
  if (statcb)
    fs.stat(abs, statcb)

  function statcb_ (er, stat) {
    self._stat2(f, abs, er, stat, cb)
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er) {
    this.statCache[abs] = false
    return cb()
  }

  this.statCache[abs] = stat

  if (abs.slice(-1) === "/" && !stat.isDirectory())
    return cb(null, false, stat)

  var c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[f] = this.cache[f] || c
  return cb(null, c, stat)
}

},{"./common.js":"/home/vadzim/v/work/nerojs/node_modules/glob/common.js","./sync.js":"/home/vadzim/v/work/nerojs/node_modules/glob/sync.js","assert":false,"events":false,"fs":false,"inflight":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inflight/inflight.js","inherits":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inherits/inherits_browser.js","minimatch":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/minimatch.js","once":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/once/once.js","path":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inflight/inflight.js":[function(require,module,exports){
var wrappy = require('wrappy')
var reqs = Object.create(null)
var once = require('once')

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)
    for (var i = 0; i < len; i++) {
      cbs[i].apply(null, args)
    }
    if (cbs.length > len) {
      // added more in the interim.
      // de-zalgo, just in case, but don't call again.
      cbs.splice(0, len)
      process.nextTick(function () {
        RES.apply(null, args)
      })
    } else {
      delete reqs[key]
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}

},{"once":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/once/once.js","wrappy":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inflight/node_modules/wrappy/wrappy.js"}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inflight/node_modules/wrappy/wrappy.js":[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/minimatch.js":[function(require,module,exports){
module.exports = minimatch
minimatch.Minimatch = Minimatch

var isWindows = false
if (typeof process !== 'undefined' && process.platform === 'win32')
  isWindows = true

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
  , expand = require("brace-expansion")

  // any single thing other than /
  // don't need to escape / when using new RegExp()
  , qmark = "[^/]"

  // * => any number of characters
  , star = qmark + "*?"

  // ** when dots are allowed.  Anything goes, except .. and .
  // not (^ or / followed by one or two dots followed by $ or /),
  // followed by anything, any number of times.
  , twoStarDot = "(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?"

  // not a ^ or / followed by a dot,
  // followed by anything, any number of times.
  , twoStarNoDot = "(?:(?!(?:\\\/|^)\\.).)*?"

  // characters that need to be escaped in RegExp.
  , reSpecials = charSet("().*{}+?[]^$\\!")

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split("").reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}


function minimatch (p, pattern, options) {
  if (typeof pattern !== "string") {
    throw new TypeError("glob pattern string required")
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === "") return p === ""

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== "string") {
    throw new TypeError("glob pattern string required")
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (isWindows)
    pattern = pattern.split("\\").join("/")

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function() {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === "#") {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return -1 === s.indexOf(false)
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
    , negate = false
    , options = this.options
    , negateOffset = 0

  if (options.nonegate) return

  for ( var i = 0, l = pattern.length
      ; i < l && pattern.charAt(i) === "!"
      ; i ++) {
    negate = !negate
    negateOffset ++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch)
      options = this.options
    else
      options = {}
  }

  pattern = typeof pattern === "undefined"
    ? this.pattern : pattern

  if (typeof pattern === "undefined") {
    throw new Error("undefined pattern")
  }

  if (options.nobrace ||
      !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === "**") return GLOBSTAR
  if (pattern === "") return ""

  var re = ""
    , hasMagic = !!options.nocase
    , escaping = false
    // ? => one single character
    , patternListStack = []
    , plType
    , stateChar
    , inClass = false
    , reClassStart = -1
    , classStart = -1
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.
    , patternStart = pattern.charAt(0) === "." ? "" // anything
      // not (start or / followed by . or .. followed by / or end)
      : options.dot ? "(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))"
      : "(?!\\.)"
    , self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case "*":
          re += star
          hasMagic = true
          break
        case "?":
          re += qmark
          hasMagic = true
          break
        default:
          re += "\\"+stateChar
          break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for ( var i = 0, len = pattern.length, c
      ; (i < len) && (c = pattern.charAt(i))
      ; i ++ ) {

    this.debug("%s\t%s %s %j", pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += "\\" + c
      escaping = false
      continue
    }

    SWITCH: switch (c) {
      case "/":
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case "\\":
        clearStateChar()
        escaping = true
        continue

      // the various stateChar values
      // for the "extglob" stuff.
      case "?":
      case "*":
      case "+":
      case "@":
      case "!":
        this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === "!" && i === classStart + 1) c = "^"
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
        continue

      case "(":
        if (inClass) {
          re += "("
          continue
        }

        if (!stateChar) {
          re += "\\("
          continue
        }

        plType = stateChar
        patternListStack.push({ type: plType
                              , start: i - 1
                              , reStart: re.length })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === "!" ? "(?:(?!" : "(?:"
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
        continue

      case ")":
        if (inClass || !patternListStack.length) {
          re += "\\)"
          continue
        }

        clearStateChar()
        hasMagic = true
        re += ")"
        plType = patternListStack.pop().type
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        switch (plType) {
          case "!":
            re += "[^/]*?)"
            break
          case "?":
          case "+":
          case "*": re += plType
          case "@": break // the default anyway
        }
        continue

      case "|":
        if (inClass || !patternListStack.length || escaping) {
          re += "\\|"
          escaping = false
          continue
        }

        clearStateChar()
        re += "|"
        continue

      // these are mostly the same in regexp and glob
      case "[":
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += "\\" + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
        continue

      case "]":
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += "\\" + c
          escaping = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
        continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
                   && !(c === "^" && inClass)) {
          re += "\\"
        }

        re += c

    } // switch
  } // for


  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    var cs = pattern.substr(classStart + 1)
      , sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + "\\[" + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  var pl
  while (pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + 3)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = "\\"
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + "|"
    })

    this.debug("tail=%j\n   %s", tail, tail)
    var t = pl.type === "*" ? star
          : pl.type === "?" ? qmark
          : "\\" + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart)
       + t + "\\("
       + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += "\\\\"
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case ".":
    case "[":
    case "(": addPatternStart = true
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== "" && hasMagic) re = "(?=.)" + re

  if (addPatternStart) re = patternStart + re

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [ re, hasMagic ]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? "i" : ""
    , regExp = new RegExp("^" + re + "$", flags)

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) return this.regexp = false
  var options = this.options

  var twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    , flags = options.nocase ? "i" : ""

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
           : (typeof p === "string") ? regExpEscape(p)
           : p._src
    }).join("\\\/")
  }).join("|")

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = "^(?:" + re + ")$"

  // can match anything, as long as it's not this.
  if (this.negate) re = "^(?!" + re + ").*$"

  try {
    return this.regexp = new RegExp(re, flags)
  } catch (ex) {
    return this.regexp = false
  }
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug("match", f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ""

  if (f === "/" && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (isWindows)
    f = f.split("\\").join("/")

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, "split", f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, "set", set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  for (var i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (var i = 0, l = set.length; i < l; i ++) {
    var pattern = set[i], file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug("matchOne",
              { "this": this
              , file: file
              , pattern: pattern })

  this.debug("matchOne", file.length, pattern.length)

  for ( var fi = 0
          , pi = 0
          , fl = file.length
          , pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi ++, pi ++ ) {

    this.debug("matchOne loop")
    var p = pattern[pi]
      , f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
        , pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for ( ; fi < fl; fi ++) {
          if (file[fi] === "." || file[fi] === ".." ||
              (!options.dot && file[fi].charAt(0) === ".")) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      WHILE: while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while',
                    file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === "." || swallowee === ".." ||
              (!options.dot && swallowee.charAt(0) === ".")) {
            this.debug("dot detected!", file, fr, pattern, pr)
            break WHILE
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr ++
        }
      }
      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug("\n>>> no match, partial?", file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === "string") {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug("string match", p, f, hit)
    } else {
      hit = f.match(p)
      this.debug("pattern match", p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === "")
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error("wtf?")
}


// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, "$1")
}


function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
}

},{"brace-expansion":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/index.js"}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/index.js":[function(require,module,exports){
var concatMap = require('concat-map');
var balanced = require('balanced-match');

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}


},{"balanced-match":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/index.js","concat-map":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/index.js"}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/index.js":[function(require,module,exports){
module.exports = balanced;
function balanced(a, b, str) {
  var bal = 0;
  var m = {};
  var ended = false;

  for (var i = 0; i < str.length; i++) {
    if (a == str.substr(i, a.length)) {
      if (!('start' in m)) m.start = i;
      bal++;
    }
    else if (b == str.substr(i, b.length) && 'start' in m) {
      ended = true;
      bal--;
      if (!bal) {
        m.end = i;
        m.pre = str.substr(0, m.start);
        m.body = (m.end - m.start > 1)
          ? str.substring(m.start + a.length, m.end)
          : '';
        m.post = str.slice(m.end + b.length);
        return m;
      }
    }
  }

  // if we opened more than we closed, find the one we closed
  if (bal && ended) {
    var start = m.start + a.length;
    m = balanced(a, b, str.substr(start));
    if (m) {
      m.start += start;
      m.end += start;
      m.pre = str.slice(0, start) + m.pre;
    }
    return m;
  }
}

},{}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/index.js":[function(require,module,exports){
module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/once/node_modules/wrappy/wrappy.js":[function(require,module,exports){
module.exports=require("/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inflight/node_modules/wrappy/wrappy.js")
},{"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inflight/node_modules/wrappy/wrappy.js":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/inflight/node_modules/wrappy/wrappy.js"}],"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/once/once.js":[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},{"wrappy":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/once/node_modules/wrappy/wrappy.js"}],"/home/vadzim/v/work/nerojs/node_modules/glob/sync.js":[function(require,module,exports){
module.exports = globSync
globSync.GlobSync = GlobSync

var fs = require("fs")
var minimatch = require("minimatch")
var Minimatch = minimatch.Minimatch
var Glob = require("./glob.js").Glob
var util = require("util")
var path = require("path")
var assert = require("assert")
var common = require("./common.js")
var alphasort = common.alphasort
var isAbsolute = common.isAbsolute
var setopts = common.setopts
var ownProp = common.ownProp

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error("must provide pattern")

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === "string") {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's "absolute" like /foo/bar,
      // or "relative" like "../baz"
      prefix = pattern.slice(0, n).join("/")
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = "."
  else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = "/" + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}

GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === "."

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== "." || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== "/")
          e = prefix + "/" + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === "/" && !this.nomount) {
        e = path.join(this.root, e)
      }
      this.matches[index][e] = true
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (!this.matches[index][e]) {
    if (this.nodir) {
      var c = this.cache[this._makeAbs(e)]
      if (c === 'DIR' || Array.isArray(c))
        return
    }

    this.matches[index][e] = true
    if (this.stat || this.mark)
      this._stat(this._makeAbs(e))
  }
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    // lstat failed, doesn't exist
    return null
  }

  var isSym = lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs).sort(alphasort))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === "/")
        e = abs + e
      else
        e = abs + "/" + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case "ENOTDIR": // totally normal. means it *does* exist.
      this.cache[f] = 'FILE'
      break

    case "ENOENT": // not terribly unusual
    case "ELOOP":
    case "ENAMETOOLONG":
    case "UNKNOWN":
      this.cache[f] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[f] = false
      if (this.strict) throw er
      if (!this.silent) console.error("glob error", er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === "." && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    if (prefix.charAt(0) === "/") {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
    }
  }

  if (process.platform === "win32")
    prefix = prefix.replace(/\\/g, "/")

  // Mark this as a match
  this.matches[index][prefix] = true
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = f
  if (f.charAt(0) === "/")
    abs = path.join(this.root, f)
  else if (this.changedCwd)
    abs = path.resolve(this.cwd, f)


  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, f)) {
    var c = this.cache[f]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but not how we need it
    if (abs.slice(-1) === "/" && c !== 'DIR')
      return false

    return c
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    try {
      stat = fs.statSync(abs)
    } catch (er) {
      return false
    }
  }

  this.statCache[abs] = stat

  if (abs.slice(-1) === "/" && !stat.isDirectory())
    return false

  var c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[f] = this.cache[f] || c
  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

},{"./common.js":"/home/vadzim/v/work/nerojs/node_modules/glob/common.js","./glob.js":"/home/vadzim/v/work/nerojs/node_modules/glob/glob.js","assert":false,"fs":false,"minimatch":"/home/vadzim/v/work/nerojs/node_modules/glob/node_modules/minimatch/minimatch.js","path":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/http-status/lib/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
module.exports = {
  100: 'Continue',
  101: 'Switching Protocols',
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  307: 'Temporary Redirect',
  400: 'Bad Request',
  401: 'Unauthorized',
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Time-out',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Request Entity Too Large',
  414: 'Request-URI Too Large',
  415: 'Unsupported Media Type',
  416: 'Requested Range not Satisfiable',
  417: 'Expectation Failed',
  422: 'Unprocessable Entity',
  429: 'Too Many Requests',
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Time-out',
  505: 'HTTP Version not Supported',
  CONTINUE: 100,
  SWITCHING_PROTOCOLS: 101,
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NON_AUTHORITATIVE_INFORMATION: 203,
  NO_CONTENT: 204,
  RESET_CONTENT: 205,
  PARTIAL_CONTENT: 206,
  MULTIPLE_CHOICES: 300,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  USE_PROXY: 305,
  TEMPORARY_REDIRECT: 307,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  REQUEST_ENTITY_TOO_LARGE: 413,
  REQUEST_URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  REQUESTED_RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,
  UNPROCESSABLE_ENTITY: 422,
  TOO_MANY_REQUESTS: 429,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505
};

},{}],"/home/vadzim/v/work/nerojs/node_modules/immutable/dist/immutable.js":[function(require,module,exports){
/**
 *  Copyright (c) 2014, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */
function universalModule() {
  var $Object = Object;

function createClass(ctor, methods, staticMethods, superClass) {
  var proto;
  if (superClass) {
    var superProto = superClass.prototype;
    proto = $Object.create(superProto);
  } else {
    proto = ctor.prototype;
  }
  $Object.keys(methods).forEach(function (key) {
    proto[key] = methods[key];
  });
  $Object.keys(staticMethods).forEach(function (key) {
    ctor[key] = staticMethods[key];
  });
  proto.constructor = ctor;
  ctor.prototype = proto;
  return ctor;
}

function superCall(self, proto, name, args) {
  return $Object.getPrototypeOf(proto)[name].apply(self, args);
}

function defaultSuperCall(self, proto, args) {
  superCall(self, proto, 'constructor', args);
}

var $traceurRuntime = {};
$traceurRuntime.createClass = createClass;
$traceurRuntime.superCall = superCall;
$traceurRuntime.defaultSuperCall = defaultSuperCall;
"use strict";
function is(first, second) {
  if (first === second) {
    return first !== 0 || second !== 0 || 1 / first === 1 / second;
  }
  if (first !== first) {
    return second !== second;
  }
  if (first && typeof first.equals === 'function') {
    return first.equals(second);
  }
  return false;
}
var DELETE = 'delete';
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
var CHANGE_LENGTH = {value: false};
var DID_ALTER = {value: false};
function MakeRef(ref) {
  ref.value = false;
  return ref;
}
function SetRef(ref) {
  ref && (ref.value = true);
}
function OwnerID() {}
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}
function invariant(condition, error) {
  if (!condition)
    throw new Error(error);
}
function hash(o) {
  if (!o) {
    return 0;
  }
  if (o === true) {
    return 1;
  }
  var type = typeof o;
  if (type === 'number') {
    if ((o | 0) === o) {
      return o & HASH_MAX_VAL;
    }
    o = '' + o;
    type = 'string';
  }
  if (type === 'string') {
    return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
  }
  if (o.hashCode) {
    return hash(typeof o.hashCode === 'function' ? o.hashCode() : o.hashCode);
  }
  return hashJSObj(o);
}
function cachedHashString(string) {
  var hash = stringHashCache[string];
  if (hash == null) {
    hash = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hash;
  }
  return hash;
}
function hashString(string) {
  var hash = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hash = (31 * hash + string.charCodeAt(ii)) & HASH_MAX_VAL;
  }
  return hash;
}
function hashJSObj(obj) {
  var hash = weakMap && weakMap.get(obj);
  if (hash)
    return hash;
  hash = obj[UID_HASH_KEY];
  if (hash)
    return hash;
  if (!canDefineProperty) {
    hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hash)
      return hash;
    hash = getIENodeHash(obj);
    if (hash)
      return hash;
  }
  if (Object.isExtensible && !Object.isExtensible(obj)) {
    throw new Error('Non-extensible objects are not allowed as keys.');
  }
  hash = ++objHashUID & HASH_MAX_VAL;
  if (weakMap) {
    weakMap.set(obj, hash);
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      'enumerable': false,
      'configurable': false,
      'writable': false,
      'value': hash
    });
  } else if (obj.propertyIsEnumerable && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
  } else if (obj.nodeType) {
    obj[UID_HASH_KEY] = hash;
  } else {
    throw new Error('Unable to set a non-enumerable property on object.');
  }
  return hash;
}
var canDefineProperty = (function() {
  try {
    Object.defineProperty({}, 'x', {});
    return true;
  } catch (e) {
    return false;
  }
}());
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
var weakMap = typeof WeakMap === 'function' && new WeakMap();
var HASH_MAX_VAL = 0x7FFFFFFF;
var objHashUID = 0;
var UID_HASH_KEY = '__immutablehash__';
if (typeof Symbol === 'function') {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
var Iterator = function Iterator(next) {
  this.next = next;
};
($traceurRuntime.createClass)(Iterator, {toString: function() {
    return '[Iterator]';
  }}, {});
var IteratorPrototype = Iterator.prototype;
IteratorPrototype.inspect = IteratorPrototype.toSource = function() {
  return this.toString();
};
IteratorPrototype[ITERATOR_SYMBOL] = function() {
  return this;
};
function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
    value: value,
    done: false
  });
  return iteratorResult;
}
function iteratorDone() {
  return {
    value: undefined,
    done: true
  };
}
function isIterable(maybeIterable) {
  return !!_iteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === 'function';
}
function getIterator(iterable) {
  var iteratorFn = _iteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function _iteratorFn(iterable) {
  var iteratorFn = iterable && ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}
var Sequence = function Sequence(value) {
  return $Sequence.from(arguments.length === 1 ? value : Array.prototype.slice.call(arguments));
};
var $Sequence = Sequence;
($traceurRuntime.createClass)(Sequence, {
  toArray: function() {
    assertNotInfinite(this.length);
    var array = new Array(this.length || 0);
    this.valueSeq().__iterate((function(v, i) {
      array[i] = v;
    }));
    return array;
  },
  toJS: function() {
    return this.map((function(value) {
      return value && typeof value.toJS === 'function' ? value.toJS() : value;
    })).__toJS();
  },
  toMap: function() {
    assertNotInfinite(this.length);
    return Map.from(this);
  },
  toObject: function() {
    assertNotInfinite(this.length);
    var object = {};
    this.__iterate((function(v, k) {
      object[k] = v;
    }));
    return object;
  },
  toOrderedMap: function() {
    assertNotInfinite(this.length);
    return OrderedMap.from(this);
  },
  toSet: function() {
    assertNotInfinite(this.length);
    return Set.from(this);
  },
  toStack: function() {
    assertNotInfinite(this.length);
    return Stack.from(this);
  },
  toVector: function() {
    assertNotInfinite(this.length);
    return Vector.from(this);
  },
  toString: function() {
    return this.__toString('Seq {', '}');
  },
  __toString: function(head, tail) {
    if (this.length === 0) {
      return head + tail;
    }
    return head + ' ' + this.map(this.__toStringMapper).join(', ') + ' ' + tail;
  },
  __toStringMapper: function(v, k) {
    return k + ': ' + quoteString(v);
  },
  concat: function() {
    for (var values = [],
        $__2 = 0; $__2 < arguments.length; $__2++)
      values[$__2] = arguments[$__2];
    return concatFactory(this, values, true);
  },
  contains: function(searchValue) {
    return this.find((function(value) {
      return is(value, searchValue);
    }), null, NOT_SET) !== NOT_SET;
  },
  entries: function() {
    return this.__iterator(ITERATE_ENTRIES);
  },
  every: function(predicate, context) {
    var returnValue = true;
    this.__iterate((function(v, k, c) {
      if (!predicate.call(context, v, k, c)) {
        returnValue = false;
        return false;
      }
    }));
    return returnValue;
  },
  filter: function(predicate, context) {
    return filterFactory(this, predicate, context, true);
  },
  find: function(predicate, context, notSetValue) {
    var foundValue = notSetValue;
    this.__iterate((function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        foundValue = v;
        return false;
      }
    }));
    return foundValue;
  },
  forEach: function(sideEffect, context) {
    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  },
  join: function(separator) {
    separator = separator !== undefined ? '' + separator : ',';
    var joined = '';
    var isFirst = true;
    this.__iterate((function(v) {
      isFirst ? (isFirst = false) : (joined += separator);
      joined += v != null ? v : '';
    }));
    return joined;
  },
  keys: function() {
    return this.__iterator(ITERATE_KEYS);
  },
  map: function(mapper, context) {
    return mapFactory(this, mapper, context);
  },
  reduce: function(reducer, initialReduction, context) {
    var reduction;
    var useFirst;
    if (arguments.length < 2) {
      useFirst = true;
    } else {
      reduction = initialReduction;
    }
    this.__iterate((function(v, k, c) {
      if (useFirst) {
        useFirst = false;
        reduction = v;
      } else {
        reduction = reducer.call(context, reduction, v, k, c);
      }
    }));
    return reduction;
  },
  reduceRight: function(reducer, initialReduction, context) {
    var reversed = this.toKeyedSeq().reverse();
    return reversed.reduce.apply(reversed, arguments);
  },
  reverse: function() {
    return reverseFactory(this, true);
  },
  slice: function(begin, end) {
    if (wholeSlice(begin, end, this.length)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.length);
    var resolvedEnd = resolveEnd(end, this.length);
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return this.cacheResult().slice(begin, end);
    }
    var skipped = resolvedBegin === 0 ? this : this.skip(resolvedBegin);
    return resolvedEnd == null || resolvedEnd === this.length ? skipped : skipped.take(resolvedEnd - resolvedBegin);
  },
  some: function(predicate, context) {
    return !this.every(not(predicate), context);
  },
  sort: function(comparator) {
    return this.sortBy(valueMapper, comparator);
  },
  values: function() {
    return this.__iterator(ITERATE_VALUES);
  },
  butLast: function() {
    return this.slice(0, -1);
  },
  count: function(predicate, context) {
    if (!predicate) {
      if (this.length == null) {
        this.length = this.__iterate(returnTrue);
      }
      return this.length;
    }
    return this.filter(predicate, context).count();
  },
  countBy: function(grouper, context) {
    var $__0 = this;
    var groupMap = {};
    var groups = [];
    this.__iterate((function(v, k) {
      var g = grouper.call(context, v, k, $__0);
      var h = hash(g);
      if (!groupMap.hasOwnProperty(h)) {
        groupMap[h] = groups.length;
        groups.push([g, 1]);
      } else {
        groups[groupMap[h]][1]++;
      }
    }));
    return $Sequence(groups).fromEntrySeq();
  },
  equals: function(other) {
    if (this === other) {
      return true;
    }
    if (!other || typeof other.equals !== 'function') {
      return false;
    }
    if (this.length != null && other.length != null) {
      if (this.length !== other.length) {
        return false;
      }
      if (this.length === 0 && other.length === 0) {
        return true;
      }
    }
    if (this.__hash != null && other.__hash != null && this.__hash !== other.__hash) {
      return false;
    }
    return this.__deepEquals(other);
  },
  __deepEquals: function(other) {
    var entries = this.entries();
    return typeof other.every === 'function' && other.every((function(v, k) {
      var entry = entries.next().value;
      return entry && is(entry[0], k) && is(entry[1], v);
    })) && entries.next().done;
  },
  entrySeq: function() {
    var sequence = this;
    if (sequence._cache) {
      return $Sequence(sequence._cache);
    }
    var entriesSequence = sequence.toKeyedSeq().map(entryMapper).valueSeq();
    entriesSequence.fromEntrySeq = (function() {
      return sequence;
    });
    return entriesSequence;
  },
  filterNot: function(predicate, context) {
    return this.filter(not(predicate), context);
  },
  findKey: function(predicate, context) {
    var foundKey;
    this.__iterate((function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        foundKey = k;
        return false;
      }
    }));
    return foundKey;
  },
  findLast: function(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
  },
  findLastKey: function(predicate, context) {
    return this.toKeyedSeq().reverse().findKey(predicate, context);
  },
  first: function() {
    return this.find(returnTrue);
  },
  flatMap: function(mapper, context) {
    return this.map((function(v, k, c) {
      return $Sequence(mapper.call(context, v, k, c));
    })).flatten(true);
  },
  flatten: function(depth) {
    return flattenFactory(this, depth, true);
  },
  flip: function() {
    return flipFactory(this);
  },
  get: function(searchKey, notSetValue) {
    return this.find((function(_, key) {
      return is(key, searchKey);
    }), null, notSetValue);
  },
  getIn: function(searchKeyPath, notSetValue) {
    var nested = this;
    if (searchKeyPath) {
      for (var ii = 0; ii < searchKeyPath.length; ii++) {
        nested = nested && nested.get ? nested.get(searchKeyPath[ii], NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
    }
    return nested;
  },
  groupBy: function(grouper, context) {
    return groupByFactory(this, grouper, context, true);
  },
  has: function(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },
  keySeq: function() {
    return this.flip().valueSeq();
  },
  last: function() {
    return this.reverse().first();
  },
  mapEntries: function(mapper, context) {
    var $__0 = this;
    return this.entrySeq().map((function(entry, index) {
      return mapper.call(context, entry, index, $__0);
    })).fromEntrySeq();
  },
  mapKeys: function(mapper, context) {
    var $__0 = this;
    return this.flip().map((function(k, v) {
      return mapper.call(context, k, v, $__0);
    })).flip();
  },
  max: function(comparator) {
    return this.maxBy(valueMapper, comparator);
  },
  maxBy: function(mapper, comparator) {
    comparator = comparator || defaultComparator;
    var seq = this;
    var maxEntry = seq.entrySeq().reduce((function(max, next) {
      return comparator(mapper(next[1], next[0], seq), mapper(max[1], max[0], seq)) > 0 ? next : max;
    }));
    return maxEntry && maxEntry[1];
  },
  min: function(comparator) {
    return this.minBy(valueMapper, comparator);
  },
  minBy: function(mapper, comparator) {
    comparator = comparator || defaultComparator;
    var seq = this;
    var minEntry = seq.entrySeq().reduce((function(min, next) {
      return comparator(mapper(next[1], next[0], seq), mapper(min[1], min[0], seq)) < 0 ? next : min;
    }));
    return minEntry && minEntry[1];
  },
  rest: function() {
    return this.slice(1);
  },
  skip: function(amount) {
    return skipFactory(this, amount, true);
  },
  skipLast: function(amount) {
    return this.reverse().skip(amount).reverse();
  },
  skipWhile: function(predicate, context) {
    return skipWhileFactory(this, predicate, context, true);
  },
  skipUntil: function(predicate, context) {
    return this.skipWhile(not(predicate), context);
  },
  sortBy: function(mapper, comparator) {
    comparator = comparator || defaultComparator;
    var seq = this;
    return $Sequence(seq.entrySeq().entrySeq().toArray().sort((function(a, b) {
      return comparator(mapper(a[1][1], a[1][0], seq), mapper(b[1][1], b[1][0], seq)) || a[0] - b[0];
    }))).fromEntrySeq().valueSeq().fromEntrySeq();
  },
  take: function(amount) {
    return takeFactory(this, amount);
  },
  takeLast: function(amount) {
    return this.reverse().take(amount).reverse();
  },
  takeWhile: function(predicate, context) {
    return takeWhileFactory(this, predicate, context);
  },
  takeUntil: function(predicate, context) {
    return this.takeWhile(not(predicate), context);
  },
  toKeyedSeq: function() {
    return this;
  },
  valueSeq: function() {
    return new ValuesSequence(this);
  },
  cacheResult: function() {
    if (!this._cache && this.__iterateUncached) {
      assertNotInfinite(this.length);
      this._cache = this.entrySeq().toArray();
      if (this.length == null) {
        this.length = this._cache.length;
      }
    }
    return this;
  },
  hashCode: function() {
    return this.__hash || (this.__hash = this.length === Infinity ? 0 : this.reduce((function(h, v, k) {
      return (h + (hash(v) ^ (v === k ? 0 : hash(k)))) & HASH_MAX_VAL;
    }), 0));
  },
  __makeSequence: function() {
    return Object.create(SequencePrototype);
  },
  __iterate: function(fn, reverse) {
    return iterate(this, fn, reverse, true);
  },
  __iterator: function(type, reverse) {
    return iterator(this, type, reverse, true);
  }
}, {from: function(value) {
    if (value instanceof $Sequence) {
      return value;
    }
    if (!Array.isArray(value)) {
      if (isIterator(value)) {
        return new IteratorSequence(value);
      }
      if (isIterable(value)) {
        return new IterableSequence(value);
      }
      if (value && value.constructor === Object) {
        return new ObjectSequence(value);
      }
      value = [value];
    }
    return new ArraySequence(value);
  }});
var SequencePrototype = Sequence.prototype;
SequencePrototype[ITERATOR_SYMBOL] = SequencePrototype.entries;
SequencePrototype.toJSON = SequencePrototype.toJS;
SequencePrototype.__toJS = SequencePrototype.toObject;
SequencePrototype.inspect = SequencePrototype.toSource = function() {
  return this.toString();
};
SequencePrototype.chain = SequencePrototype.flatMap;
var IndexedSequence = function IndexedSequence() {
  $traceurRuntime.defaultSuperCall(this, $IndexedSequence.prototype, arguments);
};
var $IndexedSequence = IndexedSequence;
($traceurRuntime.createClass)(IndexedSequence, {
  toString: function() {
    return this.__toString('Seq [', ']');
  },
  concat: function() {
    for (var values = [],
        $__3 = 0; $__3 < arguments.length; $__3++)
      values[$__3] = arguments[$__3];
    return concatFactory(this, values, false);
  },
  filter: function(predicate, context) {
    return filterFactory(this, predicate, context, false);
  },
  findIndex: function(predicate, context) {
    var key = this.findKey(predicate, context);
    return key == null ? -1 : key;
  },
  indexOf: function(searchValue) {
    return this.findIndex((function(value) {
      return is(value, searchValue);
    }));
  },
  lastIndexOf: function(searchValue) {
    return this.toKeyedSeq().reverse().indexOf(searchValue);
  },
  reverse: function() {
    return reverseFactory(this, false);
  },
  splice: function(index, removeNum) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum | 0, 0);
    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
      return this;
    }
    index = resolveBegin(index, this.length);
    var spliced = this.slice(0, index);
    return numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum));
  },
  findLastIndex: function(predicate, context) {
    return this.toKeyedSeq().reverse().findIndex(predicate, context);
  },
  first: function() {
    return this.get(0);
  },
  flatten: function(depth) {
    return flattenFactory(this, depth, false);
  },
  flip: function() {
    return flipFactory(this.toKeyedSeq());
  },
  fromEntrySeq: function() {
    return new FromEntriesSequence(this);
  },
  get: function(index, notSetValue) {
    index = wrapIndex(this, index);
    return (index < 0 || (this.length === Infinity || (this.length != null && index > this.length))) ? notSetValue : this.find((function(_, key) {
      return key === index;
    }), null, notSetValue);
  },
  groupBy: function(grouper, context) {
    return groupByFactory(this, grouper, context, false);
  },
  has: function(index) {
    index = wrapIndex(this, index);
    return index >= 0 && (this.length != null ? this.length === Infinity || index < this.length : this.indexOf(index) !== -1);
  },
  interpose: function(separator) {
    return interposeFactory(this, separator);
  },
  last: function() {
    return this.get(-1);
  },
  skip: function(amount) {
    var seq = this;
    var skipSeq = skipFactory(seq, amount, false);
    if (skipSeq !== seq) {
      skipSeq.get = function(index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 ? seq.get(index + amount, notSetValue) : notSetValue;
      };
    }
    return skipSeq;
  },
  skipWhile: function(predicate, context) {
    return skipWhileFactory(this, predicate, context, false);
  },
  sortBy: function(mapper, comparator) {
    comparator = comparator || defaultComparator;
    var seq = this;
    return Sequence(this.entrySeq().toArray().sort((function(a, b) {
      return comparator(mapper(a[1], a[0], seq), mapper(b[1], b[0], seq)) || a[0] - b[0];
    }))).fromEntrySeq().valueSeq();
  },
  take: function(amount) {
    var seq = this;
    var takeSeq = takeFactory(seq, amount);
    if (takeSeq !== seq) {
      takeSeq.get = function(index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < amount ? seq.get(index, notSetValue) : notSetValue;
      };
    }
    return takeSeq;
  },
  toKeyedSeq: function() {
    return new KeyedIndexedSequence(this);
  },
  valueSeq: function() {
    return this;
  },
  __makeSequence: function() {
    return Object.create(IndexedSequencePrototype);
  },
  __iterate: function(fn, reverse) {
    return iterate(this, fn, reverse, false);
  },
  __iterator: function(type, reverse) {
    return iterator(this, type, reverse, false);
  }
}, {}, Sequence);
var IndexedSequencePrototype = IndexedSequence.prototype;
IndexedSequencePrototype[ITERATOR_SYMBOL] = IndexedSequencePrototype.values;
IndexedSequencePrototype.__toJS = IndexedSequencePrototype.toArray;
IndexedSequencePrototype.__toStringMapper = quoteString;
var IteratorSequence = function IteratorSequence(iterator) {
  this._iterator = iterator;
  this._iteratorCache = [];
};
($traceurRuntime.createClass)(IteratorSequence, {
  __iterateUncached: function(fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;
    while (iterations < cache.length) {
      if (fn(cache[iterations], iterations++, this) === false) {
        return iterations;
      }
    }
    var step;
    while (!(step = iterator.next()).done) {
      var val = step.value;
      cache[iterations] = val;
      if (fn(val, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  },
  __iteratorUncached: function(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;
    return new Iterator((function() {
      if (iterations >= cache.length) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        cache[iterations] = step.value;
      }
      return iteratorValue(type, iterations, cache[iterations++]);
    }));
  }
}, {}, IndexedSequence);
var IterableSequence = function IterableSequence(iterable) {
  this._iterable = iterable;
  this.length = iterable.length || iterable.size;
};
($traceurRuntime.createClass)(IterableSequence, {
  __iterateUncached: function(fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterable = this._iterable;
    var iterator = getIterator(iterable);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }
    return iterations;
  },
  __iteratorUncached: function(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterable = this._iterable;
    var iterator = getIterator(iterable);
    if (!isIterator(iterator)) {
      return new Iterator((function() {
        return iteratorDone();
      }));
    }
    var iterations = 0;
    return new Iterator((function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    }));
  }
}, {}, IndexedSequence);
var ObjectSequence = function ObjectSequence(object) {
  var keys = Object.keys(object);
  this._object = object;
  this._keys = keys;
  this.length = keys.length;
};
($traceurRuntime.createClass)(ObjectSequence, {
  get: function(key, notSetValue) {
    if (notSetValue !== undefined && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  },
  has: function(key) {
    return this._object.hasOwnProperty(key);
  },
  __iterate: function(fn, reverse) {
    var object = this._object;
    var keys = this._keys;
    var maxIndex = keys.length - 1;
    for (var ii = 0; ii <= maxIndex; ii++) {
      var key = keys[reverse ? maxIndex - ii : ii];
      if (fn(object[key], key, this) === false) {
        return ii + 1;
      }
    }
    return ii;
  },
  __iterator: function(type, reverse) {
    var object = this._object;
    var keys = this._keys;
    var maxIndex = keys.length - 1;
    var ii = 0;
    return new Iterator((function() {
      var key = keys[reverse ? maxIndex - ii : ii];
      return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
    }));
  }
}, {}, Sequence);
var ArraySequence = function ArraySequence(array) {
  this._array = array;
  this.length = array.length;
};
($traceurRuntime.createClass)(ArraySequence, {
  get: function(index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  },
  __iterate: function(fn, reverse) {
    var array = this._array;
    var maxIndex = array.length - 1;
    for (var ii = 0; ii <= maxIndex; ii++) {
      if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
        return ii + 1;
      }
    }
    return ii;
  },
  __iterator: function(type, reverse) {
    var array = this._array;
    var maxIndex = array.length - 1;
    var ii = 0;
    return new Iterator((function() {
      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
    }));
  }
}, {}, IndexedSequence);
function ensureLength(indexedSeq) {
  if (indexedSeq.length == null) {
    indexedSeq.cacheResult();
  }
  invariant(indexedSeq.length < Infinity, 'Cannot reverse infinite range.');
  return indexedSeq.length;
}
function wholeSlice(begin, end, length) {
  return (begin === 0 || (length != null && begin <= -length)) && (end == null || (length != null && end >= length));
}
function resolveBegin(begin, length) {
  return resolveIndex(begin, length, 0);
}
function resolveEnd(end, length) {
  return resolveIndex(end, length, length);
}
function resolveIndex(index, length, defaultIndex) {
  return index == null ? defaultIndex : index < 0 ? Math.max(0, length + index) : length == null ? index : Math.min(length, index);
}
function valueMapper(v) {
  return v;
}
function entryMapper(v, k) {
  return [k, v];
}
function returnTrue() {
  return true;
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function quoteString(value) {
  return typeof value === 'string' ? JSON.stringify(value) : value;
}
function defaultComparator(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function wrapIndex(seq, index) {
  if (index < 0) {
    if (seq.length == null) {
      seq.cacheResult();
    }
    return seq.length + index;
  }
  return index;
}
function assertNotInfinite(length) {
  invariant(length !== Infinity, 'Cannot perform this action with an infinite sequence.');
}
function iterate(sequence, fn, reverse, useKeys) {
  var cache = sequence._cache;
  if (cache) {
    var maxIndex = cache.length - 1;
    for (var ii = 0; ii <= maxIndex; ii++) {
      var entry = cache[reverse ? maxIndex - ii : ii];
      if (fn(entry[1], useKeys ? entry[0] : ii, sequence) === false) {
        return ii + 1;
      }
    }
    return ii;
  }
  return sequence.__iterateUncached(fn, reverse);
}
function iterator(sequence, type, reverse, useKeys) {
  var cache = sequence._cache;
  if (cache) {
    var maxIndex = cache.length - 1;
    var ii = 0;
    return new Iterator((function() {
      var entry = cache[reverse ? maxIndex - ii : ii];
      return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
    }));
  }
  return sequence.__iteratorUncached(type, reverse);
}
var ValuesSequence = function ValuesSequence(seq) {
  this._seq = seq;
  this.length = seq.length;
};
($traceurRuntime.createClass)(ValuesSequence, {
  contains: function(value) {
    return this._seq.contains(value);
  },
  cacheResult: function() {
    this._seq.cacheResult();
    this.length = this._seq.length;
    return this;
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    var iterations = 0;
    return this._seq.__iterate((function(v) {
      return fn(v, iterations++, $__0);
    }), reverse);
  },
  __iterator: function(type, reverse) {
    var iterator = this._seq.__iterator(ITERATE_VALUES, reverse);
    var iterations = 0;
    return new Iterator((function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value, step);
    }));
  }
}, {}, IndexedSequence);
var KeyedIndexedSequence = function KeyedIndexedSequence(indexedSeq) {
  this._seq = indexedSeq;
  this.length = indexedSeq.length;
};
($traceurRuntime.createClass)(KeyedIndexedSequence, {
  get: function(key, notSetValue) {
    return this._seq.get(key, notSetValue);
  },
  has: function(key) {
    return this._seq.has(key);
  },
  valueSeq: function() {
    return this._seq;
  },
  reverse: function() {
    var $__0 = this;
    var reversedSequence = reverseFactory(this, true);
    reversedSequence.valueSeq = (function() {
      return $__0._seq.reverse();
    });
    return reversedSequence;
  },
  map: function(mapper, context) {
    var $__0 = this;
    var mappedSequence = mapFactory(this, mapper, context);
    mappedSequence.valueSeq = (function() {
      return $__0._seq.map(mapper, context);
    });
    return mappedSequence;
  },
  cacheResult: function() {
    this._seq.cacheResult();
    this.length = this._seq.length;
    return this;
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    var ii = reverse ? ensureLength(this) : 0;
    return this._seq.__iterate((function(v) {
      return fn(v, reverse ? --ii : ii++, $__0);
    }), reverse);
  },
  __iterator: function(type, reverse) {
    var iterator = this._seq.__iterator(ITERATE_VALUES, reverse);
    var ii = reverse ? ensureLength(this) : 0;
    return new Iterator((function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
    }));
  }
}, {}, Sequence);
var FromEntriesSequence = function FromEntriesSequence(entriesSeq) {
  this._seq = entriesSeq;
  this.length = entriesSeq.length;
};
($traceurRuntime.createClass)(FromEntriesSequence, {
  entrySeq: function() {
    return this._seq;
  },
  cacheResult: function() {
    this._seq.cacheResult();
    this.length = this._seq.length;
    return this;
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    return this._seq.__iterate((function(entry) {
      return entry && fn(entry[1], entry[0], $__0);
    }), reverse);
  },
  __iterator: function(type, reverse) {
    var iterator = this._seq.__iterator(ITERATE_VALUES, reverse);
    return new Iterator((function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        if (entry) {
          return type === ITERATE_ENTRIES ? step : iteratorValue(type, entry[0], entry[1], step);
        }
      }
    }));
  }
}, {}, Sequence);
function flipFactory(sequence) {
  var flipSequence = sequence.__makeSequence();
  flipSequence.length = sequence.length;
  flipSequence.flip = (function() {
    return sequence;
  });
  flipSequence.reverse = function() {
    var reversedSequence = sequence.reverse.apply(this);
    reversedSequence.flip = (function() {
      return sequence.reverse();
    });
    return reversedSequence;
  };
  flipSequence.has = (function(key) {
    return sequence.contains(key);
  });
  flipSequence.contains = (function(key) {
    return sequence.has(key);
  });
  flipSequence.__iterateUncached = function(fn, reverse) {
    var $__0 = this;
    return sequence.__iterate((function(v, k) {
      return fn(k, v, $__0) !== false;
    }), reverse);
  };
  flipSequence.__iteratorUncached = function(type, reverse) {
    if (type === ITERATE_ENTRIES) {
      var iterator = sequence.__iterator(type, reverse);
      return new Iterator((function() {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      }));
    }
    return sequence.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
  };
  return flipSequence;
}
function mapFactory(sequence, mapper, context) {
  var mappedSequence = sequence.__makeSequence();
  mappedSequence.length = sequence.length;
  mappedSequence.has = (function(key) {
    return sequence.has(key);
  });
  mappedSequence.get = (function(key, notSetValue) {
    var v = sequence.get(key, NOT_SET);
    return v === NOT_SET ? notSetValue : mapper.call(context, v, key, sequence);
  });
  mappedSequence.__iterateUncached = function(fn, reverse) {
    var $__0 = this;
    return sequence.__iterate((function(v, k, c) {
      return fn(mapper.call(context, v, k, c), k, $__0) !== false;
    }), reverse);
  };
  mappedSequence.__iteratorUncached = function(type, reverse) {
    var iterator = sequence.__iterator(ITERATE_ENTRIES, reverse);
    return new Iterator((function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(type, key, mapper.call(context, entry[1], key, sequence), step);
    }));
  };
  return mappedSequence;
}
function reverseFactory(sequence, useKeys) {
  var reversedSequence = sequence.__makeSequence();
  reversedSequence.length = sequence.length;
  reversedSequence.reverse = (function() {
    return sequence;
  });
  reversedSequence.flip = function() {
    var flipSequence = sequence.flip.apply(this);
    flipSequence.reverse = (function() {
      return sequence.flip();
    });
    return flipSequence;
  };
  reversedSequence.get = (function(key, notSetValue) {
    return sequence.get(useKeys ? key : -1 - key, notSetValue);
  });
  reversedSequence.has = (function(key) {
    return sequence.has(useKeys ? key : -1 - key);
  });
  reversedSequence.contains = (function(value) {
    return sequence.contains(value);
  });
  reversedSequence.cacheResult = function() {
    sequence.cacheResult();
    this.length = sequence.length;
    return this;
  };
  reversedSequence.__iterate = function(fn, reverse) {
    var $__0 = this;
    return sequence.__iterate((function(v, k) {
      return fn(v, k, $__0);
    }), !reverse);
  };
  reversedSequence.__iterator = (function(type, reverse) {
    return sequence.__iterator(type, !reverse);
  });
  return reversedSequence;
}
function filterFactory(sequence, predicate, context, useKeys) {
  var filterSequence = sequence.__makeSequence();
  if (useKeys) {
    filterSequence.has = (function(key) {
      var v = sequence.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, sequence);
    });
    filterSequence.get = (function(key, notSetValue) {
      var v = sequence.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, sequence) ? v : notSetValue;
    });
  }
  filterSequence.__iterateUncached = function(fn, reverse) {
    var $__0 = this;
    var iterations = 0;
    sequence.__iterate((function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, $__0);
      }
    }), reverse);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse) {
    var iterator = sequence.__iterator(ITERATE_ENTRIES, reverse);
    var iterations = 0;
    return new Iterator((function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, sequence)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    }));
  };
  return filterSequence;
}
function groupByFactory(seq, grouper, context, useKeys) {
  var groupMap = {};
  var groups = [];
  seq.__iterate((function(v, k) {
    var g = grouper.call(context, v, k, seq);
    var h = hash(g);
    var e = useKeys ? [k, v] : v;
    if (!groupMap.hasOwnProperty(h)) {
      groupMap[h] = groups.length;
      groups.push([g, [e]]);
    } else {
      groups[groupMap[h]][1].push(e);
    }
  }));
  return Sequence(groups).fromEntrySeq().map(useKeys ? (function(group) {
    return Sequence(group).fromEntrySeq();
  }) : (function(group) {
    return Sequence(group);
  }));
}
function takeFactory(sequence, amount) {
  if (amount > sequence.length) {
    return sequence;
  }
  if (amount < 0) {
    amount = 0;
  }
  var takeSequence = sequence.__makeSequence();
  takeSequence.length = sequence.length && Math.min(sequence.length, amount);
  takeSequence.__iterateUncached = function(fn, reverse) {
    var $__0 = this;
    if (amount === 0) {
      return 0;
    }
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    sequence.__iterate((function(v, k) {
      return ++iterations && fn(v, k, $__0) !== false && iterations < amount;
    }));
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = amount && sequence.__iterator(type, reverse);
    var iterations = 0;
    return new Iterator((function() {
      if (iterations++ > amount) {
        return iteratorDone();
      }
      return iterator.next();
    }));
  };
  return takeSequence;
}
function takeWhileFactory(sequence, predicate, context) {
  var takeSequence = sequence.__makeSequence();
  takeSequence.__iterateUncached = function(fn, reverse) {
    var $__0 = this;
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    sequence.__iterate((function(v, k, c) {
      return predicate.call(context, v, k, c) && ++iterations && fn(v, k, $__0);
    }));
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse) {
    var $__0 = this;
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = sequence.__iterator(ITERATE_ENTRIES, reverse);
    var iterating = true;
    return new Iterator((function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, $__0)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    }));
  };
  return takeSequence;
}
function skipFactory(sequence, amount, useKeys) {
  if (amount <= 0) {
    return sequence;
  }
  var skipSequence = sequence.__makeSequence();
  skipSequence.length = sequence.length && Math.max(0, sequence.length - amount);
  skipSequence.__iterateUncached = function(fn, reverse) {
    var $__0 = this;
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    sequence.__iterate((function(v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < amount))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, $__0);
      }
    }));
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = amount && sequence.__iterator(type, reverse);
    var skipped = 0;
    var iterations = 0;
    return new Iterator((function() {
      while (skipped < amount) {
        skipped++;
        iterator.next();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES) {
        return step;
      } else if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations++, null, step);
      } else {
        return iteratorValue(type, iterations++, step.value[1], step);
      }
    }));
  };
  return skipSequence;
}
function skipWhileFactory(sequence, predicate, context, useKeys) {
  var skipSequence = sequence.__makeSequence();
  skipSequence.__iterateUncached = function(fn, reverse) {
    var $__0 = this;
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var isSkipping = true;
    var iterations = 0;
    sequence.__iterate((function(v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, $__0);
      }
    }));
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse) {
    var $__0 = this;
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = sequence.__iterator(ITERATE_ENTRIES, reverse);
    var skipping = true;
    var iterations = 0;
    return new Iterator((function() {
      var step,
          k,
          v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          } else if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, null, step);
          } else {
            return iteratorValue(type, iterations++, step.value[1], step);
          }
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, $__0));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    }));
  };
  return skipSequence;
}
function concatFactory(sequence, values, useKeys) {
  var sequences = [sequence].concat(values);
  var concatSequence = Sequence(sequences);
  if (useKeys) {
    concatSequence = concatSequence.toKeyedSeq();
  }
  concatSequence = concatSequence.flatMap(valueMapper);
  concatSequence.length = sequences.reduce((function(sum, seq) {
    if (sum !== undefined) {
      var len = Sequence(seq).length;
      if (len != null) {
        return sum + len;
      }
    }
  }), 0);
  return concatSequence;
}
function flattenFactory(sequence, depth, useKeys) {
  var flatSequence = sequence.__makeSequence();
  flatSequence.__iterateUncached = function(fn, reverse) {
    var iterations = 0;
    var stopped = false;
    function flatDeep(seq, currentDepth) {
      var $__0 = this;
      seq.__iterate((function(v, k) {
        if ((!depth || currentDepth < depth) && isFlattenable(v)) {
          flatDeep(v, currentDepth + 1);
        } else if (fn(v, useKeys ? k : iterations++, $__0) === false) {
          stopped = true;
        }
        return !stopped;
      }), reverse);
    }
    flatDeep(sequence, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse) {
    var iterator = sequence.__iterator(type, reverse);
    var stack = [];
    var iterations = 0;
    return new Iterator((function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isFlattenable(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    }));
  };
  return flatSequence;
}
function isFlattenable(maybeFlattenable) {
  return maybeFlattenable && typeof maybeFlattenable.flatten === 'function' && typeof maybeFlattenable.__iterate === 'function' && typeof maybeFlattenable.__iterator === 'function';
}
function interposeFactory(sequence, separator) {
  var interposedSequence = sequence.__makeSequence();
  interposedSequence.length = sequence.length && sequence.length * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse) {
    var $__0 = this;
    var iterations = 0;
    sequence.__iterate((function(v, k) {
      return (!iterations || fn(separator, iterations++, $__0) !== false) && fn(v, iterations++, $__0) !== false;
    }), reverse);
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse) {
    var iterator = sequence.__iterator(ITERATE_VALUES, reverse);
    var iterations = 0;
    var step;
    return new Iterator((function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    }));
  };
  return interposedSequence;
}
var Map = function Map(sequence) {
  var map = $Map.empty();
  return sequence ? sequence.constructor === $Map ? sequence : map.merge(sequence) : map;
};
var $Map = Map;
($traceurRuntime.createClass)(Map, {
  toString: function() {
    return this.__toString('Map {', '}');
  },
  get: function(k, notSetValue) {
    return this._root ? this._root.get(0, hash(k), k, notSetValue) : notSetValue;
  },
  set: function(k, v) {
    return updateMap(this, k, v);
  },
  setIn: function(keyPath, v) {
    invariant(keyPath.length > 0, 'Requires non-empty key path.');
    return this.updateIn(keyPath, (function() {
      return v;
    }));
  },
  remove: function(k) {
    return updateMap(this, k, NOT_SET);
  },
  removeIn: function(keyPath) {
    invariant(keyPath.length > 0, 'Requires non-empty key path.');
    return this.updateIn(keyPath, (function() {
      return NOT_SET;
    }));
  },
  update: function(k, notSetValue, updater) {
    return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
  },
  updateIn: function(keyPath, notSetValue, updater) {
    if (!updater) {
      updater = notSetValue;
      notSetValue = undefined;
    }
    return keyPath.length === 0 ? updater(this) : updateInDeepMap(this, keyPath, notSetValue, updater, 0);
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = 0;
      this._root = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return $Map.empty();
  },
  merge: function() {
    return mergeIntoMapWith(this, null, arguments);
  },
  mergeWith: function(merger) {
    for (var seqs = [],
        $__4 = 1; $__4 < arguments.length; $__4++)
      seqs[$__4 - 1] = arguments[$__4];
    return mergeIntoMapWith(this, merger, seqs);
  },
  mergeDeep: function() {
    return mergeIntoMapWith(this, deepMerger(null), arguments);
  },
  mergeDeepWith: function(merger) {
    for (var seqs = [],
        $__5 = 1; $__5 < arguments.length; $__5++)
      seqs[$__5 - 1] = arguments[$__5];
    return mergeIntoMapWith(this, deepMerger(merger), seqs);
  },
  cursor: function(maybeKeyPath, onChange) {
    var keyPath = arguments.length === 0 || typeof maybeKeyPath === 'function' && (onChange = maybeKeyPath) ? [] : Array.isArray(maybeKeyPath) ? maybeKeyPath : [maybeKeyPath];
    return makeCursor(this, keyPath, onChange);
  },
  withMutations: function(fn) {
    var mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  },
  asMutable: function() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  },
  asImmutable: function() {
    return this.__ensureOwner();
  },
  wasAltered: function() {
    return this.__altered;
  },
  __iterator: function(type, reverse) {
    return new MapIterator(this, type, reverse);
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    var iterations = 0;
    this._root && this._root.iterate((function(entry) {
      iterations++;
      return fn(entry[1], entry[0], $__0);
    }), reverse);
    return iterations;
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.length, this._root, ownerID, this.__hash);
  }
}, {empty: function() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }}, Sequence);
var MapPrototype = Map.prototype;
MapPrototype[DELETE] = MapPrototype.remove;
Map.from = Map;
var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};
var $BitmapIndexedNode = BitmapIndexedNode;
($traceurRuntime.createClass)(BitmapIndexedNode, {
  get: function(shift, hash, key, notSetValue) {
    var bit = (1 << ((shift === 0 ? hash : hash >>> shift) & MASK));
    var bitmap = this.bitmap;
    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, hash, key, notSetValue);
  },
  update: function(ownerID, shift, hash, key, value, didChangeLength, didAlter) {
    var hashFrag = (shift === 0 ? hash : hash >>> shift) & MASK;
    var bit = 1 << hashFrag;
    var bitmap = this.bitmap;
    var exists = (bitmap & bit) !== 0;
    if (!exists && value === NOT_SET) {
      return this;
    }
    var idx = popCount(bitmap & (bit - 1));
    var nodes = this.nodes;
    var node = exists ? nodes[idx] : null;
    var newNode = updateNode(node, ownerID, shift + SHIFT, hash, key, value, didChangeLength, didAlter);
    if (newNode === node) {
      return this;
    }
    if (!exists && newNode && nodes.length >= MAX_BITMAP_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, hashFrag, newNode);
    }
    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
      return nodes[idx ^ 1];
    }
    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }
    return new $BitmapIndexedNode(ownerID, newBitmap, newNodes);
  },
  iterate: function(fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0,
        maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      if (nodes[reverse ? maxIndex - ii : ii].iterate(fn, reverse) === false) {
        return false;
      }
    }
  }
}, {});
var ArrayNode = function ArrayNode(ownerID, count, nodes) {
  this.ownerID = ownerID;
  this.count = count;
  this.nodes = nodes;
};
var $ArrayNode = ArrayNode;
($traceurRuntime.createClass)(ArrayNode, {
  get: function(shift, hash, key, notSetValue) {
    var idx = (shift === 0 ? hash : hash >>> shift) & MASK;
    var node = this.nodes[idx];
    return node ? node.get(shift + SHIFT, hash, key, notSetValue) : notSetValue;
  },
  update: function(ownerID, shift, hash, key, value, didChangeLength, didAlter) {
    var idx = (shift === 0 ? hash : hash >>> shift) & MASK;
    var removed = value === NOT_SET;
    var nodes = this.nodes;
    var node = nodes[idx];
    if (removed && !node) {
      return this;
    }
    var newNode = updateNode(node, ownerID, shift + SHIFT, hash, key, value, didChangeLength, didAlter);
    if (newNode === node) {
      return this;
    }
    var newCount = this.count;
    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;
      if (newCount < MIN_ARRAY_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newNodes = setIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }
    return new $ArrayNode(ownerID, newCount, newNodes);
  },
  iterate: function(fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0,
        maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }
}, {});
var HashCollisionNode = function HashCollisionNode(ownerID, hash, entries) {
  this.ownerID = ownerID;
  this.hash = hash;
  this.entries = entries;
};
var $HashCollisionNode = HashCollisionNode;
($traceurRuntime.createClass)(HashCollisionNode, {
  get: function(shift, hash, key, notSetValue) {
    var entries = this.entries;
    for (var ii = 0,
        len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  },
  update: function(ownerID, shift, hash, key, value, didChangeLength, didAlter) {
    var removed = value === NOT_SET;
    if (hash !== this.hash) {
      if (removed) {
        return this;
      }
      SetRef(didAlter);
      SetRef(didChangeLength);
      return mergeIntoNode(this, ownerID, shift, hash, [key, value]);
    }
    var entries = this.entries;
    var idx = 0;
    for (var len = entries.length; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    var exists = idx < len;
    if (removed && !exists) {
      return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeLength);
    if (removed && len === 2) {
      return new ValueNode(ownerID, this.hash, entries[idx ^ 1]);
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new $HashCollisionNode(ownerID, this.hash, newEntries);
  },
  iterate: function(fn, reverse) {
    var entries = this.entries;
    for (var ii = 0,
        maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }
}, {});
var ValueNode = function ValueNode(ownerID, hash, entry) {
  this.ownerID = ownerID;
  this.hash = hash;
  this.entry = entry;
};
var $ValueNode = ValueNode;
($traceurRuntime.createClass)(ValueNode, {
  get: function(shift, hash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  },
  update: function(ownerID, shift, hash, key, value, didChangeLength, didAlter) {
    var removed = value === NOT_SET;
    var keyMatch = is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }
    SetRef(didAlter);
    if (removed) {
      SetRef(didChangeLength);
      return null;
    }
    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }
      return new $ValueNode(ownerID, hash, [key, value]);
    }
    SetRef(didChangeLength);
    return mergeIntoNode(this, ownerID, shift, hash, [key, value]);
  },
  iterate: function(fn) {
    return fn(this.entry);
  }
}, {});
var MapIterator = function MapIterator(map, type, reverse) {
  this._type = type;
  this._reverse = reverse;
  this._stack = map._root && mapIteratorFrame(map._root);
};
($traceurRuntime.createClass)(MapIterator, {next: function() {
    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex;
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = this._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }}, {}, Iterator);
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node: node,
    index: 0,
    __prev: prev
  };
}
function makeMap(length, root, ownerID, hash) {
  var map = Object.create(MapPrototype);
  map.length = length;
  map._root = root;
  map.__ownerID = ownerID;
  map.__hash = hash;
  map.__altered = false;
  return map;
}
function updateMap(map, k, v) {
  var didChangeLength = MakeRef(CHANGE_LENGTH);
  var didAlter = MakeRef(DID_ALTER);
  var newRoot = updateNode(map._root, map.__ownerID, 0, hash(k), k, v, didChangeLength, didAlter);
  if (!didAlter.value) {
    return map;
  }
  var newLength = map.length + (didChangeLength.value ? v === NOT_SET ? -1 : 1 : 0);
  if (map.__ownerID) {
    map.length = newLength;
    map._root = newRoot;
    map.__hash = undefined;
    map.__altered = true;
    return map;
  }
  return newRoot ? makeMap(newLength, newRoot) : Map.empty();
}
function updateNode(node, ownerID, shift, hash, key, value, didChangeLength, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeLength);
    return new ValueNode(ownerID, hash, [key, value]);
  }
  return node.update(ownerID, shift, hash, key, value, didChangeLength, didAlter);
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, hash, entry) {
  if (node.hash === hash) {
    return new HashCollisionNode(ownerID, hash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.hash : node.hash >>> shift) & MASK;
  var idx2 = (shift === 0 ? hash : hash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, hash, entry)] : ((newNode = new ValueNode(ownerID, hash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
}
function packNodes(ownerID, nodes, count, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count);
  for (var ii = 0,
      bit = 1,
      len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node != null && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : null;
  }
  expandedNodes[including] = node;
  return new ArrayNode(ownerID, count + 1, expandedNodes);
}
function mergeIntoMapWith(map, merger, iterables) {
  var seqs = [];
  for (var ii = 0; ii < iterables.length; ii++) {
    var seq = iterables[ii];
    if (!(seq instanceof Sequence)) {
      seq = Sequence(seq);
      if (seq instanceof IndexedSequence) {
        seq = seq.fromEntrySeq();
      }
    }
    seq && seqs.push(seq);
  }
  return mergeIntoCollectionWith(map, merger, seqs);
}
function deepMerger(merger) {
  return (function(existing, value) {
    return existing && existing.mergeDeepWith ? existing.mergeDeepWith(merger, value) : merger ? merger(existing, value) : value;
  });
}
function mergeIntoCollectionWith(collection, merger, seqs) {
  if (seqs.length === 0) {
    return collection;
  }
  return collection.withMutations((function(collection) {
    var mergeIntoMap = merger ? (function(value, key) {
      var existing = collection.get(key, NOT_SET);
      collection.set(key, existing === NOT_SET ? value : merger(existing, value));
    }) : (function(value, key) {
      collection.set(key, value);
    });
    for (var ii = 0; ii < seqs.length; ii++) {
      seqs[ii].forEach(mergeIntoMap);
    }
  }));
}
function updateInDeepMap(collection, keyPath, notSetValue, updater, offset) {
  invariant(!collection || collection.set, 'updateIn with invalid keyPath');
  var key = keyPath[offset];
  var existing = collection ? collection.get(key, NOT_SET) : NOT_SET;
  var existingValue = existing === NOT_SET ? undefined : existing;
  var value = offset === keyPath.length - 1 ? updater(existing === NOT_SET ? notSetValue : existing) : updateInDeepMap(existingValue, keyPath, notSetValue, updater, offset + 1);
  return value === existingValue ? collection : value === NOT_SET ? collection && collection.remove(key) : (collection || Map.empty()).set(key, value);
}
function popCount(x) {
  x = x - ((x >> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  x = (x + (x >> 4)) & 0x0f0f0f0f;
  x = x + (x >> 8);
  x = x + (x >> 16);
  return x & 0x7f;
}
function setIn(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
var MAX_BITMAP_SIZE = SIZE / 2;
var MIN_ARRAY_SIZE = SIZE / 4;
var EMPTY_MAP;
var Vector = function Vector() {
  for (var values = [],
      $__6 = 0; $__6 < arguments.length; $__6++)
    values[$__6] = arguments[$__6];
  return $Vector.from(values);
};
var $Vector = Vector;
($traceurRuntime.createClass)(Vector, {
  toString: function() {
    return this.__toString('Vector [', ']');
  },
  get: function(index, notSetValue) {
    index = wrapIndex(this, index);
    if (index < 0 || index >= this.length) {
      return notSetValue;
    }
    index += this._origin;
    var node = vectorNodeFor(this, index);
    return node && node.array[index & MASK];
  },
  set: function(index, value) {
    return updateVector(this, index, value);
  },
  remove: function(index) {
    return updateVector(this, index, NOT_SET);
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = this._origin = this._size = 0;
      this._level = SHIFT;
      this._root = this._tail = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return $Vector.empty();
  },
  push: function() {
    var values = arguments;
    var oldLength = this.length;
    return this.withMutations((function(vect) {
      setVectorBounds(vect, 0, oldLength + values.length);
      for (var ii = 0; ii < values.length; ii++) {
        vect.set(oldLength + ii, values[ii]);
      }
    }));
  },
  pop: function() {
    return setVectorBounds(this, 0, -1);
  },
  unshift: function() {
    var values = arguments;
    return this.withMutations((function(vect) {
      setVectorBounds(vect, -values.length);
      for (var ii = 0; ii < values.length; ii++) {
        vect.set(ii, values[ii]);
      }
    }));
  },
  shift: function() {
    return setVectorBounds(this, 1);
  },
  merge: function() {
    return mergeIntoVectorWith(this, null, arguments);
  },
  mergeWith: function(merger) {
    for (var seqs = [],
        $__7 = 1; $__7 < arguments.length; $__7++)
      seqs[$__7 - 1] = arguments[$__7];
    return mergeIntoVectorWith(this, merger, seqs);
  },
  mergeDeep: function() {
    return mergeIntoVectorWith(this, deepMerger(null), arguments);
  },
  mergeDeepWith: function(merger) {
    for (var seqs = [],
        $__8 = 1; $__8 < arguments.length; $__8++)
      seqs[$__8 - 1] = arguments[$__8];
    return mergeIntoVectorWith(this, deepMerger(merger), seqs);
  },
  setLength: function(length) {
    return setVectorBounds(this, 0, length);
  },
  slice: function(begin, end) {
    var sliceSequence = $traceurRuntime.superCall(this, $Vector.prototype, "slice", [begin, end]);
    if (sliceSequence !== this) {
      var vector = this;
      var length = vector.length;
      sliceSequence.toVector = (function() {
        return setVectorBounds(vector, begin < 0 ? Math.max(0, length + begin) : length ? Math.min(length, begin) : begin, end == null ? length : end < 0 ? Math.max(0, length + end) : length ? Math.min(length, end) : end);
      });
    }
    return sliceSequence;
  },
  __iterator: function(type, reverse) {
    return new VectorIterator(this, type, reverse);
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    var iterations = 0;
    var eachFn = (function(v) {
      return fn(v, iterations++, $__0);
    });
    var tailOffset = getTailOffset(this._size);
    if (reverse) {
      iterateVNode(this._tail, 0, tailOffset - this._origin, this._size - this._origin, eachFn, reverse) && iterateVNode(this._root, this._level, -this._origin, tailOffset - this._origin, eachFn, reverse);
    } else {
      iterateVNode(this._root, this._level, -this._origin, tailOffset - this._origin, eachFn, reverse) && iterateVNode(this._tail, 0, tailOffset - this._origin, this._size - this._origin, eachFn, reverse);
    }
    return iterations;
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      this.__ownerID = ownerID;
      return this;
    }
    return makeVector(this._origin, this._size, this._level, this._root, this._tail, ownerID, this.__hash);
  }
}, {
  empty: function() {
    return EMPTY_VECT || (EMPTY_VECT = makeVector(0, 0, SHIFT));
  },
  from: function(sequence) {
    if (!sequence || sequence.length === 0) {
      return $Vector.empty();
    }
    if (sequence.constructor === $Vector) {
      return sequence;
    }
    var isArray = Array.isArray(sequence);
    if (sequence.length > 0 && sequence.length < SIZE) {
      return makeVector(0, sequence.length, SHIFT, null, new VNode(isArray ? arrCopy(sequence) : Sequence(sequence).toArray()));
    }
    if (!isArray) {
      sequence = Sequence(sequence).valueSeq();
    }
    return $Vector.empty().merge(sequence);
  }
}, IndexedSequence);
var VectorPrototype = Vector.prototype;
VectorPrototype[DELETE] = VectorPrototype.remove;
VectorPrototype.setIn = MapPrototype.setIn;
VectorPrototype.removeIn = MapPrototype.removeIn;
VectorPrototype.update = MapPrototype.update;
VectorPrototype.updateIn = MapPrototype.updateIn;
VectorPrototype.cursor = MapPrototype.cursor;
VectorPrototype.withMutations = MapPrototype.withMutations;
VectorPrototype.asMutable = MapPrototype.asMutable;
VectorPrototype.asImmutable = MapPrototype.asImmutable;
VectorPrototype.wasAltered = MapPrototype.wasAltered;
var VNode = function VNode(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};
var $VNode = VNode;
($traceurRuntime.createClass)(VNode, {
  removeBefore: function(ownerID, level, index) {
    if (index === level ? 1 << level : 0 || this.array.length === 0) {
      return this;
    }
    var originIndex = (index >>> level) & MASK;
    if (originIndex >= this.array.length) {
      return new $VNode([], ownerID);
    }
    var removingFirst = originIndex === 0;
    var newChild;
    if (level > 0) {
      var oldChild = this.array[originIndex];
      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
      if (newChild === oldChild && removingFirst) {
        return this;
      }
    }
    if (removingFirst && !newChild) {
      return this;
    }
    var editable = editableVNode(this, ownerID);
    if (!removingFirst) {
      for (var ii = 0; ii < originIndex; ii++) {
        editable.array[ii] = undefined;
      }
    }
    if (newChild) {
      editable.array[originIndex] = newChild;
    }
    return editable;
  },
  removeAfter: function(ownerID, level, index) {
    if (index === level ? 1 << level : 0 || this.array.length === 0) {
      return this;
    }
    var sizeIndex = ((index - 1) >>> level) & MASK;
    if (sizeIndex >= this.array.length) {
      return this;
    }
    var removingLast = sizeIndex === this.array.length - 1;
    var newChild;
    if (level > 0) {
      var oldChild = this.array[sizeIndex];
      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
      if (newChild === oldChild && removingLast) {
        return this;
      }
    }
    if (removingLast && !newChild) {
      return this;
    }
    var editable = editableVNode(this, ownerID);
    if (!removingLast) {
      editable.array.pop();
    }
    if (newChild) {
      editable.array[sizeIndex] = newChild;
    }
    return editable;
  }
}, {});
function iterateVNode(node, level, offset, max, fn, reverse) {
  var ii;
  var array = node && node.array;
  if (level === 0) {
    var from = offset < 0 ? -offset : 0;
    var to = max - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    for (ii = from; ii < to; ii++) {
      if (fn(array && array[reverse ? from + to - 1 - ii : ii]) === false) {
        return false;
      }
    }
  } else {
    var step = 1 << level;
    var newLevel = level - SHIFT;
    for (ii = 0; ii <= MASK; ii++) {
      var levelIndex = reverse ? MASK - ii : ii;
      var newOffset = offset + (levelIndex << level);
      if (newOffset < max && newOffset + step > 0) {
        var nextNode = array && array[levelIndex];
        if (!iterateVNode(nextNode, newLevel, newOffset, max, fn, reverse)) {
          return false;
        }
      }
    }
  }
  return true;
}
var VectorIterator = function VectorIterator(vector, type, reverse) {
  this._type = type;
  this._reverse = !!reverse;
  this._maxIndex = vector.length - 1;
  var tailOffset = getTailOffset(vector._size);
  var rootStack = vectIteratorFrame(vector._root && vector._root.array, vector._level, -vector._origin, tailOffset - vector._origin - 1);
  var tailStack = vectIteratorFrame(vector._tail && vector._tail.array, 0, tailOffset - vector._origin, vector._size - vector._origin - 1);
  this._stack = reverse ? tailStack : rootStack;
  this._stack.__prev = reverse ? rootStack : tailStack;
};
($traceurRuntime.createClass)(VectorIterator, {next: function() {
    var stack = this._stack;
    while (stack) {
      var array = stack.array;
      var rawIndex = stack.index++;
      if (this._reverse) {
        rawIndex = MASK - rawIndex;
        if (rawIndex > stack.rawMax) {
          rawIndex = stack.rawMax;
          stack.index = SIZE - rawIndex;
        }
      }
      if (rawIndex >= 0 && rawIndex < SIZE && rawIndex <= stack.rawMax) {
        var value = array && array[rawIndex];
        if (stack.level === 0) {
          var type = this._type;
          var index;
          if (type !== 1) {
            index = stack.offset + (rawIndex << stack.level);
            if (this._reverse) {
              index = this._maxIndex - index;
            }
          }
          return iteratorValue(type, index, value);
        } else {
          this._stack = stack = vectIteratorFrame(value && value.array, stack.level - SHIFT, stack.offset + (rawIndex << stack.level), stack.max, stack);
        }
        continue;
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }}, {}, Iterator);
function vectIteratorFrame(array, level, offset, max, prevFrame) {
  return {
    array: array,
    level: level,
    offset: offset,
    max: max,
    rawMax: ((max - offset) >> level),
    index: 0,
    __prev: prevFrame
  };
}
function makeVector(origin, size, level, root, tail, ownerID, hash) {
  var vect = Object.create(VectorPrototype);
  vect.length = size - origin;
  vect._origin = origin;
  vect._size = size;
  vect._level = level;
  vect._root = root;
  vect._tail = tail;
  vect.__ownerID = ownerID;
  vect.__hash = hash;
  vect.__altered = false;
  return vect;
}
function updateVector(vector, index, value) {
  index = wrapIndex(vector, index);
  if (index >= vector.length || index < 0) {
    return value === NOT_SET ? vector : vector.withMutations((function(vect) {
      index < 0 ? setVectorBounds(vect, index).set(0, value) : setVectorBounds(vect, 0, index + 1).set(index, value);
    }));
  }
  index += vector._origin;
  var newTail = vector._tail;
  var newRoot = vector._root;
  var didAlter = MakeRef(DID_ALTER);
  if (index >= getTailOffset(vector._size)) {
    newTail = updateVNode(newTail, vector.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(newRoot, vector.__ownerID, vector._level, index, value, didAlter);
  }
  if (!didAlter.value) {
    return vector;
  }
  if (vector.__ownerID) {
    vector._root = newRoot;
    vector._tail = newTail;
    vector.__hash = undefined;
    vector.__altered = true;
    return vector;
  }
  return makeVector(vector._origin, vector._size, vector._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
  var removed = value === NOT_SET;
  var newNode;
  var idx = (index >>> level) & MASK;
  var nodeHas = node && idx < node.array.length;
  if (removed && !nodeHas) {
    return node;
  }
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (!removed && nodeHas && node.array[idx] === value) {
    return node;
  }
  SetRef(didAlter);
  newNode = editableVNode(node, ownerID);
  if (removed && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = removed ? undefined : value;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function vectorNodeFor(vector, rawIndex) {
  if (rawIndex >= getTailOffset(vector._size)) {
    return vector._tail;
  }
  if (rawIndex < 1 << (vector._level + SHIFT)) {
    var node = vector._root;
    var level = vector._level;
    while (node && level > 0) {
      node = node.array[(rawIndex >>> level) & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setVectorBounds(vector, begin, end) {
  var owner = vector.__ownerID || new OwnerID();
  var oldOrigin = vector._origin;
  var oldSize = vector._size;
  var newOrigin = oldOrigin + begin;
  var newSize = end == null ? oldSize : end < 0 ? oldSize + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newSize === oldSize) {
    return vector;
  }
  if (newOrigin >= newSize) {
    return vector.clear();
  }
  var newLevel = vector._level;
  var newRoot = vector._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(newRoot && newRoot.array.length ? [null, newRoot] : [], owner);
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newSize += offsetShift;
    oldSize += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldSize);
  var newTailOffset = getTailOffset(newSize);
  while (newTailOffset >= 1 << (newLevel + SHIFT)) {
    newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
    newLevel += SHIFT;
  }
  var oldTail = vector._tail;
  var newTail = newTailOffset < oldTailOffset ? vectorNodeFor(vector, newSize - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldSize && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = (oldTailOffset >>> level) & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
  }
  if (newSize < oldSize) {
    newTail = newTail && newTail.removeAfter(owner, 0, newSize);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newSize -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = (newOrigin >>> newLevel) & MASK;
      if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newSize -= offsetShift;
    }
  }
  if (vector.__ownerID) {
    vector.length = newSize - newOrigin;
    vector._origin = newOrigin;
    vector._size = newSize;
    vector._level = newLevel;
    vector._root = newRoot;
    vector._tail = newTail;
    vector.__hash = undefined;
    vector.__altered = true;
    return vector;
  }
  return makeVector(newOrigin, newSize, newLevel, newRoot, newTail);
}
function mergeIntoVectorWith(vector, merger, iterables) {
  var seqs = [];
  for (var ii = 0; ii < iterables.length; ii++) {
    var seq = iterables[ii];
    seq && seqs.push(Sequence(seq));
  }
  var maxLength = Math.max.apply(null, seqs.map((function(s) {
    return s.length || 0;
  })));
  if (maxLength > vector.length) {
    vector = vector.setLength(maxLength);
  }
  return mergeIntoCollectionWith(vector, merger, seqs);
}
function getTailOffset(size) {
  return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
}
var EMPTY_VECT;
var Stack = function Stack() {
  for (var values = [],
      $__9 = 0; $__9 < arguments.length; $__9++)
    values[$__9] = arguments[$__9];
  return $Stack.from(values);
};
var $Stack = Stack;
($traceurRuntime.createClass)(Stack, {
  toString: function() {
    return this.__toString('Stack [', ']');
  },
  get: function(index, notSetValue) {
    var head = this._head;
    while (head && index--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  },
  peek: function() {
    return this._head && this._head.value;
  },
  push: function() {
    if (arguments.length === 0) {
      return this;
    }
    var newLength = this.length + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.length = newLength;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newLength, head);
  },
  pushAll: function(seq) {
    seq = Sequence(seq);
    if (seq.length === 0) {
      return this;
    }
    var newLength = this.length;
    var head = this._head;
    seq.reverse().forEach((function(value) {
      newLength++;
      head = {
        value: value,
        next: head
      };
    }));
    if (this.__ownerID) {
      this.length = newLength;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newLength, head);
  },
  pop: function() {
    return this.slice(1);
  },
  unshift: function() {
    return this.push.apply(this, arguments);
  },
  unshiftAll: function(seq) {
    return this.pushAll(seq);
  },
  shift: function() {
    return this.pop.apply(this, arguments);
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = 0;
      this._head = undefined;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return $Stack.empty();
  },
  slice: function(begin, end) {
    if (wholeSlice(begin, end, this.length)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.length);
    var resolvedEnd = resolveEnd(end, this.length);
    if (resolvedEnd !== this.length) {
      return $traceurRuntime.superCall(this, $Stack.prototype, "slice", [begin, end]);
    }
    var newLength = this.length - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.length = newLength;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newLength, head);
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.length, this._head, ownerID, this.__hash);
  },
  __iterateUncached: function(fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  },
  __iteratorUncached: function(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator((function() {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    }));
  }
}, {
  empty: function() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  },
  from: function(sequence) {
    var stack = $Stack.empty();
    return sequence ? sequence.constructor === $Stack ? sequence : stack.unshiftAll(sequence) : stack;
  }
}, IndexedSequence);
var StackPrototype = Stack.prototype;
StackPrototype.withMutations = MapPrototype.withMutations;
StackPrototype.asMutable = MapPrototype.asMutable;
StackPrototype.asImmutable = MapPrototype.asImmutable;
StackPrototype.wasAltered = MapPrototype.wasAltered;
function makeStack(length, head, ownerID, hash) {
  var map = Object.create(StackPrototype);
  map.length = length;
  map._head = head;
  map.__ownerID = ownerID;
  map.__hash = hash;
  map.__altered = false;
  return map;
}
var EMPTY_STACK;
var Set = function Set() {
  for (var values = [],
      $__10 = 0; $__10 < arguments.length; $__10++)
    values[$__10] = arguments[$__10];
  return $Set.from(values);
};
var $Set = Set;
($traceurRuntime.createClass)(Set, {
  toString: function() {
    return this.__toString('Set {', '}');
  },
  get: function(value, notSetValue) {
    return this._map.has(value) ? value : notSetValue;
  },
  contains: function(value) {
    return this._map.has(value);
  },
  add: function(value) {
    var newMap = this._map.set(value, null);
    if (this.__ownerID) {
      this.length = newMap.length;
      this._map = newMap;
      return this;
    }
    return newMap === this._map ? this : makeSet(newMap);
  },
  remove: function(value) {
    var newMap = this._map.remove(value);
    if (this.__ownerID) {
      this.length = newMap.length;
      this._map = newMap;
      return this;
    }
    return newMap === this._map ? this : newMap.length === 0 ? $Set.empty() : makeSet(newMap);
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = 0;
      this._map.clear();
      return this;
    }
    return $Set.empty();
  },
  union: function() {
    var seqs = arguments;
    if (seqs.length === 0) {
      return this;
    }
    return this.withMutations((function(set) {
      for (var ii = 0; ii < seqs.length; ii++) {
        Sequence(seqs[ii]).forEach((function(value) {
          return set.add(value);
        }));
      }
    }));
  },
  intersect: function() {
    for (var seqs = [],
        $__11 = 0; $__11 < arguments.length; $__11++)
      seqs[$__11] = arguments[$__11];
    if (seqs.length === 0) {
      return this;
    }
    seqs = seqs.map((function(seq) {
      return Sequence(seq);
    }));
    var originalSet = this;
    return this.withMutations((function(set) {
      originalSet.forEach((function(value) {
        if (!seqs.every((function(seq) {
          return seq.contains(value);
        }))) {
          set.remove(value);
        }
      }));
    }));
  },
  subtract: function() {
    for (var seqs = [],
        $__12 = 0; $__12 < arguments.length; $__12++)
      seqs[$__12] = arguments[$__12];
    if (seqs.length === 0) {
      return this;
    }
    seqs = seqs.map((function(seq) {
      return Sequence(seq);
    }));
    var originalSet = this;
    return this.withMutations((function(set) {
      originalSet.forEach((function(value) {
        if (seqs.some((function(seq) {
          return seq.contains(value);
        }))) {
          set.remove(value);
        }
      }));
    }));
  },
  isSubset: function(seq) {
    seq = Sequence(seq);
    return this.every((function(value) {
      return seq.contains(value);
    }));
  },
  isSuperset: function(seq) {
    var set = this;
    seq = Sequence(seq);
    return seq.every((function(value) {
      return set.contains(value);
    }));
  },
  merge: function() {
    return this.union.apply(this, arguments);
  },
  mergeWith: function(merger) {
    for (var seqs = [],
        $__13 = 1; $__13 < arguments.length; $__13++)
      seqs[$__13 - 1] = arguments[$__13];
    return this.union.apply(this, seqs);
  },
  wasAltered: function() {
    return this._map.wasAltered();
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    return this._map.__iterate((function(_, k) {
      return fn(k, k, $__0);
    }), reverse);
  },
  __iterator: function(type, reverse) {
    return this._map.map((function(_, k) {
      return k;
    })).__iterator(type, reverse);
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return makeSet(newMap, ownerID);
  }
}, {
  empty: function() {
    return EMPTY_SET || (EMPTY_SET = makeSet(Map.empty()));
  },
  from: function(sequence) {
    var set = $Set.empty();
    return sequence ? sequence.constructor === $Set ? sequence : set.union(sequence) : set;
  },
  fromKeys: function(sequence) {
    return $Set.from(Sequence(sequence).flip());
  }
}, Sequence);
var SetPrototype = Set.prototype;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype[ITERATOR_SYMBOL] = SetPrototype.values;
SetPrototype.mergeDeep = SetPrototype.merge;
SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
SetPrototype.withMutations = MapPrototype.withMutations;
SetPrototype.asMutable = MapPrototype.asMutable;
SetPrototype.asImmutable = MapPrototype.asImmutable;
SetPrototype.__toJS = IndexedSequencePrototype.__toJS;
SetPrototype.__toStringMapper = IndexedSequencePrototype.__toStringMapper;
function makeSet(map, ownerID) {
  var set = Object.create(SetPrototype);
  set.length = map ? map.length : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}
var EMPTY_SET;
var OrderedMap = function OrderedMap(sequence) {
  var map = $OrderedMap.empty();
  return sequence ? sequence.constructor === $OrderedMap ? sequence : map.merge(sequence) : map;
};
var $OrderedMap = OrderedMap;
($traceurRuntime.createClass)(OrderedMap, {
  toString: function() {
    return this.__toString('OrderedMap {', '}');
  },
  get: function(k, notSetValue) {
    var index = this._map.get(k);
    return index != null ? this._vector.get(index)[1] : notSetValue;
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = 0;
      this._map.clear();
      this._vector.clear();
      return this;
    }
    return $OrderedMap.empty();
  },
  set: function(k, v) {
    return updateOrderedMap(this, k, v);
  },
  remove: function(k) {
    return updateOrderedMap(this, k, NOT_SET);
  },
  wasAltered: function() {
    return this._map.wasAltered() || this._vector.wasAltered();
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    return this._vector.__iterate((function(entry) {
      return entry && fn(entry[1], entry[0], $__0);
    }), reverse);
  },
  __iterator: function(type, reverse) {
    return this._vector.fromEntrySeq().__iterator(type, reverse);
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newVector = this._vector.__ensureOwner(ownerID);
    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      this._vector = newVector;
      return this;
    }
    return makeOrderedMap(newMap, newVector, ownerID, this.__hash);
  }
}, {empty: function() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(Map.empty(), Vector.empty()));
  }}, Map);
OrderedMap.from = OrderedMap;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map, vector, ownerID, hash) {
  var omap = Object.create(OrderedMap.prototype);
  omap.length = map ? map.length : 0;
  omap._map = map;
  omap._vector = vector;
  omap.__ownerID = ownerID;
  omap.__hash = hash;
  return omap;
}
function updateOrderedMap(omap, k, v) {
  var map = omap._map;
  var vector = omap._vector;
  var i = map.get(k);
  var has = i !== undefined;
  var removed = v === NOT_SET;
  if ((!has && removed) || (has && v === vector.get(i)[1])) {
    return omap;
  }
  if (!has) {
    i = vector.length;
  }
  var newMap = removed ? map.remove(k) : has ? map : map.set(k, i);
  var newVector = removed ? vector.remove(i) : vector.set(i, [k, v]);
  if (omap.__ownerID) {
    omap.length = newMap.length;
    omap._map = newMap;
    omap._vector = newVector;
    omap.__hash = undefined;
    return omap;
  }
  return makeOrderedMap(newMap, newVector);
}
var EMPTY_ORDERED_MAP;
var Record = function Record(defaultValues, name) {
  var RecordType = function(values) {
    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }
    this._map = Map(values);
  };
  var keys = Object.keys(defaultValues);
  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;
  name && (RecordTypePrototype._name = name);
  RecordTypePrototype._defaultValues = defaultValues;
  RecordTypePrototype._keys = keys;
  RecordTypePrototype.length = keys.length;
  try {
    Sequence(defaultValues).forEach((function(_, key) {
      Object.defineProperty(RecordType.prototype, key, {
        get: function() {
          return this.get(key);
        },
        set: function(value) {
          invariant(this.__ownerID, 'Cannot set on an immutable record.');
          this.set(key, value);
        }
      });
    }));
  } catch (error) {}
  return RecordType;
};
($traceurRuntime.createClass)(Record, {
  toString: function() {
    return this.__toString(this._name + ' {', '}');
  },
  has: function(k) {
    return this._defaultValues.hasOwnProperty(k);
  },
  get: function(k, notSetValue) {
    if (notSetValue !== undefined && !this.has(k)) {
      return notSetValue;
    }
    return this._map.get(k, this._defaultValues[k]);
  },
  clear: function() {
    if (this.__ownerID) {
      this._map.clear();
      return this;
    }
    var SuperRecord = Object.getPrototypeOf(this).constructor;
    return SuperRecord._empty || (SuperRecord._empty = makeRecord(this, Map.empty()));
  },
  set: function(k, v) {
    if (!this.has(k)) {
      throw new Error('Cannot set unknown key "' + k + '" on ' + this._name);
    }
    var newMap = this._map.set(k, v);
    if (this.__ownerID || newMap === this._map) {
      return this;
    }
    return makeRecord(this, newMap);
  },
  remove: function(k) {
    if (k == null || !this.has(k)) {
      return this;
    }
    var newMap = this._map.remove(k);
    if (this.__ownerID || newMap === this._map) {
      return this;
    }
    return makeRecord(this, newMap);
  },
  keys: function() {
    return this._map.keys();
  },
  values: function() {
    return this._map.values();
  },
  entries: function() {
    return this._map.entries();
  },
  wasAltered: function() {
    return this._map.wasAltered();
  },
  __iterator: function(type, reverse) {
    return this._map.__iterator(type, reverse);
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    return Sequence(this._defaultValues).map((function(_, k) {
      return $__0.get(k);
    })).__iterate(fn, reverse);
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map && this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return makeRecord(this, newMap, ownerID);
  }
}, {}, Sequence);
var RecordPrototype = Record.prototype;
RecordPrototype._name = 'Record';
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.merge = MapPrototype.merge;
RecordPrototype.mergeWith = MapPrototype.mergeWith;
RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
RecordPrototype.update = MapPrototype.update;
RecordPrototype.updateIn = MapPrototype.updateIn;
RecordPrototype.cursor = MapPrototype.cursor;
RecordPrototype.withMutations = MapPrototype.withMutations;
RecordPrototype.asMutable = MapPrototype.asMutable;
RecordPrototype.asImmutable = MapPrototype.asImmutable;
function makeRecord(likeRecord, map, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._map = map;
  record.__ownerID = ownerID;
  return record;
}
var Range = function Range(start, end, step) {
  if (!(this instanceof $Range)) {
    return new $Range(start, end, step);
  }
  invariant(step !== 0, 'Cannot step a Range by 0');
  start = start || 0;
  if (end == null) {
    end = Infinity;
  }
  if (start === end && __EMPTY_RANGE) {
    return __EMPTY_RANGE;
  }
  step = step == null ? 1 : Math.abs(step);
  if (end < start) {
    step = -step;
  }
  this._start = start;
  this._end = end;
  this._step = step;
  this.length = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
};
var $Range = Range;
($traceurRuntime.createClass)(Range, {
  toString: function() {
    if (this.length === 0) {
      return 'Range []';
    }
    return 'Range [ ' + this._start + '...' + this._end + (this._step > 1 ? ' by ' + this._step : '') + ' ]';
  },
  get: function(index, notSetValue) {
    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
  },
  contains: function(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.length && possibleIndex === Math.floor(possibleIndex);
  },
  slice: function(begin, end) {
    if (wholeSlice(begin, end, this.length)) {
      return this;
    }
    begin = resolveBegin(begin, this.length);
    end = resolveEnd(end, this.length);
    if (end <= begin) {
      return __EMPTY_RANGE;
    }
    return new $Range(this.get(begin, this._end), this.get(end, this._end), this._step);
  },
  indexOf: function(searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.length) {
        return index;
      }
    }
    return -1;
  },
  lastIndexOf: function(searchValue) {
    return this.indexOf(searchValue);
  },
  take: function(amount) {
    return this.slice(0, Math.max(0, amount));
  },
  skip: function(amount) {
    return this.slice(Math.max(0, amount));
  },
  __iterate: function(fn, reverse) {
    var maxIndex = this.length - 1;
    var step = this._step;
    var value = reverse ? this._start + maxIndex * step : this._start;
    for (var ii = 0; ii <= maxIndex; ii++) {
      if (fn(value, ii, this) === false) {
        return ii + 1;
      }
      value += reverse ? -step : step;
    }
    return ii;
  },
  __iterator: function(type, reverse) {
    var maxIndex = this.length - 1;
    var step = this._step;
    var value = reverse ? this._start + maxIndex * step : this._start;
    var ii = 0;
    return new Iterator((function() {
      var v = value;
      value += reverse ? -step : step;
      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
    }));
  },
  __deepEquals: function(other) {
    return other instanceof $Range ? this._start === other._start && this._end === other._end && this._step === other._step : $traceurRuntime.superCall(this, $Range.prototype, "__deepEquals", [other]);
  }
}, {}, IndexedSequence);
var RangePrototype = Range.prototype;
RangePrototype.__toJS = RangePrototype.toArray;
RangePrototype.first = VectorPrototype.first;
RangePrototype.last = VectorPrototype.last;
var __EMPTY_RANGE = Range(0, 0);
var Repeat = function Repeat(value, times) {
  if (times === 0 && EMPTY_REPEAT) {
    return EMPTY_REPEAT;
  }
  if (!(this instanceof $Repeat)) {
    return new $Repeat(value, times);
  }
  this._value = value;
  this.length = times == null ? Infinity : Math.max(0, times);
};
var $Repeat = Repeat;
($traceurRuntime.createClass)(Repeat, {
  toString: function() {
    if (this.length === 0) {
      return 'Repeat []';
    }
    return 'Repeat [ ' + this._value + ' ' + this.length + ' times ]';
  },
  get: function(index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  },
  contains: function(searchValue) {
    return is(this._value, searchValue);
  },
  slice: function(begin, end) {
    var length = this.length;
    begin = begin < 0 ? Math.max(0, length + begin) : Math.min(length, begin);
    end = end == null ? length : end > 0 ? Math.min(length, end) : Math.max(0, length + end);
    return end > begin ? new $Repeat(this._value, end - begin) : EMPTY_REPEAT;
  },
  reverse: function() {
    return this;
  },
  indexOf: function(searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }
    return -1;
  },
  lastIndexOf: function(searchValue) {
    if (is(this._value, searchValue)) {
      return this.length;
    }
    return -1;
  },
  __iterate: function(fn, reverse) {
    for (var ii = 0; ii < this.length; ii++) {
      if (fn(this._value, ii, this) === false) {
        return ii + 1;
      }
    }
    return ii;
  },
  __iterator: function(type, reverse) {
    var $__0 = this;
    var ii = 0;
    return new Iterator((function() {
      return ii < $__0.length ? iteratorValue(type, ii++, $__0._value) : iteratorDone();
    }));
  },
  __deepEquals: function(other) {
    return other instanceof $Repeat ? is(this._value, other._value) : $traceurRuntime.superCall(this, $Repeat.prototype, "__deepEquals", [other]);
  }
}, {}, IndexedSequence);
var RepeatPrototype = Repeat.prototype;
RepeatPrototype.last = RepeatPrototype.first;
RepeatPrototype.has = RangePrototype.has;
RepeatPrototype.take = RangePrototype.take;
RepeatPrototype.skip = RangePrototype.skip;
RepeatPrototype.__toJS = RangePrototype.__toJS;
var EMPTY_REPEAT = new Repeat(undefined, 0);
function fromJS(json, converter) {
  if (converter) {
    return _fromJSWith(converter, json, '', {'': json});
  }
  return _fromJSDefault(json);
}
function _fromJSWith(converter, json, key, parentJSON) {
  if (json && (Array.isArray(json) || json.constructor === Object)) {
    return converter.call(parentJSON, key, Sequence(json).map((function(v, k) {
      return _fromJSWith(converter, v, k, json);
    })));
  }
  return json;
}
function _fromJSDefault(json) {
  if (json) {
    if (Array.isArray(json)) {
      return Sequence(json).map(_fromJSDefault).toVector();
    }
    if (json.constructor === Object) {
      return Sequence(json).map(_fromJSDefault).toMap();
    }
  }
  return json;
}
var Cursor = function Cursor(rootData, keyPath, onChange, length) {
  this.length = length;
  this._rootData = rootData;
  this._keyPath = keyPath;
  this._onChange = onChange;
};
($traceurRuntime.createClass)(Cursor, {
  equals: function(second) {
    return is(this.deref(), second && (typeof second.deref === 'function' ? second.deref() : second));
  },
  deref: function(notSetValue) {
    return this._rootData.getIn(this._keyPath, notSetValue);
  },
  get: function(key, notSetValue) {
    if (Array.isArray(key) && key.length === 0) {
      return this;
    }
    var value = this._rootData.getIn(this._keyPath.concat(key), NOT_SET);
    return value === NOT_SET ? notSetValue : wrappedValue(this, key, value);
  },
  set: function(key, value) {
    return updateCursor(this, (function(m) {
      return m.set(key, value);
    }), key);
  },
  remove: function(key) {
    return updateCursor(this, (function(m) {
      return m.remove(key);
    }), key);
  },
  clear: function() {
    return updateCursor(this, (function(m) {
      return m.clear();
    }));
  },
  update: function(keyOrFn, notSetValue, updater) {
    return arguments.length === 1 ? updateCursor(this, keyOrFn) : updateCursor(this, (function(map) {
      return map.update(keyOrFn, notSetValue, updater);
    }), keyOrFn);
  },
  withMutations: function(fn) {
    return updateCursor(this, (function(m) {
      return (m || Map.empty()).withMutations(fn);
    }));
  },
  cursor: function(subKey) {
    return Array.isArray(subKey) && subKey.length === 0 ? this : subCursor(this, subKey);
  },
  __iterate: function(fn, reverse) {
    var $__0 = this;
    var deref = this.deref();
    return deref && deref.__iterate ? deref.__iterate((function(v, k) {
      return fn(wrappedValue($__0, k, v), k, $__0);
    }), reverse) : 0;
  },
  __iterator: function(type, reverse) {
    var $__0 = this;
    var deref = this.deref();
    var iterator = deref && deref.__iterator && deref.__iterator(ITERATE_ENTRIES, reverse);
    return new Iterator((function() {
      if (!iterator) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      return iteratorValue(type, k, wrappedValue($__0, k, v), step);
    }));
  }
}, {}, Sequence);
var CursorPrototype = Cursor.prototype;
CursorPrototype[DELETE] = CursorPrototype.remove;
CursorPrototype.getIn = CursorPrototype.get;
var IndexedCursor = function IndexedCursor(rootData, keyPath, onChange, length) {
  this.length = length;
  this._rootData = rootData;
  this._keyPath = keyPath;
  this._onChange = onChange;
};
($traceurRuntime.createClass)(IndexedCursor, {}, {}, IndexedSequence);
var IndexedCursorPrototype = IndexedCursor.prototype;
IndexedCursorPrototype.equals = CursorPrototype.equals;
IndexedCursorPrototype.deref = CursorPrototype.deref;
IndexedCursorPrototype.get = CursorPrototype.get;
IndexedCursorPrototype.getIn = CursorPrototype.getIn;
IndexedCursorPrototype.set = CursorPrototype.set;
IndexedCursorPrototype[DELETE] = IndexedCursorPrototype.remove = CursorPrototype.remove;
IndexedCursorPrototype.clear = CursorPrototype.clear;
IndexedCursorPrototype.update = CursorPrototype.update;
IndexedCursorPrototype.withMutations = CursorPrototype.withMutations;
IndexedCursorPrototype.cursor = CursorPrototype.cursor;
IndexedCursorPrototype.__iterate = CursorPrototype.__iterate;
IndexedCursorPrototype.__iterator = CursorPrototype.__iterator;
function makeCursor(rootData, keyPath, onChange, value) {
  if (arguments.length < 4) {
    value = rootData.getIn(keyPath);
  }
  var length = value instanceof Sequence ? value.length : null;
  var CursorClass = value instanceof IndexedSequence ? IndexedCursor : Cursor;
  return new CursorClass(rootData, keyPath, onChange, length);
}
function wrappedValue(cursor, key, value) {
  return value instanceof Sequence ? subCursor(cursor, key, value) : value;
}
function subCursor(cursor, key, value) {
  return makeCursor(cursor._rootData, cursor._keyPath.concat(key), cursor._onChange, value);
}
function updateCursor(cursor, changeFn, changeKey) {
  var newRootData = cursor._rootData.updateIn(cursor._keyPath, changeKey ? Map.empty() : undefined, changeFn);
  var keyPath = cursor._keyPath || [];
  cursor._onChange && cursor._onChange.call(undefined, newRootData, cursor._rootData, changeKey ? keyPath.concat(changeKey) : keyPath);
  return makeCursor(newRootData, cursor._keyPath, cursor._onChange);
}
var Immutable = {
  Sequence: Sequence,
  Map: Map,
  Vector: Vector,
  Stack: Stack,
  Set: Set,
  OrderedMap: OrderedMap,
  Record: Record,
  Range: Range,
  Repeat: Repeat,
  is: is,
  fromJS: fromJS
};

  return Immutable;
}
typeof exports === 'object' ? module.exports = universalModule() :
  typeof define === 'function' && define.amd ? define(universalModule) :
    Immutable = universalModule();

},{}],"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js":[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

},{}],"/home/vadzim/v/work/nerojs/node_modules/morgan/index.js":[function(require,module,exports){
/*!
 * morgan
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var auth = require('basic-auth')
var debug = require('debug')('morgan')
var deprecate = require('depd')('morgan')
var onFinished = require('on-finished')

/**
 * Array of CLF month names.
 * @private
 */

var clfmonth = [
  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
]

/**
 * Default log buffer duration.
 * @private
 */

var defaultBufferDuration = 1000;

/**
 * Create a logger middleware.
 *
 * @public
 * @param {String|Function} format
 * @param {Object} [options]
 * @return {Function} middleware
 */

exports = module.exports = function morgan(format, options) {
  if (typeof format === 'object') {
    options = format
    format = options.format || 'default'

    // smart deprecation message
    deprecate('morgan(options): use morgan(' + (typeof format === 'string' ? JSON.stringify(format) : 'format') + ', options) instead')
  }

  if (format === undefined) {
    deprecate('undefined format: specify a format')
  }

  options = options || {}

  // output on request instead of response
  var immediate = options.immediate;

  // check if log entry should be skipped
  var skip = options.skip || function () { return false; };

  // format function
  var fmt = compile(exports[format] || format || exports.default)

  // steam
  var buffer = options.buffer
  var stream = options.stream || process.stdout

  // buffering support
  if (buffer) {
    deprecate('buffer option')

    var realStream = stream
    var buf = []
    var timer = null
    var interval = 'number' == typeof buffer
      ? buffer
      : defaultBufferDuration

    // flush function
    var flush = function(){
      timer = null

      if (buf.length) {
        realStream.write(buf.join(''));
        buf.length = 0;
      }
    }

    // swap the stream
    stream = {
      write: function(str){
        if (timer === null) {
          timer = setTimeout(flush, interval)
        }

        buf.push(str);
      }
    };
  }

  return function logger(req, res, next) {
    req._startAt = process.hrtime();
    req._startTime = new Date;
    req._remoteAddress = getip(req);

    function logRequest(){
      if (skip(req, res)) {
        debug('skip request')
        return
      }

      var line = fmt(exports, req, res)

      if (null == line) {
        debug('skip line')
        return
      }

      debug('log request')
      stream.write(line + '\n')
    };

    // immediate
    if (immediate) {
      logRequest();
    } else {
      onFinished(res, logRequest)
    }

    next();
  };
};

/**
 * Compile `format` into a function.
 *
 * @private
 * @param {Function|String} format
 * @return {Function}
 */

function compile(format) {
  if (typeof format === 'function') {
    // already compiled
    return format
  }

  if (typeof format !== 'string') {
    throw new TypeError('argument format must be a function or string')
  }

  var fmt = format.replace(/"/g, '\\"')
  var js = '  return "' + fmt.replace(/:([-\w]{2,})(?:\[([^\]]+)\])?/g, function(_, name, arg){
    return '"\n    + (tokens["' + name + '"](req, res, ' + String(JSON.stringify(arg)) + ') || "-") + "';
  }) + '";'

  return new Function('tokens, req, res', js);
};

/**
 * Define a token function with the given `name`,
 * and callback `fn(req, res)`.
 *
 * @public
 * @param {String} name
 * @param {Function} fn
 * @return {Object} exports for chaining
 */

exports.token = function(name, fn) {
  exports[name] = fn;
  return this;
};

/**
 * Define a `fmt` with the given `name`.
 *
 * @public
 * @param {String} name
 * @param {String|Function} fmt
 * @return {Object} exports for chaining
 */

exports.format = function(name, fmt){
  exports[name] = fmt;
  return this;
};

/**
 * Apache combined log format.
 */

exports.format('combined', ':remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"')

/**
 * Apache common log format.
 */

exports.format('common', ':remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length]')

/**
 * Default format.
 */

exports.format('default', ':remote-addr - :remote-user [:date] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"');
deprecate.property(exports, 'default', 'default format: use combined format')

/**
 * Short format.
 */

exports.format('short', ':remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms');

/**
 * Tiny format.
 */

exports.format('tiny', ':method :url :status :res[content-length] - :response-time ms');

/**
 * dev (colored)
 */

exports.format('dev', function(tokens, req, res){
  var color = 32; // green
  var status = res.statusCode;

  if (status >= 500) color = 31; // red
  else if (status >= 400) color = 33; // yellow
  else if (status >= 300) color = 36; // cyan

  var fn = compile('\x1b[0m:method :url \x1b[' + color + 'm:status \x1b[0m:response-time ms - :res[content-length]\x1b[0m');

  return fn(tokens, req, res);
});

/**
 * request url
 */

exports.token('url', function(req){
  return req.originalUrl || req.url;
});

/**
 * request method
 */

exports.token('method', function(req){
  return req.method;
});

/**
 * response time in milliseconds
 */

exports.token('response-time', function(req, res){
  if (!res._header || !req._startAt) return '';
  var diff = process.hrtime(req._startAt);
  var ms = diff[0] * 1e3 + diff[1] * 1e-6;
  return ms.toFixed(3);
});

/**
 * current date
 */

exports.token('date', function(req, res, format){
  format = format || 'web'

  var date = new Date()

  switch (format) {
    case 'clf':
      return clfdate(date)
    case 'iso':
      return date.toISOString()
    case 'web':
      return date.toUTCString()
  }
});

/**
 * response status code
 */

exports.token('status', function(req, res){
  return res._header ? res.statusCode : null;
});

/**
 * normalized referrer
 */

exports.token('referrer', function(req){
  return req.headers['referer'] || req.headers['referrer'];
});

/**
 * remote address
 */

exports.token('remote-addr', getip);

/**
 * remote user
 */

exports.token('remote-user', function (req) {
  var creds = auth(req)
  var user = (creds && creds.name) || '-'
  return user;
})

/**
 * HTTP version
 */

exports.token('http-version', function(req){
  return req.httpVersionMajor + '.' + req.httpVersionMinor;
});

/**
 * UA string
 */

exports.token('user-agent', function(req){
  return req.headers['user-agent'];
});

/**
 * request header
 */

exports.token('req', function(req, res, field){
  return req.headers[field.toLowerCase()];
});

/**
 * response header
 */

exports.token('res', function(req, res, field){
  return (res._headers || {})[field.toLowerCase()];
});

/**
 * Format a Date in the common log format.
 *
 * @private
 * @param {Date} dateTime
 * @return {string}
 */

function clfdate(dateTime) {
  var date = dateTime.getUTCDate()
  var hour = dateTime.getUTCHours()
  var mins = dateTime.getUTCMinutes()
  var secs = dateTime.getUTCSeconds()
  var year = dateTime.getUTCFullYear()

  var month = clfmonth[dateTime.getUTCMonth()]

  return pad2(date) + '/' + month + '/' + year
    + ':' + pad2(hour) + ':' + pad2(mins) + ':' + pad2(secs)
    + ' +0000'
}

/**
 * Get request IP address.
 *
 * @private
 * @param {IncomingMessage} req
 * @return {string}
 */

function getip(req) {
  return req.ip
    || req._remoteAddress
    || (req.connection && req.connection.remoteAddress)
    || undefined;
}

/**
 * Pad number to two digits.
 *
 * @private
 * @param {number} num
 * @return {string}
 */

function pad2(num) {
  var str = String(num)

  return (str.length === 1 ? '0' : '')
    + str
}

},{"basic-auth":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/basic-auth/index.js","debug":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/debug/browser.js","depd":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/depd/index.js","on-finished":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/on-finished/index.js"}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/basic-auth/index.js":[function(require,module,exports){

/**
 * Parse the Authorization header field of `req`.
 *
 * @param {Request} req
 * @return {Object} with .name and .pass
 * @api public
 */

module.exports = function(req){
  req = req.req || req;

  var auth = req.headers.authorization;
  if (!auth) return;

  // malformed
  var parts = auth.split(' ');
  if ('basic' != parts[0].toLowerCase()) return;
  if (!parts[1]) return;
  auth = parts[1];

  // credentials
  auth = new Buffer(auth, 'base64').toString();
  auth = auth.match(/^([^:]*):(.*)$/);
  if (!auth) return;

  return { name: auth[1], pass: auth[2] };
};

},{}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/debug/browser.js":[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/debug/debug.js"}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/debug/debug.js":[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/debug/node_modules/ms/index.js"}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/debug/node_modules/ms/index.js":[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/depd/index.js":[function(require,module,exports){
/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var callSiteToString = require('./lib/compat').callSiteToString
var EventEmitter = require('events').EventEmitter
var relative = require('path').relative

/**
 * Module exports.
 */

module.exports = depd

/**
 * Get the path to base files on.
 */

var basePath = process.cwd()

/**
 * Get listener count on event emitter.
 */

/*istanbul ignore next*/
var eventListenerCount = EventEmitter.listenerCount
  || function (emitter, type) { return emitter.listeners(type).length }

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace(str, namespace) {
  var val = str.split(/[ ,]+/)

  namespace = String(namespace).toLowerCase()

  for (var i = 0 ; i < val.length; i++) {
    if (!(str = val[i])) continue;

    // namespace contained
    if (str === '*' || str.toLowerCase() === namespace) {
      return true
    }
  }

  return false
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor(obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
  var value = descriptor.value

  descriptor.get = function getter() { return value }

  if (descriptor.writable) {
    descriptor.set = function setter(val) { return value = val }
  }

  delete descriptor.value
  delete descriptor.writable

  Object.defineProperty(obj, prop, descriptor)

  return descriptor
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString(arity) {
  var str = ''

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i
  }

  return str.substr(2)
}

/**
 * Create stack string from stack.
 */

function createStackString(stack) {
  var str = this.name + ': ' + this.namespace

  if (this.message) {
    str += ' deprecated ' + this.message
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + callSiteToString(stack[i])
  }

  return str
}

/**
 * Create deprecate for namespace in caller.
 */

function depd(namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required')
  }

  var stack = getStack()
  var site = callSiteLocation(stack[1])
  var file = site[0]

  function deprecate(message) {
    // call to self as log
    log.call(deprecate, message)
  }

  deprecate._file = file
  deprecate._ignored = isignored(namespace)
  deprecate._namespace = namespace
  deprecate._traced = istraced(namespace)
  deprecate._warned = Object.create(null)

  deprecate.function = wrapfunction
  deprecate.property = wrapproperty

  return deprecate
}

/**
 * Determine if namespace is ignored.
 */

function isignored(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.noDeprecation) {
    // --no-deprecation support
    return true
  }

  var str = process.env.NO_DEPRECATION || ''

  // namespace ignored
  return containsNamespace(str, namespace)
}

/**
 * Determine if namespace is traced.
 */

function istraced(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true
  }

  var str = process.env.TRACE_DEPRECATION || ''

  // namespace traced
  return containsNamespace(str, namespace)
}

/**
 * Display deprecation message.
 */

function log(message, site) {
  var haslisteners = eventListenerCount(process, 'deprecation') !== 0

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return
  }

  var caller
  var callFile
  var callSite
  var i = 0
  var seen = false
  var stack = getStack()
  var file = this._file

  if (site) {
    // provided site
    callSite = callSiteLocation(stack[1])
    callSite.name = site.name
    file = callSite[0]
  } else {
    // get call site
    i = 2
    site = callSiteLocation(stack[i])
    callSite = site
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i])
    callFile = caller[0]

    if (callFile === file) {
      seen = true
    } else if (callFile === this._file) {
      file = this._file
    } else if (seen) {
      break
    }
  }

  var key = caller
    ? site.join(':') + '__' + caller.join(':')
    : undefined

  if (key !== undefined && key in this._warned) {
    // already warned
    return
  }

  this._warned[key] = true

  // generate automatic message from call site
  if (!message) {
    message = callSite === site || !callSite.name
      ? defaultMessage(site)
      : defaultMessage(callSite)
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError(this._namespace, message, stack.slice(i))
    process.emit('deprecation', err)
    return
  }

  // format and write message
  var format = process.stderr.isTTY
    ? formatColor
    : formatPlain
  var msg = format.call(this, message, caller, stack.slice(i))
  process.stderr.write(msg + '\n', 'utf8')

  return
}

/**
 * Get call site location as array.
 */

function callSiteLocation(callSite) {
  var file = callSite.getFileName() || '<anonymous>'
  var line = callSite.getLineNumber()
  var colm = callSite.getColumnNumber()

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file
  }

  var site = [file, line, colm]

  site.callSite = callSite
  site.name = callSite.getFunctionName()

  return site
}

/**
 * Generate a default message from the site.
 */

function defaultMessage(site) {
  var callSite = site.callSite
  var funcName = site.name
  var typeName = callSite.getTypeName()

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation(site) + '>'
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = callSite.getThis().name || typeName
  }

  return callSite.getMethodName()
    ? typeName + '.' + funcName
    : funcName
}

/**
 * Format deprecation message without color.
 */

function formatPlain(msg, caller, stack) {
  var timestamp = new Date().toUTCString()

  var formatted = timestamp
    + ' ' + this._namespace
    + ' deprecated ' + msg

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + callSiteToString(stack[i])
    }

    return formatted
  }

  if (caller) {
    formatted += ' at ' + formatLocation(caller)
  }

  return formatted
}

/**
 * Format deprecation message with color.
 */

function formatColor(msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' // bold cyan
    + ' \x1b[33;1mdeprecated\x1b[22;39m' // bold yellow
    + ' \x1b[0m' + msg + '\x1b[39m' // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + callSiteToString(stack[i]) + '\x1b[39m' // cyan
    }

    return formatted
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
  }

  return formatted
}

/**
 * Format call site location.
 */

function formatLocation(callSite) {
  return relative(basePath, callSite[0])
    + ':' + callSite[1]
    + ':' + callSite[2]
}

/**
 * Get the stack as array of call sites.
 */

function getStack() {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = Math.max(10, limit)

  // capture the stack
  Error.captureStackTrace(obj)

  // slice this function off the top
  var stack = obj.stack.slice(1)

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace(obj, stack) {
  return stack
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction(fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function')
  }

  var args = createArgumentsString(fn.length)
  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  site.name = fn.name

  var deprecatedfn = eval('(function (' + args + ') {\n'
    + '"use strict"\n'
    + 'log.call(deprecate, message, site)\n'
    + 'return fn.apply(this, arguments)\n'
    + '})')

  return deprecatedfn
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty(obj, prop, message) {
  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
    throw new TypeError('argument obj must be object')
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

  if (!descriptor) {
    throw new TypeError('must call property on owner object')
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable')
  }

  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  // set site name
  site.name = prop

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop, message)
  }

  var get = descriptor.get
  var set = descriptor.set

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter() {
      log.call(deprecate, message, site)
      return get.apply(this, arguments)
    }
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter() {
      log.call(deprecate, message, site)
      return set.apply(this, arguments)
    }
  }

  Object.defineProperty(obj, prop, descriptor)
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError(namespace, message, stack) {
  var error = new Error()
  var stackString

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError
  })

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  })

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  })

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  })

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString
      }

      // prepare stack trace
      return stackString = createStackString.call(this, stack)
    },
    set: function setter(val) {
      stackString = val
    }
  })

  return error
}

},{"./lib/compat":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/depd/lib/compat/index.js","events":false,"path":false}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/depd/lib/compat/buffer-concat.js":[function(require,module,exports){
/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = bufferConcat

/**
 * Concatenate an array of Buffers.
 */

function bufferConcat(bufs) {
  var length = 0

  for (var i = 0, len = bufs.length; i < len; i++) {
    length += bufs[i].length
  }

  var buf = new Buffer(length)
  var pos = 0

  for (var i = 0, len = bufs.length; i < len; i++) {
    bufs[i].copy(buf, pos)
    pos += bufs[i].length
  }

  return buf
}

},{}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/depd/lib/compat/callsite-tostring.js":[function(require,module,exports){
/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = callSiteToString

/**
 * Format a CallSite file location to a string.
 */

function callSiteFileLocation(callSite) {
  var fileName
  var fileLocation = ''

  if (callSite.isNative()) {
    fileLocation = 'native'
  } else if (callSite.isEval()) {
    fileName = callSite.getScriptNameOrSourceURL()
    if (!fileName) {
      fileLocation = callSite.getEvalOrigin()
    }
  } else {
    fileName = callSite.getFileName()
  }

  if (fileName) {
    fileLocation += fileName

    var lineNumber = callSite.getLineNumber()
    if (lineNumber != null) {
      fileLocation += ':' + lineNumber

      var columnNumber = callSite.getColumnNumber()
      if (columnNumber) {
        fileLocation += ':' + columnNumber
      }
    }
  }

  return fileLocation || 'unknown source'
}

/**
 * Format a CallSite to a string.
 */

function callSiteToString(callSite) {
  var addSuffix = true
  var fileLocation = callSiteFileLocation(callSite)
  var functionName = callSite.getFunctionName()
  var isConstructor = callSite.isConstructor()
  var isMethodCall = !(callSite.isToplevel() || isConstructor)
  var line = ''

  if (isMethodCall) {
    var methodName = callSite.getMethodName()
    var typeName = getConstructorName(callSite)

    if (functionName) {
      if (typeName && functionName.indexOf(typeName) !== 0) {
        line += typeName + '.'
      }

      line += functionName

      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {
        line += ' [as ' + methodName + ']'
      }
    } else {
      line += typeName + '.' + (methodName || '<anonymous>')
    }
  } else if (isConstructor) {
    line += 'new ' + (functionName || '<anonymous>')
  } else if (functionName) {
    line += functionName
  } else {
    addSuffix = false
    line += fileLocation
  }

  if (addSuffix) {
    line += ' (' + fileLocation + ')'
  }

  return line
}

/**
 * Get constructor name of reviver.
 */

function getConstructorName(obj) {
  var receiver = obj.receiver
  return (receiver.constructor && receiver.constructor.name) || null
}

},{}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/depd/lib/compat/index.js":[function(require,module,exports){
/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

lazyProperty(module.exports, 'bufferConcat', function bufferConcat() {
  return Buffer.concat || require('./buffer-concat')
})

lazyProperty(module.exports, 'callSiteToString', function callSiteToString() {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  function prepareObjectStackTrace(obj, stack) {
    return stack
  }

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = 2

  // capture the stack
  Error.captureStackTrace(obj)

  // slice the stack
  var stack = obj.stack.slice()

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack[0].toString ? toString : require('./callsite-tostring')
})

/**
 * Define a lazy property.
 */

function lazyProperty(obj, prop, getter) {
  function get() {
    var val = getter()

    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      value: val
    })

    return val
  }

  Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: true,
    get: get
  })
}

/**
 * Call toString() on the obj
 */

function toString(obj) {
  return obj.toString()
}

},{"./buffer-concat":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/depd/lib/compat/buffer-concat.js","./callsite-tostring":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/depd/lib/compat/callsite-tostring.js"}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/on-finished/index.js":[function(require,module,exports){
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = onFinished;
module.exports.isFinished = isFinished;

/**
* Module dependencies.
*/

var first = require('ee-first')

/**
* Variables.
*/

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @api public
 */

function onFinished(msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener)
    return msg
  }

  // attach the listener to the message
  attachListener(msg, listener)

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @api public
 */

function isFinished(msg) {
  var socket = msg.socket

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(!socket || msg.complete || !socket.readable)
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener(msg, callback) {
  var eeMsg
  var eeSocket
  var finished = false

  function onFinish(error) {
    eeMsg.cancel()
    eeSocket.cancel()

    finished = true
    callback(error)
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

  function onSocket(socket) {
    // remove listener
    msg.removeListener('socket', onSocket)

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish)
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket)
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket)

  if (msg.socket === undefined) {
    // node.js 0.8 patch
    patchAssignSocket(msg, onSocket)
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @api private
 */

function attachListener(msg, listener) {
  var attached = msg.__onFinished

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg)
    attachFinishedListener(msg, attached)
  }

  attached.queue.push(listener)
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @api private
 */

function createListener(msg) {
  function listener(err) {
    if (msg.__onFinished === listener) msg.__onFinished = null
    if (!listener.queue) return

    var queue = listener.queue
    listener.queue = null

    for (var i = 0; i < queue.length; i++) {
      queue[i](err)
    }
  }

  listener.queue = []

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket)
    callback(socket)
  }
}

},{"ee-first":"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/on-finished/node_modules/ee-first/index.js"}],"/home/vadzim/v/work/nerojs/node_modules/morgan/node_modules/on-finished/node_modules/ee-first/index.js":[function(require,module,exports){

module.exports = function first(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = []

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i]

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0]

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j]
      var fn = listener(event, callback)

      // listen to the event
      ee.on(event, fn)
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      })
    }
  }

  function callback() {
    cleanup()
    done.apply(null, arguments)
  }

  function cleanup() {
    var x
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i]
      x.ee.removeListener(x.event, x.fn)
    }
  }

  function thunk(fn) {
    done = fn
  }

  thunk.cancel = cleanup

  return thunk
}

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length)
    var ee = this
    var err = event === 'error'
      ? arg1
      : null

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    done(err, ee, event, args)
  }
}

},{}],"/home/vadzim/v/work/nerojs/node_modules/traceur/bin/traceur-runtime.js":[function(require,module,exports){
(function(global) {
  'use strict';
  if (global.$traceurRuntime) {
    return ;
  }
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $Object.defineProperties;
  var $defineProperty = $Object.defineProperty;
  var $freeze = $Object.freeze;
  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;
  var $getOwnPropertyNames = $Object.getOwnPropertyNames;
  var $keys = $Object.keys;
  var $hasOwnProperty = $Object.prototype.hasOwnProperty;
  var $toString = $Object.prototype.toString;
  var $preventExtensions = Object.preventExtensions;
  var $seal = Object.seal;
  var $isExtensible = Object.isExtensible;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var method = nonEnum;
  var counter = 0;
  function newUniqueString() {
    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';
  }
  var symbolInternalProperty = newUniqueString();
  var symbolDescriptionProperty = newUniqueString();
  var symbolDataProperty = newUniqueString();
  var symbolValues = $create(null);
  var privateNames = $create(null);
  function isPrivateName(s) {
    return privateNames[s];
  }
  function createPrivateName() {
    var s = newUniqueString();
    privateNames[s] = true;
    return s;
  }
  function isShimSymbol(symbol) {
    return typeof symbol === 'object' && symbol instanceof SymbolValue;
  }
  function typeOf(v) {
    if (isShimSymbol(v))
      return 'symbol';
    return typeof v;
  }
  function Symbol(description) {
    var value = new SymbolValue(description);
    if (!(this instanceof Symbol))
      return value;
    throw new TypeError('Symbol cannot be new\'ed');
  }
  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));
  $defineProperty(Symbol.prototype, 'toString', method(function() {
    var symbolValue = this[symbolDataProperty];
    return symbolValue[symbolInternalProperty];
  }));
  $defineProperty(Symbol.prototype, 'valueOf', method(function() {
    var symbolValue = this[symbolDataProperty];
    if (!symbolValue)
      throw TypeError('Conversion from symbol to string');
    if (!getOption('symbols'))
      return symbolValue[symbolInternalProperty];
    return symbolValue;
  }));
  function SymbolValue(description) {
    var key = newUniqueString();
    $defineProperty(this, symbolDataProperty, {value: this});
    $defineProperty(this, symbolInternalProperty, {value: key});
    $defineProperty(this, symbolDescriptionProperty, {value: description});
    freeze(this);
    symbolValues[key] = this;
  }
  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));
  $defineProperty(SymbolValue.prototype, 'toString', {
    value: Symbol.prototype.toString,
    enumerable: false
  });
  $defineProperty(SymbolValue.prototype, 'valueOf', {
    value: Symbol.prototype.valueOf,
    enumerable: false
  });
  var hashProperty = createPrivateName();
  var hashPropertyDescriptor = {value: undefined};
  var hashObjectProperties = {
    hash: {value: undefined},
    self: {value: undefined}
  };
  var hashCounter = 0;
  function getOwnHashObject(object) {
    var hashObject = object[hashProperty];
    if (hashObject && hashObject.self === object)
      return hashObject;
    if ($isExtensible(object)) {
      hashObjectProperties.hash.value = hashCounter++;
      hashObjectProperties.self.value = object;
      hashPropertyDescriptor.value = $create(null, hashObjectProperties);
      $defineProperty(object, hashProperty, hashPropertyDescriptor);
      return hashPropertyDescriptor.value;
    }
    return undefined;
  }
  function freeze(object) {
    getOwnHashObject(object);
    return $freeze.apply(this, arguments);
  }
  function preventExtensions(object) {
    getOwnHashObject(object);
    return $preventExtensions.apply(this, arguments);
  }
  function seal(object) {
    getOwnHashObject(object);
    return $seal.apply(this, arguments);
  }
  freeze(SymbolValue.prototype);
  function isSymbolString(s) {
    return symbolValues[s] || privateNames[s];
  }
  function toProperty(name) {
    if (isShimSymbol(name))
      return name[symbolInternalProperty];
    return name;
  }
  function removeSymbolKeys(array) {
    var rv = [];
    for (var i = 0; i < array.length; i++) {
      if (!isSymbolString(array[i])) {
        rv.push(array[i]);
      }
    }
    return rv;
  }
  function getOwnPropertyNames(object) {
    return removeSymbolKeys($getOwnPropertyNames(object));
  }
  function keys(object) {
    return removeSymbolKeys($keys(object));
  }
  function getOwnPropertySymbols(object) {
    var rv = [];
    var names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var symbol = symbolValues[names[i]];
      if (symbol) {
        rv.push(symbol);
      }
    }
    return rv;
  }
  function getOwnPropertyDescriptor(object, name) {
    return $getOwnPropertyDescriptor(object, toProperty(name));
  }
  function hasOwnProperty(name) {
    return $hasOwnProperty.call(this, toProperty(name));
  }
  function getOption(name) {
    return global.$traceurRuntime.options[name];
  }
  function defineProperty(object, name, descriptor) {
    if (isShimSymbol(name)) {
      name = name[symbolInternalProperty];
    }
    $defineProperty(object, name, descriptor);
    return object;
  }
  function polyfillObject(Object) {
    $defineProperty(Object, 'defineProperty', {value: defineProperty});
    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});
    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});
    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});
    $defineProperty(Object, 'freeze', {value: freeze});
    $defineProperty(Object, 'preventExtensions', {value: preventExtensions});
    $defineProperty(Object, 'seal', {value: seal});
    $defineProperty(Object, 'keys', {value: keys});
  }
  function exportStar(object) {
    for (var i = 1; i < arguments.length; i++) {
      var names = $getOwnPropertyNames(arguments[i]);
      for (var j = 0; j < names.length; j++) {
        var name = names[j];
        if (isSymbolString(name))
          continue;
        (function(mod, name) {
          $defineProperty(object, name, {
            get: function() {
              return mod[name];
            },
            enumerable: true
          });
        })(arguments[i], names[j]);
      }
    }
    return object;
  }
  function isObject(x) {
    return x != null && (typeof x === 'object' || typeof x === 'function');
  }
  function toObject(x) {
    if (x == null)
      throw $TypeError();
    return $Object(x);
  }
  function checkObjectCoercible(argument) {
    if (argument == null) {
      throw new TypeError('Value cannot be converted to an Object');
    }
    return argument;
  }
  function polyfillSymbol(global, Symbol) {
    if (!global.Symbol) {
      global.Symbol = Symbol;
      Object.getOwnPropertySymbols = getOwnPropertySymbols;
    }
    if (!global.Symbol.iterator) {
      global.Symbol.iterator = Symbol('Symbol.iterator');
    }
  }
  function setupGlobals(global) {
    polyfillSymbol(global, Symbol);
    global.Reflect = global.Reflect || {};
    global.Reflect.global = global.Reflect.global || global;
    polyfillObject(global.Object);
  }
  setupGlobals(global);
  global.$traceurRuntime = {
    checkObjectCoercible: checkObjectCoercible,
    createPrivateName: createPrivateName,
    defineProperties: $defineProperties,
    defineProperty: $defineProperty,
    exportStar: exportStar,
    getOwnHashObject: getOwnHashObject,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    isObject: isObject,
    isPrivateName: isPrivateName,
    isSymbolString: isSymbolString,
    keys: $keys,
    options: {},
    setupGlobals: setupGlobals,
    toObject: toObject,
    toProperty: toProperty,
    typeof: typeOf
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
(function() {
  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme) {
      out.push(opt_scheme, ':');
    }
    if (opt_domain) {
      out.push('//');
      if (opt_userInfo) {
        out.push(opt_userInfo, '@');
      }
      out.push(opt_domain);
      if (opt_port) {
        out.push(':', opt_port);
      }
    }
    if (opt_path) {
      out.push(opt_path);
    }
    if (opt_queryData) {
      out.push('?', opt_queryData);
    }
    if (opt_fragment) {
      out.push('#', opt_fragment);
    }
    return out.join('');
  }
  ;
  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var ComponentIndex = {
    SCHEME: 1,
    USER_INFO: 2,
    DOMAIN: 3,
    PORT: 4,
    PATH: 5,
    QUERY_DATA: 6,
    FRAGMENT: 7
  };
  function split(uri) {
    return (uri.match(splitRe));
  }
  function removeDotSegments(path) {
    if (path === '/')
      return '/';
    var leadingSlash = path[0] === '/' ? '/' : '';
    var trailingSlash = path.slice(-1) === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length)
            out.pop();
          else
            up++;
          break;
        default:
          out.push(segment);
      }
    }
    if (!leadingSlash) {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function joinAndCanonicalizePath(parts) {
    var path = parts[ComponentIndex.PATH] || '';
    path = removeDotSegments(path);
    parts[ComponentIndex.PATH] = path;
    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);
  }
  function canonicalizeUrl(url) {
    var parts = split(url);
    return joinAndCanonicalizePath(parts);
  }
  function resolveUrl(base, url) {
    var parts = split(url);
    var baseParts = split(base);
    if (parts[ComponentIndex.SCHEME]) {
      return joinAndCanonicalizePath(parts);
    } else {
      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];
    }
    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {
      if (!parts[i]) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[ComponentIndex.PATH][0] == '/') {
      return joinAndCanonicalizePath(parts);
    }
    var path = baseParts[ComponentIndex.PATH];
    var index = path.lastIndexOf('/');
    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];
    parts[ComponentIndex.PATH] = path;
    return joinAndCanonicalizePath(parts);
  }
  function isAbsolute(name) {
    if (!name)
      return false;
    if (name[0] === '/')
      return true;
    var parts = split(name);
    if (parts[ComponentIndex.SCHEME])
      return true;
    return false;
  }
  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;
  $traceurRuntime.isAbsolute = isAbsolute;
  $traceurRuntime.removeDotSegments = removeDotSegments;
  $traceurRuntime.resolveUrl = resolveUrl;
})();
(function(global) {
  'use strict';
  var $__1 = $traceurRuntime,
      canonicalizeUrl = $__1.canonicalizeUrl,
      resolveUrl = $__1.resolveUrl,
      isAbsolute = $__1.isAbsolute;
  var moduleInstantiators = Object.create(null);
  var baseURL;
  if (global.location && global.location.href)
    baseURL = resolveUrl(global.location.href, './');
  else
    baseURL = '';
  function UncoatedModuleEntry(url, uncoatedModule) {
    this.url = url;
    this.value_ = uncoatedModule;
  }
  function ModuleEvaluationError(erroneousModuleName, cause) {
    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;
    if (!(cause instanceof ModuleEvaluationError) && cause.stack)
      this.stack = this.stripStack(cause.stack);
    else
      this.stack = '';
  }
  ModuleEvaluationError.prototype = Object.create(Error.prototype);
  ModuleEvaluationError.prototype.constructor = ModuleEvaluationError;
  ModuleEvaluationError.prototype.stripError = function(message) {
    return message.replace(/.*Error:/, this.constructor.name + ':');
  };
  ModuleEvaluationError.prototype.stripCause = function(cause) {
    if (!cause)
      return '';
    if (!cause.message)
      return cause + '';
    return this.stripError(cause.message);
  };
  ModuleEvaluationError.prototype.loadedBy = function(moduleName) {
    this.stack += '\n loaded by ' + moduleName;
  };
  ModuleEvaluationError.prototype.stripStack = function(causeStack) {
    var stack = [];
    causeStack.split('\n').some((function(frame) {
      if (/UncoatedModuleInstantiator/.test(frame))
        return true;
      stack.push(frame);
    }));
    stack[0] = this.stripError(stack[0]);
    return stack.join('\n');
  };
  function beforeLines(lines, number) {
    var result = [];
    var first = number - 3;
    if (first < 0)
      first = 0;
    for (var i = first; i < number; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function afterLines(lines, number) {
    var last = number + 1;
    if (last > lines.length - 1)
      last = lines.length - 1;
    var result = [];
    for (var i = number; i <= last; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function columnSpacing(columns) {
    var result = '';
    for (var i = 0; i < columns - 1; i++) {
      result += '-';
    }
    return result;
  }
  function UncoatedModuleInstantiator(url, func) {
    UncoatedModuleEntry.call(this, url, null);
    this.func = func;
  }
  UncoatedModuleInstantiator.prototype = Object.create(UncoatedModuleEntry.prototype);
  UncoatedModuleInstantiator.prototype.getUncoatedModule = function() {
    if (this.value_)
      return this.value_;
    try {
      var relativeRequire;
      if (typeof $traceurRuntime !== undefined && $traceurRuntime.require) {
        relativeRequire = $traceurRuntime.require.bind(null, this.url);
      }
      return this.value_ = this.func.call(global, relativeRequire);
    } catch (ex) {
      if (ex instanceof ModuleEvaluationError) {
        ex.loadedBy(this.url);
        throw ex;
      }
      if (ex.stack) {
        var lines = this.func.toString().split('\n');
        var evaled = [];
        ex.stack.split('\n').some(function(frame) {
          if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)
            return true;
          var m = /(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(frame);
          if (m) {
            var line = parseInt(m[2], 10);
            evaled = evaled.concat(beforeLines(lines, line));
            evaled.push(columnSpacing(m[3]) + '^');
            evaled = evaled.concat(afterLines(lines, line));
            evaled.push('= = = = = = = = =');
          } else {
            evaled.push(frame);
          }
        });
        ex.stack = evaled.join('\n');
      }
      throw new ModuleEvaluationError(this.url, ex);
    }
  };
  function getUncoatedModuleInstantiator(name) {
    if (!name)
      return ;
    var url = ModuleStore.normalize(name);
    return moduleInstantiators[url];
  }
  ;
  var moduleInstances = Object.create(null);
  var liveModuleSentinel = {};
  function Module(uncoatedModule) {
    var isLive = arguments[1];
    var coatedModule = Object.create(null);
    Object.getOwnPropertyNames(uncoatedModule).forEach((function(name) {
      var getter,
          value;
      if (isLive === liveModuleSentinel) {
        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);
        if (descr.get)
          getter = descr.get;
      }
      if (!getter) {
        value = uncoatedModule[name];
        getter = function() {
          return value;
        };
      }
      Object.defineProperty(coatedModule, name, {
        get: getter,
        enumerable: true
      });
    }));
    Object.preventExtensions(coatedModule);
    return coatedModule;
  }
  var ModuleStore = {
    normalize: function(name, refererName, refererAddress) {
      if (typeof name !== 'string')
        throw new TypeError('module name must be a string, not ' + typeof name);
      if (isAbsolute(name))
        return canonicalizeUrl(name);
      if (/[^\.]\/\.\.\//.test(name)) {
        throw new Error('module name embeds /../: ' + name);
      }
      if (name[0] === '.' && refererName)
        return resolveUrl(refererName, name);
      return canonicalizeUrl(name);
    },
    get: function(normalizedName) {
      var m = getUncoatedModuleInstantiator(normalizedName);
      if (!m)
        return undefined;
      var moduleInstance = moduleInstances[m.url];
      if (moduleInstance)
        return moduleInstance;
      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);
      return moduleInstances[m.url] = moduleInstance;
    },
    set: function(normalizedName, module) {
      normalizedName = String(normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, (function() {
        return module;
      }));
      moduleInstances[normalizedName] = module;
    },
    get baseURL() {
      return baseURL;
    },
    set baseURL(v) {
      baseURL = String(v);
    },
    registerModule: function(name, deps, func) {
      var normalizedName = ModuleStore.normalize(name);
      if (moduleInstantiators[normalizedName])
        throw new Error('duplicate module named ' + normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);
    },
    bundleStore: Object.create(null),
    register: function(name, deps, func) {
      if (!deps || !deps.length && !func.length) {
        this.registerModule(name, deps, func);
      } else {
        this.bundleStore[name] = {
          deps: deps,
          execute: function() {
            var $__0 = arguments;
            var depMap = {};
            deps.forEach((function(dep, index) {
              return depMap[dep] = $__0[index];
            }));
            var registryEntry = func.call(this, depMap);
            registryEntry.execute.call(this);
            return registryEntry.exports;
          }
        };
      }
    },
    getAnonymousModule: function(func) {
      return new Module(func.call(global), liveModuleSentinel);
    },
    getForTesting: function(name) {
      var $__0 = this;
      if (!this.testingPrefix_) {
        Object.keys(moduleInstances).some((function(key) {
          var m = /(traceur@[^\/]*\/)/.exec(key);
          if (m) {
            $__0.testingPrefix_ = m[1];
            return true;
          }
        }));
      }
      return this.get(this.testingPrefix_ + name);
    }
  };
  var moduleStoreModule = new Module({ModuleStore: ModuleStore});
  ModuleStore.set('@traceur/src/runtime/ModuleStore', moduleStoreModule);
  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
  };
  $traceurRuntime.ModuleStore = ModuleStore;
  global.System = {
    register: ModuleStore.register.bind(ModuleStore),
    registerModule: ModuleStore.registerModule.bind(ModuleStore),
    get: ModuleStore.get,
    set: ModuleStore.set,
    normalize: ModuleStore.normalize
  };
  $traceurRuntime.getModuleImpl = function(name) {
    var instantiator = getUncoatedModuleInstantiator(name);
    return instantiator && instantiator.getUncoatedModule();
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
System.registerModule("traceur-runtime@0.0.84/src/runtime/classes.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/classes.js";
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $traceurRuntime.defineProperties;
  var $defineProperty = $traceurRuntime.defineProperty;
  var $getOwnPropertyDescriptor = $traceurRuntime.getOwnPropertyDescriptor;
  var $getOwnPropertyNames = $traceurRuntime.getOwnPropertyNames;
  var $getPrototypeOf = Object.getPrototypeOf;
  var $__0 = Object,
      getOwnPropertyNames = $__0.getOwnPropertyNames,
      getOwnPropertySymbols = $__0.getOwnPropertySymbols;
  function superDescriptor(homeObject, name) {
    var proto = $getPrototypeOf(homeObject);
    do {
      var result = $getOwnPropertyDescriptor(proto, name);
      if (result)
        return result;
      proto = $getPrototypeOf(proto);
    } while (proto);
    return undefined;
  }
  function superConstructor(ctor) {
    return ctor.__proto__;
  }
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      if (!descriptor.get)
        return descriptor.value;
      return descriptor.get.call(self);
    }
    return undefined;
  }
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return value;
    }
    throw $TypeError(("super has no setter '" + name + "'."));
  }
  function getDescriptors(object) {
    var descriptors = {};
    var names = getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      descriptors[name] = $getOwnPropertyDescriptor(object, name);
    }
    var symbols = getOwnPropertySymbols(object);
    for (var i = 0; i < symbols.length; i++) {
      var symbol = symbols[i];
      descriptors[$traceurRuntime.toProperty(symbol)] = $getOwnPropertyDescriptor(object, $traceurRuntime.toProperty(symbol));
    }
    return descriptors;
  }
  function createClass(ctor, object, staticObject, superClass) {
    $defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function')
        ctor.__proto__ = superClass;
      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));
    } else {
      ctor.prototype = object;
    }
    $defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return $defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null)
        return superClass.prototype;
      throw new $TypeError('super prototype must be an Object or null');
    }
    if (superClass === null)
      return null;
    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
  }
  $traceurRuntime.createClass = createClass;
  $traceurRuntime.superConstructor = superConstructor;
  $traceurRuntime.superGet = superGet;
  $traceurRuntime.superSet = superSet;
  return {};
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/destructuring.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/destructuring.js";
  function iteratorToArray(iter) {
    var rv = [];
    var i = 0;
    var tmp;
    while (!(tmp = iter.next()).done) {
      rv[i++] = tmp.value;
    }
    return rv;
  }
  $traceurRuntime.iteratorToArray = iteratorToArray;
  return {};
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/generators.js";
  if (typeof $traceurRuntime !== 'object') {
    throw new Error('traceur runtime not found.');
  }
  var createPrivateName = $traceurRuntime.createPrivateName;
  var $defineProperties = $traceurRuntime.defineProperties;
  var $defineProperty = $traceurRuntime.defineProperty;
  var $create = Object.create;
  var $TypeError = TypeError;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var ST_NEWBORN = 0;
  var ST_EXECUTING = 1;
  var ST_SUSPENDED = 2;
  var ST_CLOSED = 3;
  var END_STATE = -2;
  var RETHROW_STATE = -3;
  function getInternalError(state) {
    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);
  }
  var RETURN_SENTINEL = {};
  function GeneratorContext() {
    this.state = 0;
    this.GState = ST_NEWBORN;
    this.storedException = undefined;
    this.finallyFallThrough = undefined;
    this.sent_ = undefined;
    this.returnValue = undefined;
    this.oldReturnValue = undefined;
    this.tryStack_ = [];
  }
  GeneratorContext.prototype = {
    pushTry: function(catchState, finallyState) {
      if (finallyState !== null) {
        var finallyFallThrough = null;
        for (var i = this.tryStack_.length - 1; i >= 0; i--) {
          if (this.tryStack_[i].catch !== undefined) {
            finallyFallThrough = this.tryStack_[i].catch;
            break;
          }
        }
        if (finallyFallThrough === null)
          finallyFallThrough = RETHROW_STATE;
        this.tryStack_.push({
          finally: finallyState,
          finallyFallThrough: finallyFallThrough
        });
      }
      if (catchState !== null) {
        this.tryStack_.push({catch: catchState});
      }
    },
    popTry: function() {
      this.tryStack_.pop();
    },
    get sent() {
      this.maybeThrow();
      return this.sent_;
    },
    set sent(v) {
      this.sent_ = v;
    },
    get sentIgnoreThrow() {
      return this.sent_;
    },
    maybeThrow: function() {
      if (this.action === 'throw') {
        this.action = 'next';
        throw this.sent_;
      }
    },
    end: function() {
      switch (this.state) {
        case END_STATE:
          return this;
        case RETHROW_STATE:
          throw this.storedException;
        default:
          throw getInternalError(this.state);
      }
    },
    handleException: function(ex) {
      this.GState = ST_CLOSED;
      this.state = END_STATE;
      throw ex;
    },
    wrapYieldStar: function(iterator) {
      var ctx = this;
      return {
        next: function(v) {
          return iterator.next(v);
        },
        throw: function(e) {
          var result;
          if (e === RETURN_SENTINEL) {
            if (iterator.return) {
              result = iterator.return(ctx.returnValue);
              if (!result.done) {
                ctx.returnValue = ctx.oldReturnValue;
                return result;
              }
              ctx.returnValue = result.value;
            }
            throw e;
          }
          if (iterator.throw) {
            return iterator.throw(e);
          }
          iterator.return && iterator.return();
          throw $TypeError('Inner iterator does not have a throw method');
        }
      };
    }
  };
  function nextOrThrow(ctx, moveNext, action, x) {
    switch (ctx.GState) {
      case ST_EXECUTING:
        throw new Error(("\"" + action + "\" on executing generator"));
      case ST_CLOSED:
        if (action == 'next') {
          return {
            value: undefined,
            done: true
          };
        }
        if (x === RETURN_SENTINEL) {
          return {
            value: ctx.returnValue,
            done: true
          };
        }
        throw x;
      case ST_NEWBORN:
        if (action === 'throw') {
          ctx.GState = ST_CLOSED;
          if (x === RETURN_SENTINEL) {
            return {
              value: ctx.returnValue,
              done: true
            };
          }
          throw x;
        }
        if (x !== undefined)
          throw $TypeError('Sent value to newborn generator');
      case ST_SUSPENDED:
        ctx.GState = ST_EXECUTING;
        ctx.action = action;
        ctx.sent = x;
        var value;
        try {
          value = moveNext(ctx);
        } catch (ex) {
          if (ex === RETURN_SENTINEL) {
            value = ctx;
          } else {
            throw ex;
          }
        }
        var done = value === ctx;
        if (done)
          value = ctx.returnValue;
        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;
        return {
          value: value,
          done: done
        };
    }
  }
  var ctxName = createPrivateName();
  var moveNextName = createPrivateName();
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  $defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));
  GeneratorFunctionPrototype.prototype = {
    constructor: GeneratorFunctionPrototype,
    next: function(v) {
      return nextOrThrow(this[ctxName], this[moveNextName], 'next', v);
    },
    throw: function(v) {
      return nextOrThrow(this[ctxName], this[moveNextName], 'throw', v);
    },
    return: function(v) {
      this[ctxName].oldReturnValue = this[ctxName].returnValue;
      this[ctxName].returnValue = v;
      return nextOrThrow(this[ctxName], this[moveNextName], 'throw', RETURN_SENTINEL);
    }
  };
  $defineProperties(GeneratorFunctionPrototype.prototype, {
    constructor: {enumerable: false},
    next: {enumerable: false},
    throw: {enumerable: false},
    return: {enumerable: false}
  });
  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {
    return this;
  }));
  function createGeneratorInstance(innerFunction, functionObject, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new GeneratorContext();
    var object = $create(functionObject.prototype);
    object[ctxName] = ctx;
    object[moveNextName] = moveNext;
    return object;
  }
  function initGeneratorFunction(functionObject) {
    functionObject.prototype = $create(GeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = GeneratorFunctionPrototype;
    return functionObject;
  }
  function AsyncFunctionContext() {
    GeneratorContext.call(this);
    this.err = undefined;
    var ctx = this;
    ctx.result = new Promise(function(resolve, reject) {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
  }
  AsyncFunctionContext.prototype = $create(GeneratorContext.prototype);
  AsyncFunctionContext.prototype.end = function() {
    switch (this.state) {
      case END_STATE:
        this.resolve(this.returnValue);
        break;
      case RETHROW_STATE:
        this.reject(this.storedException);
        break;
      default:
        this.reject(getInternalError(this.state));
    }
  };
  AsyncFunctionContext.prototype.handleException = function() {
    this.state = RETHROW_STATE;
  };
  function asyncWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new AsyncFunctionContext();
    ctx.createCallback = function(newState) {
      return function(value) {
        ctx.state = newState;
        ctx.value = value;
        moveNext(ctx);
      };
    };
    ctx.errback = function(err) {
      handleCatch(ctx, err);
      moveNext(ctx);
    };
    moveNext(ctx);
    return ctx.result;
  }
  function getMoveNext(innerFunction, self) {
    return function(ctx) {
      while (true) {
        try {
          return innerFunction.call(self, ctx);
        } catch (ex) {
          handleCatch(ctx, ex);
        }
      }
    };
  }
  function handleCatch(ctx, ex) {
    ctx.storedException = ex;
    var last = ctx.tryStack_[ctx.tryStack_.length - 1];
    if (!last) {
      ctx.handleException(ex);
      return ;
    }
    ctx.state = (ex !== RETURN_SENTINEL && last.catch !== undefined) ? last.catch : last.finally;
    if (last.finallyFallThrough !== undefined)
      ctx.finallyFallThrough = last.finallyFallThrough;
  }
  $traceurRuntime.asyncWrap = asyncWrap;
  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;
  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;
  return {};
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/relativeRequire.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/relativeRequire.js";
  var path;
  function relativeRequire(callerPath, requiredPath) {
    path = path || typeof require !== 'undefined' && require('path');
    function isDirectory(path) {
      return path.slice(-1) === '/';
    }
    function isAbsolute(path) {
      return path[0] === '/';
    }
    function isRelative(path) {
      return path[0] === '.';
    }
    if (isDirectory(requiredPath) || isAbsolute(requiredPath))
      return ;
    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);
  }
  $traceurRuntime.require = relativeRequire;
  return {};
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/spread.js";
  function spread() {
    var rv = [],
        j = 0,
        iterResult;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = $traceurRuntime.checkObjectCoercible(arguments[i]);
      if (typeof valueToSpread[$traceurRuntime.toProperty(Symbol.iterator)] !== 'function') {
        throw new TypeError('Cannot spread non-iterable object.');
      }
      var iter = valueToSpread[$traceurRuntime.toProperty(Symbol.iterator)]();
      while (!(iterResult = iter.next()).done) {
        rv[j++] = iterResult.value;
      }
    }
    return rv;
  }
  $traceurRuntime.spread = spread;
  return {};
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/type-assertions.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/type-assertions.js";
  var types = {
    any: {name: 'any'},
    boolean: {name: 'boolean'},
    number: {name: 'number'},
    string: {name: 'string'},
    symbol: {name: 'symbol'},
    void: {name: 'void'}
  };
  var GenericType = function GenericType(type, argumentTypes) {
    this.type = type;
    this.argumentTypes = argumentTypes;
  };
  ($traceurRuntime.createClass)(GenericType, {}, {});
  var typeRegister = Object.create(null);
  function genericType(type) {
    for (var argumentTypes = [],
        $__1 = 1; $__1 < arguments.length; $__1++)
      argumentTypes[$__1 - 1] = arguments[$__1];
    var typeMap = typeRegister;
    var key = $traceurRuntime.getOwnHashObject(type).hash;
    if (!typeMap[key]) {
      typeMap[key] = Object.create(null);
    }
    typeMap = typeMap[key];
    for (var i = 0; i < argumentTypes.length - 1; i++) {
      key = $traceurRuntime.getOwnHashObject(argumentTypes[i]).hash;
      if (!typeMap[key]) {
        typeMap[key] = Object.create(null);
      }
      typeMap = typeMap[key];
    }
    var tail = argumentTypes[argumentTypes.length - 1];
    key = $traceurRuntime.getOwnHashObject(tail).hash;
    if (!typeMap[key]) {
      typeMap[key] = new GenericType(type, argumentTypes);
    }
    return typeMap[key];
  }
  $traceurRuntime.GenericType = GenericType;
  $traceurRuntime.genericType = genericType;
  $traceurRuntime.type = types;
  return {};
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/runtime-modules.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/runtime-modules.js";
  System.get("traceur-runtime@0.0.84/src/runtime/relativeRequire.js");
  System.get("traceur-runtime@0.0.84/src/runtime/spread.js");
  System.get("traceur-runtime@0.0.84/src/runtime/destructuring.js");
  System.get("traceur-runtime@0.0.84/src/runtime/classes.js");
  System.get("traceur-runtime@0.0.84/src/runtime/generators.js");
  System.get("traceur-runtime@0.0.84/src/runtime/type-assertions.js");
  return {};
});
System.get("traceur-runtime@0.0.84/src/runtime/runtime-modules.js" + '');
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/utils.js";
  var $ceil = Math.ceil;
  var $floor = Math.floor;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $pow = Math.pow;
  var $min = Math.min;
  var toObject = $traceurRuntime.toObject;
  function toUint32(x) {
    return x >>> 0;
  }
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function isCallable(x) {
    return typeof x === 'function';
  }
  function isNumber(x) {
    return typeof x === 'number';
  }
  function toInteger(x) {
    x = +x;
    if ($isNaN(x))
      return 0;
    if (x === 0 || !$isFinite(x))
      return x;
    return x > 0 ? $floor(x) : $ceil(x);
  }
  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;
  function toLength(x) {
    var len = toInteger(x);
    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);
  }
  function checkIterable(x) {
    return !isObject(x) ? undefined : x[Symbol.iterator];
  }
  function isConstructor(x) {
    return isCallable(x);
  }
  function createIteratorResultObject(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function maybeDefine(object, name, descr) {
    if (!(name in object)) {
      Object.defineProperty(object, name, descr);
    }
  }
  function maybeDefineMethod(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  function maybeDefineConst(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: false,
      enumerable: false,
      writable: false
    });
  }
  function maybeAddFunctions(object, functions) {
    for (var i = 0; i < functions.length; i += 2) {
      var name = functions[i];
      var value = functions[i + 1];
      maybeDefineMethod(object, name, value);
    }
  }
  function maybeAddConsts(object, consts) {
    for (var i = 0; i < consts.length; i += 2) {
      var name = consts[i];
      var value = consts[i + 1];
      maybeDefineConst(object, name, value);
    }
  }
  function maybeAddIterator(object, func, Symbol) {
    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])
      return ;
    if (object['@@iterator'])
      func = object['@@iterator'];
    Object.defineProperty(object, Symbol.iterator, {
      value: func,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  var polyfills = [];
  function registerPolyfill(func) {
    polyfills.push(func);
  }
  function polyfillAll(global) {
    polyfills.forEach((function(f) {
      return f(global);
    }));
  }
  return {
    get toObject() {
      return toObject;
    },
    get toUint32() {
      return toUint32;
    },
    get isObject() {
      return isObject;
    },
    get isCallable() {
      return isCallable;
    },
    get isNumber() {
      return isNumber;
    },
    get toInteger() {
      return toInteger;
    },
    get toLength() {
      return toLength;
    },
    get checkIterable() {
      return checkIterable;
    },
    get isConstructor() {
      return isConstructor;
    },
    get createIteratorResultObject() {
      return createIteratorResultObject;
    },
    get maybeDefine() {
      return maybeDefine;
    },
    get maybeDefineMethod() {
      return maybeDefineMethod;
    },
    get maybeDefineConst() {
      return maybeDefineConst;
    },
    get maybeAddFunctions() {
      return maybeAddFunctions;
    },
    get maybeAddConsts() {
      return maybeAddConsts;
    },
    get maybeAddIterator() {
      return maybeAddIterator;
    },
    get registerPolyfill() {
      return registerPolyfill;
    },
    get polyfillAll() {
      return polyfillAll;
    }
  };
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/Map.js";
  var $__0 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      isObject = $__0.isObject,
      maybeAddIterator = $__0.maybeAddIterator,
      registerPolyfill = $__0.registerPolyfill;
  var getOwnHashObject = $traceurRuntime.getOwnHashObject;
  var $hasOwnProperty = Object.prototype.hasOwnProperty;
  var deletedSentinel = {};
  function lookupIndex(map, key) {
    if (isObject(key)) {
      var hashObject = getOwnHashObject(key);
      return hashObject && map.objectIndex_[hashObject.hash];
    }
    if (typeof key === 'string')
      return map.stringIndex_[key];
    return map.primitiveIndex_[key];
  }
  function initMap(map) {
    map.entries_ = [];
    map.objectIndex_ = Object.create(null);
    map.stringIndex_ = Object.create(null);
    map.primitiveIndex_ = Object.create(null);
    map.deletedCount_ = 0;
  }
  var Map = function Map() {
    var $__5,
        $__6;
    var iterable = arguments[0];
    if (!isObject(this))
      throw new TypeError('Map called on incompatible type');
    if ($hasOwnProperty.call(this, 'entries_')) {
      throw new TypeError('Map can not be reentrantly initialised');
    }
    initMap(this);
    if (iterable !== null && iterable !== undefined) {
      for (var $__2 = iterable[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__3 = void 0; !($__3 = $__2.next()).done; ) {
        var $__4 = $__3.value,
            key = ($__5 = $__4[$traceurRuntime.toProperty(Symbol.iterator)](), ($__6 = $__5.next()).done ? void 0 : $__6.value),
            value = ($__6 = $__5.next()).done ? void 0 : $__6.value;
        {
          this.set(key, value);
        }
      }
    }
  };
  ($traceurRuntime.createClass)(Map, {
    get size() {
      return this.entries_.length / 2 - this.deletedCount_;
    },
    get: function(key) {
      var index = lookupIndex(this, key);
      if (index !== undefined)
        return this.entries_[index + 1];
    },
    set: function(key, value) {
      var objectMode = isObject(key);
      var stringMode = typeof key === 'string';
      var index = lookupIndex(this, key);
      if (index !== undefined) {
        this.entries_[index + 1] = value;
      } else {
        index = this.entries_.length;
        this.entries_[index] = key;
        this.entries_[index + 1] = value;
        if (objectMode) {
          var hashObject = getOwnHashObject(key);
          var hash = hashObject.hash;
          this.objectIndex_[hash] = index;
        } else if (stringMode) {
          this.stringIndex_[key] = index;
        } else {
          this.primitiveIndex_[key] = index;
        }
      }
      return this;
    },
    has: function(key) {
      return lookupIndex(this, key) !== undefined;
    },
    delete: function(key) {
      var objectMode = isObject(key);
      var stringMode = typeof key === 'string';
      var index;
      var hash;
      if (objectMode) {
        var hashObject = getOwnHashObject(key);
        if (hashObject) {
          index = this.objectIndex_[hash = hashObject.hash];
          delete this.objectIndex_[hash];
        }
      } else if (stringMode) {
        index = this.stringIndex_[key];
        delete this.stringIndex_[key];
      } else {
        index = this.primitiveIndex_[key];
        delete this.primitiveIndex_[key];
      }
      if (index !== undefined) {
        this.entries_[index] = deletedSentinel;
        this.entries_[index + 1] = undefined;
        this.deletedCount_++;
        return true;
      }
      return false;
    },
    clear: function() {
      initMap(this);
    },
    forEach: function(callbackFn) {
      var thisArg = arguments[1];
      for (var i = 0; i < this.entries_.length; i += 2) {
        var key = this.entries_[i];
        var value = this.entries_[i + 1];
        if (key === deletedSentinel)
          continue;
        callbackFn.call(thisArg, value, key, this);
      }
    },
    entries: $traceurRuntime.initGeneratorFunction(function $__7() {
      var i,
          key,
          value;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 12;
              break;
            case 12:
              $ctx.state = (i < this.entries_.length) ? 8 : -2;
              break;
            case 4:
              i += 2;
              $ctx.state = 12;
              break;
            case 8:
              key = this.entries_[i];
              value = this.entries_[i + 1];
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = (key === deletedSentinel) ? 4 : 6;
              break;
            case 6:
              $ctx.state = 2;
              return [key, value];
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__7, this);
    }),
    keys: $traceurRuntime.initGeneratorFunction(function $__8() {
      var i,
          key,
          value;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 12;
              break;
            case 12:
              $ctx.state = (i < this.entries_.length) ? 8 : -2;
              break;
            case 4:
              i += 2;
              $ctx.state = 12;
              break;
            case 8:
              key = this.entries_[i];
              value = this.entries_[i + 1];
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = (key === deletedSentinel) ? 4 : 6;
              break;
            case 6:
              $ctx.state = 2;
              return key;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__8, this);
    }),
    values: $traceurRuntime.initGeneratorFunction(function $__9() {
      var i,
          key,
          value;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 12;
              break;
            case 12:
              $ctx.state = (i < this.entries_.length) ? 8 : -2;
              break;
            case 4:
              i += 2;
              $ctx.state = 12;
              break;
            case 8:
              key = this.entries_[i];
              value = this.entries_[i + 1];
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = (key === deletedSentinel) ? 4 : 6;
              break;
            case 6:
              $ctx.state = 2;
              return value;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__9, this);
    })
  }, {});
  Object.defineProperty(Map.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Map.prototype.entries
  });
  function polyfillMap(global) {
    var $__4 = global,
        Object = $__4.Object,
        Symbol = $__4.Symbol;
    if (!global.Map)
      global.Map = Map;
    var mapPrototype = global.Map.prototype;
    if (mapPrototype.entries === undefined)
      global.Map = Map;
    if (mapPrototype.entries) {
      maybeAddIterator(mapPrototype, mapPrototype.entries, Symbol);
      maybeAddIterator(Object.getPrototypeOf(new global.Map().entries()), function() {
        return this;
      }, Symbol);
    }
  }
  registerPolyfill(polyfillMap);
  return {
    get Map() {
      return Map;
    },
    get polyfillMap() {
      return polyfillMap;
    }
  };
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Map.js" + '');
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Set.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/Set.js";
  var $__0 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      isObject = $__0.isObject,
      maybeAddIterator = $__0.maybeAddIterator,
      registerPolyfill = $__0.registerPolyfill;
  var Map = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Map.js").Map;
  var getOwnHashObject = $traceurRuntime.getOwnHashObject;
  var $hasOwnProperty = Object.prototype.hasOwnProperty;
  function initSet(set) {
    set.map_ = new Map();
  }
  var Set = function Set() {
    var iterable = arguments[0];
    if (!isObject(this))
      throw new TypeError('Set called on incompatible type');
    if ($hasOwnProperty.call(this, 'map_')) {
      throw new TypeError('Set can not be reentrantly initialised');
    }
    initSet(this);
    if (iterable !== null && iterable !== undefined) {
      for (var $__4 = iterable[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__5 = void 0; !($__5 = $__4.next()).done; ) {
        var item = $__5.value;
        {
          this.add(item);
        }
      }
    }
  };
  ($traceurRuntime.createClass)(Set, {
    get size() {
      return this.map_.size;
    },
    has: function(key) {
      return this.map_.has(key);
    },
    add: function(key) {
      this.map_.set(key, key);
      return this;
    },
    delete: function(key) {
      return this.map_.delete(key);
    },
    clear: function() {
      return this.map_.clear();
    },
    forEach: function(callbackFn) {
      var thisArg = arguments[1];
      var $__2 = this;
      return this.map_.forEach((function(value, key) {
        callbackFn.call(thisArg, key, key, $__2);
      }));
    },
    values: $traceurRuntime.initGeneratorFunction(function $__7() {
      var $__8,
          $__9;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $__8 = $ctx.wrapYieldStar(this.map_.keys()[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__9 = $__8[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__9.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__9.value;
              $ctx.state = -2;
              break;
            case 2:
              $ctx.state = 12;
              return $__9.value;
            default:
              return $ctx.end();
          }
      }, $__7, this);
    }),
    entries: $traceurRuntime.initGeneratorFunction(function $__10() {
      var $__11,
          $__12;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $__11 = $ctx.wrapYieldStar(this.map_.entries()[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__12 = $__11[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__12.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__12.value;
              $ctx.state = -2;
              break;
            case 2:
              $ctx.state = 12;
              return $__12.value;
            default:
              return $ctx.end();
          }
      }, $__10, this);
    })
  }, {});
  Object.defineProperty(Set.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  Object.defineProperty(Set.prototype, 'keys', {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  function polyfillSet(global) {
    var $__6 = global,
        Object = $__6.Object,
        Symbol = $__6.Symbol;
    if (!global.Set)
      global.Set = Set;
    var setPrototype = global.Set.prototype;
    if (setPrototype.values) {
      maybeAddIterator(setPrototype, setPrototype.values, Symbol);
      maybeAddIterator(Object.getPrototypeOf(new global.Set().values()), function() {
        return this;
      }, Symbol);
    }
  }
  registerPolyfill(polyfillSet);
  return {
    get Set() {
      return Set;
    },
    get polyfillSet() {
      return polyfillSet;
    }
  };
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Set.js" + '');
System.registerModule("traceur-runtime@0.0.84/node_modules/rsvp/lib/rsvp/asap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/node_modules/rsvp/lib/rsvp/asap.js";
  var len = 0;
  function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      scheduleFlush();
    }
  }
  var $__default = asap;
  var browserGlobal = (typeof window !== 'undefined') ? window : {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
  function useNextTick() {
    return function() {
      process.nextTick(flush);
    };
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {characterData: true});
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function() {
      channel.port2.postMessage(0);
    };
  }
  function useSetTimeout() {
    return function() {
      setTimeout(flush, 1);
    };
  }
  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }
    len = 0;
  }
  var scheduleFlush;
  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else {
    scheduleFlush = useSetTimeout();
  }
  return {get default() {
      return $__default;
    }};
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Promise.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/Promise.js";
  var async = System.get("traceur-runtime@0.0.84/node_modules/rsvp/lib/rsvp/asap.js").default;
  var registerPolyfill = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js").registerPolyfill;
  var promiseRaw = {};
  function isPromise(x) {
    return x && typeof x === 'object' && x.status_ !== undefined;
  }
  function idResolveHandler(x) {
    return x;
  }
  function idRejectHandler(x) {
    throw x;
  }
  function chain(promise) {
    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;
    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;
    var deferred = getDeferred(promise.constructor);
    switch (promise.status_) {
      case undefined:
        throw TypeError;
      case 0:
        promise.onResolve_.push(onResolve, deferred);
        promise.onReject_.push(onReject, deferred);
        break;
      case +1:
        promiseEnqueue(promise.value_, [onResolve, deferred]);
        break;
      case -1:
        promiseEnqueue(promise.value_, [onReject, deferred]);
        break;
    }
    return deferred.promise;
  }
  function getDeferred(C) {
    if (this === $Promise) {
      var promise = promiseInit(new $Promise(promiseRaw));
      return {
        promise: promise,
        resolve: (function(x) {
          promiseResolve(promise, x);
        }),
        reject: (function(r) {
          promiseReject(promise, r);
        })
      };
    } else {
      var result = {};
      result.promise = new C((function(resolve, reject) {
        result.resolve = resolve;
        result.reject = reject;
      }));
      return result;
    }
  }
  function promiseSet(promise, status, value, onResolve, onReject) {
    promise.status_ = status;
    promise.value_ = value;
    promise.onResolve_ = onResolve;
    promise.onReject_ = onReject;
    return promise;
  }
  function promiseInit(promise) {
    return promiseSet(promise, 0, undefined, [], []);
  }
  var Promise = function Promise(resolver) {
    if (resolver === promiseRaw)
      return ;
    if (typeof resolver !== 'function')
      throw new TypeError;
    var promise = promiseInit(this);
    try {
      resolver((function(x) {
        promiseResolve(promise, x);
      }), (function(r) {
        promiseReject(promise, r);
      }));
    } catch (e) {
      promiseReject(promise, e);
    }
  };
  ($traceurRuntime.createClass)(Promise, {
    catch: function(onReject) {
      return this.then(undefined, onReject);
    },
    then: function(onResolve, onReject) {
      if (typeof onResolve !== 'function')
        onResolve = idResolveHandler;
      if (typeof onReject !== 'function')
        onReject = idRejectHandler;
      var that = this;
      var constructor = this.constructor;
      return chain(this, function(x) {
        x = promiseCoerce(constructor, x);
        return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);
      }, onReject);
    }
  }, {
    resolve: function(x) {
      if (this === $Promise) {
        if (isPromise(x)) {
          return x;
        }
        return promiseSet(new $Promise(promiseRaw), +1, x);
      } else {
        return new this(function(resolve, reject) {
          resolve(x);
        });
      }
    },
    reject: function(r) {
      if (this === $Promise) {
        return promiseSet(new $Promise(promiseRaw), -1, r);
      } else {
        return new this((function(resolve, reject) {
          reject(r);
        }));
      }
    },
    all: function(values) {
      var deferred = getDeferred(this);
      var resolutions = [];
      try {
        var makeCountdownFunction = function(i) {
          return (function(x) {
            resolutions[i] = x;
            if (--count === 0)
              deferred.resolve(resolutions);
          });
        };
        var count = 0;
        var i = 0;
        for (var $__3 = values[$traceurRuntime.toProperty(Symbol.iterator)](),
            $__4 = void 0; !($__4 = $__3.next()).done; ) {
          var value = $__4.value;
          {
            var countdownFunction = makeCountdownFunction(i);
            this.resolve(value).then(countdownFunction, (function(r) {
              deferred.reject(r);
            }));
            ++i;
            ++count;
          }
        }
        if (count === 0) {
          deferred.resolve(resolutions);
        }
      } catch (e) {
        deferred.reject(e);
      }
      return deferred.promise;
    },
    race: function(values) {
      var deferred = getDeferred(this);
      try {
        for (var i = 0; i < values.length; i++) {
          this.resolve(values[i]).then((function(x) {
            deferred.resolve(x);
          }), (function(r) {
            deferred.reject(r);
          }));
        }
      } catch (e) {
        deferred.reject(e);
      }
      return deferred.promise;
    }
  });
  var $Promise = Promise;
  var $PromiseReject = $Promise.reject;
  function promiseResolve(promise, x) {
    promiseDone(promise, +1, x, promise.onResolve_);
  }
  function promiseReject(promise, r) {
    promiseDone(promise, -1, r, promise.onReject_);
  }
  function promiseDone(promise, status, value, reactions) {
    if (promise.status_ !== 0)
      return ;
    promiseEnqueue(value, reactions);
    promiseSet(promise, status, value);
  }
  function promiseEnqueue(value, tasks) {
    async((function() {
      for (var i = 0; i < tasks.length; i += 2) {
        promiseHandle(value, tasks[i], tasks[i + 1]);
      }
    }));
  }
  function promiseHandle(value, handler, deferred) {
    try {
      var result = handler(value);
      if (result === deferred.promise)
        throw new TypeError;
      else if (isPromise(result))
        chain(result, deferred.resolve, deferred.reject);
      else
        deferred.resolve(result);
    } catch (e) {
      try {
        deferred.reject(e);
      } catch (e) {}
    }
  }
  var thenableSymbol = '@@thenable';
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function promiseCoerce(constructor, x) {
    if (!isPromise(x) && isObject(x)) {
      var then;
      try {
        then = x.then;
      } catch (r) {
        var promise = $PromiseReject.call(constructor, r);
        x[thenableSymbol] = promise;
        return promise;
      }
      if (typeof then === 'function') {
        var p = x[thenableSymbol];
        if (p) {
          return p;
        } else {
          var deferred = getDeferred(constructor);
          x[thenableSymbol] = deferred.promise;
          try {
            then.call(x, deferred.resolve, deferred.reject);
          } catch (r) {
            deferred.reject(r);
          }
          return deferred.promise;
        }
      }
    }
    return x;
  }
  function polyfillPromise(global) {
    if (!global.Promise)
      global.Promise = Promise;
  }
  registerPolyfill(polyfillPromise);
  return {
    get Promise() {
      return Promise;
    },
    get polyfillPromise() {
      return polyfillPromise;
    }
  };
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Promise.js" + '');
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/StringIterator.js", [], function() {
  "use strict";
  var $__2;
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/StringIterator.js";
  var $__0 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      createIteratorResultObject = $__0.createIteratorResultObject,
      isObject = $__0.isObject;
  var toProperty = $traceurRuntime.toProperty;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var iteratedString = Symbol('iteratedString');
  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');
  var StringIterator = function StringIterator() {};
  ($traceurRuntime.createClass)(StringIterator, ($__2 = {}, Object.defineProperty($__2, "next", {
    value: function() {
      var o = this;
      if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {
        throw new TypeError('this must be a StringIterator object');
      }
      var s = o[toProperty(iteratedString)];
      if (s === undefined) {
        return createIteratorResultObject(undefined, true);
      }
      var position = o[toProperty(stringIteratorNextIndex)];
      var len = s.length;
      if (position >= len) {
        o[toProperty(iteratedString)] = undefined;
        return createIteratorResultObject(undefined, true);
      }
      var first = s.charCodeAt(position);
      var resultString;
      if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {
        resultString = String.fromCharCode(first);
      } else {
        var second = s.charCodeAt(position + 1);
        if (second < 0xDC00 || second > 0xDFFF) {
          resultString = String.fromCharCode(first);
        } else {
          resultString = String.fromCharCode(first) + String.fromCharCode(second);
        }
      }
      o[toProperty(stringIteratorNextIndex)] = position + resultString.length;
      return createIteratorResultObject(resultString, false);
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__2, Symbol.iterator, {
    value: function() {
      return this;
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), $__2), {});
  function createStringIterator(string) {
    var s = String(string);
    var iterator = Object.create(StringIterator.prototype);
    iterator[toProperty(iteratedString)] = s;
    iterator[toProperty(stringIteratorNextIndex)] = 0;
    return iterator;
  }
  return {get createStringIterator() {
      return createStringIterator;
    }};
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/String.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/String.js";
  var createStringIterator = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/StringIterator.js").createStringIterator;
  var $__1 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__1.maybeAddFunctions,
      maybeAddIterator = $__1.maybeAddIterator,
      registerPolyfill = $__1.registerPolyfill;
  var $toString = Object.prototype.toString;
  var $indexOf = String.prototype.indexOf;
  var $lastIndexOf = String.prototype.lastIndexOf;
  function startsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) == start;
  }
  function endsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var pos = stringLength;
    if (arguments.length > 1) {
      var position = arguments[1];
      if (position !== undefined) {
        pos = position ? Number(position) : 0;
        if (isNaN(pos)) {
          pos = 0;
        }
      }
    }
    var end = Math.min(Math.max(pos, 0), stringLength);
    var start = end - searchLength;
    if (start < 0) {
      return false;
    }
    return $lastIndexOf.call(string, searchString, start) == start;
  }
  function includes(search) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    if (search && $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (pos != pos) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    if (searchLength + start > stringLength) {
      return false;
    }
    return $indexOf.call(string, searchString, pos) != -1;
  }
  function repeat(count) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var n = count ? Number(count) : 0;
    if (isNaN(n)) {
      n = 0;
    }
    if (n < 0 || n == Infinity) {
      throw RangeError();
    }
    if (n == 0) {
      return '';
    }
    var result = '';
    while (n--) {
      result += string;
    }
    return result;
  }
  function codePointAt(position) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var size = string.length;
    var index = position ? Number(position) : 0;
    if (isNaN(index)) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return undefined;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  function raw(callsite) {
    var raw = callsite.raw;
    var len = raw.length >>> 0;
    if (len === 0)
      return '';
    var s = '';
    var i = 0;
    while (true) {
      s += raw[i];
      if (i + 1 === len)
        return s;
      s += arguments[++i];
    }
  }
  function fromCodePoint() {
    var codeUnits = [];
    var floor = Math.floor;
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
    }
    return String.fromCharCode.apply(null, codeUnits);
  }
  function stringPrototypeIterator() {
    var o = $traceurRuntime.checkObjectCoercible(this);
    var s = String(o);
    return createStringIterator(s);
  }
  function polyfillString(global) {
    var String = global.String;
    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);
    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);
    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);
  }
  registerPolyfill(polyfillString);
  return {
    get startsWith() {
      return startsWith;
    },
    get endsWith() {
      return endsWith;
    },
    get includes() {
      return includes;
    },
    get repeat() {
      return repeat;
    },
    get codePointAt() {
      return codePointAt;
    },
    get raw() {
      return raw;
    },
    get fromCodePoint() {
      return fromCodePoint;
    },
    get stringPrototypeIterator() {
      return stringPrototypeIterator;
    },
    get polyfillString() {
      return polyfillString;
    }
  };
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/String.js" + '');
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/ArrayIterator.js", [], function() {
  "use strict";
  var $__2;
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/ArrayIterator.js";
  var $__0 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      toObject = $__0.toObject,
      toUint32 = $__0.toUint32,
      createIteratorResultObject = $__0.createIteratorResultObject;
  var ARRAY_ITERATOR_KIND_KEYS = 1;
  var ARRAY_ITERATOR_KIND_VALUES = 2;
  var ARRAY_ITERATOR_KIND_ENTRIES = 3;
  var ArrayIterator = function ArrayIterator() {};
  ($traceurRuntime.createClass)(ArrayIterator, ($__2 = {}, Object.defineProperty($__2, "next", {
    value: function() {
      var iterator = toObject(this);
      var array = iterator.iteratorObject_;
      if (!array) {
        throw new TypeError('Object is not an ArrayIterator');
      }
      var index = iterator.arrayIteratorNextIndex_;
      var itemKind = iterator.arrayIterationKind_;
      var length = toUint32(array.length);
      if (index >= length) {
        iterator.arrayIteratorNextIndex_ = Infinity;
        return createIteratorResultObject(undefined, true);
      }
      iterator.arrayIteratorNextIndex_ = index + 1;
      if (itemKind == ARRAY_ITERATOR_KIND_VALUES)
        return createIteratorResultObject(array[index], false);
      if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)
        return createIteratorResultObject([index, array[index]], false);
      return createIteratorResultObject(index, false);
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__2, Symbol.iterator, {
    value: function() {
      return this;
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), $__2), {});
  function createArrayIterator(array, kind) {
    var object = toObject(array);
    var iterator = new ArrayIterator;
    iterator.iteratorObject_ = object;
    iterator.arrayIteratorNextIndex_ = 0;
    iterator.arrayIterationKind_ = kind;
    return iterator;
  }
  function entries() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);
  }
  function keys() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);
  }
  function values() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);
  }
  return {
    get entries() {
      return entries;
    },
    get keys() {
      return keys;
    },
    get values() {
      return values;
    }
  };
});
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Array.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/Array.js";
  var $__0 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/ArrayIterator.js"),
      entries = $__0.entries,
      keys = $__0.keys,
      values = $__0.values;
  var $__1 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      checkIterable = $__1.checkIterable,
      isCallable = $__1.isCallable,
      isConstructor = $__1.isConstructor,
      maybeAddFunctions = $__1.maybeAddFunctions,
      maybeAddIterator = $__1.maybeAddIterator,
      registerPolyfill = $__1.registerPolyfill,
      toInteger = $__1.toInteger,
      toLength = $__1.toLength,
      toObject = $__1.toObject;
  function from(arrLike) {
    var mapFn = arguments[1];
    var thisArg = arguments[2];
    var C = this;
    var items = toObject(arrLike);
    var mapping = mapFn !== undefined;
    var k = 0;
    var arr,
        len;
    if (mapping && !isCallable(mapFn)) {
      throw TypeError();
    }
    if (checkIterable(items)) {
      arr = isConstructor(C) ? new C() : [];
      for (var $__2 = items[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__3 = void 0; !($__3 = $__2.next()).done; ) {
        var item = $__3.value;
        {
          if (mapping) {
            arr[k] = mapFn.call(thisArg, item, k);
          } else {
            arr[k] = item;
          }
          k++;
        }
      }
      arr.length = k;
      return arr;
    }
    len = toLength(items.length);
    arr = isConstructor(C) ? new C(len) : new Array(len);
    for (; k < len; k++) {
      if (mapping) {
        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);
      } else {
        arr[k] = items[k];
      }
    }
    arr.length = len;
    return arr;
  }
  function of() {
    for (var items = [],
        $__4 = 0; $__4 < arguments.length; $__4++)
      items[$__4] = arguments[$__4];
    var C = this;
    var len = items.length;
    var arr = isConstructor(C) ? new C(len) : new Array(len);
    for (var k = 0; k < len; k++) {
      arr[k] = items[k];
    }
    arr.length = len;
    return arr;
  }
  function fill(value) {
    var start = arguments[1] !== (void 0) ? arguments[1] : 0;
    var end = arguments[2];
    var object = toObject(this);
    var len = toLength(object.length);
    var fillStart = toInteger(start);
    var fillEnd = end !== undefined ? toInteger(end) : len;
    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);
    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);
    while (fillStart < fillEnd) {
      object[fillStart] = value;
      fillStart++;
    }
    return object;
  }
  function find(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg);
  }
  function findIndex(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg, true);
  }
  function findHelper(self, predicate) {
    var thisArg = arguments[2];
    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;
    var object = toObject(self);
    var len = toLength(object.length);
    if (!isCallable(predicate)) {
      throw TypeError();
    }
    for (var i = 0; i < len; i++) {
      var value = object[i];
      if (predicate.call(thisArg, value, i, object)) {
        return returnIndex ? i : value;
      }
    }
    return returnIndex ? -1 : undefined;
  }
  function polyfillArray(global) {
    var $__5 = global,
        Array = $__5.Array,
        Object = $__5.Object,
        Symbol = $__5.Symbol;
    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);
    maybeAddFunctions(Array, ['from', from, 'of', of]);
    maybeAddIterator(Array.prototype, values, Symbol);
    maybeAddIterator(Object.getPrototypeOf([].values()), function() {
      return this;
    }, Symbol);
  }
  registerPolyfill(polyfillArray);
  return {
    get from() {
      return from;
    },
    get of() {
      return of;
    },
    get fill() {
      return fill;
    },
    get find() {
      return find;
    },
    get findIndex() {
      return findIndex;
    },
    get polyfillArray() {
      return polyfillArray;
    }
  };
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Array.js" + '');
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Object.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/Object.js";
  var $__0 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill;
  var $__1 = $traceurRuntime,
      defineProperty = $__1.defineProperty,
      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      isPrivateName = $__1.isPrivateName,
      keys = $__1.keys;
  function is(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    return left !== left && right !== right;
  }
  function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      var props = source == null ? [] : keys(source);
      var p = void 0,
          length = props.length;
      for (p = 0; p < length; p++) {
        var name = props[p];
        if (isPrivateName(name))
          continue;
        target[name] = source[name];
      }
    }
    return target;
  }
  function mixin(target, source) {
    var props = getOwnPropertyNames(source);
    var p,
        descriptor,
        length = props.length;
    for (p = 0; p < length; p++) {
      var name = props[p];
      if (isPrivateName(name))
        continue;
      descriptor = getOwnPropertyDescriptor(source, props[p]);
      defineProperty(target, props[p], descriptor);
    }
    return target;
  }
  function polyfillObject(global) {
    var Object = global.Object;
    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);
  }
  registerPolyfill(polyfillObject);
  return {
    get is() {
      return is;
    },
    get assign() {
      return assign;
    },
    get mixin() {
      return mixin;
    },
    get polyfillObject() {
      return polyfillObject;
    }
  };
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Object.js" + '');
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Number.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/Number.js";
  var $__0 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      isNumber = $__0.isNumber,
      maybeAddConsts = $__0.maybeAddConsts,
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill,
      toInteger = $__0.toInteger;
  var $abs = Math.abs;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;
  var EPSILON = Math.pow(2, -52);
  function NumberIsFinite(number) {
    return isNumber(number) && $isFinite(number);
  }
  ;
  function isInteger(number) {
    return NumberIsFinite(number) && toInteger(number) === number;
  }
  function NumberIsNaN(number) {
    return isNumber(number) && $isNaN(number);
  }
  ;
  function isSafeInteger(number) {
    if (NumberIsFinite(number)) {
      var integral = toInteger(number);
      if (integral === number)
        return $abs(integral) <= MAX_SAFE_INTEGER;
    }
    return false;
  }
  function polyfillNumber(global) {
    var Number = global.Number;
    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);
    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);
  }
  registerPolyfill(polyfillNumber);
  return {
    get MAX_SAFE_INTEGER() {
      return MAX_SAFE_INTEGER;
    },
    get MIN_SAFE_INTEGER() {
      return MIN_SAFE_INTEGER;
    },
    get EPSILON() {
      return EPSILON;
    },
    get isFinite() {
      return NumberIsFinite;
    },
    get isInteger() {
      return isInteger;
    },
    get isNaN() {
      return NumberIsNaN;
    },
    get isSafeInteger() {
      return isSafeInteger;
    },
    get polyfillNumber() {
      return polyfillNumber;
    }
  };
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Number.js" + '');
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/Math.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/Math.js";
  var $__0 = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill,
      toUint32 = $__0.toUint32;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__1 = Math,
      abs = $__1.abs,
      ceil = $__1.ceil,
      exp = $__1.exp,
      floor = $__1.floor,
      log = $__1.log,
      pow = $__1.pow,
      sqrt = $__1.sqrt;
  function clz32(x) {
    x = toUint32(+x);
    if (x == 0)
      return 32;
    var result = 0;
    if ((x & 0xFFFF0000) === 0) {
      x <<= 16;
      result += 16;
    }
    ;
    if ((x & 0xFF000000) === 0) {
      x <<= 8;
      result += 8;
    }
    ;
    if ((x & 0xF0000000) === 0) {
      x <<= 4;
      result += 4;
    }
    ;
    if ((x & 0xC0000000) === 0) {
      x <<= 2;
      result += 2;
    }
    ;
    if ((x & 0x80000000) === 0) {
      x <<= 1;
      result += 1;
    }
    ;
    return result;
  }
  function imul(x, y) {
    x = toUint32(+x);
    y = toUint32(+y);
    var xh = (x >>> 16) & 0xffff;
    var xl = x & 0xffff;
    var yh = (y >>> 16) & 0xffff;
    var yl = y & 0xffff;
    return xl * yl + (((xh * yl + xl * yh) << 16) >>> 0) | 0;
  }
  function sign(x) {
    x = +x;
    if (x > 0)
      return 1;
    if (x < 0)
      return -1;
    return x;
  }
  function log10(x) {
    return log(x) * 0.434294481903251828;
  }
  function log2(x) {
    return log(x) * 1.442695040888963407;
  }
  function log1p(x) {
    x = +x;
    if (x < -1 || $isNaN(x)) {
      return NaN;
    }
    if (x === 0 || x === Infinity) {
      return x;
    }
    if (x === -1) {
      return -Infinity;
    }
    var result = 0;
    var n = 50;
    if (x < 0 || x > 1) {
      return log(1 + x);
    }
    for (var i = 1; i < n; i++) {
      if ((i % 2) === 0) {
        result -= pow(x, i) / i;
      } else {
        result += pow(x, i) / i;
      }
    }
    return result;
  }
  function expm1(x) {
    x = +x;
    if (x === -Infinity) {
      return -1;
    }
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return exp(x) - 1;
  }
  function cosh(x) {
    x = +x;
    if (x === 0) {
      return 1;
    }
    if ($isNaN(x)) {
      return NaN;
    }
    if (!$isFinite(x)) {
      return Infinity;
    }
    if (x < 0) {
      x = -x;
    }
    if (x > 21) {
      return exp(x) / 2;
    }
    return (exp(x) + exp(-x)) / 2;
  }
  function sinh(x) {
    x = +x;
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  }
  function tanh(x) {
    x = +x;
    if (x === 0)
      return x;
    if (!$isFinite(x))
      return sign(x);
    var exp1 = exp(x);
    var exp2 = exp(-x);
    return (exp1 - exp2) / (exp1 + exp2);
  }
  function acosh(x) {
    x = +x;
    if (x < 1)
      return NaN;
    if (!$isFinite(x))
      return x;
    return log(x + sqrt(x + 1) * sqrt(x - 1));
  }
  function asinh(x) {
    x = +x;
    if (x === 0 || !$isFinite(x))
      return x;
    if (x > 0)
      return log(x + sqrt(x * x + 1));
    return -log(-x + sqrt(x * x + 1));
  }
  function atanh(x) {
    x = +x;
    if (x === -1) {
      return -Infinity;
    }
    if (x === 1) {
      return Infinity;
    }
    if (x === 0) {
      return x;
    }
    if ($isNaN(x) || x < -1 || x > 1) {
      return NaN;
    }
    return 0.5 * log((1 + x) / (1 - x));
  }
  function hypot(x, y) {
    var length = arguments.length;
    var args = new Array(length);
    var max = 0;
    for (var i = 0; i < length; i++) {
      var n = arguments[i];
      n = +n;
      if (n === Infinity || n === -Infinity)
        return Infinity;
      n = abs(n);
      if (n > max)
        max = n;
      args[i] = n;
    }
    if (max === 0)
      max = 1;
    var sum = 0;
    var compensation = 0;
    for (var i = 0; i < length; i++) {
      var n = args[i] / max;
      var summand = n * n - compensation;
      var preliminary = sum + summand;
      compensation = (preliminary - sum) - summand;
      sum = preliminary;
    }
    return sqrt(sum) * max;
  }
  function trunc(x) {
    x = +x;
    if (x > 0)
      return floor(x);
    if (x < 0)
      return ceil(x);
    return x;
  }
  var f32 = new Float32Array(1);
  function fround(x) {
    f32[0] = +x;
    return f32[0];
  }
  function cbrt(x) {
    x = +x;
    if (x === 0)
      return x;
    var negate = x < 0;
    if (negate)
      x = -x;
    var result = pow(x, 1 / 3);
    return negate ? -result : result;
  }
  function polyfillMath(global) {
    var Math = global.Math;
    maybeAddFunctions(Math, ['acosh', acosh, 'asinh', asinh, 'atanh', atanh, 'cbrt', cbrt, 'clz32', clz32, 'cosh', cosh, 'expm1', expm1, 'fround', fround, 'hypot', hypot, 'imul', imul, 'log10', log10, 'log1p', log1p, 'log2', log2, 'sign', sign, 'sinh', sinh, 'tanh', tanh, 'trunc', trunc]);
  }
  registerPolyfill(polyfillMath);
  return {
    get clz32() {
      return clz32;
    },
    get imul() {
      return imul;
    },
    get sign() {
      return sign;
    },
    get log10() {
      return log10;
    },
    get log2() {
      return log2;
    },
    get log1p() {
      return log1p;
    },
    get expm1() {
      return expm1;
    },
    get cosh() {
      return cosh;
    },
    get sinh() {
      return sinh;
    },
    get tanh() {
      return tanh;
    },
    get acosh() {
      return acosh;
    },
    get asinh() {
      return asinh;
    },
    get atanh() {
      return atanh;
    },
    get hypot() {
      return hypot;
    },
    get trunc() {
      return trunc;
    },
    get fround() {
      return fround;
    },
    get cbrt() {
      return cbrt;
    },
    get polyfillMath() {
      return polyfillMath;
    }
  };
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/Math.js" + '');
System.registerModule("traceur-runtime@0.0.84/src/runtime/polyfills/polyfills.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.84/src/runtime/polyfills/polyfills.js";
  var polyfillAll = System.get("traceur-runtime@0.0.84/src/runtime/polyfills/utils.js").polyfillAll;
  polyfillAll(Reflect.global);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
    polyfillAll(global);
  };
  return {};
});
System.get("traceur-runtime@0.0.84/src/runtime/polyfills/polyfills.js" + '');

},{"path":false}],"/home/vadzim/v/work/nerojs/node_modules/websockets/lib/websockets/draft-00.js":[function(require,module,exports){
/***/
var util = require('util'), events = require('events'), crypto = require('crypto');
var URL = require('url');

var HANDSHAKE_RESPONSE = 'HTTP/1.1 101 WebSocket Protocol Handshake\r\nUpgrade: WebSocket\r\nConnection: Upgrade\r\n';

module.exports = exports = Draft00;

function Draft00(arg0, arg1) {
  var self = this;
  events.EventEmitter.call(self);

  var isClient = 'string' === typeof arg0;

  var Core = isClient ? Client: Server;
  self.core = new Core(self);

  var opts = self._options = (isClient ? arguments[1]: arguments[3]) || {};
  if('string' === typeof opts)
    opts = self._options = {
      protocols: [opts]
    };
  else if('array' === typeof opts)
    opts = self._options = {
      protocols: opts
    };
}
util.inherits(Draft00, events.EventEmitter);

function _option(key) {
  return this._options[key];
}

function Server(parent) {
  this.parent = parent;
}
function Client(parent) {
  this.parent = parent;
}

// ---------------------------------------------------
// close
// ---------------------------------------------------
Server.prototype.close = function(reason) {
  close.call(this, reason);
};
Draft00.prototype.close = function(reason) {
  this.core.close(reason);
};
function close(reason, maskbit) {
  var socket = this.parent.socket;
  socket.writable && socket.end();
  socket.destroy();
}

//---------------------------------------------------
//ping
//---------------------------------------------------
Server.prototype.ping = function(mess) {
  this.parent.emit('pong', mess);
};
Client.prototype.ping = function() {
};
Draft00.prototype.ping = function(mess) {
  this.core.ping(mess);
};

// ---------------------------------------------------
// write
// ---------------------------------------------------
Server.prototype.write = function(massage) {
  write.call(this, massage);
};
Draft00.prototype.write = function(massage) {
  this.core.write(massage);
};
function write(message, maskbit) {
  var socket = this.parent.socket;

  var length = Buffer.byteLength(message);
  var mess = new Buffer(length + 2);

  mess[0] = 0;
  mess.write(message, 1);
  mess[length + 1] = 0xFF;

  socket.write(mess);

}

// ---------------------------------------------------
// parse
// ---------------------------------------------------
Server.prototype.parse = function(data) {
  parse.call(this, data);
};
Draft00.prototype.parse = function(data) {
  this.core.parse(data);
};
function parse(data) {
  var self = this, parent = self.parent;
  self.buffer = self.buffer || [];

  var i = 0, l = data.length;
  
  try {
    frame();
  } catch(err) {
    parent.close();
  }

  function frame() {
    var type = self.type == null ? self.type = data[i++]: self.type;
    var sb = type >>> 7;
    if(sb) {
      if(0xFF !== type)
        throw new Error();// abort
      var length = 0, b;
      for(; i < l && b !== 0; i++)
        b = _length(data[i]);

    } else {
      if(0 !== type)
        throw new Error();// abort
      for(; i < l;) {
        var b = data[i++];
        0xFF === b ? _flush(): _data(b);
      }
    }

    function _data(d) {
      self.buffer.push(d);
    }
    function _length(d) {
      // TODO
    }
    function _flush() {
      var mess = self.buffer;
      parent.emit('message', Buffer(mess).toString());
      self.buffer = [], self.type = null;
      if(i < l)
        frame();
    }
  }
}

// ---------------------------------------------------
// hand shake
// ---------------------------------------------------
Draft00.prototype.handShake = function() {
  var core = this.core;
  core.handShake.apply(core, arguments);
};
Server.prototype.handShake = function(req, socket, upgradeHead) {
  var parent = this.parent, head = req['headers'];
  parent.socket = socket;

  if('WebSocket' !== head['upgrade'] || 'Upgrade' !== head['connection'])
    return socket.write(ERR_400);

  var host = head['host'], _origin = head['origin'];
  var _key1 = head['sec-websocket-key1'], _key2 = head['sec-websocket-key2'];
  var _key3 = upgradeHead;
  var _secure = !!req.socket.encrypted;
  var protocol = _secure ? 'wss://': 'ws://';

  var url = URL.parse(protocol + host);
  var _host = url.hostname, _port = url.port, _resource = url.pathname;

  var _location = protocol + _host;
  if(_port && +_port !== (_secure ? 443: 80))
    _location += ':' + _port;
  _location += req.url;

  function makeKey(key) {
    var i, len, num = '', cnt = 0;
    for(i = 0, len = key.length; i < len; i++)
      if(key[i].match(/\d/))
        num += key[i];
      else if('\u0020' === key[i])
        cnt++;
    var part = ~~(+num / cnt);
    return Buffer([part >>> 24 & 0xFF, part >>> 16 & 0xFF, part >>> 8 & 0xFF,
        part & 0xFF]);
  }

  var open = true, close = function() {
    if(open)
      open = false, parent.emit('close');
  };

  socket.on('close', close);

  socket.on('end', close);

  socket.on('data', function(data) {
    parent.parse(data);
  });

  var _part1 = makeKey(_key1), _part2 = makeKey(_key2);

  var hash = crypto.createHash('md5');
  hash.update(_part1);
  hash.update(_part2);
  hash.update(_key3);

  var head = HANDSHAKE_RESPONSE;
  head += 'Sec-WebSocket-Origin: ' + _origin + '\r\n';
  head += 'Sec-WebSocket-Location: ' + _location + '\r\n\r\n';
  socket.write(head + hash.digest(), 'binary');
  parent.emit('connect', socket);

  function _isAllowed() {
    var validate = parent._options['validateOrigin'];
    return 'function' === typeof validate ? validate(head): true;
  }
};

},{"crypto":false,"events":false,"url":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/websockets/lib/websockets/draft-10.js":[function(require,module,exports){
/***/
var util = require('util'), events = require('events'), crypto = require('crypto');
var URL = require('url'), http = require('http'), https = require('https');

var GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
var HANDSHAKE_RESPONSE = 'HTTP/1.1 101 Switching Protocols\r\nSec-WebSocket-Protocol: *\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ';
var ERR_400 = 'HTTP/1.1 400 Bad Request\r\n\r\n400 Bad Request';
var ERR_403 = 'HTTP/1.1 403 Forbidden\r\n\r\n403 Forbidden';
var ERR_426 = 'HTTP/1.1 426 Upgrade Required\r\n\r\n426 Upgrade Required';

module.exports = exports = Draft10;

function Draft10(arg0, arg1) {
  var self = this;
  events.EventEmitter.call(self);

  var isClient = 'string' === typeof arg0;

  var Core = isClient ? Client: Server;
  self.core = new Core(self);

  var opts = self._options = (isClient ? arguments[1]: arguments[3]) || {};
  if('string' === typeof opts)
    opts = self._options = {
      protocols: [opts]
    };
  else if('array' === typeof opts)
    opts = self._options = {
      protocols: opts
    };

  var bufSize = opts['bufferSize'];
  if(!bufSize || bufSize <= 0)
    opts['bufferSize'] = BUFFER_SIZE;

  self.on('_data', function(data, fin, opcode) {
    if(0 !== opcode)
      self.opcode = opcode, self.buffer = [];
//    Array.prototype.push.apply(self.buffer, data);
    self.buffer = self.buffer.concat(data);
    self.emit('data', new Buffer(data), fin, self.opcode);
    if(fin) {
      var buf = new Buffer(self.buffer);
      var message = 1 === self.opcode ? buf.toString(): buf;
      self.emit('message', message);
    }
  });
}
util.inherits(Draft10, events.EventEmitter);

function _option(key) {
  return this._options[key];
}

function Server(parent) {
  this.parent = parent;
}
function Client(parent) {
  this.parent = parent;
}

// ---------------------------------------------------
// close
// ---------------------------------------------------
Server.prototype.close = function(reason) {
  close.call(this, reason, 0);
};
Client.prototype.close = function(reason) {
  close.call(this, reason, 1);
};
Draft10.prototype.close = function(reason) {
  this.core.close(reason);
};
function close(reason, maskbit) {
  var self = this, parent = self.parent;
  var message = ERR_CODE[reason] || (reason + '');
  _ctrl.call(self, OPCODE['close'], maskbit, message);

  parent.close = function() {
    var socket = parent.socket;
    socket.writable && socket.end();
    socket.destroy();
  };
}

// ---------------------------------------------------
// Control Frames
// ---------------------------------------------------
function _ctrl(opcode, maskbit, data) {
  var parent = this.parent, buf = new Buffer(data);
  if(125 < buf.length)
    buf = buf.slice(0, 124);

  var fin = 1;
  var ext = [0x00, 0x00, 0x00];

  parent.socket.write(frame(fin, ext, opcode, maskbit, buf));

}

// ---------------------------------------------------
// write
// ---------------------------------------------------
Server.prototype.write = function(massage) {
  write.call(this, massage, 0);
};
Client.prototype.write = function(massage) {
  write.call(this, massage, 1);
};
Draft10.prototype.write = function(massage) {
  this.core.write(massage);
};
function write(message, maskbit) {
  var parent = this.parent, socket = parent.socket;

  var buf = new Buffer(message), len = buf.length;

  var i, data = [], size = parent._options['bufferSize'];
  for(i = 0; i < len; i += size)
    data.push(buf.slice(i, Math.min(buf.length, i + size)));

  var fin = 0;
  var ext = [0, 0, 0];
  var opcode = OPCODE[typeof message] || OPCODE['binary'];
  var mask = maskbit;

  i = 0, len = data.length;

  for(; i < len - 1; i++, opcode = 0)
    socket.write(frame(fin, ext, opcode, mask, data[i]));

  fin = 1;
  socket.write(frame(fin, ext, opcode, mask, data[i]));

}

// ---------------------------------------------------
// pong
// ---------------------------------------------------
Draft10.prototype.pong = Draft10.prototype.write;

// ---------------------------------------------------
// parse
// ---------------------------------------------------
Server.prototype.parse = function(data) {
  parse.call(this, data, 1);
};
Client.prototype.parse = function(data) {
  parse.call(this, data, 0);
};
Draft10.prototype.parse = function(data) {
  this.core.parse(data);
};
function parse(data, maskbit) {
  var self = this, parent = self.parent, i = 0;

  var OP_FUNC = {
    _def: function(payload, fin, opcode) {
      parent.emit('_data', payload, fin, opcode);
    },
    0x00: function(payload, fin) {
      OP_FUNC['_def'](payload, fin, 0);
    },
    0x01: function string(payload, fin) {
      OP_FUNC['_def'](payload, fin, 1);
    },
    0x02: function binary(payload, fin) {
      OP_FUNC['_def'](payload, fin, 2);
    },
    0x08: function close() {
      parent.emit('_closing', 1000);
    },
    0x09: function ping(payload) {
      self.pong(payload);
    },
    0x0A: function pong(payload) {
      // TODO
    }
  };

  if('undefined' === typeof self.buffer)
    _parseHead();

  _parsePayload();

  function _parseHead() {

    var byte = data[i++];
    var fin = byte >>> 7;
    var ope = (byte & 0x0F);

    byte = data[i++];
    var mask = byte >>> 7;
    if(maskbit !== mask)
      return parent.emit('error', 1002);
    var len = byte & 0x7F;

    if(127 === len)
      len = ((data[i++] << 24) + (data[i++] << 16) + (data[i++] << 8) + data[i++]) * Math
          .pow(2, 32) + (data[i++] << 24) + (data[i++] << 16) + (data[i++] << 8) + data[i++];
    else if(126 === len)
      len = (data[i++] << 8) + data[i++];

    var maskkey = maskbit ? [data[i++], data[i++], data[i++], data[i++]]: null;

    self.buffer = {
      fin: fin,
      ope: ope,
      length: len,
      mask: maskkey,
      payload: []
    };
  };

  function _parsePayload() {
    var buf = self.buffer, len = data.length;
    var payload = buf.payload, maskkey = buf.mask, ope = buf.ope, fin = buf.fin;
    var j = payload.length % 4;
    for(; buf.length && i < len; j++, buf.length--)
      payload.push(maskkey ? data[i++] ^ maskkey[j % 4]: data[i++]);

    if('function' !== typeof OP_FUNC[ope])
      return parent.emit('error', 1002);

    if(0 === buf.length) {
      OP_FUNC[ope](payload, !!fin);
      delete self.buffer;
    }

    // TODO test
    if(i < len)
      parse.call(self, data.slice(i), maskbit);

  }
}

// ---------------------------------------------------
// hand shake
// ---------------------------------------------------
Draft10.prototype.handShake = function() {
  var core = this.core;
  core.handShake.apply(core, arguments);
};
Server.prototype.handShake = function(req, socket, upgradeHead) {
  var parent = this.parent, head = req['headers'];
  parent.socket = socket;

  var i, keys = ['host', 'sec-websocket-key'];
  for(i = keys.length; i--;)
    if(!(keys[i] in head))
      return socket.write(ERR_400);
  if('websocket' !== head['upgrade'])
    return socket.write(ERR_400);
  if('8' !== head['sec-websocket-version'])
    return socket.write(ERR_426);
  if(true !== _isAllowed())
    return socket.write(ERR_403);

  // TODO
  head['sec-websocket-protocol'], head['cookie'];

  var open = true, close = function() {
    if(open)
      open = false, parent.emit('close');
  };

  var newkey = _hashAndEncode(head['sec-websocket-key']);
  socket.write(HANDSHAKE_RESPONSE);
  socket.write(newkey + '\r\n\r\n');
  process.nextTick(function() {
    socket.on('close', close);
    socket.on('end', close);
    socket.on('data', function(data) {
      parent.parse(data);
    });
    parent.emit('connect', socket);
  });

  function _isAllowed() {
    var validate = parent._options['validateOrigin'];
    return 'function' === typeof validate ? validate(head): true;
  }
};
Client.prototype.handShake = function(uri) {
  var parent = this.parent, url = URL.parse(uri);
  parent.URL = uri;

  var secure = parent.secure = 'wss:' === url['protocol'];

  var URI = url['protocol'];
  URI += '//';
  URI += url['host'];
  URI += url['pathname'] || '/';
  URI += (url['search'] || '').replace(/#/, '%23');

  var key = _createKey();

  var opts = {
    port: url['port'] || (secure ? 443: 80),
    host: url['hostname'],
    headers: {
      Connection: 'Upgrade',
      Upgrade: 'websocket',
      'Sec-Websocket-Key': key,
      'Sec-Websocket-Origin': 'node-websockets',
      'Sec-Websocket-Version': 8
    }
  };

  if(secure) {
    opts['key'] = parent._options['key'];
    opts['cert'] = parent._options['cert'];
    opts['ca'] = parent._options['ca'];
  }

  var prtcl = secure ? https: http, agent;
  if(prtcl.getAgent) {
    agent = prtcl.getAgent(opts['host'], opts['port']);
    opts['agent'] = agent;
  }
  var req = prtcl.request(opts);
  req.end();
  agent = agent || req;

  var newkey = _hashAndEncode(key);

  agent.on('upgrade', function(res, socket, upgradeHead) {

    socket.on('close', function(had_error) {
      parent.emit('close', had_error);
    });

    socket.on('data', function(data) {
      parent.parse(data);
    });

    // TODO
    var status = res['statusCode'];
    if(101 !== status)
      return parent.emit('_closing', status);

    var head = res['headers'];
    if('websocket' !== head['upgrade'] || 'Upgrade' !== head['connection'])
      return parent.emit('error', new Error('Invalid Response Header'));

    if(head['sec-websocket-accept'] !== newkey)
      return parent.emit('error', new Error('Invalid Server Response'));

    parent.socket = socket;

    parent.emit('connect', socket);
  });
  req.on('error', function(err) {
    parent.emit('error', err);
  });

  function _createKey() {
    var i, arr = [];
    for(i = 16; i--;)
      arr.push(~~(Math.random() * 256));
    return (new Buffer(arr)).toString('base64');
  }
};

var OPCODE = {
  string: 0x01,
  binary: 0x02,
  close: 0x08,
  ping: 0x09,
  pong: 0x0A
};
var ERR_CODE = {
  1000: 'Normal Closure',
  1001: 'Going Away',
  1002: 'Protocol error',
  1003: 'Unsupported Data',
  1004: 'Frame Too Large',
  1005: 'No Status Rcvd', // MUST NOT be set in Close control
  1006: 'Abnormal Closure', // MUST NOT be set in Close control
  1007: 'Invalid UTF-8'
};

var BUFFER_SIZE = 2000000;

function _hashAndEncode(key) {
  var newkey = (key + GUID).trim();
  var shasum = crypto.createHash('sha1');
  shasum.update(newkey);
  return shasum.digest('base64');
}

function frame(fin, ext, opcode, mask, payload) {
  var arr = [];
  var push = Array.prototype.push;
  push.apply(arr, _1st(fin, ext, opcode));
  push.apply(arr, _length(mask, payload));
  arr = arr.concat(_payload(mask, payload));

  return new Buffer(arr);
}

function _1st(fin, ext, opcode) {
  return [(fin << 7) | (ext[0] << 6) | (ext[1] << 5) | (ext[2] << 4) | opcode];
}

function _length(mask, payload) {
  var length = payload.length, len = length, extlen = [];
  if(length <= 125)
    ;
  else if(length <= 0xFFFF) {
    len = 126;
    extlen.push(length >>> 8);
    extlen.push(length & 0xFF);
  } else {
    len = 127;
    // var zerofill =
    // '0000000000000000000000000000000000000000000000000000000000000000';
    var zerofill = '000000000000000000000000000000000000000000000000';
    var bin = (zerofill + length.toString(2)).slice(-64);
    extlen.push(parseInt(bin.substr(0, 8), 2));
    extlen.push(parseInt(bin.substr(8, 8), 2));
    extlen.push(parseInt(bin.substr(16, 8), 2));
    extlen.push(parseInt(bin.substr(24, 8), 2));
    extlen.push(parseInt(bin.substr(32, 8), 2));
    extlen.push(parseInt(bin.substr(40, 8), 2));
    extlen.push(parseInt(bin.substr(48, 8), 2));
    extlen.push(parseInt(bin.substr(56, 8), 2));
  }
  extlen.unshift((mask << 7) | len);
  return extlen;
}

function _payload(maskbit, payload) {
  var i, mask, ret, length;
  if(maskbit) {
    mask = makeMask(), ret = mask.slice(-4), length = payload.length;
    for(i = 0; i < length; i++)
      ret.push(payload[i] ^ mask[i % 4]);
  } else
    ret = Array.prototype.slice.call(payload);

  return ret;

  function makeMask() {
    var i, ret = [];
    for(i = 4; i--;)
      ret.push(~~(Math.random() * 256));
    return ret;
  }
}

},{"crypto":false,"events":false,"http":false,"https":false,"url":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/websockets/lib/websockets/rfc6455.js":[function(require,module,exports){
/***/
var util = require('util'), events = require('events'), crypto = require('crypto');
var URL = require('url'), http = require('http'), https = require('https');

var GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
var HANDSHAKE_RESPONSE = 'HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ';
var ERR_400 = 'HTTP/1.1 400 Bad Request\r\n\r\n400 Bad Request';
var ERR_403 = 'HTTP/1.1 403 Forbidden\r\n\r\n403 Forbidden';
var ERR_426 = 'HTTP/1.1 426 Upgrade Required\r\n\r\n426 Upgrade Required';

module.exports = exports = Rfc6455;

function Rfc6455(arg0, arg1) {
  var self = this;
  events.EventEmitter.call(self);

  var isClient = 'string' === typeof arg0;

  var Core = isClient ? Client: Server;
  self.core = new Core(self);

  var opts = self._options = (isClient ? arguments[1]: arguments[3]) || {};
  if('string' === typeof opts)
    opts = self._options = {
      protocols: [opts]
    };
  else if('array' === typeof opts)
    opts = self._options = {
      protocols: opts
    };

  var bufSize = opts['bufferSize'];
  if(!bufSize || bufSize <= 0)
    opts['bufferSize'] = BUFFER_SIZE;

  self.on('_data', function(data, fin, opcode) {
    if(0 !== opcode)
      self.opcode = opcode, self.buffer = [];
//    Array.prototype.push.apply(self.buffer, data);
    self.buffer = self.buffer.concat(data);
    self.emit('data', new Buffer(data), fin, self.opcode);
    if(fin) {
      var buf = new Buffer(self.buffer);
      var message = 1 === self.opcode ? buf.toString(): buf;
      self.emit('message', message);
    }
  });
}
util.inherits(Rfc6455, events.EventEmitter);

function _option(key) {
  return this._options[key];
}

function Server(parent) {
  this.parent = parent;
}
function Client(parent) {
  this.parent = parent;
}

// ---------------------------------------------------
// close
// ---------------------------------------------------
Server.prototype.close = function(reason) {
  close.call(this, reason, 0);
};
Client.prototype.close = function(reason) {
  close.call(this, reason, 1);
};
Rfc6455.prototype.close = function(reason) {
  this.core.close(reason);
};
function close(reason, maskbit) {
  var self = this, parent = self.parent;
  if(!parent.socket) return;
  var message = ERR_CODE[reason] || (reason + '');
  _ctrl.call(self, OPCODE['close'], maskbit, message);

  parent.close = function() {
    var socket = parent.socket;
    socket.writable && socket.end();
    socket.destroy();
  };
}

//---------------------------------------------------
//ping
//---------------------------------------------------
Server.prototype.ping = function(mess) {
  ping.call(this, mess, 0);
};
Client.prototype.ping = function(mess) {
  ping.call(this, mess, 1);
};
Rfc6455.prototype.ping = function(mess) {
  this.core.ping(mess);
};
function ping(mess, maskbit) {
  var self = this, parent = self.parent;
  _ctrl.call(self, OPCODE['ping'], maskbit, mess);
}


// ---------------------------------------------------
// Control Frames
// ---------------------------------------------------
function _ctrl(opcode, maskbit, data) {
  var parent = this.parent, buf = new Buffer(data);
  if(125 < buf.length)
    buf = buf.slice(0, 124);

  var fin = 1;
  var ext = [0x00, 0x00, 0x00];

  parent.socket.write(frame(fin, ext, opcode, maskbit, buf));

}

// ---------------------------------------------------
// write
// ---------------------------------------------------
Server.prototype.write = function(massage) {
  write.call(this, massage, 0);
};
Client.prototype.write = function(massage) {
  write.call(this, massage, 1);
};
Rfc6455.prototype.write = function(massage) {
  this.core.write(massage);
};
function write(message, maskbit) {
  var parent = this.parent, socket = parent.socket;

  var buf = new Buffer(message), len = buf.length;

  var i, data = [], size = parent._options['bufferSize'];
  for(i = 0; i < len; i += size)
    data.push(buf.slice(i, Math.min(buf.length, i + size)));

  var fin = 0;
  var ext = [0, 0, 0];
  var opcode = OPCODE[typeof message] || OPCODE['binary'];
  var mask = maskbit;

  i = 0, len = data.length;

  for(; i < len - 1; i++, opcode = 0)
    socket.write(frame(fin, ext, opcode, mask, data[i]));

  fin = 1;
  socket.write(frame(fin, ext, opcode, mask, data[i]));

}

// ---------------------------------------------------
// pong
// ---------------------------------------------------
Rfc6455.prototype.pong = Rfc6455.prototype.write;

// ---------------------------------------------------
// parse
// ---------------------------------------------------
Server.prototype.parse = function(data) {
  parse.call(this, data, 1);
};
Client.prototype.parse = function(data) {
  parse.call(this, data, 0);
};
Rfc6455.prototype.parse = function(data) {
  this.core.parse(data);
};
function parse(data, maskbit) {
  var self = this, parent = self.parent, i = 0;

  var OP_FUNC = {
    _def: function(payload, fin, opcode) {
      parent.emit('_data', payload, fin, opcode);
    },
    0x00: function(payload, fin) {
      OP_FUNC['_def'](payload, fin, 0);
    },
    0x01: function string(payload, fin) {
      OP_FUNC['_def'](payload, fin, 1);
    },
    0x02: function binary(payload, fin) {
      OP_FUNC['_def'](payload, fin, 2);
    },
    0x08: function close() {
      parent.emit('_closing', 1000);
    },
    0x09: function ping(payload) {
      parent.pong(payload); // TODO
    },
    0x0A: function pong(payload) {
      parent.emit('pong', Buffer(payload).toString());
    }
  };
  if(self.buffer instanceof Buffer) {
    var _data = Buffer(self.buffer.length + data.length);
    self.buffer.copy(_data);
    data.copy(_data, self.buffer.length);
    data = _data;
    delete self.buffer;
  }

  if('undefined' === typeof self.buffer)
    self.buffer = _parseHead();

  if(!(self.buffer instanceof Buffer))
    _parsePayload();

  function _parseHead() {
    var length = data.length;
    if(length < 2)
      return data;
    var _byte = data[i++];
    var fin = _byte >>> 7;
    var ope = (_byte & 0x0F);

    _byte = data[i++];
    var mask = _byte >>> 7;
    if(maskbit !== mask)
      return parent.emit('error', 1002);
    var len = _byte & 0x7F;

    if(length < 2 + ({"126": 2, "127": 8} || 0)[len] + (maskbit ? 4: 0))
      return data;
    
    if(127 === len)
      len = ((data[i++] << 24) + (data[i++] << 16) + (data[i++] << 8) + data[i++]) * Math
          .pow(2, 32) + (data[i++] << 24) + (data[i++] << 16) + (data[i++] << 8) + data[i++];
    else if(126 === len)
      len = (data[i++] << 8) + data[i++];

    var maskkey = maskbit ? [data[i++], data[i++], data[i++], data[i++]]: null;

    return {
      fin: fin,
      ope: ope,
      length: len,
      mask: maskkey,
      payload: []
    };
  }

  function _parsePayload() {
    var buf = self.buffer, len = data.length;
    var payload = buf.payload, maskkey = buf.mask, ope = buf.ope, fin = buf.fin;
    var j = payload.length % 4;
    for(; buf.length && i < len; j++, buf.length--)
      payload.push(maskkey ? data[i++] ^ maskkey[j % 4]: data[i++]);

    if('function' !== typeof OP_FUNC[ope])
      return parent.emit('error', 1002);

    try {
      if(0 === buf.length) {
        OP_FUNC[ope](payload, !!fin);
        delete self.buffer;
      }

      // TODO test
      if(i < len)
        parse.call(self, data.slice(i), maskbit);
    } catch(e) {
      /* for debug parse error
      console.log(Date());
      console.log(data);
      console.log('E:length:' + data.length);
      console.log('E:i:' + i);
      console.log('E:mask:' + maskbit);
      */
      console.error(e);
      throw e;
    }

  }
}

// ---------------------------------------------------
// hand shake
// ---------------------------------------------------
Rfc6455.prototype.handShake = function() {
  var core = this.core;
  core.handShake.apply(core, arguments);
};
Server.prototype.handShake = function(req, socket, upgradeHead) {
  var parent = this.parent, head = req['headers'];
  parent.socket = socket;

  var i, keys = ['host', 'sec-websocket-key', 'upgrade'];
  for(i = keys.length; i--;)
    if(!(keys[i] in head))
      return socket.write(ERR_400);
  if('websocket' !== head['upgrade'].toLowerCase())
    return socket.write(ERR_400);
  if('13' !== head['sec-websocket-version'])
    return socket.write(ERR_426);
  if(true !== _isAllowed())
    return socket.write(ERR_403);

  // TODO
  head['sec-websocket-protocol'], head['cookie'];

  var open = true, close = function() {
    if(open)
      open = false, parent.emit('close');
  };

  var newkey = _hashAndEncode(head['sec-websocket-key']);
  socket.write(new Buffer(HANDSHAKE_RESPONSE + newkey + '\r\n\r\n'));
  process.nextTick(function() {
    socket.on('close', close);
    socket.on('end', close);
    socket.on('data', function(data) {
      parent.parse(data);
    });
    parent.emit('connect', socket);
  });

  function _isAllowed() {
    var validate = parent._options['validateOrigin'];
    return 'function' === typeof validate ? validate(head): true;
  }
};
Client.prototype.handShake = function(uri) {
  var parent = this.parent, url = URL.parse(uri);
  parent.URL = uri;

  var secure = parent.secure = 'wss:' === url['protocol'];

  var path = url['pathname'] || '/';
  path += (url['search'] || '').replace(/#/, '%23');
  path += (url['hash'] || '');

  var key = _createKey();

  var opts = {
    port: url['port'] || (secure ? 443: 80),
    host: url['hostname'],
    path: path,
    headers: {
      Connection: 'Upgrade',
      Upgrade: 'websocket',
      'Sec-Websocket-Key': key,
      'Sec-Websocket-Origin': 'node-websockets',
      'Sec-Websocket-Version': 13
    }
  };

  if(secure) {
    opts['key'] = parent._options['key'];
    opts['cert'] = parent._options['cert'];
    opts['ca'] = parent._options['ca'];
    opts['rejectUnauthorized'] = parent._options['rejectUnauthorized'];
  }

  var prtcl = secure ? https: http, agent;
  if(prtcl.getAgent) {
    agent = prtcl.getAgent(opts['host'], opts['port']);
    opts['agent'] = agent;
  }
  var req = prtcl.request(opts);
  req.end();
  agent = agent || req;

  var newkey = _hashAndEncode(key);

  agent.on('upgrade', function(res, socket, upgradeHead) {
    parent.socket = socket;

    socket.on('close', function(had_error) {
      parent.emit('close', had_error);
    });

    socket.on('data', function(data) {
      parent.parse(data);
    });

    // TODO
    var status = res['statusCode'];
    if(101 !== status)
      return parent.emit('_closing', status);

    var head = res['headers'];
    if('websocket' !== head['upgrade'] || 'Upgrade' !== head['connection'])
      return parent.emit('error', new Error('Invalid Response Header'));

    if(head['sec-websocket-accept'] !== newkey)
      return parent.emit('error', new Error('Invalid Server Response'));

    parent.emit('connect', socket);
  });
  req.on('error', function(err) {
    parent.emit('error', err);
  });

  function _createKey() {
    var i, arr = [];
    for(i = 16; i--;)
      arr.push(~~(Math.random() * 256));
    return (new Buffer(arr)).toString('base64');
  }
};

var OPCODE = {
  string: 0x01,
  binary: 0x02,
  close: 0x08,
  ping: 0x09,
  pong: 0x0A
};
var ERR_CODE = {
  1000: 'Normal Closure',
  1001: 'Going Away',
  1002: 'Protocol error',
  1003: 'Unsupported Data',
  1004: 'Frame Too Large',
  1005: 'No Status Rcvd', // MUST NOT be set in Close control
  1006: 'Abnormal Closure', // MUST NOT be set in Close control
  1007: 'Invalid UTF-8'
};

var BUFFER_SIZE = 2000000;

function _hashAndEncode(key) {
  var newkey = (key + GUID).trim();
  var shasum = crypto.createHash('sha1');
  shasum.update(newkey);
  return shasum.digest('base64');
}

function frame(fin, ext, opcode, mask, payload) {
  var arr = [];
  var push = Array.prototype.push;
  push.apply(arr, _1st(fin, ext, opcode));
  push.apply(arr, _length(mask, payload));
  arr = arr.concat(_payload(mask, payload));

  return new Buffer(arr);
}

function _1st(fin, ext, opcode) {
  return [(fin << 7) | (ext[0] << 6) | (ext[1] << 5) | (ext[2] << 4) | opcode];
}

function _length(mask, payload) {
  var length = payload.length, len = length, extlen = [];
  if(length <= 125)
    ;
  else if(length <= 0xFFFF) {
    len = 126;
    extlen.push(length >>> 8);
    extlen.push(length & 0xFF);
  } else {
    len = 127;
    // var zerofill =
    // '0000000000000000000000000000000000000000000000000000000000000000';
    var zerofill = '000000000000000000000000000000000000000000000000';
    var bin = (zerofill + length.toString(2)).slice(-64);
    extlen.push(parseInt(bin.substr(0, 8), 2));
    extlen.push(parseInt(bin.substr(8, 8), 2));
    extlen.push(parseInt(bin.substr(16, 8), 2));
    extlen.push(parseInt(bin.substr(24, 8), 2));
    extlen.push(parseInt(bin.substr(32, 8), 2));
    extlen.push(parseInt(bin.substr(40, 8), 2));
    extlen.push(parseInt(bin.substr(48, 8), 2));
    extlen.push(parseInt(bin.substr(56, 8), 2));
  }
  extlen.unshift((mask << 7) | len);
  return extlen;
}

function _payload(maskbit, payload) {
  var i, mask, ret, length;
  if(maskbit) {
    mask = makeMask(), ret = mask.slice(-4), length = payload.length;
    for(i = 0; i < length; i++)
      ret.push(payload[i] ^ mask[i % 4]);
  } else
    ret = Array.prototype.slice.call(payload);

  return ret;

  function makeMask() {
    var i, ret = [];
    for(i = 4; i--;)
      ret.push(~~(Math.random() * 256));
    return ret;
  }
}

},{"crypto":false,"events":false,"http":false,"https":false,"url":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/websockets/lib/websockets/socket.js":[function(require,module,exports){
/***/
var util = require('util'), events = require('events'), crypto = require('crypto');
var fs = require('fs'), URL = require('url'), path = require('path');

var STATE = {
  CONNECTING: 0,
  OPEN: 1,
  CLOSING: 2,
  CLOSED: 3
};

module.exports = exports = WebSocket;

var EVTS = ['close', '_closing', 'connect', 'error', 'message'], length = EVTS.length;

function WebSocket() {
  var self = this;
  events.EventEmitter.call(self);

  self.readyState = STATE.CONNECTING;

  self.on('error', function(err) {
    self.close(err && err.message);
    if('function' === typeof self.onerror)
      self.onerror(err);
  });

  self.on('close', function() {
    self.readyState = STATE.CLOSED;
    if('function' === typeof self.onclose)
      self.onclose();
  });

  self.on('open', function() {
    self.readyState = STATE.OPEN;
    if('function' === typeof self.onopen)
      self.onopen();
  });

  self.on('message', function() {
    if('function' === typeof self.onmessage)
      self.onmessage();
  });

  self.on('_closing', function(reason) {
    self.readyState = STATE.CLOSING;
    process.nextTick(function() {
      close.call(self, reason);
    });
  });

  self.on('connect', function() {
    self.emit('open');
  });

  var args = arguments;
  process.nextTick(function() {
    handShake.apply(self, args);
  });
}
util.inherits(WebSocket, events.EventEmitter);

function handShake() {
  var self = this;
  var arg0 = arguments[0], arg1 = arguments[1], arg2 = arguments[2], arg3 = arguments[3];

  var Protocol = _getProtocol.apply(null, arguments);
  var protocol = self.protocol = new Protocol(arg0, arg1, arg2, arg3);

  var i = length, evts = EVTS;
  for(; i--;)
    _bubbling(evts[i], protocol, self);

  self.on('connect', function(socket) {
    self.secure = !!socket.encrypted;
    var _socket = socket['socket'] || socket;
    _socket.setTimeout(0);
    _socket.setNoDelay(true);
    _socket.setKeepAlive(true, 0);
  });
  protocol.handShake.apply(protocol, arguments);

};

function close(reason) {
  var self = this, protocol = self.protocol;
  self.send = function() {
  };
  protocol.close(reason);
}

WebSocket.prototype.send = function() {
  var protocol = this.protocol;
  protocol.write.apply(protocol, arguments);
};

WebSocket.prototype.close = function(reason) {
  this.emit('_closing');
};

WebSocket.prototype.addEventListener = WebSocket.prototype.addListener;

function _bubbling(evt, from, to) {
  from.on(evt, function() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(evt);
    to.emit.apply(to, args);
  });
}

function _getProtocol(arg0) {
  // for client
  if('string' === typeof arg0)
    return require('./rfc6455');

  var header = arg0['headers'];
  var version = header['sec-websocket-version'];

  if('8' === version)
    return require('./draft-10');

  if(header['sec-websocket-key1'] && header['sec-websocket-key2'])
    return require('./draft-00');
  // default: rfc6455
  return require('./rfc6455');
}

},{"./draft-00":"/home/vadzim/v/work/nerojs/node_modules/websockets/lib/websockets/draft-00.js","./draft-10":"/home/vadzim/v/work/nerojs/node_modules/websockets/lib/websockets/draft-10.js","./rfc6455":"/home/vadzim/v/work/nerojs/node_modules/websockets/lib/websockets/rfc6455.js","crypto":false,"events":false,"fs":false,"path":false,"url":false,"util":false}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Dumper.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Dumper, Inline, Utils;

Utils = require('./Utils');

Inline = require('./Inline');

Dumper = (function() {
  function Dumper() {}

  Dumper.indentation = 4;

  Dumper.prototype.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    var key, output, prefix, value, willBeInlined, _i, _len;
    if (inline == null) {
      inline = 0;
    }
    if (indent == null) {
      indent = 0;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    output = '';
    prefix = (indent ? Utils.strRepeat(' ', indent) : '');
    if (inline <= 0 || typeof input !== 'object' || input instanceof Date || Utils.isEmpty(input)) {
      output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
    } else {
      if (input instanceof Array) {
        for (_i = 0, _len = input.length; _i < _len; _i++) {
          value = input[_i];
          willBeInlined = inline - 1 <= 0 || typeof value !== 'object' || Utils.isEmpty(value);
          output += prefix + '-' + (willBeInlined ? ' ' : "\n") + this.dump(value, inline - 1, (willBeInlined ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : '');
        }
      } else {
        for (key in input) {
          value = input[key];
          willBeInlined = inline - 1 <= 0 || typeof value !== 'object' || Utils.isEmpty(value);
          output += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + ':' + (willBeInlined ? ' ' : "\n") + this.dump(value, inline - 1, (willBeInlined ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : '');
        }
      }
    }
    return output;
  };

  return Dumper;

})();

module.exports = Dumper;

},{"./Inline":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Inline.js","./Utils":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Utils.js"}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Escaper.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Escaper, Pattern;

Pattern = require('./Pattern');

Escaper = (function() {
  var ch;

  function Escaper() {}

  Escaper.LIST_ESCAPEES = ['\\\\', '\\"', '"', "\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x09", "\x0a", "\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", "\x16", "\x17", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1f", (ch = String.fromCharCode)(0x0085), ch(0x00A0), ch(0x2028), ch(0x2029)];

  Escaper.LIST_ESCAPED = ['\\"', '\\\\', '\\"', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"];

  Escaper.MAPPING_ESCAPEES_TO_ESCAPED = (function() {
    var i, mapping, _i, _ref;
    mapping = {};
    for (i = _i = 0, _ref = Escaper.LIST_ESCAPEES.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      mapping[Escaper.LIST_ESCAPEES[i]] = Escaper.LIST_ESCAPED[i];
    }
    return mapping;
  })();

  Escaper.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern('[\\x00-\\x1f]|\xc2\x85|\xc2\xa0|\xe2\x80\xa8|\xe2\x80\xa9');

  Escaper.PATTERN_MAPPING_ESCAPEES = new Pattern(Escaper.LIST_ESCAPEES.join('|'));

  Escaper.PATTERN_SINGLE_QUOTING = new Pattern('[\\s\'":{}[\\],&*#?]|^[-?|<>=!%@`]');

  Escaper.requiresDoubleQuoting = function(value) {
    return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
  };

  Escaper.escapeWithDoubleQuotes = function(value) {
    var result;
    result = this.PATTERN_MAPPING_ESCAPEES.replace(value, (function(_this) {
      return function(str) {
        return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
      };
    })(this));
    return '"' + result + '"';
  };

  Escaper.requiresSingleQuoting = function(value) {
    return this.PATTERN_SINGLE_QUOTING.test(value);
  };

  Escaper.escapeWithSingleQuotes = function(value) {
    return "'" + value.replace(/'/g, "''") + "'";
  };

  return Escaper;

})();

module.exports = Escaper;

},{"./Pattern":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Pattern.js"}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Exception/DumpException.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var DumpException,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

DumpException = (function(_super) {
  __extends(DumpException, _super);

  function DumpException(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  DumpException.prototype.toString = function() {
    if ((this.parsedLine != null) && (this.snippet != null)) {
      return '<DumpException> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<DumpException> ' + this.message;
    }
  };

  return DumpException;

})(Error);

module.exports = DumpException;

},{}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Exception/ParseException.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var ParseException,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ParseException = (function(_super) {
  __extends(ParseException, _super);

  function ParseException(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  ParseException.prototype.toString = function() {
    if ((this.parsedLine != null) && (this.snippet != null)) {
      return '<ParseException> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<ParseException> ' + this.message;
    }
  };

  return ParseException;

})(Error);

module.exports = ParseException;

},{}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Inline.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var DumpException, Escaper, Inline, ParseException, Pattern, Unescaper, Utils,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Pattern = require('./Pattern');

Unescaper = require('./Unescaper');

Escaper = require('./Escaper');

Utils = require('./Utils');

ParseException = require('./Exception/ParseException');

DumpException = require('./Exception/DumpException');

Inline = (function() {
  function Inline() {}

  Inline.REGEX_QUOTED_STRING = '(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'(?:[^\']*(?:\'\'[^\']*)*)\')';

  Inline.PATTERN_TRAILING_COMMENTS = new Pattern('^\\s*#.*$');

  Inline.PATTERN_QUOTED_SCALAR = new Pattern('^' + Inline.REGEX_QUOTED_STRING);

  Inline.PATTERN_THOUSAND_NUMERIC_SCALAR = new Pattern('^(-|\\+)?[0-9,]+(\\.[0-9]+)?$');

  Inline.PATTERN_SCALAR_BY_DELIMITERS = {};

  Inline.settings = {};

  Inline.configure = function(exceptionOnInvalidType, objectDecoder) {
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = null;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
    this.settings.objectDecoder = objectDecoder;
  };

  Inline.parse = function(value, exceptionOnInvalidType, objectDecoder) {
    var context, result;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
    this.settings.objectDecoder = objectDecoder;
    if (value == null) {
      return '';
    }
    value = Utils.trim(value);
    if (0 === value.length) {
      return '';
    }
    context = {
      exceptionOnInvalidType: exceptionOnInvalidType,
      objectDecoder: objectDecoder,
      i: 0
    };
    switch (value.charAt(0)) {
      case '[':
        result = this.parseSequence(value, context);
        ++context.i;
        break;
      case '{':
        result = this.parseMapping(value, context);
        ++context.i;
        break;
      default:
        result = this.parseScalar(value, null, ['"', "'"], context);
    }
    if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), '') !== '') {
      throw new ParseException('Unexpected characters near "' + value.slice(context.i) + '".');
    }
    return result;
  };

  Inline.dump = function(value, exceptionOnInvalidType, objectEncoder) {
    var result, type, _ref;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    if (value == null) {
      return 'null';
    }
    type = typeof value;
    if (type === 'object') {
      if (value instanceof Date) {
        return value.toISOString();
      } else if (objectEncoder != null) {
        result = objectEncoder(value);
        if (typeof result === 'string' || (result != null)) {
          return result;
        }
      }
      return this.dumpObject(value);
    }
    if (type === 'boolean') {
      return (value ? 'true' : 'false');
    }
    if (Utils.isDigits(value)) {
      return (type === 'string' ? "'" + value + "'" : String(parseInt(value)));
    }
    if (Utils.isNumeric(value)) {
      return (type === 'string' ? "'" + value + "'" : String(parseFloat(value)));
    }
    if (type === 'number') {
      return (value === Infinity ? '.Inf' : (value === -Infinity ? '-.Inf' : (isNaN(value) ? '.NaN' : value)));
    }
    if (Escaper.requiresDoubleQuoting(value)) {
      return Escaper.escapeWithDoubleQuotes(value);
    }
    if (Escaper.requiresSingleQuoting(value)) {
      return Escaper.escapeWithSingleQuotes(value);
    }
    if ('' === value) {
      return '""';
    }
    if (Utils.PATTERN_DATE.test(value)) {
      return "'" + value + "'";
    }
    if ((_ref = value.toLowerCase()) === 'null' || _ref === '~' || _ref === 'true' || _ref === 'false') {
      return "'" + value + "'";
    }
    return value;
  };

  Inline.dumpObject = function(value, exceptionOnInvalidType, objectSupport) {
    var key, output, val, _i, _len;
    if (objectSupport == null) {
      objectSupport = null;
    }
    if (value instanceof Array) {
      output = [];
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        val = value[_i];
        output.push(this.dump(val));
      }
      return '[' + output.join(', ') + ']';
    } else {
      output = [];
      for (key in value) {
        val = value[key];
        output.push(this.dump(key) + ': ' + this.dump(val));
      }
      return '{' + output.join(', ') + '}';
    }
  };

  Inline.parseScalar = function(scalar, delimiters, stringDelimiters, context, evaluate) {
    var i, joinedDelimiters, match, output, pattern, strpos, tmp, _ref, _ref1;
    if (delimiters == null) {
      delimiters = null;
    }
    if (stringDelimiters == null) {
      stringDelimiters = ['"', "'"];
    }
    if (context == null) {
      context = null;
    }
    if (evaluate == null) {
      evaluate = true;
    }
    if (context == null) {
      context = {
        exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
        objectDecoder: this.settings.objectDecoder,
        i: 0
      };
    }
    i = context.i;
    if (_ref = scalar.charAt(i), __indexOf.call(stringDelimiters, _ref) >= 0) {
      output = this.parseQuotedScalar(scalar, context);
      i = context.i;
      if (delimiters != null) {
        tmp = Utils.ltrim(scalar.slice(i), ' ');
        if (!(_ref1 = tmp.charAt(0), __indexOf.call(delimiters, _ref1) >= 0)) {
          throw new ParseException('Unexpected characters (' + scalar.slice(i) + ').');
        }
      }
    } else {
      if (!delimiters) {
        output = scalar.slice(i);
        i += output.length;
        strpos = output.indexOf(' #');
        if (strpos !== -1) {
          output = Utils.rtrim(output.slice(0, strpos));
        }
      } else {
        joinedDelimiters = delimiters.join('|');
        pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
        if (pattern == null) {
          pattern = new Pattern('^(.+?)(' + joinedDelimiters + ')');
          this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
        }
        if (match = pattern.exec(scalar.slice(i))) {
          output = match[1];
          i += output.length;
        } else {
          throw new ParseException('Malformed inline YAML string (' + scalar + ').');
        }
      }
      if (evaluate) {
        output = this.evaluateScalar(output, context);
      }
    }
    context.i = i;
    return output;
  };

  Inline.parseQuotedScalar = function(scalar, context) {
    var i, match, output;
    i = context.i;
    if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
      throw new ParseException('Malformed inline YAML string (' + scalar.slice(i) + ').');
    }
    output = match[0].substr(1, match[0].length - 2);
    if ('"' === scalar.charAt(i)) {
      output = Unescaper.unescapeDoubleQuotedString(output);
    } else {
      output = Unescaper.unescapeSingleQuotedString(output);
    }
    i += match[0].length;
    context.i = i;
    return output;
  };

  Inline.parseSequence = function(sequence, context) {
    var e, i, isQuoted, len, output, value, _ref;
    output = [];
    len = sequence.length;
    i = context.i;
    i += 1;
    while (i < len) {
      context.i = i;
      switch (sequence.charAt(i)) {
        case '[':
          output.push(this.parseSequence(sequence, context));
          i = context.i;
          break;
        case '{':
          output.push(this.parseMapping(sequence, context));
          i = context.i;
          break;
        case ']':
          return output;
        case ',':
        case ' ':
        case "\n":
          break;
        default:
          isQuoted = ((_ref = sequence.charAt(i)) === '"' || _ref === "'");
          value = this.parseScalar(sequence, [',', ']'], ['"', "'"], context);
          i = context.i;
          if (!isQuoted && typeof value === 'string' && (value.indexOf(': ') !== -1 || value.indexOf(":\n") !== -1)) {
            try {
              value = this.parseMapping('{' + value + '}');
            } catch (_error) {
              e = _error;
            }
          }
          output.push(value);
          --i;
      }
      ++i;
    }
    throw new ParseException('Malformed inline YAML string ' + sequence);
  };

  Inline.parseMapping = function(mapping, context) {
    var $value, done, i, key, len, output, shouldContinueWhileLoop, value;
    output = {};
    len = mapping.length;
    i = context.i;
    i += 1;
    shouldContinueWhileLoop = false;
    while (i < len) {
      context.i = i;
      switch (mapping.charAt(i)) {
        case ' ':
        case ',':
        case "\n":
          ++i;
          context.i = i;
          shouldContinueWhileLoop = true;
          break;
        case '}':
          return output;
      }
      if (shouldContinueWhileLoop) {
        shouldContinueWhileLoop = false;
        continue;
      }
      key = this.parseScalar(mapping, [':', ' ', "\n"], ['"', "'"], context, false);
      i = context.i;
      done = false;
      while (i < len) {
        context.i = i;
        switch (mapping.charAt(i)) {
          case '[':
            value = this.parseSequence(mapping, context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            break;
          case '{':
            $value = this.parseMapping(mapping, context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            break;
          case ':':
          case ' ':
          case "\n":
            break;
          default:
            value = this.parseScalar(mapping, [',', '}'], ['"', "'"], context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            --i;
        }
        ++i;
        if (done) {
          break;
        }
      }
    }
    throw new ParseException('Malformed inline YAML string ' + mapping);
  };

  Inline.evaluateScalar = function(scalar, context) {
    var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar;
    scalar = Utils.trim(scalar);
    scalarLower = scalar.toLowerCase();
    switch (scalarLower) {
      case 'null':
      case '':
      case '~':
        return null;
      case 'true':
        return true;
      case 'false':
        return false;
      case '.inf':
        return Infinity;
      case '.nan':
        return NaN;
      case '-.inf':
        return Infinity;
      default:
        firstChar = scalarLower.charAt(0);
        switch (firstChar) {
          case '!':
            firstSpace = scalar.indexOf(' ');
            if (firstSpace === -1) {
              firstWord = scalarLower;
            } else {
              firstWord = scalarLower.slice(0, firstSpace);
            }
            switch (firstWord) {
              case '!':
                if (firstSpace !== -1) {
                  return parseInt(this.parseScalar(scalar.slice(2)));
                }
                return null;
              case '!str':
                return Utils.ltrim(scalar.slice(4));
              case '!!str':
                return Utils.ltrim(scalar.slice(5));
              case '!!int':
                return parseInt(this.parseScalar(scalar.slice(5)));
              case '!!bool':
                return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);
              case '!!float':
                return parseFloat(this.parseScalar(scalar.slice(7)));
              case '!!timestamp':
                return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));
              default:
                if (context == null) {
                  context = {
                    exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                    objectDecoder: this.settings.objectDecoder,
                    i: 0
                  };
                }
                objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;
                if (objectDecoder) {
                  trimmedScalar = Utils.rtrim(scalar);
                  firstSpace = trimmedScalar.indexOf(' ');
                  if (firstSpace === -1) {
                    return objectDecoder(trimmedScalar, null);
                  } else {
                    subValue = Utils.ltrim(trimmedScalar.slice(firstSpace + 1));
                    if (!(subValue.length > 0)) {
                      subValue = null;
                    }
                    return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                  }
                }
                if (exceptionOnInvalidType) {
                  throw new ParseException('Custom object support when parsing a YAML file has been disabled.');
                }
                return null;
            }
            break;
          case '0':
            if ('0x' === scalar.slice(0, 2)) {
              return Utils.hexDec(scalar);
            } else if (Utils.isDigits(scalar)) {
              return Utils.octDec(scalar);
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else {
              return scalar;
            }
            break;
          case '+':
            if (Utils.isDigits(scalar)) {
              raw = scalar;
              cast = parseInt(raw);
              if (raw === String(cast)) {
                return cast;
              } else {
                return raw;
              }
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
          case '-':
            if (Utils.isDigits(scalar.slice(1))) {
              if ('0' === scalar.charAt(1)) {
                return -Utils.octDec(scalar.slice(1));
              } else {
                raw = scalar.slice(1);
                cast = parseInt(raw);
                if (raw === String(cast)) {
                  return -cast;
                } else {
                  return -raw;
                }
              }
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
          default:
            if (date = Utils.stringToDate(scalar)) {
              return date;
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
        }
    }
  };

  return Inline;

})();

module.exports = Inline;

},{"./Escaper":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Escaper.js","./Exception/DumpException":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Exception/DumpException.js","./Exception/ParseException":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Exception/ParseException.js","./Pattern":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Pattern.js","./Unescaper":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Unescaper.js","./Utils":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Utils.js"}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Parser.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Inline, ParseException, Parser, Pattern, Utils;

Inline = require('./Inline');

Pattern = require('./Pattern');

Utils = require('./Utils');

ParseException = require('./Exception/ParseException');

Parser = (function() {
  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\|>]*)\\s+)?(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$');

  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$');

  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\-((?<leadspaces>\\s+)(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');

  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \'"\\{\\[].*?) *\\:(\\s+(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \'"\\[\\{].*?) *\\:(\\s+(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\d+');

  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');

  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\n*)$');

  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\%YAML[: ][\\d\\.]+.*\n');

  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\#.*?\n)+');

  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\-\\-\\-.*?\n');

  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\.\\.\\.\\s*$');

  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};

  Parser.prototype.CONTEXT_NONE = 0;

  Parser.prototype.CONTEXT_SEQUENCE = 1;

  Parser.prototype.CONTEXT_MAPPING = 2;

  function Parser(offset) {
    this.offset = offset != null ? offset : 0;
    this.lines = [];
    this.currentLineNb = -1;
    this.currentLine = '';
    this.refs = {};
  }

  Parser.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {
    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, k, key, lastKey, lineCount, matches, mergeNode, parsed, parsedItem, parser, refName, refValue, val, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _name, _ref, _ref1, _ref2;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.currentLineNb = -1;
    this.currentLine = '';
    this.lines = this.cleanup(value).split("\n");
    data = null;
    context = this.CONTEXT_NONE;
    allowOverwrite = false;
    while (this.moveToNextLine()) {
      if (this.isCurrentLineEmpty()) {
        continue;
      }
      if ("\t" === this.currentLine[0]) {
        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
      isRef = mergeNode = false;
      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
        if (this.CONTEXT_MAPPING === context) {
          throw new ParseException('You cannot define a sequence item when in a mapping');
        }
        context = this.CONTEXT_SEQUENCE;
        if (data == null) {
          data = [];
        }
        if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
          isRef = matches.ref;
          values.value = matches.value;
        }
        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {
          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
          } else {
            data.push(null);
          }
        } else {
          if (((_ref = values.leadspaces) != null ? _ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {
            c = this.getRealCurrentLineNb();
            parser = new Parser(c);
            parser.refs = this.refs;
            block = values.value;
            indent = this.getCurrentLineIndentation();
            if (this.isNextLineIndented(false)) {
              block += "\n" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
            }
            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
          } else {
            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
          }
        }
      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {
        if (this.CONTEXT_SEQUENCE === context) {
          throw new ParseException('You cannot define a mapping item when in a sequence');
        }
        context = this.CONTEXT_MAPPING;
        if (data == null) {
          data = {};
        }
        Inline.configure(exceptionOnInvalidType, objectDecoder);
        try {
          key = Inline.parseScalar(values.key);
        } catch (_error) {
          e = _error;
          e.parsedLine = this.getRealCurrentLineNb() + 1;
          e.snippet = this.currentLine;
          throw e;
        }
        if ('<<' === key) {
          mergeNode = true;
          allowOverwrite = true;
          if (((_ref1 = values.value) != null ? _ref1.indexOf('*') : void 0) === 0) {
            refName = values.value.slice(1);
            if (this.refs[refName] == null) {
              throw new ParseException('Reference "' + refName + '" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            refValue = this.refs[refName];
            if (typeof refValue !== 'object') {
              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            if (refValue instanceof Array) {
              for (i = _i = 0, _len = refValue.length; _i < _len; i = ++_i) {
                value = refValue[i];
                if (data[_name = String(i)] == null) {
                  data[_name] = value;
                }
              }
            } else {
              for (key in refValue) {
                value = refValue[key];
                if (data[key] == null) {
                  data[key] = value;
                }
              }
            }
          } else {
            if ((values.value != null) && values.value !== '') {
              value = values.value;
            } else {
              value = this.getNextEmbedBlock();
            }
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            parsed = parser.parse(value, exceptionOnInvalidType);
            if (typeof parsed !== 'object') {
              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            if (parsed instanceof Array) {
              for (_j = 0, _len1 = parsed.length; _j < _len1; _j++) {
                parsedItem = parsed[_j];
                if (typeof parsedItem !== 'object') {
                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);
                }
                if (parsedItem instanceof Array) {
                  for (i = _k = 0, _len2 = parsedItem.length; _k < _len2; i = ++_k) {
                    value = parsedItem[i];
                    k = String(i);
                    if (!data.hasOwnProperty(k)) {
                      data[k] = value;
                    }
                  }
                } else {
                  for (key in parsedItem) {
                    value = parsedItem[key];
                    if (!data.hasOwnProperty(key)) {
                      data[key] = value;
                    }
                  }
                }
              }
            } else {
              for (key in parsed) {
                value = parsed[key];
                if (!data.hasOwnProperty(key)) {
                  data[key] = value;
                }
              }
            }
          }
        } else if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
          isRef = matches.ref;
          values.value = matches.value;
        }
        if (mergeNode) {

        } else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {
          if (!(this.isNextLineIndented()) && !(this.isNextLineUnIndentedCollection())) {
            if (allowOverwrite || data[key] === void 0) {
              data[key] = null;
            }
          } else {
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);
            if (allowOverwrite || data[key] === void 0) {
              data[key] = val;
            }
          }
        } else {
          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);
          if (allowOverwrite || data[key] === void 0) {
            data[key] = val;
          }
        }
      } else {
        lineCount = this.lines.length;
        if (1 === lineCount || (2 === lineCount && Utils.isEmpty(this.lines[1]))) {
          try {
            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);
          } catch (_error) {
            e = _error;
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
          if (typeof value === 'object') {
            if (value instanceof Array) {
              first = value[0];
            } else {
              for (key in value) {
                first = value[key];
                break;
              }
            }
            if (typeof first === 'string' && first.indexOf('*') === 0) {
              data = [];
              for (_l = 0, _len3 = value.length; _l < _len3; _l++) {
                alias = value[_l];
                data.push(this.refs[alias.slice(1)]);
              }
              value = data;
            }
          }
          return value;
        } else if ((_ref2 = Utils.ltrim(value).charAt(0)) === '[' || _ref2 === '{') {
          try {
            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
          } catch (_error) {
            e = _error;
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
        }
        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
      if (isRef) {
        if (data instanceof Array) {
          this.refs[isRef] = data[data.length - 1];
        } else {
          lastKey = null;
          for (key in data) {
            lastKey = key;
          }
          this.refs[isRef] = data[lastKey];
        }
      }
    }
    if (Utils.isEmpty(data)) {
      return null;
    } else {
      return data;
    }
  };

  Parser.prototype.getRealCurrentLineNb = function() {
    return this.currentLineNb + this.offset;
  };

  Parser.prototype.getCurrentLineIndentation = function() {
    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;
  };

  Parser.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {
    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;
    if (indentation == null) {
      indentation = null;
    }
    if (includeUnindentedCollection == null) {
      includeUnindentedCollection = false;
    }
    this.moveToNextLine();
    if (indentation == null) {
      newIndent = this.getCurrentLineIndentation();
      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);
      if (!(this.isCurrentLineEmpty()) && 0 === newIndent && !unindentedEmbedBlock) {
        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
    } else {
      newIndent = indentation;
    }
    data = [this.currentLine.slice(newIndent)];
    if (!includeUnindentedCollection) {
      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
    }
    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
    removeComments = !removeCommentsPattern.test(this.currentLine);
    while (this.moveToNextLine()) {
      indent = this.getCurrentLineIndentation();
      if (indent === newIndent) {
        removeComments = !removeCommentsPattern.test(this.currentLine);
      }
      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {
        this.moveToPreviousLine();
        break;
      }
      if (this.isCurrentLineBlank()) {
        data.push(this.currentLine.slice(newIndent));
        continue;
      }
      if (removeComments && this.isCurrentLineComment()) {
        if (indent === newIndent) {
          continue;
        }
      }
      if (indent >= newIndent) {
        data.push(this.currentLine.slice(newIndent));
      } else if (0 === indent) {
        this.moveToPreviousLine();
        break;
      } else {
        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
    }
    return data.join("\n");
  };

  Parser.prototype.moveToNextLine = function() {
    if (this.currentLineNb >= this.lines.length - 1) {
      return false;
    }
    this.currentLine = this.lines[++this.currentLineNb];
    return true;
  };

  Parser.prototype.moveToPreviousLine = function() {
    this.currentLine = this.lines[--this.currentLineNb];
  };

  Parser.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {
    var e, foldedIndent, matches, modifiers, pos, val, _ref, _ref1;
    if (0 === value.indexOf('*')) {
      pos = value.indexOf('#');
      if (pos !== -1) {
        value = value.substr(1, pos - 2);
      } else {
        value = value.slice(1);
      }
      if (this.refs[value] === void 0) {
        throw new ParseException('Reference "' + value + '" does not exist.', this.currentLine);
      }
      return this.refs[value];
    }
    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
      modifiers = (_ref = matches.modifiers) != null ? _ref : '';
      foldedIndent = Math.abs(parseInt(modifiers));
      if (isNaN(foldedIndent)) {
        foldedIndent = 0;
      }
      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);
      if (matches.type != null) {
        Inline.configure(exceptionOnInvalidType, objectDecoder);
        return Inline.parseScalar(matches.type + ' ' + val);
      } else {
        return val;
      }
    }
    try {
      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
    } catch (_error) {
      e = _error;
      if (((_ref1 = value.charAt(0)) === '[' || _ref1 === '{') && e instanceof ParseException && this.isNextLineIndented()) {
        value += "\n" + this.getNextEmbedBlock();
        try {
          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
        } catch (_error) {
          e = _error;
          e.parsedLine = this.getRealCurrentLineNb() + 1;
          e.snippet = this.currentLine;
          throw e;
        }
      } else {
        e.parsedLine = this.getRealCurrentLineNb() + 1;
        e.snippet = this.currentLine;
        throw e;
      }
    }
  };

  Parser.prototype.parseFoldedScalar = function(separator, indicator, indentation) {
    var isCurrentLineBlank, line, matches, newText, notEOF, pattern, text, _i, _len, _ref;
    if (indicator == null) {
      indicator = '';
    }
    if (indentation == null) {
      indentation = 0;
    }
    notEOF = this.moveToNextLine();
    if (!notEOF) {
      return '';
    }
    isCurrentLineBlank = this.isCurrentLineBlank();
    text = '';
    while (notEOF && isCurrentLineBlank) {
      if (notEOF = this.moveToNextLine()) {
        text += "\n";
        isCurrentLineBlank = this.isCurrentLineBlank();
      }
    }
    if (0 === indentation) {
      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
        indentation = matches[0].length;
      }
    }
    if (indentation > 0) {
      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];
      if (pattern == null) {
        pattern = new Pattern('^ {' + indentation + '}(.*)$');
        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
      }
      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
        if (isCurrentLineBlank) {
          text += this.currentLine.slice(indentation);
        } else {
          text += matches[1];
        }
        if (notEOF = this.moveToNextLine()) {
          text += "\n";
          isCurrentLineBlank = this.isCurrentLineBlank();
        }
      }
    } else if (notEOF) {
      text += "\n";
    }
    if (notEOF) {
      this.moveToPreviousLine();
    }
    if ('>' === separator) {
      newText = '';
      _ref = text.split("\n");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (line.length === 0 || line.charAt(0) === ' ') {
          newText = Utils.rtrim(newText, ' ') + line + "\n";
        } else {
          newText += line + ' ';
        }
      }
      text = newText;
    }
    if ('+' !== indicator) {
      text = Utils.rtrim(text);
    }
    if ('' === indicator) {
      text = this.PATTERN_TRAILING_LINES.replace(text, "\n");
    } else if ('-' === indicator) {
      text = this.PATTERN_TRAILING_LINES.replace(text, '');
    }
    return text;
  };

  Parser.prototype.isNextLineIndented = function(ignoreComments) {
    var EOF, currentIndentation, ret;
    if (ignoreComments == null) {
      ignoreComments = true;
    }
    currentIndentation = this.getCurrentLineIndentation();
    EOF = !this.moveToNextLine();
    if (ignoreComments) {
      while (!EOF && this.isCurrentLineEmpty()) {
        EOF = !this.moveToNextLine();
      }
    } else {
      while (!EOF && this.isCurrentLineBlank()) {
        EOF = !this.moveToNextLine();
      }
    }
    if (EOF) {
      return false;
    }
    ret = false;
    if (this.getCurrentLineIndentation() > currentIndentation) {
      ret = true;
    }
    this.moveToPreviousLine();
    return ret;
  };

  Parser.prototype.isCurrentLineEmpty = function() {
    var trimmedLine;
    trimmedLine = Utils.trim(this.currentLine, ' ');
    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';
  };

  Parser.prototype.isCurrentLineBlank = function() {
    return '' === Utils.trim(this.currentLine, ' ');
  };

  Parser.prototype.isCurrentLineComment = function() {
    var ltrimmedLine;
    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');
    return ltrimmedLine.charAt(0) === '#';
  };

  Parser.prototype.cleanup = function(value) {
    var count, trimmedValue, _ref, _ref1, _ref2;
    if (value.indexOf("\r") !== -1) {
      value = value.split("\r\n").join("\n").split("\r").join("\n");
    }
    count = 0;
    _ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = _ref[0], count = _ref[1];
    this.offset += count;
    _ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = _ref1[0], count = _ref1[1];
    if (count === 1) {
      this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
      value = trimmedValue;
    }
    _ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = _ref2[0], count = _ref2[1];
    if (count === 1) {
      this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
      value = trimmedValue;
      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');
    }
    return value;
  };

  Parser.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {
    var notEOF, ret;
    if (currentIndentation == null) {
      currentIndentation = null;
    }
    if (currentIndentation == null) {
      currentIndentation = this.getCurrentLineIndentation();
    }
    notEOF = this.moveToNextLine();
    while (notEOF && this.isCurrentLineEmpty()) {
      notEOF = this.moveToNextLine();
    }
    if (false === notEOF) {
      return false;
    }
    ret = false;
    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {
      ret = true;
    }
    this.moveToPreviousLine();
    return ret;
  };

  Parser.prototype.isStringUnIndentedCollectionItem = function() {
    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';
  };

  return Parser;

})();

module.exports = Parser;

},{"./Exception/ParseException":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Exception/ParseException.js","./Inline":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Inline.js","./Pattern":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Pattern.js","./Utils":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Utils.js"}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Pattern.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Pattern;

Pattern = (function() {
  Pattern.prototype.regex = null;

  Pattern.prototype.rawRegex = null;

  Pattern.prototype.cleanedRegex = null;

  Pattern.prototype.mapping = null;

  function Pattern(rawRegex, modifiers) {
    var capturingBracketNumber, char, cleanedRegex, i, len, mapping, name, part, subChar;
    if (modifiers == null) {
      modifiers = '';
    }
    cleanedRegex = '';
    len = rawRegex.length;
    mapping = null;
    capturingBracketNumber = 0;
    i = 0;
    while (i < len) {
      char = rawRegex.charAt(i);
      if (char === '\\') {
        cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
        i++;
      } else if (char === '(') {
        if (i < len - 2) {
          part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
          if (part === '(?:') {
            i += 2;
            cleanedRegex += part;
          } else if (part === '(?<') {
            capturingBracketNumber++;
            i += 2;
            name = '';
            while (i + 1 < len) {
              subChar = rawRegex.charAt(i + 1);
              if (subChar === '>') {
                cleanedRegex += '(';
                i++;
                if (name.length > 0) {
                  if (mapping == null) {
                    mapping = {};
                  }
                  mapping[name] = capturingBracketNumber;
                }
                break;
              } else {
                name += subChar;
              }
              i++;
            }
          } else {
            cleanedRegex += char;
            capturingBracketNumber++;
          }
        } else {
          cleanedRegex += char;
        }
      } else {
        cleanedRegex += char;
      }
      i++;
    }
    this.rawRegex = rawRegex;
    this.cleanedRegex = cleanedRegex;
    this.regex = new RegExp(this.cleanedRegex, 'g' + modifiers.replace('g', ''));
    this.mapping = mapping;
  }

  Pattern.prototype.exec = function(str) {
    var index, matches, name, _ref;
    this.regex.lastIndex = 0;
    matches = this.regex.exec(str);
    if (matches == null) {
      return null;
    }
    if (this.mapping != null) {
      _ref = this.mapping;
      for (name in _ref) {
        index = _ref[name];
        matches[name] = matches[index];
      }
    }
    return matches;
  };

  Pattern.prototype.test = function(str) {
    this.regex.lastIndex = 0;
    return this.regex.test(str);
  };

  Pattern.prototype.replace = function(str, replacement) {
    this.regex.lastIndex = 0;
    return str.replace(this.regex, replacement);
  };

  Pattern.prototype.replaceAll = function(str, replacement, limit) {
    var count;
    if (limit == null) {
      limit = 0;
    }
    this.regex.lastIndex = 0;
    count = 0;
    while (this.regex.test(str) && (limit === 0 || count < limit)) {
      this.regex.lastIndex = 0;
      str = str.replace(this.regex, '');
      count++;
    }
    return [str, count];
  };

  return Pattern;

})();

module.exports = Pattern;

},{}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Unescaper.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Pattern, Unescaper, Utils;

Utils = require('./Utils');

Pattern = require('./Pattern');

Unescaper = (function() {
  function Unescaper() {}

  Unescaper.PATTERN_ESCAPED_CHARACTER = new Pattern('\\\\([0abt\tnvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})');

  Unescaper.unescapeSingleQuotedString = function(value) {
    return value.replace('\'\'', '\'');
  };

  Unescaper.unescapeDoubleQuotedString = function(value) {
    if (this._unescapeCallback == null) {
      this._unescapeCallback = (function(_this) {
        return function(str) {
          return _this.unescapeCharacter(str);
        };
      })(this);
    }
    return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
  };

  Unescaper.unescapeCharacter = function(value) {
    var ch;
    ch = String.fromCharCode;
    switch (value.charAt(1)) {
      case '0':
        return ch(0);
      case 'a':
        return ch(7);
      case 'b':
        return ch(8);
      case 't':
        return "\t";
      case "\t":
        return "\t";
      case 'n':
        return "\n";
      case 'v':
        return ch(11);
      case 'f':
        return ch(12);
      case 'r':
        return ch(13);
      case 'e':
        return ch(27);
      case ' ':
        return ' ';
      case '"':
        return '"';
      case '/':
        return '/';
      case '\\':
        return '\\';
      case 'N':
        return ch(0x0085);
      case '_':
        return ch(0x00A0);
      case 'L':
        return ch(0x2028);
      case 'P':
        return ch(0x2029);
      case 'x':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 2)));
      case 'u':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));
      case 'U':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));
      default:
        return '';
    }
  };

  return Unescaper;

})();

module.exports = Unescaper;

},{"./Pattern":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Pattern.js","./Utils":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Utils.js"}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Utils.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Pattern, Utils;

Pattern = require('./Pattern');

Utils = (function() {
  function Utils() {}

  Utils.REGEX_LEFT_TRIM_BY_CHAR = {};

  Utils.REGEX_RIGHT_TRIM_BY_CHAR = {};

  Utils.REGEX_SPACES = /\s+/g;

  Utils.REGEX_DIGITS = /^\d+$/;

  Utils.REGEX_OCTAL = /[^0-7]/gi;

  Utils.REGEX_HEXADECIMAL = /[^a-f0-9]/gi;

  Utils.PATTERN_DATE = new Pattern('^' + '(?<year>[0-9][0-9][0-9][0-9])' + '-(?<month>[0-9][0-9]?)' + '-(?<day>[0-9][0-9]?)' + '(?:(?:[Tt]|[ \t]+)' + '(?<hour>[0-9][0-9]?)' + ':(?<minute>[0-9][0-9])' + ':(?<second>[0-9][0-9])' + '(?:\.(?<fraction>[0-9]*))?' + '(?:[ \t]*(?<tz>Z|(?<tz_sign>[-+])(?<tz_hour>[0-9][0-9]?)' + '(?::(?<tz_minute>[0-9][0-9]))?))?)?' + '$', 'i');

  Utils.LOCAL_TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;

  Utils.trim = function(str, char) {
    var regexLeft, regexRight;
    if (char == null) {
      char = '\\s';
    }
    return str.trim();
    regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[char];
    if (regexLeft == null) {
      this.REGEX_LEFT_TRIM_BY_CHAR[char] = regexLeft = new RegExp('^' + char + '' + char + '*');
    }
    regexLeft.lastIndex = 0;
    regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[char];
    if (regexRight == null) {
      this.REGEX_RIGHT_TRIM_BY_CHAR[char] = regexRight = new RegExp(char + '' + char + '*$');
    }
    regexRight.lastIndex = 0;
    return str.replace(regexLeft, '').replace(regexRight, '');
  };

  Utils.ltrim = function(str, char) {
    var regexLeft;
    if (char == null) {
      char = '\\s';
    }
    regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[char];
    if (regexLeft == null) {
      this.REGEX_LEFT_TRIM_BY_CHAR[char] = regexLeft = new RegExp('^' + char + '' + char + '*');
    }
    regexLeft.lastIndex = 0;
    return str.replace(regexLeft, '');
  };

  Utils.rtrim = function(str, char) {
    var regexRight;
    if (char == null) {
      char = '\\s';
    }
    regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[char];
    if (regexRight == null) {
      this.REGEX_RIGHT_TRIM_BY_CHAR[char] = regexRight = new RegExp(char + '' + char + '*$');
    }
    regexRight.lastIndex = 0;
    return str.replace(regexRight, '');
  };

  Utils.isEmpty = function(value) {
    return !value || value === '' || value === '0';
  };

  Utils.subStrCount = function(string, subString, start, length) {
    var c, i, len, sublen, _i;
    c = 0;
    string = '' + string;
    subString = '' + subString;
    if (start != null) {
      string = string.slice(start);
    }
    if (length != null) {
      string = string.slice(0, length);
    }
    len = string.length;
    sublen = subString.length;
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
      if (subString === string.slice(i, sublen)) {
        c++;
        i += sublen - 1;
      }
    }
    return c;
  };

  Utils.isDigits = function(input) {
    this.REGEX_DIGITS.lastIndex = 0;
    return this.REGEX_DIGITS.test(input);
  };

  Utils.octDec = function(input) {
    this.REGEX_OCTAL.lastIndex = 0;
    return parseInt((input + '').replace(this.REGEX_OCTAL, ''), 8);
  };

  Utils.hexDec = function(input) {
    this.REGEX_HEXADECIMAL.lastIndex = 0;
    input = this.trim(input);
    if ((input + '').slice(0, 2) === '0x') {
      input = (input + '').slice(2);
    }
    return parseInt((input + '').replace(this.REGEX_HEXADECIMAL, ''), 16);
  };

  Utils.utf8chr = function(c) {
    var ch;
    ch = String.fromCharCode;
    if (0x80 > (c %= 0x200000)) {
      return ch(c);
    }
    if (0x800 > c) {
      return ch(0xC0 | c >> 6) + ch(0x80 | c & 0x3F);
    }
    if (0x10000 > c) {
      return ch(0xE0 | c >> 12) + ch(0x80 | c >> 6 & 0x3F) + ch(0x80 | c & 0x3F);
    }
    return ch(0xF0 | c >> 18) + ch(0x80 | c >> 12 & 0x3F) + ch(0x80 | c >> 6 & 0x3F) + ch(0x80 | c & 0x3F);
  };

  Utils.parseBoolean = function(input, strict) {
    var lowerInput;
    if (strict == null) {
      strict = true;
    }
    if (typeof input === 'string') {
      lowerInput = input.toLowerCase();
      if (!strict) {
        if (lowerInput === 'no') {
          return false;
        }
      }
      if (lowerInput === '0') {
        return false;
      }
      if (lowerInput === 'false') {
        return false;
      }
      if (lowerInput === '') {
        return false;
      }
      return true;
    }
    return !!input;
  };

  Utils.isNumeric = function(input) {
    this.REGEX_SPACES.lastIndex = 0;
    return typeof input === 'number' || typeof input === 'string' && !isNaN(input) && input.replace(this.REGEX_SPACES, '') !== '';
  };

  Utils.stringToDate = function(str) {
    var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;
    if (!(str != null ? str.length : void 0)) {
      return null;
    }
    info = this.PATTERN_DATE.exec(str);
    if (!info) {
      return null;
    }
    year = parseInt(info.year, 10);
    month = parseInt(info.month, 10) - 1;
    day = parseInt(info.day, 10);
    if (info.hour == null) {
      date = new Date(Date.UTC(year, month, day));
      return date;
    }
    hour = parseInt(info.hour, 10);
    minute = parseInt(info.minute, 10);
    second = parseInt(info.second, 10);
    if (info.fraction != null) {
      fraction = info.fraction.slice(0, 3);
      while (fraction.length < 3) {
        fraction += '0';
      }
      fraction = parseInt(fraction, 10);
    } else {
      fraction = 0;
    }
    if (info.tz != null) {
      tz_hour = parseInt(info.tz_hour, 10);
      if (info.tz_minute != null) {
        tz_minute = parseInt(info.tz_minute, 10);
      } else {
        tz_minute = 0;
      }
      tz_offset = (tz_hour * 60 + tz_minute) * 60000;
      if ('-' === info.tz_sign) {
        tz_offset *= -1;
      }
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (tz_offset) {
      date.setTime(date.getTime() + tz_offset);
    }
    return date;
  };

  Utils.strRepeat = function(str, number) {
    var i, res;
    res = '';
    i = 0;
    while (i < number) {
      res += str;
      i++;
    }
    return res;
  };

  Utils.getStringFromFile = function(path, callback) {
    var data, fs, name, req, xhr, _i, _len, _ref;
    if (callback == null) {
      callback = null;
    }
    xhr = null;
    if (typeof window !== "undefined" && window !== null) {
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else if (window.ActiveXObject) {
        _ref = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          try {
            xhr = new ActiveXObject(name);
          } catch (_error) {}
        }
      }
    }
    if (xhr != null) {
      if (callback != null) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200 || xhr.status === 0) {
              return callback(xhr.responseText);
            } else {
              return callback(null);
            }
          }
        };
        xhr.open('GET', path, true);
        return xhr.send(null);
      } else {
        xhr.open('GET', path, false);
        xhr.send(null);
        if (xhr.status === 200 || xhr.status === 0) {
          return xhr.responseText;
        }
        return null;
      }
    } else {
      req = require;
      fs = req('fs');
      if (callback != null) {
        return fs.readFile(path, function(err, data) {
          if (err) {
            return callback(null);
          } else {
            return callback(String(data));
          }
        });
      } else {
        data = fs.readFileSync(path);
        if (data != null) {
          return String(data);
        }
        return null;
      }
    }
  };

  return Utils;

})();

module.exports = Utils;

},{"./Pattern":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Pattern.js"}],"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Yaml.js":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Dumper, Parser, Utils, Yaml;

Parser = require('./Parser');

Dumper = require('./Dumper');

Utils = require('./Utils');

Yaml = (function() {
  function Yaml() {}

  Yaml.parse = function(input, exceptionOnInvalidType, objectDecoder) {
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    return new Parser().parse(input, exceptionOnInvalidType, objectDecoder);
  };

  Yaml.parseFile = function(path, callback, exceptionOnInvalidType, objectDecoder) {
    var input;
    if (callback == null) {
      callback = null;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    if (callback != null) {
      return Utils.getStringFromFile(path, (function(_this) {
        return function(input) {
          var result;
          result = null;
          if (input != null) {
            result = _this.parse(input, exceptionOnInvalidType, objectDecoder);
          }
          callback(result);
        };
      })(this));
    } else {
      input = Utils.getStringFromFile(path);
      if (input != null) {
        return this.parse(input, exceptionOnInvalidType, objectDecoder);
      }
      return null;
    }
  };

  Yaml.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    var yaml;
    if (inline == null) {
      inline = 2;
    }
    if (indent == null) {
      indent = 4;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    yaml = new Dumper();
    yaml.indentation = indent;
    return yaml.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
  };

  Yaml.register = function() {
    var require_handler;
    require_handler = function(module, filename) {
      return module.exports = YAML.parseFile(filename);
    };
    if ((typeof require !== "undefined" && require !== null ? require.extensions : void 0) != null) {
      require.extensions['.yml'] = require_handler;
      return require.extensions['.yaml'] = require_handler;
    }
  };

  Yaml.stringify = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    return this.dump(input, inline, indent, exceptionOnInvalidType, objectEncoder);
  };

  Yaml.load = function(path, callback, exceptionOnInvalidType, objectDecoder) {
    return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
  };

  return Yaml;

})();

if (typeof window !== "undefined" && window !== null) {
  window.YAML = Yaml;
}

module.exports = Yaml;

},{"./Dumper":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Dumper.js","./Parser":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Parser.js","./Utils":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Utils.js"}],"/home/vadzim/v/work/nerojs/src/JSONTransform.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/JSONTransform.js" ] = total
        }
      }( function () {
        "use strict";
var Duplex = require("stream").Duplex;
exports.parse = function(stream) {
  var ret = new Duplex;
  var buffer = "";
  var pushStr = (function(str) {
    str = str.trim();
    if (str)
      try {
        ret.emit("data", JSON.parse(str));
      } catch (error) {
        ret.emit("error", error);
      }
  });
  stream.on("data", (function(chunk) {
    buffer += String(chunk);
    var ret = buffer.split("\n");
    buffer = ret.pop();
    ret.forEach(pushStr);
  }));
  stream.on("end", (function() {
    pushStr(buffer);
    buffer = "";
    ret.push(null);
  }));
  stream.on("error", (function(error) {
    return ret.emit("error", error);
  }));
  ret.on("end", (function() {
    return stream.end();
  }));
  ret._read = (function(n) {});
  ret._write = (function(obj) {});
  ret.write = (function(obj) {
    var text = JSON.stringify(obj);
    text += "\n";
    text = new Buffer(text);
    stream.write(text);
  });
  return ret;
};

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/JSONTransform.map

      } )
    }()

},{"stream":false}],"/home/vadzim/v/work/nerojs/src/JSONservice.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/JSONservice.js" ] = total
        }
      }( function () {
        "use strict";
var $__2;
var path = require("path");
var Immutable = require("immutable");
var co = require("co");
var ra = require("ra");
var fs = require("fs");
var UID = require("uid");
var lu = require("localUtils");
var HTTPStatus = require("http-status");
var MAX_CACHE_SIZE = 10000;
var SLEEP_BETWEEN_SAVES = 300;
var mkdir = co.cb(fs.mkdir);
var writeFile = co.cb(fs.writeFile);
var readFile = co.cb(fs.readFile);
var JSONservice = function JSONservice(file, template) {
  var $__0 = this;
  var M = ra.clean({
    map: null,
    savedUID: null,
    get readFile() {
      return $traceurRuntime.initGeneratorFunction(function $__5() {
        var json,
            text,
            $__6,
            $__7,
            $__8,
            _;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $ctx.pushTry(11, null);
                $ctx.state = 14;
                break;
              case 14:
                $__6 = readFile(file);
                $ctx.state = 6;
                break;
              case 6:
                $ctx.state = 2;
                return $__6;
              case 2:
                $__7 = $ctx.sent;
                $ctx.state = 4;
                break;
              case 4:
                $__8 = String($__7);
                text = $__8;
                $ctx.state = 8;
                break;
              case 8:
                try {
                  json = YAML.parse(text);
                } catch (error) {
                  try {
                    json = JSON.parse(text);
                  } catch (_) {
                    throw error;
                  }
                }
                if (!json.uid)
                  UID(json);
                $ctx.state = 10;
                break;
              case 10:
                $ctx.popTry();
                $ctx.state = 16;
                break;
              case 11:
                $ctx.popTry();
                _ = $ctx.storedException;
                $ctx.state = 17;
                break;
              case 17:
                json = UID(template);
                $ctx.state = 16;
                break;
              case 16:
                M.savedUID = json.uid;
                M.map = Immutable.OrderedMap().set(json.uid, json);
                $ctx.state = -2;
                break;
              default:
                return $ctx.end();
            }
        }, $__5, this);
      }).call(this);
    },
    last: {
      get $() {
        return M.map && {
          json: M.map.last(),
          text: JSON.stringify(M.map.last(), null, "\t")
        };
      },
      text: null,
      json: {uid: null}
    },
    get writeFile() {
      return $traceurRuntime.initGeneratorFunction(function $__5() {
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $ctx.state = 2;
                return co.sleep(SLEEP_BETWEEN_SAVES);
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              case 4:
                $ctx.state = (M.savedUID != M.last.json.uid) ? 9 : -2;
                break;
              case 9:
                M.savedUID = M.last.json.uid;
                $ctx.state = 10;
                break;
              case 10:
                $ctx.state = 6;
                return writeFile(file, M.last.text).catch(lu.rethrow);
              case 6:
                $ctx.maybeThrow();
                $ctx.state = -2;
                break;
              default:
                return $ctx.end();
            }
        }, $__5, this);
      })();
    }
  }).setName(path.basename(file, ".json"));
  this.getState = (function() {
    return lu.valueOf(M.last.json);
  });
  this.waitForChange = $traceurRuntime.initGeneratorFunction(function $__5(response) {
    var polling;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            polling = response && lu.polling(response);
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return M.last.live.text;
          case 2:
            $ctx.maybeThrow();
            $ctx.state = 4;
            break;
          case 4:
            polling && polling.stop();
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__5, this);
  });
  this.waitForReady = (function(response) {
    return !M.last.text && $__0.waitForChange(response);
  });
  this.applyChanges = (function(changes) {
    var partial = arguments[1] !== (void 0) ? arguments[1] : true;
    var json = M.last.json.valueOf();
    var n = (partial ? lu.applyDiff : lu.assignDiff)(json, changes) || {};
    if (n !== json) {
      M.map = (partial ? M.map : Immutable.OrderedMap()).withMutations((function(map) {
        while (map.length > MAX_CACHE_SIZE)
          map.delete(map.findKey(lu.returnTrue));
        n.uid = UID();
        map.set(n.uid, n);
      }));
    }
    ra.forceCalculations();
    return M.map.last();
  });
  this.wsService = (function(connection) {
    var self = ra({
      active: true,
      id: null,
      get sendChanges() {
        if (!connection || !self.active || !self.id || self.id == M.last.json.uid)
          return ;
        var clientData = M.map.get(self.id);
        self.id = M.last.json.uid;
        var partial = false;
        var text = M.last.text;
        if (clientData) {
          var diff = JSON.stringify(lu.makeDiff(clientData, M.last.json.valueOf()));
          if (text.length > diff.length * 1.5) {
            partial = true;
            text = diff;
          }
        }
        connection.send(("{\"partial\":" + partial + ",\"data\":" + text + "}"));
      }
    });
    connection.on("close", (function() {
      connection = null;
      self.active = false;
    }));
    connection.on("message", (function(message) {
      try {
        message = JSON.parse(message);
      } catch (error) {
        console.log("web socket message error".red, error);
        connection.send(JSON.stringify({error: "wrong format"}));
        return ;
      }
      switch (message.what) {
        case "init":
          self.id = message.id || {};
          break;
        case "save":
          $__0.applyChanges(message.data, !!message.partial);
          break;
        default:
          connection.send(JSON.stringify({error: "unrecognised message"}));
      }
    }));
  });
  this.httpService = co.func($traceurRuntime.initGeneratorFunction(function $__9(request, response, next) {
    var data,
        clientData,
        diff,
        $__10,
        $__11,
        $__12,
        $__13,
        $__14,
        $__15,
        $__16;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $ctx.state = (request.method != "POST") ? 1 : 2;
            break;
          case 1:
            $ctx.returnValue = response.status(HTTPStatus.METHOD_NOT_ALLOWED).end();
            $ctx.state = -2;
            break;
          case 2:
            $__10 = lu.readStream;
            $__11 = $__10.call(lu, request);
            $ctx.state = 9;
            break;
          case 9:
            $ctx.state = 5;
            return $__11;
          case 5:
            $__12 = $ctx.sent;
            $ctx.state = 7;
            break;
          case 7:
            $__13 = $__12.toString;
            $__14 = $__13.call($__12);
            $__15 = $__14.trim;
            $__16 = $__15.call($__14);
            data = $__16;
            $ctx.state = 11;
            break;
          case 11:
            $ctx.state = (data && request.query.id) ? 12 : 13;
            break;
          case 12:
            $ctx.returnValue = response.status(HTTPStatus.BAD_REQUEST).end();
            $ctx.state = -2;
            break;
          case 13:
            $ctx.state = 16;
            return this.waitForReady(response);
          case 16:
            $ctx.maybeThrow();
            $ctx.state = 18;
            break;
          case 18:
            $ctx.state = (data) ? 21 : 20;
            break;
          case 21:
            data = JSON.parse(data);
            this.applyChanges(data.data, !!data.partial);
            $ctx.state = 22;
            break;
          case 22:
            $ctx.returnValue = response.status(HTTPStatus.ACCEPTED).end();
            $ctx.state = -2;
            break;
          case 20:
            response.contentType("json");
            $ctx.state = 36;
            break;
          case 36:
            $ctx.state = (request.query.id && request.query.id == M.last.json.uid) ? 24 : 27;
            break;
          case 24:
            $ctx.state = 25;
            return this.waitForChange(response);
          case 25:
            $ctx.maybeThrow();
            $ctx.state = 27;
            break;
          case 27:
            $ctx.state = (request.query.id && (clientData = M.map.get(request.query.id))) ? 32 : 30;
            break;
          case 32:
            diff = lu.makeDiff(clientData, M.last.json.valueOf());
            $ctx.state = 33;
            break;
          case 33:
            $ctx.state = (!isDataLongerThan(20, diff)) ? 29 : 30;
            break;
          case 29:
            $ctx.returnValue = response.end(JSON.stringify({
              partial: true,
              data: diff
            }));
            $ctx.state = -2;
            break;
          case 30:
            response.end(("{\"partial\":false,\"data\":" + M.last.text + "}"));
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__9, this);
  })).bind(this);
};
($traceurRuntime.createClass)(JSONservice, ($__2 = {}, Object.defineProperty($__2, "applyItemChanges", {
  value: function(item, changes) {
    var partial = arguments[2] !== (void 0) ? arguments[2] : true;
    var $__2;
    if (!partial)
      throw new Error("not implemented: replacing an item");
    return this.applyChanges(($__2 = {}, Object.defineProperty($__2, item, {
      value: changes,
      configurable: true,
      enumerable: true,
      writable: true
    }), $__2), true)[item];
  },
  configurable: true,
  enumerable: true,
  writable: true
}), $__2), {});
module.exports = JSONservice;
function isDataLongerThan(maxLength, data) {
  var length = 0;
  !function walk(x) {
    if (x instanceof Immutable.Map) {
      length += x.length;
      for (var $__3 = x[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__4 = void 0; !($__4 = $__3.next()).done; ) {
        var y = $__4.value;
        if (length > maxSize)
          return ;
        else
          walk(y);
      }
    } else
      ++length;
  }(data);
  return length > maxLength;
}

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/JSONservice.map

      } )
    }()

},{"co":"/home/vadzim/v/work/nerojs/src/co.js","fs":false,"http-status":"/home/vadzim/v/work/nerojs/node_modules/http-status/lib/index.js","immutable":"/home/vadzim/v/work/nerojs/node_modules/immutable/dist/immutable.js","localUtils":"/home/vadzim/v/work/nerojs/src/localUtils.js","path":false,"ra":"/home/vadzim/v/work/nerojs/src/ra.js","uid":"/home/vadzim/v/work/nerojs/src/uid.js"}],"/home/vadzim/v/work/nerojs/src/actionToCommands.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/actionToCommands.js" ] = total
        }
      }( function () {
        "use strict";
var lodash = require("lodash");
var _ = (function() {
  for (var args = [],
      $__0 = 0; $__0 < arguments.length; $__0++)
    args[$__0] = arguments[$__0];
  return args.reduce((function(res, obj) {
    var $__2,
        $__3,
        $__4;
    if (Array.isArray(obj))
      ($__2 = [obj, res], res = ($__3 = $__2[$traceurRuntime.toProperty(Symbol.iterator)](), ($__4 = $__3.next()).done ? void 0 : $__4.value), obj = ($__4 = $__3.next()).done ? void 0 : $__4.value, $__2);
    if (Array.isArray(obj))
      throw new Error("wrong parameters: more than one array passed");
    if (Array.isArray(res))
      return res.map((function(res) {
        return [res, obj].reduce(lodash.assign, {});
      }));
    else
      return [res, obj].reduce(lodash.assign, {});
  }), {});
});
var click = [{TIME: "Pressed_0_sec"}, {TIME: "Released_0_sec"}];
var press = [{TIME: "Pressed_0_sec"}];
var RL = {
  ROL: 1,
  DIM: 1
};
var ROL = {ROL: 1};
var DIM = {DIM: 1};
var All = {
  Comfort_1: _(press, RL, {id: "Set_To_Comfort_1"}),
  Comfort_2: _(press, RL, {id: "Set_To_Comfort_2"}),
  Stop: _(click, ROL, {id: "Stop"}),
  Link: _(press, {id: "Write_Group"})
};
var RollShutter = _(All, {
  Up: _(click, RL, {id: "Up"}),
  Down: _(click, RL, {id: "Down"}),
  ToUp: _(click, RL, {id: "Up"}),
  ToDown: _(click, RL, {id: "Down"}),
  Script: _(click, RL, {id: "Script"}),
  Loop: null
});
var Jalousie = _(All, {
  Up: _(click, {id: "Up"}),
  Down: _(click, {id: "Down"}),
  ToUp: _(click, {id: "Up"}),
  ToDown: _(click, {id: "Down"}),
  Script: _(click, {id: "Script"}),
  Loop: null
});
var Dimeer = _(All, {
  Up: _(press, RL, {id: "Up"}),
  Down: _(press, RL, {id: "Down"}),
  ToUp: _(press, RL, {id: "Up"}),
  ToDown: _(press, RL, {id: "Down"}),
  Script: _(click, RL, {id: "Script"}),
  Loop: null
});
var deviceTypes = {
  RollShutter: RollShutter,
  Jalousie: Jalousie,
  Dimeer: Dimeer
};
function find(obj) {
  for (var path = [],
      $__1 = 1; $__1 < arguments.length; $__1++)
    path[$__1 - 1] = arguments[$__1];
  return path.reduce((function(obj, name) {
    return obj && obj[name];
  }), obj);
}
function createCommandSequence(group, deviceType, action) {
  var name,
      id;
  var seq = find(deviceTypes, deviceType, action);
  if (!seq)
    throw new Error(("wrong action specified: " + deviceType + "." + action));
  return seq.map((function(c) {
    return _(c, {group: group});
  }));
}
exports.createCommandSequence = createCommandSequence;

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/actionToCommands.map

      } )
    }()

},{"lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js"}],"/home/vadzim/v/work/nerojs/src/checkreboot.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/checkreboot.js" ] = total
        }
      }( function () {
        "use strict";
require("colors");
var co = require("co");
var fs = require("fs");
var exec = co.cb(require("child_process").exec);
var currentVersion = 5;
var file = __dirname + "/.shver";
co.go($traceurRuntime.initGeneratorFunction(function $__0() {
  var saveVersion,
      $__1,
      $__2,
      $__3,
      $__4,
      $__5,
      $__6,
      _ignore;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          currentVersion = String(currentVersion);
          $ctx.state = 34;
          break;
        case 34:
          $ctx.pushTry(9, null);
          $ctx.state = 12;
          break;
        case 12:
          $__1 = co.cb;
          $__2 = fs.readFile;
          $__3 = $__1.call(co, $__2);
          $__4 = $__3(file);
          $ctx.state = 6;
          break;
        case 6:
          $ctx.state = 2;
          return $__4;
        case 2:
          $__5 = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          $__6 = String($__5);
          saveVersion = $__6;
          $ctx.state = 8;
          break;
        case 8:
          $ctx.popTry();
          $ctx.state = 14;
          break;
        case 9:
          $ctx.popTry();
          _ignore = $ctx.storedException;
          $ctx.state = 14;
          break;
        case 14:
          $ctx.state = (saveVersion != currentVersion) ? 30 : -2;
          break;
        case 30:
          console.log("******** SERVER IS ABOUT TO REBOOT ********".red);
          $ctx.state = 31;
          break;
        case 31:
          $ctx.state = 19;
          return co.cb(fs.writeFile)(file, currentVersion);
        case 19:
          $ctx.maybeThrow();
          $ctx.state = 21;
          break;
        case 21:
          $ctx.state = 23;
          return co.sleep(5000);
        case 23:
          $ctx.maybeThrow();
          $ctx.state = 25;
          break;
        case 25:
          $ctx.state = 27;
          return exec("reboot");
        case 27:
          $ctx.maybeThrow();
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__0, this);
}));

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/checkreboot.map

      } )
    }()

},{"child_process":false,"co":"/home/vadzim/v/work/nerojs/src/co.js","colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/index.js","fs":false}],"/home/vadzim/v/work/nerojs/src/co.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/co.js" ] = total
        }
      }( function () {
        "use strict";
var later = require("later");
var EventEmitter = require("events").EventEmitter;
var co = module.exports = exports = new EventEmitter;
var threadCatcher = null;
exports.currentThread = null;
exports.global = null;
var id = (function(value) {
  return value;
});
exports.go = (function(fun) {
  for (var args = [],
      $__2 = 1; $__2 < arguments.length; $__2++)
    args[$__2 - 1] = arguments[$__2];
  if (typeof fun == "function")
    fun = fun.apply(null, args);
  if (!fun.next) {
    var value = fun;
    fun = {next: function() {
        var ret = {
          value: value,
          done: !value
        };
        value = null;
        return ret;
      }};
  }
  return new Thread(fun);
});
exports.gocall = (function(fun, context) {
  for (var args = [],
      $__3 = 2; $__3 < arguments.length; $__3++)
    args[$__3 - 2] = arguments[$__3];
  return new Thread(fun.apply(context, args));
});
exports.func = (function(fun) {
  return function proc() {
    return new Thread(fun.apply(this, arguments));
  };
});
exports.cb = (function(funWithCB) {
  return function() {
    for (var args = [],
        $__4 = 0; $__4 < arguments.length; $__4++)
      args[$__4] = arguments[$__4];
    var $__0 = this;
    return new Promise((function(resolve, reject) {
      var $__5;
      return ($__5 = funWithCB).call.apply($__5, $traceurRuntime.spread([$__0], args, [(function(error, value) {
        if (error != null)
          reject(error);
        else
          resolve(value);
      })]));
    }));
  };
});
exports.catchThreads = (function(cb, onThread) {
  var oldCatcher = threadCatcher;
  threadCatcher = onThread;
  try {
    return cb();
  } finally {
    threadCatcher = oldCatcher;
  }
});
exports.wait = (function(funWithCB) {
  return ({then: funWithCB});
});
exports.sleep = (function(milliseconds) {
  return ({then: (function(resolve) {
      var timer = setTimeout(resolve, milliseconds);
      return {kill: function() {
          clearTimout(timer);
        }};
    })});
});
exports.yield = exports.sleep(1);
exports.requestAnimationFrame = {then: (function(resolve) {
    if (typeof cancelAnimationFrame == "function") {
      var frame = requestAnimationFrame(resolve);
      return {kill: function() {
          cancelAnimationFrame(timer);
        }};
    } else
      return exports.sleep(1).then(resolve);
  })};
var rethrow = (function(e) {
  return setTimeout((function() {
    throw e;
  }), 1);
});
var constant = (function(x) {
  return (function() {
    return x;
  });
});
function iteratorFailed(error) {
  return {
    done: true,
    iteratorFailed: true,
    value: error
  };
}
function iteratorNext(iterator, result) {
  try {
    return iterator.next(result);
  } catch (error) {
    return iteratorFailed(error);
  }
}
function iteratorThrow(iterator, result) {
  if (!iterator.throw)
    return iteratorFailed(result);
  try {
    return iterator.throw(result);
  } catch (error) {
    return iteratorFailed(error);
  }
}
function iteratorCheck(ret) {
  if (ret.done && ret.iteratorFailed)
    throw ret.value;
  else
    return ret;
}
function killIterator(iterator) {
  if (iterator && iterator.throw) {
    var v = iteratorThrow(iterator, new EKill);
    if (!v.done || !v.iteratorFailed)
      rethrow(new Error("thread ate EKill"));
  }
}
var _private = {writable: true};
var notEnumerable = {enumerable: false};
var EKill = function EKill() {
  var message = arguments[0] !== (void 0) ? arguments[0] : "kill";
  $traceurRuntime.superConstructor($EKill).call(this, message);
};
var $EKill = EKill;
($traceurRuntime.createClass)(EKill, {}, {}, Error);
exports.EKill = EKill;
var catchDefer = (function(func) {
  try {
    return func();
  } catch (error) {
    return {next: (function() {
        return iteratorFailed(error);
      })};
  }
});
var IteratorProxy = function IteratorProxy(iterator) {
  if (iterator instanceof $IteratorProxy)
    return iterator;
  this._iterator = iterator;
  this._deferred = null;
  this._result = null;
};
var $IteratorProxy = IteratorProxy;
($traceurRuntime.createClass)(IteratorProxy, {
  defer: function(proc) {
    if (typeof proc != "function")
      throw new Error("type error: only functions can be deferred");
    if (!this._deferred)
      this._deferred = [];
    this._deferred.push(proc);
  },
  call: function(proc, value) {
    var old = $IteratorProxy._iterator;
    $IteratorProxy._iterator = this;
    start: for (; ; ) {
      var ret = proc(this._iterator, value);
      if (!ret.done || !this._deferred)
        return ret;
      proc = iteratorNext;
      if (!this._result)
        this._result = ret;
      else if (ret.iteratorFailed) {
        if (this._result.iteratorFailed)
          rethrow(this._result.value);
        this._result = ret;
      }
      while (this._deferred.length) {
        var def = catchDefer(this._deferred.pop());
        if (def != null && typeof def.next == "function") {
          this._iterator = def;
          continue start;
        }
      }
      return this._result;
    }
    $IteratorProxy._iterator = old;
  },
  next: function(value) {
    return iteratorCheck(this.call(iteratorNext, value));
  },
  throw: function(value) {
    return iteratorCheck(this.call(iteratorThrow, value));
  }
}, {});
IteratorProxy._iterator = null;
exports.defer = (function(proc) {
  if (!IteratorProxy._iterator)
    throw new Error("defer: not in a co-thread");
  IteratorProxy._iterator.defer(proc);
});
var Thread = function Thread(iterator) {
  var $__0 = this;
  this._attachedToStack = true;
  this._iterator = new IteratorProxy(iterator);
  this._stopCount = 0;
  this._stack = [];
  this._global = {};
  this._current = null;
  this.$name = {toString: (function() {
      return "<Thread>";
    })};
  this._newStep();
  this._start = (function() {
    if ($__0._start && $__0._step && $__0._step.next) {
      if ($__0._stopCount > 0)
        $__0._step.resume = $__0._start;
      else {
        $__0._start = null;
        $__0._step.next();
      }
    }
  });
  this._promise = new Promise((function(resolve, reject) {
    $__0._resolve = resolve;
    $__0._reject = reject;
  }));
  if (!this._resolve)
    throw new Error("assertion failure: wrong implementation of Promise");
  later.then(this._start);
  if (threadCatcher)
    threadCatcher(this);
  exports.emit("start", this);
};
($traceurRuntime.createClass)(Thread, {
  linkName: function(value) {
    var suffix = arguments[1] !== (void 0) ? arguments[1] : ":thread";
    if (value.$name)
      value = value.$name;
    this.$name.toString = (function() {
      return "" + value + suffix;
    });
    return this;
  },
  waitForInput: function() {
    this._checkFinished();
    if (this._stopCount > 0)
      throw new Error("thread is paused");
    if (this._start)
      this._start();
    return this;
  },
  _attachPromise: function(promise) {
    promise.kill = this.kill.bind(this);
    return promise;
  },
  then: function(onFulfilled, onRejected) {
    this._attachedToStack = false;
    return this._attachPromise(this._promise.then(onFulfilled, onRejected));
  },
  catch: function(onRejected) {
    this._attachedToStack = false;
    return this._attachPromise(this._promise.catch(onRejected));
  },
  isFinished: function() {
    return !this._step;
  },
  isPaused: function() {
    return this._stopCount > 0;
  },
  throw: function(exception) {
    if (this == exports.currentThread)
      throw exception;
    this._checkFinished();
    this._newStep();
    if (this._stopCount > 0)
      this._step.resume = this._step.fail.bind(this._step, exception);
    else
      this._step.fail(exception);
  },
  attachToStack: function() {
    this._attachedToStack = true;
  },
  kill: function(reason) {
    var safe = arguments[1] !== (void 0) ? arguments[1] : true;
    if (this.isFinished())
      return ;
    this._reject(reason);
    if (safe) {
      killIterator(this._iterator);
      for (var a = this._stack,
          i = a.length - 1; i >= 0; --i)
        killIterator(a[i]);
    }
    if (this._current)
      try {
        this._current.kill(reason, safe);
      } catch (e) {
        rethrow(e);
      }
    this._done();
    if (this == exports.currentThread)
      throw new EKill;
  },
  pause: function() {
    this._checkFinished();
    ++this._stopCount;
  },
  resume: function() {
    if (this._stopCount == 0)
      throw new Error("thread not paused");
    if (0 == --this._stopCount && this._step && this._step.resume) {
      later.then(this._step.resume);
      this._step.resume = null;
    }
  },
  _tick: function(step, imethod, result) {
    if (step !== this._step)
      return ;
    if (this._stopCount > 0) {
      step.resume = this._tick.bind(this, step, imethod, result);
      return ;
    }
    for (; ; ) {
      this._current = null;
      var previosThread = exports.currentThread;
      exports.currentThread = this;
      global.currentThreadData = exports.global = this._global;
      var v = this._iterator.call(imethod, result);
      exports.currentThread = previosThread;
      global.currentThreadData = exports.global = previosThread && previosThread._global;
      if (v.done) {
        if (this.isFinished())
          return ;
        if (this._iterator = this._stack.pop()) {
          imethod = v.iteratorFailed ? iteratorThrow : iteratorNext;
          result = v.value;
          continue;
        }
        var r = v.iteratorFailed ? this._reject : this._resolve;
        this._done();
        if (v.iteratorFailed && this._attachedToStack)
          rethrow(v.value);
        r(v.value);
      } else if (!v.value)
        exports.yield.then(step.next);
      else if (v.value.then) {
        var p = v.value.then(step.next, step.fail);
        if (p && p.kill)
          this._current = p;
      } else if (v.value.next) {
        this._stack.push(this._iterator);
        this._iterator = new IteratorProxy(v.value);
        imethod = iteratorNext;
        result = undefined;
        continue;
      } else if ("onload" in v.value && !v.value.onload && "onerror" in v.value && !v.value.onerror) {
        v.value.onload = step.next;
        v.value.onerror = step.fail;
      } else
        throw new Error("thread type error");
      break;
    }
  },
  _done: function() {
    this._step = null;
    this._iterator = null;
    this._stack = null;
    this._resolve = null;
    this._reject = null;
    this._current = null;
  },
  _newStep: function() {
    var step = this._step = {resume: null};
    step.next = this._tick.bind(this, step, iteratorNext);
    step.fail = this._tick.bind(this, step, iteratorThrow);
    var $name = this.$name;
    step.next.$name = {toString: (function() {
        return $name + ":next";
      })};
    step.fail.$name = {toString: (function() {
        return $name + ":fail";
      })};
  },
  _onPromise: function(resolve, reject) {
    this._resolve = resolve;
    this._reject = reject;
    this.resume();
  },
  _checkFinished: function() {
    if (this.isFinished())
      throw new Error("thread is already finished");
  }
}, {});
exports.Thread = Thread;
Object.keys(Thread.prototype).forEach((function(k) {
  return k.match(/^_/) && Object.defineProperty(Thread.prototype, k, notEnumerable);
}));
exports.currentThread = (new Thread({next: function() {
    return {value: {then: function() {}}};
  }})).waitForInput();
exports.global = exports.currentThread._global;

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/co.map

      } )
    }()

},{"events":false,"later":"/home/vadzim/v/work/nerojs/src/later.js"}],"/home/vadzim/v/work/nerojs/src/csvConfig.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/csvConfig.js" ] = total
        }
      }( function () {
        "use strict";
var $__4 = $traceurRuntime.initGeneratorFunction(readCSV),
    $__10 = $traceurRuntime.initGeneratorFunction(read),
    $__14 = $traceurRuntime.initGeneratorFunction(readArrays),
    $__18 = $traceurRuntime.initGeneratorFunction(readTree);
Object.defineProperties(module.exports, {
  readCSV: {get: function() {
      return readCSV;
    }},
  read: {get: function() {
      return read;
    }},
  readArrays: {get: function() {
      return readArrays;
    }},
  readTree: {get: function() {
      return readTree;
    }},
  parse: {get: function() {
      return parse;
    }},
  parseTree: {get: function() {
      return parseTree;
    }},
  parseArrays: {get: function() {
      return parseArrays;
    }},
  __esModule: {value: true}
});
var csv = require("csv");
var co = require("co");
var lodash = require("lodash");
function isStars(str) {
  return [].slice.call(str).every((function(ch) {
    return ch == "*";
  }));
}
function readCSV(text) {
  var $__5,
      $__6,
      $__7,
      $__8,
      $__9;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $__5 = co.cb;
          $__6 = csv.parse;
          $__7 = $__5.call(co, $__6);
          $__8 = $__7(text, {});
          $ctx.state = 6;
          break;
        case 6:
          $ctx.state = 2;
          return $__8;
        case 2:
          $__9 = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          $ctx.returnValue = $__9;
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__4, this);
}
function read(text, key) {
  var $__11,
      $__12,
      $__13;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $__11 = readCSV(text);
          $ctx.state = 6;
          break;
        case 6:
          $ctx.state = 2;
          return $__11;
        case 2:
          $__12 = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          $__13 = parse($__12, key);
          $ctx.state = 8;
          break;
        case 8:
          $ctx.returnValue = $__13;
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__10, this);
}
function readArrays(text) {
  var $__15,
      $__16,
      $__17;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $__15 = readCSV(text);
          $ctx.state = 6;
          break;
        case 6:
          $ctx.state = 2;
          return $__15;
        case 2:
          $__16 = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          $__17 = parseArrays($__16);
          $ctx.state = 8;
          break;
        case 8:
          $ctx.returnValue = $__17;
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__14, this);
}
function readTree(text) {
  var $__19,
      $__20,
      $__21;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $__19 = readCSV(text);
          $ctx.state = 6;
          break;
        case 6:
          $ctx.state = 2;
          return $__19;
        case 2:
          $__20 = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          $__21 = parseTree($__20);
          $ctx.state = 8;
          break;
        case 8:
          $ctx.returnValue = $__21;
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__18, this);
}
function parse(csv, key) {
  var $__1,
      $__2;
  var $__0 = csv.filter((function(a) {
    return a.some(Boolean);
  })),
      titles = ($__1 = $__0[$traceurRuntime.toProperty(Symbol.iterator)](), ($__2 = $__1.next()).done ? void 0 : $__2.value),
      body = $traceurRuntime.iteratorToArray($__1);
  var array = body.map((function(row) {
    return lodash.zipObject(lodash.zip(titles, row));
  }));
  if (key != null)
    array = lodash.zipObject(array.map((function(row) {
      var id = row[key];
      delete row[key];
      return [id, row];
    })));
  return array;
}
function parseTree(csv) {
  var $__1,
      $__2;
  var $__0 = csv.filter((function(a) {
    return a.some(Boolean);
  })),
      titles = ($__1 = $__0[$traceurRuntime.toProperty(Symbol.iterator)](), ($__2 = $__1.next()).done ? void 0 : $__2.value),
      body = $traceurRuntime.iteratorToArray($__1);
  body = body.map((function(row) {
    var tab = {length: Infinity};
    if (isStars(row[0])) {
      tab = row[0];
      row[0] = "";
    }
    return {
      tab: tab,
      row: lodash.zipObject(lodash.zip(titles, row))
    };
  }));
  var last = {
    tab: "",
    row: {content: []}
  };
  var ret = [];
  body.forEach((function(row) {
    while (last.tab.length >= row.tab.length)
      last = ret.pop();
    !(last.row.content || (last.row.content = [])).push(row.row);
    ret.push(last);
    last = row;
  }));
  return ret[0].row.content;
}
function parseArrays(csv) {
  var $__3;
  return lodash.zipObject(($__3 = lodash).zip.apply($__3, $traceurRuntime.spread(csv)).map((function(x) {
    var $__1,
        $__2;
    var $__0 = x.filter(Boolean),
        name = ($__1 = $__0[$traceurRuntime.toProperty(Symbol.iterator)](), ($__2 = $__1.next()).done ? void 0 : $__2.value),
        data = $traceurRuntime.iteratorToArray($__1);
    return [name, data];
  })));
}

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/csvConfig.map

      } )
    }()

},{"co":"/home/vadzim/v/work/nerojs/src/co.js","csv":"/home/vadzim/v/work/nerojs/node_modules/csv/lib/index.js","lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js"}],"/home/vadzim/v/work/nerojs/src/deviceActions.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/deviceActions.js" ] = total
        }
      }( function () {
        "use strict";
var deviceTypes = require("deviceTypes");
var actions = {
  Up: (function(device) {
    return 1;
  }),
  Down: (function(device) {
    return 0;
  }),
  Comfort_1: (function(device) {
    return device.comfort_1;
  }),
  Comfort_2: (function(device) {
    return device.comfort_2;
  }),
  Stop: (function(device) {
    return null;
  }),
  Loop: (function(device) {
    return device.state ? 0 : 1;
  }),
  Script: (function(device) {
    return null;
  }),
  Link: (function(device) {
    return null;
  })
};
function getNewState(device, action) {
  var fn = actions[action];
  return fn && fn(device);
}
exports.getNewState = getNewState;

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/deviceActions.map

      } )
    }()

},{"deviceTypes":"/home/vadzim/v/work/nerojs/src/deviceTypes.json"}],"/home/vadzim/v/work/nerojs/src/deviceTypes.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={
	"Nero II 8713-50": {
		"buttons": "RollShutter"
	},
	"Intro II 8513-50": {
		"buttons": "RollShutter"
	},
	"Nero II 8421": {
		"buttons": "Dimeer"
	}
}
},{}],"/home/vadzim/v/work/nerojs/src/http_common_server.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/http_common_server.js" ] = total
        }
      }( function () {
        "use strict";
var path = require("path");
var lodash = require("lodash");
var fs = require("fs");
var ra = require("ra");
var co = require("co");
var lu = require("localUtils");
var UID = require("uid");
var express = require("express");
require("rewriter");
var userAgents = [/\((iPhone);/, /\s(Android)\s([\d\.]+).*\s(Chrome\/\d+)/, /\s(Chrome\/\d+)/];
function getUserAgentName(ua) {
  for (var $__0 = userAgents[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__1 = void 0; !($__1 = $__0.next()).done; ) {
    var test = $__1.value;
    {
      var match = ua.match(test);
      if (match) {
        var ret = [];
        for (var i = 1; i in match; ++i)
          if (match[i])
            ret.push(match[i]);
        if (ret.length)
          return ret.join(" ");
        else if (ret[0])
          return ret[0];
      }
    }
  }
  return ua;
}
module.exports = function($__2) {
  var $__4;
  var $__3 = $__2,
      router = ($__4 = $__3.router) === void 0 ? null : $__4;
  var ret = express().use(require("cookie-parser")()).post("/log", (function(request, response, next) {
    lu.log(decodeURIComponent(request.url.slice(5)).replace(/<span\s+style\=`color\:(\w+);`>(.*?)<\/span>/g, (function(_, color, text) {
      return text[color];
    })) + (" " + getUserAgentName(request.headers["user-agent"])));
    response.status(200).end();
  })).use(require("http_log")).post("/info", function() {
    var fn = path.resolve(__dirname + "/../log/clients.json");
    var clients = ra.clean({
      uid: "",
      json: null,
      get updateFile() {
        return $traceurRuntime.initGeneratorFunction(function $__5() {
          var file,
              obj,
              $__6,
              $__7,
              $__8,
              $__9,
              i,
              $__10,
              $__11,
              $__12,
              $__13,
              $__14,
              $__15,
              $__16,
              $__17,
              _;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  clients.uid;
                  $ctx.state = 39;
                  break;
                case 39:
                  $ctx.state = 2;
                  return co.cb(fs.mkdir)(path.dirname(fn)).catch((function(_) {}));
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  $ctx.pushTry(13, null);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__10 = JSON.parse;
                  $__11 = co.cb;
                  $__12 = fs.readFile;
                  $__13 = $__11.call(co, $__12);
                  $__14 = $__13(fn);
                  $ctx.state = 10;
                  break;
                case 10:
                  $ctx.state = 6;
                  return $__14;
                case 6:
                  $__15 = $ctx.sent;
                  $ctx.state = 8;
                  break;
                case 8:
                  $__16 = String($__15);
                  $__17 = $__10.call(JSON, $__16);
                  file = $__17;
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 18;
                  break;
                case 13:
                  $ctx.popTry();
                  _ = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  if (!file)
                    file = {};
                  obj = clients.json;
                  clients.json = {};
                  $ctx.state = 41;
                  break;
                case 41:
                  $__6 = [];
                  $__7 = obj;
                  for ($__8 in $__7)
                    $__6.push($__8);
                  $ctx.state = 33;
                  break;
                case 33:
                  $__9 = 0;
                  $ctx.state = 31;
                  break;
                case 31:
                  $ctx.state = ($__9 < $__6.length) ? 25 : 29;
                  break;
                case 28:
                  $__9++;
                  $ctx.state = 31;
                  break;
                case 25:
                  i = $__6[$__9];
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.state = (!(i in $__7)) ? 28 : 23;
                  break;
                case 23:
                  if (obj.hasOwnProperty(i))
                    file[i] = obj[i];
                  $ctx.state = 28;
                  break;
                case 29:
                  $ctx.state = 35;
                  return co.cb(fs.writeFile)(fn, JSON.stringify(file, null, "   ")).catch((function(_) {}));
                case 35:
                  $ctx.maybeThrow();
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__5, this);
        }).call(this);
      }
    });
    clients.json = {};
    return (function(request, response, next) {
      var info = decodeURIComponent(request.url.slice(6));
      clients.json[info] = String(new Date);
      clients.uid = UID();
      response.status(200).end();
    });
  }()).use(require("compression")({threshold: 0})).get("/debugHtml", co.func($traceurRuntime.initGeneratorFunction(function $__5(request, response) {
    var $__18,
        $__19,
        $__20,
        $__21,
        $__22,
        $__23,
        $__24,
        $__25,
        $__26;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            response.status(200);
            response.contentType("html");
            $ctx.state = 10;
            break;
          case 10:
            $__18 = response.end;
            $__19 = co.cb;
            $__20 = fs.readFile;
            $__21 = $__19.call(co, $__20);
            $__22 = $__21(__dirname + "/../tmp/debug.html", "utf8");
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return $__22;
          case 2:
            $__23 = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            $__24 = $__23.replace;
            $__25 = $__24.call($__23, /\b(script|manifest)\b/g, (function($) {
              return "no" + $;
            }));
            $__26 = $__18.call(response, $__25);
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__5, this);
  }))).post("/debugHtml", co.func($traceurRuntime.initGeneratorFunction(function $__27(request, response) {
    var $__28,
        $__29,
        $__30,
        $__31,
        $__32,
        $__33,
        $__34,
        $__35;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            console.log("receiving debugHtml...".yellow);
            $ctx.state = 14;
            break;
          case 14:
            $__28 = co.cb;
            $__29 = fs.writeFile;
            $__30 = $__28.call(co, $__29);
            $__31 = lu.readStream;
            $__32 = $__31.call(lu, request);
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return $__32;
          case 2:
            $__33 = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            $__34 = beautify($__33);
            $__35 = $__30(__dirname + "/../tmp/debug.html", $__34);
            $ctx.state = 8;
            break;
          case 8:
            $ctx.state = 10;
            return $__35;
          case 10:
            $ctx.maybeThrow();
            $ctx.state = 12;
            break;
          case 12:
            response.end();
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__27, this);
  })));
  if (router)
    ret.use(router);
  ret.rewrite(/^\/index\d+\.html/, (function(_) {
    return "/index.html";
  })).use(require("http_static"));
  return ret;
};

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/http_common_server.map

      } )
    }()

},{"co":"/home/vadzim/v/work/nerojs/src/co.js","compression":false,"cookie-parser":"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/index.js","express":false,"fs":false,"http_log":"/home/vadzim/v/work/nerojs/src/http_log.js","http_static":"/home/vadzim/v/work/nerojs/src/http_static.js","localUtils":"/home/vadzim/v/work/nerojs/src/localUtils.js","lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js","path":false,"ra":"/home/vadzim/v/work/nerojs/src/ra.js","rewriter":"/home/vadzim/v/work/nerojs/src/rewriter.js","uid":"/home/vadzim/v/work/nerojs/src/uid.js"}],"/home/vadzim/v/work/nerojs/src/http_log.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/http_log.js" ] = total
        }
      }( function () {
        "use strict";
global._LOG = true;
var logger = require("morgan");
var lu = require("localUtils");
logger.token("cookie", (function(request, response) {
  return request.headers.cookie;
}));
logger.token("startTime", (function(request, response) {
  return request.startTime;
}));
logger.token("requestTime", (function(request, response) {
  return lu.formatms((new Date) - request.startTime) + "s";
}));
logger.token("manifestHeaders", (function(request, response) {
  if (!request.url.match(/\.manifest(\?|$)/))
    return "";
  var ret = ("\n" + request.method + " " + request.url);
  request.rawHeaders.forEach((function(str, index) {
    ret += ["\n", ": "][index % 2];
    ret += str;
  }));
  return ret;
}));
var L = logger(":remote-addr".blue + " - :remote-user [:date] \"" + ":method".green + " " + ":url".cyan + " HTTP/:http-version\" " + ":status".green + " :res[content-length] \":referrer\" \":user-agent\" " + ":requestTime".yellow + ":manifestHeaders");
module.exports = (function(request, response, next) {
  if (global._LOG) {
    console.log((request.method + " " + request.url.green));
    request.startTime = new Date;
    L(request, response, next);
  } else
    next();
});

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/http_log.map

      } )
    }()

},{"localUtils":"/home/vadzim/v/work/nerojs/src/localUtils.js","morgan":"/home/vadzim/v/work/nerojs/node_modules/morgan/index.js"}],"/home/vadzim/v/work/nerojs/src/http_static.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/http_static.js" ] = total
        }
      }( function () {
        "use strict";
var $__3 = $traceurRuntime.initGeneratorFunction(readFiles);
var path = require("path");
var fs = require("fs");
var cfg = require("csvConfig");
var lodash = require("lodash");
var co = require("co");
var lu = require("localUtils");
var express = require("express");
require("rewriter");
var isSVG = lodash.bindKey(/\.svg$/, "test");
function readFiles(path, filter) {
  var names,
      files;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $ctx.state = 2;
          return co.cb(fs.readdir)(path);
        case 2:
          names = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          if (filter)
            names = names.filter(filter);
          files = names.map((function(fn) {
            return [fn, co.cb(fs.readFile)(path + "/" + fn, "utf8")];
          }));
          $ctx.state = 8;
          break;
        case 8:
          $ctx.returnValue = lodash.zipObject(files);
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__3, this);
}
function staticData(value) {
  var contentType = arguments[1] !== (void 0) ? arguments[1] : "json";
  return co.func($traceurRuntime.initGeneratorFunction(function $__4(_, response) {
    var $__5,
        $__6,
        $__7,
        $__8,
        $__9,
        $__10,
        $__11;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $__5 = response.contentType;
            $__6 = $__5.call(response, contentType);
            $__7 = $__6.end;
            $__8 = value.then;
            $ctx.state = 11;
            break;
          case 11:
            $ctx.state = ($__8) ? 1 : 7;
            break;
          case 1:
            $ctx.state = 2;
            return value;
          case 2:
            $__9 = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            $__10 = $__9;
            $ctx.state = 6;
            break;
          case 7:
            $__10 = value;
            $ctx.state = 6;
            break;
          case 6:
            $__11 = $__7.call($__6, $__10);
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__4, this);
  }));
}
var cookieInfinite = {expires: new Date("Fri, 31-Dec-9999 23:59:59 GMT")};
module.exports = express.Router().get("/templates", staticData(co.go($traceurRuntime.initGeneratorFunction(function $__4() {
  var $__2,
      files,
      ret,
      $__0,
      $__1,
      f,
      $__12,
      $__13,
      $__14,
      $__15,
      $__16,
      $__17,
      $__18,
      $__19,
      $__20,
      $__21;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $ctx.state = 2;
          return readFiles(__dirname + "/../templates/locations/", lodash.bindKey(/\.csv$/, "test"));
        case 2:
          files = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          ret = [];
          $ctx.state = 26;
          break;
        case 26:
          $__0 = Object.keys(files)[$traceurRuntime.toProperty(Symbol.iterator)](), $__1 = void 0;
          $ctx.state = 18;
          break;
        case 18:
          $ctx.state = (!($__1 = $__0.next()).done) ? 19 : 21;
          break;
        case 19:
          f = $__1.value;
          $ctx.state = 20;
          break;
        case 20:
          $__2 = ret;
          $__12 = ret.push;
          $__13 = $__12.apply;
          $__14 = $traceurRuntime.spread;
          $__15 = cfg.readTree;
          $__16 = files[f];
          $ctx.state = 14;
          break;
        case 14:
          $ctx.state = 6;
          return $__16;
        case 6:
          $__17 = $ctx.sent;
          $ctx.state = 8;
          break;
        case 8:
          $__18 = $__15.call(cfg, $__17);
          $ctx.state = 16;
          break;
        case 16:
          $ctx.state = 10;
          return $__18;
        case 10:
          $__19 = $ctx.sent;
          $ctx.state = 12;
          break;
        case 12:
          $__20 = $__14.call($traceurRuntime, $__19);
          $__21 = $__13.call($__12, $__2, $__20);
          $ctx.state = 18;
          break;
        case 21:
          $ctx.returnValue = JSON.stringify(ret);
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__4, this);
})))).get("/messages", staticData(co.go($traceurRuntime.initGeneratorFunction(function $__22() {
  var $__23,
      $__24,
      $__25,
      $__26,
      $__27,
      $__28,
      $__29,
      $__30,
      $__31,
      $__32;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $__23 = JSON.stringify;
          $__24 = cfg.read;
          $__25 = co.cb;
          $__26 = fs.readFile;
          $__27 = $__25.call(co, $__26);
          $__28 = $__27(__dirname + "/../templates/messages.csv", "utf8");
          $ctx.state = 10;
          break;
        case 10:
          $ctx.state = 2;
          return $__28;
        case 2:
          $__29 = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          $__30 = $__24.call(cfg, $__29, "id");
          $ctx.state = 12;
          break;
        case 12:
          $ctx.state = 6;
          return $__30;
        case 6:
          $__31 = $ctx.sent;
          $ctx.state = 8;
          break;
        case 8:
          $__32 = $__23.call(JSON, $__31);
          $ctx.state = 14;
          break;
        case 14:
          $ctx.returnValue = $__32;
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__22, this);
})))).rewrite(/^\/apple\-touch\-icon/, (function(url) {
  return ("/touch" + path.extname(url));
})).rewrite(/^\/favicon.ico$/, (function() {
  return "/favicon96.ico";
})).get("/images", co.func($traceurRuntime.initGeneratorFunction(function $__33(request, response, next) {
  var path,
      images,
      written,
      $__34,
      $__35,
      $__36,
      $__37,
      name,
      $__38,
      $__39,
      $__40,
      $__41,
      $__42,
      $__43;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          path = __dirname + "/../www" + "/images";
          $ctx.state = 29;
          break;
        case 29:
          $ctx.state = 2;
          return readFiles(path, isSVG);
        case 2:
          images = $ctx.sent;
          $ctx.state = 4;
          break;
        case 4:
          response.contentType("json");
          response.write("{");
          written = false;
          $ctx.state = 31;
          break;
        case 31:
          $__34 = [];
          $__35 = images;
          for ($__36 in $__35)
            $__34.push($__36);
          $ctx.state = 27;
          break;
        case 27:
          $__37 = 0;
          $ctx.state = 25;
          break;
        case 25:
          $ctx.state = ($__37 < $__34.length) ? 21 : 23;
          break;
        case 16:
          $__37++;
          $ctx.state = 25;
          break;
        case 21:
          name = $__34[$__37];
          $ctx.state = 22;
          break;
        case 22:
          $ctx.state = (!(name in $__35)) ? 16 : 19;
          break;
        case 19:
          $ctx.state = (images.hasOwnProperty(name)) ? 13 : 16;
          break;
        case 13:
          if (written)
            response.write(",");
          response.write(JSON.stringify(name));
          response.write(":");
          $ctx.state = 14;
          break;
        case 14:
          $__38 = response.write;
          $__39 = JSON.stringify;
          $__40 = images[name];
          $ctx.state = 10;
          break;
        case 10:
          $ctx.state = 6;
          return $__40;
        case 6:
          $__41 = $ctx.sent;
          $ctx.state = 8;
          break;
        case 8:
          $__42 = $__39.call(JSON, $__41);
          $__43 = $__38.call(response, $__42);
          $ctx.state = 12;
          break;
        case 12:
          written = true;
          $ctx.state = 16;
          break;
        case 23:
          response.write("}");
          response.end();
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__33, this);
}))).rewrite(/^\/$/, (function(_) {
  return "/index.html";
})).use(/^\/index.html/, (function(request, response, next) {
  if (request.query.appicon)
    response.cookie("appicon", request.query.appicon, cookieInfinite);
  response.clearCookie("icon");
  response.clearCookie("room");
  next();
})).use(express.static(__dirname + "/../www", {
  lastModified: true,
  etag: true
}));

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/http_static.map

      } )
    }()

},{"co":"/home/vadzim/v/work/nerojs/src/co.js","csvConfig":"/home/vadzim/v/work/nerojs/src/csvConfig.js","express":false,"fs":false,"localUtils":"/home/vadzim/v/work/nerojs/src/localUtils.js","lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js","path":false,"rewriter":"/home/vadzim/v/work/nerojs/src/rewriter.js"}],"/home/vadzim/v/work/nerojs/src/inc.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/inc.js" ] = total
        }
      }( function () {
        "use strict";
var last = Date.now();
module.exports = (function() {
  var ret = Date.now();
  if (ret <= last)
    ret = last + 1;
  last = ret;
  return ret;
});

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/inc.map

      } )
    }()

},{}],"/home/vadzim/v/work/nerojs/src/later.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/later.js" ] = total
        }
      }( function () {
        "use strict";
module.exports = new (require("scheduler"))();

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/later.map

      } )
    }()

},{"scheduler":"/home/vadzim/v/work/nerojs/src/scheduler.js"}],"/home/vadzim/v/work/nerojs/src/localUtils.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/localUtils.js" ] = total
        }
      }( function () {
        "use strict";
var $__1;
var lodash = require("lodash");
var ra = require("ra");
var co = require("co");
function assert(value, message) {
  if (!value)
    throw new Error("" + message);
}
if (!global.WeakMap) {
  var n = 0;
  global.WeakMap = (function() {
    var WeakMap = function WeakMap(data) {
      var $__11,
          $__12;
      this._index = ("__WeakMap" + ++n);
      if (data)
        for (var $__3 = data[$traceurRuntime.toProperty(Symbol.iterator)](),
            $__4 = void 0; !($__4 = $__3.next()).done; ) {
          var $__10 = $__4.value,
              key = ($__11 = $__10[$traceurRuntime.toProperty(Symbol.iterator)](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
              value = ($__12 = $__11.next()).done ? void 0 : $__12.value;
          this.set(key, value);
        }
    };
    return ($traceurRuntime.createClass)(WeakMap, {
      get: function(obj) {
        return this.has(obj) ? obj[this._index] : undefined;
      },
      has: function(obj) {
        return obj.hasOwnProperty(this._index);
      },
      delete: function(obj) {
        delete obj[this._index];
      },
      set: function(obj, value) {
        Object.defineProperty(obj, this._index, {
          configurable: true,
          value: value
        });
        return this;
      }
    }, {});
  }());
}
var lu = module.exports = ($__1 = {}, Object.defineProperty($__1, "dumpPromise", {
  value: (function(p) {
    return p.then((function(result) {
      return lu.log("result:", result);
    }), (function(error) {
      return lu.error("error:", error);
    }));
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "dump", {
  value: function(msg, value) {
    console.log(msg, value);
    return value;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "log", {
  value: console.log.bind(console),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "info", {
  value: (console.info || console.log).bind(console),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "warn", {
  value: (console.warn || console.log).bind(console),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "error", {
  value: (console.error || console.log).bind(console),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "trace", {
  value: (console.trace || console.log).bind(console),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "rests", {
  value: function(num) {
    for (var rests = [],
        $__7 = 1; $__7 < arguments.length; $__7++)
      rests[$__7 - 1] = arguments[$__7];
    var ret = [];
    for (var $__3 = rests[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__4 = void 0; !($__4 = $__3.next()).done; ) {
      var r = $__4.value;
      {
        var n = num % r;
        num = (num - n) / r;
        ret.push(n);
      }
    }
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "pad", {
  value: function(s, n, p) {
    s = String(s);
    var x = "";
    n -= s.length;
    while (n > 0) {
      x += p;
      --n;
    }
    return x + s;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "time", {
  value: function() {
    var d = new Date();
    return (d.getHours() + ":" + lu.pad(d.getMinutes(), 2, 0) + ":" + lu.pad(d.getSeconds(), 2, 0) + "." + lu.pad(d.getMilliseconds(), 3, 0));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "stack", {
  value: (function() {
    return (new Error).stack;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "options", {
  value: function(options, def) {
    var ret = {};
    for (var i in def)
      if (def.hasOwnProperty(i))
        if (options == null)
          ret[i] = def[i];
        else {
          var op = options[i];
          if (op == null)
            op = def[i];
          ret[i] = op;
        }
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "str", {
  value: (function(obj, depth) {
    if (depth == null)
      depth = 1;
    if (!obj || !depth || depth < 1)
      return "" + obj;
    if (Array.isArray(obj))
      return ("[ " + obj.map((function(x) {
        return lu.str(x, depth - 1);
      })).join(" ") + " ]");
    if (!obj.constructor || obj.constructor == Object)
      return ("{ " + Object.keys(obj).map((function(x) {
        return x + "=" + lu.str(obj[x], depth - 1);
      })).join(" ") + " }");
    return String(obj);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "toOneLine", {
  value: function(obj) {
    var ret = JSON.stringify(obj);
    ret += "\n";
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "byLines", {
  value: function(callback) {
    var buffer = "";
    return (function(chunk) {
      buffer += String(chunk);
      var ret = buffer.split("\n");
      buffer = ret.pop();
      ret.forEach(callback);
    });
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "byJSON", {
  value: function(callback) {
    return byLines((function(line) {
      return callback(JSON.parse(line.trim()));
    }));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "valueOf", {
  value: (function(val) {
    return val == null ? null : val.valueOf == null ? val : val.valueOf();
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnThis", {
  value: function() {
    return this;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnNull", {
  value: (function() {
    return null;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnTrue", {
  value: (function() {
    return true;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnFalse", {
  value: (function() {
    return false;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnZero", {
  value: (function() {
    return 0;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnOne", {
  value: (function() {
    return 1;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "promiseSucceeded", {
  value: Promise.resolve(),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "promiseNull", {
  value: Promise.resolve(null),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "promiseTrue", {
  value: Promise.resolve(true),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "promiseFalse", {
  value: Promise.resolve(false),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "promiseZero", {
  value: Promise.resolve(0),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "promiseOne", {
  value: Promise.resolve(1),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnNullPromise", {
  value: (function() {
    return lu.promiseNull;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnTruePromise", {
  value: (function() {
    return lu.promiseTrue;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnFalsePromise", {
  value: (function() {
    return lu.promiseFalse;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnZeroPromise", {
  value: (function() {
    return lu.promiseZero;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "returnOnePromise", {
  value: (function() {
    return lu.promiseOne;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "waitFor", {
  value: function(timeout, interval, callback) {
    if (typeof timeout == "function") {
      interval = timeout;
      timeout = 5000;
    }
    if (typeof interval == "function") {
      callback = interval;
      interval = 200;
    }
    return new Promise((function(resolve, reject) {
      var start = Date.now();
      setTimeout(function check() {
        var ret;
        if (ret = callback())
          resolve(ret);
        else if (Date.now() - start > timeout)
          reject(new Error("timeout"));
        else
          setTimeout(check, interval);
      }, interval);
    }));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "empty", {
  value: Object.freeze(Object.create(null)),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "JSONEqual", {
  value: function(a, b) {
    return JSON.stringify(a) == JSON.stringify(b);
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "new", {
  value: function() {
    for (var descedents = [],
        $__8 = 0; $__8 < arguments.length; $__8++)
      descedents[$__8] = arguments[$__8];
    return descedents.reduce((function(ancestor, descedent) {
      return lodash.assign(ancestor, descedent);
    }), {});
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "call", {
  value: function(fun) {
    for (var args = [],
        $__9 = 1; $__9 < arguments.length; $__9++)
      args[$__9 - 1] = arguments[$__9];
    return fun.apply((void 0), $traceurRuntime.spread(args));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "rethrow", {
  value: function(e) {
    setTimeout((function() {
      throw e;
    }), 1);
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "catch", {
  value: function(cb, ret) {
    try {
      return cb();
    } catch (e) {
      return ret;
    }
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "tryElse", {
  value: function(f, g) {
    var ok = false;
    try {
      var ret = f();
      ok = true;
      return ret;
    } finally {
      if (!ok)
        g();
    }
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "try", {
  value: $traceurRuntime.initGeneratorFunction(function $__13(fun) {
    var startTimeToWait,
        maxTimeToWait,
        multiply,
        timeToWait,
        $__14,
        $__15,
        e;
    var $arguments = arguments;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            startTimeToWait = $arguments[1] !== (void 0) ? $arguments[1] : 100;
            maxTimeToWait = $arguments[2] !== (void 0) ? $arguments[2] : 3000;
            multiply = $arguments[3] !== (void 0) ? $arguments[3] : 1.5;
            timeToWait = startTimeToWait;
            $ctx.state = 26;
            break;
          case 26:
            $ctx.pushTry(17, null);
            $ctx.state = 20;
            break;
          case 20:
            $__14 = fun();
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return $__14;
          case 2:
            $__15 = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            $ctx.returnValue = $__15;
            $ctx.state = -2;
            break;
          case 8:
            $ctx.popTry();
            $ctx.state = 26;
            break;
          case 17:
            $ctx.popTry();
            e = $ctx.storedException;
            $ctx.state = 13;
            break;
          case 13:
            lu.rethrow(e);
            $ctx.state = 14;
            break;
          case 14:
            $ctx.state = 10;
            return co.sleep(timeToWait);
          case 10:
            $ctx.maybeThrow();
            $ctx.state = 12;
            break;
          case 12:
            timeToWait = Math.min(timeToWait * multiply, maxTimeToWait);
            $ctx.state = 26;
            break;
          default:
            return $ctx.end();
        }
    }, $__13, this);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "unique", {
  value: function(value, index, array) {
    return index == 0 || value != array[index - 1];
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "joinData", {
  value: function(array) {
    return array.length == 0 ? "" : typeof array[0] == "string" ? array.join("") : Buffer.isBuffer(array[0]) ? Buffer.concat(array) : array.join("");
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "readStream", {
  value: $traceurRuntime.initGeneratorFunction(function $__16(stream) {
    var $__17,
        $__18,
        $__19,
        $__20,
        $__21,
        $__22,
        $__23,
        $__24,
        $__25,
        $__26,
        $__27,
        $__28,
        $__29,
        $__30,
        $__31;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $__30 = {then: function(resolve, reject) {
                var content = [];
                $__17 = stream.on, $__20 = function(chunk) {
                  return $__18 = content.push, $__19 = $__18.call(content, chunk), $__19;
                }, $__21 = $__17.call(stream, "data", $__20), $__21;
                $__22 = stream.on, $__26 = function() {
                  return $__23 = lu.joinData, $__24 = $__23.call(lu, content), $__25 = resolve($__24), $__25;
                }, $__27 = $__22.call(stream, "end", $__26), $__27;
                $__28 = stream.on, $__29 = $__28.call(stream, "error", reject), $__29;
              }};
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return $__30;
          case 2:
            $__31 = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            $ctx.returnValue = $__31;
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__16, this);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "readJSON", {
  value: $traceurRuntime.initGeneratorFunction(function $__32(stream) {
    var $__33,
        $__34,
        $__35,
        $__36,
        $__37;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $__33 = JSON.parse;
            $__34 = lu.readStream;
            $__35 = $__34.call(lu, stream);
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return $__35;
          case 2:
            $__36 = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            $__37 = $__33.call(JSON, $__36);
            $ctx.state = 8;
            break;
          case 8:
            $ctx.returnValue = $__37;
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__32, this);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "readChunk", {
  value: $traceurRuntime.initGeneratorFunction(function $__38(stream) {
    var $__39,
        $__40,
        $__41,
        $__42,
        $__43,
        $__44,
        $__45,
        $__46,
        $__47,
        $__48,
        $__49,
        $__50,
        $__51,
        $__52,
        $__53,
        $__54,
        $__55,
        $__56,
        $__57,
        $__58;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $__57 = {then: function(resolve, reject) {
                $__39 = stream.on, $__40 = $__39.call(stream, "data", onData), $__40;
                $__41 = stream.on, $__42 = $__41.call(stream, "end", onEnd), $__42;
                $__43 = stream.on, $__44 = $__43.call(stream, "error", onError), $__44;
                function done() {
                  $__45 = stream.removeListener, $__46 = $__45.call(stream, "data", onData), $__46;
                  $__47 = stream.removeListener, $__48 = $__47.call(stream, "end", onEnd), $__48;
                  $__49 = stream.removeListener, $__50 = $__49.call(stream, "error", onError), $__50;
                }
                function onData(chunk) {
                  $__51 = done(), $__51;
                  $__52 = resolve(chunk), $__52;
                }
                function onEnd() {
                  $__53 = done(), $__53;
                  $__54 = resolve(null), $__54;
                }
                function onError(error) {
                  $__55 = done(), $__55;
                  $__56 = reject(error), $__56;
                }
              }};
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return $__57;
          case 2:
            $__58 = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            $ctx.returnValue = $__58;
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__38, this);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "static", {
  value: function(fun) {
    return co.func($traceurRuntime.initGeneratorFunction(function $__59(request, response) {
      var $__1,
          $__2,
          headWritten,
          responseEnded,
          body;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              headWritten = false, responseEnded = false;
              $ctx.state = 16;
              break;
            case 16:
              $ctx.pushTry(null, 8);
              $ctx.state = 10;
              break;
            case 10:
              $ctx.state = 2;
              return fun();
            case 2:
              body = $ctx.sent;
              $ctx.state = 4;
              break;
            case 4:
              response.writeHead(200, ($__1 = {}, Object.defineProperty($__1, "Content-Type", {
                value: "text/html; charset=UTF-8",
                configurable: true,
                enumerable: true,
                writable: true
              }), $__1));
              headWritten = true;
              if (typeof body != "string")
                body = React.renderComponentToString(body);
              response.end(body);
              responseEnded = true;
              $ctx.state = 8;
              $ctx.finallyFallThrough = -2;
              break;
            case 8:
              $ctx.popTry();
              $ctx.state = 14;
              break;
            case 14:
              if (!headWritten)
                response.writeHead(500, ($__2 = {}, Object.defineProperty($__2, "Content-Type", {
                  value: "text/plain",
                  configurable: true,
                  enumerable: true,
                  writable: true
                }), $__2));
              if (!responseEnded)
                response.end("<<< ERROR >>>");
              $ctx.state = 12;
              break;
            case 12:
              $ctx.state = $ctx.finallyFallThrough;
              break;
            default:
              return $ctx.end();
          }
      }, $__59, this);
    }));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "property", {
  value: function(obj, name, defaultValue) {
    var privateName = "_" + name;
    if (arguments.length > 2)
      obj[privateName] = defaultValue;
    obj[name] = function(value) {
      if (arguments.length == 0)
        return obj[privateName];
      else {
        obj[privateName] = value;
        return obj;
      }
    };
    return obj;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "polling", {
  value: function(stream) {
    var ret = {
      stop: function() {
        if (!ret)
          return ;
        if (ret._polling != null) {
          clearTimeout(ret._polling);
          ret._polling = null;
        }
        ret = null;
      },
      _polling: null,
      _tryToSendChunk: function() {
        if (!ret)
          return ;
        ret._polling = null;
        if (!stream.write(ret._chunk))
          stream.once("drain", ret._tryToSendChunk);
        else {
          if (typeof stream.flush == "function")
            stream.flush();
          ret._polling = setTimeout(ret._tryToSendChunk, ret._interval);
        }
      }
    };
    lu.property(ret, "chunk", "\n");
    lu.property(ret, "interval", 60000);
    stream.once("end", ret.stop);
    stream.once("close", ret.stop);
    stream.once("error", ret.stop);
    process.nextTick(ret._tryToSendChunk);
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "testDiffImm", {
  value: function() {
    var p = {
      a: 1,
      x: {u: 9}
    };
    var q = {x: {c: 2}};
    assert(Immutable.is(Immutable.fromJS(q), lu.applyDiffImm(p, lu.makeDiffImm(p, q))));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "testDiff", {
  value: function() {
    var p = {
      a: 1,
      x: {u: 9}
    };
    var q = {x: {c: 2}};
    assert(Immutable.is(Immutable.fromJS(q), Immutable.fromJS(lu.applyDiff(p, lu.makeDiff(p, q)))));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "applyDiffImm", {
  value: function(dest, diff) {
    return Immutable.fromJS(dest || Immutable.Map()).withMutations((function(dest) {
      Immutable.fromJS(diff).forEach((function(value, key) {
        if (value == null)
          dest.delete(key);
        else if (!(value instanceof Immutable.Map))
          dest.set(key, value);
        else
          dest.set(key, lu.applyDiffImm(dest.get(key), value));
      }));
    }));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "makeDiffImm", {
  value: function(previous, next) {
    return Immutable.Map().withMutations((function(ret) {
      function toArray(obj) {
        var ret = [];
        obj && Immutable.fromJS(obj).forEach((function(value, key) {
          ret.push({
            key: key,
            value: value
          });
        }));
        return ret.sort((function(v1, v2) {
          return v1.key < v2.key ? -1 : v1.key > v2.key ? 1 : 0;
        }));
      }
      var pa = toArray(previous);
      var na = toArray(next);
      var p = pa.pop();
      var n = na.pop();
      while (p || n) {
        if (!n || p && p.key > n.key) {
          ret.set(p.key, null);
          p = pa.pop();
        } else if (!p || p.key < n.key) {
          ret.set(n.key, n.value);
          n = na.pop();
        } else {
          if (p.value instanceof Immutable.Map && n.value instanceof Immutable.Map)
            ret.set(n.key, lu.makeDiffImm(p.value, n.value));
          else
            ret.set(n.key, n.value);
          p = pa.pop();
          n = na.pop();
        }
      }
    }));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "assignDiffImm", {
  value: function(dest, src) {
    return lu.applyDiffImm(dest, lu.makeDiffImm(dest, src));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "isLiteral", {
  value: (function(obj) {
    return obj && typeof obj == "object" && obj.constructor == Object;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "applyDiff", {
  value: function(dest, diff) {
    var ret = dest;
    var cnt = 0;
    function copyDest() {
      ret = {};
      for (var key in dest)
        if (dest.hasOwnProperty(key)) {
          ret[key] = dest[key];
          ++cnt;
        }
    }
    for (var key in diff)
      if (diff.hasOwnProperty(key)) {
        var value = diff[key];
        if (value != null && typeof value == "object")
          value = lu.applyDiff(ret && ret[key], value);
        if (value == null) {
          if (ret != null && ret.hasOwnProperty(key)) {
            if (ret === dest)
              copyDest();
            delete ret[key];
            --cnt;
          }
        } else {
          if (ret == null || ret[key] !== value) {
            if (ret === dest)
              copyDest();
            ret[key] = value;
          }
          cnt = Infinity;
        }
      }
    if (ret !== dest && cnt == 0)
      ret = null;
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "makeDiff", {
  value: function(previous, next) {
    var ret = null;
    function toArray(obj) {
      var ret = [];
      lodash.forEach(obj, (function(value, key) {
        ret.push({
          key: key,
          value: value
        });
      }));
      return ret.sort((function(v1, v2) {
        return v1.key < v2.key ? -1 : v1.key > v2.key ? 1 : 0;
      }));
    }
    var pa = toArray(previous);
    var na = toArray(next);
    var p = pa.pop();
    var n = na.pop();
    while (p || n) {
      if (!n || p && p.key > n.key) {
        if (ret == null)
          ret = {};
        ret[p.key] = null;
        p = pa.pop();
      } else if (!p || p.key < n.key) {
        if (ret == null)
          ret = {};
        ret[n.key] = n.value;
        n = na.pop();
      } else {
        if (p.value !== n.value) {
          if (lu.isLiteral(p.value) && lu.isLiteral(n.value)) {
            var diff = lu.makeDiff(p.value, n.value);
            if (diff != null) {
              if (ret == null)
                ret = {};
              ret[n.key] = diff;
            }
          } else {
            if (ret == null)
              ret = {};
            ret[n.key] = n.value;
          }
        }
        p = pa.pop();
        n = na.pop();
      }
    }
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "assignDiff", {
  value: function(dest, src) {
    return lu.applyDiff(dest, lu.makeDiff(dest, src));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "cast", {
  value: function(type, obj) {
    if (!obj || typeof obj != "object")
      return obj;
    var $__10 = type || {},
        constructor = $__10.constructor,
        elements = $__10.elements;
    if (typeof constructor == "string")
      constructor = Immutable[constructor];
    return (constructor || Immutable.Map)().withMutations((function(ret) {
      return Object.keys(obj).forEach((function(k) {
        return ret.set(k, lu.cast(elements && elements[k], obj[k]));
      }));
    }));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "concatString", {
  value: (function(array) {
    var ret = "";
    !function walk(array) {
      if (typeof array != "object")
        ret += array;
      else if (array.length != null)
        array.forEach(walk);
      else
        for (var $__3 = array[$traceurRuntime.toProperty(Symbol.iterator)](),
            $__4 = void 0; !($__4 = $__3.next()).done; ) {
          var s = $__4.value;
          walk(s);
        }
    }(array);
    return ret;
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "sortedDiff", {
  value: function(first, second) {
    var fi = first[Symbol.iterator]();
    var si = second[Symbol.iterator]();
    var ret = {
      common: [],
      first: [],
      second: []
    };
    var fv = fi.next(),
        sv = si.next();
    while (!fv.done || !sv.done) {
      if (sv.done || fv.value < sv.value) {
        ret.first.push(fv.value);
        fv = fi.next();
      } else if (fv.done || fv.value > sv.value) {
        ret.second.push(sv.value);
        sv = si.next();
      } else {
        ret.common.push(fv.value);
        fv = fi.next();
        sv = si.next();
      }
    }
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "measure", {
  value: function(fun) {
    var now = global.performance || global.Date;
    var t = now.now();
    try {
      return fun();
    } finally {
      t = (now.now() - t) / 1000;
      if (t > 0) {
        var i = 1;
        while (t < 1000) {
          i *= 10;
          t *= 10;
        }
        t = Math.round(t) / i;
      }
      console.log(t);
    }
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "skip", {
  value: $traceurRuntime.initGeneratorFunction(function $__59(c, buf) {
    var $__3,
        $__4,
        b;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $__3 = buf[$traceurRuntime.toProperty(Symbol.iterator)](), $__4 = void 0;
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = (!($__4 = $__3.next()).done) ? 8 : -2;
            break;
          case 8:
            b = $__4.value;
            $ctx.state = 9;
            break;
          case 9:
            $ctx.state = (c > 0) ? 5 : 1;
            break;
          case 5:
            --c;
            $ctx.state = 6;
            break;
          case 1:
            $ctx.state = 2;
            return b;
          case 2:
            $ctx.maybeThrow();
            $ctx.state = 6;
            break;
          default:
            return $ctx.end();
        }
    }, $__59, this);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "take", {
  value: $traceurRuntime.initGeneratorFunction(function $__60(c, buf) {
    var $__3,
        $__4,
        b;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $__3 = buf[$traceurRuntime.toProperty(Symbol.iterator)](), $__4 = void 0;
            $ctx.state = 4;
            break;
          case 4:
            $ctx.state = (!($__4 = $__3.next()).done) ? 10 : -2;
            break;
          case 10:
            b = $__4.value;
            $ctx.state = 11;
            break;
          case 11:
            $ctx.state = (c > 0) ? 5 : -2;
            break;
          case 5:
            --c;
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return b;
          case 2:
            $ctx.maybeThrow();
            $ctx.state = 4;
            break;
          default:
            return $ctx.end();
        }
    }, $__60, this);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "copy", {
  value: function(buf) {
    var ret = lu.array(buf);
    if (ret == buf)
      ret = buf.slice();
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "array", {
  value: function(buf) {
    if (Array.isArray(buf))
      return buf;
    var ret = [];
    if (!buf[Symbol.iterator])
      for (var i = 0; i < buf.length; ++i)
        ret.push(buf[i]);
    else
      for (var $__3 = buf[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__4 = void 0; !($__4 = $__3.next()).done; ) {
        var b = $__4.value;
        ret.push(b);
      }
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "buffer", {
  value: function(buf) {
    if (buf instanceof Buffer)
      return buf;
    else
      return new Buffer(lu.array(buf));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "vector", {
  value: function(buf) {
    return buf instanceof Buffer ? buf : lu.array(buf);
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "concat", {
  value: $traceurRuntime.initGeneratorFunction(function $__61(list) {
    var $__5,
        $__6,
        l,
        $__3,
        $__4,
        x;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $__5 = list[$traceurRuntime.toProperty(Symbol.iterator)](), $__6 = void 0;
            $ctx.state = 7;
            break;
          case 7:
            $ctx.state = (!($__6 = $__5.next()).done) ? 9 : -2;
            break;
          case 9:
            l = $__6.value;
            $ctx.state = 10;
            break;
          case 10:
            $__3 = l[$traceurRuntime.toProperty(Symbol.iterator)](), $__4 = void 0;
            $ctx.state = 4;
            break;
          case 4:
            $ctx.state = (!($__4 = $__3.next()).done) ? 5 : 7;
            break;
          case 5:
            x = $__4.value;
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return x;
          case 2:
            $ctx.maybeThrow();
            $ctx.state = 4;
            break;
          default:
            return $ctx.end();
        }
    }, $__61, this);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "word", {
  value: function(w) {
    return [w & 0xff, (w >> 8) & 0xff];
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "dword", {
  value: function(w) {
    return [w & 0xff, (w >> 8) & 0xff, (w >> 16) & 0xff, (w >> 24) & 0xff];
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "makeWord", {
  value: function(lo, hi) {
    return (lo & 0xff) + (hi & 0xff) << 8;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "arrayEqual", {
  value: function(a, b) {
    return a && b && a.length == b.length && a.every((function(ai, i) {
      return ai == b[i];
    }));
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "compare", {
  value: function(a, b) {
    if (a == b)
      return 0;
    if (a < b)
      return -1;
    return 1;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__1, "formatms", {
  value: function(value) {
    var ret = "";
    value = Math.round(value);
    var ms = value % 1000;
    value -= ms;
    value /= 1000;
    var s = value % 60;
    value -= s;
    value /= 60;
    var m = value % 60;
    value -= m;
    value /= 60;
    var h = value;
    ret += h ? h : "";
    ret += ret ? ":" + z(m, 2) : m ? m : "";
    ret += ret ? ":" + z(s, 2) : s;
    ret += "." + z(ms, 3);
    return ret;
    function z(value, len) {
      var str = String(value);
      var ret = "";
      for (var i = str.length; i < len; ++i)
        ret += "0";
      ret += str;
      return ret;
    }
  },
  configurable: true,
  enumerable: true,
  writable: true
}), $__1);

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/localUtils.map

      } )
    }()

},{"co":"/home/vadzim/v/work/nerojs/src/co.js","lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js","ra":"/home/vadzim/v/work/nerojs/src/ra.js"}],"/home/vadzim/v/work/nerojs/src/modem.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/modem.js" ] = total
        }
      }( function () {
        "use strict";
var lodash = require("lodash");
var CRC = require("modemcrc");
var co = require("co");
var lu = require("localUtils");
var USB_bFLAG_DATA = 0x7e;
var USB_bSTAF_DATA = 0x7d;
var PROTOCOL_NUMBER = 1;
var ModemError = function ModemError() {
  $traceurRuntime.superConstructor($ModemError).apply(this, arguments);
};
var $ModemError = ModemError;
($traceurRuntime.createClass)(ModemError, {}, {}, Error);
var ModemTimeout = function ModemTimeout() {
  $traceurRuntime.superConstructor($ModemTimeout).apply(this, arguments);
};
var $ModemTimeout = ModemTimeout;
($traceurRuntime.createClass)(ModemTimeout, {}, {}, ModemError);
function after(promise, proc) {
  var noResultNoArgs = (function() {
    return proc && proc() && undefined;
  });
  return promise.then(noResultNoArgs, noResultNoArgs);
}
var Modem = function Modem(stream, slog) {
  this._stream = stream;
  this._log = slog;
  this._stream.on("data", this._ondata.bind(this));
  this._commands = [];
  this._onready = Promise.resolve();
};
var $Modem = Modem;
($traceurRuntime.createClass)(Modem, {
  lock: function(callback, silent) {
    var onready = this._onready;
    var ret = co.gocall($traceurRuntime.initGeneratorFunction(function $__8() {
      var $__0,
          log,
          $__9,
          $__10,
          $__11,
          $__12,
          $__13,
          $__14,
          $__15,
          $__16,
          $__17,
          $__18,
          $__19,
          $__20,
          $__21,
          $__22;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $__0 = this;
              $ctx.state = 22;
              break;
            case 22:
              $ctx.state = 2;
              return onready;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              log = this._log;
              if (silent)
                this._log = null;
              $ctx.state = 24;
              break;
            case 24:
              $ctx.pushTry(null, 14);
              $ctx.state = 16;
              break;
            case 16:
              $__9 = callback.call;
              $__20 = function() {
                var $__5;
                for (var args = [],
                    $__4 = 0; $__10 = arguments.length, $__4 < $__10; $__11 = $__4, $__4 = $__11 + 1, $__11)
                  $__12 = arguments[$__4], args[$__4] = $__12, $__12;
                return $__13 = $__0._sendBuffer, $__5 = $Modem, $__14 = $Modem.encode, $__15 = $__14.apply, $__16 = $traceurRuntime.spread, $__17 = $__16.call($traceurRuntime, args), $__18 = $__15.call($__14, $__5, $__17), $__19 = $__13.call($__0, $__18), $__19;
              };
              $__21 = $__9.call(callback, this, $__20);
              $ctx.state = 10;
              break;
            case 10:
              $ctx.state = 6;
              return $__21;
            case 6:
              $__22 = $ctx.sent;
              $ctx.state = 8;
              break;
            case 8:
              $ctx.returnValue = $__22;
              $ctx.state = 14;
              $ctx.finallyFallThrough = -2;
              break;
            case 14:
              $ctx.popTry();
              $ctx.state = 20;
              break;
            case 20:
              if (silent)
                this._log = log;
              $ctx.state = 18;
              break;
            case 18:
              $ctx.state = $ctx.finallyFallThrough;
              break;
            default:
              return $ctx.end();
          }
      }, $__8, this);
    }), this);
    this._onready = after(ret);
    return ret;
  },
  _sendBuffer: function(buffer) {
    var $__0 = this;
    if (this._current)
      throw new Error("modem is busy");
    this._log && this._log("buffer prepared:", buffer, $Modem.extractMessage(buffer));
    var timeout;
    var promise = new Promise((function(resolve, reject) {
      timeout = setTimeout((function() {
        $__0._log && $__0._log("timeout");
        reject(new ModemTimeout());
      }), 3000);
      $__0._current = {
        resolve: resolve,
        reject: reject,
        buffer: []
      };
      $__0._log && $__0._log("writing buffer");
      var w = $__0._stream.write(buffer);
      $__0._log && $__0._log(("++++++++++++++++++++++ written: " + w + " ++++++++++++++++++++++"));
    }));
    after(promise, (function() {
      clearTimeout(timeout);
      $__0._current = null;
    }));
    return promise;
  },
  _ondata: function(data) {
    this._log && this._log("received:", data);
    if (!(data instanceof Buffer))
      throw new Error("data must be an instance of Buffer");
    var current = this._current;
    if (!current)
      return ;
    var buffer = current.buffer;
    for (var i = 0; i < data.length; ++i) {
      var d = data[i];
      if (buffer.length == 0 && d != USB_bFLAG_DATA)
        continue;
      if (current.staf) {
        current.staf = false;
        buffer.push(d);
      } else if (d == USB_bSTAF_DATA)
        current.staf = true;
      else
        buffer.push(d);
    }
    if (current.staf)
      return ;
    var len = buffer.length;
    this._log && this._log("parsing:", new Buffer(buffer));
    var msg;
    while ((msg = $Modem.extractMessage(buffer)) == false)
      buffer.shift();
    if (msg == null && len != buffer.length)
      this._log && this._log("skipped:", len - buffer.length);
    this._log && this._log("parsed:", msg);
    if (msg == null)
      return ;
    if (!msg) {
      current.reject(new ModemError("wrong packet from modem"));
      return ;
    }
    if (this._debugTimeout) {
      this._debugTimeout = false;
      return ;
    }
    current.resolve(msg);
  }
}, {
  encodeCommand: function(command, info) {
    return $Modem._commands[command](info);
  },
  encodeArray: function(array) {
    var $__5;
    array = lu.copy(array);
    if (array.length > 0xff)
      throw new ModemError("too long message");
    array.unshift(0xff, 0x03, PROTOCOL_NUMBER, array.length);
    ($__5 = array).push.apply($__5, $traceurRuntime.spread(lu.word(CRC.calc_crc(array))));
    var buffer = [USB_bFLAG_DATA];
    for (var $__2 = array[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__3 = void 0; !($__3 = $__2.next()).done; ) {
      var d = $__3.value;
      {
        if (d == USB_bFLAG_DATA || d == USB_bSTAF_DATA)
          buffer.push(USB_bSTAF_DATA);
        buffer.push(d);
      }
    }
    return lu.buffer(buffer);
  },
  encode: function(command, info) {
    if (typeof command != "string") {
      info = command;
      command = info.id;
    }
    return this.encodeArray(this.encodeCommand(command, info));
  }
});
Modem.Error = ModemError;
Modem.ETimeout = ModemTimeout;
Modem._commands = {};
module.exports = Modem;
var dataSize = byte(4);
var dataCRC = {
  read: (function(data) {
    var size = dataSize.read(data);
    return size == null ? null : readWord(size + 5, data);
  }),
  write: (function(data) {
    return writeWord(dataSize.read(data), data);
  })
};
var cmd1 = record({
  lo: byte(7 - 5),
  hi: byte(8 - 5)
});
function checkCRC(data, cb) {
  var crc = dataCRC.read(data);
  if (crc == null)
    return null;
  var size = dataSize.read(data);
  if (crc != CRC.calc_crc(data.slice(1, 5 + size)))
    return false;
  var ret = cb(data.slice(5, 5 + size));
  if (ret)
    data.splice(0, 5 + size + 2);
  else
    ret = false;
  return ret;
}
var P1Readers = [];
function ApplyP1Readers(data) {
  if (data.length != 8)
    return false;
  var cmd = cmd1.read(data);
  var c = P1Readers[cmd.lo];
  var f = c && (c[cmd.hi] ? c[cmd.hi] : c.any);
  if (!f)
    return false;
  var ret = f(data);
  return ret;
}
Modem.Work_Mode = 1;
Modem.Init_Device_Mode = 2;
Modem.Extended_Work_Mode = 3;
Modem.extractMessages = function(buffer) {
  if (typeof buffer == "string")
    buffer = buffer.split(/\s|\r|\n/).filter((function(x) {
      return x.match(/^[0-9a-fA-F]{1,2}$/);
    })).map((function(x) {
      return parseInt(("0x" + x));
    }));
  var ret = [];
  var msg;
  while (true) {
    while ((msg = Modem.extractMessage(buffer)) == false)
      buffer.shift();
    if (msg == null) {
      if (buffer.length > 0)
        ret.push(buffer);
      return ret;
    }
    ret.push(msg);
  }
};
Modem.extractMessage = function(data) {
  if (data.length < 4)
    return null;
  data = lu.array(data);
  if (!(data[0] == USB_bFLAG_DATA && data[1] == 0xff && data[2] == 0x03 && data[3] == PROTOCOL_NUMBER))
    return false;
  return checkCRC(data, ApplyP1Readers);
};
function bit(pos, shift) {
  var mask = arguments[2] !== (void 0) ? arguments[2] : 1;
  return {
    write: function(data, value) {
      data[pos] = (data[pos] & (~(mask << shift))) + ((value & mask) << shift);
      return data;
    },
    read: function(data) {
      return data[pos] == null ? null : (data[pos] >> shift) & mask;
    }
  };
}
function byte(pos) {
  return {
    write: function(data, value) {
      data[pos] = value;
      return data;
    },
    read: function(data) {
      return data[pos];
    }
  };
}
function writeWord(pos, data, value) {
  data[pos] = value & 0xff;
  data[pos + 1] = (value >> 8) & 0xff;
  return data;
}
function readWord(pos, data) {
  return data[pos] == null || data[pos + 1] == null ? null : data[pos] + (data[pos + 1] << 8);
}
function word(pos) {
  return {
    write: writeWord.bind(null, pos),
    read: readWord.bind(null, pos)
  };
}
function dword(pos) {
  return {
    write: function(data, value) {
      data[pos] = value & 0xff;
      data[pos + 1] = (value >> 8) & 0xff;
      data[pos + 2] = (value >> 16) & 0xff;
      data[pos + 3] = (value >> 24) & 0xff;
      return data;
    },
    read: function(data) {
      return data[pos] == null || data[pos + 1] == null || data[pos + 2] == null || data[pos + 3] == null ? null : data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
    }
  };
}
function record(type) {
  return {
    read: (function(data) {
      var ret = {};
      for (var i in type)
        if (type.hasOwnProperty(i))
          ret[i] = type[i].read(data);
      return ret;
    }),
    write: (function(data, value) {
      for (var i in type)
        if (type.hasOwnProperty(i))
          type[i].write(data, value[i]);
      return data;
    }),
    rec: type
  };
}
function compose(t1, t2) {
  return {
    read: (function(data) {
      return t1.read(t2.read(data));
    }),
    write: (function(data, value) {
      return t2.write(data, t1.write(value));
    })
  };
}
!function Init1() {
  var ACK = bit(11 - 5, 7),
      DIM = bit(11 - 5, 6),
      ROL = bit(11 - 5, 5),
      WCK = bit(11 - 5, 3),
      RPM = bit(11 - 5, 2),
      DEL = bit(11 - 5, 1),
      SGRP = bit(11 - 5, 0),
      DN = bit(12 - 5, 7),
      UP = bit(12 - 5, 6),
      PRIORITY = bit(12 - 5, 0, 7),
      _8 = byte(8 - 5),
      _9 = byte(9 - 5),
      _10 = byte(10 - 5),
      _11 = byte(11 - 5),
      _12 = byte(12 - 5),
      _9_10 = word(9 - 5),
      _9_10_11_12 = dword(9 - 5),
      group = word(5 - 5),
      cmdLo = cmd1.rec.lo,
      cmdHi = cmd1.rec.hi,
      constants = {
        cmdLo: cmdLo,
        cmdHi: cmdHi
      };
  function enumeration(enumeration) {
    var r = {};
    if (enumeration[Symbol.iterator]) {
      var i = 0;
      for (var $__2 = enumeration[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__3 = void 0; !($__3 = $__2.next()).done; ) {
        var name = $__3.value;
        {
          if (name != null)
            r[name] = i;
          ++i;
        }
      }
    } else {
      for (var i$__6 in enumeration)
        if (enumeration.hasOwnProperty(i$__6))
          r[enumeration[i$__6]] = i$__6;
    }
    return {
      read: (function(value) {
        if (value == null)
          return null;
        var ret = r[value];
        if (ret == null)
          ret = value;
        return ret;
      }),
      write: (function(value) {
        if (value == null)
          return null;
        var ret = value;
        if (typeof value == "string") {
          ret = enumeration[value];
          if (ret == null)
            throw new Error(("wrong constant " + value));
        }
        return ret;
      })
    };
  }
  function prec(precision) {
    return {
      read: (function(c) {
        return c == null ? null : c * precision;
      }),
      write: (function(c) {
        return c == null ? null : Math.round(c / precision);
      })
    };
  }
  function leftpad(str, len) {
    var pad = arguments[2] !== (void 0) ? arguments[2] : " ";
    var p = "";
    var l = len - str.length;
    if (!pad)
      return str;
    while (l && l > 0) {
      p += pad;
      --l;
    }
    return p + str;
  }
  function hex() {
    var len = arguments[0] !== (void 0) ? arguments[0] : 0;
    return {
      read: (function(c) {
        return c == null ? null : leftpad(c.toString(16), len, "0");
      }),
      write: (function(c) {
        return c == null ? null : parseInt(c, 16);
      })
    };
  }
  function set(set) {
    function check() {
      if (typeof set == "string")
        set = types[set];
      else if (typeof set.read != "function")
        set = enumeration(set);
      check = (function() {});
    }
    return {
      read: (function(x) {
        check();
        if (x == null)
          return null;
        var i = 0;
        var ret = {};
        while (x) {
          if (x & 1)
            ret[set.read(i)] = true;
          ++i;
          x >>= 1;
        }
        return ret;
      }),
      write: (function(x) {
        check();
        if (x == null || typeof x != "object")
          return x;
        var ret = 0;
        if (!x[Symbol.iterator])
          x = Object.keys(x).filter((function(i) {
            return x[i];
          }));
        for (var $__2 = x[$traceurRuntime.toProperty(Symbol.iterator)](),
            $__3 = void 0; !($__3 = $__2.next()).done; ) {
          var i = $__3.value;
          ret |= 1 << set.write(i);
        }
        return ret;
      })
    };
  }
  var types = {
    GROUP: enumeration({Any_Group: 0}),
    CMD: enumeration({
      None: 0,
      Stop: 1,
      Up: 2,
      Down: 3,
      Comfort_1: 4,
      Comfort_2: 5,
      Script: 6,
      Loop: 7,
      Set_To_Comfort: 8
    }),
    TIME: enumeration({
      Pressed_0_sec: 1,
      Pressed_0_5_sec: 2,
      Pressed_1_sec: 3,
      Pressed_4: 4,
      Released_0_sec: 9,
      Released_0_5_sec: 10,
      Released_1_sec: 11,
      Released_4_sec: 12
    }),
    COMFORT: prec(0.0001),
    MOVE_TIME: prec(0.01),
    MODE: enumeration(["Ignore_For_Out", "Idle", "Setting", "Comfort_1", "Comfort_2", "Self_Group", "Remote", "Program", "Script", "Comfort_For_Script", "Update"]),
    GROUP_SETTING: enumeration(["Received_Cmd_Is_Executed_Only_Locally", "Received_Cmd_Is_Executed_Locally_And_For_Self_Group"]),
    KEYPAD_STATUS: set(["Key_Up_Pressed", "Key_Stop_Pressed", "Key_Down_Pressed", "Key_Comfort_Pressed", "Key_Group_Pressed", "Key_Program_Pressed", "Key_External_1_Pressed", "Key_External_2_Pressed"]),
    RESULT: enumeration({
      OK: 1,
      Packet_Error: 2,
      Memory_Overflow: 3,
      Packet_Missed: 4,
      Packet_Not_Allowed: 5,
      Packed_appled_at_modem: 6,
      Connection_error: 7,
      Command_in_progress: 8,
      Command_auth_req: 9,
      Device_Error: 10
    }),
    LEVEL: prec(0.001),
    MODEM_MODE: enumeration({
      Work_Mode: 1,
      Init_Device_Mode: 2,
      Extended_Work_Mode: 3,
      Extended_Init_Mode: 4,
      Reset_Password_Mode: 5,
      RSSI_catch_mode: 6
    }),
    PROTOCOL_NUM: enumeration({
      NERO_II_SmartHome: 0,
      INTRO_II_SmartHome: 1,
      All_protocols: 0xff
    }),
    PROTOCOLS: set("PROTOCOL_NUM"),
    MODEM_FUNCTIONS: set({}),
    CUR_CONDITION: prec(0.0001),
    DEST_CONDITION: prec(0.0001),
    ID: hex()
  };
  function registerReader(cmdLo, cmdHi, reader) {
    if (typeof cmdLo != "number")
      throw new ModemError("wrong cmdLo");
    P1Readers[cmdLo] = P1Readers[cmdLo] || [];
    if (typeof cmdHi != "number")
      cmdHi = "any";
    P1Readers[cmdLo][cmdHi] = reader;
  }
  function registerWriter(id, writer, type) {
    if (Modem._commands[id]) {
      var msg = ("duplicate command identifier " + id);
      console.error("registerWriter", msg);
      throw new Error(msg);
    }
    (Modem._commands[id] = function(info) {
      var data = [];
      data.length = 8;
      writer(data, info);
      return data;
    }).type = type;
  }
  function command(id, type) {
    var t = {};
    var $__7 = function(i) {
      if (type.hasOwnProperty(i)) {
        var f = type[i];
        if (typeof f == "number") {
          var x = f;
          var c = constants[i];
          if (!c)
            throw new ModemError("wrong constant in command definition");
          f = {
            read: (function() {
              return x;
            }),
            write: (function(data) {
              return c.write(data, x);
            })
          };
        }
        if (types[i])
          f = compose(types[i], f);
        t[i] = f;
      }
    };
    for (var i in type) {
      $__7(i);
    }
    var read = function(data) {
      var ret = {id: id};
      for (var i in t)
        if (t.hasOwnProperty(i))
          ret[i] = t[i].read(data);
      return ret;
    };
    registerReader(type.cmdLo, type.cmdHi, read);
    var write = function(data, info) {
      for (var i in t)
        if (t.hasOwnProperty(i))
          t[i].write(data, info && info[i]);
      return data;
    };
    registerWriter(id, write, type);
  }
  command("Write_Group", {
    group: group,
    cmdLo: 1,
    TIME: _9,
    WCK: WCK,
    RPM: RPM,
    DEL: DEL
  });
  command("Write_Script", {
    group: group,
    cmdLo: 2,
    cmdHi: 0,
    TIME: _9,
    WCK: WCK,
    RPM: RPM,
    DEL: DEL
  });
  command("Write_Script_With_Cmd", {
    group: group,
    cmdLo: 2,
    CMD: _8,
    TIME: _9,
    WCK: WCK,
    RPM: RPM,
    DEL: DEL
  });
  command("Write_By_Allowance", {
    group: group,
    cmdLo: 3,
    TIME: _9
  });
  command("Stop_Write_With_Ack", {
    group: group,
    cmdLo: 4
  });
  command("Write_Group_In_Idle", {
    group: group,
    cmdLo: 5,
    GROUP: _9_10,
    ACK: ACK
  });
  command("Allow_Group_Writing", {
    group: group,
    cmdLo: 6,
    cmdHi: 0,
    ACK: ACK
  });
  command("Allow_Script_Writing", {
    group: group,
    cmdLo: 6,
    CMD: _8,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL
  });
  command("Allow_Script_With_Comfort_Writing", {
    group: group,
    cmdLo: 6,
    cmdHi: 32,
    COMFORT: _9_10,
    ACK: ACK,
    DN: DN,
    UP: UP
  });
  command("Change_Script_Into_Cmd", {
    group: group,
    cmdLo: 7,
    CMD: _8,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL
  });
  command("Change_Script_Into_Comfort", {
    group: group,
    cmdLo: 7,
    cmdHi: 32,
    COMFORT: _9_10,
    ACK: ACK,
    DN: DN,
    UP: UP
  });
  command("Delete_Group_In_Programming_Mode", {
    group: group,
    cmdLo: 8,
    cmdHi: 1,
    GROUP: _9_10,
    ACK: ACK
  });
  command("Delete_Group_In_Idle_Mode", {
    group: group,
    cmdLo: 8,
    cmdHi: 2,
    GROUP: _9_10,
    ACK: ACK
  });
  command("Clear_Device_Memory_In_Idle_Mode", {
    group: group,
    cmdLo: 8,
    cmdHi: 3,
    ACK: ACK
  });
  command("Stop", {
    group: group,
    cmdLo: 16,
    cmdHi: 1,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL,
    SGRP: SGRP,
    PRIORITY: PRIORITY
  });
  command("Up", {
    group: group,
    cmdLo: 16,
    cmdHi: 2,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL,
    SGRP: SGRP,
    PRIORITY: PRIORITY
  });
  command("Down", {
    group: group,
    cmdLo: 16,
    cmdHi: 3,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL,
    SGRP: SGRP,
    PRIORITY: PRIORITY
  });
  command("Set_To_Comfort_1", {
    group: group,
    cmdLo: 16,
    cmdHi: 4,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL,
    SGRP: SGRP,
    PRIORITY: PRIORITY
  });
  command("Set_To_Comfort_2", {
    group: group,
    cmdLo: 16,
    cmdHi: 5,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL,
    SGRP: SGRP,
    PRIORITY: PRIORITY
  });
  command("Script", {
    group: group,
    cmdLo: 16,
    cmdHi: 6,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL,
    SGRP: SGRP,
    PRIORITY: PRIORITY
  });
  command("Loop", {
    group: group,
    cmdLo: 16,
    cmdHi: 7,
    TIME: _9,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL,
    SGRP: SGRP,
    PRIORITY: PRIORITY
  });
  command("Set_To_Comfort", {
    group: group,
    cmdLo: 16,
    cmdHi: 32,
    COMFORT: _9_10,
    ACK: ACK,
    SGRP: SGRP,
    DN: DN,
    UP: UP,
    PRIORITY: PRIORITY
  });
  command("ScanCod_For_Modes", {
    group: group,
    cmdLo: 17,
    CMD: _8,
    TIME: _9,
    MODE: _10,
    ACK: ACK,
    DIM: DIM,
    ROL: ROL
  });
  command("GoTo_Mode", {
    group: group,
    cmdLo: 24,
    cmdHi: 1,
    To_MODE: _9,
    From_MODE: _10,
    ACK: ACK
  });
  command("Change_Mode_Setting", {
    group: group,
    cmdLo: 24,
    cmdHi: 2,
    MODE_SETTING: _9,
    MASK: _10,
    ACK: ACK
  });
  command("Change_System_Setting", {
    group: group,
    cmdLo: 24,
    cmdHi: 3,
    SYSTEM_SETTING: _9,
    MASK: _10,
    ACK: ACK
  });
  command("Change_Cmd_Setting", {
    group: group,
    cmdLo: 24,
    cmdHi: 4,
    CMD_SETTING: _9,
    MASK: _10,
    ACK: ACK
  });
  command("Change_Group_Setting", {
    group: group,
    cmdLo: 24,
    cmdHi: 5,
    GROUP_SETTING: _9,
    MASK: _10,
    ACK: ACK
  });
  command("Change_Move_Time", {
    group: group,
    cmdLo: 24,
    cmdHi: 6,
    MOVE_TIME: _9_10,
    ACK: ACK
  });
  command("Change_Comfort_1", {
    group: group,
    cmdLo: 24,
    cmdHi: 7,
    COMFORT: _9_10,
    ACK: ACK,
    DN: DN,
    UP: UP
  });
  command("Change_Comfort_2", {
    group: group,
    cmdLo: 24,
    cmdHi: 8,
    COMFORT: _9_10,
    ACK: ACK,
    DN: DN,
    UP: UP
  });
  command("Change_Script_Comfort", {
    group: group,
    cmdLo: 24,
    cmdHi: 9,
    COMFORT: _9_10,
    ACK: ACK,
    DN: DN,
    UP: UP
  });
  command("Reset_To_Factory_Setting", {
    group: group,
    cmdLo: 24,
    cmdHi: 10,
    DEFAUL_SETTING: _9_10,
    ACK: ACK
  });
  command("Change_Group_Settings_For_Scenario_Control", {
    group: group,
    cmdLo: 24,
    cmdHi: 11,
    GRP_KEYS: _9,
    SCEN_GRP_SETTING: _10,
    ACK: ACK
  });
  function request(id, fun, tToModem, tFromModem) {
    tToModem.cmdLo = 32;
    tToModem.cmdHi = fun;
    tFromModem.cmdLo = 33;
    tFromModem.cmdHi = fun;
    command(id, tToModem);
    command(("answer_" + id), tFromModem);
  }
  request("Mode", 1, {group: group}, {
    group: group,
    MODE: _9
  });
  request("Mode_Setting", 2, {group: group}, {
    group: group,
    MODE_SETTING: _9
  });
  request("System_Setting", 3, {group: group}, {
    group: group,
    SYSTEM_SETTING: _9
  });
  request("Cmd_Setting", 4, {group: group}, {
    group: group,
    CMD_SETTING: _9
  });
  request("Group_Setting", 5, {group: group}, {
    group: group,
    GROUP_SETTING: _9
  });
  request("Move_Time", 6, {group: group}, {
    group: group,
    MOVE_TIME: _9_10
  });
  request("Comfort_1", 7, {group: group}, {
    group: group,
    COMFORT: _9_10,
    DN: DN,
    UP: UP
  });
  request("Comfort_2", 8, {group: group}, {
    group: group,
    COMFORT: _9_10,
    DN: DN,
    UP: UP
  });
  request("Script_Comfort", 9, {group: group}, {
    group: group,
    COMFORT: _9_10,
    DN: DN,
    UP: UP
  });
  request("Keypad_Status", 10, {group: group}, {
    group: group,
    KEYPAD_STATUS: _9
  });
  request("Cur_Condition", 11, {group: group}, {
    group: group,
    CUR_CONDITION: _9_10,
    DN: DN,
    UP: UP
  });
  request("Dest_Condition", 12, {group: group}, {
    group: group,
    DEST_CONDITION: _9_10,
    DN: DN,
    UP: UP
  });
  request("Version_High", 13, {group: group}, {
    group: group,
    PRODUCT_HARD: _9,
    PRODUCT_VARIANT: _10
  });
  request("Version_Low", 14, {group: group}, {
    group: group,
    PRODUCT_VERSION: _9,
    PRODUCT_ID: _10
  });
  request("Result", 15, {group: group}, {
    group: group,
    RESULT: _9
  });
  request("Signal_Level", 16, {group: group}, {
    group: group,
    LEVEL: _9_10
  });
  request("Free_Cell_Count", 17, {}, {COUNT: _9_10});
  request("Version", 18, {}, {
    PRODUCT_VERSION: _9,
    PRODUCT_ID: _10,
    PRODUCT_HARD: _11,
    PRODUCT_VARIANT: _12
  });
  request("Id_Cell_Number", 19, {}, {DEV_NUM: _9});
  request("Scenario_Control_Group_Setting", 20, {
    group: group,
    key1: _9
  }, {
    group: group,
    GRP_KEYS: _9,
    SCEN_GRP_SETTING: _10
  });
  request("Functions", 21, {}, {
    PROTOCOLS: _9,
    MODEM_FUNCTIONS: _10
  });
  request("Identifier", 22, {}, {ID: _9_10_11_12});
  command("Change_modem_work_mode", {
    cmdLo: 25,
    cmdHi: 1,
    MODEM_MODE: _9
  });
  command("Do_id_nx_substitution", {
    cmdLo: 25,
    cmdHi: 2,
    DEV_NUM: _9_10
  });
  command("Delete_id_nx_of_device", {
    cmdLo: 25,
    cmdHi: 3,
    DEV_NUM: _9_10
  });
  command("Change_protocol", {
    cmdLo: 25,
    cmdHi: 4,
    PROTOCOL_NUM: _9
  });
}();

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/modem.map

      } )
    }()

},{"co":"/home/vadzim/v/work/nerojs/src/co.js","localUtils":"/home/vadzim/v/work/nerojs/src/localUtils.js","lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js","modemcrc":"/home/vadzim/v/work/nerojs/src/modemcrc.js"}],"/home/vadzim/v/work/nerojs/src/modemcrc.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/modemcrc.js" ] = total
        }
      }( function () {
        "use strict";
var $__2 = $traceurRuntime.initGeneratorFunction(append_crc);
var initial_crc = 0x0000;
function update_crc(crc, byte) {
  for (var i = 0; i < 8; i++) {
    if (crc & 0x8000) {
      crc <<= 1;
      crc &= 0xffff;
      if (byte & 0x0001)
        crc |= 0x0001;
      crc ^= 0x1021;
    } else {
      crc <<= 1;
      crc &= 0xffff;
      if (byte & 0x0001)
        crc |= 0x0001;
    }
    byte = byte >> 1;
  }
  return crc;
}
function iterable(data) {
  if (data[Symbol.iterator] || data.next)
    return data;
  else
    return $traceurRuntime.initGeneratorFunction(function $__2() {
      var i;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 7;
              break;
            case 7:
              $ctx.state = (i < data.length) ? 1 : -2;
              break;
            case 4:
              ++i;
              $ctx.state = 7;
              break;
            case 1:
              $ctx.state = 2;
              return data[i];
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__2, this);
    });
}
function calc_crc(data) {
  var crc = initial_crc;
  for (var $__0 = iterable(data)[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__1 = void 0; !($__1 = $__0.next()).done; ) {
    var temp = $__1.value;
    crc = update_crc(crc, temp);
  }
  return crc;
}
function append_crc(data) {
  var first,
      crc,
      $__0,
      $__1,
      b;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          first = true;
          crc = initial_crc;
          $ctx.state = 22;
          break;
        case 22:
          $__0 = iterable(data)[$traceurRuntime.toProperty(Symbol.iterator)](), $__1 = void 0;
          $ctx.state = 8;
          break;
        case 8:
          $ctx.state = (!($__1 = $__0.next()).done) ? 9 : 11;
          break;
        case 9:
          b = $__1.value;
          $ctx.state = 10;
          break;
        case 10:
          crc = update_crc(crc, b);
          $ctx.state = 6;
          break;
        case 6:
          $ctx.state = 2;
          return b;
        case 2:
          $ctx.maybeThrow();
          $ctx.state = 4;
          break;
        case 4:
          first = false;
          $ctx.state = 8;
          break;
        case 11:
          $ctx.state = 14;
          return crc & 0xff;
        case 14:
          $ctx.maybeThrow();
          $ctx.state = 16;
          break;
        case 16:
          $ctx.state = 18;
          return (crc >> 8) & 0xff;
        case 18:
          $ctx.maybeThrow();
          $ctx.state = -2;
          break;
        default:
          return $ctx.end();
      }
  }, $__2, this);
}
module.exports = {
  initial_crc: initial_crc,
  update_crc: update_crc,
  calc_crc: calc_crc,
  append_crc: append_crc
};

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/modemcrc.map

      } )
    }()

},{}],"/home/vadzim/v/work/nerojs/src/modemstub.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/modemstub.js" ] = total
        }
      }( function () {
        "use strict";
var Modem = require("modem");
var net = require("net");
var fs = require("fs");
var lu = require("localUtils");
require("colors");
var createServer = (function(port) {
  var server = net.createServer((function(socket) {
    socket.on("data", (function(data) {
      console.log(("stub: <Buffer " + lu.array(data).map((function(x) {
        return x.toString(16);
      })).join(" ") + ">").yellow);
      data = Modem.extractMessage(data);
      console.log(("stub: " + JSON.stringify(data)).yellow);
      socket.pause();
      setTimeout((function() {
        socket.resume();
        var ret = null;
        switch (data.id) {
          case "Version":
            ret = {
              PRODUCT_VERSION: 1,
              PRODUCT_ID: 73,
              PRODUCT_HARD: 22,
              PRODUCT_VARIANT: 8
            };
            break;
          case "Free_Cell_Count":
            ret = {COUNT: 122};
            break;
          case "Functions":
            ret = {
              PROTOCOLS: {
                NERO_II_SmartHome: true,
                INTRO_II_SmartHome: true
              },
              MODEM_FUNCTIONS: {}
            };
            break;
          case "Change_modem_work_mode":
            if (data.MODEM_MODE == "Work_Mode")
              ret = "OK";
            break;
          case "Write_Group":
          case "Set_To_Comfort":
          case "Set_To_Comfort_1":
          case "Set_To_Comfort_2":
          case "Up":
          case "Down":
          case "Stop":
            ret = "OK";
            break;
        }
        if (ret != null) {
          if (typeof ret == "string")
            ret = {
              id: "answer_Result",
              RESULT: ret
            };
          socket.write(Modem.encode(ret.id || ("answer_" + data.id), ret));
        }
      }), 300);
    }));
  }));
  server.on("error", (function(error) {
    return console.log("stub error:".red, error);
  }));
  server.listen(port);
  return server;
});
createServer(2233);
fs.unlink("/tmp/stub2233", (function() {
  return createServer("/tmp/stub2233");
}));

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/modemstub.map

      } )
    }()

},{"colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/index.js","fs":false,"localUtils":"/home/vadzim/v/work/nerojs/src/localUtils.js","modem":"/home/vadzim/v/work/nerojs/src/modem.js","net":false}],"/home/vadzim/v/work/nerojs/src/pingpong.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/pingpong.js" ] = total
        }
      }( function () {
        "use strict";
var fs = require("fs");
var stream = require("stream");
var constants = require("constants");
var co = require("co");
var lodash = require("lodash");
var cowrite = co.cb(fs.write);
var coread = co.cb(fs.read);
var PingPong = function PingPong(options) {
  $traceurRuntime.superConstructor($PingPong).call(this);
  if (options == null)
    options = {};
  this.options = {};
  this.options.bufferSize = options.bufferSize || 64 * 1024;
  this.options.timeout = options.timeout;
  this.buf = new Buffer(this.options.bufferSize);
};
var $PingPong = PingPong;
($traceurRuntime.createClass)(PingPong, {
  connect: function(path) {
    var $__0 = this;
    fs.open(path, constants.O_RDWR | constants.O_NOCTTY, (function(error, fd) {
      if (error)
        $__0.emit("error", error);
      else {
        $__0.fd = fd;
        $__0.emit("connect");
      }
    }));
  },
  destroy: function() {
    if (this.fd != null) {
      fs.close(this.fd);
      this.fd = null;
    }
  },
  unref: function() {},
  _read: function(n) {
    if (this.fd == null)
      return this.push(null);
  },
  _write: function(chunk, encoding, callback) {
    co.gocall($traceurRuntime.initGeneratorFunction(function $__2() {
      var $__0,
          t,
          done,
          bytesRead,
          error;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $__0 = this;
              done = lodash.once((function(error) {
                t && clearTimeout(t);
                if (error)
                  $__0.destroy();
                return callback(error);
              }));
              t = this.options.timeout && setTimeout((function() {
                return done(new Error("timeout"));
              }), this.options.timeout);
              $ctx.state = 23;
              break;
            case 23:
              $ctx.pushTry(15, null);
              $ctx.state = 18;
              break;
            case 18:
              if (typeof chunk == "string")
                chunk = new Buffer(chunk, encoding);
              $ctx.state = 10;
              break;
            case 10:
              $ctx.state = 2;
              return cowrite(this.fd, chunk, 0, chunk.length, null);
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return coread(this.fd, this.buf, 0, this.buf.length, null);
            case 6:
              bytesRead = $ctx.sent;
              $ctx.state = 8;
              break;
            case 8:
              this.push(this.buf.slice(0, bytesRead));
              $ctx.state = 12;
              break;
            case 12:
              $ctx.popTry();
              $ctx.state = 20;
              break;
            case 15:
              $ctx.popTry();
              error = $ctx.storedException;
              $ctx.state = 13;
              break;
            case 13:
              $ctx.returnValue = done(error);
              $ctx.state = -2;
              break;
            case 20:
              done();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__2, this);
    }), this);
  }
}, {}, stream.Duplex);
module.exports = PingPong;

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/pingpong.map

      } )
    }()

},{"co":"/home/vadzim/v/work/nerojs/src/co.js","constants":false,"fs":false,"lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js","stream":false}],"/home/vadzim/v/work/nerojs/src/platform.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/platform.js" ] = total
        }
      }( function () {
        "use strict";
Object.defineProperty(Object.prototype, "_LOG_", {
  value: function() {
    console.log(this);
    return this;
  },
  configurable: true
});
if (typeof Symbol == "function" && Symbol.iterator) {
  var x = null;
  try {
    x = eval.call(null, "(function*(){}().constructor.prototype)");
  } catch (_) {}
  if (x && !x[Symbol.iterator])
    x[Symbol.iterator] = function() {
      return this;
    };
}
function initImmutableIterators() {
  var sequenceIterator = function() {
    var seq = this;
    return {next: (function() {
        var value = seq.first();
        var ret = {
          value: value,
          done: value === void 0 && seq.length === 0
        };
        seq = seq.rest();
        return ret;
      })};
  };
  var indexedIterator = function() {
    var $__0 = this;
    var index = 0;
    return {next: (function() {
        return index < $__0.length ? {value: $__0.get(index++)} : {done: true};
      })};
  };
  var valuesIterator = function() {
    return indexedIterator.call(this.values());
  };
  var it = (function(constructor, iterator) {
    return constructor.prototype[Symbol.iterator] = iterator;
  });
  it(Immutable.Sequence, sequenceIterator);
  it(Immutable.Range, indexedIterator);
  it(Immutable.Vector, indexedIterator);
  it(Immutable.Repeat, indexedIterator);
  it(Immutable.Map, valuesIterator);
  it(Immutable.OrderedMap, valuesIterator);
  it(Immutable.Set, valuesIterator);
  var m = Immutable.Map({x: 1});
  it(m.values().constructor, indexedIterator);
  it(m.keys().constructor, indexedIterator);
  it(Immutable.Sequence(2, 3, 4).constructor, indexedIterator);
}

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/platform.map

      } )
    }()

},{}],"/home/vadzim/v/work/nerojs/src/ra.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/ra.js" ] = total
        }
      }( function () {
        "use strict";
var $__2;
var later = require("later").push;
var co = require("co");
var UID = require("uid");
var lodash = require("lodash");
var actionKey = "ACTION_" + UID();
var updates = {};
updates.scheduled = false;
updates.procs = [];
updates.index = 0;
updates.maxIndex = 32768;
updates.processing = false;
updates.totalTime = 0;
updates.maxTime = 0;
updates.maxTime1 = 0;
updates.minTime = Infinity;
updates.runCount = 0;
updates.runAllCount = 0;
global.updates = updates;
var performance = global.performance || global.Date;
updates.start = performance.now();
updates.log = (function() {
  return console.log((":: " + updates.totalTime / 1000 + " / " + (performance.now() - updates.start) / 1000 + " (" + updates.maxTime / 1000 + ", " + updates.maxTime1 / 1000 + ", " + updates.minTime / 1000 + ", " + Action.maxCount + ", " + updates.runCount + ", " + updates.runAllCount + ")"));
});
updates.checkSchedule = (function() {
  if (!updates.scheduled && updates.procs.length > 0) {
    updates.scheduled = true;
    later(updates.tick);
  }
});
updates.tick = (function() {
  updates.scheduled = false;
  var $__12 = function(_try) {
    try {
      updates.runAll();
      return 0;
    } catch (error) {
      setTimeout((function() {
        throw error;
      }), 1);
    }
  },
      $__13;
  $__11: for (var _try = 0; _try < 1000; ++_try) {
    $__13 = $__12(_try);
    switch ($__13) {
      case 0:
        break $__11;
    }
  }
  updates.checkSchedule();
});
updates.runAll = (function() {
  var start = performance.now();
  var st1 = start;
  var runCount = updates.runCount;
  var processing = updates.processing;
  updates.processing = true;
  var action = co.global[actionKey];
  if (action != null)
    co.global[actionKey] = null;
  try {
    while (updates.index < updates.procs.length) {
      if (global.APP_TIMEOUT && global.APP_TIMEOUT < Date.now) {
        alert("Application is running too long");
      }
      var proc = updates.procs[updates.index];
      ++updates.index;
      ++updates.runCount;
      if (updates.index >= updates.maxIndex && updates.index * 3 > updates.procs.length) {
        updates.procs.splice(0, updates.index);
        updates.index = 0;
      }
      proc();
      var t1 = performance.now();
      if (updates.maxTime1 < t1 - st1)
        updates.maxTime1 = t1 - st1;
      st1 = t1;
    }
    updates.index = updates.procs.length = 0;
  } finally {
    if (action != null)
      co.global[actionKey] = action;
    updates.processing = processing;
    if (!processing) {
      var time = performance.now() - start;
      updates.totalTime += time;
      if (updates.maxTime < time)
        updates.maxTime = time;
      runCount = updates.runCount - runCount;
      if (runCount) {
        ++updates.runAllCount;
        if (updates.minTime > time)
          updates.minTime = time;
      }
    }
  }
});
updates.later = (function(proc) {
  updates.procs.push(proc);
  updates.checkSchedule();
});
updates.later.then = updates.later;
var emptyMap = typeof Immutable == "undefined" ? null : Immutable.Map();
var checkNull = (function(value) {
  return value == null || value == emptyMap ? null : value;
});
var checkMap = (function(value) {
  return value == null ? emptyMap : value;
});
var returnThis = function() {
  return this;
};
var isLiteral = (function(value) {
  return value && typeof value == "object" && value.constructor == Object;
});
var getValue = (function(value) {
  return value == null || value.valueOf == null ? value : value.valueOf();
});
var close = (function(value) {
  return value != null && value.close != null && value.close();
});
function AbstractGuard() {}
var invalidKeyCall = function(key) {
  throw new Error(("access to an undeclared property \"" + this.$name + "." + key + "\""));
};
var usedProps = Object.create(null);
var usedPropsProto = Object.create(null);
var guardProp = (function(key) {
  if (!usedProps[key]) {
    usedProps[key] = true;
    Object.defineProperty(usedPropsProto, key, {
      get: function() {
        invalidKeyCall.call(this, key);
      },
      set: function() {
        invalidKeyCall.call(this, key);
      }
    });
  }
});
AbstractGuard.prototype = usedPropsProto;
if (global.APP_DEBUG) {
  AbstractGuard.prototype = (global.__UsedScriptIdentifiers__ + "").split(/[\s,]+/).reduce((function(proto, key) {
    var $__2;
    return Object.create(proto, ($__2 = {}, Object.defineProperty($__2, key, {
      value: {
        get: function() {
          invalidKeyCall.call(this, key);
        },
        set: function(_) {
          invalidKeyCall.call(this, key);
        }
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__2));
  }), AbstractGuard.prototype);
}
AbstractGuard.prototype = Object.create(AbstractGuard.prototype, {
  toString: {value: {}.toString},
  valueOf: {value: {}.valueOf},
  toLocaleString: {value: {}.toLocaleString},
  hasOwnProperty: {value: {}.hasOwnProperty},
  isPrototypeOf: {value: {}.isPrototypeOf},
  propertyIsEnumerable: {value: {}.propertyIsEnumerable},
  $name: {
    value: "<...>",
    writable: 1
  }
});
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var ImmutableInterface = function ImmutableInterface() {
  $traceurRuntime.superConstructor($ImmutableInterface).apply(this, arguments);
};
var $ImmutableInterface = ImmutableInterface;
($traceurRuntime.createClass)(ImmutableInterface, {
  get props() {
    throw new Error("access to deprecated 'props' property detected");
  },
  get declaredProperties() {
    return this.live;
  },
  get length() {
    var m = this.valueOf();
    return m == null ? 0 : Object.keys(m).length;
  },
  get: function(key) {
    if (key != null) {
      var m = this.valueOf();
      if (m != null && m.hasOwnProperty(key))
        return m[key];
    }
    return null;
  },
  map: function(fun) {
    var m = this.valueOf();
    return m && lodash.mapValues(m, fun);
  },
  keys: function() {
    var m = this.valueOf();
    return m == null ? EMPTY_ARRAY : Object.keys(m);
  }
}, {}, AbstractGuard);
var ReadOnlyCell = function ReadOnlyCell(parent) {
  $traceurRuntime.superConstructor($ReadOnlyCell).call(this);
  this._parent = parent;
};
var $ReadOnlyCell = ReadOnlyCell;
($traceurRuntime.createClass)(ReadOnlyCell, {
  getReadOnly: function() {
    return this;
  },
  get live() {
    return this._parent.live;
  },
  get $name() {
    return this._parent.$name;
  },
  valueOf: function() {
    return this._parent.valueOf.apply(this._parent, arguments);
  },
  noTouch: function() {
    return this._parent.noTouch.apply(this._parent, arguments);
  },
  toString: function() {
    return this._parent.toString.apply(this._parent, arguments);
  },
  toJSON: function() {
    return this._parent.toJSON.apply(this._parent, arguments);
  },
  getName: function() {
    return this._parent.getName.apply(this._parent, arguments);
  }
}, {}, ImmutableInterface);
var Getter = (function(fun, isValueEqual) {
  var last;
  var ret = !isValueEqual ? function() {
    return fun.apply(this, arguments);
  } : function() {
    var ret = fun.apply(this, arguments);
    if (!Object.is(last, ret) && !isValueEqual(last, ret))
      last = ret;
    return last;
  };
  ret.isGetter = true;
  return ret;
});
var Type = (function(f) {
  g.typeDescriptor = true;
  return g;
  function g() {
    return f.apply(this, arguments);
  }
});
var runGetter = (function(cell, getter, sticky) {
  return (new Action(getter, cell, sticky)).linkName(cell, ":getter");
});
var runSetter = (function(cell, setter, sticky) {
  return (new Action((function() {
    return setter(cell.valueOf());
  }), null, sticky)).linkName(cell, ":setter");
});
var Cell = function Cell(sticky) {
  var $__0 = this;
  $traceurRuntime.superConstructor($Cell).call(this);
  this._id = UID();
  this._value = null;
  this._error = null;
  this._isValueEqual = Object.is;
  this._initialized = false;
  this._closed = false;
  this._dirty = false;
  this._live = null;
  this._liveArray = null;
  this._actionsArr = [];
  this._parent = null;
  this._onchange = [];
  this.$name = {toString: (function() {
      return $__0.getName();
    })};
  this._notifyWritten();
  this._sticky = !!sticky;
};
var $Cell = Cell;
($traceurRuntime.createClass)(Cell, {
  valueOf: function() {
    return this._read();
  },
  assign: function(value) {
    return this._write(value, false, null);
  },
  throw: function(value) {
    return this._write(null, false, value);
  },
  touch: function() {
    this._fire();
  },
  noTouch: function() {
    if (this._dirty)
      this._updateSelf();
    if (this._error)
      throw this._error;
    return this._value;
  },
  then: function(proc) {
    this._onchange.push(proc);
  },
  close: function() {
    if (this._closed)
      return ;
    this._closed = true;
    this._fire();
    if (this._parent)
      this._parent.close();
    if (this._liveArray) {
      for (var $__3 = this._liveArray[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__4 = void 0; !($__4 = $__3.next()).done; ) {
        var p = $__4.value;
        p.close();
      }
      this._liveArray = null;
    }
    this._value = null;
    this._error = null;
    this._actionsArr = null;
    this._parent = null;
  },
  get live() {
    return this._live;
  },
  getReadOnly: function() {
    return this._readOnly || (this._readOnly = new ReadOnlyCell(this));
  },
  toString: function() {
    var $__10;
    for (var args = [],
        $__7 = 0; $__7 < arguments.length; $__7++)
      args[$__7] = arguments[$__7];
    var v = this._read();
    return (v == null) || !v.toString ? "" + v : ($__10 = v).toString.apply($__10, $traceurRuntime.spread(args));
  },
  toJSON: function() {
    var $__10;
    for (var args = [],
        $__8 = 0; $__8 < arguments.length; $__8++)
      args[$__8] = arguments[$__8];
    var v = this._read();
    return (v == null) || !v.toJSON ? v : ($__10 = v).toJSON.apply($__10, $traceurRuntime.spread(args));
  },
  setName: function(name) {
    this._name = name;
    return this;
  },
  getName: function() {
    var ret = this._name || this._key;
    var p = this._parent;
    while (p) {
      ret = (p._name || p._key) + "." + ret;
      p = p._parent;
    }
    return ret;
  },
  defineProperty: function(key) {
    if (!this._live) {
      this._live = {};
      this._liveArray = [];
    }
    if (!key)
      return ;
    guardProp(key);
    var c = this._live[key];
    if (this._live.hasOwnProperty(key))
      return c;
    this._liveArray.push(c = this._live[key] = new $Cell(this._sticky));
    c._key = key;
    c._parent = this;
    c._level = (this._level || 0) + 1;
    Object.defineProperty(this, key, {
      enumerable: true,
      configurable: true,
      get: (function() {
        if (c._live)
          return c;
        else
          return c._read();
      }),
      set: (function(value) {
        return c._write(value, false);
      })
    });
    if (this._value != null)
      c._write(this._value[key], true);
    return c;
  },
  init: function(value) {
    this._init(value, false, false);
  },
  setConst: function(prop, value) {
    Object.defineProperty(this, prop, {
      enumerable: true,
      get: (function() {
        return value;
      })
    });
    return this;
  },
  setVar: function(prop, value) {
    Object.defineProperty(this, prop, {
      enumerable: true,
      writable: true,
      value: value
    });
    return this;
  },
  _init: function(value, recursive, isGetter, isValueEqual) {
    var cell = this;
    if (!recursive && cell._initialized)
      throw new Error("already initialized");
    if (this._parent)
      this._parent._dirty = true;
    cell._initialized = true;
    if (isValueEqual)
      this._isValueEqual = isValueEqual;
    value = checkNull(value);
    if (value == null)
      return ;
    if (typeof value == "function" && value.typeDescriptor)
      value = value(cell._key);
    if (typeof value == "function" && (isGetter || value.isGetter)) {
      runGetter(cell, value, this._sticky);
      return ;
    }
    if (!isLiteral(value)) {
      if (value == null || typeof value != "object" || value.valueOf == Object.prototype.valueOf)
        cell._value = value;
      else
        cell._init((function() {
          return getValue(value);
        }), true, true);
      return ;
    }
    if (recursive)
      throw new Error("wrong parameters");
    cell.defineProperty();
    var $__15 = function(key) {
      var descr = Object.getOwnPropertyDescriptor(value, key);
      if (!descr)
        return 0;
      var get = descr.get;
      var subValue = descr.value;
      if (descr.set)
        throw new Error("wrong parameters");
      else if (get)
        subValue = get.length == 0 ? get : (function() {
          return get();
        });
      if (key == "$")
        cell._init(subValue, true, !!get);
      else
        cell.defineProperty(key)._init(subValue, false, !!get);
    },
        $__16;
    $__14: for (var key in value) {
      $__16 = $__15(key);
      switch ($__16) {
        case 0:
          continue $__14;
      }
    }
  },
  _read: function() {
    if (this._dirty)
      this._updateSelf();
    var action = co.global[actionKey];
    if (action)
      if (this._closed)
        action.close();
      else
        action.onread(this);
    if (this._error)
      throw this._error;
    return this._value;
  },
  _write: function(newValue, down, newError) {
    if (newError == null)
      newError = null;
    this._initialized = true;
    this._dirty = false;
    newValue = checkNull(newValue);
    if (this._closed) {
      var action = co.global[actionKey];
      if (action)
        action.close();
    } else if (!this._isValueEqual(this._value, newValue) || this._error != newError) {
      this._value = newValue;
      this._error = newError;
      if (this._live)
        for (var $__3 = this._liveArray[$traceurRuntime.toProperty(Symbol.iterator)](),
            $__4 = void 0; !($__4 = $__3.next()).done; ) {
          var p = $__4.value;
          p._write(newValue && newValue[p._key], true);
        }
      this._fire();
      if (!down) {
        var p$__17 = this._parent;
        while (p$__17 && !p$__17._dirty) {
          p$__17._dirty = true;
          p$__17._fire();
        }
      }
    }
    if (!down)
      this._notifyWritten();
    return newValue;
  },
  _updateSelf: function() {
    var cnt = 0;
    var ret = {};
    for (var key in this._value)
      if (this._value.hasOwnProperty(key)) {
        ret[key] = this._value[key];
        ++cnt;
      }
    for (var $__3 = this._liveArray[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__4 = void 0; !($__4 = $__3.next()).done; ) {
      var p = $__4.value;
      {
        if (p._dirty)
          p._updateSelf();
        if (p._error) {
          this._error = p._error;
          this._value = null;
          this._dirty = false;
          return ;
        }
        var value = p._value;
        if (value == null) {
          if (ret.hasOwnProperty(p._key)) {
            delete ret[p._key];
            --cnt;
          }
        } else {
          ret[p._key] = value;
          cnt = Infinity;
        }
      }
    }
    if (cnt == 0)
      ret = null;
    this._value = ret;
    this._dirty = false;
  },
  debug: function(cb) {
    this._actionsArr.push({action: {_fire: cb}});
  },
  debugger: function() {
    this.debug((function() {
      debugger;
    }));
  },
  _fire: function() {
    var a;
    a = this._actionsArr;
    if (a.length) {
      for (var i = 0; i < a.length; i++) {
        var c = a[i];
        if (c.action)
          c.action._fire();
        c.pushedC = false;
      }
      a.length = 0;
    }
    a = this._onchange;
    if (a.length) {
      for (var i$__18 = 0; i$__18 < a.length; i$__18++)
        updates.later(a[i$__18]);
      a.length = 0;
    }
  },
  _notifyWritten: function() {
    var action = co.global[actionKey];
    if (action)
      action.onwritten(this);
  }
}, {}, ImmutableInterface);
var rethrow = (function(error) {
  return setTimeout((function() {
    throw error;
  }), 1);
});
var Action = function Action(fun, dest, sticky) {
  var $__0 = this;
  this._id = UID();
  this._fun = fun;
  this._dest = dest;
  this._cellSet = {};
  this._cellSetSize = 0;
  this._cellArr = [];
  this.$name = {toString: (function() {
      return "<Action>";
    })};
  this._thread = co.gocall(this._loop, this).linkName(this).waitForInput();
  this._runCount = 0;
  var owner;
  if ((owner = co.global[actionKey]) && owner._children)
    owner._children.push(this);
  this._children = null;
  this._threads = null;
  this._onthread = null;
  this._generatorProxy = null;
  this._generator = null;
  if (sticky) {
    this._children = [];
    this._threads = [];
    this._onthread = (function(thread) {
      return $__0._threads.push(thread);
    });
  }
};
var $Action = Action;
($traceurRuntime.createClass)(Action, ($__2 = {}, Object.defineProperty($__2, "linkName", {
  value: function(value) {
    var suffix = arguments[1] !== (void 0) ? arguments[1] : ":action";
    if (value.$name)
      value = value.$name;
    this.$name.toString = (function() {
      return "" + value + suffix;
    });
    return this;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_initGeneratorProxy", {
  value: function() {
    var $__2;
    var $__0 = this;
    var _value;
    var _next = (function() {
      return $__0._generator.next(_value);
    });
    var _throw = (function() {
      return $__0._generator.throw(_value);
    });
    this._generatorProxy = ($__2 = {}, Object.defineProperty($__2, Symbol.iterator, {
      value: returnThis,
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__2, "next", {
      value: (function(v) {
        _value = v;
        try {
          return co.catchThreads(_next, $__0._onthread);
        } finally {
          _value = null;
        }
      }),
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__2, "throw", {
      value: (function(v) {
        _value = v;
        try {
          return co.catchThreads(_throw, $__0._onthread);
        } finally {
          _value = null;
        }
      }),
      configurable: true,
      enumerable: true,
      writable: true
    }), $__2);
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_loop", {
  value: $traceurRuntime.initGeneratorFunction(function $__24() {
    var $__0,
        next,
        errorCatched,
        ret,
        $__25,
        $__26,
        $__27,
        $__28,
        error;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $__0 = this;
            $ctx.state = 99;
            break;
          case 99:
            $ctx.state = 2;
            return updates.later;
          case 2:
            $ctx.maybeThrow();
            $ctx.state = 4;
            break;
          case 4:
            next = {then: (function(next) {
                $__0._onchange = next;
              })};
            co.global[actionKey] = this;
            errorCatched = false;
            $ctx.state = 101;
            break;
          case 101:
            $ctx.pushTry(90, null);
            $ctx.state = 93;
            break;
          case 93:
            $ctx.state = (!errorCatched) ? 65 : 69;
            break;
          case 65:
            $ctx.state = (this.isClosed()) ? 7 : 64;
            break;
          case 64:
            this._begin();
            errorCatched = true;
            ret = void 0;
            $ctx.state = 67;
            break;
          case 67:
            $ctx.state = (this._children) ? 38 : 60;
            break;
          case 38:
            ret = co.catchThreads(this._fun, this._onthread);
            $ctx.state = 39;
            break;
          case 39:
            $ctx.state = (ret && ret.next && ret.throw) ? 30 : 36;
            break;
          case 30:
            if (!this._generatorProxy)
              this._initGeneratorProxy();
            this._generator = ret;
            $ctx.state = 31;
            break;
          case 31:
            $ctx.pushTry(null, 23);
            $ctx.state = 25;
            break;
          case 25:
            $__25 = $ctx.wrapYieldStar(this._generatorProxy[Symbol.iterator]());
            $ctx.sent = void 0;
            $ctx.action = 'next';
            $ctx.state = 19;
            break;
          case 19:
            $__26 = $__25[$ctx.action]($ctx.sentIgnoreThrow);
            $ctx.state = 16;
            break;
          case 16:
            $ctx.state = ($__26.done) ? 10 : 9;
            break;
          case 10:
            $ctx.sent = $__26.value;
            $ctx.state = 17;
            break;
          case 9:
            $ctx.state = 19;
            return $__26.value;
          case 17:
            ret = $ctx.sentIgnoreThrow;
            $ctx.state = 23;
            $ctx.finallyFallThrough = 21;
            break;
          case 23:
            $ctx.popTry();
            $ctx.state = 29;
            break;
          case 29:
            this._generator = null;
            $ctx.state = 27;
            break;
          case 36:
            $ctx.state = (ret && ret.then) ? 32 : 21;
            break;
          case 32:
            $ctx.state = 33;
            return ret;
          case 33:
            ret = $ctx.sent;
            $ctx.state = 21;
            break;
          case 60:
            ret = (0, this._fun)();
            $ctx.state = 61;
            break;
          case 61:
            $ctx.state = (ret && ret.next && ret.throw) ? 50 : 58;
            break;
          case 50:
            $__27 = $ctx.wrapYieldStar(ret[Symbol.iterator]());
            $ctx.sent = void 0;
            $ctx.action = 'next';
            $ctx.state = 51;
            break;
          case 51:
            $__28 = $__27[$ctx.action]($ctx.sentIgnoreThrow);
            $ctx.state = 48;
            break;
          case 48:
            $ctx.state = ($__28.done) ? 42 : 41;
            break;
          case 42:
            $ctx.sent = $__28.value;
            $ctx.state = 49;
            break;
          case 41:
            $ctx.state = 51;
            return $__28.value;
          case 49:
            ret = $ctx.sentIgnoreThrow;
            $ctx.state = 21;
            break;
          case 58:
            $ctx.state = (ret && ret.then) ? 54 : 21;
            break;
          case 54:
            $ctx.state = 55;
            return ret;
          case 55:
            ret = $ctx.sent;
            $ctx.state = 21;
            break;
          case 21:
            if (this._dest)
              this._dest.assign(ret);
            $ctx.state = 69;
            break;
          case 69:
            errorCatched = false;
            $ctx.state = 83;
            break;
          case 83:
            $ctx.state = (this.isClosed()) ? 7 : 80;
            break;
          case 80:
            switch (this._end()) {
              default:
                $ctx.state = 93;
                break;
              case false:
                $ctx.state = 7;
                break;
              case true:
                $ctx.state = 73;
                break;
            }
            break;
          case 74:
            $ctx.maybeThrow();
            $ctx.state = 93;
            break;
          case 73:
            $ctx.state = 74;
            return next;
          case 84:
            $ctx.popTry();
            $ctx.state = 101;
            break;
          case 90:
            $ctx.popTry();
            error = $ctx.storedException;
            $ctx.state = 89;
            break;
          case 89:
            $ctx.state = (error instanceof co.EKill) ? 7 : 87;
            break;
          case 87:
            if (errorCatched)
              this._dest.throw(error);
            else
              rethrow(error);
            $ctx.state = 101;
            break;
          case 7:
            co.global[actionKey] = null;
            this._finalize();
            $ctx.state = -2;
            break;
          case 27:
            $ctx.state = $ctx.finallyFallThrough;
            break;
          default:
            return $ctx.end();
        }
    }, $__24, this);
  }),
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "isClosed", {
  value: function() {
    return !this._cellSet;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "close", {
  value: function() {
    var thread = this._thread;
    this._fire();
    this._finalize();
    thread && thread.kill();
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_closeChildren", {
  value: function() {
    var c;
    if (c = this._children) {
      for (var i = 0,
          l = c.length; i < l; ++i)
        c[i].close();
      c.length = 0;
    }
    if (c = this._threads) {
      for (var i$__19 = 0,
          l$__20 = c.length; i$__19 < l$__20; ++i$__19)
        c[i$__19].kill();
      c.length = 0;
    }
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_finalize", {
  value: function() {
    this._unsubscribe();
    this._cellSet = null;
    this._cellArr = null;
    this._fun = null;
    this._dest = null;
    this._thread = null;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_begin", {
  value: function() {
    this._unsubscribe();
    ++this._runCount;
    if ($Action.maxCount < this._runCount) {
      $Action.maxCount = this._runCount;
    }
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_unsubscribe", {
  value: function() {
    this._onchange = null;
    var a = this._cellArr;
    if (a) {
      for (var i = 0; i < a.length; ++i) {
        var c = a[i];
        c.cell = null;
        c.value = null;
        c.action = null;
        c.read = false;
        c.written = false;
        c.pushedA = false;
      }
      if (this._cellSetSize > 32 && a.length < this._cellSetSize / 4)
        this._cellSet = {};
      a.length = 0;
    }
    this._closeChildren();
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_end", {
  value: function() {
    var ret = false;
    var a = this._cellArr;
    for (var i = 0; i < a.length; ++i) {
      var c = a[i];
      if (c.written)
        c.action = null;
      else {
        if (!c.pushedC) {
          c.cell._actionsArr.push(c);
          c.pushedC = true;
        }
        if (!Object.is(c.value, c.cell._value) || !Object.is(c.error, c.cell._error))
          return null;
        c.action = this;
        ret = true;
      }
      c.value = null;
      c.cell = null;
    }
    return ret;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_linkCell", {
  value: function(cell) {
    var c = this._cellSet[cell._id];
    if (c == null) {
      c = this._cellSet[cell._id] = {
        cell: null,
        value: null,
        error: null,
        action: null,
        read: false,
        written: false,
        pushedA: false,
        pushedC: false
      };
      ++this._cellSetSize;
    }
    if (!c.pushedA) {
      this._cellArr.push(c);
      c.cell = cell;
      c.pushedA = true;
    }
    return c;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "onread", {
  value: function(cell) {
    var c = this._linkCell(cell);
    c.read = true;
    c.value = cell._value;
    c.error = cell._error;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "onwritten", {
  value: function(cell) {
    this._linkCell(cell).written = true;
  },
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__2, "_fire", {
  value: function() {
    if (this._onchange)
      updates.later(this._onchange);
    this._unsubscribe();
  },
  configurable: true,
  enumerable: true,
  writable: true
}), $__2), {});
Action.maxCount = 0;
var newReactive = (function(getter, handlers, sticky, isValueEqual) {
  for (var $__3 = handlers[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__4 = void 0; !($__4 = $__3.next()).done; ) {
    var h = $__4.value;
    if (h != null && typeof h != "function")
      throw new Error("wrong parameters");
  }
  var cell = new Cell(sticky);
  if (getter !== undefined)
    cell._init(getter, false, true, isValueEqual);
  for (var $__5 = handlers[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__6 = void 0; !($__6 = $__5.next()).done; ) {
    var h$__21 = $__6.value;
    h$__21 && (h$__21.length ? runSetter : runGetter)(cell, h$__21, sticky);
  }
  return cell;
});
var ra = function() {
  var name,
      fun,
      sticky,
      isValueEqual,
      index = 0,
      length = arguments.length - 1;
  if (typeof arguments[index] == "string")
    name = arguments[index++];
  if (typeof arguments[index] == "boolean")
    sticky = arguments[index++];
  fun = arguments[index++];
  if (typeof arguments[index] == "function")
    isValueEqual = arguments[index++];
  return newReactive(fun, [], sticky, isValueEqual);
};
exports = module.exports = ra;
exports.ra = ra;
exports.clean = (function(getter) {
  for (var handers = [],
      $__9 = 1; $__9 < arguments.length; $__9++)
    handers[$__9 - 1] = arguments[$__9];
  return newReactive(getter, handers, false);
});
exports.detach = (function(fun) {
  var old;
  if (old = co.global[actionKey]) {
    co.global[actionKey] = null;
    try {
      return fun();
    } finally {
      co.global[actionKey] = old;
    }
  } else
    return fun();
});
exports.Cell = Cell;
exports.ImmutableInterface = ImmutableInterface;
exports.AbstractGuard = AbstractGuard;
exports.Getter = Getter;
exports.Type = Type;
exports.importFrom = (function(observable) {
  return Type((function(name) {
    return Getter((function() {
      return observable.live[name].valueOf();
    }));
  }));
});
exports.forceCalculations = (function() {
  return updates.runAll();
});
exports.map = (function(dest, source, convert) {
  throw new Error("message");
  if (!(dest instanceof Cell))
    dest = ra.clean(dest);
  var scache = ra.clean();
  scache.defineProperty();
  var dcache = ra.clean();
  dcache.defineProperty();
  ra.clean((function() {
    return scache.assign(getValue(source));
  }));
  ra.clean((function() {
    var src = scache.valueOf();
    updates.later((function() {
      var i = 0;
      var $__22 = function(k) {
        if (src.hasOwnProperty(k)) {
          if (dcache.live.hasOwnProperty(k))
            return {v: (void 0)};
          var s = scache.defineProperty(k);
          var d = dcache.defineProperty(k);
          !((function(i) {
            return ra.clean((function() {
              return convert(d, s, k, i);
            }));
          }))(i);
          ++i;
        }
      },
          $__23;
      for (var k in src) {
        $__23 = $__22(k);
        if (typeof $__23 === "object")
          return $__23.v;
      }
    }));
  }));
  ra.clean((function() {
    return dest.assign(getValue(dcache));
  }));
  return dest;
});
exports.slice = (function(dest, source, keysVar) {
  throw new Error("message");
  if (!(dest instanceof Cell))
    dest = ra.clean(dest);
  var cacheHolder = ra.clean();
  ra.clean((function() {
    var keys = getValue(keysVar);
    if (keys)
      keys.sort();
    updates.later((function() {
      var c = ra.clean();
      var s = c.defineProperty("source");
      var d = c.defineProperty("dest");
      keys && keys.forEach((function(k) {
        var sk = s.defineProperty(k);
        var dk = d.defineProperty(k);
        ra.clean((function() {
          return dk.assign(sk.valueOf());
        }));
      }));
      var t = cacheHolder.valueOf();
      cacheHolder.assign(c);
      t && t.close();
    }));
  }));
  ra.clean((function() {
    var c = cacheHolder.valueOf();
    c && c.source && c.source.assign(source.valueOf());
  }));
  ra.clean((function() {
    var c = cacheHolder.valueOf();
    dest.assign(c && c.dest && c.dest.valueOf());
  }));
  return dest;
});

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/ra.map

      } )
    }()

},{"co":"/home/vadzim/v/work/nerojs/src/co.js","later":"/home/vadzim/v/work/nerojs/src/later.js","lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js","uid":"/home/vadzim/v/work/nerojs/src/uid.js"}],"/home/vadzim/v/work/nerojs/src/rewriter.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/rewriter.js" ] = total
        }
      }( function () {
        "use strict";
var express = require("express");
express.Router.rewrite = express.application.rewrite = function rewrite(what, rewriter) {
  return this.all(what, (function(request, _, next) {
    request.url = rewriter(request.url);
    next();
  }));
};

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/rewriter.map

      } )
    }()

},{"express":false}],"/home/vadzim/v/work/nerojs/src/scheduler.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/scheduler.js" ] = total
        }
      }( function () {
        "use strict";
var maxIndex = 32768;
var Scheduler = function Scheduler(options) {
  this.setImmediate = (options && options.setImmediate) || process.nextTick;
  this.maxTicks = (options && options.maxTicks) || Infinity;
  this._procs = [];
  this._index = 0;
  this._scheduled = false;
  this._processing = false;
  this._handler = this._handler.bind(this);
  this.push = this.then.bind(this);
};
($traceurRuntime.createClass)(Scheduler, {
  then: function(proc) {
    this._procs.push(proc);
    if (!this._processing)
      this._schedule();
  },
  _schedule: function() {
    if (!this._scheduled) {
      this.setImmediate(this._handler);
      this._scheduled = true;
    }
  },
  _handler: function() {
    this._scheduled = false;
    var $__1 = this,
        $__2 = function() {
          try {
            $__1._handler1();
          } catch (error) {
            setTimeout((function() {
              throw error;
            }), 0);
          }
        };
    while (this._procs.length) {
      $__2();
    }
  },
  _handler1: function() {
    this._processing = true;
    try {
      var t = 0;
      while (this._index < this._procs.length && (++t <= this.maxTicks)) {
        var proc = this._procs[this._index];
        this._procs[this._index] = null;
        ++this._index;
        if (this._index >= maxIndex && this._index * 3 > this._procs.length) {
          this._procs.splice(0, this._index);
          this._index = 0;
        }
        proc();
      }
    } finally {
      this._processing = false;
      if (this._procs.length && this._index >= this._procs.length)
        this._procs.length = this._index = 0;
      if (this._index)
        this._schedule();
    }
  }
}, {});
module.exports = Scheduler;

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/scheduler.map

      } )
    }()

},{}],"/home/vadzim/v/work/nerojs/src/server.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/server.js" ] = total
        }
      }( function () {
        module.exports = function() {
  "use strict";
  var $__82 = $traceurRuntime.initGeneratorFunction(readFiles);
  require("checkreboot");
  require("platform");
  var repl = false;
  var YAML = require("yamljs");
  var path = require("path");
  var fs = require("fs");
  var os = require("os");
  var cfg = require("csvConfig");
  var HTTPStatus = require("http-status");
  var http = require("http");
  var url = require("url");
  var net = require("net");
  var crypto = require("crypto");
  var stream = require("stream");
  var glob = require("glob");
  var constants = require("constants");
  var PingPong = require("pingpong");
  var actionToCommands = require("actionToCommands");
  var deviceActions = require("deviceActions");
  var deviceTypes = require("deviceTypes");
  var Modem = require("modem");
  var Inc = require("inc");
  var lodash = require("lodash");
  var ra = require("ra");
  var co = require("co");
  var lu = require("localUtils");
  var UID = require("uid");
  var configName = process.argv[2] || __dirname + "/../server.conf";
  var config = lu.tryElse((function() {
    return YAML.load(configName);
  }), (function() {}));
  var updateInterfacesInterval = 2000;
  fs.mkdir(__dirname + "/../var", (function() {}));
  config = lodash.merge({
    port: 80,
    serviceport: 8088,
    modem: "/dev/ttyACM*",
    modemPingInterval: 6000,
    boss: "controller.sh.neroelectronics.vadzim.info:8011",
    auth: "./user.conf",
    restoreConnectionInterval: 2000
  }, config);
  var internalModemService = ("/tmp/" + UID());
  var authName = path.resolve(path.dirname(configName), config.auth);
  var auth = lu.catch((function() {
    return YAML.load(authName);
  }), null);
  auth = lodash.merge({name: "nero"}, auth);
  if (auth && !auth.modem)
    throw new Error("modem name required in user configuration file");
  if (auth && !auth.name)
    throw new Error("name required in user configuration file");
  if (auth && !auth.userkey)
    throw new Error("userkey required in user configuration file");
  if (auth) {
    var s = crypto.createHash("sha256");
    s.update(JSON.stringify([String(auth.name || null), String(auth.userkey || null), String(auth.modemkey || null), String(auth.modem || null)]));
    auth.hash = s.digest("hex");
  }
  var authMessage = "Smart Home";
  var closeSocket = (function(socket) {
    socket.end();
    socket.unref();
    socket.destroy();
  });
  var service = ra({
    interfacesTimer: true,
    get updateInterfacesTimer() {
      setInterval((function() {
        return service.live.interfacesTimer.touch();
      }), updateInterfacesInterval);
    },
    interfaces: ra.Getter((function() {
      var $__12;
      return service.interfacesTimer && ($__12 = []).concat.apply($__12, $traceurRuntime.spread(lodash.map(os.networkInterfaces(), (function(ni) {
        return ni.filter((function(i) {
          return !i.internal && !i.scopeid;
        })).map((function(i) {
          var a = i.address;
          if (i.family == "IPv6")
            a = ("[" + a + "]");
          return {url: ("http://" + a + ":" + config.serviceport)};
        }));
      }))));
    }), lu.JSONEqual)
  });
  var CustomError = function CustomError(message, data) {
    $traceurRuntime.superConstructor($CustomError).call(this, message);
    data && lodash.assign(this, data);
  };
  var $CustomError = CustomError;
  ($traceurRuntime.createClass)(CustomError, {}, {}, Error);
  var modem = ra({
    retryInterval: config.restoreConnectionInterval,
    port: config.modem,
    proxy: config.modemProxy,
    portIndex: 0,
    socket: null,
    pingInterval: config.modemPingInterval,
    createSocket: function() {
      return new Promise((function(resolve, reject) {
        console.error("creating socket");
        var socket;
        var reconnect = lodash.once((function() {
          if (modem.socket && socket != modem.socket)
            return ;
          setTimeout((function() {
            if (!modem.socket)
              modem.createSocket();
          }), modem.retryInterval);
          if (socket) {
            closeSocket(socket);
            socket = null;
            modem.socket = null;
          }
        }));
        var onerror = (function(error) {
          console.error("socket error", error);
          reconnect();
          reject(error);
        });
        var connect = (function(port) {
          if (modem.socket) {
            closeSocket(modem.socket);
            modem.socket = null;
          }
          console.error(("trying to connect to: " + port) + (modem.proxy ? (" via " + modem.proxy) : ""));
          if (modem.proxy) {
            socket = new (stream.Duplex);
            socket.destroy = function() {
              this.ps.stdin.end();
              this.ps.kill();
            };
            socket.unref = (function() {});
            socket._read = (function(n) {});
            socket._write = function(chunk, encoding, callback) {
              this.ps.stdin.write(chunk, encoding);
              console.log('**************', callback);
              callback();
            };
            socket.connect = function(path) {
              var $__0 = this;
              console.log("starting proxy", modem.proxy, port);
              this.ps = require("child_process").spawn(modem.proxy, [path]);
              this.ps.stderr.on("data", (function(data) {
                return process.stdout.write(String(data).blue);
              }));
              this.ps.stdout.on("data", (function(data) {
                return $__0.push(data);
              }));
              this.ps.on("error", (function(error) {
                return $__0.emit("error", error);
              }));
              this.ps.stdin.on("error", (function(error) {
                return $__0.emit("error", error);
              }));
              this.ps.on("exit", (function(data) {
                return $__0.push(null);
              }));
              this.emit("connect");
            };
          } else if (typeof port == "number")
            socket = new net.Socket();
          else
            socket = new PingPong({timeout: 3000});
          socket.on("connect", (function() {
            socket.unref();
            modem.socket = socket;
            resolve(socket);
          }));
          socket.on("error", onerror);
          socket.on("end", (function() {
            console.error("socket ended");
            reconnect();
          }));
          socket.on("close", (function() {
            console.error("socket closed");
            reconnect();
          }));
          socket.on("timeout", (function() {
            console.error("socket timeout");
            reconnect();
          }));
          socket.connect(port);
        });
        if (modem.port == +modem.port)
          connect(+modem.port);
        else
          glob(modem.port, {}, (function(error, dir) {
            if (error)
              return onerror(error);
            if (!dir.length)
              return onerror(new Error(("Cannot find a modem in " + modem.port)));
            if (modem.portIndex >= dir.length)
              modem.portIndex = 0;
            connect(dir[modem.portIndex++]);
          }));
      }));
    },
    get initializeSocket() {
      modem.createSocket();
    },
    get handle() {
      return modem.socket && new Modem(modem.socket, (function() {
        var $__12;
        for (var args = [],
            $__4 = 0; $__4 < arguments.length; $__4++)
          args[$__4] = arguments[$__4];
        return ($__12 = console).info.apply($__12, $traceurRuntime.spread([lu.time()], args));
      }));
    },
    rawcommand: $traceurRuntime.initGeneratorFunction(function $__14() {
      var args,
          $__4,
          $__21,
          $__22,
          $__23,
          $__24,
          $__25,
          $__26,
          $__27,
          $__28,
          $__29,
          $__30,
          $__31,
          $__32,
          $__33,
          $__34,
          $__35,
          $__36,
          $__37,
          $__38,
          $__39,
          $__40,
          $__41,
          $__42,
          $__43,
          $__44,
          $__45,
          $__46,
          $__47,
          $__48,
          $__49;
      var $arguments = arguments;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              for (args = [], $__4 = 0; $__4 < $arguments.length; $__4++)
                args[$__4] = $arguments[$__4];
              $ctx.state = 17;
              break;
            case 17:
              $__21 = modem.handle;
              $ctx.state = 13;
              break;
            case 13:
              $ctx.state = ($__21) ? 5 : 9;
              break;
            case 5:
              $__22 = modem.handle;
              $__23 = $__22.lock;
              $__24 = $traceurRuntime.initGeneratorFunction;
              $__46 = $__24.call($traceurRuntime, function $__15(command) {
                var $__16,
                    $__17,
                    $__18,
                    $__19,
                    $__20,
                    error;
                return $__25 = $traceurRuntime.createGeneratorInstance, $__45 = $__25.call($traceurRuntime, function($ctx) {
                  while (true)
                    switch ($__26 = $ctx.state, $__26) {
                      case 0:
                        $__27 = $ctx.pushTry, $__28 = $__27.call($ctx, 13, null), $__28;
                        $ctx.state = 16, 16;
                        break;
                      case 16:
                        $__29 = command.apply, $__16 = $__29, $__29;
                        $__30 = $traceurRuntime.spread, $__17 = $__30, $__30;
                        $__31 = $__17.call, $__32 = $__31.call($__17, $traceurRuntime, args), $__18 = $__32, $__32;
                        $__33 = $__16.call, $__34 = $__33.call($__16, command, (void 0), $__18), $__19 = $__34, $__34;
                        $ctx.state = 6, 6;
                        break;
                      case 6:
                        $ctx.state = 2, 2;
                        return $__19;
                      case 2:
                        $__35 = $ctx.sent, $__20 = $__35, $__35;
                        $ctx.state = 4, 4;
                        break;
                      case 4:
                        $ctx.returnValue = $__20, $__20;
                        $ctx.state = -2, -2;
                        break;
                      case 8:
                        $__36 = $ctx.popTry, $__37 = $__36.call($ctx), $__37;
                        $ctx.state = -2, -2;
                        break;
                      case 13:
                        $__38 = $ctx.popTry, $__39 = $__38.call($ctx), $__39;
                        $__40 = $ctx.storedException, error = $__40, $__40;
                        $ctx.state = 11, 11;
                        break;
                      case 11:
                        $__41 = console.error, $__42 = $__41.call(console, "modem error", error, "executing", args), $__42;
                        $ctx.state = 12, 12;
                        break;
                      case 12:
                        $ctx.returnValue = null, null;
                        $ctx.state = -2, -2;
                        break;
                      default:
                        return $__43 = $ctx.end, $__44 = $__43.call($ctx), $__44;
                    }
                }, $__15, this), $__45;
              });
              $__47 = $__23.call($__22, $__46);
              $ctx.state = 6;
              break;
            case 6:
              $ctx.state = 2;
              return $__47;
            case 2:
              $__48 = $ctx.sent;
              $ctx.state = 4;
              break;
            case 4:
              $__49 = $__48;
              $ctx.state = 8;
              break;
            case 9:
              $__49 = $__21;
              $ctx.state = 8;
              break;
            case 8:
              $ctx.returnValue = $__49;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__14, this);
    }),
    get version() {
      return modem.rawcommand("Version");
    },
    get pingModem() {
      return modem.pingInterval && ra($traceurRuntime.initGeneratorFunction(function $__15() {
        var error;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $ctx.state = 2;
                return co.sleep(modem.pingInterval);
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              case 4:
                $ctx.state = (modem.handle) ? 11 : 0;
                break;
              case 11:
                $ctx.pushTry(9, null);
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = 6;
                return modem.handle.lock($traceurRuntime.initGeneratorFunction(function $__50(command) {
                  return $traceurRuntime.createGeneratorInstance(function($ctx) {
                    while (true)
                      switch ($ctx.state) {
                        case 0:
                          $ctx.state = 2;
                          return command("Version");
                        case 2:
                          $ctx.maybeThrow();
                          $ctx.state = -2;
                          break;
                        default:
                          return $ctx.end();
                      }
                  }, $__50, this);
                }), true);
              case 6:
                $ctx.maybeThrow();
                $ctx.state = 8;
                break;
              case 8:
                $ctx.popTry();
                $ctx.state = 0;
                break;
              case 9:
                $ctx.popTry();
                error = $ctx.storedException;
                $ctx.state = 15;
                break;
              case 15:
                console.error("modem ping error", error);
                $ctx.state = 0;
                break;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      }));
    },
    get sversion() {
      return modem.version && String.fromCharCode(modem.version.PRODUCT_VERSION, modem.version.PRODUCT_ID, modem.version.PRODUCT_HARD, modem.version.PRODUCT_VARIANT);
    },
    sminVersion: String.fromCharCode(1, 5),
    get versionOK() {
      return modem.sversion && modem.sversion >= modem.sminVersion;
    },
    vercommand: $traceurRuntime.initGeneratorFunction(function $__15() {
      var $__12,
          args,
          $__5,
          $__51,
          $__52,
          $__53,
          $__54,
          $__55,
          $__56,
          $__57,
          $__58;
      var $arguments = arguments;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              for (args = [], $__5 = 0; $__5 < $arguments.length; $__5++)
                args[$__5] = $arguments[$__5];
              $ctx.state = 17;
              break;
            case 17:
              $__51 = modem.versionOK;
              $ctx.state = 13;
              break;
            case 13:
              $ctx.state = (!$__51) ? 9 : 5;
              break;
            case 9:
              $__58 = null;
              $ctx.state = 10;
              break;
            case 5:
              $__12 = modem;
              $__52 = modem.rawcommand;
              $__53 = $__52.apply;
              $__54 = $traceurRuntime.spread;
              $__55 = $__54.call($traceurRuntime, args);
              $__56 = $__53.call($__52, $__12, $__55);
              $ctx.state = 6;
              break;
            case 6:
              $ctx.state = 2;
              return $__56;
            case 2:
              $__57 = $ctx.sent;
              $ctx.state = 4;
              break;
            case 4:
              $__58 = $__57;
              $ctx.state = 10;
              break;
            case 10:
              $ctx.returnValue = $__58;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__15, this);
    }),
    get functions() {
      return modem.vercommand("Functions");
    },
    get initProtocols() {
      return modem.vercommand("Change_protocol", {PROTOCOL_NUM: "All_protocols"});
    },
    get protocolOK() {
      return !!(modem.functions && modem.functions.PROTOCOLS && modem.initProtocols);
    },
    sendcommand: $traceurRuntime.initGeneratorFunction(function $__50() {
      var $__12,
          args,
          $__6,
          $__59,
          $__60,
          $__61,
          $__62,
          $__63,
          $__64,
          $__65,
          $__66;
      var $arguments = arguments;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              for (args = [], $__6 = 0; $__6 < $arguments.length; $__6++)
                args[$__6] = $arguments[$__6];
              $ctx.state = 17;
              break;
            case 17:
              $__59 = modem.protocolOK;
              $ctx.state = 13;
              break;
            case 13:
              $ctx.state = (!$__59) ? 9 : 5;
              break;
            case 9:
              $__66 = null;
              $ctx.state = 10;
              break;
            case 5:
              $__12 = modem;
              $__60 = modem.vercommand;
              $__61 = $__60.apply;
              $__62 = $traceurRuntime.spread;
              $__63 = $__62.call($traceurRuntime, args);
              $__64 = $__61.call($__60, $__12, $__63);
              $ctx.state = 6;
              break;
            case 6:
              $ctx.state = 2;
              return $__64;
            case 2:
              $__65 = $ctx.sent;
              $ctx.state = 4;
              break;
            case 4:
              $__66 = $__65;
              $ctx.state = 10;
              break;
            case 10:
              $ctx.returnValue = $__66;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__50, this);
    }),
    get freeCells() {
      return modem.sendcommand("Free_Cell_Count");
    },
    setModemWorkMode: function() {
      return modem.command("Change_modem_work_mode", {MODEM_MODE: "Work_Mode"});
    },
    get initModemWorkMode() {
      return modem.sendcommand("Change_modem_work_mode", {MODEM_MODE: "Work_Mode"});
    },
    command: function() {
      for (var args = [],
          $__7 = 0; $__7 < arguments.length; $__7++)
        args[$__7] = arguments[$__7];
      return co.gocall($traceurRuntime.initGeneratorFunction(function $__67() {
        var $__12,
            $__68,
            $__69,
            $__70,
            $__71,
            $__72,
            $__73,
            $__74;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__12 = this;
                $__68 = this;
                $__69 = $__68.sendcommand;
                $__70 = $__69.apply;
                $__71 = $traceurRuntime.spread;
                $__72 = $__71.call($traceurRuntime, args);
                $__73 = $__70.call($__69, $__12, $__72);
                $ctx.state = 6;
                break;
              case 6:
                $ctx.state = 2;
                return $__73;
              case 2:
                $__74 = $ctx.sent;
                $ctx.state = 4;
                break;
              case 4:
                $ctx.returnValue = $__74;
                $ctx.state = -2;
                break;
              default:
                return $ctx.end();
            }
        }, $__67, this);
      }), this);
    },
    get showModemStatus() {
      console.info(("Modem is " + (modem.protocolOK ? "active" : "inactive")));
    },
    session: function(callback) {
      return ra.detach((function() {
        return co.go($traceurRuntime.initGeneratorFunction(function $__67() {
          var $__75,
              $__76,
              $__77,
              $__78,
              $__79,
              $__80,
              $__81;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $ctx.state = (modem.protocolOK) ? 5 : 13;
                  break;
                case 5:
                  $__75 = modem.handle;
                  $__76 = $__75.lock;
                  $__77 = $__76.call($__75, callback);
                  $ctx.state = 6;
                  break;
                case 6:
                  $ctx.state = 2;
                  return $__77;
                case 2:
                  $__78 = $ctx.sent;
                  $ctx.state = 4;
                  break;
                case 4:
                  $ctx.returnValue = $__78;
                  $ctx.state = -2;
                  break;
                case 13:
                  $__79 = lu.returnNullPromise;
                  $__80 = callback($__79);
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = 10;
                  return $__80;
                case 10:
                  $__81 = $ctx.sent;
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.returnValue = $__81;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__67, this);
        }));
      }));
    },
    check: function(answer) {
      var result = arguments[1] !== (void 0) ? arguments[1] : "OK";
      if (answer.id !== "answer_Result" || answer.RESULT !== result)
        throw new Error("unexpected modem result");
      return answer.RESULT;
    },
    userCommand: $traceurRuntime.initGeneratorFunction(function $__67($__10) {
      var $__11,
          deviceId,
          command,
          data,
          socket,
          error,
          device,
          deviceCommand,
          groups,
          i,
          commands,
          newstate,
          passedToModem,
          my_timestamp,
          errors;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $__11 = $__10, deviceId = $__11.deviceId, command = $__11.command, data = $__11.data, socket = $__11.socket;
              error = (function(status, message) {
                throw new CustomError(message || HTTPStatus[status], {status: status});
              });
              $ctx.state = 26;
              break;
            case 26:
              $ctx.state = 2;
              return modem.devices.waitForReady(socket);
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              device = modem.devices.getState()[deviceId];
              deviceCommand = command;
              if (!device)
                error(HTTPStatus.NOT_FOUND);
              $ctx.state = 28;
              break;
            case 28:
              $ctx.state = (!device.group) ? 19 : 16;
              break;
            case 19:
              $ctx.state = (deviceCommand == "Link") ? 13 : 17;
              break;
            case 13:
              groups = lodash.reduce(modem.devices.getState(), (function(ret, d) {
                if (d.group)
                  ret[d.group] = true;
                return ret;
              }), []);
              $ctx.state = 14;
              break;
            case 14:
              i = 2;
              $ctx.state = 12;
              break;
            case 12:
              $ctx.state = (i <= 1022) ? 9 : 10;
              break;
            case 6:
              ++i;
              $ctx.state = 12;
              break;
            case 9:
              $ctx.state = (groups[i] == null) ? 7 : 6;
              break;
            case 7:
              modem.devices.applyItemChanges(deviceId, {group: i});
              $ctx.state = 10;
              break;
            case 10:
              ra.forceCalculations();
              device = modem.devices.getState()[deviceId];
              if (!device.group)
                error(HTTPStatus.INTERNAL_SERVER_ERROR, "No more group numbers for devices");
              $ctx.state = 16;
              break;
            case 17:
              error(HTTPStatus.NOT_FOUND, "No group in device");
              $ctx.state = 16;
              break;
            case 16:
              newstate = deviceActions.getNewState(device, deviceCommand);
              commands = actionToCommands.createCommandSequence(device.group, deviceTypes[device.model].buttons, deviceCommand);
              if (!commands || !commands.length)
                error(HTTPStatus.NOT_FOUND);
              passedToModem = false;
              my_timestamp = Inc();
              errors = [];
              co.defer((function() {
                if (!passedToModem && my_timestamp == modem.devices.getState()[deviceId].newstate_timestamp)
                  modem.devices.applyItemChanges(deviceId, {
                    newstate: null,
                    newstate_timestamp: null
                  });
              }));
              modem.devices.applyItemChanges(deviceId, {
                newstate: newstate,
                newstate_timestamp: my_timestamp,
                errorneous: null
              });
              $ctx.state = 30;
              break;
            case 30:
              $ctx.state = 22;
              return modem.session($traceurRuntime.initGeneratorFunction(function $__82(command) {
                var $__2,
                    $__3,
                    c,
                    acknowledgement,
                    answer,
                    e,
                    $__84,
                    $__85,
                    $__86,
                    $__87,
                    $__88,
                    $__89;
                return $traceurRuntime.createGeneratorInstance(function($ctx) {
                  while (true)
                    switch ($ctx.state) {
                      case 0:
                        command = $traceurRuntime.initGeneratorFunction(function $__83() {
                          return $traceurRuntime.createGeneratorInstance(function($ctx) {
                            while (true)
                              switch ($ctx.state) {
                                case 0:
                                  $ctx.state = 2;
                                  return co.sleep(2000);
                                case 2:
                                  $ctx.maybeThrow();
                                  $ctx.state = 4;
                                  break;
                                case 4:
                                  $ctx.returnValue = {RESULT: "Connection_error"};
                                  $ctx.state = -2;
                                  break;
                                default:
                                  return $ctx.end();
                              }
                          }, $__83, this);
                        });
                        $ctx.state = 32;
                        break;
                      case 32:
                        $__2 = commands[$traceurRuntime.toProperty(Symbol.iterator)](), $__3 = void 0;
                        $ctx.state = 14;
                        break;
                      case 14:
                        $ctx.state = (!($__3 = $__2.next()).done) ? 18 : 20;
                        break;
                      case 18:
                        c = $__3.value;
                        $ctx.state = 19;
                        break;
                      case 19:
                        $ctx.pushTry(9, null);
                        $ctx.state = 12;
                        break;
                      case 12:
                        acknowledgement = device.acknowledgement !== false;
                        c.ACK = !!acknowledgement;
                        $ctx.state = 6;
                        break;
                      case 6:
                        $ctx.state = 2;
                        return command(c);
                      case 2:
                        answer = $ctx.sent;
                        $ctx.state = 4;
                        break;
                      case 4:
                        if (!(answer.RESULT == "OK"))
                          throw new CustomError(answer.RESULT, {answer: answer});
                        $ctx.state = 8;
                        break;
                      case 8:
                        $ctx.popTry();
                        $ctx.state = 14;
                        break;
                      case 9:
                        $ctx.popTry();
                        e = $ctx.storedException;
                        $ctx.state = 15;
                        break;
                      case 15:
                        console.error("modem error:".red, e);
                        if (e instanceof Modem.ETimeout || e.answer && e.answer.RESULT == "Connection_error")
                          errors.push(e);
                        else
                          throw e;
                        $ctx.state = 14;
                        break;
                      case 20:
                        $ctx.state = (errors.length) ? 26 : 29;
                        break;
                      case 26:
                        $__84 = commands[0];
                        $__85 = $__84.group;
                        $__86 = {
                          id: "Dest_Condition",
                          group: $__85
                        };
                        $__87 = command($__86);
                        $ctx.state = 27;
                        break;
                      case 27:
                        $ctx.state = 23;
                        return $__87;
                      case 23:
                        $__88 = $ctx.sent;
                        $ctx.state = 25;
                        break;
                      case 25:
                        $__89 = $__88.DEST_CONDITION;
                        newstate = $__89;
                        $ctx.state = 29;
                        break;
                      case 29:
                        if (newstate != null) {
                          modem.devices.applyItemChanges(deviceId, {
                            state: newstate,
                            state_timestamp: my_timestamp,
                            errorneous: newstate == null ? true : null
                          });
                          passedToModem = true;
                        }
                        $ctx.state = -2;
                        break;
                      default:
                        return $ctx.end();
                    }
                }, $__82, this);
              }));
            case 22:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__67, this);
    })
  });
  require("watchStop")(configName)(authName)(__dirname + "/../templates/")(__dirname + "/../templates/locations/");
  var express = require("express");
  require("rewriter");
  var JSONservice = require("JSONservice");
  global.LOGGER = console;
  function readFiles(path, filter) {
    var names,
        files;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $ctx.state = 2;
            return co.cb(fs.readdir)(path);
          case 2:
            names = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            if (filter)
              names = names.filter(filter);
            files = names.map((function(fn) {
              return [fn, co.cb(fs.readFile)(path + "/" + fn, "utf8")];
            }));
            $ctx.state = 8;
            break;
          case 8:
            $ctx.returnValue = lodash.zipObject(files);
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__82, this);
  }
  function staticData(value) {
    var contentType = arguments[1] !== (void 0) ? arguments[1] : "json";
    return co.func($traceurRuntime.initGeneratorFunction(function $__83(_, response) {
      var $__90,
          $__91,
          $__92,
          $__93,
          $__94,
          $__95,
          $__96;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $__90 = response.contentType;
              $__91 = $__90.call(response, contentType);
              $__92 = $__91.end;
              $__93 = value.then;
              $ctx.state = 11;
              break;
            case 11:
              $ctx.state = ($__93) ? 1 : 7;
              break;
            case 1:
              $ctx.state = 2;
              return value;
            case 2:
              $__94 = $ctx.sent;
              $ctx.state = 4;
              break;
            case 4:
              $__95 = $__94;
              $ctx.state = 6;
              break;
            case 7:
              $__95 = value;
              $ctx.state = 6;
              break;
            case 6:
              $__96 = $__92.call($__91, $__95);
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__83, this);
    }));
  }
  function beautify(text) {
    return text.toString().replace(/([a-df-z"'\x20])(><)/g, (function($, $1, $2) {
      return ($1 + "\n" + $2);
    }));
  }
  var cookieInfinite = {expires: new Date("Fri, 31-Dec-9999 23:59:59 GMT")};
  var toBase64 = (function(str) {
    return (new Buffer(str)).toString("base64");
  });
  var fromBase64 = (function(str) {
    return (new Buffer(str, "base64")).toString();
  });
  var cookieParser = require("cookie-parser")();
  var parseCookies = (function(request) {
    return cookieParser(request, null, lodash.noop);
  });
  var checkAuthorization = co.func($traceurRuntime.initGeneratorFunction(function $__83(request, response, next) {
    var a,
        origin,
        socket;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            parseCookies(request);
            $ctx.state = 16;
            break;
          case 16:
            $ctx.state = (auth && request.cookies.auth != auth.hash) ? 1 : 10;
            break;
          case 1:
            $ctx.state = 2;
            return co.sleep(200);
          case 2:
            $ctx.maybeThrow();
            $ctx.state = 4;
            break;
          case 4:
            a = request.headers.authorization;
            if (a)
              a = a.match(/^Basic\s+(.*)$/);
            if (a)
              a = a[1];
            $ctx.state = 13;
            break;
          case 13:
            $ctx.state = (a == toBase64((auth.name + ":" + auth.userkey))) ? 9 : 7;
            break;
          case 9:
            response && response.cookie("auth", auth.hash, cookieInfinite);
            $ctx.state = 10;
            break;
          case 7:
            origin = request.headers.origin || "*";
            socket = request.socket;
            socket.write(("HTTP/1.1 " + HTTPStatus.UNAUTHORIZED + " " + HTTPStatus[HTTPStatus.UNAUTHORIZED] + "\r\nAccess-Control-Allow-Origin: " + origin + "\r\nAccess-Control-Allow-Credentials: true\r\nWWW-Authenticate: Basic realm=" + JSON.stringify(authMessage) + "\r\n\r\nunauthorized"));
            socket.end();
            response && response.status(HTTPStatus.UNAUTHORIZED).end();
            $ctx.state = 8;
            break;
          case 8:
            $ctx.state = -2;
            break;
          case 10:
            next();
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__83, this);
  }));
  var modemService = express().use(cookieParser).use(require("http_log")).use((function(request, response, next) {
    var origin = request.headers.origin || "*";
    response.setHeader("Access-Control-Allow-Origin", origin);
    response.setHeader("Access-Control-Allow-Credentials", true);
    next();
  })).use(require("compression")({threshold: 0})).all("/ping", (function(request, response) {
    return response.end("pong");
  })).all("/logout", (function(request, response) {
    response.clearCookie("auth");
    request.on("data", (function(data) {
      return response.write(data);
    }));
    request.on("end", (function() {
      return response.end("\n\n...LOGOUT");
    }));
  })).use(checkAuthorization).all("/login", (function(request, response) {
    response.end();
  })).post("/command", co.func($traceurRuntime.initGeneratorFunction(function $__97(request, response) {
    var error;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            co.defer((function() {
              return response.end();
            }));
            $ctx.state = 15;
            break;
          case 15:
            $ctx.pushTry(5, null);
            $ctx.state = 8;
            break;
          case 8:
            $ctx.state = 2;
            return modem.userCommand({
              deviceId: request.query.id,
              command: request.query.cmd,
              data: null,
              socket: response
            });
          case 2:
            $ctx.maybeThrow();
            $ctx.state = 4;
            break;
          case 4:
            $ctx.popTry();
            $ctx.state = -2;
            break;
          case 5:
            $ctx.popTry();
            error = $ctx.storedException;
            $ctx.state = 11;
            break;
          case 11:
            console.error("command error", error, error.stack);
            response.status(error.code || HTTPStatus.INTERNAL_SERVER_ERROR).end(error.message || "");
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__97, this);
  }))).all("/devices", (modem.devices = new JSONservice(__dirname + "/../var/devices", {})).httpService).all("/rooms", (modem.places = new JSONservice(__dirname + "/../var/rooms", {
    main: "room",
    room: {content: []}
  })).httpService).post("/modem", co.func($traceurRuntime.initGeneratorFunction(function $__98(request, response, next) {
    var $__12,
        ret,
        undefined,
        func,
        args,
        $__99,
        $__100,
        $__101,
        $__102,
        $__103,
        $__104,
        $__105,
        $__106,
        $__107,
        error;
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            $ctx.pushTry(11, null);
            $ctx.state = 14;
            break;
          case 14:
            path$__13 = JSON.parse(request.query.path);
            func = JSON.parse(request.query.func);
            args = JSON.parse(request.query.args);
            $ctx.state = 10;
            break;
          case 10:
            $__99 = modem.devices;
            $__100 = $__99[path$__13];
            $__12 = $__100;
            $__101 = $__100[func];
            $__102 = $__101.apply;
            $__103 = $traceurRuntime.spread;
            $__104 = $__103.call($traceurRuntime, args);
            $__105 = $__102.call($__101, $__12, $__104);
            $ctx.state = 6;
            break;
          case 6:
            $ctx.state = 2;
            return $__105;
          case 2:
            $__106 = $ctx.sent;
            $ctx.state = 4;
            break;
          case 4:
            $__107 = {result: $__106};
            ret = $__107;
            $ctx.state = 8;
            break;
          case 8:
            $ctx.popTry();
            $ctx.state = 16;
            break;
          case 11:
            $ctx.popTry();
            error = $ctx.storedException;
            $ctx.state = 17;
            break;
          case 17:
            ret = {error: !(error instanceof Error) ? {error: error} : {
                stack: error.stack,
                message: error.message,
                name: error.name
              }};
            $ctx.state = 16;
            break;
          case 16:
            response.json(ret);
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__98, this);
  })));
  var WebSocket = require("websockets/lib/websockets/socket");
  var onUpgrade = (function(request, socket, head) {
    console.log(request.url.red);
    console.log("checking authorization".red);
    checkAuthorization(request, null, (function() {
      console.log("authorized".red);
      var connection = new WebSocket(request, socket, head, {});
      connection.on("message", (function(message) {
        return console.log(("<< " + request.url.red + " " + message.cyan));
      }));
      var oldSend = connection.send;
      connection.send = (function(message) {
        console.log((">> " + request.url.red + " " + message.cyan));
        oldSend.call(connection, message);
      });
      connection.on("open", (function() {
        return console.log("websocket open".green, request.url.red);
      }));
      connection.on("close", (function() {
        return console.log("websocket close".green, request.url.red);
      }));
      connection.on("error", (function(error) {
        return console.log("websocket error".green, request.url.red, error);
      }));
      switch (request.url) {
        case "/devices":
          modem.devices.wsService(connection);
          break;
        case "/places":
          modem.places.wsService(connection);
          break;
        case "/commands":
          connection.on("message", co.func($traceurRuntime.initGeneratorFunction(function $__108(message) {
            var id,
                error;
            return $traceurRuntime.createGeneratorInstance(function($ctx) {
              while (true)
                switch ($ctx.state) {
                  case 0:
                    $ctx.pushTry(9, null);
                    $ctx.state = 12;
                    break;
                  case 12:
                    message = JSON.parse(message);
                    id = message.id;
                    message = message.question;
                    if (!id || !message)
                      throw new Error("wrong question");
                    $ctx.state = 6;
                    break;
                  case 6:
                    $ctx.state = 2;
                    return modem.userCommand({
                      deviceId: message.device,
                      command: message.command,
                      data: null
                    });
                  case 2:
                    $ctx.maybeThrow();
                    $ctx.state = 4;
                    break;
                  case 4:
                    connection.send(JSON.stringify({
                      id: id,
                      answer: "done"
                    }));
                    $ctx.state = 8;
                    break;
                  case 8:
                    $ctx.popTry();
                    $ctx.state = -2;
                    break;
                  case 9:
                    $ctx.popTry();
                    error = $ctx.storedException;
                    $ctx.state = 15;
                    break;
                  case 15:
                    console.error("command error", error, error.stack);
                    connection.send(JSON.stringify({
                      id: id,
                      error: error.message
                    }));
                    $ctx.state = -2;
                    break;
                  default:
                    return $ctx.end();
                }
            }, $__108, this);
          })));
        default:
      }
    }));
  });
  var createModemServer = (function(Server) {
    var $__12;
    for (var connection = [],
        $__8 = 1; $__8 < arguments.length; $__8++)
      connection[$__8 - 1] = arguments[$__8];
    return ($__12 = Server.createServer(modemService).on("upgrade", onUpgrade)).listen.apply($__12, $traceurRuntime.spread(connection));
  });
  createModemServer(http, config.serviceport, "::");
  createModemServer(http, internalModemService);
  var commonService = require("http_common_server")({router: require("express").Router().get("/modem_locations", (function(request, response) {
      response.json(service.interfaces);
    }))});
  http.createServer(commonService).listen(config.port, "::");
  var tellToBoss = (function() {
    var u = config.boss;
    if (!u.match(/\:\/\//))
      u = ("net://" + u);
    var b = url.parse(u);
    var sockets = {};
    console.log(("connecting to boss " + b.hostname + ":" + b.port).green);
    var client = require("JSONTransform").parse(net.connect(b.port, b.hostname, (function() {
      return ra((function() {
        return client.writable && client.write({
          what: "login",
          client: auth.modem,
          password: auth.modemkey,
          modemLocations: service.interfaces
        });
      }));
    })));
    var reconnect = lodash.once((function() {
      return setTimeout(tellToBoss, config.restoreConnectionInterval);
    }));
    var createStream = (function(streamid) {
      var stream = sockets[streamid] = {
        buffer: [],
        socket: net.connect(internalModemService, (function() {
          if (stream.buffer.length)
            stream.socket.write(Buffer.concat(stream.buffer));
          stream.buffer = null;
        }))
      };
      stream.socket.on("data", (function(data) {
        return client.write({
          what: "modem data",
          stream: streamid,
          data: data.toString("base64")
        });
      }));
      stream.socket.on("end", (function() {
        client.write({
          what: "modem data",
          stream: streamid,
          data: null
        });
        setTimeout((function() {
          delete sockets[streamid];
        }), 5000);
      }));
      return stream;
    });
    client.on("end", reconnect);
    client.on("error", (function(error) {
      console.log("boss error: ", error);
      reconnect();
    }));
    client.on("data", (function(data) {
      if (!data)
        return ;
      switch (data.what) {
        case "user data":
          var streamid = data.stream;
          var stream = sockets[streamid];
          if (data.data == null) {
            if (stream) {
              if (stream.socket.writable)
                stream.socket.end();
            } else
              console.log("STRANGE: received end of an absent stream", streamid);
          } else {
            var schunk = new Buffer(data.data, "base64");
            if (!stream)
              stream = createStream(streamid);
            if (stream.socket.writable)
              stream.socket.write(schunk);
            else if (stream.buffer)
              stream.buffer.push(schunk);
            else
              console.log("STRANGE: request to write to a closed stream");
          }
      }
    }));
  });
  tellToBoss();
  if (repl) {
    global.r = require;
    require("repl").start({
      useGlobal: true,
      ignoreUndefined: true
    });
    require("modemstub");
    modem.retryInterval = 2000000;
    global.Modem = Modem;
    global.mm = modem;
    global.c = (function() {
      for (var args = [],
          $__9 = 0; $__9 < arguments.length; $__9++)
        args[$__9] = arguments[$__9];
      modem.session($traceurRuntime.initGeneratorFunction(function $__108(command) {
        var $__109,
            $__110,
            $__111,
            $__112,
            $__113;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__109 = command.apply;
                $__110 = $traceurRuntime.spread;
                $__111 = $__110.call($traceurRuntime, args);
                $__112 = $__109.call(command, (void 0), $__111);
                $ctx.state = 6;
                break;
              case 6:
                $ctx.state = 2;
                return $__112;
              case 2:
                $__113 = $ctx.sent;
                $ctx.state = 4;
                break;
              case 4:
                $ctx.returnValue = $__113;
                $ctx.state = -2;
                break;
              default:
                return $ctx.end();
            }
        }, $__108, this);
      }));
    });
    c.v = c.bind(this, "Version");
    c.c = (function() {
      var COMFORT = arguments[0] !== (void 0) ? arguments[0] : 1;
      return c("Set_To_Comfort", {
        group: 1021,
        COMFORT: COMFORT
      });
    });
    global.m = (function(text) {
      return Modem.extractMessages(text).map((function(x) {
        switch (x.id) {
          case "Change_modem_work_mode":
            return {Change_modem_work_mode: x.MODEM_MODE};
          case "Free_Cell_Count":
            return null;
          case "answer_Result":
            return x.RESULT;
          case "answer_Free_Cell_Count":
            return {Free_Cell_Count: x.COUNT};
          case "Change_modem_work_mode":
          case "Functions":
          case "answer_Functions":
            delete x.cmdLo;
            delete x.cmdHi;
        }
        return x;
      })).filter(Boolean);
    });
    global.v = (function() {
      return m("\n16:29:56: Поддерживаемые драйверы sql\n16:29:56: QSQLITE\n16:29:56: QMYSQL3\n16:29:56: QMYSQL\n16:29:56: QPSQL7\n16:29:56: QPSQL\n16:29:56: Поток интерфейса перезапущен\n16:29:56: Открыт порт RS232 №3\n16:29:56: Посылка команды на модем 7e ff 3 1 8 0 0 20 12 0 0 0 0 68 39\n16:29:56: Принят ответ от модема: 7e ff 3 1 8 0 0 21 12 1 49 16 8 23 34 \n16:29:56: Версия ПО модема:73.1.8.22\n16:29:56: Посылка команды на модем 7e ff 3 1 8 0 0 20 11 0 0 0 0 9f 1f\n16:29:57: Принят ответ от модема: 7e ff 3 1 8 0 0 21 11 7a 0 7e 0 17 91 \n16:29:57: Посылка команды на модем 7e ff 3 1 8 0 0 20 15 0 0 0 0 59 99\n16:29:57: Принят ответ от модема: 7e ff 3 1 8 0 0 21 15 3 0 0 0 35 52 \n16:29:57: x=1366,y=628\n16:29:57: Поддерживаемые протоколы: Nero II Smarthome; Intro II Smarthome;\n16:29:57: Дополнительные функции: 0\n16:30:17: Посылка команды на модем 7e ff 3 1 8 fe 3 1 0 1 0 0 0 12 32\n16:30:18: Принят ответ от модема: 7e ff 3 1 8 fe 3 21 f 1 0 0 0 b1 1b \n16:30:28: Посылка команды на модем 7e ff 3 1 8 0 0 19 1 1 0 0 0 b 24\n16:30:28: Принят ответ от модема: 7e ff 3 1 8 0 0 21 f 1 0 0 0 96 a8 \n16:30:28: Посылка команды на модем 7e ff 3 1 8 0 0 20 11 0 0 0 0 9f 1f\n16:30:28: Принят ответ от модема: 7e ff 3 1 8 0 0 21 11 7a 0 7e 0 17 91 \n16:30:38: Посылка команды на модем 7e ff 3 1 8 fd 3 1 0 1 0 0 0 22 8c\n16:30:38: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5 \n16:30:42: Посылка команды на модем 7e ff 3 1 8 0 0 19 1 1 0 0 0 b 24\n16:30:42: Принят ответ от модема: 7e ff 3 1 8 0 0 21 f 1 0 0 0 96 a8 \n16:30:42: Посылка команды на модем 7e ff 3 1 8 0 0 20 11 0 0 0 0 9f 1f\n16:30:42: Принят ответ от модема: 7e ff 3 1 8 0 0 21 11 7a 0 7e 0 17 91 \n16:33:27: Посылка команды на модем 7e ff 3 1 8 fe 3 10 20 10 27 80 81 33 98\n16:33:28: Принят ответ от модема: 7e ff 3 1 8 fe 3 21 f 1 0 0 0 b1 1b \n16:34:01: Посылка команды на модем 7e ff 3 1 8 fd 3 10 20 10 27 80 81 3 26\n16:34:02: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5 \n16:34:11: Посылка команды на модем 7e ff 3 1 8 fe 3 10 20 0 0 80 81 30 ac\n16:34:11: Принят ответ от модема: 7e ff 3 1 8 fe 3 21 f 1 0 0 0 b1 1b \n16:34:18: Посылка команды на модем 7e ff 3 1 8 fd 3 10 20 0 0 80 81 0 12\n16:34:19: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5 \n\n\n00:31:52: Посылка команды на модем 7e ff 3 1 8 fd 3 10 20 0 0 80 81 0 12 00:31:52: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:31:57: Посылка команды на модем 7e ff 3 1 8 fe 3 10 20 10 27 80 81 33 98 00:31:58: Принят ответ от модема: 7e ff 3 1 8 fe 3 21 f 1 0 0 0 b1 1b  00:32:10: Посылка команды на модем 7e ff 3 1 8 fe 3 10 20 0 0 80 81 30 ac 00:32:11: Принят ответ от модема: 7e ff 3 1 8 fe 3 21 f 1 0 0 0 b1 1b  00:32:25: Посылка команды на модем 7e ff 3 1 8 fd 3 10 20 10 27 80 81 3 26 00:32:26: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:32:33: Посылка команды на модем 7e ff 3 1 8 fd 3 10 20 0 0 80 81 0 12 00:32:33: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:32:52: Посылка команды на модем 7e ff 3 1 8 fd 3 10 20 10 27 80 81 3 26 00:32:52: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:37:50: Посылка команды на модем 7e ff 3 1 8 fd 3 10 3 1 0 0 1 ae f2 00:37:51: Таймаут ожидания ответа от модема 00:37:52: Посылка команды на модем 7e ff 3 1 8 fd 3 10 3 9 0 0 1 dd f1 00:37:52: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:37:53: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:37:54: Посылка команды на модем 7e ff 3 1 8 fd 3 10 2 1 0 0 1 f4 c9 00:37:55: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:37:55: Посылка команды на модем 7e ff 3 1 8 fd 3 10 2 9 0 0 1 87 ca 00:37:56: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:38:04: Посылка команды на модем 7e ff 3 1 8 fd 3 10 4 1 0 60 1 9f 54 00:38:05: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:38:06: Посылка команды на модем 7e ff 3 1 8 fd 3 10 5 1 0 60 1 c5 6f 00:38:08: Таймаут ожидания ответа от модема 00:38:08: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:38:27: Посылка команды на модем 7e ff 3 1 8 fd 3 10 1 1 0 20 1 3 eb 00:38:28: Таймаут ожидания ответа от модема 00:38:28: Посылка команды на модем 7e ff 3 1 8 fd 3 10 1 9 0 20 1 70 e8 00:38:28: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:38:29: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:38:32: Посылка команды на модем 7e ff 3 1 8 fd 3 10 2 1 0 0 1 f4 c9 00:38:33: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5  00:38:33: Посылка команды на модем 7e ff 3 1 8 fd 3 10 2 9 0 0 1 87 ca 00:38:34: Принят ответ от модема: 7e ff 3 1 8 fd 3 21 f 1 0 0 0 81 a5 \n" || "\n13:00:35: Посылка команды на модем 7e ff 3 1 8 fe 3 8 3 0 0 80 0 e2 c8\n13:00:37: Таймаут ожидания ответа от модема\n13:00:37: Посылка команды на модем 7e ff 3 1 8 fe 3 8 1 0 0 0 0 4f d4\n13:00:38: Принят ответ от модема: 7e ff 3 1 8 fe 3 21 f 4 0 0 0 cf 6 \n13:00:38: Модем ответил: ошибка\n13:00:38: Посылка команды на модем 7e ff 3 1 8 0 0 19 1 1 0 0 0 b 24\n13:00:39: Принят ответ от модема: 7e ff 3 1 8 fe 3 21 f 1 0 0 0 b1 1b \n13:00:40: Принят ответ от модема: 7e ff 3 1 8 0 0 21 f 1 0 0 0 96 a8 \n13:00:40: Посылка команды на модем 7e ff 3 1 8 0 0 20 11 0 0 0 0 9f 1f\n13:00:40: Принят ответ от модема: 7e ff 3 1 8 0 0 21 11 7a 0 7e 0 17 91 \n\n\t");
    });
  }
  return {};
}.call(Reflect.global);

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/server.map

      } )
    }()

},{"JSONTransform":"/home/vadzim/v/work/nerojs/src/JSONTransform.js","JSONservice":"/home/vadzim/v/work/nerojs/src/JSONservice.js","actionToCommands":"/home/vadzim/v/work/nerojs/src/actionToCommands.js","checkreboot":"/home/vadzim/v/work/nerojs/src/checkreboot.js","child_process":false,"co":"/home/vadzim/v/work/nerojs/src/co.js","compression":false,"constants":false,"cookie-parser":"/home/vadzim/v/work/nerojs/node_modules/cookie-parser/index.js","crypto":false,"csvConfig":"/home/vadzim/v/work/nerojs/src/csvConfig.js","deviceActions":"/home/vadzim/v/work/nerojs/src/deviceActions.js","deviceTypes":"/home/vadzim/v/work/nerojs/src/deviceTypes.json","express":false,"fs":false,"glob":"/home/vadzim/v/work/nerojs/node_modules/glob/glob.js","http":false,"http-status":"/home/vadzim/v/work/nerojs/node_modules/http-status/lib/index.js","http_common_server":"/home/vadzim/v/work/nerojs/src/http_common_server.js","http_log":"/home/vadzim/v/work/nerojs/src/http_log.js","inc":"/home/vadzim/v/work/nerojs/src/inc.js","localUtils":"/home/vadzim/v/work/nerojs/src/localUtils.js","lodash":"/home/vadzim/v/work/nerojs/node_modules/lodash/dist/lodash.js","modem":"/home/vadzim/v/work/nerojs/src/modem.js","modemstub":"/home/vadzim/v/work/nerojs/src/modemstub.js","net":false,"os":false,"path":false,"pingpong":"/home/vadzim/v/work/nerojs/src/pingpong.js","platform":"/home/vadzim/v/work/nerojs/src/platform.js","ra":"/home/vadzim/v/work/nerojs/src/ra.js","repl":false,"rewriter":"/home/vadzim/v/work/nerojs/src/rewriter.js","stream":false,"uid":"/home/vadzim/v/work/nerojs/src/uid.js","url":false,"watchStop":"/home/vadzim/v/work/nerojs/src/watchStop.js","websockets/lib/websockets/socket":"/home/vadzim/v/work/nerojs/node_modules/websockets/lib/websockets/socket.js","yamljs":"/home/vadzim/v/work/nerojs/node_modules/yamljs/lib/Yaml.js"}],"/home/vadzim/v/work/nerojs/src/uid.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/uid.js" ] = total
        }
      }( function () {
        "use strict";
"use strict";
var counter = 0;
module.exports = function uid(obj) {
  var i = (++counter).toString(36);
  var r = parseInt(Math.random().toString().slice(2, 17)).toString(36);
  var id = (r.length + 9).toString(36) + r + i;
  if (obj == null)
    return id;
  else {
    obj.uid = id;
    return obj;
  }
};

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/uid.map

      } )
    }()

},{}],"/home/vadzim/v/work/nerojs/src/watchStop.js":[function(require,module,exports){
!function () {
      !function ( body ) {
        var now = global.performance || Date
        var total = 0
        var start = now.now()
        var oldRequire = require
        var newRequire = function () {
          total += now.now() - start
          require = oldRequire
          try {
            return oldRequire.apply( this, arguments )
          }
          finally {
            require = newRequire
            start = now.now()
          }
        }
        require = newRequire
        try {
          body()
        }
        finally {
          require = oldRequire
          total += now.now() - start
          total /= 1000
          if ( !global.__require_stats__ )
            global.__require_stats__ = {}
          global.__require_stats__[ "/home/vadzim/v/work/nerojs/src/watchStop.js" ] = total
        }
      }( function () {
        "use strict";
"use strict";
require("colors");
var fs = require("fs");
var pn = process.argv[1];
watch(pn);
function watch(fn) {
  fs.watch(fn, function() {
    setTimeout(function() {
      process.stderr.write("\n" + "Aborting process".red + " " + pn.yellow + ". Changed " + fn + "\n");
      process.exit(1);
    }, 300);
  });
  return module.exports;
}
module.exports = watch;

//# sourceMappingURL=/home/vadzim/v/work/nerojs/src/watchStop.map

      } )
    }()

},{"colors":"/home/vadzim/v/work/nerojs/node_modules/colors/lib/index.js","fs":false}]},{},["/home/vadzim/v/work/nerojs/node_modules/traceur/bin/traceur-runtime.js","/home/vadzim/v/work/nerojs/src/server.js"]);
