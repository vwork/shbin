"use strict";
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,Buffer){


var Parser = require('jsonparse')
  , through = require('through')

/*

  the value of this.stack that creationix's jsonparse has is weird.

  it makes this code ugly, but his problem is way harder that mine,
  so i'll forgive him.

*/

exports.parse = function (path, map) {

  var parser = new Parser()
  var stream = through(function (chunk) {
    if('string' === typeof chunk)
      chunk = new Buffer(chunk)
    parser.write(chunk)
  },
  function (data) {
    if(data)
      stream.write(data)
    stream.queue(null)
  })

  if('string' === typeof path)
    path = path.split('.').map(function (e) {
      if (e === '*')
        return true
      else if (e === '') // '..'.split('.') returns an empty string
        return {recurse: true}
      else
        return e
    })


  var count = 0, _key
  if(!path || !path.length)
    path = null

  parser.onValue = function (value) {
    if (!this.root)
      stream.root = value

    if(! path) return

    var i = 0 // iterates on path
    var j  = 0 // iterates on stack
    while (i < path.length) {
      var key = path[i]
      var c
      j++

      if (key && !key.recurse) {
        c = (j === this.stack.length) ? this : this.stack[j]
        if (!c) return
        if (! check(key, c.key)) return
        i++
      } else {
        i++
        var nextKey = path[i]
        if (! nextKey) return
        while (true) {
          c = (j === this.stack.length) ? this : this.stack[j]
          if (!c) return
          if (check(nextKey, c.key)) {
            i++;
            this.stack[j].value = null
            break
          }
          j++
        }
      }

    }
    if (j !== this.stack.length) return

    count ++
    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])
    var data = this.value[this.key]
    if(null != data)
      if(null != (data = map ? map(data, actualPath) : data))
        stream.queue(data)
    delete this.value[this.key]
    for(var k in this.stack)
      this.stack[k].value = null
  }
  parser._onToken = parser.onToken;

  parser.onToken = function (token, value) {
    parser._onToken(token, value);
    if (this.stack.length === 0) {
      if (stream.root) {
        if(!path)
          stream.queue(stream.root)
        count = 0;
        stream.root = null;
      }
    }
  }
  
  parser.onError = function (err) {
    if(err.message.indexOf("at position") > -1)
      err.message = "Invalid JSON (" + err.message + ")";
    stream.emit('error', err)
  }


  return stream
}

function check (x, y) {
  if ('string' === typeof x)
    return y == x
  else if (x && 'function' === typeof x.exec)
    return x.exec(y)
  else if ('boolean' === typeof x)
    return x
  else if ('function' === typeof x)
    return x(y)
  return false
}

exports.stringify = function (op, sep, cl, indent) {
  indent = indent || 0
  if (op === false){
    op = ''
    sep = '\n'
    cl = ''
  } else if (op == null) {

    op = '[\n'
    sep = '\n,\n'
    cl = '\n]\n'

  }

  //else, what ever you like

  var stream
    , first = true
    , anyData = false
  stream = through(function (data) {
    anyData = true
    var json = JSON.stringify(data, null, indent)
    if(first) { first = false ; stream.queue(op + json)}
    else stream.queue(sep + json)
  },
  function (data) {
    if(!anyData)
      stream.queue(op)
    stream.queue(cl)
    stream.queue(null)
  })

  return stream
}

exports.stringifyObject = function (op, sep, cl, indent) {
  indent = indent || 0
  if (op === false){
    op = ''
    sep = '\n'
    cl = ''
  } else if (op == null) {

    op = '{\n'
    sep = '\n,\n'
    cl = '\n}\n'

  }

  //else, what ever you like

  var first = true
    , anyData = false
  stream = through(function (data) {
    anyData = true
    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)
    if(first) { first = false ; this.queue(op + json)}
    else this.queue(sep + json)
  },
  function (data) {
    if(!anyData) this.queue(op)
    this.queue(cl)

    this.queue(null)
  })

  return stream
}

if(!module.parent && process.title !== 'browser') {
  process.stdin
    .pipe(exports.parse(process.argv[2]))
    .pipe(exports.stringify('[', ',\n', ']\n', 2))
    .pipe(process.stdout)
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":192,"buffer":215,"jsonparse":2,"through":3}],2:[function(require,module,exports){
(function (Buffer){
/*global Buffer*/
// Named constants with unique integer values
var C = {};
// Tokens
var LEFT_BRACE    = C.LEFT_BRACE    = 0x1;
var RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;
var LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;
var RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;
var COLON         = C.COLON         = 0x5;
var COMMA         = C.COMMA         = 0x6;
var TRUE          = C.TRUE          = 0x7;
var FALSE         = C.FALSE         = 0x8;
var NULL          = C.NULL          = 0x9;
var STRING        = C.STRING        = 0xa;
var NUMBER        = C.NUMBER        = 0xb;
// Tokenizer States
var START   = C.START   = 0x11;
var STOP    = C.STOP    = 0x12;
var TRUE1   = C.TRUE1   = 0x21;
var TRUE2   = C.TRUE2   = 0x22;
var TRUE3   = C.TRUE3   = 0x23;
var FALSE1  = C.FALSE1  = 0x31;
var FALSE2  = C.FALSE2  = 0x32;
var FALSE3  = C.FALSE3  = 0x33;
var FALSE4  = C.FALSE4  = 0x34;
var NULL1   = C.NULL1   = 0x41;
var NULL2   = C.NULL2   = 0x42;
var NULL3   = C.NULL3   = 0x43;
var NUMBER1 = C.NUMBER1 = 0x51;
var NUMBER2 = C.NUMBER2 = 0x52;
var NUMBER3 = C.NUMBER3 = 0x53;
var NUMBER4 = C.NUMBER4 = 0x54;
var NUMBER5 = C.NUMBER5 = 0x55;
var NUMBER6 = C.NUMBER6 = 0x56;
var NUMBER7 = C.NUMBER7 = 0x57;
var NUMBER8 = C.NUMBER8 = 0x58;
var STRING1 = C.STRING1 = 0x61;
var STRING2 = C.STRING2 = 0x62;
var STRING3 = C.STRING3 = 0x63;
var STRING4 = C.STRING4 = 0x64;
var STRING5 = C.STRING5 = 0x65;
var STRING6 = C.STRING6 = 0x66;
// Parser States
var VALUE   = C.VALUE   = 0x71;
var KEY     = C.KEY     = 0x72;
// Parser Modes
var OBJECT  = C.OBJECT  = 0x81;
var ARRAY   = C.ARRAY   = 0x82;


function Parser() {
  this.tState = START;
  this.value = undefined;

  this.string = undefined; // string data
  this.unicode = undefined; // unicode escapes

  // For number parsing
  this.negative = undefined;
  this.magnatude = undefined;
  this.position = undefined;
  this.exponent = undefined;
  this.negativeExponent = undefined;
  this.numberLength = 0;
  
  this.key = undefined;
  this.mode = undefined;
  this.stack = [];
  this.state = VALUE;
  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary
  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read
  this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) }; // for rebuilding chars split before boundary is reached

  // Stream offset
  this.offset = -1;
}

// Slow code to string converter (only used when throwing syntax errors)
Parser.toknam = function (code) {
  var keys = Object.keys(C);
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    if (C[key] === code) { return key; }
  }
  return code && ("0x" + code.toString(16));
}

var proto = Parser.prototype;
proto.onError = function (err) { throw err; };
proto.charError = function (buffer, i) {
  this.tState = STOP;
  this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
};
proto.write = function (buffer) {
  if (typeof buffer === "string") buffer = new Buffer(buffer);
  var n;
  for (var i = 0, l = buffer.length; i < l; i++) {
    if (this.tState === START){
      n = buffer[i];
      this.offset++;
      if(n === 0x7b){ this.onToken(LEFT_BRACE, "{"); // {
      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, "}"); // }
      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, "["); // [
      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, "]"); // ]
      }else if(n === 0x3a){ this.onToken(COLON, ":");  // :
      }else if(n === 0x2c){ this.onToken(COMMA, ","); // ,
      }else if(n === 0x74){ this.tState = TRUE1;  // t
      }else if(n === 0x66){ this.tState = FALSE1;  // f
      }else if(n === 0x6e){ this.tState = NULL1; // n
      }else if(n === 0x22){ this.string = ""; this.tState = STRING1; // "
      }else if(n === 0x2d){ this.negative = true; this.tState = NUMBER1; // -
      }else if(n === 0x30){ this.magnatude = 0; this.tState = NUMBER2; // 0
      }else{
        if (n > 0x30 && n < 0x40) { // 1-9
          this.magnatude = n - 0x30; this.tState = NUMBER3;
        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {
          // whitespace
        } else {
            return this.charError(buffer, i);
        }
      }
    }else if (this.tState === STRING1){ // After open quote
      n = buffer[i]; // get current byte from buffer
      // check for carry over of a multi byte char split between data chunks
      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration
      if (this.bytes_remaining > 0) {
        for (var j = 0; j < this.bytes_remaining; j++) {
          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
        }
        this.string += this.temp_buffs[this.bytes_in_sequence].toString();
        this.bytes_in_sequence = this.bytes_remaining = 0;
        i = i + j - 1;
      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time
        if (n <= 193) {
          return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
        }
        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;
        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;
        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;
        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split
          for (var k = 0; k <= (buffer.length - 1 - i); k++) {
            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk
          }
          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;
          i = buffer.length - 1;
        } else {
          this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();
          i = i + this.bytes_in_sequence - 1;
        }
      } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.offset += Buffer.byteLength(this.string, 'utf8') + 1; this.string = undefined; }
      else if (n === 0x5c) { this.tState = STRING2; }
      else if (n >= 0x20) { this.string += String.fromCharCode(n); }
      else {
          return this.charError(buffer, i);
      }
    }else if (this.tState === STRING2){ // After backslash
      n = buffer[i];
      if(n === 0x22){ this.string += "\""; this.tState = STRING1;
      }else if(n === 0x5c){ this.string += "\\"; this.tState = STRING1; 
      }else if(n === 0x2f){ this.string += "\/"; this.tState = STRING1; 
      }else if(n === 0x62){ this.string += "\b"; this.tState = STRING1; 
      }else if(n === 0x66){ this.string += "\f"; this.tState = STRING1; 
      }else if(n === 0x6e){ this.string += "\n"; this.tState = STRING1; 
      }else if(n === 0x72){ this.string += "\r"; this.tState = STRING1; 
      }else if(n === 0x74){ this.string += "\t"; this.tState = STRING1; 
      }else if(n === 0x75){ this.unicode = ""; this.tState = STRING3;
      }else{ 
        return this.charError(buffer, i); 
      }
    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes
      n = buffer[i];
      // 0-9 A-F a-f
      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {
        this.unicode += String.fromCharCode(n);
        if (this.tState++ === STRING6) {
          this.string += String.fromCharCode(parseInt(this.unicode, 16));
          this.unicode = undefined;
          this.tState = STRING1; 
        }
      } else {
        return this.charError(buffer, i);
      }
    }else if (this.tState === NUMBER1){ // after minus
      n = buffer[i];
      this.numberLength++;
      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }
      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }
      else {
          return this.charError(buffer, i);
      }
    }else if (this.tState === NUMBER2){ // * After initial zero
      n = buffer[i];
      this.numberLength++;
      if(n === 0x2e){ // .
        this.position = 0.1; this.tState = NUMBER4;
      }else if(n === 0x65 ||  n === 0x45){ // e/E
        this.exponent = 0; this.tState = NUMBER6;
      }else{
        this.tState = START;
        this.onToken(NUMBER, 0);
        this.offset += this.numberLength - 1;
        this.numberLength = 0;
        this.magnatude = undefined;
        this.negative = undefined;
        i--;
      }
    }else if (this.tState === NUMBER3){ // * After digit (before period)
      n = buffer[i];
      this.numberLength++;
      if(n === 0x2e){ // .
        this.position = 0.1; this.tState = NUMBER4;
      }else if(n === 0x65 || n === 0x45){ // e/E
        this.exponent = 0; this.tState = NUMBER6;
      }else{
        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }
        else {
          this.tState = START; 
          if (this.negative) {
            this.magnatude = -this.magnatude;
            this.negative = undefined;
          }
          this.onToken(NUMBER, this.magnatude); 
          this.offset += this.numberLength - 1;
          this.numberLength = 0;
          this.magnatude = undefined;
          i--;
        }
      }
    }else if (this.tState === NUMBER4){ // After period
      n = buffer[i];
      this.numberLength++;
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.magnatude += this.position * (n - 0x30);
        this.position /= 10;
        this.tState = NUMBER5; 
      } else {
          return this.charError(buffer, i);
      }
    }else if (this.tState === NUMBER5){ // * After digit (after period)
      n = buffer[i];
      this.numberLength++;
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.magnatude += this.position * (n - 0x30);
        this.position /= 10;
      }
      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e
      else {
        this.tState = START; 
        if (this.negative) {
          this.magnatude = -this.magnatude;
          this.negative = undefined;
        }
        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude); 
        this.offset += this.numberLength - 1;
        this.numberLength = 0;
        this.magnatude = undefined;
        this.position = undefined;
        i--; 
      }
    }else if (this.tState === NUMBER6){ // After E
      n = buffer[i];
      this.numberLength++;
      if (n === 0x2b || n === 0x2d) { // +/-
        if (n === 0x2d) { this.negativeExponent = true; }
        this.tState = NUMBER7;
      }
      else if (n >= 0x30 && n < 0x40) {
        this.exponent = this.exponent * 10 + (n - 0x30);
        this.tState = NUMBER8;
      }
      else {
          return this.charError(buffer, i);
      }
    }else if (this.tState === NUMBER7){ // After +/-
      n = buffer[i];
      this.numberLength++;
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.exponent = this.exponent * 10 + (n - 0x30);
        this.tState = NUMBER8;
      }
      else {
          return this.charError(buffer, i);
      }
    }else if (this.tState === NUMBER8){ // * After digit (after +/-)
      n = buffer[i];
      this.numberLength++;
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.exponent = this.exponent * 10 + (n - 0x30);
      }
      else {
        if (this.negativeExponent) {
          this.exponent = -this.exponent;
          this.negativeExponent = undefined;
        }
        this.magnatude *= Math.pow(10, this.exponent);
        this.exponent = undefined;
        if (this.negative) { 
          this.magnatude = -this.magnatude;
          this.negative = undefined;
        }
        this.tState = START;
        this.onToken(NUMBER, this.magnatude);
        this.offset += this.numberLength - 1;
        this.numberLength = 0;
        this.magnatude = undefined;
        i--; 
      } 
    }else if (this.tState === TRUE1){ // r
      if (buffer[i] === 0x72) { this.tState = TRUE2; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === TRUE2){ // u
      if (buffer[i] === 0x75) { this.tState = TRUE3; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === TRUE3){ // e
      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); this.offset+= 3; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === FALSE1){ // a
      if (buffer[i] === 0x61) { this.tState = FALSE2; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === FALSE2){ // l
      if (buffer[i] === 0x6c) { this.tState = FALSE3; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === FALSE3){ // s
      if (buffer[i] === 0x73) { this.tState = FALSE4; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === FALSE4){ // e
      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); this.offset+= 4; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === NULL1){ // u
      if (buffer[i] === 0x75) { this.tState = NULL2; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === NULL2){ // l
      if (buffer[i] === 0x6c) { this.tState = NULL3; }
      else { return this.charError(buffer, i); }
    }else if (this.tState === NULL3){ // l
      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); this.offset += 3; }
      else { return this.charError(buffer, i); }
    }
  }
};
proto.onToken = function (token, value) {
  // Override this to get events
};

proto.parseError = function (token, value) {
  this.tState = STOP;
  this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? ("(" + JSON.stringify(value) + ")") : "") + " in state " + Parser.toknam(this.state)));
};
proto.push = function () {
  this.stack.push({value: this.value, key: this.key, mode: this.mode});
};
proto.pop = function () {
  var value = this.value;
  var parent = this.stack.pop();
  this.value = parent.value;
  this.key = parent.key;
  this.mode = parent.mode;
  this.emit(value);
  if (!this.mode) { this.state = VALUE; }
};
proto.emit = function (value) {
  if (this.mode) { this.state = COMMA; }
  this.onValue(value);
};
proto.onValue = function (value) {
  // Override me
};  
proto.onToken = function (token, value) {
  if(this.state === VALUE){
    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){
      if (this.value) {
        this.value[this.key] = value;
      }
      this.emit(value);  
    }else if(token === LEFT_BRACE){
      this.push();
      if (this.value) {
        this.value = this.value[this.key] = {};
      } else {
        this.value = {};
      }
      this.key = undefined;
      this.state = KEY;
      this.mode = OBJECT;
    }else if(token === LEFT_BRACKET){
      this.push();
      if (this.value) {
        this.value = this.value[this.key] = [];
      } else {
        this.value = [];
      }
      this.key = 0;
      this.mode = ARRAY;
      this.state = VALUE;
    }else if(token === RIGHT_BRACE){
      if (this.mode === OBJECT) {
        this.pop();
      } else {
        return this.parseError(token, value);
      }
    }else if(token === RIGHT_BRACKET){
      if (this.mode === ARRAY) {
        this.pop();
      } else {
        return this.parseError(token, value);
      }
    }else{
      return this.parseError(token, value);
    }
  }else if(this.state === KEY){
    if (token === STRING) {
      this.key = value;
      this.state = COLON;
    } else if (token === RIGHT_BRACE) {
      this.pop();
    } else {
      return this.parseError(token, value);
    }
  }else if(this.state === COLON){
    if (token === COLON) { this.state = VALUE; }
    else { return this.parseError(token, value); }
  }else if(this.state === COMMA){
    if (token === COMMA) { 
      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }
      else if (this.mode === OBJECT) { this.state = KEY; }

    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
      this.pop();
    } else {
      return this.parseError(token, value);
    }
  }else{
    return this.parseError(token, value);
  }
};

Parser.C = C;

module.exports = Parser;

}).call(this,require("buffer").Buffer)

},{"buffer":215}],3:[function(require,module,exports){
(function (process){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,require('_process'))

},{"_process":192,"stream":210}],4:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator/runtime");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/shim":183,"regenerator/runtime":184}],5:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],6:[function(require,module,exports){
var isObject = require('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":36}],7:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./$.to-iobject')
  , toLength  = require('./$.to-length')
  , toIndex   = require('./$.to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index;
    } return !IS_INCLUDES && -1;
  };
};
},{"./$.to-index":71,"./$.to-iobject":73,"./$.to-length":74}],8:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./$.ctx')
  , IObject  = require('./$.iobject')
  , toObject = require('./$.to-object')
  , toLength = require('./$.to-length');
module.exports = function(TYPE){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./$.ctx":17,"./$.iobject":33,"./$.to-length":74,"./$.to-object":75}],9:[function(require,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var toObject = require('./$.to-object')
  , IObject  = require('./$.iobject')
  , enumKeys = require('./$.enum-keys');

module.exports = require('./$.fails')(function(){
  return Symbol() in Object.assign({}); // Object.assign available and Symbol is native
}) ? function assign(target, source){   // eslint-disable-line no-unused-vars
  var T = toObject(target)
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = IObject(arguments[i++])
      , keys   = enumKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
} : Object.assign;
},{"./$.enum-keys":21,"./$.fails":23,"./$.iobject":33,"./$.to-object":75}],10:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , TAG = require('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":11,"./$.wks":78}],11:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],12:[function(require,module,exports){
'use strict';
var $            = require('./$')
  , hide         = require('./$.hide')
  , ctx          = require('./$.ctx')
  , species      = require('./$.species')
  , strictNew    = require('./$.strict-new')
  , defined      = require('./$.defined')
  , forOf        = require('./$.for-of')
  , step         = require('./$.iter-step')
  , ID           = require('./$.uid')('id')
  , $has         = require('./$.has')
  , isObject     = require('./$.is-object')
  , isExtensible = Object.isExtensible || isObject
  , SUPPORT_DESC = require('./$.support-desc')
  , SIZE         = SUPPORT_DESC ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments[1], 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(SUPPORT_DESC)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    require('./$.iter-define')(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    species(C);
    species(require('./$.core')[NAME]); // for wrapper
  }
};
},{"./$":43,"./$.core":16,"./$.ctx":17,"./$.defined":19,"./$.for-of":26,"./$.has":29,"./$.hide":30,"./$.is-object":36,"./$.iter-define":39,"./$.iter-step":41,"./$.mix":48,"./$.species":61,"./$.strict-new":62,"./$.support-desc":68,"./$.uid":76}],13:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = require('./$.for-of')
  , classof = require('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":10,"./$.for-of":26}],14:[function(require,module,exports){
'use strict';
var hide         = require('./$.hide')
  , anObject     = require('./$.an-object')
  , strictNew    = require('./$.strict-new')
  , forOf        = require('./$.for-of')
  , method       = require('./$.array-methods')
  , WEAK         = require('./$.uid')('weak')
  , isObject     = require('./$.is-object')
  , $has         = require('./$.has')
  , isExtensible = Object.isExtensible || isObject
  , find         = method(5)
  , findIndex    = method(6)
  , id           = 0;

// fallback for frozen keys
var frozenStore = function(that){
  return that._l || (that._l = new FrozenStore);
};
var FrozenStore = function(){
  this.a = [];
};
var findFrozen = function(store, key){
  return find(store.a, function(it){
    return it[0] === key;
  });
};
FrozenStore.prototype = {
  get: function(key){
    var entry = findFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findFrozen(this, key);
  },
  set: function(key, value){
    var entry = findFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = findIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = id++;      // collection id
      that._l = undefined; // leak store for frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return frozenStore(this)['delete'](key);
        return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return frozenStore(this).has(key);
        return $has(key, WEAK) && $has(key[WEAK], this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    if(!isExtensible(anObject(key))){
      frozenStore(that).set(key, value);
    } else {
      $has(key, WEAK) || hide(key, WEAK, {});
      key[WEAK][that._i] = value;
    } return that;
  },
  frozenStore: frozenStore,
  WEAK: WEAK
};
},{"./$.an-object":6,"./$.array-methods":8,"./$.for-of":26,"./$.has":29,"./$.hide":30,"./$.is-object":36,"./$.mix":48,"./$.strict-new":62,"./$.uid":76}],15:[function(require,module,exports){
'use strict';
var global     = require('./$.global')
  , $def       = require('./$.def')
  , forOf      = require('./$.for-of')
  , strictNew  = require('./$.strict-new');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    require('./$.redef')(proto, KEY,
      KEY == 'delete' ? function(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'has' ? function has(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'get' ? function get(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
      : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !require('./$.fails')(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    require('./$.mix')(C.prototype, methods);
  } else {
    var inst  = new C
      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
      , buggyZero;
    // wrap for init collections from iterable
    if(!require('./$.iter-detect')(function(iter){ new C(iter); })){ // eslint-disable-line no-new
      C = wrapper(function(target, iterable){
        strictNew(target, C, NAME);
        var that = new Base;
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    IS_WEAK || inst.forEach(function(val, key){
      buggyZero = 1 / key === -Infinity;
    });
    // fix converting -0 key to +0
    if(buggyZero){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    // + fix .add & .set for chaining
    if(buggyZero || chain !== inst)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  require('./$.tag')(C, NAME);

  O[NAME] = C;
  $def($def.G + $def.W + $def.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$.def":18,"./$.fails":23,"./$.for-of":26,"./$.global":28,"./$.iter-detect":40,"./$.mix":48,"./$.redef":55,"./$.strict-new":62,"./$.tag":69}],17:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  } return function(/* ...args */){
      return fn.apply(that, arguments);
    };
};
},{"./$.a-function":5}],16:[function(require,module,exports){
var core = module.exports = {};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],18:[function(require,module,exports){
var global     = require('./$.global')
  , core       = require('./$.core')
  , hide       = require('./$.hide')
  , $redef     = require('./$.redef')
  , PROTOTYPE  = 'prototype';
var ctx = function(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
};
var $def = function(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , isProto  = type & $def.P
    , target   = isGlobal ? global : type & $def.S
        ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    if(type & $def.B && own)exp = ctx(out, global);
    else exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target && !own)$redef(target, key, out);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(isProto)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
global.core = core;
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
module.exports = $def;
},{"./$.core":16,"./$.global":28,"./$.hide":30,"./$.redef":55}],19:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],21:[function(require,module,exports){
// all enumerable object keys, includes symbols
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":43}],22:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
module.exports = Math.expm1 || function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
};
},{}],23:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],24:[function(require,module,exports){
'use strict';
module.exports = function(KEY, length, exec){
  var defined  = require('./$.defined')
    , SYMBOL   = require('./$.wks')(KEY)
    , original = ''[KEY];
  if(require('./$.fails')(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    require('./$.redef')(String.prototype, KEY, exec(defined, SYMBOL, original));
    require('./$.hide')(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return original.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return original.call(string, this); }
    );
  }
};
},{"./$.defined":19,"./$.fails":23,"./$.hide":30,"./$.redef":55,"./$.wks":78}],20:[function(require,module,exports){
var isObject = require('./$.is-object')
  , document = require('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":28,"./$.is-object":36}],25:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./$.an-object');
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)result += 'g';
  if(that.ignoreCase)result += 'i';
  if(that.multiline)result += 'm';
  if(that.unicode)result += 'u';
  if(that.sticky)result += 'y';
  return result;
};
},{"./$.an-object":6}],26:[function(require,module,exports){
var ctx         = require('./$.ctx')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , anObject    = require('./$.an-object')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":6,"./$.ctx":17,"./$.is-array-iter":34,"./$.iter-call":37,"./$.to-length":74,"./core.get-iterator-method":79}],27:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toString  = {}.toString
  , toIObject = require('./$.to-iobject')
  , getNames  = require('./$').getNames;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":43,"./$.to-iobject":73}],29:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],30:[function(require,module,exports){
var $          = require('./$')
  , createDesc = require('./$.property-desc');
module.exports = require('./$.support-desc') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":43,"./$.property-desc":54,"./$.support-desc":68}],31:[function(require,module,exports){
module.exports = require('./$.global').document && document.documentElement;
},{"./$.global":28}],32:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],33:[function(require,module,exports){
// indexed object, fallback for non-array-like ES3 strings
var cof = require('./$.cof');
module.exports = 0 in Object('z') ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":11}],34:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./$.iterators')
  , ITERATOR  = require('./$.wks')('iterator');
module.exports = function(it){
  return (Iterators.Array || Array.prototype[ITERATOR]) === it;
};
},{"./$.iterators":42,"./$.wks":78}],35:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./$.is-object')
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};
},{"./$.is-object":36}],36:[function(require,module,exports){
// http://jsperf.com/core-js-isobject
module.exports = function(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
};
},{}],37:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":6}],38:[function(require,module,exports){
'use strict';
var $ = require('./$')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: require('./$.property-desc')(1,next)});
  require('./$.tag')(Constructor, NAME + ' Iterator');
};
},{"./$":43,"./$.hide":30,"./$.property-desc":54,"./$.tag":69,"./$.wks":78}],39:[function(require,module,exports){
'use strict';
var LIBRARY         = require('./$.library')
  , $def            = require('./$.def')
  , $redef          = require('./$.redef')
  , hide            = require('./$.hide')
  , has             = require('./$.has')
  , SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , Iterators       = require('./$.iterators')
  , BUGGY           = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR     = '@@iterator'
  , KEYS            = 'keys'
  , VALUES          = 'values';
var returnThis = function(){ return this; };
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
  require('./$.iter-create')(Constructor, NAME, next);
  var createMethod = function(kind){
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG      = NAME + ' Iterator'
    , proto    = Base.prototype
    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , _default = _native || createMethod(DEFAULT)
    , methods, key;
  // Fix native
  if(_native){
    var IteratorPrototype = require('./$').getProto(_default.call(new Base));
    // Set @@toStringTag to native iterators
    require('./$.tag')(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
  }
  // Define iterator
  if(!LIBRARY || FORCE)hide(proto, SYMBOL_ITERATOR, _default);
  // Plug for library
  Iterators[NAME] = _default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      keys:    IS_SET            ? _default : createMethod(KEYS),
      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
      entries: DEFAULT != VALUES ? _default : createMethod('entries')
    };
    if(FORCE)for(key in methods){
      if(!(key in proto))$redef(proto, key, methods[key]);
    } else $def($def.P + $def.F * BUGGY, NAME, methods);
  }
};
},{"./$":43,"./$.def":18,"./$.has":29,"./$.hide":30,"./$.iter-create":38,"./$.iterators":42,"./$.library":45,"./$.redef":55,"./$.tag":69,"./$.wks":78}],28:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var UNDEFINED = 'undefined';
var global = module.exports = typeof window != UNDEFINED && window.Math == Math
  ? window : typeof self != UNDEFINED && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],40:[function(require,module,exports){
var SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , SAFE_CLOSING    = false;
try {
  var riter = [7][SYMBOL_ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }
module.exports = function(exec){
  if(!SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[SYMBOL_ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[SYMBOL_ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":78}],42:[function(require,module,exports){
module.exports = {};
},{}],43:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],41:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],45:[function(require,module,exports){
module.exports = false;
},{}],46:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};
},{}],47:[function(require,module,exports){
var global    = require('./$.global')
  , macrotask = require('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , isNode    = require('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    if(domain)domain.enter();
    head.fn.call(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
}

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":11,"./$.global":28,"./$.task":70}],48:[function(require,module,exports){
var $redef = require('./$.redef');
module.exports = function(target, src){
  for(var key in src)$redef(target, key, src[key]);
  return target;
};
},{"./$.redef":55}],49:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
module.exports = function(KEY, exec){
  var $def = require('./$.def')
    , fn   = (require('./$.core').Object || {})[KEY] || Object[KEY]
    , exp  = {};
  exp[KEY] = exec(fn);
  $def($def.S + $def.F * require('./$.fails')(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":16,"./$.def":18,"./$.fails":23}],44:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":43,"./$.to-iobject":73}],50:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject');
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = Array(length)
      , key;
    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
    else while(length > i)result[i] = O[keys[i++]];
    return result;
  };
};
},{"./$":43,"./$.to-iobject":73}],51:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var $        = require('./$')
  , anObject = require('./$.an-object')
  , Reflect  = require('./$.global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = $.getNames(anObject(it))
    , getSymbols = $.getSymbols;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
},{"./$":43,"./$.an-object":6,"./$.global":28}],53:[function(require,module,exports){
module.exports = require('./$.global');
},{"./$.global":28}],54:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],55:[function(require,module,exports){
// add fake Function#toString
// for correct work wrapped methods / constructors with methods like LoDash isNative
var global    = require('./$.global')
  , hide      = require('./$.hide')
  , SRC       = require('./$.uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./$.core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  if(typeof val == 'function'){
    hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if(!('name' in val))val.name = key;
  }
  if(O === global){
    O[key] = val;
  } else {
    if(!safe)delete O[key];
    hide(O, key, val);
  }
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./$.core":16,"./$.global":28,"./$.hide":30,"./$.uid":76}],52:[function(require,module,exports){
'use strict';
var path      = require('./$.path')
  , invoke    = require('./$.invoke')
  , aFunction = require('./$.a-function');
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !_length)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(_length > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
},{"./$.a-function":5,"./$.invoke":32,"./$.path":53}],56:[function(require,module,exports){
module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};
},{}],58:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = require('./$').getDesc
  , isObject = require('./$.is-object')
  , anObject = require('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line
    ? function(buggy, set){
        try {
          set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
          set({}, []);
        } catch(e){ buggy = true; }
        return function setPrototypeOf(O, proto){
          check(O, proto);
          if(buggy)O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }()
    : undefined),
  check: check
};
},{"./$":43,"./$.an-object":6,"./$.ctx":17,"./$.is-object":36}],57:[function(require,module,exports){
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],59:[function(require,module,exports){
var global = require('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":28}],61:[function(require,module,exports){
'use strict';
var $       = require('./$')
  , SPECIES = require('./$.wks')('species');
module.exports = function(C){
  if(require('./$.support-desc') && !(SPECIES in C))$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":43,"./$.support-desc":68,"./$.wks":78}],62:[function(require,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],63:[function(require,module,exports){
// true  -> String#at
// false -> String#codePointAt
var toInteger = require('./$.to-integer')
  , defined   = require('./$.defined');
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l
      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":19,"./$.to-integer":72}],60:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],64:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var defined = require('./$.defined')
  , cof     = require('./$.cof');

module.exports = function(that, searchString, NAME){
  if(cof(searchString) == 'RegExp')throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
},{"./$.cof":11,"./$.defined":19}],65:[function(require,module,exports){
// https://github.com/ljharb/proposal-string-pad-left-right
var toLength = require('./$.to-length')
  , repeat   = require('./$.string-repeat')
  , defined  = require('./$.defined');

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength)return S;
  if(fillStr == '')fillStr = ' ';
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = left
    ? stringFiller.slice(stringFiller.length - fillLen)
    : stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};
},{"./$.defined":19,"./$.string-repeat":66,"./$.to-length":74}],66:[function(require,module,exports){
'use strict';
var toInteger = require('./$.to-integer')
  , defined   = require('./$.defined');

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
},{"./$.defined":19,"./$.to-integer":72}],67:[function(require,module,exports){
// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

var $def    = require('./$.def')
  , defined = require('./$.defined')
  , spaces  = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
      '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

module.exports = function(KEY, exec){
  var exp  = {};
  exp[KEY] = exec(trim);
  $def($def.P + $def.F * require('./$.fails')(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  }), 'String', exp);
};
},{"./$.def":18,"./$.defined":19,"./$.fails":23}],68:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":23}],69:[function(require,module,exports){
var has  = require('./$.has')
  , hide = require('./$.hide')
  , TAG  = require('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))hide(it, TAG, tag);
};
},{"./$.has":29,"./$.hide":30,"./$.wks":78}],71:[function(require,module,exports){
var toInteger = require('./$.to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./$.to-integer":72}],70:[function(require,module,exports){
'use strict';
var ctx                = require('./$.ctx')
  , invoke             = require('./$.invoke')
  , html               = require('./$.html')
  , cel                = require('./$.dom-create')
  , global             = require('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScript){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":11,"./$.ctx":17,"./$.dom-create":20,"./$.global":28,"./$.html":31,"./$.invoke":32}],72:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],74:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":72}],75:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":19}],73:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./$.iobject')
  , defined = require('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":19,"./$.iobject":33}],76:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],77:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./$.wks')('unscopables');
if(!(UNSCOPABLES in []))require('./$.hide')(Array.prototype, UNSCOPABLES, {});
module.exports = function(key){
  [][UNSCOPABLES][key] = true;
};
},{"./$.hide":30,"./$.wks":78}],78:[function(require,module,exports){
var store  = require('./$.shared')('wks')
  , Symbol = require('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || require('./$.uid'))('Symbol.' + name));
};
},{"./$.global":28,"./$.shared":59,"./$.uid":76}],79:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};
},{"./$.classof":10,"./$.core":16,"./$.iterators":42,"./$.wks":78}],81:[function(require,module,exports){
'use strict';
var $def     = require('./$.def')
  , toObject = require('./$.to-object')
  , toIndex  = require('./$.to-index')
  , toLength = require('./$.to-length');
$def($def.P, 'Array', {
  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
  copyWithin: function copyWithin(target/* = 0 */, start /* = 0, end = @length */){
    var O     = toObject(this)
      , len   = toLength(O.length)
      , to    = toIndex(target, len)
      , from  = toIndex(start, len)
      , end   = arguments[2]
      , fin   = end === undefined ? len : toIndex(end, len)
      , count = Math.min(fin - from, len - to)
      , inc   = 1;
    if(from < to && to < from + count){
      inc  = -1;
      from = from + count - 1;
      to   = to   + count - 1;
    }
    while(count-- > 0){
      if(from in O)O[to] = O[from];
      else delete O[to];
      to   += inc;
      from += inc;
    } return O;
  }
});
require('./$.unscope')('copyWithin');
},{"./$.def":18,"./$.to-index":71,"./$.to-length":74,"./$.to-object":75,"./$.unscope":77}],80:[function(require,module,exports){
'use strict';
var $                = require('./$')
  , SUPPORT_DESC     = require('./$.support-desc')
  , createDesc       = require('./$.property-desc')
  , html             = require('./$.html')
  , cel              = require('./$.dom-create')
  , has              = require('./$.has')
  , cof              = require('./$.cof')
  , $def             = require('./$.def')
  , invoke           = require('./$.invoke')
  , arrayMethod      = require('./$.array-methods')
  , IE_PROTO         = require('./$.uid')('__proto__')
  , isObject         = require('./$.is-object')
  , anObject         = require('./$.an-object')
  , aFunction        = require('./$.a-function')
  , toObject         = require('./$.to-object')
  , toIObject        = require('./$.to-iobject')
  , toInteger        = require('./$.to-integer')
  , toIndex          = require('./$.to-index')
  , toLength         = require('./$.to-length')
  , IObject          = require('./$.iobject')
  , fails            = require('./$.fails')
  , ObjectProto      = Object.prototype
  , A                = []
  , _slice           = A.slice
  , _join            = A.join
  , defineProperty   = $.setDesc
  , getOwnDescriptor = $.getDesc
  , defineProperties = $.setDescs
  , $indexOf         = require('./$.array-includes')(false)
  , factories        = {}
  , IE8_DOM_DEFINE;

if(!SUPPORT_DESC){
  IE8_DOM_DEFINE = !fails(function(){
    return defineProperty(cel('div'), 'a', {get: function(){ return 7; }}).a != 7;
  });
  $.setDesc = function(O, P, Attributes){
    if(IE8_DOM_DEFINE)try {
      return defineProperty(O, P, Attributes);
    } catch(e){ /* empty */ }
    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
    if('value' in Attributes)anObject(O)[P] = Attributes.value;
    return O;
  };
  $.getDesc = function(O, P){
    if(IE8_DOM_DEFINE)try {
      return getOwnDescriptor(O, P);
    } catch(e){ /* empty */ }
    if(has(O, P))return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
  };
  $.setDescs = defineProperties = function(O, Properties){
    anObject(O);
    var keys   = $.getKeys(Properties)
      , length = keys.length
      , i = 0
      , P;
    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
    return O;
  };
}
$def($def.S + $def.F * !SUPPORT_DESC, 'Object', {
  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $.getDesc,
  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  defineProperty: $.setDesc,
  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
  defineProperties: defineProperties
});

  // IE 8- don't enum bug keys
var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
            'toLocaleString,toString,valueOf').split(',')
  // Additional keys for getOwnPropertyNames
  , keys2 = keys1.concat('length', 'prototype')
  , keysLen1 = keys1.length;

// Create object with `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = cel('iframe')
    , i      = keysLen1
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write('<script>document.F=Object</script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict.prototype[keys1[i]];
  return createDict();
};
var createGetKeys = function(names, length){
  return function(object){
    var O      = toIObject(object)
      , i      = 0
      , result = []
      , key;
    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(length > i)if(has(O, key = names[i++])){
      ~$indexOf(result, key) || result.push(key);
    }
    return result;
  };
};
var Empty = function(){};
$def($def.S, 'Object', {
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  getPrototypeOf: $.getProto = $.getProto || function(O){
    O = toObject(O);
    if(has(O, IE_PROTO))return O[IE_PROTO];
    if(typeof O.constructor == 'function' && O instanceof O.constructor){
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  },
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  create: $.create = $.create || function(O, /*?*/Properties){
    var result;
    if(O !== null){
      Empty.prototype = anObject(O);
      result = new Empty();
      Empty.prototype = null;
      // add "__proto__" for Object.getPrototypeOf shim
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : defineProperties(result, Properties);
  },
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
});

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }
  return factories[len](F, args);
};

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
$def($def.P, 'Function', {
  bind: function bind(that /*, args... */){
    var fn       = aFunction(this)
      , partArgs = _slice.call(arguments, 1);
    var bound = function(/* args... */){
      var args = partArgs.concat(_slice.call(arguments));
      return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
    };
    if(isObject(fn.prototype))bound.prototype = fn.prototype;
    return bound;
  }
});

// fallback for not array-like ES3 strings and DOM objects
var buggySlice = fails(function(){
  if(html)_slice.call(html);
});

$def($def.P + $def.F * buggySlice, 'Array', {
  slice: function(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return _slice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});
$def($def.P + $def.F * (IObject != Object), 'Array', {
  join: function(){
    return _join.apply(IObject(this), arguments);
  }
});

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
$def($def.S, 'Array', {isArray: function(arg){ return cof(arg) == 'Array'; }});

var createArrayReduce = function(isRight){
  return function(callbackfn, memo){
    aFunction(callbackfn);
    var O      = IObject(this)
      , length = toLength(O.length)
      , index  = isRight ? length - 1 : 0
      , i      = isRight ? -1 : 1;
    if(arguments.length < 2)for(;;){
      if(index in O){
        memo = O[index];
        index += i;
        break;
      }
      index += i;
      if(isRight ? index < 0 : length <= index){
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
      memo = callbackfn(memo, O[index], index, this);
    }
    return memo;
  };
};
var methodize = function($fn){
  return function(arg1/*, arg2 = undefined */){
    return $fn(this, arg1, arguments[1]);
  };
};
$def($def.P, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: $.each = $.each || methodize(arrayMethod(0)),
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: methodize(arrayMethod(1)),
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: methodize(arrayMethod(2)),
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: methodize(arrayMethod(3)),
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: methodize(arrayMethod(4)),
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: createArrayReduce(false),
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: createArrayReduce(true),
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: methodize($indexOf),
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(fromIndex));
    if(index < 0)index = toLength(length + index);
    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
    return -1;
  }
});

// 20.3.3.1 / 15.9.4.4 Date.now()
$def($def.S, 'Date', {now: function(){ return +new Date; }});

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
// PhantomJS and old webkit had a broken Date implementation.
var date       = new Date(-5e13 - 1)
  , brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z'
      && fails(function(){ new Date(NaN).toISOString(); }));
$def($def.P + $def.F * brokenDate, 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(this))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});
},{"./$":43,"./$.a-function":5,"./$.an-object":6,"./$.array-includes":7,"./$.array-methods":8,"./$.cof":11,"./$.def":18,"./$.dom-create":20,"./$.fails":23,"./$.has":29,"./$.html":31,"./$.invoke":32,"./$.iobject":33,"./$.is-object":36,"./$.property-desc":54,"./$.support-desc":68,"./$.to-index":71,"./$.to-integer":72,"./$.to-iobject":73,"./$.to-length":74,"./$.to-object":75,"./$.uid":76}],82:[function(require,module,exports){
'use strict';
var $def     = require('./$.def')
  , toObject = require('./$.to-object')
  , toIndex  = require('./$.to-index')
  , toLength = require('./$.to-length');
$def($def.P, 'Array', {
  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
  fill: function fill(value /*, start = 0, end = @length */){
    var O      = toObject(this, true)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length)
      , end    = arguments[2]
      , endPos = end === undefined ? length : toIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
  }
});
require('./$.unscope')('fill');
},{"./$.def":18,"./$.to-index":71,"./$.to-length":74,"./$.to-object":75,"./$.unscope":77}],83:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var KEY    = 'findIndex'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(6);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
},{"./$.array-methods":8,"./$.def":18,"./$.unscope":77}],85:[function(require,module,exports){
'use strict';
var ctx         = require('./$.ctx')
  , $def        = require('./$.def')
  , toObject    = require('./$.to-object')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
$def($def.S + $def.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , mapfn   = arguments[1]
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, arguments[2], 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
      }
    } else {
      for(result = new C(length = toLength(O.length)); length > index; index++){
        result[index] = mapping ? mapfn(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});
},{"./$.ctx":17,"./$.def":18,"./$.is-array-iter":34,"./$.iter-call":37,"./$.iter-detect":40,"./$.to-length":74,"./$.to-object":75,"./core.get-iterator-method":79}],84:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var KEY    = 'find'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(5);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
},{"./$.array-methods":8,"./$.def":18,"./$.unscope":77}],86:[function(require,module,exports){
'use strict';
var setUnscope = require('./$.unscope')
  , step       = require('./$.iter-step')
  , Iterators  = require('./$.iterators')
  , toIObject  = require('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

setUnscope('keys');
setUnscope('values');
setUnscope('entries');
},{"./$.iter-define":39,"./$.iter-step":41,"./$.iterators":42,"./$.to-iobject":73,"./$.unscope":77}],87:[function(require,module,exports){
'use strict';
var $def = require('./$.def');

// WebKit Array.of isn't generic
$def($def.S + $def.F * require('./$.fails')(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , length = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(length);
    while(length > index)result[index] = arguments[index++];
    result.length = length;
    return result;
  }
});
},{"./$.def":18,"./$.fails":23}],89:[function(require,module,exports){
'use strict';
var $             = require('./$')
  , isObject      = require('./$.is-object')
  , HAS_INSTANCE  = require('./$.wks')('hasInstance')
  , FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = $.getProto(O))if(this.prototype === O)return true;
  return false;
}});
},{"./$":43,"./$.is-object":36,"./$.wks":78}],88:[function(require,module,exports){
require('./$.species')(Array);
},{"./$.species":61}],91:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments[0]); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":15,"./$.collection-strong":12}],92:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $def   = require('./$.def')
  , log1p  = require('./$.log1p')
  , sqrt   = Math.sqrt
  , $acosh = Math.acosh;

// V8 bug https://code.google.com/p/v8/issues/detail?id=3509 
$def($def.S + $def.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});
},{"./$.def":18,"./$.log1p":46}],93:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $def = require('./$.def');

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

$def($def.S, 'Math', {asinh: asinh});
},{"./$.def":18}],94:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $def = require('./$.def');

$def($def.S, 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});
},{"./$.def":18}],95:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $def = require('./$.def')
  , sign = require('./$.sign');

$def($def.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});
},{"./$.def":18,"./$.sign":60}],96:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $def = require('./$.def');

$def($def.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});
},{"./$.def":18}],97:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $def = require('./$.def')
  , exp  = Math.exp;

$def($def.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});
},{"./$.def":18}],98:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $def = require('./$.def');

$def($def.S, 'Math', {expm1: require('./$.expm1')});
},{"./$.def":18,"./$.expm1":22}],99:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $def  = require('./$.def')
  , sign  = require('./$.sign')
  , pow   = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$def($def.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});
},{"./$.def":18,"./$.sign":60}],100:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $def = require('./$.def')
  , abs  = Math.abs;

$def($def.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , len  = arguments.length
      , larg = 0
      , arg, div;
    while(i < len){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});
},{"./$.def":18}],101:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $def = require('./$.def');

// WebKit fails with big numbers
$def($def.S + $def.F * require('./$.fails')(function(){
  return Math.imul(0xffffffff, 5) != -5;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
},{"./$.def":18,"./$.fails":23}],102:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $def = require('./$.def');

$def($def.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});
},{"./$.def":18}],103:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $def = require('./$.def');

$def($def.S, 'Math', {log1p: require('./$.log1p')});
},{"./$.def":18,"./$.log1p":46}],104:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $def = require('./$.def');

$def($def.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});
},{"./$.def":18}],105:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $def = require('./$.def');

$def($def.S, 'Math', {sign: require('./$.sign')});
},{"./$.def":18,"./$.sign":60}],106:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $def  = require('./$.def')
  , expm1 = require('./$.expm1')
  , exp   = Math.exp;

$def($def.S, 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});
},{"./$.def":18,"./$.expm1":22}],107:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $def  = require('./$.def')
  , expm1 = require('./$.expm1')
  , exp   = Math.exp;

$def($def.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});
},{"./$.def":18,"./$.expm1":22}],108:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $def = require('./$.def');

$def($def.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
},{"./$.def":18}],109:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , global     = require('./$.global')
  , has        = require('./$.has')
  , cof        = require('./$.cof')
  , isObject   = require('./$.is-object')
  , fails      = require('./$.fails')
  , NUMBER     = 'Number'
  , $Number    = global[NUMBER]
  , Base       = $Number
  , proto      = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF = cof($.create(proto)) == NUMBER;
var toPrimitive = function(it){
  var fn, val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to number");
};
var toNumber = function(it){
  if(isObject(it))it = toPrimitive(it);
  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
    var binary = false;
    switch(it.charCodeAt(1)){
      case 66 : case 98  : binary = true;
      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
    }
  } return +it;
};
if(!($Number('0o1') && $Number('0b1'))){
  $Number = function Number(it){
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? new Base(toNumber(it)) : toNumber(it);
  };
  $.each.call(require('./$.support-desc') ? $.getNames(Base) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES6 (in case, if modules with ES6 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
    ).split(','), function(key){
      if(has(Base, key) && !has($Number, key)){
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    }
  );
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./$.redef')(global, NUMBER, $Number);
}
},{"./$":43,"./$.cof":11,"./$.fails":23,"./$.global":28,"./$.has":29,"./$.is-object":36,"./$.redef":55,"./$.support-desc":68}],110:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $def = require('./$.def');

$def($def.S, 'Number', {EPSILON: Math.pow(2, -52)});
},{"./$.def":18}],111:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $def      = require('./$.def')
  , _isFinite = require('./$.global').isFinite;

$def($def.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});
},{"./$.def":18,"./$.global":28}],112:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $def = require('./$.def');

$def($def.S, 'Number', {isInteger: require('./$.is-integer')});
},{"./$.def":18,"./$.is-integer":35}],113:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $def = require('./$.def');

$def($def.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});
},{"./$.def":18}],114:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $def      = require('./$.def')
  , isInteger = require('./$.is-integer')
  , abs       = Math.abs;

$def($def.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});
},{"./$.def":18,"./$.is-integer":35}],115:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $def = require('./$.def');

$def($def.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
},{"./$.def":18}],116:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $def = require('./$.def');

$def($def.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
},{"./$.def":18}],117:[function(require,module,exports){
// 20.1.2.12 Number.parseFloat(string)
var $def = require('./$.def');

$def($def.S, 'Number', {parseFloat: parseFloat});
},{"./$.def":18}],90:[function(require,module,exports){
var setDesc    = require('./$').setDesc
  , createDesc = require('./$.property-desc')
  , has        = require('./$.has')
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';
// 19.2.4.2 name
NAME in FProto || require('./$.support-desc') && setDesc(FProto, NAME, {
  configurable: true,
  get: function(){
    var match = ('' + this).match(nameRE)
      , name  = match ? match[1] : '';
    has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
    return name;
  }
});
},{"./$":43,"./$.has":29,"./$.property-desc":54,"./$.support-desc":68}],119:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');

$def($def.S + $def.F, 'Object', {assign: require('./$.assign')});
},{"./$.assign":9,"./$.def":18}],118:[function(require,module,exports){
// 20.1.2.13 Number.parseInt(string, radix)
var $def = require('./$.def');

$def($def.S, 'Number', {parseInt: parseInt});
},{"./$.def":18}],121:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./$.to-iobject');

require('./$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./$.object-sap":49,"./$.to-iobject":73}],120:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(it) : it;
  };
});
},{"./$.is-object":36,"./$.object-sap":49}],123:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('getPrototypeOf', function($getPrototypeOf){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./$.object-sap":49,"./$.to-object":75}],124:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});
},{"./$.is-object":36,"./$.object-sap":49}],125:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});
},{"./$.is-object":36,"./$.object-sap":49}],126:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});
},{"./$.is-object":36,"./$.object-sap":49}],122:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./$.object-sap')('getOwnPropertyNames', function(){
  return require('./$.get-names').get;
});
},{"./$.get-names":27,"./$.object-sap":49}],128:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":49,"./$.to-object":75}],127:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $def = require('./$.def');
$def($def.S, 'Object', {
  is: require('./$.same')
});
},{"./$.def":18,"./$.same":57}],130:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(it) : it;
  };
});
},{"./$.is-object":36,"./$.object-sap":49}],131:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $def = require('./$.def');
$def($def.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.def":18,"./$.set-proto":58}],132:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./$.classof')
  , test    = {};
test[require('./$.wks')('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  require('./$.redef')(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}
},{"./$.classof":10,"./$.redef":55,"./$.wks":78}],133:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , LIBRARY    = require('./$.library')
  , global     = require('./$.global')
  , ctx        = require('./$.ctx')
  , classof    = require('./$.classof')
  , $def       = require('./$.def')
  , isObject   = require('./$.is-object')
  , anObject   = require('./$.an-object')
  , aFunction  = require('./$.a-function')
  , strictNew  = require('./$.strict-new')
  , forOf      = require('./$.for-of')
  , setProto   = require('./$.set-proto').set
  , same       = require('./$.same')
  , species    = require('./$.species')
  , SPECIES    = require('./$.wks')('species')
  , RECORD     = require('./$.uid')('record')
  , asap       = require('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var useNative = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && require('./$.support-desc')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var isPromise = function(it){
  return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
};
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(react){
      var cb = ok ? react.ok : react.fail
        , ret, then;
      try {
        if(cb){
          if(!ok)record.h = true;
          ret = cb === true ? value : cb(value);
          if(ret === react.P){
            react.rej(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(ret)){
            then.call(ret, react.res, react.rej);
          } else react.res(ret);
        } else react.rej(value);
      } catch(err){
        react.rej(err);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      if(isUnhandled(record.p)){
        if(isNode){
          process.emit('unhandledRejection', value, record.p);
        } else if(global.console && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise[RECORD]
    , chain  = record.a || record.c
    , i      = 0
    , react;
  if(record.h)return false;
  while(chain.length > i){
    react = chain[i++];
    if(react.fail || !isUnhandled(react.P))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!useNative){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    this[RECORD] = record;
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.mix')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var S = anObject(anObject(this).constructor)[SPECIES];
      var react = {
        ok:   typeof onFulfilled == 'function' ? onFulfilled : true,
        fail: typeof onRejected == 'function'  ? onRejected  : false
      };
      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
        react.res = aFunction(res);
        react.rej = aFunction(rej);
      });
      var record = this[RECORD];
      record.c.push(react);
      if(record.a)record.a.push(react);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

// export
$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
require('./$.tag')(P, PROMISE);
species(P);
species(Wrapper = require('./$.core')[PROMISE]);

// statics
$def($def.S + $def.F * !useNative, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    return new this(function(res, rej){ rej(r); });
  }
});
$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    return isPromise(x) && sameConstructor(x.constructor, this)
      ? x : new this(function(res){ res(x); });
  }
});
$def($def.S + $def.F * !(useNative && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C      = getConstructor(this)
      , values = [];
    return new C(function(res, rej){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        C.resolve(promise).then(function(value){
          results[index] = value;
          --remaining || res(results);
        }, rej);
      });
      else res(results);
    });
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C = getConstructor(this);
    return new C(function(res, rej){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(res, rej);
      });
    });
  }
});
},{"./$":43,"./$.a-function":5,"./$.an-object":6,"./$.classof":10,"./$.core":16,"./$.ctx":17,"./$.def":18,"./$.for-of":26,"./$.global":28,"./$.is-object":36,"./$.iter-detect":40,"./$.library":45,"./$.microtask":47,"./$.mix":48,"./$.same":57,"./$.set-proto":58,"./$.species":61,"./$.strict-new":62,"./$.support-desc":68,"./$.tag":69,"./$.uid":76,"./$.wks":78}],129:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
  };
});
},{"./$.is-object":36,"./$.object-sap":49}],134:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $def   = require('./$.def')
  , _apply = Function.apply;

$def($def.S, 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    return _apply.call(target, thisArgument, argumentsList);
  }
});
},{"./$.def":18}],136:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var $        = require('./$')
  , $def     = require('./$.def')
  , anObject = require('./$.an-object');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$def($def.S + $def.F * require('./$.fails')(function(){
  Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    try {
      $.setDesc(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./$":43,"./$.an-object":6,"./$.def":18,"./$.fails":23}],137:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $def     = require('./$.def')
  , getDesc  = require('./$').getDesc
  , anObject = require('./$.an-object');

$def($def.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = getDesc(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});
},{"./$":43,"./$.an-object":6,"./$.def":18}],135:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $         = require('./$')
  , $def      = require('./$.def')
  , aFunction = require('./$.a-function')
  , anObject  = require('./$.an-object')
  , isObject  = require('./$.is-object')
  , bind      = Function.bind || require('./$.core').Function.prototype.bind;

// MS Edge supports only 2 arguments
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
$def($def.S + $def.F * require('./$.fails')(function(){
  function F(){}
  return !(Reflect.construct(function(){}, [], F) instanceof F);
}), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      if(args != undefined)switch(anObject(args).length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = $.create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});
},{"./$":43,"./$.a-function":5,"./$.an-object":6,"./$.core":16,"./$.def":18,"./$.fails":23,"./$.is-object":36}],138:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $def     = require('./$.def')
  , anObject = require('./$.an-object');
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
require('./$.iter-create')(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$def($def.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});
},{"./$.an-object":6,"./$.def":18,"./$.iter-create":38}],139:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var $        = require('./$')
  , $def     = require('./$.def')
  , anObject = require('./$.an-object');

$def($def.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return $.getDesc(anObject(target), propertyKey);
  }
});
},{"./$":43,"./$.an-object":6,"./$.def":18}],140:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $def     = require('./$.def')
  , getProto = require('./$').getProto
  , anObject = require('./$.an-object');

$def($def.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});
},{"./$":43,"./$.an-object":6,"./$.def":18}],141:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var $        = require('./$')
  , has      = require('./$.has')
  , $def     = require('./$.def')
  , isObject = require('./$.is-object')
  , anObject = require('./$.an-object');

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = $.getDesc(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = $.getProto(target)))return get(proto, propertyKey, receiver);
}

$def($def.S, 'Reflect', {get: get});
},{"./$":43,"./$.an-object":6,"./$.def":18,"./$.has":29,"./$.is-object":36}],142:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $def = require('./$.def');

$def($def.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});
},{"./$.def":18}],143:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $def          = require('./$.def')
  , anObject      = require('./$.an-object')
  , $isExtensible = Object.isExtensible;

$def($def.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});
},{"./$.an-object":6,"./$.def":18}],144:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $def = require('./$.def');

$def($def.S, 'Reflect', {ownKeys: require('./$.own-keys')});
},{"./$.def":18,"./$.own-keys":51}],146:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $def     = require('./$.def')
  , setProto = require('./$.set-proto');

if(setProto)$def($def.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./$.def":18,"./$.set-proto":58}],145:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $def               = require('./$.def')
  , anObject           = require('./$.an-object')
  , $preventExtensions = Object.preventExtensions;

$def($def.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./$.an-object":6,"./$.def":18}],147:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var $          = require('./$')
  , has        = require('./$.has')
  , $def       = require('./$.def')
  , createDesc = require('./$.property-desc')
  , anObject   = require('./$.an-object')
  , isObject   = require('./$.is-object');

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = $.getDesc(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = $.getProto(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    $.setDesc(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$def($def.S, 'Reflect', {set: set});
},{"./$":43,"./$.an-object":6,"./$.def":18,"./$.has":29,"./$.is-object":36,"./$.property-desc":54}],148:[function(require,module,exports){
var $       = require('./$')
  , global  = require('./$.global')
  , cof     = require('./$.cof')
  , $flags  = require('./$.flags')
  , $RegExp = global.RegExp
  , Base    = $RegExp
  , proto   = $RegExp.prototype
  , re      = /a/g
  // "new" creates a new object
  , CORRECT_NEW = new $RegExp(re) !== re
  // RegExp allows a regex with flags as the pattern
  , ALLOWS_RE_WITH_FLAGS = function(){
    try {
      return $RegExp(re, 'i') == '/a/i';
    } catch(e){ /* empty */ }
  }();

if(require('./$.support-desc')){
  if(!CORRECT_NEW || !ALLOWS_RE_WITH_FLAGS){
    $RegExp = function RegExp(pattern, flags){
      var patternIsRegExp  = cof(pattern) == 'RegExp'
        , flagsIsUndefined = flags === undefined;
      if(!(this instanceof $RegExp) && patternIsRegExp && flagsIsUndefined)return pattern;
      return CORRECT_NEW
        ? new Base(patternIsRegExp && !flagsIsUndefined ? pattern.source : pattern, flags)
        : new Base(patternIsRegExp ? pattern.source : pattern
          , patternIsRegExp && flagsIsUndefined ? $flags.call(pattern) : flags);
    };
    $.each.call($.getNames(Base), function(key){
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function(){ return Base[key]; },
        set: function(it){ Base[key] = it; }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    require('./$.redef')(global, 'RegExp', $RegExp);
  }
}

require('./$.species')($RegExp);
},{"./$":43,"./$.cof":11,"./$.flags":25,"./$.global":28,"./$.redef":55,"./$.species":61,"./$.support-desc":68}],150:[function(require,module,exports){
// @@match logic
require('./$.fix-re-wks')('match', 1, function(defined, MATCH){
  // 21.1.3.11 String.prototype.match(regexp)
  return function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  };
});
},{"./$.fix-re-wks":24}],151:[function(require,module,exports){
// @@replace logic
require('./$.fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  };
});
},{"./$.fix-re-wks":24}],152:[function(require,module,exports){
// @@search logic
require('./$.fix-re-wks')('search', 1, function(defined, SEARCH){
  // 21.1.3.15 String.prototype.search(regexp)
  return function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  };
});
},{"./$.fix-re-wks":24}],153:[function(require,module,exports){
// @@split logic
require('./$.fix-re-wks')('split', 2, function(defined, SPLIT, $split){
  // 21.1.3.17 String.prototype.split(separator, limit)
  return function split(separator, limit){
    'use strict';
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined
      ? fn.call(separator, O, limit)
      : $split.call(String(O), separator, limit);
  };
});
},{"./$.fix-re-wks":24}],154:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments[0]); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":15,"./$.collection-strong":12}],155:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(false);
$def($def.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
},{"./$.def":18,"./$.string-at":63}],156:[function(require,module,exports){
'use strict';
var $def     = require('./$.def')
  , toLength = require('./$.to-length')
  , context  = require('./$.string-context');

// should throw error on regex
$def($def.P + $def.F * !require('./$.fails')(function(){ 'q'.endsWith(/./); }), 'String', {
  // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, 'endsWith')
      , endPosition = arguments[1]
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return that.slice(end - search.length, end) === search;
  }
});
},{"./$.def":18,"./$.fails":23,"./$.string-context":64,"./$.to-length":74}],157:[function(require,module,exports){
var $def    = require('./$.def')
  , toIndex = require('./$.to-index')
  , fromCharCode = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res = []
      , len = arguments.length
      , i   = 0
      , code;
    while(len > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
},{"./$.def":18,"./$.to-index":71}],158:[function(require,module,exports){
'use strict';
var $def    = require('./$.def')
  , context = require('./$.string-context');

$def($def.P, 'String', {
  // 21.1.3.7 String.prototype.includes(searchString, position = 0)
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, 'includes').indexOf(searchString, arguments[1]);
  }
});
},{"./$.def":18,"./$.string-context":64}],159:[function(require,module,exports){
'use strict';
var $at  = require('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":39,"./$.string-at":63}],160:[function(require,module,exports){
var $def      = require('./$.def')
  , toIObject = require('./$.to-iobject')
  , toLength  = require('./$.to-length');

$def($def.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl = toIObject(callSite.raw)
      , len = toLength(tpl.length)
      , sln = arguments.length
      , res = []
      , i   = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < sln)res.push(String(arguments[i]));
    } return res.join('');
  }
});
},{"./$.def":18,"./$.to-iobject":73,"./$.to-length":74}],149:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
var $ = require('./$');
if(require('./$.support-desc') && /./g.flags != 'g')$.setDesc(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./$.flags')
});
},{"./$":43,"./$.flags":25,"./$.support-desc":68}],161:[function(require,module,exports){
var $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./$.string-repeat')
});
},{"./$.def":18,"./$.string-repeat":66}],163:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./$.string-trim')('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});
},{"./$.string-trim":67}],164:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = require('./$')
  , global         = require('./$.global')
  , has            = require('./$.has')
  , SUPPORT_DESC   = require('./$.support-desc')
  , $def           = require('./$.def')
  , $redef         = require('./$.redef')
  , shared         = require('./$.shared')
  , setTag         = require('./$.tag')
  , uid            = require('./$.uid')
  , wks            = require('./$.wks')
  , keyOf          = require('./$.keyof')
  , $names         = require('./$.get-names')
  , enumKeys       = require('./$.enum-keys')
  , isObject       = require('./$.is-object')
  , anObject       = require('./$.an-object')
  , toIObject      = require('./$.to-iobject')
  , createDesc     = require('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

var setSymbolDesc = SUPPORT_DESC ? function(){ // fallback for old Android
  try {
    return _create(setDesc({}, HIDDEN, {
      get: function(){
        return setDesc(this, HIDDEN, {value: false})[HIDDEN];
      }
    }))[HIDDEN] || setDesc;
  } catch(e){
    return function(it, key, D){
      var protoDesc = getDesc(ObjectProto, key);
      if(protoDesc)delete ObjectProto[key];
      setDesc(it, key, D);
      if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
    };
  }
}() : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments[0]));
  };
  $redef($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(SUPPORT_DESC && !require('./$.library')){
    $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

// MS Edge converts symbol values to JSON as {}
// WebKit converts symbol values in objects to JSON as null
if(!useNative || require('./$.fails')(function(){
  return JSON.stringify([{a: $Symbol()}, [$Symbol()]]) != '[{},[null]]';
}))$redef($Symbol.prototype, 'toJSON', function toJSON(){
  if(useNative && isObject(this))return this;
});

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
    'species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), function(it){
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  }
);

setter = true;

$def($def.G + $def.W, {Symbol: $Symbol});

$def($def.S, 'Symbol', symbolStatics);

$def($def.S + $def.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setTag(global.JSON, 'JSON', true);
},{"./$":43,"./$.an-object":6,"./$.def":18,"./$.enum-keys":21,"./$.fails":23,"./$.get-names":27,"./$.global":28,"./$.has":29,"./$.is-object":36,"./$.keyof":44,"./$.library":45,"./$.property-desc":54,"./$.redef":55,"./$.shared":59,"./$.support-desc":68,"./$.tag":69,"./$.to-iobject":73,"./$.uid":76,"./$.wks":78}],162:[function(require,module,exports){
'use strict';
var $def     = require('./$.def')
  , toLength = require('./$.to-length')
  , context  = require('./$.string-context');

// should throw error on regex
$def($def.P + $def.F * !require('./$.fails')(function(){ 'q'.startsWith(/./); }), 'String', {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, 'startsWith')
      , index  = toLength(Math.min(arguments[1], that.length))
      , search = String(searchString);
    return that.slice(index, index + search.length) === search;
  }
});
},{"./$.def":18,"./$.fails":23,"./$.string-context":64,"./$.to-length":74}],165:[function(require,module,exports){
'use strict';
var $            = require('./$')
  , weak         = require('./$.collection-weak')
  , isObject     = require('./$.is-object')
  , has          = require('./$.has')
  , frozenStore  = weak.frozenStore
  , WEAK         = weak.WEAK
  , isExtensible = Object.isExtensible || isObject
  , tmp          = {};

// 23.3 WeakMap Objects
var $WeakMap = require('./$.collection')('WeakMap', function(get){
  return function WeakMap(){ return get(this, arguments[0]); };
}, {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      if(!isExtensible(key))return frozenStore(this).get(key);
      if(has(key, WEAK))return key[WEAK][this._i];
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
}, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  $.each.call(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    require('./$.redef')(proto, key, function(a, b){
      // store frozen objects on leaky map
      if(isObject(a) && !isExtensible(a)){
        var result = frozenStore(this)[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./$":43,"./$.collection":15,"./$.collection-weak":14,"./$.has":29,"./$.is-object":36,"./$.redef":55}],166:[function(require,module,exports){
'use strict';
var weak = require('./$.collection-weak');

// 23.4 WeakSet Objects
require('./$.collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments[0]); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
},{"./$.collection":15,"./$.collection-weak":14}],167:[function(require,module,exports){
'use strict';
var $def      = require('./$.def')
  , $includes = require('./$.array-includes')(true);
$def($def.P, 'Array', {
  // https://github.com/domenic/Array.prototype.includes
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments[1]);
  }
});
require('./$.unscope')('includes');
},{"./$.array-includes":7,"./$.def":18,"./$.unscope":77}],168:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def');

$def($def.P, 'Map', {toJSON: require('./$.collection-to-json')('Map')});
},{"./$.collection-to-json":13,"./$.def":18}],170:[function(require,module,exports){
// https://gist.github.com/WebReflection/9353781
var $          = require('./$')
  , $def       = require('./$.def')
  , ownKeys    = require('./$.own-keys')
  , toIObject  = require('./$.to-iobject')
  , createDesc = require('./$.property-desc');

$def($def.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , setDesc = $.setDesc
      , getDesc = $.getDesc
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key, D;
    while(keys.length > i){
      D = getDesc(O, key = keys[i++]);
      if(key in result)setDesc(result, key, createDesc(0, D));
      else result[key] = D;
    } return result;
  }
});
},{"./$":43,"./$.def":18,"./$.own-keys":51,"./$.property-desc":54,"./$.to-iobject":73}],169:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $def     = require('./$.def')
  , $entries = require('./$.object-to-array')(true);

$def($def.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./$.def":18,"./$.object-to-array":50}],171:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $def    = require('./$.def')
  , $values = require('./$.object-to-array')(false);

$def($def.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});
},{"./$.def":18,"./$.object-to-array":50}],173:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def');

$def($def.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":13,"./$.def":18}],172:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $def = require('./$.def')
  , $re  = require('./$.replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');
$def($def.S, 'RegExp', {escape: function escape(it){ return $re(it); }});

},{"./$.def":18,"./$.replacer":56}],174:[function(require,module,exports){
// https://github.com/mathiasbynens/String.prototype.at
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(true);
$def($def.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
},{"./$.def":18,"./$.string-at":63}],176:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  padRight: function padRight(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments[1], false);
  }
});
},{"./$.def":18,"./$.string-pad":65}],177:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./$.string-trim')('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
});
},{"./$.string-trim":67}],175:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  padLeft: function padLeft(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments[1], true);
  }
});
},{"./$.def":18,"./$.string-pad":65}],179:[function(require,module,exports){
// JavaScript 1.6 / Strawman array statics shim
var $       = require('./$')
  , $def    = require('./$.def')
  , $Array  = require('./$.core').Array || Array
  , statics = {};
var setStatics = function(keys, length){
  $.each.call(keys.split(','), function(key){
    if(length == undefined && key in $Array)statics[key] = $Array[key];
    else if(key in [])statics[key] = require('./$.ctx')(Function.call, [][key], length);
  });
};
setStatics('pop,reverse,shift,keys,values,entries', 1);
setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
           'reduce,reduceRight,copyWithin,fill');
$def($def.S, 'Array', statics);
},{"./$":43,"./$.core":16,"./$.ctx":17,"./$.def":18}],178:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./$.string-trim')('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
});
},{"./$.string-trim":67}],180:[function(require,module,exports){
require('./es6.array.iterator');
var global      = require('./$.global')
  , hide        = require('./$.hide')
  , Iterators   = require('./$.iterators')
  , ITERATOR    = require('./$.wks')('iterator')
  , NL          = global.NodeList
  , HTC         = global.HTMLCollection
  , NLProto     = NL && NL.prototype
  , HTCProto    = HTC && HTC.prototype
  , ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
if(NL && !(ITERATOR in NLProto))hide(NLProto, ITERATOR, ArrayValues);
if(HTC && !(ITERATOR in HTCProto))hide(HTCProto, ITERATOR, ArrayValues);
},{"./$.global":28,"./$.hide":30,"./$.iterators":42,"./$.wks":78,"./es6.array.iterator":86}],181:[function(require,module,exports){
var $def  = require('./$.def')
  , $task = require('./$.task');
$def($def.G + $def.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./$.def":18,"./$.task":70}],182:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global     = require('./$.global')
  , $def       = require('./$.def')
  , invoke     = require('./$.invoke')
  , partial    = require('./$.partial')
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$def($def.G + $def.B + $def.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});
},{"./$.def":18,"./$.global":28,"./$.invoke":32,"./$.partial":52}],183:[function(require,module,exports){
require('./modules/es5');
require('./modules/es6.symbol');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.number.constructor');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.iterator');
require('./modules/es6.array.species');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-left');
require('./modules/es7.string.pad-right');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.regexp.escape');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/js.array.statics');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/$.core');
},{"./modules/$.core":16,"./modules/es5":80,"./modules/es6.array.copy-within":81,"./modules/es6.array.fill":82,"./modules/es6.array.find":84,"./modules/es6.array.find-index":83,"./modules/es6.array.from":85,"./modules/es6.array.iterator":86,"./modules/es6.array.of":87,"./modules/es6.array.species":88,"./modules/es6.function.has-instance":89,"./modules/es6.function.name":90,"./modules/es6.map":91,"./modules/es6.math.acosh":92,"./modules/es6.math.asinh":93,"./modules/es6.math.atanh":94,"./modules/es6.math.cbrt":95,"./modules/es6.math.clz32":96,"./modules/es6.math.cosh":97,"./modules/es6.math.expm1":98,"./modules/es6.math.fround":99,"./modules/es6.math.hypot":100,"./modules/es6.math.imul":101,"./modules/es6.math.log10":102,"./modules/es6.math.log1p":103,"./modules/es6.math.log2":104,"./modules/es6.math.sign":105,"./modules/es6.math.sinh":106,"./modules/es6.math.tanh":107,"./modules/es6.math.trunc":108,"./modules/es6.number.constructor":109,"./modules/es6.number.epsilon":110,"./modules/es6.number.is-finite":111,"./modules/es6.number.is-integer":112,"./modules/es6.number.is-nan":113,"./modules/es6.number.is-safe-integer":114,"./modules/es6.number.max-safe-integer":115,"./modules/es6.number.min-safe-integer":116,"./modules/es6.number.parse-float":117,"./modules/es6.number.parse-int":118,"./modules/es6.object.assign":119,"./modules/es6.object.freeze":120,"./modules/es6.object.get-own-property-descriptor":121,"./modules/es6.object.get-own-property-names":122,"./modules/es6.object.get-prototype-of":123,"./modules/es6.object.is":127,"./modules/es6.object.is-extensible":124,"./modules/es6.object.is-frozen":125,"./modules/es6.object.is-sealed":126,"./modules/es6.object.keys":128,"./modules/es6.object.prevent-extensions":129,"./modules/es6.object.seal":130,"./modules/es6.object.set-prototype-of":131,"./modules/es6.object.to-string":132,"./modules/es6.promise":133,"./modules/es6.reflect.apply":134,"./modules/es6.reflect.construct":135,"./modules/es6.reflect.define-property":136,"./modules/es6.reflect.delete-property":137,"./modules/es6.reflect.enumerate":138,"./modules/es6.reflect.get":141,"./modules/es6.reflect.get-own-property-descriptor":139,"./modules/es6.reflect.get-prototype-of":140,"./modules/es6.reflect.has":142,"./modules/es6.reflect.is-extensible":143,"./modules/es6.reflect.own-keys":144,"./modules/es6.reflect.prevent-extensions":145,"./modules/es6.reflect.set":147,"./modules/es6.reflect.set-prototype-of":146,"./modules/es6.regexp.constructor":148,"./modules/es6.regexp.flags":149,"./modules/es6.regexp.match":150,"./modules/es6.regexp.replace":151,"./modules/es6.regexp.search":152,"./modules/es6.regexp.split":153,"./modules/es6.set":154,"./modules/es6.string.code-point-at":155,"./modules/es6.string.ends-with":156,"./modules/es6.string.from-code-point":157,"./modules/es6.string.includes":158,"./modules/es6.string.iterator":159,"./modules/es6.string.raw":160,"./modules/es6.string.repeat":161,"./modules/es6.string.starts-with":162,"./modules/es6.string.trim":163,"./modules/es6.symbol":164,"./modules/es6.weak-map":165,"./modules/es6.weak-set":166,"./modules/es7.array.includes":167,"./modules/es7.map.to-json":168,"./modules/es7.object.entries":169,"./modules/es7.object.get-own-property-descriptors":170,"./modules/es7.object.values":171,"./modules/es7.regexp.escape":172,"./modules/es7.set.to-json":173,"./modules/es7.string.at":174,"./modules/es7.string.pad-left":175,"./modules/es7.string.pad-right":176,"./modules/es7.string.trim-left":177,"./modules/es7.string.trim-right":178,"./modules/js.array.statics":179,"./modules/web.dom.iterable":180,"./modules/web.immediate":181,"./modules/web.timers":182}],184:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(
      innerFn, self || null,
      new Context(tryLocsList || [])
    );

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function(arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument
        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
        : Promise.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration. If the Promise is rejected, however, the
            // result for this iteration will be rejected with the same
            // reason. Note that rejections of yielded Promises are not
            // thrown back into the generator function, as is the case
            // when an awaited Promise is rejected. This difference in
            // behavior between yield and await is important, because it
            // allows the consumer to decide what to do with the yielded
            // rejection (swallow it and continue, manually .throw it back
            // into the generator, abandon iteration, whatever). With
            // await, by contrast, there is no opportunity to examine the
            // rejection reason outside the generator function, so the
            // only option is to throw it from the await expression, and
            // let the generator function handle the exception.
            result.value = unwrapped;
            return result;
          });
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      var enqueueResult =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(function() {
          return invoke(method, arg);
        }) : new Promise(function(resolve) {
          resolve(invoke(method, arg));
        });

      // Avoid propagating enqueueResult failures to Promises returned by
      // later invocations of the iterator.
      previousPromise = enqueueResult["catch"](function(ignored){});

      return enqueueResult;
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":192}],185:[function(require,module,exports){
module.exports = require("./lib/polyfill");

},{"./lib/polyfill":4}],187:[function(require,module,exports){

},{}],188:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],189:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],190:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],191:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],192:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],193:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],186:[function(require,module,exports){
module.exports = require("babel-core/polyfill");

},{"babel-core/polyfill":185}],194:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],195:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],197:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":198}],198:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/



/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":200,"./_stream_writable":202,"core-util-is":203,"inherits":189,"process-nextick-args":204}],199:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":201,"core-util-is":203,"inherits":189}],200:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/



/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function')
    this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      processNextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    processNextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }; }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":198,"_process":192,"buffer":215,"core-util-is":203,"events":188,"inherits":189,"isarray":191,"process-nextick-args":204,"string_decoder/":211,"util":187}],196:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":194,"./encode":195}],201:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":198,"core-util-is":203,"inherits":189}],203:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,{"isBuffer":require("/home/vadzim/v/work/nerojs/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js")})

},{"/home/vadzim/v/work/nerojs/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js":190}],204:[function(require,module,exports){
(function (process){
'use strict';
module.exports = nextTick;

function nextTick(fn) {
  var args = new Array(arguments.length - 1);
  var i = 0;
  while (i < args.length) {
    args[i++] = arguments[i];
  }
  process.nextTick(function afterTick() {
    fn.apply(null, args);
  });
}

}).call(this,require('_process'))

},{"_process":192}],205:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  if (!global.localStorage) return false;
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],206:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":199}],207:[function(require,module,exports){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":198,"./lib/_stream_passthrough.js":199,"./lib/_stream_readable.js":200,"./lib/_stream_transform.js":201,"./lib/_stream_writable.js":202}],208:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":201}],209:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":202}],210:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":188,"inherits":189,"readable-stream/duplex.js":197,"readable-stream/passthrough.js":206,"readable-stream/readable.js":207,"readable-stream/transform.js":208,"readable-stream/writable.js":209}],202:[function(require,module,exports){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function (){try {
Object.defineProperty(WritableState.prototype, 'buffer', {
  get: require('util-deprecate')(function() {
    return this.getBuffer();
  }, '_writableState.buffer is deprecated. Use ' +
      '_writableState.getBuffer() instead.')
});
}catch(_){}}());


function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = nop;

  if (state.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.bufferedRequest)
      clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string')
    encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
.indexOf((encoding + '').toLowerCase()) > -1))
    throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    processNextTick(cb, er);
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      processNextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var buffer = [];
    var cbs = [];
    while (entry) {
      cbs.push(entry.callback);
      buffer.push(entry);
      entry = entry.next;
    }

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    state.lastBufferedRequest = null;
    doWrite(stream, state, true, state.length, buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined)
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(state) {
  return (state.ending &&
          state.length === 0 &&
          state.bufferedRequest === null &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      processNextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./_stream_duplex":198,"buffer":215,"core-util-is":203,"events":188,"inherits":189,"process-nextick-args":204,"util-deprecate":205}],211:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":215}],212:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":193,"querystring":196}],213:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],215:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

},{"base64-js":216,"ieee754":217,"is-array":218}],214:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":213,"_process":192,"inherits":189}],216:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],217:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],219:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');

module.exports = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
}

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr =  /^#([a-fA-F0-9]{3})$/,
       hex =  /^#([a-fA-F0-9]{6})$/,
       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
       keyword = /(\D+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr);
   if (match) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   }
   else if (match = string.match(hex)) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   }
   else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   }
   else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
    var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   }
   else if (vals = getHsla(string)) {
      return vals[3];
   }
   else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgb) {
   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
              + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return (str.length < 2) ? "0" + str : str;
}


//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
   reverseNames[colorNames[name]] = name;
}

},{"color-name":220}],220:[function(require,module,exports){
module.exports={
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
}
},{}],221:[function(require,module,exports){
/*

The MIT License (MIT)

Original Library 
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var ansiStyles = colors.styles = require('./styles');
var defineProps = Object.defineProperties;

colors.supportsColor = require('./system/supports-colors');

if (typeof colors.enabled === "undefined") {
  colors.enabled = colors.supportsColor;
}

colors.stripColors = colors.strip = function(str){
  return ("" + str).replace(/\x1B\[\d+m/g, '');
};


var stylize = colors.stylize = function stylize (str, style) {
  if (!colors.enabled) {
    return str+'';
  }

  return ansiStyles[style].open + str + ansiStyles[style].close;
}

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe,  '\\$&');
}

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function () {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function (key) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function () {
        return build(this._styles.concat(key));
      }
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = arguments;
  var argsLen = args.length;
  var str = argsLen !== 0 && String(arguments[0]);
  if (argsLen > 1) {
    for (var a = 1; a < argsLen; a++) {
      str += ' ' + args[a];
    }
  }

  if (!colors.enabled || !str) {
    return str;
  }

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
  }

  return str;
}

function applyTheme (theme) {
  for (var style in theme) {
    (function(style){
      colors[style] = function(str){
        if (typeof theme[style] === 'object'){
          var out = str;
          for (var i in theme[style]){
            out = colors[theme[style][i]](out);
          }
          return out;
        }
        return colors[theme[style]](str);
      };
    })(style)
  }
}

colors.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      colors.themes[theme] = require(theme);
      applyTheme(colors.themes[theme]);
      return colors.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function (name) {
    ret[name] = {
      get: function () {
        return build([name]);
      }
    };
  });
  return ret;
}

var sequencer = function sequencer (map, str) {
  var exploded = str.split(""), i = 0;
  exploded = exploded.map(map);
  return exploded.join("");
};

// custom formatter methods
colors.trap = require('./custom/trap');
colors.zalgo = require('./custom/zalgo');

// maps
colors.maps = {};
colors.maps.america = require('./maps/america');
colors.maps.zebra = require('./maps/zebra');
colors.maps.rainbow = require('./maps/rainbow');
colors.maps.random = require('./maps/random')

for (var map in colors.maps) {
  (function(map){
    colors[map] = function (str) {
      return sequencer(colors.maps[map], str);
    }
  })(map)
}

defineProps(colors, init());
},{"./custom/trap":222,"./custom/zalgo":223,"./maps/america":226,"./maps/rainbow":227,"./maps/random":228,"./maps/zebra":229,"./styles":230,"./system/supports-colors":231}],218:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],222:[function(require,module,exports){
module['exports'] = function runTheTrap (text, options) {
  var result = "";
  text = text || "Run the trap, drop the bass";
  text = text.split('');
  var trap = {
    a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
    b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
    c: ["\u00a9", "\u023b", "\u03fe"],
    d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
    e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
    f: ["\u04fa"],
    g: ["\u0262"],
    h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
    i: ["\u0f0f"],
    j: ["\u0134"],
    k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
    l: ["\u0139"],
    m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
    n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
    o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
    p: ["\u01f7", "\u048e"],
    q: ["\u09cd"],
    r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
    s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
    t: ["\u0141", "\u0166", "\u0373"],
    u: ["\u01b1", "\u054d"],
    v: ["\u05d8"],
    w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
    x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
    y: ["\u00a5", "\u04b0", "\u04cb"],
    z: ["\u01b5", "\u0240"]
  }
  text.forEach(function(c){
    c = c.toLowerCase();
    var chars = trap[c] || [" "];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== "undefined") {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;

}

},{}],223:[function(require,module,exports){
// please no
module['exports'] = function zalgo(text, options) {
  text = text || "   he is here   ";
  var soul = {
    "up" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', ''
    ],
    "down" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', ''
    ],
    "mid" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '',
      '', '', '', '',
      '', '', ' '
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }
  

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] =   typeof options["up"]   !== 'undefined' ? options["up"]   : true;
    options["mid"] =  typeof options["mid"]  !== 'undefined' ? options["mid"]  : true;
    options["down"] = typeof options["down"] !== 'undefined' ? options["down"] : true;
    options["size"] = typeof options["size"] !== 'undefined' ? options["size"] : "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.mid = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.mid = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text, options);
}

},{}],225:[function(require,module,exports){
var colors = require('./colors');
module['exports'] = colors;

// Remark: By default, colors will add style properties to String.prototype
//
// If you don't wish to extend String.prototype you can do this instead and native String will not be touched
//
//   var colors = require('colors/safe);
//   colors.red("foo")
//
//
require('./extendStringPrototype')();
},{"./colors":221,"./extendStringPrototype":224}],226:[function(require,module,exports){
var colors = require('../colors');

module['exports'] = (function() {
  return function (letter, i, exploded) {
    if(letter === " ") return letter;
    switch(i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter)
      case 2: return colors.blue(letter)
    }
  }
})();
},{"../colors":221}],227:[function(require,module,exports){
var colors = require('../colors');

module['exports'] = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
})();


},{"../colors":221}],228:[function(require,module,exports){
var colors = require('../colors');

module['exports'] = (function () {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
  return function(letter, i, exploded) {
    return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
  };
})();
},{"../colors":221}],224:[function(require,module,exports){
var colors = require('./colors');

module['exports'] = function () {

  //
  // Extends prototype of native string object to allow for "foo".red syntax
  //
  var addProperty = function (color, func) {
    String.prototype.__defineGetter__(color, func);
  };

  var sequencer = function sequencer (map, str) {
      return function () {
        var exploded = this.split(""), i = 0;
        exploded = exploded.map(map);
        return exploded.join("");
      }
  };

  addProperty('strip', function () {
    return colors.strip(this);
  });

  addProperty('stripColors', function () {
    return colors.strip(this);
  });

  addProperty("trap", function(){
    return colors.trap(this);
  });

  addProperty("zalgo", function(){
    return colors.zalgo(this);
  });

  addProperty("zebra", function(){
    return colors.zebra(this);
  });

  addProperty("rainbow", function(){
    return colors.rainbow(this);
  });

  addProperty("random", function(){
    return colors.random(this);
  });

  addProperty("america", function(){
    return colors.america(this);
  });

  //
  // Iterate through all default styles and colors
  //
  var x = Object.keys(colors.styles);
  x.forEach(function (style) {
    addProperty(style, function () {
      return colors.stylize(this, style);
    });
  });

  function applyTheme(theme) {
    //
    // Remark: This is a list of methods that exist
    // on String that you should not overwrite.
    //
    var stringPrototypeBlacklist = [
      '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
      'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
      'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
      'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
    ];

    Object.keys(theme).forEach(function (prop) {
      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
        console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
      }
      else {
        if (typeof(theme[prop]) === 'string') {
          colors[prop] = colors[theme[prop]];
          addProperty(prop, function () {
            return colors[theme[prop]](this);
          });
        }
        else {
          addProperty(prop, function () {
            var ret = this;
            for (var t = 0; t < theme[prop].length; t++) {
              ret = colors[theme[prop][t]](ret);
            }
            return ret;
          });
        }
      }
    });
  }

  colors.setTheme = function (theme) {
    if (typeof theme === 'string') {
      try {
        colors.themes[theme] = require(theme);
        applyTheme(colors.themes[theme]);
        return colors.themes[theme];
      } catch (err) {
        console.log(err);
        return err;
      }
    } else {
      applyTheme(theme);
    }
  };

};
},{"./colors":221}],230:[function(require,module,exports){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49]

};

Object.keys(codes).forEach(function (key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});
},{}],229:[function(require,module,exports){
var colors = require('../colors');

module['exports'] = function (letter, i, exploded) {
  return i % 2 === 0 ? letter : colors.inverse(letter);
};
},{"../colors":221}],232:[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],231:[function(require,module,exports){
(function (process){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var argv = process.argv;

module.exports = (function () {
  if (argv.indexOf('--no-color') !== -1 ||
    argv.indexOf('--color=false') !== -1) {
    return false;
  }

  if (argv.indexOf('--color') !== -1 ||
    argv.indexOf('--color=true') !== -1 ||
    argv.indexOf('--color=always') !== -1) {
    return true;
  }

  if (process.stdout && !process.stdout.isTTY) {
    return false;
  }

  if (process.platform === 'win32') {
    return true;
  }

  if ('COLORTERM' in process.env) {
    return true;
  }

  if (process.env.TERM === 'dumb') {
    return false;
  }

  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    return true;
  }

  return false;
})();
}).call(this,require('_process'))

},{"_process":192}],233:[function(require,module,exports){
/*
	costs: {
		delete: number | function ( char )
		insert: number | function ( char )
		replace: number | function ( what, by )
		transpose: number | function ( left, right )
	}
*/

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
function getCost(costs, op, a, b) {
	var cost = typeof costs == "object" ? costs[op] : costs;
	return typeof cost == "function" ? cost.call(costs, a, b) : cost;
}

exports.default = function (s1, s2) {
	var costs = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

	var d = [];
	for (var i = 0; i <= s1.length; ++i) {
		d[i] = i < 3 ? [] : d[i - 3]; // some optimization
		for (var j = 0; j <= s2.length; ++j) {
			d[i][j] = i == 0 && j == 0 ? 0 : i == 0 ? d[i][j - 1] + getCost(costs, "insert", s2[j - 1]) : j == 0 ? d[i - 1][j] + getCost(costs, "delete", s1[i - 1]) : Math.min(d[i - 1][j] + getCost(costs, "delete", s1[i - 1]), d[i][j - 1] + getCost(costs, "insert", s2[j - 1]), d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : getCost(costs, "replace", s1[i - 1], s2[j - 1])), i > 1 && j > 1 && s1[i - 1] == s2[j - 2] && s1[i - 2] == s2[j - 1] ? d[i - 2][j - 2] + getCost(costs, "transpose", s1[i - 2], s1[i - 1]) : Infinity);
		}
	}
	return d[s1.length][s2.length];
};

module.exports = exports.default;

},{}],235:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

exports.default = function (key) {
	var defaults = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	var ret = (0, _ra2.default)(defaults).setConst("reset", function () {
		localStorage.removeItem(key);
		ret.assign(defaults);
		// ret.loaded = true
	}).setName("localStorage." + key);
	var stored = localStorage.getItem(key);
	if (stored != null) ret.assign(JSON.parse(stored));
	(0, _ra2.default)(function () {
		if (ret.valueOf() != defaults) localStorage.setItem(key, JSON.stringify(ret));
	});
	return ret;
};

module.exports = exports.default;

},{"ra":255}],236:[function(require,module,exports){
(function (process,global){
/*

TODO 2015.03.25    :           "  "  "   ".

*/
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _JSONlocal = require("JSONlocal");

var _JSONlocal2 = _interopRequireDefault(_JSONlocal);

var _localUtils = require("localUtils");

var lu = _interopRequireWildcard(_localUtils);

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _co = require("co");

var co = _interopRequireWildcard(_co);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var _diff = require("diff");

var Diff = _interopRequireWildcard(_diff);

var _uid = require("uid");

var _uid2 = _interopRequireDefault(_uid);

var _httpClient = require("httpClient");

var httpClient = _interopRequireWildcard(_httpClient);

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

// import deviceActions from "netro/deviceActions"

var _websocketStream = require("websocketStream");

var _websocketStream2 = _interopRequireDefault(_websocketStream);

var _pingpongStream = require("pingpongStream");

var _pingpongStream2 = _interopRequireDefault(_pingpongStream);

var _JSONDuplex = require("JSONDuplex");

var _JSONDuplex2 = _interopRequireDefault(_JSONDuplex);

var _sf = require("sf");

var sf = _interopRequireWildcard(_sf);

var _devdb = require("devdb");

var devdb = _interopRequireWildcard(_devdb);

var _commands = require("commands");

var commands = _interopRequireWildcard(_commands);

var _dbcache = require("dbcache");

var _dbcache2 = _interopRequireDefault(_dbcache);

var _windowSize = require("windowSize");

var _windowSize2 = _interopRequireDefault(_windowSize);

var WebSocketRetry = 1000;
var savePlacesTimeout = 3000;

function websocket(url) {
	return (0, _pingpongStream2.default)().setOther((0, _JSONDuplex2.default)()).setOther((0, _websocketStream2.default)(url));
}

var PersistentWebSocket = (function (_EventEmitter) {
	_inherits(PersistentWebSocket, _EventEmitter);

	function PersistentWebSocket(url) {
		var _this = this;

		_classCallCheck(this, PersistentWebSocket);

		_get(Object.getPrototypeOf(PersistentWebSocket.prototype), "constructor", this).call(this);
		this._ws = null;
		this._sheduledCreating = null;
		this._nextCreate = -Infinity;
		this._onend = function () {
			return _this._createHandle(true);
		};
		this._onerror = function (error) {
			return _this.emit("error", error);
		};
		this._ondata = function (message) {
			return _this.emit("message", message);
		};
		this._url = null;
		this.connected = false;
		this.closed = false;
		// this.user = undefined
		// this.key = undefined
		this.url = url;
		// window.addEventListener( `_application_resumed` )
	}

	_createClass(PersistentWebSocket, [{
		key: "_clearHandle",
		value: function _clearHandle() {
			if (this._ws) {
				this._ws.removeListener("end", this._onend);
				this._ws.removeListener("error", this._onerror);
				this._ws.removeListener("data", this._ondata);
				this._ws.end();
				this._ws = null;
				this.emit("pause");
			}
			if (this._sheduledCreating) {
				clearTimeout(this._sheduledCreating);
				this._sheduledCreating = null;
			}
		}
	}, {
		key: "_openWebSocket",
		value: function _openWebSocket() {
			this._ws.setOther(websocket(this._url));
			this.emit("resume");
		}
	}, {
		key: "_createHandle",
		value: function _createHandle(retrying) {
			var _this2 = this;

			this._clearHandle();
			if (this.closed || !this._url) return;
			this._ws = sf.duplexer(sf.through(), sf.through());
			this._ws.on("end", this._onend);
			this._ws.on("error", this._onerror);
			this._ws.on("data", this._ondata);
			var t = this._nextCreate;
			var n = Date.now();
			this._nextCreate = n + WebSocketRetry;
			if (!retrying || n >= t) this._openWebSocket();else this._sheduledCreating = setTimeout(function () {
				return _this2._openWebSocket();
			}, t - n);
		}
	}, {
		key: "reinit",
		value: function reinit() {
			this._ws && this._ws.end();
		}
	}, {
		key: "send",
		value: function send(data) {
			if (!this._ws) throw new Error("socket is not open");
			this._ws.write(data);
		}
	}, {
		key: "delete",
		value: function _delete() {
			this.close();
		}
	}, {
		key: "close",
		value: function close() {
			this.closed = true;
			this._clearHandle();
			this.emit("close");
		}
	}, {
		key: "ask",
		value: function ask(question) {
			return co.go(regeneratorRuntime.mark(function callee$2$0() {
				var id, packet, message;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							id = (0, _uid2.default)();
							packet = this.get(id);

							this.send({ id: id, question: question });
							context$3$0.next = 5;
							return packet;

						case 5:
							message = context$3$0.sent;

							if (!message.error) {
								context$3$0.next = 8;
								break;
							}

							throw new Error(message.error);

						case 8:
							return context$3$0.abrupt("return", message.answer);

						case 9:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}).bind(this));
		}
	}, {
		key: "get",
		value: function get(predicate, timeout) {
			return co.go(regeneratorRuntime.mark(function callee$2$0() {
				var _ref, event, data;

				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (typeof predicate == "string" || typeof predicate == "number") {
								(function () {
									var id = predicate;
									predicate = function (msg) {
										return msg.id == id;
									};
								})();
							} else if (!(typeof predicate == "function")) {
								(function () {
									var p = predicate;
									predicate = function (msg) {
										return lodash.every(p, function (value, key) {
											return msg[key] == value;
										});
									};
								})();
							}
							context$3$0.next = 3;
							return co.receive(this, { close: true, pause: true, message: predicate, timeout: timeout });

						case 3:
							_ref = context$3$0.sent;
							event = _ref.event;
							data = _ref.data;

							if (!(event == "message")) {
								context$3$0.next = 8;
								break;
							}

							return context$3$0.abrupt("return", data);

						case 8:
							throw new Error("timeout " + (this._url || "ws://"));

						case 9:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}).bind(this));
		}
	}, {
		key: "url",
		get: function get() {
			return this._url;
		},
		set: function set(url) {
			if (this._url != url) {
				this._url = url;
				this._createHandle();
			}
		}
	}]);

	return PersistentWebSocket;
})(_events2.default);

function wsClient(app, url) {
	var ws = new PersistentWebSocket();
	(0, _ra2.default)(function () {
		return ws.url = app.localModem && app.localModem + url;
	});
	ws.active = _ra2.default.on(ws, ["pause", "resume"], function () {
		return ws.connected;
	});
	return ws;
}

function wsJSONclient(app, url) {

	var json = (0, _JSONlocal2.default)(url, { uid: null });
	var ws = wsClient(app, url);
	var init = function init() {
		return ws.send({ channel: "database", what: "init", id: json.uid });
	};
	var resolvers = {};

	var doError = function doError(message, data) {
		throw new Error("wsJSONclient: " + message + ": " + JSON.stringify(data));
	};

	lu.on(ws, {
		resume: init,
		message: function message(_message) {
			switch (_message.what) {
				case "error":
					doError("error from server", _message);
				case "saved":
					{
						var resolve = resolvers[_message.messageId];
						delete resolvers[_message.messageId];
						resolve && resolve();
						return;
					}
				case "data":
					{
						if (_message.partial && _message.previous != json.uid) init();else if (Object.prototype.hasOwnProperty.call(_message, "data")) json.assign(Diff.apply(json.valueOf(), _message.data, _message.partial));
						return;
					}
				default:
					doError("unknown message from server", _message);
			}
		},
		error: function error() {
			app.onCredentials();
		}
	});

	function doReject(messageId, reject) {
		delete resolvers[messageId];
		reject();
	}

	var save = function save(partial, data) {
		return new Promise(function (resolve, reject) {
			var messageId = (0, _uid2.default)();
			resolvers[messageId] = resolve;
			ws.send({ channel: "database", what: "save", data: partial ? data : Object.assign({ __partial__: false }, data || {}), messageId: messageId });
			setTimeout(doReject, savePlacesTimeout, messageId, reject);
		});
	};

	return {
		data: json.getReadOnly(),
		active: ws.active,
		send: function send(data) {
			return save(false, data);
		},
		update: function update(data) {
			return save(true, data);
		},
		delete: function _delete() {
			ws.close();
		}
	};
}

exports.default = function (appid) {

	var localDefaults = {
		activeDeviceId: "",
		language: "ru",
		iconSize: 40, // millimeters
		labels: true,
		placesPages: {},
		themeName: ""
	};

	var local = (0, _JSONlocal2.default)(appid, localDefaults);

	var app = (0, _ra2.default)({

		_process: _ra2.default.Value(process),

		getMessage: function getMessage(data) {
			var language = local.language || "ru";
			return [language, "ru", "en", "by"].filter(function (l) {
				return Object.prototype.hasOwnProperty.call(data, l);
			}).map(function (l) {
				return data[l];
			})[0];
		},

		themes: new Promise(function (resolve) {
			resolve(require("themes"));
		}),
		themeName: null,
		get fillThemeName() {
			this.themeName = local.live.themeName.noTouch() || this.themeName || this.themes && Object.keys(this.themes).pop();
		},
		get saveThemeName() {
			local.themeName = this.themeName;
		},
		get theme() {
			return this.themes && this.themes[this.themeName] || false;
		},

		margin: 0.5 /*mm*/ * 96 / 25.4,
		pageWidth: 2,
		pageHeight: 3,
		pageStarting: false,
		dialog: "",
		editing: false,
		moving: 0,
		history: [],
		menuWidth: 100,
		menuHeight: 100,

		loggedin: false,
		// credentials: 1,
		onCredentials: function onCredentials() {
			this.loggedin = false;
		},

		go: function go(to, path) {
			var _this3 = this;

			if (!to) return;
			var h = this.history;
			var a = local.activeDeviceId;
			var l = undefined;
			while (h.length && (l = h[h.length - 1], l == to || l == a || path && path.indexOf(l) >= 0)) h.pop();
			if (a != to) h.push(a);
			path && h.push.apply(h, _toConsumableArray(path.filter(function (id) {
				return id != _this3.main;
			}).reverse()));
			local.activeDeviceId = to;
			this.dialog = "";
		},

		back: function back() {
			while (this.history.length) {
				var device = this.history.pop();
				if (this.getDevice(device)) return local.activeDeviceId = device;
			}
			local.activeDeviceId = this.main;
		},

		windowSize: _windowSize2.default.getReadOnly(),

		placesShifts: {},

		// TODO !!       !!
		get modemLocations() {
			return httpClient.get("/modem_locations");
		},

		get localModem() {
			return this.modemLocations && this.modemLocations[0] ? this.modemLocations[0].url.replace(/^http(?=s?\:\/\/)/, "ws") : "";
		},

		get doLogin() {
			return regeneratorRuntime.mark(function callee$2$0() {
				var script;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					var _this4 = this;

					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!(!this.loggedin && this.modemLocations)) {
								context$3$0.next = 23;
								break;
							}

							script = document.createElement("script");

							script.src = this.modemLocations[0].url + "/login?" + (0, _uid2.default)();
							document.body.appendChild(script);
							context$3$0.prev = 4;
							context$3$0.next = 7;
							return script;

						case 7:
							context$3$0.next = 16;
							break;

						case 9:
							context$3$0.prev = 9;
							context$3$0.t0 = context$3$0["catch"](4);

							global.LOG("error while trying to login: " + (context$3$0.t0 && context$3$0.t0.message && context$3$0.t0));
							console.error(context$3$0.t0);
							context$3$0.next = 15;
							return co.sleep(300);

						case 15:
							return context$3$0.abrupt("continue", 0);

						case 16:
							context$3$0.prev = 16;

							document.body.removeChild(script);
							return context$3$0.finish(16);

						case 19:
							global.LOG("logged in");
							_ra2.default.detach(function () {
								return _this4.loggedin = true;
							});
							// TODO: this code with an XMLHttpRequest does not work on iPhone :(((
							// let xhr = new XMLHttpRequest
							// xhr.open( `POST`, this.modemLocations[ 0 ].url + `/login`, true, `nero`, `123` )
							// xhr.withCredentials = true
							// try {
							// 	xhr.send()
							// 	yield xhr
							// 	// alert( xhr.status )
							// 	LOG( ( `` + xhr.status ).blue )
							// 	if ( xhr.status >= 200 && xhr.status <= 299 )
							// 		return ra.detach( () => this.loggedin = true )
							// }
							// catch ( error ) {
							// 	// alert( `ERR` )
							// 	console.log( `error while trying to login`, error )
							// }
							// yield co.sleep( 300 )
							context$3$0.next = 0;
							break;

						case 23:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[4, 9, 16, 19]]);
			}).call(this);
		},

		login: function login(name, pwd) {},

		get serverDevices() {
			return wsJSONclient(this, "/database");
		},

		dbcache: _ra2.default.Value((0, _dbcache2.default)()),
		get updateDBCache() {
			this.dbcache.source = this.serverDevices.data.valueOf();
		},
		get devices() {
			return this.dbcache.result || Object.create(null);
		},

		get commands() {
			return wsClient(this, "/commands");
		},
		get connectedToServer() {
			return true && this.serverDevices.active.valueOf() && this.commands.active.valueOf();
		},
		get waitForRestart() {
			return regeneratorRuntime.mark(function callee$2$0(argument) {
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							context$3$0.next = 2;
							return co.receive(this.commands, { message: function message(_message2) {
									return _message2 && _message2.server_command == "restart_client";
								} });

						case 2:
							context$3$0.next = 4;
							return co.sleep(100);

						case 4:
							console.warn("CLIENT_RESTART");
							window.cachedUrlResources = null;
							context$3$0.next = 8;
							return Promise.all([cacheUrlResource("./js/index.js"), cacheUrlResource("./main.html")]);

						case 8:
							window.location.reload(true);

						case 9:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}).call(this);
		},

		get main() {
			return this.devices.main;
		},

		getDevice: function getDevice(deviceId) {
			return this.devices.content && this.devices.content[lu.valueOf(deviceId)];
		},

		get activeDeviceId() {
			return local.activeDeviceId || this.main;
		},

		get activeDevice() {
			return this.getDevice(this.activeDeviceId);
		},

		get activeContentIds() {
			var device = this.activeDevice;
			return _ra2.default.Array(lodash.keys(device && device.content).sort(function (a, b) {
				return device.content[a].index - device.content[b].index;
			}));
		},

		get activeContent() {
			return _ra2.default.Array(this.activeContentIds.map(this.getDevice));
		},

		linkingPlaceId: null,
		get clearLinkingPlaceId() {
			if (this.dialog != "AskToLinkDevice" && this.dialog != "AskIfDeviceHasBeenLinked") this.linkingPlaceId = null;
		},

		get checkIfTimeToGoBack() {
			// lu.valueOf( this.places )
			if (!this.getDevice(this.activeDeviceId)) this.back();
		},

		get caption() {
			return this.getMessage(this.getDevice(this.activeDeviceId)) || this.message("favorites");
		},

		get deviceType() {
			var ret = this.getDevice(this.activeDeviceId);
			if (!ret) ret = this.getDevice(this.main);
			return ret && ret.type || "place";
		},

		get deviceIds() {
			return _ra2.default.Array(lodash.keys(this.devices.content).sort());
		},

		get initialLoading() {
			return !this.devices.uid;
		},

		get initialized() {
			return !this.initialLoading && !!this.devices.main;
		},

		setDatabase: function setDatabase(devices) {
			this.serverDevices.send(devices);
		},

		reset: function reset() {
			local.reset();
			this.setDatabase({ uid: (0, _uid2.default)() });
			this.dialog = "";
			this.editing = false;
			this.history.length = 0;
		},

		setTemplate: function setTemplate(template) {
			console.log(template);
			var devices = {
				uid: (0, _uid2.default)(),
				content: {}
			};
			function copy(template, device) {
				Object.keys(template).forEach(function (key) {
					return key != "image" && // TODO: !!!!!!!!
					key != "content" && key != "type" && (device[key] = template[key]);
				});
				return device;
			}
			function walk(template, id) {
				if (template.content || template.type == "place") {
					(function () {
						var content = {};
						devices.content[id] = copy(template, { type: "place", content: content });
						var index = 0;
						template.content && template.content.forEach(function (p) {
							return content[walk(p, (0, _uid2.default)())] = { index: index++ };
						});
					})();
				} else {
					devices.content[id] = copy(template, { type: "single" });
				}
				return id;
			}
			devices.main = walk(template, (0, _uid2.default)());
			this.setDatabase(devices);
		},

		get templates() {
			return regeneratorRuntime.mark(function callee$2$0() {
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							context$3$0.prev = 0;
							context$3$0.next = 3;
							return httpClient.get("/templates");

						case 3:
							return context$3$0.abrupt("return", context$3$0.sent);

						case 6:
							context$3$0.prev = 6;
							context$3$0.t0 = context$3$0["catch"](0);
							return context$3$0.abrupt("return", context$3$0.t0);

						case 9:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[0, 6]]);
			}).call(this);
		},

		get allMessages() {
			return regeneratorRuntime.mark(function callee$2$0() {
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							context$3$0.next = 2;
							return httpClient.get("/messages");

						case 2:
							return context$3$0.abrupt("return", context$3$0.sent);

						case 3:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}).call(this);
		},

		get messages() {
			var allMessages = this.allMessages;
			if (allMessages == null) return;
			var ret = {};
			var language = local.language || "ru";
			lodash.forOwn(allMessages, function (value, key) {
				return ret[key] = Object.prototype.hasOwnProperty.call(value, language) ? value[language] : key;
			});
			return ret;
		},

		message: function message(id) {
			var ret = this.messages && this.messages[id];
			if (ret == null) ret = id;
			return ret;
		},

		notification: function notification(message) {
			// alert( message )
		},

		saveDevice: function saveDevice(deviceId, device) {
			var diff = Diff.make(this.getDevice(deviceId), device);
			return diff == null ? Promise.resolve() : this.serverDevices.update({ content: _defineProperty({}, deviceId, diff) });
		},

		newIndex: function newIndex(iconId) {
			return Object.keys(this.getDevice(iconId).content || {}).length + 1;
		},

		linkItem: function linkItem(iconId, itemId, extra) {
			return co.go(regeneratorRuntime.mark(function callee$2$0() {
				var place, device, rec, packet, result;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!(iconId == itemId)) {
								context$3$0.next = 2;
								break;
							}

							throw new Error("cannot link place to itself");

						case 2:
							place = this.getDevice(iconId);
							device = this.getDevice(itemId);

							if (!(place.type == "group")) {
								context$3$0.next = 9;
								break;
							}

							if (place.group) {
								context$3$0.next = 7;
								break;
							}

							throw new Error("internal error: no GROUP number found");

						case 7:
							if (device.group) {
								context$3$0.next = 9;
								break;
							}

							throw new Error("cannot add unlinked device to a group");

						case 9:
							rec = this.dbcache.open();

							co.defer(rec.close);
							packet = { content: _defineProperty({}, iconId, {
									__present__: true,
									content: _defineProperty({}, itemId, { index: this.newIndex(iconId) })
								}) };
							result = !extra ? packet : Diff.merge(extra, packet);

							rec.update(result);

							if (!(place.type == "group")) {
								context$3$0.next = 17;
								break;
							}

							context$3$0.next = 17;
							return this.command(itemId, "AppendTo", place.group);

						case 17:
							context$3$0.next = 19;
							return this.serverDevices.update(result);

						case 19:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}).bind(this));
		},

		linkToFavourites: function linkToFavourites(itemId) {
			return this.linkItem(this.main, itemId);
		},

		linkActiveToFavourites: function linkActiveToFavourites(itemId) {
			return this.linkToFavourites(this.activeDeviceId);
		},

		addItem: function addItem(iconId, item) {
			var id = arguments.length <= 2 || arguments[2] === undefined ? (0, _uid2.default)() : arguments[2];

			var _content5;

			var index = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

			return this.serverDevices.update({ content: (_content5 = {}, _defineProperty(_content5, iconId, { content: _defineProperty({}, id, { index: index != null ? index : this.newIndex(iconId) }) }), _defineProperty(_content5, id, item), _content5) });
		},

		addPlace: function addPlace(iconId) {
			return this.addItem(iconId, {
				type: "place",
				ru: "",
				en: "Room"
			});
		},

		addDevice: function addDevice(iconId) {
			return this.addItem(iconId, {
				type: "single",
				ru: "",
				en: "Device"
			});
		},

		addGroup: function addGroup(iconId, id) {
			return co.go(regeneratorRuntime.mark(function callee$2$0() {
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!id) id = (0, _uid2.default)();
							context$3$0.next = 3;
							return this.addItem(iconId, {
								type: "group",
								ru: "",
								en: "Group"
							}, id);

						case 3:
							context$3$0.next = 5;
							return this.command(id, "Reserve");

						case 5:
							return context$3$0.abrupt("return", id);

						case 6:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}).bind(this));
		},

		deleteItem: function deleteItem(iconId, itemId) {
			return co.go(regeneratorRuntime.mark(function callee$2$0() {
				var place, rec;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							place = this.getDevice(iconId);
							rec = this.dbcache.open();

							co.defer(rec.close);
							rec.update({ content: _defineProperty({}, iconId, { content: _defineProperty({}, itemId, null) }) });

							if (!(place.type == "group" && place.group)) {
								context$3$0.next = 7;
								break;
							}

							context$3$0.next = 7;
							return this.command(itemId, "RemoveFrom", place.group);

						case 7:
							context$3$0.next = 9;
							return this.serverDevices.update(rec.transformer());

						case 9:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}).bind(this));
		},

		insertInto: function insertInto(iconId, itemId, fromId) {
			return this.linkItem(iconId, itemId, { content: _defineProperty({}, fromId, { content: _defineProperty({}, itemId, null) }) });
		},

		errors: null,
		throw: function _throw(dialog, data, retry) {
			if (!dialog) throw new Error("an error has to have its own dialog");
			this.errors = (this.errors || []).concat([{
				dialog: dialog,
				data: data,
				retry: retry
			}]);
		},
		clearError: function clearError() {
			var _this5 = this;

			_ra2.default.detach(function () {
				if (_this5.error) {
					_this5.dialog = "";
					_this5.errors = _this5.errors && _this5.errors.slice(1);
				}
			});
		},
		get checkError() {
			var _this6 = this;

			if (!this.dialog) if (this.errors && this.errors.length) _ra2.default.detach(function () {
				var error = _this6.errors[0];
				_this6.errors = _this6.errors && _this6.errors.slice(1);
				_this6.dialog = error.dialog;
				_this6.error = error;
			});else this.error = null;
		},
		error: null,

		purgeItem: function purgeItem(deviceId, force) {
			return co.go(regeneratorRuntime.mark(function callee$2$0() {
				var device, rec, cmd;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							device = this.getDevice(deviceId);
							rec = this.dbcache.open();

							co.defer(regeneratorRuntime.mark(function callee$3$0() {
								return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
									while (1) switch (context$4$0.prev = context$4$0.next) {
										case 0:
											if (!force) {
												context$4$0.next = 3;
												break;
											}

											context$4$0.next = 3;
											return rec.save();

										case 3:
											rec.close();
											// server MUST send us actual state BEFORE returning result of command execution
											if ((lu.valueOf(this.serverDevices.data) || 1)[deviceId]) this.throw("ErrorUnlinkingDevice", { deviceId: deviceId });

										case 5:
										case "end":
											return context$4$0.stop();
									}
								}, callee$3$0, this);
							}).bind(this));
							rec.update(devdb.Clear(this.devices, deviceId));
							cmd = undefined;

							if (device && device.group != null) if (device.type == "group") cmd = "Clear";else if (device.type == "single") cmd = "Unlink";

							if (!cmd) {
								context$3$0.next = 11;
								break;
							}

							context$3$0.next = 9;
							return this.command(deviceId, cmd);

						case 9:
							context$3$0.next = 13;
							break;

						case 11:
							context$3$0.next = 13;
							return this.serverDevices.update(rec.transformer());

						case 13:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}).bind(this));
		},

		renameItem: function renameItem(itemId, name) {
			var ret = lodash.reduce(this.getDevice(itemId), function (ret, _, key) {
				if (key.length == 2) ret[key] = null;
				return ret;
			}, {});
			ret[localDefaults.language || "ru"] = name;
			return this.serverDevices.update({ content: _defineProperty({}, itemId, ret) });
		},

		changePicture: function changePicture(itemId, icon) {
			return this.serverDevices.update({ content: _defineProperty({}, itemId, { icon: icon }) });
		},

		command: function command(deviceId, cmd, data) {

			// debugger

			// TODO:
			// let newstate = deviceActions.getNewState( this.getDevice( deviceId ), cmd )
			// if ( newstate != null ) {
			// }
			return this.commands.ask({ device: deviceId, command: cmd, data: data }).detach();
		},

		iconCommand: function iconCommand(icon, iconId, cmd, data) {
			// console.log( icon, iconId, cmd )
			icon = lu.valueOf(icon);
			if (icon.type == "place" ? cmd == "Short" : cmd == "Long") return this.go(iconId);
			if (icon.type != "place" && !icon.group) {
				this.dialog = "AskToLinkDevice";
				this.linkingPlaceId = iconId;
				// return Promise.reject( new Error( `device not configured` ) )
				return Promise.resolve();
			}
			if (cmd == "Short" || cmd == "Long") {
				if (icon && icon.state) {
					cmd = "Set";
					data = 0;
				} else {
					cmd = "Set";
					data = 1;
				}
				// cmd = `Comfort_1`
			}
			return this.command(iconId, cmd, data);
		},

		focus: function focus(node) {
			// magic actions to force allow to show keyboard by input.focus() on iOS ( so far checked iOS 8 )
			setTimeout(function () {
				return node.focus();
			}, 400);
		},

		searchAction: null,
		searchFilter: null,
		get checkSearchDialog() {
			if (this.dialog != "SearchItems" && this.dialog != "SearchPictures") {
				this.searchAction = null;
				this.searchFilter = null;
			}
		},

		icons: null,

		modules: new WeakMap(),
		_load: function _load(module) {
			if (module && Object.prototype.hasOwnProperty.call(module, "default")) module = module.default;
			var ret = this.modules.get(module);
			if (ret == null) {
				ret = module(app, local);
				this.modules.set(module, ret);
			}
			return ret;
		},
		load: _ra2.default.Value(function () {
			var module = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];

			if (typeof module.then == "function") return module.then(app._load);else return app._load(module);
		}),

		hover: null,

		debugger: function _debugger() {
			debugger;
		}

	}).setName("app");

	return { app: app, local: local };
};

module.exports = exports.default;

// yield Promise.race( [ co.promise( script ), co.timeout( 15000 ) ] )

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"JSONDuplex":234,"JSONlocal":235,"_process":192,"co":238,"commands":239,"dbcache":241,"devdb":242,"diff":243,"events":188,"httpClient":247,"localUtils":249,"lodash":232,"pingpongStream":253,"ra":255,"sf":256,"themes":258,"uid":281,"websocketStream":283,"windowSize":284}],234:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _JSONStream = require("JSONStream");

var JSONStream = _interopRequireWildcard(_JSONStream);

var _sf = require("sf");

var sf = _interopRequireWildcard(_sf);

exports.default = function () {
	return sf.duplexer({
		readableObjectMode: true,
		writableObjectMode: true,
		otherReadableObjectMode: false,
		otherWritableObjectMode: false
	}, JSONStream.stringify(false), JSONStream.parse());
};

//TODO: paste a bugreport that JSONStream.parse() returns not an instance of readable -- i mean, it has no read() method.
module.exports = exports.default;

},{"JSONStream":1,"sf":256}],237:[function(require,module,exports){
(function (process){
"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var setTimeout = window.setTimeout;
// let setInterval = window.setInterval

process.nextTick = nextTick;

var queue = [];
var timer = null;
var processing = false;
var current = 0;
var secret = "process-tick-" + Math.random();

var installTimer = function installTimer() {
	timer = setTimeout(onTimer, 1);
};

if (window.postMessage && window.addEventListener) {
	(function () {
		window.addEventListener("message", function (ev) {
			var source = ev.source;
			if ((source == window || source == null) && ev.data == secret) {
				ev.stopPropagation();
				onTimer();
			}
		});
		var postMessage = window.postMessage;
		installTimer = function () {
			postMessage(secret, "*");
			timer = true;
		};
	})();
}

var _arr = ["setTimeout", "setInterval", "requestAnimationFrame"];

var _loop = function () {
	var name = _arr[_i];
	var proc = hookMethod(window, name, function (handler, time) {
		if (typeof arguments[0] == "function") arguments[0] = getProxy(arguments[0]);
		return proc.apply(this, arguments);
	});
};

for (var _i = 0; _i < _arr.length; _i++) {
	_loop();
}

![window, document].forEach(hookEventListener);

function onTimer() {
	timer = null;
	checkQueue();
}

function ensureTimer() {
	if (!timer && !processing) installTimer();
}

nextTick._dbg = null;
function DEBUGGER() {
	debugger;
}

function nextTick(fun) {
	if (nextTick._dbg && nextTick._dbg()) DEBUGGER();
	var args = undefined;
	if (arguments.length > 1) {
		var _fun;

		args = [];
		for (var i = 1; i < arguments.length; ++i) {
			args.push(arguments[i]);
		}fun = (_fun = fun).bind.apply(_fun, [null].concat(_toConsumableArray(args)));
	}
	queue.push(fun);
	ensureTimer();
}

function checkQueue() {
	if (!processing && queue.length > 0) processQueue();
}

function processQueue() {
	current = 0;
	processing = true;
	try {
		loopQueue();
	} finally {
		// console.log( `ticks: ` + index )
		processing = false;
		if (queue.length) {
			queue.splice(0, current);
			ensureTimer();
		}
	}
}

function loopQueue() {
	if (nextTick._dbg && nextTick._dbg()) DEBUGGER();
	while (current < queue.length) {
		if (current >= 0x10000) {
			queue.splice(0, current);
			current = 0;
		}
		queue[current++]();
		if (nextTick._dbg && nextTick._dbg()) DEBUGGER();
	}
	queue.length = 0;
}

function getProxy(handler) {
	function proxy() {
		var ret = handler.handleEvent ? handler.handleEvent.apply(handler, arguments) : handler.apply(this, arguments);
		checkQueue();
		return ret;
	}
	var ret = undefined;
	if ((ret = handler[secret]) != null) return ret;else {
		assignProperty(proxy, secret, proxy);
		return assignProperty(handler, secret, proxy);
	}
}

function hookEventListener(obj) {
	if (obj.addEventListener) {
		(function () {
			var addEventListener = hookMethod(obj, "addEventListener", function (event, handler) {
				arguments[1] = getProxy(arguments[1]);
				return addEventListener.apply(this, arguments);
			});
			var removeEventListener = hookMethod(obj, "removeEventListener", function (event, handler) {
				if (arguments[1][secret]) arguments[1] = arguments[1][secret];
				return removeEventListener.apply(this, arguments);
			});
		})();
	}
}

function hookMethod(obj, name, proxy) {
	var ret = obj[name];
	if (ret) {
		assignProperty(proxy, "toString", function () {
			return ret.toString();
		});
		obj[name] = proxy;
	}
	return ret;
}

function assignProperty(obj, name, value) {
	if (Object.defineProperty) Object.defineProperty(obj, name, { value: value });else obj[name] = value;
	return value;
}

}).call(this,require('_process'))

},{"_process":192}],239:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _diff = require("diff");

var Diff = _interopRequireWildcard(_diff);

var SetState = {
	db: function db(options, _db, id, state) {
		var _id;

		return { content: _defineProperty({}, id, (_id = {
				__present__: true
			}, _defineProperty(_id, ((options || 0).mode || "") + "state", state), _defineProperty(_id, "errorneous", null), _id)) };
	},
	cmd: function cmd(db, id, state) {}
};
exports.SetState = SetState;

},{"diff":243}],240:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

exports.load = load;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _co = require("co");

var co = _interopRequireWildcard(_co);

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var _log = require("log");

var Log = _interopRequireWildcard(_log);

var log = Log.open("ui");

function toNode(child, node) {
	restart: for (;;) {
		child = child && typeof child.valueOf == "function" ? child.valueOf() : child;
		if (Array.isArray(child)) {
			if (child.length == 0) return null;
			if (child.length == 1) {
				child = child[0];
				continue restart;
			}
			if (!node) node = document.createDocumentFragment();
			child.forEach(function (child) {
				return toNode(child, node);
			});
			child = node;
		} else {
			if (typeof child == "string") child = document.createTextNode(child);
			if (node) {
				node.appendChild(child);
				child = node;
			}
		}
		return child;
	}
}

var requestReflow = typeof cancelAnimationFrame == "function" ? requestAnimationFrame : setTimeout;

var requestDocumentTouch = (function () {
	// workaround of weblit/blink bug: sometimes document does not update its state after className of some element is changed
	var timeout = undefined;
	var touchDocument = function touchDocument() {
		timeout = null;
		// trying to force reflow
		var div = document.createElement("div");
		div.style.position = "fixed";
		div.style.right = div.style.bottom = "1px";
		div.style.width = div.style.height = "1px";
		// TODO: ATTENTION: check that alpha-channel do not freeze animations on page
		div.style.backgroundColor = "rgba( 0, 0, 0, 0.01 )";
		div.style.pointerEvents = "none";
		div.style.zIndex = 1e99;
		document.body.appendChild(div);
		setTimeout(function () {
			return document.body.removeChild(div);
		}, 100); // 100ms seems to be enough. if it is equal to 1 than no effect is present.
	};return function () {
		return timeout || (timeout = setTimeout(touchDocument));
	};

	// ;() => timeout || ( later( touchDocument ), timeout = true )
})();

var waitUntilReflow = (function () {
	var frame = undefined;
	var reflow = function reflow(resolve) {
		return requestReflow(function () {
			frame = null;
			requestDocumentTouch();
			resolve();
		});
	};return function () {
		return frame || (frame = new Promise(reflow));
	};
})();

function fcalc(f, cb) {
	if (typeof f != "function") cb(f);else {
		(function () {
			var first = true;
			(0, _ra2.default)(regeneratorRuntime.mark(function callee$2$0() {
				var ret;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!first) {
								context$3$0.next = 5;
								break;
							}

							first = false;
							requestDocumentTouch();
							context$3$0.next = 7;
							break;

						case 5:
							context$3$0.next = 7;
							return waitUntilReflow();

						case 7:
							ret = f();

							if (!(ret && ret.next && ret.throw)) {
								context$3$0.next = 12;
								break;
							}

							context$3$0.next = 11;
							return ret;

						case 11:
							ret = context$3$0.sent;

						case 12:
							cb(ret);

						case 13:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}));
		})();
	}
}

function setContent(control, content) {
	var cb = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	fcalc(content, function (content) {
		var c = toNode(content);
		if (c) {
			control.innerHTML = "";
			control.appendChild(c);
		} else control.innerHTML = "";
		cb && cb();
	});
}

function toAttrString(value) {
	if (Array.isArray(value)) return value.map(toAttrString).join(" ");else if (value) return "" + value;else return "";
}

function appendContent(content, f) {
	if (!f) f = document.createDocumentFragment();
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = content[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var c = _step.value;

			if (typeof c == "function") {
				var p = document.createElement("span");
				setContent(p, c);
				f.appendChild(p);
			} else if (c instanceof Node) f.appendChild(c);else if (c != null && typeof c != "string" && !(c instanceof String) && c[Symbol.iterator]) appendContent(c, f);else f.appendChild(document.createTextNode(c));
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator["return"]) {
				_iterator["return"]();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return f;
}

var GeneratorFunctionPrototype = Object.getPrototypeOf(regeneratorRuntime.mark(function callee$0$0() {
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
}));

function createElement(name, attributes, content) {
	if (typeof name == "function") return name(attributes && attributes._ ? Object.assign({}, attributes, attributes._, { _: null }) : attributes || false, appendContent(content));
	var onCreate = undefined;
	var ret = document.createElement(name);
	var classes = [];
	function applyAttributes(attributes) {
		if (attributes == null) return;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			var _loop = function () {
				var _step2$value = _slicedToArray(_step2.value, 2);

				var name = _step2$value[0];
				var value = _step2$value[1];

				if (name == "_") {// noop
				} else if (name == "class") classes.push(value);else if (name == "style")
						// TODO: smth like to "class" attribute - parse parent style and update it
						fcalc(value, function (value) {
							if (typeof value == "string") ret.setAttribute("style", value);else {
								var _iteratorNormalCompletion3 = true;
								var _didIteratorError3 = false;
								var _iteratorError3 = undefined;

								try {
									var _loop2 = function () {
										var _step3$value = _slicedToArray(_step3.value, 2);

										var name = _step3$value[0];
										var value = _step3$value[1];

										fcalc(value, function (value) {
											return ret.style[name] = value;
										});
									};

									for (var _iterator3 = lodash.pairs(value)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
										_loop2();
									}
								} catch (err) {
									_didIteratorError3 = true;
									_iteratorError3 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
											_iterator3["return"]();
										}
									} finally {
										if (_didIteratorError3) {
											throw _iteratorError3;
										}
									}
								}
							}
						});else if (name == "oncreate") onCreate = value;else if (name.match(/^on/)) {
						if (value != null) {
							if (typeof value == "function") value = [value];
							_iteratorNormalCompletion4 = true;
							_didIteratorError4 = false;
							_iteratorError4 = undefined;

							try {
								var _loop3 = function () {
									var handler = _step4.value;

									if (Object.getPrototypeOf(handler) == GeneratorFunctionPrototype) handler = co.eventHandler(handler);
									ret.addEventListener(name.slice("on".length), function (event) {
										log.log("event", name, event);
										return handler.call(this, event);
									});
								};

								for (_iterator4 = value[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
									_loop3();
								}
							} catch (err) {
								_didIteratorError4 = true;
								_iteratorError4 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
										_iterator4["return"]();
									}
								} finally {
									if (_didIteratorError4) {
										throw _iteratorError4;
									}
								}
							}
						}
					} else fcalc(value, function (value) {
						value = toAttrString(value);
						if (ret.getAttribute(name) != value) ret.setAttribute(name, value);
					});
			};

			for (var _iterator2 = lodash.pairs(attributes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var _iteratorNormalCompletion4;

				var _didIteratorError4;

				var _iteratorError4;

				var _iterator4, _step4;

				_loop();
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
					_iterator2["return"]();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		if (Object.prototype.hasOwnProperty.call(attributes, "_")) applyAttributes(attributes._);
	}
	applyAttributes(attributes);
	if (classes.length) {
		(function () {
			var copy = classes.map(function () {
				return null;
			});
			classes.forEach(function (c, i) {
				return fcalc(c, function (c) {
					copy[i] = c;
					var className = toAttrString(copy).replace(/(^|\s|\r|\n)(null|undefined|false|0|\-0|NaN)(?=$|\s|\r|\n)/g, "");
					if (ret.className != className) ret.className = className;
				});
			});
		})();
	}
	switch (content.length) {
		case 0:
			break;
		case 1:
			setContent(ret, content[0]);
			break;
		default:
			ret.appendChild(appendContent(content));
			break;
	}
	if (typeof onCreate == "function") {
		onCreate.call(ret, {
			type: "create",
			target: ret,
			srcElement: ret,
			currentTarget: ret
		});
	}
	return ret;
}

var _lastModule = undefined;

exports.createElement = createElementFromModule;

function createElementFromModule(name, attributes) {
	for (var _len = arguments.length, content = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		content[_key - 2] = arguments[_key];
	}

	var ret = createElement(name, attributes, content);
	_lastModule = ret;
	return ret;
}

function load(module) {
	return module && module.component || _lastModule;
}

var updateInputValue = function updateInputValue() {
	var _this = this;

	setTimeout(function () {
		return _this._raValue.assign(_this.value);
	});
};
var raValue = {
	get: function get() {
		var _this2 = this;

		if (!this._raValue) _ra2.default.detach(function () {
			_this2._raValue = (0, _ra2.default)();
			_this2._raValue.assign(_this2.value);
			_this2.addEventListener("change", updateInputValue);
			_this2.addEventListener("keypress", updateInputValue);
			_this2.addEventListener("keydown", updateInputValue);
			_this2.addEventListener("keyup", updateInputValue);
		});
		return this._raValue.valueOf();
	},
	set: function set(value) {
		if (this.value != value) {
			this.value = value;
			if (this._raValue) this._raValue.assign(this.value);
		}
	}
};

var _arr = [HTMLInputElement, HTMLTextAreaElement];
for (var _i = 0; _i < _arr.length; _i++) {
	var C = _arr[_i];
	Object.defineProperty(C.prototype, "raValue", raValue);
}

},{"co":238,"lodash":232,"log":250,"ra":255}],238:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x10, _x11, _x12) { var _again = true; _function: while (_again) { var object = _x10, property = _x11, receiver = _x12; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x10 = parent; _x11 = property; _x12 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

exports.read = read;
exports.write = write;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _stream = require("stream");

var stream = _interopRequireWildcard(_stream);

var coCurrent = null,
    coGlobal = Object.create(null);
exports.current = coCurrent;
exports.global = coGlobal;

var _debug = null;
var _killdebug = !true;
var DEBUGGER = function DEBUGGER() {
	debugger;
};

function __debug() {
	var thread = arguments.length <= 0 || arguments[0] === undefined ? coCurrent : arguments[0];
	var debug = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	return debug ? (_debug || (_debug = new WeakSet())).add(thread) : _debug && _debug.delete(thread);
}
exports._debug = __debug;
var go = function go(fun) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	if (typeof fun == "function") fun = fun.apply(undefined, args);
	if (typeof fun.next != "function") {
		(function () {
			var value = fun;
			fun = {
				next: function next() {
					var ret = { value: value, done: !value };
					value = null;
					return ret;
				}
			};
		})();
	}
	return new Thread(fun, false);
};

exports.go = go;
var func = function func(fun) {
	if (arguments.length >= 2) fun = Array.prototype.reduceRight.call(arguments, function (g, f) {
		return f(g);
	});
	return function proc() {
		return new Thread(fun.apply(this, arguments), true);
	};
};

exports.func = func;
var eventHandler = function eventHandler(fun) {
	return function proc() {
		var ret = new Thread(fun.apply(this, arguments), true);
		ret.waitForInput();
		return ret;
	};
};

exports.eventHandler = eventHandler;
// the first argument is an error, the second one is a result
var cbfunc = function cbfunc(funWithCB) {
	return function () {
		var _this = this;

		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		return new Promise(function (resolve, reject) {
			return funWithCB.call.apply(funWithCB, [_this].concat(args, [function (error, value) {
				return error == null ? resolve(value) : reject(error);
			}]));
		});
	};
};

exports.cbfunc = cbfunc;
var killablePromise = function killablePromise(callback) {
	return new Promise(function (resolve, reject) {
		// return callback( resolve, reject )
		var done = false;
		var makeProc = function makeProc(proc) {
			return function (value) {
				if (done) return;
				done = true;
				try {
					return proc(value);
				} finally {
					def.close();
					kill && kill();
				}
			};
		};
		var call_reject = makeProc(reject);
		var def = defer(call_reject);
		var kill = callback(makeProc(resolve), call_reject);
	});
};

var receive = function receive(emitter, events) {
	return killablePromise(function (resolve, reject) {
		var handlers = Object.create(null);
		var timer = undefined;

		var _loop = function (_event) {
			if (Object.prototype.hasOwnProperty.call(events, _event)) {
				var _ret3 = (function () {
					var predicate = events[_event];
					if (predicate == null)
						//
						// allow simpler events defining like
						//
						// yield co.receive( obj, { data: true, timeout: getTimeout( ... ) } )
						//
						// instead of
						//
						// let events = { data: true }
						// if ( getTimeout( ... ) != null ) events.timeout = getTimeout( ... )
						// yield co.receive( obj, events )
						//
						return {
							v: "continue"
						};
					if (_event == "timeout") timer = setTimeout(function () {
						return resolve({ event: "timeout", data: null });
					}, predicate);else emitter.addListener(_event, handlers[_event] = function (data) {
						if (typeof predicate != "function" || predicate(data)) resolve({ event: _event, data: data });
					});
				})();

				if (typeof _ret3 === "object") return _ret3.v;
			}
		};

		for (var _event in events) {
			var _ret2 = _loop(_event);

			if (_ret2 === "continue") continue;
		}return function () {
			if (!handlers) return;
			clearTimeout(timer);
			for (var _event2 in handlers) {
				emitter.removeListener(_event2, handlers[_event2]);
			}handlers = null;
		};
	});
};

exports.receive = receive;
var cbPromises = undefined;

var cb = function cb(f) {
	if (!cbPromises) cbPromises = new WeakMap();else if (cbPromises.has(coGlobal)) throw new Error("co.wait must be called after previous co.cb call");
	var ret = null;
	cbPromises.set(coGlobal, new Promise(function (resolve, reject) {
		return ret = function (error, result) {
			return error ? reject(error) : resolve(result);
		};
	}));
	return ret;
};

exports.cb = cb;
var wait = function wait() {
	var ret = cbPromises && cbPromises.get(coGlobal);
	if (!ret) throw new Error("co.wait must be called after co.cb call");
	cbPromises.delete(coGlobal);
	return ret;
};

exports.wait = wait;
var sleep = function sleep(milliseconds) {
	return { then: function then(resolve) {
			var timer = setTimeout(resolve, milliseconds);
			return { kill: function kill() {
					clearTimeout(timer);
				} };
		} };
};

exports.sleep = sleep;
var tick = sleep(1);

exports.tick = tick;
var timeout = function timeout(milliseconds) {
	return { then: function then(_, reject) {
			var timer = setTimeout(reject, milliseconds);
			return { kill: function kill() {
					clearTimeout(timer);
				} };
		} };
};

exports.timeout = timeout;
var promise = function promise(value) {
	return Promise.all([go(regeneratorRuntime.mark(function callee$1$0() {
		return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
			while (1) switch (context$2$0.prev = context$2$0.next) {
				case 0:
					context$2$0.next = 2;
					return value;

				case 2:
				case "end":
					return context$2$0.stop();
			}
		}, callee$1$0, this);
	}))]);
};

exports.promise = promise;
var coRequestAnimationFrame = { then: function then(resolve) {
		if (typeof cancelAnimationFrame == "function") {
			var _ret4 = (function () {
				var frame = requestAnimationFrame(resolve);
				return {
					v: { kill: function kill() {
							cancelAnimationFrame(frame);
						} }
				};
			})();

			if (typeof _ret4 === "object") return _ret4.v;
		} else return sleep(1).then(resolve);
	} };
exports.requestAnimationFrame = coRequestAnimationFrame;
var wrap = function wrap(proc) {
	return coCurrent ? coCurrent.wrap(proc) : proc;
};

exports.wrap = wrap;
var resolved = (function () {
	var resolve = function resolve(value, callback) {
		return callback(value);
	};
	return function (value) {
		return { then: resolve.bind(null, value) };
	};
})();

function read() {
	var stream = this;
	var value = stream.read();
	if (value != null || !stream.readable) return resolved(value);
	return receive(stream, { readable: true }).then(function () {
		return stream.read();
	});
}

function write(data, chunk) {
	var stream = this;
	if (stream.write(data, chunk)) return null;else return receive(stream, { drain: true, end: true, finish: true });
}

var rethrow = function rethrow(e) {
	process.nextTick(function () {
		throw e;
	});
};

var noop = function noop() {};

function iteratorFailed(error) {
	return { done: true, iteratorFailed: true, value: error };
}

function iteratorNext(iterator, result) {
	try {
		return iterator.next(result);
	} catch (error) {
		return iteratorFailed(error);
	}
}

function iteratorThrow(iterator, result) {
	if (!iterator.throw) return iteratorFailed(result);
	try {
		return iterator.throw(result);
	} catch (error) {
		return iteratorFailed(error);
	}
}

var DONE = { done: true };

var EKill = (function (_Error) {
	_inherits(EKill, _Error);

	function EKill() {
		var message = arguments.length <= 0 || arguments[0] === undefined ? "kill" : arguments[0];

		_classCallCheck(this, EKill);

		_get(Object.getPrototypeOf(EKill.prototype), "constructor", this).call(this, message);
	}

	return EKill;
})(Error);

exports.EKill = EKill;

var FINALIZING = new EKill("finalizing");

function iteratorReturn(iterator, value) {
	if (iterator.return) {
		try {
			var v = iterator.return(value);
			if (!v || !v.done) rethrow(new Error("thread has eaten return()"));
		} catch (error) {
			rethrow(new Error("thread has eaten return() and thrown an exception"));
			return iteratorFailed(error);
		}
	} else if (iterator.throw) {
		var e = new EKill();
		var v = iteratorThrow(iterator, e);
		if (!v || !v.done || !v.iteratorFailed) rethrow(new Error("thread has eaten EKill"));else if (v.value != e) return v;
	}
	return DONE;
}

function killIterator(iterator, value) {
	if (iterator) {
		var res = iteratorReturn(iterator, value);
		if (res.done && res.iteratorFailed) rethrow(res.value);
	}
	return DONE;
}

// Thread

var dummyIterator = {
	next: function next() {
		return DONE;
	},
	throw: function _throw(error) {
		throw error;
	},
	return: function _return(value) {
		return { value: value, done: true };
	}
};

var defer = function defer(proc) {
	if (typeof proc != "function") throw new Error("only functions can be deferred");
	var thread = coCurrent;
	if (!thread || !thread._current) throw new Error("not in a thread");
	var iterator = dummyIterator;
	function createIterator() {
		if (proc) {
			// Keep in mind exceptions. Save state consistent in case of exception in proc().
			var p = proc;
			proc = null;
			var i = p();
			if (i && typeof i.next == "function") iterator = i;
			deferRec._iterator = iterator;
		}
		return iterator;
	}
	var lazyIteratorProxy = {
		next: function next(value) {
			return createIterator().next(value);
		},
		throw: function _throw(error) {
			createIterator();
			return iterator.throw ? iterator.throw(error) : dummyIterator.throw(error);
		},
		return: function _return(value) {
			if (proc)
				// let deffered iterator do at least one step
				createIterator().next(undefined);
			if (iterator.return) return iterator.return(value);else {
				if (iterator.throw) !(function () {
					var ekill = new EKill("return");
					try {
						iterator.throw(ekill);
					} catch (error) {
						if (error != ekill) throw error;
					}
				})();
				return dummyIterator.return(value);
			}
		}
	};
	var deferRec = new IteratorRec(thread, lazyIteratorProxy, thread._current._caller);
	thread._stack.push(deferRec);
	return { close: function close() {
			proc = null;
		} };
};

exports.defer = defer;
var nextTick = function nextTick(proc) {
	return coCurrent ? coCurrent.nextTick(proc) : process.nextTick(proc);
};

exports.nextTick = nextTick;

var IteratorRec = (function () {
	function IteratorRec(thread, iterator, caller) {
		_classCallCheck(this, IteratorRec);

		this._thread = thread;
		this._caller = caller;
		this._iterator = iterator;
		this._method = iteratorNext;
		this._value = undefined;
		this._currentPromise = null;
		this._next = this._next.bind(this);
		this._throw = this._throw.bind(this);
		this._cb = this._cb.bind(this);
	}

	_createClass(IteratorRec, [{
		key: "_store",
		value: function _store(value, isError) {
			if (isError) {
				if (this._method == iteratorThrow) rethrow(this._value);else this._method = iteratorThrow;
				this._value = value;
			} else if (this._method == null) {
				this._method = iteratorNext;
				this._value = value;
			}
		}
	}, {
		key: "_onvalue",
		value: function _onvalue(method, value) {
			if (_debug && _debug.has(this._thread)) DEBUGGER();
			this._currentPromise = null;
			if (this._thread) {
				this._value = value;
				this._method = method;
				process.nextTick(this._thread._processIterator);
			}
		}
	}, {
		key: "_next",
		value: function _next(value) {
			this._onvalue(iteratorNext, value);
		}
	}, {
		key: "_throw",
		value: function _throw(error) {
			if (!this._thread) rethrow(error);
			this._onvalue(iteratorThrow, error);
		}
	}, {
		key: "_cb",
		value: function _cb(error, data) {
			if (error) this._throw(error);else this._next(data);
		}
	}]);

	return IteratorRec;
})();

function _onsuccess(event) {
	this._next(event.target.result);
}

function _onload(event) {
	this._next(event.target);
}

function _onerror(event) {
	this._throw(event.target.error || event);
}

function getStack() {
	var n = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	var m = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	try {
		throw new Error("xxx");
	} catch (error) {
		return error.stack.split("\n").filter(Boolean).slice(3 + n, m ? -m : Infinity);
	}
}

var Child = (function () {
	function Child() {
		_classCallCheck(this, Child);

		this._owner = null;
	}

	_createClass(Child, [{
		key: "_kill",
		value: function _kill() {
			this.detach();
		}
	}, {
		key: "detach",
		value: function detach() {
			if (this._owner) this._owner._unlinkChild(this);
			return this;
		}
	}, {
		key: "attach",
		value: function attach(owner) {
			owner._linkChild(this);
		}
	}]);

	return Child;
})();

var Thread = (function (_Child) {
	_inherits(Thread, _Child);

	function Thread(iterator, standalone) {
		var _this2 = this;

		_classCallCheck(this, Thread);

		_get(Object.getPrototypeOf(Thread.prototype), "constructor", this).call(this);
		this._dbg = getStack();
		this._processTicks = this._processTicks.bind(this);
		this._processIterator = this._processIterator.bind(this);
		this._promise = new Promise(function (resolve, reject) {
			_this2._resolve = resolve;
			_this2._reject = reject;
		});
		var it = new IteratorRec(this, null, null);
		it._method = null;
		this._stack = [it, new IteratorRec(this, iterator, it)];
		this._ticks = [];
		this._index = 0;
		this._current = null;
		this._started = false;
		this._killing = null;
		this._children = null;
		this.global = Object.create(null);
		if (!standalone && coCurrent) this.attach(coCurrent);
		process.nextTick(this._processIterator);
	}

	_createClass(Thread, [{
		key: "waitForInput",
		value: function waitForInput() {
			if (this._ticks.length > 0) throw new Error("unplanned behaviour: ticks also must be done on waitForInput, but this is not implemented");
			if (!this._started) {
				this._processIterator();
				if (this._stack.length > 0 && !this._killing) this._stack.push(null); // compensate extra _processIterator call.
			}
			return this;
		}
	}, {
		key: "nextTick",
		value: function nextTick(tick) {
			if (process.nextTick._dbg && process.nextTick._dbg()) DEBUGGER();
			if (this._ticks.length == 0) process.nextTick(this._processTicks);
			this._ticks.push(tick);
		}
	}, {
		key: "then",
		value: function then(onFulfilled, onRejected) {
			return this._attachPromise(this._promise.then(onFulfilled, onRejected));
		}
	}, {
		key: "catch",
		value: function _catch(onRejected) {
			return this._attachPromise(this._promise.catch(onRejected));
		}
	}, {
		key: "isFinished",
		value: function isFinished() {
			return this._stack.length == 0;
		}
	}, {
		key: "throw",
		value: function _throw(error) {
			if (this._current) throw error;
			this._checkFinished();
			var it = this._stack.pop();
			var jt = new IteratorRec(this, it._iterator, it._caller);
			it._thread = it._iterator = it._caller = null;
			this._stack.push(jt);
			jt._throw(error);
		}
	}, {
		key: "finish",
		value: function finish(proc) {
			try {
				this.return(proc());
			} catch (e) {
				this.kill(e);
			}
		}
	}, {
		key: "return",
		value: function _return(result) {
			return this._killingByUser(result, false);
		}
	}, {
		key: "kill",
		value: function kill(reason) {
			return this._killingByUser(reason, true);
		}
	}, {
		key: "killChildren",
		value: function killChildren(reason) {
			if (this._children) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this._children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var c = _step.value;

						if (_debug && _debug.has(c)) DEBUGGER();
						if (_killdebug && !c._killing) DEBUGGER();
						c._owner = null;
						c._kill(reason, reason !== undefined);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator["return"]) {
							_iterator["return"]();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				this._children.clear();
			}
		}
	}, {
		key: "propogateChildrenToOwner",
		value: function propogateChildrenToOwner() {
			if (!this._children) return;
			if (this._owner) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = this._children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var c = _step2.value;

						c._owner = null;
						this._owner._linkChild(c);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}this._children.clear();
		}
	}, {
		key: "_linkChild",
		value: function _linkChild(child) {
			if (this._killing) throw new Error("CREATING CHILD WHILE KILLING OWNER!!!");
			if (child._owner != null) throw new Error("child already linked");
			if (!this._children) this._children = new Set();
			child._owner = this;
			this._children.add(child);
		}
	}, {
		key: "_unlinkChild",
		value: function _unlinkChild(child) {
			if (child._owner != this) throw new Error("not a child");
			child._owner = null;
			if (!this._killing && this._children) this._children.delete(child);
		}
	}, {
		key: "_processTicks",
		value: function _processTicks() {
			if (_debug && _debug.has(this)) DEBUGGER();
			var previousThread = coCurrent;
			var previousGlobal = coGlobal;
			exports.global = coGlobal = this.global;
			exports.current = coCurrent = this;
			try {
				this._callTicks(); // move loop to the function w/o try/finally to allow optimizations
			} finally {
				exports.global = coGlobal = previousGlobal;
				exports.current = coCurrent = previousThread;
				if (this._ticks.length > 0) {
					this._ticks.splice(0, this._index);
					process.nextTick(this._processTicks);
				}
			}
		}
	}, {
		key: "_callTicks",
		value: function _callTicks() {
			if (process.nextTick._dbg && process.nextTick._dbg()) DEBUGGER();
			var t = this._ticks;
			for (var i = 0; i < t.length; ++i) {
				this._index = i + 1;
				t[i]();
				if (process.nextTick._dbg && process.nextTick._dbg()) DEBUGGER();
			}
			t.length = 0;
		}
	}, {
		key: "call",
		value: function call(proc) {
			var previousThread = coCurrent;
			var previousGlobal = coGlobal;
			exports.global = coGlobal = this.global;
			exports.current = coCurrent = this;
			try {
				return proc();
			} finally {
				exports.global = coGlobal = previousGlobal;
				exports.current = coCurrent = previousThread;
			}
		}
	}, {
		key: "wrap",
		value: function wrap(proc) {
			var self = this;
			return function () {
				var _this3 = this,
				    _arguments2 = arguments;

				return self.call(function () {
					return proc.apply(_this3, _arguments2);
				});
			};
		}
	}, {
		key: "_finalize",
		value: function _finalize(it) {
			if (!this._killing) this._killing = FINALIZING;
			if (it._method == iteratorNext) this._resolve(it._value);else // it._method == iteratorThrow or it._method == null ( when killing )
				this._reject(it._value);
			if (this._owner) this._owner._unlinkChild(this);
			this.killChildren(it._method == iteratorNext ? undefined : it._value === undefined ? null : it._value);
			// _promise must be left to store thread result
			this._resolve = null;
			this._reject = null;
			this._current = null;
			this._children = null;
			this._owner = null;
		}
	}, {
		key: "_processIterator",
		value: function _processIterator() {
			if (_debug && _debug.has(this)) DEBUGGER();
			this._started = true;
			if (this._stack.length == 0) return;
			if (this._ticks.length > 0) {
				// do any ticks before yielding
				process.nextTick(this._processIterator);
				return;
			}
			var it = this._stack.pop();
			if (!it) return; // got compensated extra _processIterator call. see waitForInput.
			if (!this._killing && it._method == null) {
				debugger;
				throw new Error("it._method cannot be null");
			}
			if (this._stack.length == 0) {
				this._finalize(it);
				return;
			}
			this._current = it;
			var method = undefined,
			    value = undefined;
			if (!this._killing) {
				method = it._method;
				value = it._value;
			} else {
				method = killIterator;
				value = undefined;
			}
			it._method = null;
			it._value = null;
			it._currentPromise = null;
			var previousThread = coCurrent;
			var previousGlobal = coGlobal;
			exports.global = coGlobal = this.global;
			exports.current = coCurrent = this;
			var v = method(it._iterator, value);
			exports.global = coGlobal = previousGlobal;
			exports.current = coCurrent = previousThread;
			this._current = null;
			if (this._killing) {
				if (v.done && v.iteratorFailed && v.value != this._killing) rethrow(v.value);
				process.nextTick(this._processIterator);
				return;
			}
			if (v.done) {
				it._caller._store(v.value, v.iteratorFailed);
				process.nextTick(this._processIterator);
				return;
			}
			this._stack.push(it);
			if (v.value != null) {
				if (typeof v.value.then == "function") {
					var p = v.value.then(it._next, it._throw);
					if (p && typeof p.kill == "function") it._currentPromise = p;else if (typeof v.value.kill == "function") it._currentPromise = v.value;
					return;
				}
				if (typeof v.value.next == "function") {
					this._stack.push(new IteratorRec(this, v.value, it));
					process.nextTick(this._processIterator);
					return;
				}
				if (typeof v.value == "object") {
					if ("onerror" in v.value && !v.value.onerror) {
						if ("onload" in v.value && !v.value.onload) {
							v.value.onload = _onload.bind(it);
							v.value.onerror = _onerror.bind(it);
							return;
						}
						if ("onsuccess" in v.value && !v.value.onsuccess) {
							v.value.onsuccess = _onsuccess.bind(it);
							v.value.onerror = _onerror.bind(it);
							return;
						}
					}
				}
				// TODO: throw a type error here
			}
			it._next(undefined);
		}
	}, {
		key: "_attachPromise",
		value: function _attachPromise(promise) {
			promise.kill = this._kill.bind(this);
			return promise;
		}
	}, {
		key: "_killingByUser",
		value: function _killingByUser(reason, isError) {
			this._kill(reason, isError);
			if (this._current) throw this._killing;
			return this.then(noop, noop);
		}
	}, {
		key: "_kill",
		value: function _kill(reason, isError) {
			if (_debug && _debug.has(this)) DEBUGGER();
			if (!this._killing) {
				if (_killdebug) DEBUGGER();
				process.nextTick(this._processIterator);
				this._killing = new EKill(reason);
				if (this._owner) this._owner._unlinkChild(this);
				this.killChildren(!isError ? undefined : reason === undefined ? null : reason);
				if (this._stack.length > 0) this._stack[0]._store(reason, isError);
			}
		}
	}, {
		key: "_checkFinished",
		value: function _checkFinished() {
			if (this.isFinished()) throw new Error("thread is already finished");
		}
	}]);

	return Thread;
})(Child);

exports.Thread = Thread;

var pTRUE = Promise.resolve(true);
var pFALSE = Promise.resolve(false);
var pUNDEFINED = Promise.resolve();
var pDONE = Promise.resolve({ done: true, value: null });
var pNEVER = { then: function then(_) {} };

var yieldable = function yieldable(value) {
	return value && (typeof value.then == "function" || typeof value.next == "function");
};
var promisify = function promisify(value) {
	return yieldable(value) ? value : Promise.resolve(value);
};
var AND = function AND(data) {
	return data.every(Boolean);
};

function sendReturn() {
	var _this4 = this;

	this && process.nextTick(function () {
		return _this4.return();
	});
}

function throwTimeout() {
	throw new Error("timeout");
}

/*
Stream has multiple APIs.
Pipe has only one simple API.
pipe.next() returns Promise which evaluates to iterator.next-like object - { Boolean done, Object value }
pipe.push( value ) returns Promise which evaluates to Boolean. False is returned if a pipe is closed.
pipe.read() returns Promise. If there is no data then pipe.read() terminates calling thread. One must do finalize actions in co.defer or try/finally.
pipe.write( value ) returns Promise which evaluates when data is actually written. If pipe is ended then pipe.write terminates thread. One must do finalize actions in co.defer or try/finally.
*/

var End = (function () {
	function End(pipe) {
		_classCallCheck(this, End);

		this._pipe = pipe;
	}

	_createClass(End, [{
		key: "close",
		value: function close() {
			if (this._pipe) {
				this._pipe.close();
				this._pipe = null;
			}
		}
	}]);

	return End;
})();

var PipeData = (function () {
	function PipeData() {
		_classCallCheck(this, PipeData);

		this._data = [];
		this._readers = [];
	}

	_createClass(PipeData, [{
		key: "close",
		value: function close() {
			if (this._data) {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = this._data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var reject = _step3.value.reject;
						reject();
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
							_iterator3["return"]();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				this._data = null;
			}
			if (this._readers) {
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = this._readers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var reject = _step4.value.reject;
						reject();
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
							_iterator4["return"]();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				this._readers = null;
			}
		}
	}]);

	return PipeData;
})();

var Readable = (function (_End) {
	_inherits(Readable, _End);

	function Readable() {
		_classCallCheck(this, Readable);

		_get(Object.getPrototypeOf(Readable.prototype), "constructor", this).apply(this, arguments);
	}

	_createClass(Readable, [{
		key: "next",
		value: function next() {
			var _this5 = this;

			if (!this._pipe || !this._pipe._data) return pDONE;
			if (this._pipe._data.length) {
				var cell = this._pipe._data.shift();
				cell.resolve();
				return Promise.resolve({ done: false, value: cell.data });
			}
			return new Promise(function (_resolve) {
				return _this5._pipe._readers.push({ resolve: function resolve(value) {
						return _resolve({ done: false, value: value });
					}, reject: function reject() {
						return _resolve(DONE);
					} });
			});
		}
	}, {
		key: "read",
		value: function read() {
			var _this6 = this;

			var thread = arguments.length <= 0 || arguments[0] === undefined ? coCurrent : arguments[0];

			if (!this._pipe || !this._pipe._data) {
				sendReturn.call(thread);
				return pNEVER;
			}
			if (this._pipe._data.length) {
				var cell = this._pipe._data.shift();
				cell.resolve();
				return Promise.resolve(cell.data);
			}
			return new Promise(function (resolve) {
				return _this6._pipe._readers.push({ resolve: resolve, reject: sendReturn.bind(thread) });
			});
		}
	}, {
		key: "pipe",
		value: function pipe() {
			for (var _len3 = arguments.length, destinations = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				destinations[_key3] = arguments[_key3];
			}

			if (!destinations.length) return this.close();
			go(regeneratorRuntime.mark(function callee$2$0() {
				var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _loop2, _iterator5, _step5, dest, _loop3, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6;

				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					var _this7 = this;

					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							defer(function () {
								return _this7.close();
							});
							_iteratorNormalCompletion5 = true;
							_didIteratorError5 = false;
							_iteratorError5 = undefined;
							context$3$0.prev = 4;

							_loop2 = function () {
								var dest = _step5.value;

								defer(function () {
									return dest.close();
								});
							};

							for (_iterator5 = destinations[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
								_loop2();
							}context$3$0.next = 13;
							break;

						case 9:
							context$3$0.prev = 9;
							context$3$0.t0 = context$3$0["catch"](4);
							_didIteratorError5 = true;
							_iteratorError5 = context$3$0.t0;

						case 13:
							context$3$0.prev = 13;
							context$3$0.prev = 14;

							if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
								_iterator5["return"]();
							}

						case 16:
							context$3$0.prev = 16;

							if (!_didIteratorError5) {
								context$3$0.next = 19;
								break;
							}

							throw _iteratorError5;

						case 19:
							return context$3$0.finish(16);

						case 20:
							return context$3$0.finish(13);

						case 21:
							if (!(destinations.length == 1)) {
								context$3$0.next = 33;
								break;
							}

							dest = destinations[0];

						case 23:
							context$3$0.t1 = dest;
							context$3$0.next = 26;
							return this.read();

						case 26:
							context$3$0.t2 = context$3$0.sent;
							context$3$0.next = 29;
							return context$3$0.t1.write.call(context$3$0.t1, context$3$0.t2);

						case 29:
							context$3$0.next = 23;
							break;

						case 31:
							context$3$0.next = 37;
							break;

						case 33:
							_loop3 = regeneratorRuntime.mark(function callee$3$0() {
								var value, _promise;

								return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
									while (1) switch (context$4$0.prev = context$4$0.next) {
										case 0:
											context$4$0.next = 2;
											return this.read();

										case 2:
											value = context$4$0.sent;
											_iteratorNormalCompletion6 = true;
											_didIteratorError6 = false;
											_iteratorError6 = undefined;
											context$4$0.prev = 6;
											_iterator6 = destinations.map(function (dest) {
												return dest.write(value);
											})[Symbol.iterator]();

										case 8:
											if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
												context$4$0.next = 15;
												break;
											}

											_promise = _step6.value;
											context$4$0.next = 12;
											return _promise;

										case 12:
											_iteratorNormalCompletion6 = true;
											context$4$0.next = 8;
											break;

										case 15:
											context$4$0.next = 21;
											break;

										case 17:
											context$4$0.prev = 17;
											context$4$0.t0 = context$4$0["catch"](6);
											_didIteratorError6 = true;
											_iteratorError6 = context$4$0.t0;

										case 21:
											context$4$0.prev = 21;
											context$4$0.prev = 22;

											if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
												_iterator6["return"]();
											}

										case 24:
											context$4$0.prev = 24;

											if (!_didIteratorError6) {
												context$4$0.next = 27;
												break;
											}

											throw _iteratorError6;

										case 27:
											return context$4$0.finish(24);

										case 28:
											return context$4$0.finish(21);

										case 29:
										case "end":
											return context$4$0.stop();
									}
								}, callee$3$0, _this7, [[6, 17, 21, 29], [22,, 24, 28]]);
							});

						case 34:
							return context$3$0.delegateYield(_loop3(), "t3", 35);

						case 35:
							context$3$0.next = 34;
							break;

						case 37:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[4, 9, 13, 21], [14,, 16, 20]]);
			}).bind(this)).detach();
		}
	}, {
		key: "transform",
		value: function transform(fun) {
			var ret = new Pipe();
			var sread = this;
			var swrite = ret.in;
			go(regeneratorRuntime.mark(function callee$2$0() {
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							defer(function () {
								return ret.close();
							});
							context$3$0.next = 3;
							return fun(sread, swrite);

						case 3:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			})).detach();
			return ret.out;
		}
	}, {
		key: "map",
		value: function map(fun) {
			return this.transform(regeneratorRuntime.mark(function callee$2$0(sin, sout) {
				var value;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							context$3$0.next = 2;
							return sin.read();

						case 2:
							value = context$3$0.sent;
							context$3$0.t0 = sout;
							context$3$0.next = 6;
							return promisify(fun(value));

						case 6:
							context$3$0.t1 = context$3$0.sent;
							context$3$0.next = 9;
							return context$3$0.t0.write.call(context$3$0.t0, context$3$0.t1);

						case 9:
							context$3$0.next = 0;
							break;

						case 11:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}));
		}
	}, {
		key: "filter",
		value: function filter(fun) {
			return this.transform(regeneratorRuntime.mark(function callee$2$0(sin, sout) {
				var value;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							context$3$0.next = 2;
							return sin.read();

						case 2:
							value = context$3$0.sent;
							context$3$0.next = 5;
							return promisify(fun(value));

						case 5:
							if (!context$3$0.sent) {
								context$3$0.next = 8;
								break;
							}

							context$3$0.next = 8;
							return sout.write(value);

						case 8:
							context$3$0.next = 0;
							break;

						case 10:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}));
		}
	}, {
		key: "createStream",
		value: function createStream(options) {
			var _this8 = this;

			var ret = new stream.Readable(Object.assign({ objectMode: true }, options));
			var read = ret._read = function () {
				return _this8.next().then(function (_ref) {
					var done = _ref.done;
					var value = _ref.value;

					if (done) ret.push(null);else if (ret.push(value)) read();
				});
			};
			return ret;
		}
	}]);

	return Readable;
})(End);

var Writable = (function (_End2) {
	_inherits(Writable, _End2);

	function Writable() {
		_classCallCheck(this, Writable);

		_get(Object.getPrototypeOf(Writable.prototype), "constructor", this).apply(this, arguments);
	}

	// let statics = Class => {
	// let statics = Class.prototype._statics
	// if ( statics ) for ( let name of statics )
	// 	Class[ name ] = ( ...args ) => ( new Class )[ name ]( ...args )
	// }

	// let static_version = ( proto, name, desc ) => {
	// 	let statics = proto._statics || ( proto._statics = [] )
	// 	statics.push( name )
	// }

	// @statics

	_createClass(Writable, [{
		key: "push",
		value: function push(data) {
			var _this9 = this;

			if (!this._pipe || !this._pipe._readers) return pFALSE;
			if (this._pipe._readers.length) {
				this._pipe._readers.shift().resolve(data);
				return pTRUE;
			}
			return new Promise(function (_resolve2) {
				return _this9._pipe._data.push({ resolve: function resolve() {
						return _resolve2(true);
					}, reject: function reject() {
						return _resolve2(false);
					}, data: data });
			});
		}
	}, {
		key: "write",
		value: function write(data) {
			var _this10 = this;

			var thread = arguments.length <= 1 || arguments[1] === undefined ? coCurrent : arguments[1];

			if (!this._pipe || !this._pipe._readers) {
				sendReturn.call(thread);
				return pNEVER;
			}
			if (this._pipe._readers.length) {
				this._pipe._readers.shift().resolve(data);
				return pUNDEFINED;
			}
			return new Promise(function (resolve) {
				return _this10._pipe._data.push({ resolve: resolve, reject: sendReturn.bind(thread), data: data });
			});
		}
	}, {
		key: "createStream",
		value: function createStream(options) {
			var _this11 = this;

			var ret = new stream.Writable(Object.assign({ objectMode: true }, options));
			ret._write = function (chunk, encoding, callback) {
				return _this11.push(chunk).then(function (written) {
					callback();
					if (!written) ret.end();
				});
			};
			ret.on("end", function () {
				return _this11.close;
			});
			ret.on("finish", function () {
				return _this11.close;
			});
			return ret;
		}
	}]);

	return Writable;
})(End);

var Pipe = (function (_Child2) {
	_inherits(Pipe, _Child2);

	function Pipe(writable, readable) {
		_classCallCheck(this, Pipe);

		_get(Object.getPrototypeOf(Pipe.prototype), "constructor", this).call(this);
		if (readable && writable) {
			this._data = null;
			this.in = writable;
			this.out = readable;
		} else if (!readable && !writable) {
			this._data = new PipeData();
			this.in = new Writable(this._data);
			this.out = new Readable(this._data);
		} else throw new Error("Pipe: wrong parameters");
		this.close = this._kill.bind(this);
		if (coCurrent) this.attach(coCurrent);
	}

	_createClass(Pipe, [{
		key: "_kill",
		value: function _kill() {
			_get(Object.getPrototypeOf(Pipe.prototype), "_kill", this).call(this);
			if (this._data) {
				this._data.close();
				this._data = null;
			}
			if (this.in) {
				this.in.close();
				this.in = null;
			}
			if (this.out) {
				this.out.close();
				this.out = null;
			}
		}
	}, {
		key: "makeFunc",
		value: function makeFunc() {
			for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
				args[_key4] = arguments[_key4];
			}

			return Pipe.makeFunc.apply(Pipe, [this.in, this.out].concat(args));
		}
	}, {
		key: "fromStream",
		value: function fromStream(stream) {
			stream.pipe(this.in.createStream());
			return this.out;
		}
	}, {
		key: "toStream",
		value: function toStream(dest, options) {
			this.out.createStream(options).pipe(dest);
			return this.in;
		}
	}, {
		key: "pipe",
		value: function pipe() {
			var _out;

			(_out = this.out).pipe.apply(_out, arguments);
			return this.in;
		}
	}, {
		key: "transform",
		value: function transform(fun) {
			return new Pipe(this.in, this.out.transform(fun));
		}
	}, {
		key: "map",
		value: function map(fun) {
			return new Pipe(this.in, this.out.map(fun));
		}
	}, {
		key: "filter",
		value: function filter(fun) {
			return new Pipe(this.in, this.out.filter(fun));
		}
	}], [{
		key: "makeFunc",
		value: function makeFunc(sparam, sresult) {
			var timeout = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
			var timeoutProc = arguments.length <= 3 || arguments[3] === undefined ? throwTimeout : arguments[3];

			return function (value) {
				var ret = sparam.write(value).then(wrap(function () {
					return sresult.read();
				}));
				if (timeout) return new Promise(function (resolve, reject) {
					var t = setTimeout(function () {
						try {
							resolve(timeoutProc());
						} catch (e) {
							reject(e);
						}
					}, timeout);
					after(ret, function () {
						return clearTimeout(t);
					});
					ret.then(resolve, reject);
				});else return ret;
			};
		}
	}, {
		key: "create",
		value: function create() {
			var pipe = new Pipe();
			var stream = this;
			stream.pipe(pipe.in.createStream());
			return pipe.out;
		}
	}, {
		key: "fromStream",
		value: function fromStream(stream) {
			return new Pipe().fromStream(stream);
		}
	}, {
		key: "toStream",
		value: function toStream(dest, options) {
			return new Pipe().toStream(dest, options);
		}
	}, {
		key: "pipe",
		value: function pipe() {
			var _ref2;

			return (_ref2 = new Pipe()).pipe.apply(_ref2, arguments);
		}
	}, {
		key: "transform",
		value: function transform(fun) {
			return new Pipe().transform(fun);
		}
	}, {
		key: "map",
		value: function map(fun) {
			return new Pipe().map(fun);
		}
	}, {
		key: "filter",
		value: function filter(fun) {
			return new Pipe().filter(fun);
		}
	}]);

	return Pipe;
})(Child);

exports.Pipe = Pipe;

Pipe.NULL = new Pipe();
Pipe.NULL.close();

var after = function after(promise, proc) {
	var noResultNoArgs = function noResultNoArgs() {
		return proc && proc() && undefined;
	};
	return promise.then(noResultNoArgs, noResultNoArgs);
};

var synchronized = function synchronized(func) {
	var lock = pUNDEFINED;
	return function (value) {
		var onready = lock;
		var ret = go(regeneratorRuntime.mark(function callee$2$0() {
			return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						context$3$0.next = 2;
						return onready;

					case 2:
						context$3$0.next = 4;
						return func(value);

					case 4:
						return context$3$0.abrupt("return", context$3$0.sent);

					case 5:
					case "end":
						return context$3$0.stop();
				}
			}, callee$2$0, this);
		}));
		lock = after(ret);
		return ret;
	};
};
exports.synchronized = synchronized;

}).call(this,require('_process'))

},{"_process":192,"stream":210}],241:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _diff = require("diff");

var Diff = _interopRequireWildcard(_diff);

function noop() {}

function _apply(source, transformer) {
	return Diff.apply(source, transformer(source));
}

function getTransformer(transformer) {
	return typeof transformer == "function" ? transformer : function () {
		return transformer;
	};
}

exports.default = function () {
	var cache = (0, _ra2.default)({
		source: null,
		transformers: [(0, _ra2.default)({
			get result() {
				return cache.source;
			}
		})],
		get result() {
			return cache.transformers[cache.transformers.length - 1].result;
		},
		open: function open() {
			var transformer = arguments.length <= 0 || arguments[0] === undefined ? noop : arguments[0];

			transformer = getTransformer(transformer);
			var item = (0, _ra2.default)({
				transformer: _ra2.default.Value(transformer),
				get index() {
					return item && cache.transformers.indexOf(item);
				},
				get source() {
					return item && cache.transformers[item.index - 1].result;
				},
				get result() {
					if (!item) return null;
					var r = _apply(item.source, item.transformer);
					if (item.result) r = Diff.apply(item.result, r, false);
					return r;
				},
				close: function close() {
					if (item) {
						cache.transformers = cache.transformers.filter(function (i) {
							return i != item;
						});
						item = null;
					}
				},
				update: function update(new_transformer) {
					transformer = item.transformer = getTransformer(new_transformer);
				},
				apply: function apply(db) {
					return _apply(db, transformer);
				}
			});
			cache.transformers = cache.transformers.concat([item]);
			return item;
		}
	});
	return cache;
};

module.exports = exports.default;

},{"diff":243,"ra":255}],243:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.change = change;
exports.apply = apply;
exports.merge = merge;
exports.make = make;
var LiteralPrototype = Object.getPrototypeOf({});

var isSet = function isSet(obj) {
	if (obj == null) return false;
	var proto = Object.getPrototypeOf(obj);
	return proto === LiteralPrototype || proto === null;
};

var NON_PARTIAL = Object.create(null);
NON_PARTIAL.__partial__ = false;

var PARTIAL = Object.create(null);

function change(dest, path, diff, partial) {
	var x = dest,
	    rdiff = {},
	    pdiff = rdiff;
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var index = _step.value;

			x = x[index];
			if (x == null) return dest;
			pdiff = pdiff[index] = {};
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator["return"]) {
				_iterator["return"]();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	Object.assign(pdiff, diff);
	if (pdiff.__partial__ == null && partial === false) pdiff.__partial__ = false;
	return apply(dest, rdiff);
}

function apply(dest, diff, partial) {

	if (dest == null && diff != null && diff.__present__) return dest;

	var ret = dest;
	var cnt = 0;

	function copyDest() {
		ret = Object.create(null);
		for (var key in dest) {
			if (Object.prototype.hasOwnProperty.call(dest, key)) {
				var value = dest[key];
				if (value === undefined) continue;
				ret[key] = dest[key];
				++cnt;
			}
		}
	}

	if (diff && diff.__partial__ === false) partial = false;

	for (var key in diff) {
		if (key != "__partial__" && key != "__present__" && Object.prototype.hasOwnProperty.call(diff, key)) {
			var value = diff[key];
			if (value === undefined) continue;
			if (value != null && typeof value == "object") value = apply(ret && ret[key], value, partial);
			if (value == null) {
				if (ret != null && Object.prototype.hasOwnProperty.call(ret, key)) {
					if (ret === dest) copyDest();
					delete ret[key];
					--cnt;
				}
			} else {
				if (ret == null || ret[key] !== value) {
					if (ret === dest) copyDest();
					ret[key] = value;
				}
				cnt = Infinity;
			}
		}
	}if (partial === false) for (var key in ret) {
		if (Object.prototype.hasOwnProperty.call(ret, key)) {
			if (!Object.prototype.hasOwnProperty.call(diff, key) || diff[key] === undefined) {
				if (ret === dest) copyDest();
				delete ret[key];
				--cnt;
			} else cnt = Infinity;
		}
	}if (ret !== dest && cnt == 0) ret = null;

	return ret;
}

function merge(a, b) {

	if (a == null) a = NON_PARTIAL;
	if (b == null) b = NON_PARTIAL;

	if (b.__partial__ === false) return b;

	var ret = a;

	function copyDest() {
		ret = Object.create(null);
		for (var key in a) {
			if (Object.prototype.hasOwnProperty.call(a, key)) {
				var value = a[key];
				if (value === undefined) continue;
				ret[key] = a[key];
			}
		}
	}

	for (var key in b) {
		if (Object.prototype.hasOwnProperty.call(b, key)) {
			var value = b[key];
			if (value === undefined) continue;
			if (value == null) value = NON_PARTIAL;
			if (typeof value == "object") {
				var r = ret ? ret[key] : undefined;
				if (r === undefined) r = PARTIAL;
				value = merge(r, value);
			}
			if (ret == null || ret[key] !== value) {
				if (ret === a) copyDest();
				ret[key] = value;
			}
		}
	}if (ret !== a && typeof a != "object") ret.__partial__ = false;

	return ret;
}

function make(previous, next) {
	if (previous === next) return undefined;
	var ret = undefined;
	function toArray(obj) {
		var ret = [];
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = Object.keys(obj)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var key = _step2.value;

				ret.push({ value: obj[key], key: key });
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
					_iterator2["return"]();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		return ret.sort(function (v1, v2) {
			return v1.key < v2.key ? -1 : v1.key > v2.key ? 1 : 0;
		});
	}
	var pa = toArray(previous);
	var na = toArray(next);
	var p = pa.pop();
	var n = na.pop();
	while (p || n) {
		if (!n || p && p.key > n.key) {
			if (!ret) ret = Object.create(null);
			ret[p.key] = null; // deleting
			p = pa.pop();
		} else if (!p || p.key < n.key) {
			if (!ret) ret = Object.create(null);
			ret[n.key] = n.value;
			n = na.pop();
		} else {
			if (p.value !== n.value) {
				if (isSet(p.value) && isSet(n.value)) {
					var diff = make(p.value, n.value);
					if (diff) {
						if (!ret) ret = Object.create(null);
						ret[n.key] = diff;
					}
				} else {
					if (!ret) ret = Object.create(null);
					ret[n.key] = n.value;
				}
			}
			p = pa.pop();
			n = na.pop();
		}
	}
	return ret ? ret : undefined;
}

// TODO:

// function assert( value, message ) {
// 	if ( !value )
// 		throw new Error( `` + message )
// }

// function testDiff() {
// 	let p = { a: 1, x: { u: 9 } }
// 	let q = { x: { c: 2 } }
// 	assert( JSON.stringify( q ) == JSON.stringify( Diff.apply( p, Diff.make( p, q ) ) ) )
// }

},{}],244:[function(require,module,exports){
/*

2014.09.22

it should be better to use hammer.js, but i cannot use it without problems -
hammer.js often drops events, while direct addEventListener does not.

*/

"use strict";

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var _co = require("co");

var co = _interopRequireWildcard(_co);

var _sparsequeue = require("sparsequeue");

var _sparsequeue2 = _interopRequireDefault(_sparsequeue);

var TRACE = undefined;
// let TC = 0
// TRACE = ( ...info ) => LOG( `${ ++TC } g ${ JSON.stringify( info ).slice( 0, 100 ) }`.green )

var SWIPE_TIMEOUT = 400; // ms
var PRESS_TIMEOUT = 500; // ms
var PRESS_MOVE_OUT = 2 /* ~mm */ * (96 / 25.4);

function squareDistance(p1, p2) {
	return (p1.pageX - p2.pageX) * (p1.pageX - p2.pageX) + (p1.pageY - p2.pageY) * (p1.pageY - p2.pageY);
}

function getX(p) {
	return p.pageX;
}
function getY(p) {
	return p.pageY;
}
function increasing(v, i, p) {
	return i == 0 || v >= p[i - 1];
}
function decreasing(v, i, p) {
	return i == 0 || v <= p[i - 1];
}

document.addEventListener("touch", co.eventHandler(regeneratorRuntime.mark(function callee$0$0(event) {
	var all, trace, last, pressed, swiped, pan, panlock, sent, send, ensurepan, sendpan, pressTimeout, stoppedTimeout, startStoppedTimeout, stopPoint, pt, longmove, dx, dy, sizex, sizey, prev, direction, traceX, traceY, bounds;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				startStoppedTimeout = function startStoppedTimeout() {
					clearTimeout(stoppedTimeout);
					stoppedTimeout = setTimeout(function () {
						ensurepan();
						sendpan("stop");
						startStoppedTimeout();
					}, PRESS_TIMEOUT);
				};

				sendpan = function sendpan(type, direction, pt, detail) {
					var data = send(type, direction, pt, detail);
					if (pan) {
						if (panlock && panlock.length) {
							panlock[0].queue.push(data);
							panlock.forEach(function (p, i) {
								return i > 0 && (p.dirty = true);
							});
							pan.dirty = true;
						} else pan.queue.push(data);
					}
				};

				ensurepan = function ensurepan(direction) {
					if (pan) return;
					pan = { queue: new _sparsequeue2.default() };
					send("pan", direction, last, {
						next: pan.queue,
						lock: function lock() {
							if (!panlock) panlock = [];
							var ret = { queue: new _sparsequeue2.default() };
							panlock.push(ret);
							return ret.queue;
						},
						unlock: function unlock(lock) {
							panlock = panlock.filter(function (l) {
								return l != lock;
							});
							var p = panlock[0] || pan;
							if (p.dirty) {
								p.dirty = false;
								sendpan("pan", "unlocked");
							}
						}
					}, "");
				};

				send = function send(type, direction, pt, detail, typeDirection) {
					TRACE && TRACE(type, all);
					if (typeDirection == null) typeDirection = direction;
					if (!detail) detail = {};
					detail.direction = direction;
					detail.pressed = pressed;
					detail.type = type;
					detail.start = event;
					detail.original = pt || event;
					var ret = new CustomEvent(type + (typeDirection || ""), { bubbles: true, cancelable: true, detail: detail });
					ret.pageX = last.pageX;
					ret.pageY = last.pageY;
					ret.clientX = last.clientX;
					ret.clientY = last.clientY;
					ret.screenX = last.screenX;
					ret.screenY = last.screenY;
					ret.deltaX = last.pageX - event.pageX;
					ret.deltaY = last.pageY - event.pageY;
					ret.lastDeltaX = last.pageX - sent.pageX;
					ret.lastDeltaY = last.pageY - sent.pageY;
					sent = last;
					ret.preventDefault = function () {
						return event.preventDefault();
					};
					event.target.dispatchEvent(ret);
					return ret;
				};

				all = undefined;
				trace = [event];
				last = event;
				pressed = null;
				swiped = false;
				pan = null;
				panlock = null;
				sent = event;

				co.defer(function () {
					panlock && panlock.forEach(function (lock) {
						return lock.queue.close();
					});
					pan && pan.queue.close();
				});

				pressTimeout = undefined;
				stoppedTimeout = undefined;

				co.defer(function () {
					clearTimeout(pressTimeout);
					clearTimeout(stoppedTimeout);
				});

				pressTimeout = setTimeout(function () {
					pressed = true;
					send("press");
				}, PRESS_TIMEOUT);

				startStoppedTimeout();

				TRACE && TRACE("enter", { x: event.pageX, y: event.pageY, t: event.timeStamp });

				stopPoint = event;
				pt = undefined;

			case 21:
				context$1$0.next = 23;
				return event.detail.next;

			case 23:
				if (!(pt = context$1$0.sent)) {
					context$1$0.next = 31;
					break;
				}

				if (TRACE) {
					(all || (all = [])).push({ x: pt.pageX, y: pt.pageY, t: pt.timeStamp - event.timeStamp });
					TRACE("next", all);
				}
				if (last.timeStamp - event.timeStamp > SWIPE_TIMEOUT) trace = null;

				longmove = squareDistance(pt, stopPoint) > PRESS_MOVE_OUT * PRESS_MOVE_OUT;

				if (longmove) {
					stopPoint = pt;
					startStoppedTimeout();
				}

				if (longmove || !trace || trace.length > 1) {
					if (pressed == null) {
						pressed = false;
						clearTimeout(pressTimeout);
					}
					dx = pt.pageX - last.pageX;
					dy = pt.pageY - last.pageY;

					if (dx || dy) {
						sizex = Math.abs(dx);
						sizey = Math.abs(dy);
						prev = last;

						if (trace) trace.push(last);
						last = pt;
						direction = "";

						if (sizex >= sizey && dx > 0) direction = "right";else if (sizex >= sizey && dx < 0) direction = "left";else if (sizex < sizey && dy > 0) direction = "down";else if (sizex < sizey && dy < 0) direction = "up";
						ensurepan(direction);
						sendpan("pan", direction, last);
					}
				}

			case 29:
				context$1$0.next = 21;
				break;

			case 31:
				clearTimeout(pressTimeout);
				if (last.timeStamp - event.timeStamp < SWIPE_TIMEOUT && trace && trace.length > 2) {
					// remove first point to eliminate touch bouncing effect
					trace.shift();
					traceX = trace.map(getX);
					traceY = trace.map(getY);
					bounds = {
						x: Math.max.apply(Math, _toConsumableArray(traceX)) - Math.min.apply(Math, _toConsumableArray(traceX)),
						y: Math.max.apply(Math, _toConsumableArray(traceY)) - Math.min.apply(Math, _toConsumableArray(traceY))
					};
					direction = "";

					if (bounds.x > bounds.y && traceX.every(increasing)) direction = "right";else if (bounds.x > bounds.y && traceX.every(decreasing)) direction = "left";else if (bounds.x < bounds.y && traceY.every(increasing)) direction = "down";else if (bounds.x < bounds.y && traceY.every(decreasing)) direction = "up";
					if (direction) {
						swiped = true;
						sendpan("swipe", direction, last);
					}
				}
				if (!pressed && !swiped && !pan) sendpan("tap");
				TRACE && TRACE("done", all);

			case 35:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
})));

},{"co":238,"sparsequeue":257}],245:[function(require,module,exports){
"use strict";

var marked0$0 = [iterateOverItem].map(regeneratorRuntime.mark);
var style = document.createElement("div").style;
if (!("transform" in style) && "webkitTransform" in style) {
	Object.defineProperty(window.CSSStyleDeclaration.prototype, "transform", {
		get: function get() {
			return this.webkitTransform;
		},
		set: function set(value) {
			this.webkitTransform = value;
		}
	});
}

function iterateOverItem() {
	var i, l;
	return regeneratorRuntime.wrap(function iterateOverItem$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				i = 0, l = this.length;

			case 1:
				if (!(i < l)) {
					context$1$0.next = 7;
					break;
				}

				context$1$0.next = 4;
				return this.item(i);

			case 4:
				++i;
				context$1$0.next = 1;
				break;

			case 7:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[0], this);
}

var _arr = [NodeList, HTMLCollection];
for (var _i = 0; _i < _arr.length; _i++) {
	var Class = _arr[_i];
	if (!Class.prototype[Symbol.iterator]) Class.prototype[Symbol.iterator] = iterateOverItem;
}

},{}],242:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var _diff = require("diff");

var Diff = _interopRequireWildcard(_diff);

var _uid = require("uid");

var _uid2 = _interopRequireDefault(_uid);

var Unlink = function Unlink(devices, deviceId) {
	return lodash.reduce(devices.content, function (ret, q, index) {
		if (q) if (index == deviceId) ret.content[index] = null;else if (q.content && q.content[deviceId]) ret.content[index] = { content: _defineProperty({}, deviceId, null) };
		return ret;
	}, { content: {} });
};

exports.Unlink = Unlink;
exports.Clear = Unlink;
var Set = function Set(devices, deviceId, data) {
	var device = devices.content[deviceId];
	if (!device || !device.group) return;
	var ret = { content: _defineProperty({}, deviceId, data) };
	if (device.type == "group") ret = lodash.reduce(device.content, function (ret, q, index) {
		if (q) ret.content[index] = data;
		return ret;
	}, ret);
	return ret;
};

exports.Set = Set;
var findFreeGroup = function findFreeGroup(devices) {
	var groups = [];
	for (var i = 1; i <= 1022; ++i) {
		groups[i] = i;
	}lodash.forEach(devices.content, function (device) {
		device && Number.isFinite(device.group) && (groups[device.group] = false);
	});
	groups = groups.filter(Boolean);
	return !groups.length ? null : groups[Math.floor(Math.random() * groups.length) % groups.length];
};

exports.findFreeGroup = findFreeGroup;
var cleanDatabase = function cleanDatabase(devices) {
	var ret = devices || {};
	function _save(diff) {
		ret = Diff.apply(ret, diff);
	}
	function _change(path, value) {
		_save(path.reduceRight(function (ret, key) {
			return _defineProperty({}, key, ret);
		}, value));
	}
	function assign() {
		for (var _len = arguments.length, path = Array(_len), _key = 0; _key < _len; _key++) {
			path[_key] = arguments[_key];
		}

		_change(path, path.pop());
	}
	function remove() {
		for (var _len2 = arguments.length, path = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			path[_key2] = arguments[_key2];
		}

		_change(path, null);
	}

	// move root items to content
	if (!ret.content) lodash.forEach(ret, function (place, placeId) {
		if (place != null && typeof place != "object") return;
		remove(placeId);
		assign("content", placeId, place);
	});else // TODO delete later
		lodash.forEach(ret, function (place, placeId) {
			if (place != null && typeof place != "object") return;
			if (placeId == "content") return;
			remove(placeId);
		});

	// remove items with wrong type & remove group from places
	lodash.forEach(ret.content, function (place, placeId) {
		if (place == null || typeof place != "object") return remove("content", placeId);
		if (place.type == "device") // TODO: remove later
			assign("content", placeId, "type", "single");
		if (place.device == placeId) remove("content", placeId, "device");else if (!(place.type || "").match(/^(place|group|single)$/)) return remove("content", placeId);
		if (place.group != null && (!Number.isFinite(place.group) || place.type == "place")) remove("content", placeId, "group");
	});

	// create main
	if (ret && (typeof ret.main != "string" || !ret.content || !ret.content[ret.main] || !ret.content[ret.main].type)) {
		(function () {
			var main = (0, _uid2.default)();
			var i = 0;
			lodash.forEach(ret.content, function (place, key) {
				assign("content", main, "content", key, ++i);
			});
			if (ret.content && ret.content[main]) {
				assign("content", main, "type", "place");
				assign("main", main);
			}
		})();
	}

	// remove items with duplicate group
	var reachable = undefined;
	function groupIndex(key) {
		if (!reachable) {
			(function () {
				var push = function push(key) {
					if (!(key in reachable) && ret.content.hasOwnProperty(key)) {
						reachable[key] = true;
						reachableKeys.push(key);
					}
					return key;
				};

				reachable = Object.create(null);
				var reachableKeys = [];

				push(ret.main);
				for (var _i = 0; _i < reachableKeys.length; ++_i) {
					var place = ret.content[reachableKeys[_i]];
					if (place && place.content) Object.keys(place.content).forEach(push);
				}
			})();
		}
		var i = 0;
		if (ret.content[key].type == "group") i += 2;
		if (key in reachable) i += 1;
	}

	var groups = Object.create(null);
	lodash.forEach(ret.content, function (place, key) {
		if (!place || place.group == null) return;
		if (!groups[place.group]) groups[place.group] = key;else {
			if (groupIndex(groups[place.group]) < groupIndex(key)) {
				remove("content", groups[place.group]);
				groups[place.group] = key;
			} else remove("content", key);
		}
	});

	// check content
	lodash.forEach(ret.content, function (place, key) {
		if (!place || place.content == null) return;
		if (typeof place.content != "object") return remove("content", key, "content");
		lodash.forEach(place.content, function (_, ckey) {
			if (!ret.content[ckey] || typeof ret.content[ckey] != "object") remove("content", key, "content", ckey);
		});
		place = ret.content[key]; // reassign place cause it could change in previous forEach
		lodash.keys(place.content).sort(function (a, b) {
			return (place.content[a].index || 0) - (place.content[b].index || 0);
		}).forEach(function (ckey, index) {
			if (place.content[ckey].index != index) assign("content", key, "content", ckey, "index", index);
		});
	});

	return Diff.make(devices, ret);
};
exports.cleanDatabase = cleanDatabase;

},{"diff":243,"lodash":232,"uid":281}],246:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var preventDefault = function preventDefault(event) {
	return event && event.preventDefault && event.preventDefault();
};

exports.preventDefault = preventDefault;
var Submit = function Submit(event) {
	event && event.preventDefault();
	var c = this;
	while (c && !(c instanceof HTMLFormElement)) c = c.parentNode;
	if (c) c.dispatchEvent(new CustomEvent("submit", null));
	return false;
};

exports.Submit = Submit;
var noBorders = "border: none; margin: 0; padding: 0;";

var Centered = function Centered(attr, content) {
	var style = noBorders;
	var transform = "";
	switch (attr.horizontal) {
		case "left":
			style += "text-align: left;";
			break;
		case "right":
			style += "text-align: right;";
			break;
		case "center":
		case "":
		case undefined:
		case null:
			style += "text-align: center;";
			break;
		default:
			throw new Error("attr.horizontal: " + attr.horizontal);
	}
	switch (attr.vertical) {
		case "top":
			style += "top: 0;";
			break;
		case "bottom":
			style += "bottom: 0;";
			break;
		case "center":
		case "":
		case undefined:
		case null:
			style += "top: 50%;";
			transform += "translateY( -50% )";
			break;
		default:
			throw new Error("attr.vertical: " + attr.vertical);
	}
	if (transform) style += "transform: " + transform + "; -webkit-transform: " + transform + ";";
	return __(
		"div",
		{ style: noBorders + " width: 100%; height: 100%; position: relative;" },
		__(
			"div",
			{ style: style + " width: 100%; position: absolute;" },
			content
		)
	);
};

exports.Centered = Centered;
var isEmptyNode = function isEmptyNode(node) {
	return node instanceof Comment || node instanceof global.ProcessingInstruction || node instanceof Text && !node.nodeValue.trim();
};

exports.isEmptyNode = isEmptyNode;
var importTemplate = function importTemplate(template) {
	return document.importNode(template.content, true);
};

exports.importTemplate = importTemplate;
var importElement = function importElement(template) {
	var ret = importTemplate(template);
	if (!ret) return null;
	while (ret.lastChild && isEmptyNode(ret.lastChild)) ret.removeChild(ret.lastChild);
	while (ret.firstChild && isEmptyNode(ret.firstChild)) ret.removeChild(ret.firstChild);
	if (!ret.firstChild) return null;
	if (ret.childNodes.length == 1) return ret.childNodes.item(0);
	var root = document.createElement("span");
	root.appendChild(ret);
	return root;
};

exports.importElement = importElement;
var importComponent = function importComponent(template) {
	var data = importElement(template);
	if (data) {
		var init = data.getElementsByClassName("init")[0];
		if (init && init.type == "init") {
			var finit = new Function("component", [].slice.call(init.childNodes).map(function (x) {
				return x.data || "";
			}).join(""));
			finit(data);
		}
	}
	return data;
};

exports.importComponent = importComponent;
var tickCache = function tickCache(fun) {
	var cachedResult = undefined;
	var cached = false;

	var clearCache = function clearCache() {
		cachedResult = null;
		cached = false;
	};

	return function () {
		if (!cached) {
			cachedResult = fun.apply(this, arguments);
			cached = true;
			setImmediate(clearCache);
		}
		return cachedResult;
	};
};

exports.tickCache = tickCache;
var createEvent = function createEvent(type, detail, on) {
	var event = new CustomEvent(type, { detail: detail, bubbles: true, cancelable: true });
	if (on) {
		event.pageX = on.pageX;
		event.pageY = on.pageY;
		event.clientX = on.clientX;
		event.clientY = on.clientY;
		event.screenX = on.screenX;
		event.screenY = on.screenY;
	}
	return event;
};

exports.createEvent = createEvent;
var sendEvent = function sendEvent(type, detail, on) {
	return on.target.dispatchEvent(createEvent(type, detail, on));
};
exports.sendEvent = sendEvent;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],247:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _url2 = require("url");

var URL = _interopRequireWildcard(_url2);

var get = function get(url, encoding) {
	return xhr({ method: "GET", url: url, encoding: encoding });
};

exports.get = get;
var post = function post(url, data, encoding) {
	return xhr({ method: "POST", url: url, data: data, encoding: encoding });
};

exports.post = post;
var xhr = function xhr(options) {
	var _context;

	var method = options.method;
	var url = options.url;
	var encoding = options.encoding;
	var data = options.data;

	var xhr = new XMLHttpRequest();
	if (encoding == "binary") xhr.responseType = "arraybuffer";else xhr.responseType = "text";
	var promise = new Promise(function (resolve, reject) {
		var onerror = function onerror(error) {
			if (typeof error == "string") {
				error = new Error(error);
				error.method = method;
				error.url = url;
			}
			global._ALERT && global._ALERT("try " + error + url);
			reject(error);
		};
		xhr.ontimeout = function () {
			return onerror(new Error("TIMEOUT " + url));
		};
		xhr.onerror = function (e) {
			return onerror(e || "ERROR");
		};
		xhr.onreadystatechange = function () {
			if (xhr.readyState == xhr.DONE && xhr.status == 0) xhr.ontimeout();
		};
		xhr.onload = function () {
			// alert( xhr.status )
			if (xhr.status >= 200 && xhr.status <= 299) return resolve(xhr.response == null ? null : xhr.response);
			if (xhr.status == 401) {
				// append some thing to the page to force standalone browser to show login dialog
				var surl = URL.parse(url);
				if (surl.host) {
					(function () {
						surl = surl.protocol + "//" + surl.host + "/dummy." + Math.random() + ".js";
						var script = document.createElement("script");
						script.src = surl;
						// alert( surl )
						document.body.appendChild(script);
						setTimeout(function () {
							return document.body.removeChild(script);
						}, 1000);
					})();
				}
			}
			onerror(xhr.status + " " + xhr.statusText);
		};
	});
	switch (encoding) {
		case "immutable":
			promise = promise.then(function (data) {
				return global.Immutable.fromJS(JSON.parse(data));
			});
			break;
		case "binary":
			promise = promise.then(function (data) {
				return new Uint8Array(data);
			});
			break;
		case "text":
			break;
		default:
			promise = promise.then(function (data) {
				var actualEncoding = encoding;
				if (!actualEncoding) {
					var ct = xhr.getResponseHeader("content-type") || "";
					if (ct.match(/^application\/json/)) actualEncoding = "json";
				}
				switch (actualEncoding) {
					case "json":
						return JSON.parse(data);
				}
				return data;
			});
	}
	xhr.open(method || "GET", url);
	xhr.withCredentials = true;
	xhr.send(data);
	xhr.then = (_context = promise).then.bind(_context);
	xhr.catch = (_context = promise).catch.bind(_context);
	return xhr;
};

exports.xhr = xhr;
var url = function url(_url, params) {
	if (params) {
		var delimeter = "?";
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = Object.keys(params)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var k = _step.value;

				_url += "" + delimeter + encodeURIComponent(k) + "=" + encodeURIComponent(params[k]);
				delimeter = "&";
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator["return"]) {
					_iterator["return"]();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	}
	return _url;
};
exports.url = url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"url":212}],249:[function(require,module,exports){
(function (process,global,Buffer){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.dump = dump;
exports.mapObj = mapObj;
exports.rests = rests;
exports.pad = pad;
exports.time = time;
exports.options = options;
exports.str = str;
exports.toOneLine = toOneLine;
exports.byLines = byLines;
exports.byJSON = byJSON;
exports.returnThis = returnThis;
exports.when = when;
exports.waitFor = waitFor;
exports.JSONEqual = JSONEqual;
exports.call = call;
exports.rethrow = rethrow;
exports.catchMap = catchMap;
exports.catchCall = catchCall;
exports.unique = unique;
exports.joinData = joinData;
exports.on = on;
exports.off = off;
exports.readStream = readStream;
exports.readJSON = readJSON;
exports.readChunk = readChunk;
exports.property = property;
exports.polling = polling;
exports.isSet = isSet;
exports.concatString = concatString;
exports.sortedDiff = sortedDiff;
exports.measure = measure;
exports.skip = skip;
exports.take = take;
exports.copy = copy;
exports.array1 = array1;
exports.array = array;
exports.buffer = buffer;
exports.vector = vector;
exports.concat = concat;
exports.word = word;
exports.dword = dword;
exports.makeWord = makeWord;
exports.arrayEqual = arrayEqual;
exports.compare = compare;
exports.formatms = formatms;
exports.get = get;
exports.limitCalls = limitCalls;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var marked0$0 = [readStream, readJSON, readChunk, skip, take, concat].map(regeneratorRuntime.mark);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var LiteralPrototype = Object.getPrototypeOf({});

var dumpPromise = function dumpPromise(p) {
	return p.then(function (result) {
		return console.log("result:", result);
	}, function (error) {
		return console.error("error:", error);
	});
};

exports.dumpPromise = dumpPromise;

function dump(msg, value) {
	console.log(msg, value);
	return value;
}

function mapObj(obj, props) {
	var ret = Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
	lodash.forEach(props, function (fun, key) {
		ret[key] = typeof fun == "function" ? fun(obj[key]) : fun;
	});
	return ret;
}

function rests(num) {
	for (var _len = arguments.length, rests = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		rests[_key - 1] = arguments[_key];
	}

	var ret = [];
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = rests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var r = _step.value;

			var n = num % r;
			num = (num - n) / r;
			ret.push(n);
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator["return"]) {
				_iterator["return"]();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return ret;
}

function pad(s, n, p) {
	s = String(s);
	var x = "";
	n -= s.length;
	while (n > 0) {
		x += p;
		--n;
	}
	return x + s;
}

function time() {
	var d = new Date();
	return d.getHours() + ":" + pad(d.getMinutes(), 2, 0) + ":" + pad(d.getSeconds(), 2, 0) + "." + pad(d.getMilliseconds(), 3, 0);
}

var stack = function stack() {
	return new Error().stack;
};

exports.stack = stack;

function options(options, def) {
	var ret = {};
	for (var i in def) {
		if (Object.prototype.hasOwnProperty.call(def, i)) if (options == null) ret[i] = def[i];else {
			var op = options[i];
			if (op == null) op = def[i];
			ret[i] = op;
		}
	}return ret;
}

function str(obj, depth) {
	if (depth == null) depth = 1;
	if (!obj || !depth || depth < 1) return "" + obj;
	if (Array.isArray(obj)) return "[ " + obj.map(function (x) {
		return str(x, depth - 1);
	}).join(" ") + " ]";
	if (!obj.constructor || obj.constructor == Object) return "{ " + Object.keys(obj).map(function (x) {
		return x + "=" + str(obj[x], depth - 1);
	}).join(" ") + " }";
	return String(obj);
}

function toOneLine(obj) {
	var ret = JSON.stringify(obj);
	ret += "\n";
	return ret;
}

function byLines(callback) {
	var buffer = "";
	return function (chunk) {
		buffer += String(chunk);
		var ret = buffer.split("\n");
		buffer = ret.pop();
		ret.forEach(callback);
	};
}

function byJSON(callback) {
	return byLines(function (line) {
		return callback(JSON.parse(line.trim()));
	});
}

var valueOf = function valueOf(val) {
	return val == null ? null : val.valueOf == null ? val : val.valueOf();
};

exports.valueOf = valueOf;

function returnThis() {
	return this;
}

var returnNull = function returnNull() {
	return null;
};
exports.returnNull = returnNull;
var returnTrue = function returnTrue() {
	return true;
};
exports.returnTrue = returnTrue;
var returnFalse = function returnFalse() {
	return false;
};
exports.returnFalse = returnFalse;
var returnZero = function returnZero() {
	return 0;
};
exports.returnZero = returnZero;
var returnOne = function returnOne() {
	return 1;
};

exports.returnOne = returnOne;
var promiseSucceeded = Promise.resolve();
exports.promiseSucceeded = promiseSucceeded;
var promiseFailed = Promise.reject();
exports.promiseFailed = promiseFailed;
var promiseNull = Promise.resolve(null);
exports.promiseNull = promiseNull;
var promiseTrue = Promise.resolve(true);
exports.promiseTrue = promiseTrue;
var promiseFalse = Promise.resolve(false);
exports.promiseFalse = promiseFalse;
var promiseZero = Promise.resolve(0);
exports.promiseZero = promiseZero;
var promiseOne = Promise.resolve(1);

exports.promiseOne = promiseOne;
var returnSucceeded = function returnSucceeded() {
	return promiseSucceeded;
};
exports.returnSucceeded = returnSucceeded;
var returnFailed = function returnFailed() {
	return promiseFailed;
};
exports.returnFailed = returnFailed;
var returnNullPromise = function returnNullPromise() {
	return promiseNull;
};
exports.returnNullPromise = returnNullPromise;
var returnTruePromise = function returnTruePromise() {
	return promiseTrue;
};
exports.returnTruePromise = returnTruePromise;
var returnFalsePromise = function returnFalsePromise() {
	return promiseFalse;
};
exports.returnFalsePromise = returnFalsePromise;
var returnZeroPromise = function returnZeroPromise() {
	return promiseZero;
};
exports.returnZeroPromise = returnZeroPromise;
var returnOnePromise = function returnOnePromise() {
	return promiseOne;
};

exports.returnOnePromise = returnOnePromise;

function when(promise, cb) {
	if (promise != null) promise.then(cb, cb);else process.nextTick(cb);
	return promise;
}

function waitFor(timeout, interval, callback) {
	if (typeof timeout == "function") {
		interval = timeout;
		timeout = 5000;
	}
	if (typeof interval == "function") {
		callback = interval;
		interval = 200;
	}
	return new Promise(function (resolve, reject) {
		var start = Date.now();
		setTimeout(function check() {
			var ret = undefined;
			if (ret = callback()) resolve(ret);else if (Date.now() - start > timeout) reject(new Error("timeout"));else setTimeout(check, interval);
		}, interval);
	});
}

var empty = Object.freeze(Object.create(null));

exports.empty = empty;

function JSONEqual(a, b) {
	return JSON.stringify(a) == JSON.stringify(b);
}

exports.new = _new;

function _new() {
	for (var _len2 = arguments.length, descedents = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		descedents[_key2] = arguments[_key2];
	}

	return Object.assign.apply(Object, [{}].concat(descedents));
}

function call(fun) {
	for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		args[_key3 - 1] = arguments[_key3];
	}

	return fun.apply(undefined, args);
}

function rethrow(e) {
	setTimeout(function () {
		throw e;
	}, 1);
}

// optimization -- using try/catch in a separate function.
exports.catch = _catch;

function _catch(cb, ret) {
	try {
		return cb();
	} catch (e) {
		return ret(e);
	}
}

function catchMap(cb, mapResult, mapError) {
	var result = undefined;
	try {
		result = cb();
	} catch (error) {
		return mapError(error);
	}
	return mapResult(result);
}

function catchCall(cb) {
	try {
		return { ok: true, result: cb() };
	} catch (error) {
		return { ok: false, error: error };
	}
}

function unique(value, index, array) {
	return index == 0 || value != array[index - 1];
}

function joinData(array) {
	return array.length == 0 ? "" : typeof array[0] == "string" ? array.join("") : Buffer.isBuffer(array[0]) ? Buffer.concat(array) : array.join("");
}

function on(emitter, events) {
	lodash.forEach(events, function (handler, event) {
		emitter.on(event, handler);
	});
}

function off(emitter, events) {
	lodash.forEach(events, function (handler, event) {
		emitter.removeListener(event, handler);
	});
}

function readStream(stream) {
	return regeneratorRuntime.wrap(function readStream$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				context$1$0.next = 2;
				return { then: function then(resolve, reject) {
						var content = [];
						stream.on("data", function (chunk) {
							return content.push(chunk);
						});
						stream.on("end", function () {
							return resolve(joinData(content));
						});
						stream.on("error", reject);
					} };

			case 2:
				return context$1$0.abrupt("return", context$1$0.sent);

			case 3:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[0], this);
}

function readJSON(stream) {
	return regeneratorRuntime.wrap(function readJSON$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				context$1$0.t0 = JSON;
				context$1$0.next = 3;
				return readStream(stream);

			case 3:
				context$1$0.t1 = context$1$0.sent;
				return context$1$0.abrupt("return", context$1$0.t0.parse.call(context$1$0.t0, context$1$0.t1));

			case 5:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[1], this);
}

function readChunk(stream) {
	return regeneratorRuntime.wrap(function readChunk$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				context$1$0.next = 2;
				return { then: function then(resolve, reject) {
						stream.on("data", onData);
						stream.on("end", onEnd);
						stream.on("error", onError);
						function done() {
							stream.removeListener("data", onData);
							stream.removeListener("end", onEnd);
							stream.removeListener("error", onError);
						}
						function onData(chunk) {
							done();
							resolve(chunk);
						}
						function onEnd() {
							done();
							resolve(null);
						}
						function onError(error) {
							done();
							reject(error);
						}
					} };

			case 2:
				return context$1$0.abrupt("return", context$1$0.sent);

			case 3:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[2], this);
}

function property(obj, name, defaultValue) {
	var privateName = "_" + name;
	if (arguments.length > 2) obj[privateName] = defaultValue;
	obj[name] = function (value) {
		if (arguments.length == 0) return obj[privateName];else {
			obj[privateName] = value;
			return obj;
		}
	};
	return obj;
}

function polling(stream) {
	var ret = {
		stop: function stop() {
			if (!ret) return;
			if (ret._polling != null) {
				clearTimeout(ret._polling);
				ret._polling = null;
			}
			ret = null;
		},
		_polling: null,
		_tryToSendChunk: function _tryToSendChunk() {
			if (!ret) return;
			ret._polling = null;
			if (!stream.write(ret._chunk)) stream.once("drain", ret._tryToSendChunk);else {
				if (typeof stream.flush == "function") stream.flush();
				ret._polling = setTimeout(ret._tryToSendChunk, ret._interval);
			}
		}
	};

	property(ret, "chunk", "\n");
	property(ret, "interval", 60000);

	// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
	stream.once("end", ret.stop);
	// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
	stream.once("close", ret.stop);
	// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
	stream.once("error", ret.stop);

	process.nextTick(ret._tryToSendChunk);

	return ret;
}

function isSet(obj) {
	if (obj == null) return false;
	var proto = Object.getPrototypeOf(obj);
	return proto === LiteralPrototype || proto === null;
}

function concatString(array) {
	var ret = "";
	!(function walk(array) {
		if (typeof array != "object") ret += array;else if (array.length != null) array.forEach(walk);else {
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var s = _step2.value;

					walk(s);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
						_iterator2["return"]();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	})(array);
	return ret;
}

function sortedDiff(first, second) {
	var fi = first[Symbol.iterator]();
	var si = second[Symbol.iterator]();
	var ret = {
		common: [],
		first: [],
		second: []
	};
	var fv = fi.next(),
	    sv = si.next();
	while (!fv.done || !sv.done) {
		if (sv.done || fv.value < sv.value) {
			ret.first.push(fv.value);
			fv = fi.next();
		} else if (fv.done || fv.value > sv.value) {
			ret.second.push(sv.value);
			sv = si.next();
		} else {
			ret.common.push(fv.value);
			fv = fi.next();
			sv = si.next();
		}
	}
	return ret;
}

function measure(fun) {
	var now = global.performance || global.Date;
	var t = now.now();
	try {
		return fun();
	} finally {
		t = (now.now() - t) / 1000;
		if (t > 0) {
			var i = 1;
			while (t < 1000) {
				i *= 10;
				t *= 10;
			}
			t = Math.round(t) / i;
		}
		console.log(t);
	}
}

function skip(c, buf) {
	var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, b;

	return regeneratorRuntime.wrap(function skip$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				_iteratorNormalCompletion3 = true;
				_didIteratorError3 = false;
				_iteratorError3 = undefined;
				context$1$0.prev = 3;
				_iterator3 = buf[Symbol.iterator]();

			case 5:
				if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
					context$1$0.next = 16;
					break;
				}

				b = _step3.value;

				if (!(c > 0)) {
					context$1$0.next = 11;
					break;
				}

				--c;
				context$1$0.next = 13;
				break;

			case 11:
				context$1$0.next = 13;
				return b;

			case 13:
				_iteratorNormalCompletion3 = true;
				context$1$0.next = 5;
				break;

			case 16:
				context$1$0.next = 22;
				break;

			case 18:
				context$1$0.prev = 18;
				context$1$0.t0 = context$1$0["catch"](3);
				_didIteratorError3 = true;
				_iteratorError3 = context$1$0.t0;

			case 22:
				context$1$0.prev = 22;
				context$1$0.prev = 23;

				if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
					_iterator3["return"]();
				}

			case 25:
				context$1$0.prev = 25;

				if (!_didIteratorError3) {
					context$1$0.next = 28;
					break;
				}

				throw _iteratorError3;

			case 28:
				return context$1$0.finish(25);

			case 29:
				return context$1$0.finish(22);

			case 30:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[3], this, [[3, 18, 22, 30], [23,, 25, 29]]);
}

function take(c, buf) {
	var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, b;

	return regeneratorRuntime.wrap(function take$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				_iteratorNormalCompletion4 = true;
				_didIteratorError4 = false;
				_iteratorError4 = undefined;
				context$1$0.prev = 3;
				_iterator4 = buf[Symbol.iterator]();

			case 5:
				if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
					context$1$0.next = 17;
					break;
				}

				b = _step4.value;

				if (!(c > 0)) {
					context$1$0.next = 13;
					break;
				}

				--c;
				context$1$0.next = 11;
				return b;

			case 11:
				context$1$0.next = 14;
				break;

			case 13:
				return context$1$0.abrupt("break", 17);

			case 14:
				_iteratorNormalCompletion4 = true;
				context$1$0.next = 5;
				break;

			case 17:
				context$1$0.next = 23;
				break;

			case 19:
				context$1$0.prev = 19;
				context$1$0.t0 = context$1$0["catch"](3);
				_didIteratorError4 = true;
				_iteratorError4 = context$1$0.t0;

			case 23:
				context$1$0.prev = 23;
				context$1$0.prev = 24;

				if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
					_iterator4["return"]();
				}

			case 26:
				context$1$0.prev = 26;

				if (!_didIteratorError4) {
					context$1$0.next = 29;
					break;
				}

				throw _iteratorError4;

			case 29:
				return context$1$0.finish(26);

			case 30:
				return context$1$0.finish(23);

			case 31:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[4], this, [[3, 19, 23, 31], [24,, 26, 30]]);
}

function copy(buf) {
	var ret = array(buf);
	if (ret == buf) ret = buf.slice();
	return ret;
}

function array1(value) {
	if (Array.isArray(value)) return value;else return [value];
}

function array(buf) {
	if (Array.isArray(buf)) return buf;
	var ret = [];
	if (!buf[Symbol.iterator]) for (var i = 0; i < buf.length; ++i) {
		ret.push(buf[i]);
	} else {
		var _iteratorNormalCompletion5 = true;
		var _didIteratorError5 = false;
		var _iteratorError5 = undefined;

		try {
			for (var _iterator5 = buf[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
				var b = _step5.value;

				ret.push(b);
			}
		} catch (err) {
			_didIteratorError5 = true;
			_iteratorError5 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
					_iterator5["return"]();
				}
			} finally {
				if (_didIteratorError5) {
					throw _iteratorError5;
				}
			}
		}
	}return ret;
}

function buffer(buf) {
	if (buf instanceof Buffer) return buf;else return new Buffer(array(buf));
}

function vector(buf) {
	return buf instanceof Buffer ? buf : array(buf);
}

function concat(list) {
	var _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, l, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, x;

	return regeneratorRuntime.wrap(function concat$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				_iteratorNormalCompletion6 = true;
				_didIteratorError6 = false;
				_iteratorError6 = undefined;
				context$1$0.prev = 3;
				_iterator6 = list[Symbol.iterator]();

			case 5:
				if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
					context$1$0.next = 36;
					break;
				}

				l = _step6.value;
				_iteratorNormalCompletion7 = true;
				_didIteratorError7 = false;
				_iteratorError7 = undefined;
				context$1$0.prev = 10;
				_iterator7 = l[Symbol.iterator]();

			case 12:
				if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
					context$1$0.next = 19;
					break;
				}

				x = _step7.value;
				context$1$0.next = 16;
				return x;

			case 16:
				_iteratorNormalCompletion7 = true;
				context$1$0.next = 12;
				break;

			case 19:
				context$1$0.next = 25;
				break;

			case 21:
				context$1$0.prev = 21;
				context$1$0.t0 = context$1$0["catch"](10);
				_didIteratorError7 = true;
				_iteratorError7 = context$1$0.t0;

			case 25:
				context$1$0.prev = 25;
				context$1$0.prev = 26;

				if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
					_iterator7["return"]();
				}

			case 28:
				context$1$0.prev = 28;

				if (!_didIteratorError7) {
					context$1$0.next = 31;
					break;
				}

				throw _iteratorError7;

			case 31:
				return context$1$0.finish(28);

			case 32:
				return context$1$0.finish(25);

			case 33:
				_iteratorNormalCompletion6 = true;
				context$1$0.next = 5;
				break;

			case 36:
				context$1$0.next = 42;
				break;

			case 38:
				context$1$0.prev = 38;
				context$1$0.t1 = context$1$0["catch"](3);
				_didIteratorError6 = true;
				_iteratorError6 = context$1$0.t1;

			case 42:
				context$1$0.prev = 42;
				context$1$0.prev = 43;

				if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
					_iterator6["return"]();
				}

			case 45:
				context$1$0.prev = 45;

				if (!_didIteratorError6) {
					context$1$0.next = 48;
					break;
				}

				throw _iteratorError6;

			case 48:
				return context$1$0.finish(45);

			case 49:
				return context$1$0.finish(42);

			case 50:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[5], this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
}

function word(w) {
	return [w & 0xff, w >> 8 & 0xff];
}

function dword(w) {
	return [w & 0xff, w >> 8 & 0xff, w >> 16 & 0xff, w >> 24 & 0xff];
}

function makeWord(lo, hi) {
	return (lo & 0xff) + (hi & 0xff) << 8;
}

function arrayEqual(a, b) {
	return a && b && a.length == b.length && a.every(function (ai, i) {
		return ai == b[i];
	});
}

function compare(a, b) {
	if (a == b) return 0;
	if (a < b) return -1;
	return 1;
}

function formatms(value) {
	var ret = "";
	value = Math.round(value);
	var ms = value % 1000;
	value -= ms;
	value /= 1000;
	var s = value % 60;
	value -= s;
	value /= 60;
	var m = value % 60;
	value -= m;
	value /= 60;
	var h = value;
	ret += h ? h : "";
	ret += ret ? ":" + z(m, 2) : m ? m : "";
	ret += ret ? ":" + z(s, 2) : s;
	ret += "." + z(ms, 3);
	return ret;
	function z(value, len) {
		var str = String(value);
		var ret = "";
		for (var i = str.length; i < len; ++i) {
			ret += "0";
		}ret += str;
		return ret;
	}
}

function get(obj) {
	var _iteratorNormalCompletion8 = true;
	var _didIteratorError8 = false;
	var _iteratorError8 = undefined;

	try {
		for (var _len4 = arguments.length, path = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
			path[_key4 - 1] = arguments[_key4];
		}

		for (var _iterator8 = path[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
			var p = _step8.value;

			if (obj == null) break;else obj = obj[p];
		}
	} catch (err) {
		_didIteratorError8 = true;
		_iteratorError8 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion8 && _iterator8["return"]) {
				_iterator8["return"]();
			}
		} finally {
			if (_didIteratorError8) {
				throw _iteratorError8;
			}
		}
	}

	return obj;
}

function limitCalls(limit, period, message) {
	var calls = 0;
	return function () {
		if (calls >= limit) if (message) throw new Error.create(message);else return false;
		++calls;
		setTimeout(function () {
			return --calls;
		}, period);
		return true;
	};
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":192,"buffer":215,"lodash":232}],248:[function(require,module,exports){
/*

vadzim zienka

2015.05.11
added this.stoppedTransition to not to fire tap when scrolling is stopped by that tap.

 */

'use strict';

(function (window, document, Math) {
	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
		window.setTimeout(callback, 1000 / 60);
	};

	var utils = (function () {
		var me = {};

		var _elementStyle = document.createElement('div').style;
		var _vendor = (function () {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			    transform,
			    i = 0,
			    l = vendors.length;

			for (; i < l; i++) {
				transform = vendors[i] + 'ransform';
				if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
			}

			return false;
		})();

		function _prefixStyle(style) {
			if (_vendor === false) return false;
			if (_vendor === '') return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		}

		me.getTime = Date.now || function getTime() {
			return new Date().getTime();
		};

		me.extend = function (target, obj) {
			for (var i in obj) {
				target[i] = obj[i];
			}
		};

		me.addEvent = function (el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};

		me.removeEvent = function (el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};

		me.prefixPointerEvent = function (pointerEvent) {
			return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) : pointerEvent;
		};

		me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
			    speed = Math.abs(distance) / time,
			    destination,
			    duration;

			deceleration = deceleration === undefined ? 0.0006 : deceleration;

			destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
			duration = speed / deceleration;

			if (destination < lowerMargin) {
				destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if (destination > 0) {
				destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}

			return {
				destination: Math.round(destination),
				duration: duration
			};
		};

		var _transform = _prefixStyle('transform');

		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: window.PointerEvent || window.MSPointerEvent, // IE10 is prefixed
			hasTransition: _prefixStyle('transition') in _elementStyle
		});

		// This should find all Android browsers lower than build 535.19 (both stock browser and webview)
		me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !/Chrome\/\d/.test(window.navigator.appVersion);

		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});

		me.hasClass = function (e, c) {
			var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
			return re.test(e.className);
		};

		me.addClass = function (e, c) {
			if (me.hasClass(e, c)) {
				return;
			}

			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};

		me.removeClass = function (e, c) {
			if (!me.hasClass(e, c)) {
				return;
			}

			var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
			e.className = e.className.replace(re, ' ');
		};

		me.offset = function (el) {
			var left = -el.offsetLeft,
			    top = -el.offsetTop;

			// jshint -W084
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			// jshint +W084

			return {
				left: left,
				top: top
			};
		};

		me.preventDefaultException = function (el, exceptions) {
			for (var i in exceptions) {
				if (exceptions[i].test(el[i])) {
					return true;
				}
			}

			return false;
		};

		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,

			mousedown: 2,
			mousemove: 2,
			mouseup: 2,

			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,

			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});

		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function fn(k) {
					return k * (2 - k);
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
				fn: function fn(k) {
					return Math.sqrt(1 - --k * k);
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function fn(k) {
					var b = 4;
					return (k = k - 1) * k * ((b + 1) * k + b) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function fn(k) {
					if ((k /= 1) < 1 / 2.75) {
						return 7.5625 * k * k;
					} else if (k < 2 / 2.75) {
						return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
					} else if (k < 2.5 / 2.75) {
						return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
					} else {
						return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function fn(k) {
					var f = 0.22,
					    e = 0.4;

					if (k === 0) {
						return 0;
					}
					if (k == 1) {
						return 1;
					}

					return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
				}
			}
		});

		me.tap = function (e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};

		me.click = function (e) {
			var target = e.target,
			    ev;

			if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);

				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};

		return me;
	})();

	function IScroll(el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style; // cache style for better performance

		this.options = {

			resizeScrollbars: true,

			mouseWheelSpeed: 20,

			snapThreshold: 0.334,

			// INSERT POINT: OPTIONS

			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,

			bounce: true,
			bounceTime: 600,
			bounceEasing: '',

			preventDefault: true,
			preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

			HWCompositing: true,
			useTransition: true,
			useTransform: true
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		// Normalize options
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;

		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

		// If you want eventPassthrough I have to lock one of the axes
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

		// With eventPassthrough we also need lockDirection mechanism
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

		if (this.options.tap === true) {
			this.options.tap = 'tap';
		}

		if (this.options.shrinkScrollbars == 'scale') {
			this.options.useTransition = false;
		}

		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

		if (this.options.probeType == 3) {
			this.options.useTransition = false;
		}

		// INSERT POINT: NORMALIZATION

		// Some defaults	
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};

		// INSERT POINT: DEFAULTS

		this._init();
		this.refresh();

		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	}

	IScroll.prototype = {
		version: '5.1.3',

		_init: function _init() {
			this._initEvents();

			if (this.options.scrollbars || this.options.indicators) {
				this._initIndicators();
			}

			if (this.options.mouseWheel) {
				this._initWheel();
			}

			if (this.options.snap) {
				this._initSnap();
			}

			if (this.options.keyBindings) {
				this._initKeys();
			}

			// INSERT POINT: _init
		},

		destroy: function destroy() {
			this._initEvents(true);

			this._execEvent('destroy');
		},

		_transitionEnd: function _transitionEnd(e) {
			if (e.target != this.scroller || !this.isInTransition) {
				return;
			}

			this._transitionTime();
			if (!this.resetPosition(this.options.bounceTime)) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},

		_start: function _start(e) {
			// React to left mouse button only
			if (utils.eventType[e.type] != 1) {
				if (e.button !== 0) {
					return;
				}
			}

			if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    pos;

			this.initiated = utils.eventType[e.type];
			this.moved = false;
			this.distX = 0;
			this.distY = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;

			this._transitionTime();

			this.startTime = utils.getTime();

			this.stoppedTransition = false;
			if (this.options.useTransition && this.isInTransition) {
				this.stoppedTransition = true;
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if (!this.options.useTransition && this.isAnimating) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}

			this.startX = this.x;
			this.startY = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault) {
				// increases performance on Android? TODO: check!
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    deltaX = point.pageX - this.pointX,
			    deltaY = point.pageY - this.pointY,
			    timestamp = utils.getTime(),
			    newX,
			    newY,
			    absDistX,
			    absDistY;

			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this.distX += deltaX;
			this.distY += deltaY;
			absDistX = Math.abs(this.distX);
			absDistY = Math.abs(this.distY);

			// We need to move at least 10 pixels for the scrolling to initiate
			if (timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10)) {
				return;
			}

			// If you are scrolling in one direction lock the other
			if (!this.directionLocked && !this.options.freeScroll) {
				if (absDistX > absDistY + this.options.directionLockThreshold) {
					this.directionLocked = 'h'; // lock horizontally
				} else if (absDistY >= absDistX + this.options.directionLockThreshold) {
						this.directionLocked = 'v'; // lock vertically
					} else {
							this.directionLocked = 'n'; // no lock
						}
			}

			if (this.directionLocked == 'h') {
				if (this.options.eventPassthrough == 'vertical') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'horizontal') {
					this.initiated = false;
					return;
				}

				deltaY = 0;
			} else if (this.directionLocked == 'v') {
				if (this.options.eventPassthrough == 'horizontal') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'vertical') {
					this.initiated = false;
					return;
				}

				deltaX = 0;
			}

			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			// Slow down if outside of the boundaries
			if (newX > 0 || newX < this.maxScrollX) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if (newY > 0 || newY < this.maxScrollY) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}

			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

			if (!this.moved) {
				this._execEvent('scrollStart');
			}

			this.moved = true;

			this._translate(newX, newY);

			/* REPLACE START: _move */
			if (timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;

				if (this.options.probeType == 1) {
					this._execEvent('scroll');
				}
			}

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}
			/* REPLACE END: _move */
		},

		_end: function _end(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.changedTouches ? e.changedTouches[0] : e,
			    momentumX,
			    momentumY,
			    duration = utils.getTime() - this.startTime,
			    newX = Math.round(this.x),
			    newY = Math.round(this.y),
			    distanceX = Math.abs(newX - this.startX),
			    distanceY = Math.abs(newY - this.startY),
			    time = 0,
			    easing = '';

			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();

			// reset if we are outside of the boundaries
			if (this.resetPosition(this.options.bounceTime)) {
				return;
			}

			this.scrollTo(newX, newY); // ensures that the last position is rounded

			// we scrolled less than 10 pixels
			if (!this.moved) {
				if (!this.stoppedTransition) {
					if (this.options.tap) {
						utils.tap(e, this.options.tap);
					}

					if (this.options.click) {
						utils.click(e);
					}
				}

				this._execEvent('scrollCancel');
				return;
			}

			if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
				this._execEvent('flick');
				return;
			}

			// start momentum animation if needed
			if (this.options.momentum && duration < 300) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}

			if (this.options.snap) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
				newX = snap.x;
				newY = snap.y;

				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}

			// INSERT POINT: _end

			if (newX != this.x || newY != this.y) {
				// change easing function when scroller goes out of the boundaries
				if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
					easing = utils.ease.quadratic;
				}

				this.scrollTo(newX, newY, time, easing);
				return;
			}

			this._execEvent('scrollEnd');
		},

		_resize: function _resize() {
			var that = this;

			clearTimeout(this.resizeTimeout);

			this.resizeTimeout = setTimeout(function () {
				that.refresh();
			}, this.options.resizePolling);
		},

		resetPosition: function resetPosition(time) {
			var x = this.x,
			    y = this.y;

			time = time || 0;

			if (!this.hasHorizontalScroll || this.x > 0) {
				x = 0;
			} else if (this.x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (!this.hasVerticalScroll || this.y > 0) {
				y = 0;
			} else if (this.y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			if (x == this.x && y == this.y) {
				return false;
			}

			this.scrollTo(x, y, time, this.options.bounceEasing);

			return true;
		},

		disable: function disable() {
			this.enabled = false;
		},

		enable: function enable() {
			this.enabled = true;
		},

		refresh: function refresh() {
			var rf = this.wrapper.offsetHeight; // Force reflow

			this.wrapperWidth = this.wrapper.clientWidth;
			this.wrapperHeight = this.wrapper.clientHeight;

			/* REPLACE START: refresh */

			this.scrollerWidth = this.scroller.offsetWidth;
			this.scrollerHeight = this.scroller.offsetHeight;

			this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY = this.wrapperHeight - this.scrollerHeight;

			/* REPLACE END: refresh */

			this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

			if (!this.hasHorizontalScroll) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}

			if (!this.hasVerticalScroll) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}

			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;

			this.wrapperOffset = utils.offset(this.wrapper);

			this._execEvent('refresh');

			this.resetPosition();

			// INSERT POINT: _refresh
		},

		on: function on(type, fn) {
			if (!this._events[type]) {
				this._events[type] = [];
			}

			this._events[type].push(fn);
		},

		off: function off(type, fn) {
			if (!this._events[type]) {
				return;
			}

			var index = this._events[type].indexOf(fn);

			if (index > -1) {
				this._events[type].splice(index, 1);
			}
		},

		_execEvent: function _execEvent(type) {
			if (!this._events[type]) {
				return;
			}

			var i = 0,
			    l = this._events[type].length;

			if (!l) {
				return;
			}

			for (; i < l; i++) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},

		scrollBy: function scrollBy(x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;

			this.scrollTo(x, y, time, easing);
		},

		scrollTo: function scrollTo(x, y, time, easing) {
			easing = easing || utils.ease.circular;

			this.isInTransition = this.options.useTransition && time > 0;

			if (!time || this.options.useTransition && easing.style) {
				this._transitionTimingFunction(easing.style);
				this._transitionTime(time);
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},

		scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);

			if (!el) {
				return;
			}

			var pos = utils.offset(el);

			pos.left -= this.wrapperOffset.left;
			pos.top -= this.wrapperOffset.top;

			// if offsetX/Y are true we center the element to the screen
			if (offsetX === true) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if (offsetY === true) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}

			pos.left -= offsetX || 0;
			pos.top -= offsetY || 0;

			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

			this.scrollTo(pos.left, pos.top, time, easing);
		},

		_transitionTime: function _transitionTime(time) {
			time = time || 0;

			this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
			}

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTime(time);
				}
			}

			// INSERT POINT: _transitionTime
		},

		_transitionTimingFunction: function _transitionTimingFunction(easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}

			// INSERT POINT: _transitionTimingFunction
		},

		_translate: function _translate(x, y) {
			if (this.options.useTransform) {

				/* REPLACE START: _translate */

				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

				/* REPLACE END: _translate */
			} else {
					x = Math.round(x);
					y = Math.round(y);
					this.scrollerStyle.left = x + 'px';
					this.scrollerStyle.top = y + 'px';
				}

			this.x = x;
			this.y = y;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].updatePosition();
				}
			}

			// INSERT POINT: _translate
		},

		_initEvents: function _initEvents(remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
			    target = this.options.bindToWrapper ? this.wrapper : window;

			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);

			if (this.options.click) {
				eventType(this.wrapper, 'click', this, true);
			}

			if (!this.options.disableMouse) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}

			if (utils.hasPointer && !this.options.disablePointer) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}

			if (utils.hasTouch && !this.options.disableTouch) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}

			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},

		getComputedPosition: function getComputedPosition() {
			var matrix = window.getComputedStyle(this.scroller, null),
			    x,
			    y;

			if (this.options.useTransform) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}

			return { x: x, y: y };
		},

		_initIndicators: function _initIndicators() {
			var interactive = this.options.interactiveScrollbars,
			    customStyle = typeof this.options.scrollbars != 'string',
			    indicators = [],
			    indicator;

			var that = this;

			this.indicators = [];

			if (this.options.scrollbars) {
				// Vertical scrollbar
				if (this.options.scrollY) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}

				// Horizontal scrollbar
				if (this.options.scrollX) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}

			if (this.options.indicators) {
				// TODO: check concat compatibility
				indicators = indicators.concat(this.options.indicators);
			}

			for (var i = indicators.length; i--;) {
				this.indicators.push(new Indicator(this, indicators[i]));
			}

			// TODO: check if we can use array.map (wide compatibility and performance issues)
			function _indicatorsMap(fn) {
				for (var i = that.indicators.length; i--;) {
					fn.call(that.indicators[i]);
				}
			}

			if (this.options.fadeScrollbars) {
				this.on('scrollEnd', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollCancel', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1);
					});
				});

				this.on('beforeScrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1, true);
					});
				});
			}

			this.on('refresh', function () {
				_indicatorsMap(function () {
					this.refresh();
				});
			});

			this.on('destroy', function () {
				_indicatorsMap(function () {
					this.destroy();
				});

				delete this.indicators;
			});
		},

		_initWheel: function _initWheel() {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

			this.on('destroy', function () {
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},

		_wheel: function _wheel(e) {
			if (!this.enabled) {
				return;
			}

			e.preventDefault();
			e.stopPropagation();

			var wheelDeltaX,
			    wheelDeltaY,
			    newX,
			    newY,
			    that = this;

			if (this.wheelTimeout === undefined) {
				that._execEvent('scrollStart');
			}

			// Execute the scrollEnd event after 400ms the wheel stopped scrolling
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function () {
				that._execEvent('scrollEnd');
				that.wheelTimeout = undefined;
			}, 400);

			if ('deltaX' in e) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ('wheelDeltaX' in e) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ('wheelDelta' in e) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ('detail' in e) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}

			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;

			if (!this.hasVerticalScroll) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}

			if (this.options.snap) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;

				if (wheelDeltaX > 0) {
					newX--;
				} else if (wheelDeltaX < 0) {
					newX++;
				}

				if (wheelDeltaY > 0) {
					newY--;
				} else if (wheelDeltaY < 0) {
					newY++;
				}

				this.goToPage(newX, newY);

				return;
			}

			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

			if (newX > 0) {
				newX = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
			}

			if (newY > 0) {
				newY = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
			}

			this.scrollTo(newX, newY, 0);

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}

			// INSERT POINT: _wheel
		},

		_initSnap: function _initSnap() {
			this.currentPage = {};

			if (typeof this.options.snap == 'string') {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}

			this.on('refresh', function () {
				var i = 0,
				    l,
				    m = 0,
				    n,
				    cx,
				    cy,
				    x = 0,
				    y,
				    stepX = this.options.snapStepX || this.wrapperWidth,
				    stepY = this.options.snapStepY || this.wrapperHeight,
				    el;

				this.pages = [];

				if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
					return;
				}

				if (this.options.snap === true) {
					cx = Math.round(stepX / 2);
					cy = Math.round(stepY / 2);

					while (x > -this.scrollerWidth) {
						this.pages[i] = [];
						l = 0;
						y = 0;

						while (y > -this.scrollerHeight) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};

							y -= stepY;
							l++;
						}

						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;

					for (; i < l; i++) {
						if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
							m = 0;
							n++;
						}

						if (!this.pages[m]) {
							this.pages[m] = [];
						}

						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);

						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};

						if (x > this.maxScrollX) {
							m++;
						}
					}
				}

				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

				// Update snap threshold if needed
				if (this.options.snapThreshold % 1 === 0) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});

			this.on('flick', function () {
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);

				this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
			});
		},

		_nearestSnap: function _nearestSnap(x, y) {
			if (!this.pages.length) {
				return { x: 0, y: 0, pageX: 0, pageY: 0 };
			}

			var i = 0,
			    l = this.pages.length,
			    m = 0;

			// Check if we exceeded the snap threshold
			if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
				return this.currentPage;
			}

			if (x > 0) {
				x = 0;
			} else if (x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (y > 0) {
				y = 0;
			} else if (y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			for (; i < l; i++) {
				if (x >= this.pages[i][0].cx) {
					x = this.pages[i][0].x;
					break;
				}
			}

			l = this.pages[i].length;

			for (; m < l; m++) {
				if (y >= this.pages[0][m].cy) {
					y = this.pages[0][m].y;
					break;
				}
			}

			if (i == this.currentPage.pageX) {
				i += this.directionX;

				if (i < 0) {
					i = 0;
				} else if (i >= this.pages.length) {
					i = this.pages.length - 1;
				}

				x = this.pages[i][0].x;
			}

			if (m == this.currentPage.pageY) {
				m += this.directionY;

				if (m < 0) {
					m = 0;
				} else if (m >= this.pages[0].length) {
					m = this.pages[0].length - 1;
				}

				y = this.pages[0][m].y;
			}

			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},

		goToPage: function goToPage(x, y, time, easing) {
			easing = easing || this.options.bounceEasing;

			if (x >= this.pages.length) {
				x = this.pages.length - 1;
			} else if (x < 0) {
				x = 0;
			}

			if (y >= this.pages[x].length) {
				y = this.pages[x].length - 1;
			} else if (y < 0) {
				y = 0;
			}

			var posX = this.pages[x][y].x,
			    posY = this.pages[x][y].y;

			time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;

			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};

			this.scrollTo(posX, posY, time, easing);
		},

		next: function next(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x++;

			if (x >= this.pages.length && this.hasVerticalScroll) {
				x = 0;
				y++;
			}

			this.goToPage(x, y, time, easing);
		},

		prev: function prev(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x--;

			if (x < 0 && this.hasVerticalScroll) {
				x = 0;
				y--;
			}

			this.goToPage(x, y, time, easing);
		},

		_initKeys: function _initKeys(e) {
			// default key bindings
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;

			// if you give me characters I give you keycode
			if (typeof this.options.keyBindings == 'object') {
				for (i in this.options.keyBindings) {
					if (typeof this.options.keyBindings[i] == 'string') {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}

			for (i in keys) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}

			utils.addEvent(window, 'keydown', this);

			this.on('destroy', function () {
				utils.removeEvent(window, 'keydown', this);
			});
		},

		_key: function _key(e) {
			if (!this.enabled) {
				return;
			}

			var snap = this.options.snap,
			    // we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			    newY = snap ? this.currentPage.pageY : this.y,
			    now = utils.getTime(),
			    prevTime = this.keyTime || 0,
			    acceleration = 0.250,
			    pos;

			if (this.options.useTransition && this.isInTransition) {
				pos = this.getComputedPosition();

				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}

			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

			switch (e.keyCode) {
				case this.options.keyBindings.pageUp:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX += snap ? 1 : this.wrapperWidth;
					} else {
						newY += snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.pageDown:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX -= snap ? 1 : this.wrapperWidth;
					} else {
						newY -= snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.end:
					newX = snap ? this.pages.length - 1 : this.maxScrollX;
					newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
					break;
				case this.options.keyBindings.home:
					newX = 0;
					newY = 0;
					break;
				case this.options.keyBindings.left:
					newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.up:
					newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.right:
					newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.down:
					newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				default:
					return;
			}

			if (snap) {
				this.goToPage(newX, newY);
				return;
			}

			if (newX > 0) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}

			if (newY > 0) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}

			this.scrollTo(newX, newY, 0);

			this.keyTime = now;
		},

		_animate: function _animate(destX, destY, duration, easingFn) {
			var that = this,
			    startX = this.x,
			    startY = this.y,
			    startTime = utils.getTime(),
			    destTime = startTime + duration;

			function step() {
				var now = utils.getTime(),
				    newX,
				    newY,
				    easing;

				if (now >= destTime) {
					that.isAnimating = false;
					that._translate(destX, destY);

					if (!that.resetPosition(that.options.bounceTime)) {
						that._execEvent('scrollEnd');
					}

					return;
				}

				now = (now - startTime) / duration;
				easing = easingFn(now);
				newX = (destX - startX) * easing + startX;
				newY = (destY - startY) * easing + startY;
				that._translate(newX, newY);

				if (that.isAnimating) {
					rAF(step);
				}

				if (that.options.probeType == 3) {
					that._execEvent('scroll');
				}
			}

			this.isAnimating = true;
			step();
		},

		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
				case 'orientationchange':
				case 'resize':
					this._resize();
					break;
				case 'transitionend':
				case 'webkitTransitionEnd':
				case 'oTransitionEnd':
				case 'MSTransitionEnd':
					this._transitionEnd(e);
					break;
				case 'wheel':
				case 'DOMMouseScroll':
				case 'mousewheel':
					this._wheel(e);
					break;
				case 'keydown':
					this._key(e);
					break;
				case 'click':
					if (!e._constructed) {
						e.preventDefault();
						e.stopPropagation();
					}
					break;
			}
		}
	};
	function createDefaultScrollbar(direction, interactive, type) {
		var scrollbar = document.createElement('div'),
		    indicator = document.createElement('div');

		if (type === true) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}

		indicator.className = 'iScrollIndicator';

		if (direction == 'h') {
			if (type === true) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if (type === true) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}

		scrollbar.style.cssText += ';overflow:hidden';

		if (!interactive) {
			scrollbar.style.pointerEvents = 'none';
		}

		scrollbar.appendChild(indicator);

		return scrollbar;
	}

	function Indicator(scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;

		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;

		if (this.options.interactive) {
			if (!this.options.disableTouch) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}

		if (this.options.fade) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
			this.wrapperStyle.opacity = '0';
		}
	}

	Indicator.prototype = {
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
			}
		},

		destroy: function destroy() {
			if (this.options.interactive) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);

				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);

				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}

			if (this.options.defaultScrollbars) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},

		_start: function _start(e) {
			var point = e.touches ? e.touches[0] : e;

			e.preventDefault();
			e.stopPropagation();

			this.transitionTime();

			this.initiated = true;
			this.moved = false;
			this.lastPointX = point.pageX;
			this.lastPointY = point.pageY;

			this.startTime = utils.getTime();

			if (!this.options.disableTouch) {
				utils.addEvent(window, 'touchmove', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(window, 'mousemove', this);
			}

			this.scroller._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			var point = e.touches ? e.touches[0] : e,
			    deltaX,
			    deltaY,
			    newX,
			    newY,
			    timestamp = utils.getTime();

			if (!this.moved) {
				this.scroller._execEvent('scrollStart');
			}

			this.moved = true;

			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;

			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			this._pos(newX, newY);

			if (this.scroller.options.probeType == 1 && timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.scroller._execEvent('scroll');
			} else if (this.scroller.options.probeType > 1) {
				this.scroller._execEvent('scroll');
			}

			// INSERT POINT: indicator._move

			e.preventDefault();
			e.stopPropagation();
		},

		_end: function _end(e) {
			if (!this.initiated) {
				return;
			}

			this.initiated = false;

			e.preventDefault();
			e.stopPropagation();

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			if (this.scroller.options.snap) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

				if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}

			if (this.moved) {
				this.scroller._execEvent('scrollEnd');
			}
		},

		transitionTime: function transitionTime(time) {
			time = time || 0;
			this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
			}
		},

		transitionTimingFunction: function transitionTimingFunction(easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},

		refresh: function refresh() {
			this.transitionTime();

			if (this.options.listenX && !this.options.listenY) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if (this.options.listenY && !this.options.listenX) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}

			if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}

			var r = this.wrapper.offsetHeight; // force refresh

			if (this.options.listenX) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if (this.options.resize) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}

				this.maxPosX = this.wrapperWidth - this.indicatorWidth;

				if (this.options.shrink == 'clip') {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}

				this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
			}

			if (this.options.listenY) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if (this.options.resize) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;

				if (this.options.shrink == 'clip') {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
			}

			this.updatePosition();
		},

		updatePosition: function updatePosition() {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			    y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

			if (!this.options.ignoreBoundaries) {
				if (x < this.minBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if (x > this.maxBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}

				if (y < this.minBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if (y > this.maxBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}

			this.x = x;
			this.y = y;

			if (this.scroller.options.useTransform) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},

		_pos: function _pos(x, y) {
			if (x < 0) {
				x = 0;
			} else if (x > this.maxPosX) {
				x = this.maxPosX;
			}

			if (y < 0) {
				y = 0;
			} else if (y > this.maxPosY) {
				y = this.maxPosY;
			}

			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

			this.scroller.scrollTo(x, y);
		},

		fade: function fade(val, hold) {
			if (hold && !this.visible) {
				return;
			}

			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;

			var time = val ? 250 : 500,
			    delay = val ? 0 : 300;

			val = val ? '1' : '0';

			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

			this.fadeTimeout = setTimeout((function (val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}).bind(this, val), delay);
		}
	};

	IScroll.utils = utils;

	if (typeof module != 'undefined' && module.exports) {
		module.exports = IScroll;
	} else {
		window.IScroll = IScroll;
	}
})(window, document, Math);
/*! iScroll v5.1.3 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */

},{}],250:[function(require,module,exports){
(function (process){
// options

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

// end of options

require("colors");

var options = {
	min: "trace",
	log: 1,
	stub: {},
	srv: {
		ws: {},
		boss: 1 && {},
		modem: 1 && {
			proxy: 1 && {
				data: 1 && {},
				log: 1 && {}
			}
		}
	},
	modem: 1 && {
		transform: 1 && {}
	},
	boss: 0 && {},
	http: 1 && {},
	ui: 0 && {
		event: 0 && {}
	}
};

var log_stream = process.stderr || { write: console.log.bind(console) };

var prefixes = {
	trace: "TRACE ".green,
	error: "ERROR ".yellow,
	fatal: "FATAL ".red
};

var values = {};
var current = 0;
var main = Object.create(null);
var method = function method(name) {
	values[name] = ++current;
	return main[name] = Log.bind(null, name);
};

function getValue(kind) {
	return values[kind] || values.log || 0;
}

function Log() {
	var l = options;
	if (l === false || l === 0) return;
	var kind = arguments[0];
	if (getValue(kind) < getValue(options.min)) return;
	for (var i = 1; i < arguments.length - 1; ++i) {
		l = l[arguments[i]];
		if (l === false || l === 0) return;
		if (l == null) break;
	}
	var path = "";
	for (var i = 1; i < arguments.length - 1; ++i) {
		path += " ";
		path += arguments[i];
	}
	var msg = arguments[arguments.length - 1];
	log_stream.write("" + (prefixes[kind] || "") + ("" + new Date().toISOString().replace("T", ";").replace("Z", "") + path + ":").gray + " " + msg + "\n");
	log_stream.flush && log_stream.flush();
}

// order of methods does matter. The later the important.
var trace = method("trace");
exports.trace = trace;
var log = method("log");
exports.log = log;
var error = method("error");
exports.error = error;
var fatal = method("fatal");

exports.fatal = fatal;
var open = (function open() {
	var ret = Object.create(null);
	ret.open = open;

	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	for (var kind in main) {
		var _kind;

		ret[kind] = (_kind = this[kind]).bind.apply(_kind, [null].concat(args));
	}return ret;
}).bind(main);

exports.open = open;
var setStream = function setStream(stream) {
	return log_stream = stream;
};

exports.setStream = setStream;
log("log", "start", JSON.stringify(process.argv));

}).call(this,require('_process'))

},{"_process":192,"colors":225}],252:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.update_crc = update_crc;
exports.calc_crc = calc_crc;
exports.append_crc = append_crc;
var marked0$0 = [append_crc].map(regeneratorRuntime.mark);
var initial_crc = 0x0000;

exports.initial_crc = initial_crc;

function update_crc(crc, byte) {
	//  ,    ,  
	//     :)
	for (var i = 0; i < 8; i++) {
		if (crc & 0x8000) {
			crc <<= 1;
			crc &= 0xffff;
			if (byte & 0x0001) crc |= 0x0001;
			crc ^= 0x1021;
		} else {
			crc <<= 1;
			crc &= 0xffff;
			if (byte & 0x0001) crc |= 0x0001;
		}
		byte = byte >> 1;
	}
	return crc;
}

function iterable(data) {
	if (data[Symbol.iterator] || data.next) return data;else return regeneratorRuntime.mark(function callee$1$0() {
		var i;
		return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
			while (1) switch (context$2$0.prev = context$2$0.next) {
				case 0:
					i = 0;

				case 1:
					if (!(i < data.length)) {
						context$2$0.next = 7;
						break;
					}

					context$2$0.next = 4;
					return data[i];

				case 4:
					++i;
					context$2$0.next = 1;
					break;

				case 7:
				case "end":
					return context$2$0.stop();
			}
		}, callee$1$0, this);
	});
}

function calc_crc(data) {
	var crc = initial_crc;
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = iterable(data)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var temp = _step.value;

			crc = update_crc(crc, temp);
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator["return"]) {
				_iterator["return"]();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return crc;
}

function append_crc(data) {
	var first, crc, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, b;

	return regeneratorRuntime.wrap(function append_crc$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				first = true;
				crc = initial_crc;
				_iteratorNormalCompletion2 = true;
				_didIteratorError2 = false;
				_iteratorError2 = undefined;
				context$1$0.prev = 5;
				_iterator2 = iterable(data)[Symbol.iterator]();

			case 7:
				if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
					context$1$0.next = 16;
					break;
				}

				b = _step2.value;

				crc = update_crc(crc, b);
				context$1$0.next = 12;
				return b;

			case 12:
				first = false;

			case 13:
				_iteratorNormalCompletion2 = true;
				context$1$0.next = 7;
				break;

			case 16:
				context$1$0.next = 22;
				break;

			case 18:
				context$1$0.prev = 18;
				context$1$0.t0 = context$1$0["catch"](5);
				_didIteratorError2 = true;
				_iteratorError2 = context$1$0.t0;

			case 22:
				context$1$0.prev = 22;
				context$1$0.prev = 23;

				if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
					_iterator2["return"]();
				}

			case 25:
				context$1$0.prev = 25;

				if (!_didIteratorError2) {
					context$1$0.next = 28;
					break;
				}

				throw _iteratorError2;

			case 28:
				return context$1$0.finish(25);

			case 29:
				return context$1$0.finish(22);

			case 30:
				context$1$0.next = 32;
				return crc & 0xff;

			case 32:
				context$1$0.next = 34;
				return crc >> 8 & 0xff;

			case 34:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[0], this, [[5, 18, 22, 30], [23,, 25, 29]]);
}

},{}],253:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _stream = require("stream");

var stream = _interopRequireWildcard(_stream);

var _sf = require("sf");

var sf = _interopRequireWildcard(_sf);

var _uid = require("uid");

var _uid2 = _interopRequireDefault(_uid);

var INTERVAL = 60000;
var TIMEOUT = 9000;
var MAX_PINGS = 2000;

// this - filtered stream
// this.other - stream with pingpongs

exports.default = function () {
	var _ref = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

	var _ref$log = _ref.log;
	var log = _ref$log === undefined ? null : _ref$log;
	var _ref$interval = _ref.interval;
	var interval = _ref$interval === undefined ? INTERVAL : _ref$interval;
	var _ref$timeout = _ref.timeout;
	var timeout = _ref$timeout === undefined ? TIMEOUT : _ref$timeout;
	var _ref$maxpings = _ref.maxpings;
	var maxpings = _ref$maxpings === undefined ? MAX_PINGS : _ref$maxpings;

	var pings = new Map();
	var writer = new stream.Transform({ objectMode: true, transform: function transform(data, chunk, callback) {
			writer.push(data);
			ping();
			callback();
		} });
	var reader = new stream.Transform({ objectMode: true, transform: function transform(data, chunk, callback) {
			if (data.what == "ping") writer.push({ what: "pong", pong: data.ping });else if (data.what == "pong") onpong(data.pong);else this.push(data);
			callback();
		} });
	reader.on("end", cleanup);
	reader.on("finish", cleanup);
	writer.on("end", cleanup);
	writer.on("finish", cleanup);
	var timer = undefined;
	function onTimer() {
		timer = setTimeout(onTimer, interval);
		ping();
	}
	onTimer();
	function cleanup() {
		clearTimeout(timer);
		pings = null;
	}
	function onpong(id) {
		if (pings.has(id)) {
			clearTimeout(pings.get(id));
			pings.delete(id);
			if (ret.waitingForFirstPing) {
				ret.waitingForFirstPing = false;
				ret.emit("open");
			}
		}
	}
	function ping() {
		if (!pings) return;
		if (pings.size >= maxpings) {
			log && log.error("too many pings");
			ontimeout();
			return;
		}
		var id = (0, _uid2.default)();
		writer.push({ what: "ping", ping: id });
		pings.set(id, setTimeout(function () {
			log && log.error("time out on " + id);
			ontimeout();
		}, timeout));
	}
	function ontimeout() {
		writer.emit("error", new Error("timeout"));
		writer.push(null);
		reader.push(null);
	}
	var ret = sf.duplexer(writer, reader);
	ret.waitingForFirstPing = true;
	return ret;
};

module.exports = exports.default;

},{"sf":256,"stream":210,"uid":281}],254:[function(require,module,exports){
"use strict";

Object.defineProperty(Object.prototype, "_LOG_", { value: function value() {
		console.log(this);
		return this;
	}, configurable: true });

if (typeof Symbol == "function" && Symbol.iterator) {
	var x = null;
	try {
		x = eval.call(null, "(function*(){}().constructor.prototype)");
	} catch (_) {}
	if (x && !x[Symbol.iterator]) x[Symbol.iterator] = function () {
		return this;
	};
}

},{}],255:[function(require,module,exports){
(function (process){
/*

TODO:

* Warning if a live property has not been read during the life time of observable value or during some period of time (e.g. 1-30 minutes) since creating that observable value.

* check for changes during execution of (function*) and restart calculus.


TODO BUG:
let app = ra( {
	moving1: {
		a: 1,
		b: 2,
		c: {
			d: 3,
		},
	},
}
_app.moving1.a
1
_app.moving1.c.d
3
_app.moving1={a:4}
Object {a: 4}
_app.moving1.c.d
3                       <----------- !!!  MUST BE NULL !!!!
_app.moving1.c
Cell {_id: "j87yqkoqppuv", _value: null, _error: null, _isValueEqual: function, _initialized: true}
_app.moving1.c.valueOf()
null


*/

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

exports.default = ra;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _co = require("co");

var co = _interopRequireWildcard(_co);

var _uid = require("uid");

var _uid2 = _interopRequireDefault(_uid);

var _diff = require("diff");

var Diff = _interopRequireWildcard(_diff);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var Actions = new WeakMap();
var Values = new WeakSet();

// let debugLog = false

var checkNull = function checkNull(value) {
	return value == null ? null : value;
};
var getValue = function getValue(value) {
	return value == null || value.valueOf == null ? value : value.valueOf();
};
var isLiteral = function isLiteral(value) {
	return value && typeof value == "object" && value.constructor == Object;
};

var usedPropsGuard = function usedPropsGuard() {
	_classCallCheck(this, usedPropsGuard);
};

var AbstractGuard = (function (_usedPropsGuard) {
	_inherits(AbstractGuard, _usedPropsGuard);

	function AbstractGuard() {
		_classCallCheck(this, AbstractGuard);

		_get(Object.getPrototypeOf(AbstractGuard.prototype), "constructor", this).apply(this, arguments);
	}

	return AbstractGuard;
})(usedPropsGuard);

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {

	for (var _iterator = "toString valueOf toLocaleString hasOwnProperty isPrototypeOf propertyIsEnumerable".split(" ")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
		var i = _step.value;

		Object.defineProperty(AbstractGuard.prototype, i, { value: ({})[i], enumerable: false });
	}
} catch (err) {
	_didIteratorError = true;
	_iteratorError = err;
} finally {
	try {
		if (!_iteratorNormalCompletion && _iterator["return"]) {
			_iterator["return"]();
		}
	} finally {
		if (_didIteratorError) {
			throw _iteratorError;
		}
	}
}

Object.defineProperty(AbstractGuard.prototype, "$name", { value: "<...>", enumerable: false, writable: true });

var invalidKeyCall = function invalidKeyCall(key) {
	throw new Error("access to an undeclared property \"" + this.$name + "." + key + "\"");
};

var guardProp = function guardProp(key) {
	if (!Object.prototype.hasOwnProperty.call(usedPropsGuard.prototype, key)) {
		Object.defineProperty(usedPropsGuard.prototype, key, {
			get: function get() {
				invalidKeyCall.call(this, key);
			},
			set: function set() {
				invalidKeyCall.call(this, key);
			}
		});
		// console.log( Object.keys( usedPropsGuard.prototype ).length )
		// console.log( Object.getOwnPropertyNames( usedPropsGuard.prototype ).length )
	}
};

//   ,   Proxy    .
//  , ,     (2014.11.25)

// if ( typeof Proxy == "function" ) {
// 	AbstractGuard.prototype = new Proxy( AbstractGuard.prototype, {
// 		get: function ( _, key ) { invalidKeyCall.call( this, key ) },
// 		set: function ( _, key ) { invalidKeyCall.call( this, key ) },
// 	} )
// }

// if ( global.APP_DEBUG ) {
// 	//
// 	// ' '  ~700-800    /
// 	//   Google Chrome'   .
// 	//  :
// 	// -     Object.defineProperty
// 	// -    Object.defineProperties
// 	// -     eval
// 	// -     eval
// 	// -      script  
// 	//   :
// 	// -   script   src
// 	//   ():
// 	// -      '   '
// 	//   .     '  
// 	//     ,      ,     
// 	//  .
// 	//
// 	//     .
// 	//
// 	//        ' 
// 	//    .
// 	//
// 	AbstractGuard.prototype =
// 		( global.__UsedScriptIdentifiers__ + `` )
// 		.split( /[\s,]+/ )
// 		.reduce( ( proto, key ) =>
// 			Object.create( proto, { [ key ]: {
// 				get: function () { invalidKeyCall.call( this, key ) },
// 				set: function ( _ ) { invalidKeyCall.call( this, key ) },
// 			} } ),
// 			AbstractGuard.prototype )
// }

var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);

var ImmutableInterface = (function (_AbstractGuard) {
	_inherits(ImmutableInterface, _AbstractGuard);

	function ImmutableInterface() {
		_classCallCheck(this, ImmutableInterface);

		_get(Object.getPrototypeOf(ImmutableInterface.prototype), "constructor", this).apply(this, arguments);
	}

	_createClass(ImmutableInterface, [{
		key: "get",
		value: function get(key) {
			if (key != null) {
				var m = this.valueOf();
				if (m != null && Object.prototype.hasOwnProperty.call(m, key)) return m[key];
			}
			return null;
		}
	}, {
		key: "map",
		value: function map(fun) {
			var m = this.valueOf();
			return m && (Array.isArray(m) ? lodash.map(m, fun) : lodash.mapValues(m, fun));
		}
	}, {
		key: "keys",
		value: function keys() {
			var m = this.valueOf();
			return m == null ? EMPTY_ARRAY : Object.keys(m);
		}
	}, {
		key: "props",

		// debugger
		get: function get() {
			throw new Error("access to deprecated 'props' property detected");
		}
	}, {
		key: "declaredProperties",
		get: function get() {
			return this.live;
		}
	}, {
		key: "length",
		get: function get() {
			var m = this.valueOf();return m == null ? 0 : Object.keys(m).length;
		}
	}]);

	return ImmutableInterface;
})(AbstractGuard);

var ReadOnlyCell = (function (_ImmutableInterface) {
	_inherits(ReadOnlyCell, _ImmutableInterface);

	function ReadOnlyCell(parent) {
		_classCallCheck(this, ReadOnlyCell);

		_get(Object.getPrototypeOf(ReadOnlyCell.prototype), "constructor", this).call(this);
		this._parent = parent;
	}

	_createClass(ReadOnlyCell, [{
		key: "getReadOnly",
		value: function getReadOnly() {
			return this;
		}
	}, {
		key: "valueOf",
		value: function valueOf() {
			return this._parent.valueOf.apply(this._parent, arguments);
		}
	}, {
		key: "noTouch",
		value: function noTouch() {
			return this._parent.noTouch.apply(this._parent, arguments);
		}
	}, {
		key: "toString",
		value: function toString() {
			return this._parent.toString.apply(this._parent, arguments);
		}
	}, {
		key: "toJSON",
		value: function toJSON() {
			return this._parent.toJSON.apply(this._parent, arguments);
		}
	}, {
		key: "getName",
		value: function getName() {
			return this._parent.getName.apply(this._parent, arguments);
		}
	}, {
		key: "live",
		get: function get() {
			return this._parent.live;
		}
	}]);

	return ReadOnlyCell;
})(ImmutableInterface);

var Getter = function Getter(fun, isValueEqual) {
	var last = undefined;
	var ret = !isValueEqual ? function () {
		return fun.apply(this, arguments);
	} : function () {
		var ret = fun.apply(this, arguments);
		if (!is(last, ret, isValueEqual)) last = ret;
		return last;
	};
	ret.isGetter = true;
	return ret;
};

var Type = function Type(f) {
	g.typeDescriptor = true;
	return g;
	function g() {
		return f.apply(this, arguments);
	}
};

var runGetter = function runGetter(cell, getter) {
	return new Action(getter, cell);
};

var runSetter = function runSetter(cell, setter) {
	return new Action(function () {
		return setter(cell.valueOf());
	}, null);
};

function is(a, b, isEqual) {
	return Object.is(a, b) || b && typeof b.isEqualTo == "function" && b.isEqualTo(a) || a && typeof a.isEqualTo == "function" && a.isEqualTo(b) || typeof isEqual == "function" && isEqual(a, b);
}

var This = (function () {
	function This() {
		_classCallCheck(this, This);
	}

	_createClass(This, [{
		key: "_defineThatProperty",
		value: function _defineThatProperty(key, that) {
			Object.defineProperty(this, key, {
				configurable: true,
				enumerable: true,
				get: function get() {
					return that[key];
				},
				set: function set(value) {
					that[key] = value;
				}
			});
		}
	}], [{
		key: "create",
		value: function create(parent, that) {
			var ret = null;
			if (!parent) ret = new This();else ret = Object.create(parent);
			ret.valueOf = function () {
				return that.valueOf();
			};
			ret.toString = function () {
				return that.toString();
			};
			ret.toJSON = function () {
				return that.toJSON();
			};
			ret.assign = function (value) {
				return that.assign(value);
			};
			ret.throw = function (value) {
				return that.throw(value);
			};
			Object.defineProperty(ret, "live", { get: function get() {
					return that.live;
				} });
			return ret;
		}
	}]);

	return This;
})();

var Cell = (function (_ImmutableInterface2) {
	_inherits(Cell, _ImmutableInterface2);

	function Cell() {
		_classCallCheck(this, Cell);

		_get(Object.getPrototypeOf(Cell.prototype), "constructor", this).call(this);
		this._id = (0, _uid2.default)();
		this._that = null;
		this._value = null;
		this._error = null;
		this._isValueEqual = is;
		this._initialized = false;
		this._frozen = false;
		this._closed = false;
		this._dirty = false;
		this._live = null;
		this._liveArray = null;
		this._actionsArr = [];
		this._parent = null;
		this._notifyWritten();
		Values.add(this);
	}

	_createClass(Cell, [{
		key: "valueOf",
		value: function valueOf() {
			return this._read();
		}
	}, {
		key: "assign",
		value: function assign(value) {
			return this._write(value, false, null);
		}
	}, {
		key: "update",
		value: function update(diff) {
			return this.assign(Diff.apply(this.noTouch(), diff));
		}
	}, {
		key: "throw",
		value: function _throw(value) {
			return this._write(null, false, value);
		}
	}, {
		key: "touch",
		value: function touch() {
			this._fire();
		}
	}, {
		key: "noTouch",
		value: function noTouch() {
			if (this._dirty) this._updateSelf();
			if (this._error) throw this._error;
			return this._value;
		}
	}, {
		key: "then",
		value: function then(mapvalue, maperror) {
			var _this = this;

			if (mapvalue != null && typeof mapvalue != "function" || maperror != null && typeof maperror != "function" || mapvalue == null && maperror == null) throw new Error("ra.then: wrong parameters");
			return ra(maperror == null ? function () {
				return mapvalue(_this.valueOf());
			} : function () {
				var value = undefined;
				try {
					value = _this.valueOf();
				} catch (error) {
					return maperror(error);
				}
				return mapvalue == null ? value : mapvalue(value);
			});
		}
	}, {
		key: "catch",
		value: function _catch(maperror) {
			return this.then(null, maperror);
		}
	}, {
		key: "close",
		value: function close() {
			if (this._closed) return;
			this._closed = true;
			this._fire();
			if (this._parent) this._parent.close();
			if (this._liveArray) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = this._liveArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var p = _step2.value;

						p.close();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}

				this._liveArray = null;
			}
			this._value = null;
			this._error = null;
			this._actionsArr = null;
			this._parent = null;
		}
	}, {
		key: "freeze",
		value: function freeze() {
			if (this._closed || this._frozen) return;
			this._frozen = true;
			this._fire(); // TODO      _fire     
			if (this._parent) this._parent.freeze();
			if (this._liveArray) {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = this._liveArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var p = _step3.value;

						p.freeze();
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
							_iterator3["return"]();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			}
		}
	}, {
		key: "getReadOnly",
		value: function getReadOnly() {
			return this._readOnly || (this._readOnly = new ReadOnlyCell(this));
		}
	}, {
		key: "toString",
		value: function toString() {
			var v = this._read();
			return v == null || !v.toString ? "" + v : v.toString.apply(v, arguments);
		}
	}, {
		key: "toJSON",
		value: function toJSON() {
			var v = this._read();
			return v == null || !v.toJSON ? v : v.toJSON.apply(v, arguments);
		}
	}, {
		key: "with",
		value: function _with(cb) {
			return cb.call(this._getThat());
		}
	}, {
		key: "setName",
		value: function setName(name) {
			this._name = name;
			return this;
		}
	}, {
		key: "getName",
		value: function getName() {
			var ret = this._name || this._key;
			var p = this._parent;
			while (p) {
				ret = (p._name || p._key) + "." + ret;
				p = p._parent;
			}
			return ret;
		}
	}, {
		key: "_getThat",
		value: function _getThat() {
			if (!this._that) {
				this._that = This.create(this._parent && this._parent._getThat(), this);
				if (this._live) for (var i in this._live) {
					this._that._defineThatProperty(i, this);
				}
			}
			return this._that;
		}
	}, {
		key: "defineProperty",
		value: function defineProperty(key) {
			// pass key == `` to make Cell object, not value
			if (!this._live) {
				this._live = Object.create(null);
				this._liveArray = [];
			}
			if (!key) return;
			guardProp(key);
			var c = this._live[key];
			if (c) return c;
			c = new Cell();
			this._live[key] = c;
			this._liveArray.push(c);
			c._key = key;
			c._parent = this;
			c._level = (this._level || 0) + 1;
			Object.defineProperty(this, key, {
				enumerable: true,
				configurable: true,
				get: function get() {
					if (c._live) return c;else return c._read();
				},
				set: function set(value) {
					if (c._live) value = getValue(value);
					c._write(value, false);
				}
			});
			if (this._that) this._that._defineThatProperty(key, this);
			if (this._value != null) c._write(this._value[key], true);
			return c;
		}
	}, {
		key: "init",
		value: function init(value) {
			this._init(value, false, false);
		}
	}, {
		key: "setConst",
		value: function setConst(prop, value) {
			Object.defineProperty(this, prop, { enumerable: true, get: function get() {
					return value;
				} });
			return this;
		}
	}, {
		key: "setVar",
		value: function setVar(prop, value) {
			Object.defineProperty(this, prop, { enumerable: true, writable: true, value: value });
			return this;
		}
	}, {
		key: "_init",
		value: function _init(value, recursive, isGetter, isValueEqual) {
			var cell = this;
			if (!recursive && cell._initialized) throw new Error("already initialized");
			if (this._parent) this._parent._dirty = true;
			cell._initialized = true;
			if (isValueEqual) this._isValueEqual = isValueEqual;
			value = checkNull(value);
			if (typeof value == "function" && value.typeDescriptor) value = value(cell._key);
			if (value == null) // we are already null at the point of birth
				return;
			if (Values.has(value)) // force just a value
				return cell._value = value;
			if (typeof value == "function") {
				if (isGetter || value.isGetter) // getter
					runGetter(cell, function () {
						return value.call(cell._parent && cell._parent._getThat());
					});else // method
					cell._value = function () {
						return value.apply(cell._parent && cell._parent._getThat(), arguments);
					};
				return;
			}
			if (!isLiteral(value)) {
				// just a value or a promise
				if (typeof value.then == "function") value.then(cell.assign.bind(cell), cell.throw.bind(cell));else cell._value = value;
				return;
			}
			// subrecord description
			if (recursive) throw new Error("wrong parameters");
			cell.defineProperty();
			for (var key in value) {
				var descr = Object.getOwnPropertyDescriptor(value, key);
				if (!descr) continue;
				var get = descr.get;
				var subValue = descr.value;
				if (descr.set) throw new Error("wrong parameters");else if (get) subValue = get;
				if (key == "$") cell._init(subValue, true, !!get);else cell.defineProperty(key, true)._init(subValue, false, !!get);
			}
		}
	}, {
		key: "_read",
		value: function _read() {
			if (this._dirty) this._updateSelf();
			var action = Actions.get(co.global);
			if (action) {
				if (this._closed) action.close();else if (!this._frozen) action.onread(this);
			}
			if (this._error) throw this._error;
			return this._value;
		}
	}, {
		key: "_write",
		value: function _write(newValue, down, newError) {
			if (newError == null) newError = null;
			if (this._frozen) throw new Error("Try to change a frozen value");
			this._initialized = true;
			this._dirty = false;
			newValue = checkNull(newValue);
			if (this._closed) {
				var action = Actions.get(co.global);
				if (action) action.close();
			} else if (!this._isValueEqual(this._value, newValue) || this._error != newError) {
				// console.log(`>`+this.$name)//debugger
				this._value = newValue;
				this._error = newError;
				if (this._live) {
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = this._liveArray[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var p = _step4.value;

							p._write(newValue && newValue[p._key], true);
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
								_iterator4["return"]();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
				}this._fire();
				if (!down) {
					var p = this._parent;
					while (p && !p._dirty) {
						p._dirty = true;
						p._fire();
						p = p._parent;
					}
				}
			}
			if (!down) this._notifyWritten();
			return newValue;
		}
	}, {
		key: "_updateSelf",
		value: function _updateSelf() {
			var cnt = 0;
			var ret = {};
			for (var key in this._value) {
				if (Object.prototype.hasOwnProperty.call(this._value, key)) {
					ret[key] = this._value[key];
					++cnt;
				}
			}var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = this._liveArray[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var p = _step5.value;

					if (p._dirty) p._updateSelf();
					if (p._error) {
						this._error = p._error;
						this._value = null;
						this._dirty = false;
						return;
					}
					var value = p._value;
					if (value == null) {
						if (Object.prototype.hasOwnProperty.call(ret, p._key)) {
							delete ret[p._key];
							--cnt;
						}
					} else {
						ret[p._key] = value;
						cnt = Infinity;
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
						_iterator5["return"]();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			if (cnt == 0) ret = null;

			this._value = ret;
			this._dirty = false;
		}
	}, {
		key: "debug",
		value: function debug(cb) {
			this._actionsArr.push({ action: { _fire: cb } });
		}
	}, {
		key: "debugger",
		value: function _debugger() {
			this.debug(function () {
				debugger;
			});
		}
	}, {
		key: "_fire",
		value: function _fire() {
			var a = undefined;
			a = this._actionsArr;
			if (a.length) {
				for (var i = 0; i < a.length; i++) {
					var c = a[i];
					if (c.action) c.action._fire();
					c.pushedC = false;
				}
				a.length = 0;
			}
		}
	}, {
		key: "_notifyWritten",
		value: function _notifyWritten() {
			var action = Actions.get(co.global);
			if (action) action.onwritten(this);
		}
	}, {
		key: "changed",
		get: function get() {
			var _this2 = this;

			return this._actionsArr && { then: function then(proc) {
					return _this2._actionsArr.push({ action: { _fire: function _fire() {
								return process.nextTick(proc);
							} } });
				} };
		}
	}, {
		key: "live",
		get: function get() {
			return this._live;
		}
	}]);

	return Cell;
})(ImmutableInterface);

var rethrow = function rethrow(error) {
	return setTimeout(function () {
		throw error;
	}, 1);
};

var Action = (function () {
	function Action(fun, dest) {
		_classCallCheck(this, Action);

		this._id = (0, _uid2.default)();
		this._fun = fun;
		this._dest = dest;
		this._cellSet = Object.create(null);
		this._cellSetSize = 0;
		this._cellArr = [];
		this._thread = co.go(this._loop.bind(this)).waitForInput();
	}

	_createClass(Action, [{
		key: "_loop",
		value: regeneratorRuntime.mark(function _loop() {
			var next, isError, ret;
			return regeneratorRuntime.wrap(function _loop$(context$2$0) {
				var _this3 = this;

				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						next = { then: function then(next) {
								_this3._onchange = next;
							} };

						Actions.set(co.global, this);
						co.defer(function () {
							Actions.delete(co.global);
							_this3._finalize();
						});
						context$2$0.next = 5;
						return;

					case 5:
						if (!this.isClosed()) {
							context$2$0.next = 7;
							break;
						}

						return context$2$0.abrupt("return");

					case 7:
						this._begin();
						isError = false;
						ret = undefined;
						context$2$0.prev = 10;

						ret = (0, this._fun)();

						if (!(ret && !Values.has(ret) && (ret.next || ret.then))) {
							context$2$0.next = 16;
							break;
						}

						context$2$0.next = 15;
						return ret;

					case 15:
						ret = context$2$0.sent;

					case 16:
						context$2$0.next = 22;
						break;

					case 18:
						context$2$0.prev = 18;
						context$2$0.t0 = context$2$0["catch"](10);

						isError = true;
						ret = context$2$0.t0;

					case 22:
						if (!this.isClosed()) {
							context$2$0.next = 24;
							break;
						}

						return context$2$0.abrupt("return");

					case 24:
						if (this._dest) {
							if (isError) this._dest.throw(ret);else this._dest.assign(ret);
						} else {
							if (isError) rethrow(ret);
						}
						context$2$0.t1 = this._end();
						context$2$0.next = context$2$0.t1 === false ? 28 : context$2$0.t1 === true ? 30 : 32;
						break;

					case 28:
						// Current thread doesn't need any more. Let it be garbaged, but its children must be preserved.
						co.current.propogateChildrenToOwner();
						return context$2$0.abrupt("return");

					case 30:
						context$2$0.next = 32;
						return next;

					case 32:
						context$2$0.next = 5;
						break;

					case 34:
					case "end":
						return context$2$0.stop();
				}
			}, _loop, this, [[10, 18]]);
		})
	}, {
		key: "isClosed",

		// case null:
		/* immediate recalculation */
		value: function isClosed() {
			return !this._cellArr;
		}
	}, {
		key: "close",
		value: function close() {
			this._thread && this._thread.kill();
		}
	}, {
		key: "_finalize",
		value: function _finalize() {
			this._unsubscribe();
			this._cellSet = null;
			this._cellArr = null;
			this._fun = null;
			this._dest = null;
			this._thread = null;
		}
	}, {
		key: "_begin",
		value: function _begin() {
			this._unsubscribe();
			// TODO: fix a bug and uncomment next line !!!
			// co.current.killChildren()
		}
	}, {
		key: "_unsubscribe",
		value: function _unsubscribe() {
			this._onchange = null;
			var a = this._cellArr;
			if (a) {
				for (var i = 0; i < a.length; ++i) {
					var c = a[i];
					c.cell = null;
					c.value = null;
					c.error = null;
					c.action = null;
					c.read = false;
					c.written = false;
					c.pushedA = false;
					// do not change c.pushedC here!!
				}
				if (this._cellSetSize > 32 && a.length < this._cellSetSize / 4) {
					this._cellSet = Object.create(null);
					this._cellSetSize = 0;
				}
				a.length = 0;
			}
		}
	}, {
		key: "_end",
		value: function _end() {
			var ret = false;
			var a = this._cellArr;
			for (var i = 0; i < a.length; ++i) {
				var c = a[i];
				if (c.written) c.action = null;else {
					if (!c.pushedC) {
						c.cell._actionsArr.push(c);
						c.pushedC = true;
					}
					if (!is(c.value, c.cell._value) || c.error != c.cell._error) return null;
					c.action = this;
					ret = true;
				}
				c.value = null;
				c.cell = null;
			}
			return ret;
		}
	}, {
		key: "_linkCell",
		value: function _linkCell(cell) {
			if (!this._cellSet) return; // TODO debugger workaround: this._cellSet must not be null
			var c = this._cellSet[cell._id];
			if (c == null) {
				c = this._cellSet[cell._id] = {
					cell: null,
					value: null,
					error: null,
					action: null,
					read: false,
					written: false,
					pushedA: false,
					pushedC: false
				};
				++this._cellSetSize;
			}
			if (!c.pushedA) {
				this._cellArr.push(c);
				c.cell = cell;
				c.pushedA = true;
			}
			return c;
		}
	}, {
		key: "onread",
		value: function onread(cell) {
			var c = this._linkCell(cell);
			if (!c) return; // TODO debugger workaround: this._linkCell must not return null
			c.read = true;
			c.value = cell._value;
			c.error = cell._error;
		}
	}, {
		key: "onwritten",
		value: function onwritten(cell) {
			this._linkCell(cell).written = true;
		}
	}, {
		key: "_fire",
		value: function _fire() {
			if (this._onchange) this._thread.nextTick(this._onchange);
			this._unsubscribe();
		}
	}]);

	return Action;
})();

var newReactive = function newReactive(getter, handlers, isValueEqual) {
	var _iteratorNormalCompletion6 = true;
	var _didIteratorError6 = false;
	var _iteratorError6 = undefined;

	try {
		for (var _iterator6 = handlers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
			var h = _step6.value;

			if (h != null && typeof h != "function") throw new Error("wrong parameters");
		}
	} catch (err) {
		_didIteratorError6 = true;
		_iteratorError6 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
				_iterator6["return"]();
			}
		} finally {
			if (_didIteratorError6) {
				throw _iteratorError6;
			}
		}
	}

	var cell = new Cell();
	if (getter !== undefined) cell._init(getter, false, true, isValueEqual);
	var _iteratorNormalCompletion7 = true;
	var _didIteratorError7 = false;
	var _iteratorError7 = undefined;

	try {
		for (var _iterator7 = handlers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
			var h = _step7.value;

			h && (h.length ? runSetter : runGetter)(cell, h);
		}
	} catch (err) {
		_didIteratorError7 = true;
		_iteratorError7 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
				_iterator7["return"]();
			}
		} finally {
			if (_didIteratorError7) {
				throw _iteratorError7;
			}
		}
	}

	return cell;
};

// let ra_prop = function ( target, name, descr ) {
// 	// body...
// }

function ra(fun) {
	if (arguments.length > 1) {
		throw new Error(arguments.length);
		// return ra_prop( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] )
	} else return newReactive(fun, []);
}

function ArrayIsEqualTo(a) {
	return this == a || Array.isArray(a) && this.length == a.length && this.every(function (e, i) {
		return is(e, a[i]);
	});
}

function JsonIsEqualTo(a) {
	return this == a || JSON.stringify(this) == JSON.stringify(a);
}

ra.ra = ra;

ra.is = is;

ra.Array = function (array) {
	array.isEqualTo = ArrayIsEqualTo;
	return array;
};

ra.JSON = function (obj) {
	obj.isEqualTo = JsonIsEqualTo;
	return obj;
};

ra.Value = function (obj) {
	if (obj && (typeof obj == "object" || typeof obj == "function")) Values.add(obj);
	return obj;
};

ra.detach = function (fun) {
	var old = undefined;
	if (old = Actions.get(co.global)) {
		Actions.delete(co.global);
		try {
			return fun();
		} finally {
			Actions.set(co.global, old);
		}
	} else return fun();
};

ra.on = function (emitter, event, getter) {
	var ret = ra();
	var handler = function handler(data) {
		return ret.assign(getter(data));
	};
	if (event == "string") emitter.on(event, handler);else {
		var _iteratorNormalCompletion8 = true;
		var _didIteratorError8 = false;
		var _iteratorError8 = undefined;

		try {
			for (var _iterator8 = event[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
				var e = _step8.value;

				emitter.on(e, handler);
			}
		} catch (err) {
			_didIteratorError8 = true;
			_iteratorError8 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion8 && _iterator8["return"]) {
					_iterator8["return"]();
				}
			} finally {
				if (_didIteratorError8) {
					throw _iteratorError8;
				}
			}
		}
	}handler();
	return ret;
};

ra.Cell = Cell;
ra.ImmutableInterface = ImmutableInterface;
ra.AbstractGuard = AbstractGuard;
ra.Getter = Getter;
ra.Type = Type;
ra.importFrom = function (observable) {
	return Type(function (name) {
		return Getter(function () {
			return observable.live[name].valueOf();
		});
	});
};

function toKey(obj) {
	if (!toKey.Keys) toKey.Keys = typeof WeakMap != "undefined" ? new WeakMap() : (function () {
		var id = "_to_key_" + (0, _uid2.default)();
		return {
			set: function set(obj, value) {
				Object.defineProperty(obj, id, {
					enumerable: false,
					configurable: true,
					writable: false,
					value: value
				});
			},
			get: function get(obj) {
				return obj[id];
			},
			has: function has(obj) {
				return Object.prototype.hasOwnProperty.call(obj, id);
			}
		};
	})();
	// delete( obj ) { delete obj[ id ] },
	if (obj && (typeof obj == "object" || typeof obj == "function")) {
		if (!toKey.Keys.has(obj)) toKey.Keys.set(obj, (0, _uid2.default)());
		return toKey.Keys.get(obj);
	}
	return typeof obj + obj;
}

ra.makeKey = function (obj, key) {
	return ra(function () {
		return obj.get(key);
	});
};

ra.map = function (array, mapper) {
	if (!(array instanceof Cell)) throw new Error("ra.map: first argument must be a cell");
	var cache = Object.create(null);
	var ret = ra();
	ra.detach(function () {
		return ra(function () {
			// TODO ,   array.close()       cache[].index  cache[].proc
			var a = array.valueOf();
			ra.detach(function () {
				var retarr = [];
				var index = 0;
				lodash.forEach(cache, function (c) {
					c.abandoned = true;
				});
				a && a.forEach(function (value) {
					var key = toKey(value);
					var c = undefined;
					if (!(c = cache[key])) c = cache[key] = {
						value: value,
						index: ra()
					};
					c.abandoned = false;
					c.index.assign(index++);
					if (!c.proc) c.proc = ra(function () {
						return mapper(value, c.index);
					});
					retarr.push(c.proc);
				});
				lodash.keys(cache).forEach(function (key) {
					var c = cache[key];
					if (c.abandoned) {
						delete cache[key];
						c.index.close();
						c.proc.close();
					}
				});
				ret.assign(ra.Array(retarr));
			});
		});
	});
	return ret;
};

ra.keymap = function (array, mapper) {
	var mapped = ra.map(array, mapper);
	return ra(function () {
		return lodash.zipObject(array.valueOf(), mapped.valueOf());
	});
};

// ra.slice = ( dest, source, keysVar ) => {
// 	throw new Error( "message" )
// 	// TODO: optimization
// 	if ( !( dest instanceof Cell ) )
// 		dest = ra( dest )
// 	let cacheHolder = ra()
// 	ra( () => {
// 		let keys = getValue( keysVar )
// 		if ( keys )
// 			keys.sort()
// 		process.nextTick( () => {
// 			let c = ra()
// 			let s = c.defineProperty( `source` )
// 			let d = c.defineProperty( `dest` )
// 			keys && keys.forEach( k => {
// 				let sk = s.defineProperty( k )
// 				let dk = d.defineProperty( k )
// 				ra( () => dk.assign( sk.valueOf() ) )
// 			} )
// 			let t = cacheHolder.valueOf()
// 			cacheHolder.assign( c )
// 			t && t.close()
// 		} )
// 	} )
// 	ra( () => {
// 		let c = cacheHolder.valueOf()
// 		c && c.source && c.source.assign( source.valueOf() )
// 	} )
// 	ra( () => {
// 		let c = cacheHolder.valueOf()
// 		dest.assign( c && c.dest && c.dest.valueOf() )
// 	} )
// 	return dest
// }
module.exports = exports.default;

}).call(this,require('_process'))

},{"_process":192,"co":238,"diff":243,"lodash":232,"uid":281}],251:[function(require,module,exports){
(function (Buffer){
// https://kps.sketch.by/svn/dea/transcoder_m4/src/Debug/Exe/

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x5, _x6, _x7) { var _again = true; _function: while (_again) { var object = _x5, property = _x6, receiver = _x7; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x5 = parent; _x6 = property; _x7 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _stream = require("stream");

var stream = _interopRequireWildcard(_stream);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var _netroModemcrc = require("netro/modemcrc");

var CRC = _interopRequireWildcard(_netroModemcrc);

var _co = require("co");

var co = _interopRequireWildcard(_co);

var _util = require("util");

var util = _interopRequireWildcard(_util);

var _localUtils = require("localUtils");

var lu = _interopRequireWildcard(_localUtils);

var _sf = require("sf");

var sf = _interopRequireWildcard(_sf);

var _log = require("log");

var Log = _interopRequireWildcard(_log);

var modem_log = Log.open("modem");

var USB_bFLAG_DATA = 0x7e;
var USB_bSTAF_DATA = 0x7d;
var PROTOCOL_NUMBER = 1;

var MODEM_TIMEOUT = 9000;

var ModemError = (function (_Error) {
	_inherits(ModemError, _Error);

	function ModemError() {
		_classCallCheck(this, ModemError);

		_get(Object.getPrototypeOf(ModemError.prototype), "constructor", this).apply(this, arguments);
	}

	return ModemError;
})(Error);

var ModemTimeout = (function (_ModemError) {
	_inherits(ModemTimeout, _ModemError);

	function ModemTimeout() {
		_classCallCheck(this, ModemTimeout);

		_get(Object.getPrototypeOf(ModemTimeout.prototype), "constructor", this).apply(this, arguments);
	}

	return ModemTimeout;
})(ModemError);

var throwModemTimeout = function throwModemTimeout() {
	throw new ModemTimeout();
};

var Modem = (function () {
	function Modem(duplex) {
		var log = arguments.length <= 1 || arguments[1] === undefined ? modem_log : arguments[1];

		_classCallCheck(this, Modem);

		var modem = sf.Func(sf.connect.call(duplex, Modem.BinaryStream(log)), { timeout: MODEM_TIMEOUT, throwTimeout: throwModemTimeout });
		this.lock = co.synchronized(function (callback) {
			return callback(function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				return modem(args);
			});
		});
	}

	// function LOG( msg, arg ) {
	// 	process.stderr.write( msg + ` ` + ( arg && arg.inspect ? arg.inspect() : JSON.stringify( arg ) ) + `\n` )
	// 	return arg
	// }

	// constructor( min, mout = min ) {
	// 	let modem = co.Pipe.makeFunc(
	// 		co.Pipe.map( Modem.mapToBinary ).toStream( mout ),
	// 		min::co.Pipe.create().transform( Modem.transformFromBinary ),
	// 		MODEM_TIMEOUT,
	// 		throwModemTimeout,
	// 	)
	// 	this.lock = co.synchronized( callback => callback( ( ...args ) => modem( args ) ) )
	// }

	_createClass(Modem, null, [{
		key: "encode",
		value: function encode(command, info) {
			if (typeof command != "string") {
				info = command;
				command = info.id;
			}
			var array = Modem._commands[command](info);
			if (array.length > 0xff) throw new ModemError("too long message");
			array.unshift(0xff, 0x03, PROTOCOL_NUMBER, array.length);
			array.push.apply(array, _toConsumableArray(lu.word(CRC.calc_crc(array))));
			var buffer = [USB_bFLAG_DATA];
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var d = _step.value;

					if (d == USB_bFLAG_DATA || d == USB_bSTAF_DATA) buffer.push(USB_bSTAF_DATA);
					buffer.push(d);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator["return"]) {
						_iterator["return"]();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return lu.buffer(buffer);
		}
	}, {
		key: "extractMessage",
		value: function extractMessage(data) {
			if (data.length < 4) return null;
			data = lu.array(data);
			if (!(data[0] == USB_bFLAG_DATA && data[1] == 0xff && data[2] == 0x03 && data[3] == PROTOCOL_NUMBER)) return false;
			return checkCRC(data, ApplyP1Readers);
		}
	}, {
		key: "BinaryStream",
		value: function BinaryStream(log) {
			return sf.duplexer(Modem.FromBinary(log), Modem.ToBinary(log));
		}
	}, {
		key: "CommandStream",
		value: function CommandStream(log) {
			return BinaryStream(log).other;
		}
	}, {
		key: "ToBinary",
		value: function ToBinary(log) {
			return new stream.Transform({ writableObjectMode: true, transform: function transform(command, encoding, callback) {
					this.push(Modem.encode.apply(Modem, _toConsumableArray(command)));
					callback();
				} });
		}
	}, {
		key: "FromBinary",
		value: function FromBinary(log) {

			var buffer = [];
			var staf = false;

			return new stream.Transform({ readableObjectMode: true, transform: function transform(chunk, encoding, callback) {
					log && log.log("transform", "received", util.inspect(chunk));
					if (!(chunk instanceof Buffer)) throw new Error("chunk must be an instance of Buffer");
					for (var i = 0; i < chunk.length; ++i) {
						var d = chunk[i];
						if (buffer.length == 0 && d != USB_bFLAG_DATA) continue;
						if (staf) {
							staf = false;
							buffer.push(d);
						} else if (d == USB_bSTAF_DATA) {
							staf = true;
							continue;
						} else buffer.push(d);
						var skipped = undefined;
						var msg = undefined;
						while ((msg = Modem.extractMessage(buffer)) === false) {
							if (!skipped) skipped = [];
							skipped.push(buffer[0]);
							buffer.shift();
						}
						if (skipped) log && log.log("transform", "skipped", util.inspect(skipped));
						if (msg != null) {
							log && log.log("transform", "parsed", util.inspect(msg));
							this.push(msg);
						}
					}
					callback();
				} });
		}
	}]);

	return Modem;
})();

exports.default = Modem;
Modem.Error = ModemError;
Modem.ETimeout = ModemTimeout;

Modem._commands = {};

var dataSize = byte(4);
var dataCRC = {
	read: function read(data) {
		var size = dataSize.read(data);
		return size == null ? null : readWord(size + 5, data);
	},
	write: function write(data) {
		return writeWord(dataSize.read(data), data);
	}
};

var cmd1 = record({ lo: byte(7 - 5), hi: byte(8 - 5) });

function checkCRC(data, cb) {
	var crc = dataCRC.read(data);
	if (crc == null) return null;
	var size = dataSize.read(data);
	if (crc != CRC.calc_crc(data.slice(1, 5 + size))) return false;
	var ret = cb(data.slice(5, 5 + size));
	if (ret) data.splice(0, 5 + size + 2);else ret = false;
	return ret;
}

var P1Readers = [];

function ApplyP1Readers(data) {
	if (data.length != 8) return false;
	var cmd = cmd1.read(data);
	var c = P1Readers[cmd.lo];
	var f = c && (c[cmd.hi] ? c[cmd.hi] : c.any);
	if (!f) return false;
	var ret = f(data);
	return ret;
}

Modem.Work_Mode = 1;
Modem.Init_Device_Mode = 2;
Modem.Extended_Work_Mode = 3;

function bit(pos, shift) {
	var mask = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

	return {
		write: function write(data, value) {
			data[pos] = (data[pos] & ~(mask << shift)) + ((value & mask) << shift);
			return data;
		},
		read: function read(data) {
			return data[pos] == null ? null : data[pos] >> shift & mask;
		}
	};
}

function byte(pos) {
	return {
		write: function write(data, value) {
			data[pos] = value;
			return data;
		},
		read: function read(data) {
			return data[pos];
		}
	};
}

function writeWord(pos, data, value) {
	data[pos] = value & 0xff;
	data[pos + 1] = value >> 8 & 0xff;
	return data;
}

function readWord(pos, data) {
	return data[pos] == null || data[pos + 1] == null ? null : data[pos] + (data[pos + 1] << 8);
}

function word(pos) {
	return {
		write: writeWord.bind(null, pos),
		read: readWord.bind(null, pos)
	};
}

function dword(pos) {
	return {
		write: function write(data, value) {
			data[pos] = value & 0xff;
			data[pos + 1] = value >> 8 & 0xff;
			data[pos + 2] = value >> 16 & 0xff;
			data[pos + 3] = value >> 24 & 0xff;
			return data;
		},
		read: function read(data) {
			return data[pos] == null || data[pos + 1] == null || data[pos + 2] == null || data[pos + 3] == null ? null : data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
		}
	};
}

function record(type) {
	return {
		read: function read(data) {
			var ret = {};
			for (var i in type) {
				if (Object.prototype.hasOwnProperty.call(type, i)) ret[i] = type[i].read(data);
			}return ret;
		},
		write: function write(data, value) {
			for (var i in type) {
				if (Object.prototype.hasOwnProperty.call(type, i)) type[i].write(data, value[i]);
			}return data;
		},
		rec: type
	};
}

function compose(t1, t2) {
	return {
		read: function read(data) {
			return t1.read(t2.read(data));
		},
		write: function write(data, value) {
			return t2.write(data, t1.write(value));
		}
	};
}

!(function Init1() {
	var ACK = bit(11 - 5, 7),
	    DIM = bit(11 - 5, 6),
	    ROL = bit(11 - 5, 5),
	   
	// = bit( 11 - 5, 4 ),
	WCK = bit(11 - 5, 3),
	    RPM = bit(11 - 5, 2),
	    DEL = bit(11 - 5, 1),
	    SGRP = bit(11 - 5, 0),
	    DN = bit(12 - 5, 7),
	    UP = bit(12 - 5, 6),
	   
	// = bit( 12 - 5, 5 ),
	// = bit( 12 - 5, 4 ),
	// = bit( 12 - 5, 3 ),
	PRIORITY = bit(12 - 5, 0, 7),
	    _8 = byte(8 - 5),
	    _9 = byte(9 - 5),
	    _10 = byte(10 - 5),
	    _11 = byte(11 - 5),
	    _12 = byte(12 - 5),
	    _9_10 = word(9 - 5),
	    _9_10_11_12 = dword(9 - 5),
	    group = word(5 - 5),
	    cmdLo = cmd1.rec.lo,
	    cmdHi = cmd1.rec.hi,
	    constants = { cmdLo: cmdLo, cmdHi: cmdHi };

	function enumeration(enumeration) {
		var r = {};
		if (enumeration[Symbol.iterator]) {
			var i = 0;
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = enumeration[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var _name = _step2.value;

					if (_name != null) r[_name] = i;
					++i;
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
						_iterator2["return"]();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		} else {
			for (var i in enumeration) {
				if (Object.prototype.hasOwnProperty.call(enumeration, i)) r[enumeration[i]] = i;
			}
		}
		function getValue(value) {
			if (typeof value == "number") return value;
			if (String(Number(value)) == value) return Number(value);
			var ret = enumeration[value];
			if (ret == null) throw new Error("wrong constant " + value);
			return ret;
		}
		return {
			read: function read(value) {
				if (value == null) return null;
				var ret = r[value];
				if (ret == null) ret = value;
				return ret;
			},
			write: function write(value) {
				if (value == null) return null;
				var ret = value;
				if (Array.isArray(value)) ret = value.map(getValue).reduce(function (a, b) {
					return a | b;
				});else if (typeof value == "string") ret = getValue(value);
				return ret;
			}
		};
	}

	function prec(precision) {
		return {
			read: function read(c) {
				return c == null ? null : c * precision;
			},
			write: function write(c) {
				return c == null ? null : Math.round(c / precision);
			}
		};
	}

	function leftpad(str, len) {
		var pad = arguments.length <= 2 || arguments[2] === undefined ? " " : arguments[2];

		var p = "";
		var l = len - str.length;
		if (!pad) return str;
		while (l && l > 0) {
			p += pad;
			--l;
		}
		return p + str;
	}

	function hex() {
		var len = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

		return {
			read: function read(c) {
				return c == null ? null : leftpad(c.toString(16), len, "0");
			},
			write: function write(c) {
				return c == null ? null : parseInt(c, 16);
			}
		};
	}

	function set(set) {
		function check() {
			if (typeof set == "string") set = types[set];else if (typeof set.read != "function") set = enumeration(set);
			check = function () {};
		}
		return {
			read: function read(x) {
				check();
				if (x == null) return null;
				var i = 0;
				var ret = {};
				while (x) {
					if (x & 1) ret[set.read(i)] = true;
					++i;
					x >>= 1;
				}
				return ret;
			},
			write: function write(x) {
				check();
				if (x == null || typeof x != "object") return x;
				var ret = 0;
				if (!x[Symbol.iterator]) x = Object.keys(x).filter(function (i) {
					return x[i];
				});
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = x[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var i = _step3.value;

						ret |= 1 << set.write(i);
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
							_iterator3["return"]();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				return ret;
			}
		};
	}

	var types = {
		GROUP: enumeration({
			Any_Group: 0
		}),
		CMD: enumeration({
			None: 0,
			Stop: 1,
			Up: 2,
			Down: 3,
			Comfort_1: 4,
			Comfort_2: 5,
			Script: 6,
			Loop: 7,
			Set_To_Comfort: 8
		}),
		TIME: enumeration({
			Pressed_0_sec: 1,
			Pressed_0_5_sec: 2,
			Pressed_1_sec: 3,
			Pressed_4: 4,
			Released_0_sec: 9,
			Released_0_5_sec: 10,
			Released_1_sec: 11,
			Released_4_sec: 12
		}),
		// ATTRIBUTE: ...,
		COMFORT: prec(0.0001), // 0..1
		MOVE_TIME: prec(0.01), // seconds
		MODE: enumeration(["Ignore_For_Out", "Idle", "Setting", "Comfort_1", "Comfort_2", "Self_Group", "Remote", "Program", "Script", "Comfort_For_Script", "Update"]),
		// MASK: ...,
		// MODE_SETTING: ...,
		// SYSTEM_SETTING: ...,
		// CMD_SETTING: ...,
		GROUP_SETTING: enumeration(["Received_Cmd_Is_Executed_Only_Locally", "Received_Cmd_Is_Executed_Locally_And_For_Self_Group"]),
		// DEFAUL_SETTING: ...,
		KEYPAD_STATUS: set(["Key_Up_Pressed", "Key_Stop_Pressed", "Key_Down_Pressed", "Key_Comfort_Pressed", "Key_Group_Pressed", "Key_Program_Pressed", "Key_External_1_Pressed", "Key_External_2_Pressed"]),
		RESULT: enumeration({
			OK: 1,
			Packet_Error: 2,
			Memory_Overflow: 3,
			Packet_Missed: 4,
			Packet_Not_Allowed: 5,
			Packed_appled_at_modem: 6,
			Connection_error: 7,
			Command_in_progress: 8,
			Command_auth_req: 9,
			Device_Error: 10
		}),
		LEVEL: prec(0.001), // 0..1
		MODEM_MODE: enumeration({
			Work_Mode: 1,
			Init_Device_Mode: 2,
			Extended_Work_Mode: 3,
			Extended_Init_Mode: 4,
			Reset_Password_Mode: 5,
			RSSI_catch_mode: 6
		}),
		// GRP_KEYS: ...,
		// SCEN_GRP_SETTING: ...,
		PROTOCOL_NUM: enumeration({
			NERO_II_SmartHome: 0,
			INTRO_II_SmartHome: 1
		}),
		PROTOCOLS: set("PROTOCOL_NUM"),
		MODEM_FUNCTIONS: set({}),

		// !!! TODO: ,     CUR_CONDITION / DEST_CONDITION
		CUR_CONDITION: prec(0.0001), // 0..1
		DEST_CONDITION: prec(0.0001), // 0..1
		ID: hex()
	};

	function registerReader(cmdLo, cmdHi, reader) {
		if (typeof cmdLo != "number") throw new ModemError("wrong cmdLo");
		P1Readers[cmdLo] = P1Readers[cmdLo] || [];
		if (typeof cmdHi != "number") cmdHi = "any";
		P1Readers[cmdLo][cmdHi] = reader;
	}

	function registerWriter(id, writer, type) {
		if (Modem._commands[id]) {
			var msg = "duplicate command identifier " + id;
			console.error("registerWriter " + util.inspect(msg));
			throw new Error(msg);
		}
		Modem._commands[id] = Object.assign(function (info) {
			var data = [];
			data.length = 8;
			writer(data, info);
			return data;
		}, { type: type });
	}

	function command(id, type) {
		var t = {};
		for (var i in type) {
			if (Object.prototype.hasOwnProperty.call(type, i)) {
				var f = type[i];
				if (typeof f == "number") {
					(function () {
						var x = f;
						var c = constants[i];
						if (!c) throw new ModemError("wrong constant in command definition");
						f = {
							read: function read() {
								return x;
							},
							write: function write(data) {
								return c.write(data, x);
							}
						};
					})();
				}
				if (types[i]) f = compose(types[i], f);
				t[i] = f;
			}
		}var read = function read(data) {
			var ret = { id: id };
			for (var i in t) {
				if (Object.prototype.hasOwnProperty.call(t, i)) ret[i] = t[i].read(data);
			}return ret;
		};
		registerReader(type.cmdLo, type.cmdHi, read);
		var write = function write(data, info) {
			for (var i in t) {
				if (Object.prototype.hasOwnProperty.call(t, i)) t[i].write(data, info && info[i]);
			}return data;
		};
		registerWriter(id, write, type);
	}

	// Initial Device
	command("Write_Group", { group: group, cmdLo: 1, TIME: _9, WCK: WCK, RPM: RPM, DEL: DEL });
	command("Write_Script", { group: group, cmdLo: 2, cmdHi: 0, TIME: _9, WCK: WCK, RPM: RPM, DEL: DEL });
	command("Write_Script_With_Cmd", { group: group, cmdLo: 2, CMD: _8, TIME: _9, WCK: WCK, RPM: RPM, DEL: DEL });
	command("Write_By_Allowance", { group: group, cmdLo: 3, TIME: _9 });
	command("Stop_Write_With_Ack", { group: group, cmdLo: 4 });

	//Programming Cmd
	command("Write_Group_In_Idle", { group: group, cmdLo: 5, GROUP: _9_10, ACK: ACK });
	command("Allow_Group_Writing", { group: group, cmdLo: 6, cmdHi: 0, ACK: ACK });
	command("Allow_Script_Writing", { group: group, cmdLo: 6, CMD: _8, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL });
	command("Allow_Script_With_Comfort_Writing", { group: group, cmdLo: 6, cmdHi: 32, COMFORT: _9_10, ACK: ACK, DN: DN, UP: UP });
	command("Change_Script_Into_Cmd", { group: group, cmdLo: 7, CMD: _8, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL });
	command("Change_Script_Into_Comfort", { group: group, cmdLo: 7, cmdHi: 32, COMFORT: _9_10, ACK: ACK, DN: DN, UP: UP });
	command("Delete_Group_In_Programming_Mode", { group: group, cmdLo: 8, cmdHi: 1, GROUP: _9_10, ACK: ACK });
	command("Delete_Group_In_Idle_Mode", { group: group, cmdLo: 8, cmdHi: 2, GROUP: _9_10, ACK: ACK });
	command("Clear_Device_Memory_In_Idle_Mode", { group: group, cmdLo: 8, cmdHi: 3, ACK: ACK });

	// Action Cmd
	command("Stop", { group: group, cmdLo: 16, cmdHi: 1, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL, SGRP: SGRP, PRIORITY: PRIORITY });
	command("Up", { group: group, cmdLo: 16, cmdHi: 2, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL, SGRP: SGRP, PRIORITY: PRIORITY });
	command("Down", { group: group, cmdLo: 16, cmdHi: 3, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL, SGRP: SGRP, PRIORITY: PRIORITY });
	command("Set_To_Comfort_1", { group: group, cmdLo: 16, cmdHi: 4, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL, SGRP: SGRP, PRIORITY: PRIORITY });
	command("Set_To_Comfort_2", { group: group, cmdLo: 16, cmdHi: 5, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL, SGRP: SGRP, PRIORITY: PRIORITY });
	command("Script", { group: group, cmdLo: 16, cmdHi: 6, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL, SGRP: SGRP, PRIORITY: PRIORITY });
	command("Loop", { group: group, cmdLo: 16, cmdHi: 7, TIME: _9, ACK: ACK, DIM: DIM, ROL: ROL, SGRP: SGRP, PRIORITY: PRIORITY });
	command("Set_To_Comfort", { group: group, cmdLo: 16, cmdHi: 32, COMFORT: _9_10, ACK: ACK, SGRP: SGRP, DN: DN, UP: UP, PRIORITY: PRIORITY });
	command("ScanCod_For_Modes", { group: group, cmdLo: 17, CMD: _8, TIME: _9, MODE: _10, ACK: ACK, DIM: DIM, ROL: ROL });

	// Control Cmd
	command("GoTo_Mode", { group: group, cmdLo: 24, cmdHi: 1, To_MODE: _9, From_MODE: _10, ACK: ACK });
	command("Change_Mode_Setting", { group: group, cmdLo: 24, cmdHi: 2, MODE_SETTING: _9, MASK: _10, ACK: ACK });
	command("Change_System_Setting", { group: group, cmdLo: 24, cmdHi: 3, SYSTEM_SETTING: _9, MASK: _10, ACK: ACK });
	command("Change_Cmd_Setting", { group: group, cmdLo: 24, cmdHi: 4, CMD_SETTING: _9, MASK: _10, ACK: ACK });
	command("Change_Group_Setting", { group: group, cmdLo: 24, cmdHi: 5, GROUP_SETTING: _9, MASK: _10, ACK: ACK });
	command("Change_Move_Time", { group: group, cmdLo: 24, cmdHi: 6, MOVE_TIME: _9_10, ACK: ACK });
	command("Change_Comfort_1", { group: group, cmdLo: 24, cmdHi: 7, COMFORT: _9_10, ACK: ACK, DN: DN, UP: UP });
	command("Change_Comfort_2", { group: group, cmdLo: 24, cmdHi: 8, COMFORT: _9_10, ACK: ACK, DN: DN, UP: UP });
	command("Change_Script_Comfort", { group: group, cmdLo: 24, cmdHi: 9, COMFORT: _9_10, ACK: ACK, DN: DN, UP: UP });
	command("Reset_To_Factory_Setting", { group: group, cmdLo: 24, cmdHi: 10, DEFAUL_SETTING: _9_10, ACK: ACK });
	command("Change_Group_Settings_For_Scenario_Control", { group: group, cmdLo: 24, cmdHi: 11, GRP_KEYS: _9, SCEN_GRP_SETTING: _10, ACK: ACK });

	// Request	
	function request(id, fun, tToModem, tFromModem) {
		tToModem.cmdLo = 32;
		tToModem.cmdHi = fun;
		tFromModem.cmdLo = 33;
		tFromModem.cmdHi = fun;
		command(id, tToModem);
		command("answer_" + id, tFromModem);
	}

	request("Mode", 1, { group: group }, { group: group, MODE: _9 });
	request("Mode_Setting", 2, { group: group }, { group: group, MODE_SETTING: _9 });
	request("System_Setting", 3, { group: group }, { group: group, SYSTEM_SETTING: _9 });
	request("Cmd_Setting", 4, { group: group }, { group: group, CMD_SETTING: _9 });
	request("Group_Setting", 5, { group: group }, { group: group, GROUP_SETTING: _9 });
	request("Move_Time", 6, { group: group }, { group: group, MOVE_TIME: _9_10 });
	request("Comfort_1", 7, { group: group }, { group: group, COMFORT: _9_10, DN: DN, UP: UP });
	request("Comfort_2", 8, { group: group }, { group: group, COMFORT: _9_10, DN: DN, UP: UP });
	request("Script_Comfort", 9, { group: group }, { group: group, COMFORT: _9_10, DN: DN, UP: UP });
	request("Keypad_Status", 10, { group: group }, { group: group, KEYPAD_STATUS: _9 });
	request("Cur_Condition", 11, { group: group }, { group: group, CUR_CONDITION: _9_10, DN: DN, UP: UP });
	request("Dest_Condition", 12, { group: group }, { group: group, DEST_CONDITION: _9_10, DN: DN, UP: UP });
	request("Version_High", 13, { group: group }, { group: group, PRODUCT_HARD: _9, PRODUCT_VARIANT: _10 });
	request("Version_Low", 14, { group: group }, { group: group, PRODUCT_VERSION: _9, PRODUCT_ID: _10 });
	request("Result", 15, { group: group }, { group: group, RESULT: _9 });
	request("Signal_Level", 16, { group: group }, { group: group, LEVEL: _9_10 });
	request("Free_Cell_Count", 17, {}, { COUNT: _9_10 });
	request("Version", 18, {}, { PRODUCT_VERSION: _9, PRODUCT_ID: _10, PRODUCT_HARD: _11, PRODUCT_VARIANT: _12 });
	request("Id_Cell_Number", 19, {}, { DEV_NUM: _9 });
	request("Scenario_Control_Group_Setting", 20, { group: group, key1: _9 }, { group: group, GRP_KEYS: _9, SCEN_GRP_SETTING: _10 });
	request("Functions", 21, {}, { PROTOCOLS: _9, MODEM_FUNCTIONS: _10 });
	request("Identifier", 22, {}, { ID: _9_10_11_12 });

	//  
	command("Change_modem_work_mode", { cmdLo: 25, cmdHi: 1, MODEM_MODE: _9 });
	command("Do_id_nx_substitution", { cmdLo: 25, cmdHi: 2, DEV_NUM: _9_10 }); // 0xffff - modem
	command("Delete_id_nx_of_device", { cmdLo: 25, cmdHi: 3, DEV_NUM: _9_10 }); // 0xffff - all
	command("Change_protocol", { cmdLo: 25, cmdHi: 4, PROTOCOLS: _9 });
})();
module.exports = exports.default;

}).call(this,require("buffer").Buffer)

},{"buffer":215,"co":238,"localUtils":249,"lodash":232,"log":250,"netro/modemcrc":252,"sf":256,"stream":210,"util":214}],256:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var _bind = Function.prototype.bind;

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

exports.pipe = pipe;
exports.from = from;
exports.connect = connect;
exports.throwTimeout = throwTimeout;
exports.Map = Map;
exports.duplexer = duplexer;
exports.std = std;
exports.filter = filter;
exports.Func = Func;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _stream4 = require("stream");

var stream = _interopRequireWildcard(_stream4);

var Pipe = (function () {
	function Pipe(_stream) {
		_classCallCheck(this, Pipe);

		this._stream = _stream;
	}

	_createClass(Pipe, [{
		key: "pipe",
		value: function pipe() {
			var _stream2;

			return new Pipe((_stream2 = this._stream).pipe.apply(_stream2, arguments));
		}
	}, {
		key: "input",
		value: function input() {
			return this._stream;
		}
	}]);

	return Pipe;
})();

function pipe(dest) {
	return new Pipe(new stream.PassThrough()).pipe(dest);
}

function from(stream) {
	stream.pipe(this);
	return stream;
}

function connect(duplex) {
	this.pipe(duplex);
	duplex.pipe(this);
	return duplex.other;
}

function throwTimeout() {
	throw new Error("timeout");
}

function Map(map) {
	return new stream.Transform({ objectMode: true, transform: function transform(data, _, callback) {
			try {
				this.push(map(data));
			} catch (error) {
				this.emit("error", error);
			} finally {
				callback();
			}
		} });
}

var through = function through() {
	return new stream.PassThrough({ objectMode: true });
};

exports.through = through;
function not(flag) {
	if (flag === true) return false;
	if (flag === false) return true;
	return flag;
}

var Duplexer = (function (_stream$Duplex) {
	_inherits(Duplexer, _stream$Duplex);

	function Duplexer() /* options = null, writer, reader */{
		var _this = this;

		_classCallCheck(this, Duplexer);

		var options = undefined,
		    writer = undefined,
		    reader = undefined;

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		if (!args[0] || !args[0]._readableState && !args[0]._writableState) options = args.shift();
		writer = args.shift();
		reader = args.shift();
		options = Object.assign({}, options);
		var otherOptions = {
			objectMode: options.objectMode,
			readableObjectMode: options.otherWritableObjectMode != null ? options.otherWritableObjectMode : options.writableObjectMode,
			writableObjectMode: options.otherReadableObjectMode != null ? options.otherReadableObjectMode : options.readableObjectMode
		};
		if (reader && options.readableObjectMode == null) options.readableObjectMode = reader._readableState.objectMode;
		if (writer && options.writableObjectMode == null) options.writableObjectMode = writer._writableState.objectMode;
		_get(Object.getPrototypeOf(Duplexer.prototype), "constructor", this).call(this, options);
		this._ondata = function (data) {
			if (!_this.push(data)) {
				if (_this._reader) _this._reader.pause();
			}
		};
		this._onend = function () {
			return _this.push(null);
		};
		this._onerror = function (error) {
			return _this.emit("error", error);
		};
		this._write_callback = null;
		this._ondrain = function () {
			var callback = _this._write_callback;
			_this._write_callback = null;
			callback && callback();
		};
		this._otherOptions = otherOptions;
		this.on("finish", function () {
			return _this._writer.end();
		});
		this._that = null;
		this._other = null;
		this.setStreams(writer, reader);
	}

	_createClass(Duplexer, [{
		key: "setOther",
		value: function setOther(other) {
			var _context;

			this._other = (_context = this.other, connect).call(_context, other);
			return this;
		}
	}, {
		key: "_read",
		value: function _read() {
			if (this._reader) this._reader.resume();
		}
	}, {
		key: "_do_write",
		value: function _do_write(data, encoding, callback) {
			if (this._writer.write(data, encoding)) callback();else {
				this._write_callback = callback;
				this._writer.once("drain", this._ondrain);
			}
		}
	}, {
		key: "_write",
		value: function _write(data, encoding, callback) {
			var _this2 = this;

			if (this._writer) this._do_write(data, encoding, callback);else this.once("writer", function () {
				return _this2._do_write(data, encoding, callback);
			});
		}
	}, {
		key: "setReadable",
		value: function setReadable(reader) {
			if (this._reader == reader) return;
			if (this._reader) {
				this._reader.removeListener("data", this._ondata);
				this._reader.removeListener("end", this._onend);
				this._reader.removeListener("error", this._onerror);
				this._reader = null;
			}
			if (reader) {
				this._reader = reader;
				this._reader.addListener("data", this._ondata);
				this._reader.addListener("end", this._onend);
				this._reader.addListener("error", this._onerror);
			}
			if (this._that) this._that.setWritable(reader);
			return this;
		}
	}, {
		key: "setWritable",
		value: function setWritable(writer) {
			if (this._writer == writer) return;
			if (this._writer) {
				this._writer.removeListener("error", this._onerror);
				this._writer.removeListener("drain", this._ondrain);
				this._writer = null;
				this._ondrain();
			}
			if (writer) {
				this._writer = writer;
				this._writer.addListener("error", this._onerror);
				this.emit("writer");
			}
			if (this._that) this._that.setReadable(writer);
			return this;
		}
	}, {
		key: "setStreams",
		value: function setStreams(writer, reader) {
			this.setWritable(writer);
			this.setReadable(reader);
			return this;
		}
	}, {
		key: "other",
		get: function get() {
			if (!this._that) {
				var other = new Duplexer(this._otherOptions, this._reader, this._writer);
				this._that = other;
				this._other = other;
				other._that = this;
				other._other = this;
			}
			return this._other;
		}
	}]);

	return Duplexer;
})(stream.Duplex);

exports.Duplexer = Duplexer;

function duplexer() {
	for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		args[_key2] = arguments[_key2];
	}

	return new (_bind.apply(Duplexer, [null].concat(args)))();
}

function std(proc) {
	if (!proc) return duplexer(process.stdout, process.stdin);else return duplexer(proc.stdin, proc.stdout);
}

var DEST_READY = 0;
var DEST_PAUSED = 1;
var SRC_PAUSED = 2;

function filter(filters) {
	// let streams = Array.isArray( filters ) ? [] : {}
	var f = [];
	var sum = through();
	var split = through();
	var count = 1;
	var onend = function onend() {
		if (0 == --count) sum.end();
	};
	var paused = 0;
	var ondrain = function ondrain() {
		if (0 == --count) sum.end();
	};
	process.nextTick(onend);
	function clearPaused(filter) {
		if (filter.paused == SRC_PAUSED) {
			filter.paused = DEST_READY;
			if (0 == --paused) split.resume();
		}
	}
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		var _loop = function () {
			var name = _step.value;

			var filter = filters[name];
			// if ( typeof filter == `function` )
			// 	filter = { filter: filter, stream: through() }
			// streams[ name ] = filter.stream
			filter = { filter: filter.filter, stream: filter.stream, paused: DEST_READY };
			f.push(filter);
			filter.stream.on("drain", function () {
				return clearPaused(filter);
			});
			if (typeof filter.stream.pipe == "function") {
				filter.stream.pipe(sum, { end: false });
				++count;
				filter.stream.on("end", onend);
			}
		};

		for (var _iterator = Object.keys(filters)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			_loop();
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator["return"]) {
				_iterator["return"]();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	split.on("data", function (data) {
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = f[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var _filter = _step2.value;

				if (_filter.filter(data)) {
					if (_filter.stream.write(data)) clearPaused(_filter);else if (_filter.paused == DEST_READY) _filter.paused = DEST_PAUSED;else if (_filter.paused == DEST_PAUSED) {
						_filter.paused = SRC_PAUSED;
						if (1 == ++paused) split.pause();
					}
				}
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
					_iterator2["return"]();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	});
	split.on("end", function () {
		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = f[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _stream3 = _step3.value.stream;

				_stream3.end();
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
					_iterator3["return"]();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}
	});
	var ret = new Duplexer(split, sum);
	// ret.streams = streams
	return ret;
}

function Func(duplex) {
	var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	var _ref$timeout = _ref.timeout;
	var timeout = _ref$timeout === undefined ? null : _ref$timeout;
	var _ref$timeoutProc = _ref.timeoutProc;
	var timeoutProc = _ref$timeoutProc === undefined ? throwTimeout : _ref$timeoutProc;

	var promises = [];
	var shift = function shift() {
		var ret = promises.shift();
		clearTimeout(ret.timer);
		return ret;
	};
	duplex.on("data", function (result) {
		return shift().resolve(result);
	});
	duplex.on("error", function (error) {
		while (promises.length) shift().reject(error);
	});
	duplex.on("end", function (error) {
		while (promises.length) timer(shift());
	});
	var timer = function timer(promise) {
		try {
			promise.resolve(throwTimeout());
		} catch (error) {
			promise.resolve(error);
		}
	};
	var ontimeout = function ontimeout() {
		return timer(shift());
	};
	return function (value) {
		duplex.write(value);
		return new Promise(function (resolve, reject) {
			return promises.push({
				resolve: resolve,
				reject: reject,
				timer: timeout && setTimeout(ontimeout, timeout)
			});
		});
	};
}

}).call(this,require('_process'))

},{"_process":192,"stream":210}],258:[function(require,module,exports){
module.exports={
	"Green": {
		"caption": {
			"en": "Green",
			"ru": "",
			"by": ""
		},
		"background": "img/theme1.jpg",
		"fill": "#42A001",
		"off": "#455903"
	},
	"Blue": {
		"caption": {
			"en": "Blue",
			"ru": "",
			"by": ""
		},
		"background": "img/theme2.jpg",
		"fill": "#EBF5F7",
		"off": "#4C778F"
	},
	"Dark": {
		"caption": {
			"en": "Dark",
			"ru": "",
			"by": ""
		},
		"background": "img/theme3.jpg",
		"fill": "#425951",
		"off": "#3A5052"
	}
}

},{}],259:[function(require,module,exports){
/*
by design:
      ( touchmove  mousemove) -      ,         ,     .
*/

"use strict";

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _sparsequeue = require("sparsequeue");

var _sparsequeue2 = _interopRequireDefault(_sparsequeue);

var tracks = Object.create(null);

setInterval(function () {
	for (var identifier in tracks) {
		var track = tracks[identifier];
		if (track.abandoned) {
			// if ( track.handler.return )
			// 	track.handler.return()
			// delete tracks[ identifier ]
		} else track.abandoned = true;
	}
}, 7000);

function pushEvent(track, event) {
	track.points.push(event);
	if (track.preventDefault && event.preventDefault) event.preventDefault();
}

function stopEvents(track) {
	track.points.close();
}

function startTrack(identifier, event) {
	var points = new _sparsequeue2.default();
	var detail = {
		cancelEvent: null,
		next: points
	};
	var track = {
		abandoned: false,
		closed: false,
		detail: detail,
		points: points,
		preventDefault: false
	};
	tracks[identifier] = track;
	var ret = new CustomEvent("touch", { detail: detail, bubbles: true, cancelable: true });
	ret.pageX = event.pageX;
	ret.pageY = event.pageY;
	ret.clientX = event.clientX;
	ret.clientY = event.clientY;
	ret.screenX = event.screenX;
	ret.screenY = event.screenY;
	ret.preventDefault = function () {
		event.preventDefault();
		track.preventDefault = true;
	};
	event.target.dispatchEvent(ret);
	pushEvent(track, event);
}

function onExistingTrack(fun) {
	return function (identifier, arg) {
		var track = tracks[identifier];
		if (!track) return;
		track.abandoned = false;
		fun(track, arg);
	};
}

var continueTrack = onExistingTrack(pushEvent);

var stopTrack = onExistingTrack(function (track, event) {
	pushEvent(track, event);
	stopEvents(track);
});

var removeTrack = onExistingTrack(stopEvents);

var cancelTrack = onExistingTrack(function (track, event) {
	track.detail.cancelEvent = event;
	stopEvents(track);
});

function forTouches(event, cb) {
	for (var i = 0; i < event.changedTouches.length; ++i) {
		var touch = event.changedTouches.item(i);
		cb(touch.identifier, {
			type: "touchmove",
			identifier: touch.identifier,
			target: touch.target,
			screenX: touch.screenX,
			screenY: touch.screenY,
			clientX: touch.clientX,
			clientY: touch.clientY,
			pageX: touch.pageX,
			pageY: touch.pageY,
			radiusX: touch.radiusX,
			radiusY: touch.radiusY,
			rotationAngle: touch.rotationAngle,
			force: touch.force,
			timeStamp: event.timeStamp,
			preventDefault: event.preventDefault.bind(event)
		});
	}
	var current = Object.create(null);
	for (var i = 0; i < event.touches.length; ++i) {
		current[event.touches.item(i).identifier] = true;
	}for (var identifier in tracks) {
		if (!(identifier in current)) removeTrack(identifier);else tracks[identifier].abandoned = false;
	}
}

var container = document;

// function onevent( event ) {
// 	console.log( event.type, event.target )
// }

container.addEventListener("mousedown", function (event) {
	// onevent( event )
	if (event.button == 0) startTrack("mouse", event);else if (!(event.buttons & 1)) removeTrack("mouse");
});

container.addEventListener("mousemove", function (event) {
	// onevent( event )
	if (event.buttons & 1) continueTrack("mouse", event);else removeTrack("mouse");
});

container.addEventListener("mouseup", function (event) {
	// onevent( event )
	if (event.button == 0) stopTrack("mouse", event);else if (!(event.buttons & 1)) removeTrack("mouse");
});

container.addEventListener("touchstart", function (event) {
	// onevent( event )
	forTouches(event, startTrack);
});

container.addEventListener("touchmove", function (event) {
	// onevent( event )
	forTouches(event, continueTrack);
});

container.addEventListener("touchend", function (event) {
	// onevent( event )
	forTouches(event, stopTrack);
});

container.addEventListener("touchcancel", function (event) {
	// onevent( event )
	forTouches(event, cancelTrack);
});

},{"sparsequeue":257}],257:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function rethrow(error) {
	setTimeout(function () {
		throw error;
	});
}

function safeEach(array, cb) {
	for (var i = 0, l = array.length; i < l; ++i) {
		try {
			cb(array.shift());
		} catch (error) {
			rethrow(error);
		}
	}
}

var SparseQueue = (function () {
	function SparseQueue() {
		_classCallCheck(this, SparseQueue);

		this._cbs = [];
	}

	_createClass(SparseQueue, [{
		key: "then",
		value: function then(cb) {
			if (this._closed) process.nextTick(function () {
				return cb(undefined);
			});else this._cbs.push(cb);
		}
	}, {
		key: "isClosed",
		value: function isClosed() {
			return this._closed;
		}
	}, {
		key: "close",
		value: function close() {
			this._closed = true;
			safeEach(this._cbs, function (handler) {
				return handler(undefined);
			});
		}
	}, {
		key: "push",
		value: function push(data) {
			if (this._closed) throw new Error("queue is aready closed");
			safeEach(this._cbs, function (handler) {
				return handler(data);
			});
		}
	}, {
		key: "pushcb",
		value: function pushcb(data) {
			if (this._closed) throw new Error("queue is aready closed");
			safeEach(this._cbs, function (handler) {
				return handler(data());
			});
		}
	}]);

	return SparseQueue;
})();

exports.default = SparseQueue;
module.exports = exports.default;

}).call(this,require('_process'))

},{"_process":192}],261:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _uiMenu = require("ui/Menu");

var _uiMenu2 = _interopRequireDefault(_uiMenu);

var _uiCommand = require("ui/Command");

var _uiCommand2 = _interopRequireDefault(_uiCommand);

var _uiAddExistingItem = require("ui/AddExistingItem");

var _uiAddExistingItem2 = _interopRequireDefault(_uiAddExistingItem);

exports.default = function (app) {
	var Menu = app.load(_uiMenu2.default);
	var Command = app.load(_uiCommand2.default);
	var AddExistingItem = app.load(_uiAddExistingItem2.default);
	return __(
		Menu,
		null,
		__(AddExistingItem, null),
		__(Command, {
			message: "commandCreateNewGroup",
			onclick: function () {
				app.addGroup(app.activeDeviceId);
			}
		}),
		__(Command, {
			message: "commandAddNewDevice",
			onclick: function () {
				return app.addDevice(app.activeDeviceId);
			}
		}),
		__(Command, {
			message: "commandAddPlace",
			onclick: function () {
				// app.dialog = `AddPlace`
				app.addPlace(app.activeDeviceId);
			}
		})
	);
};

module.exports = exports.default;

},{"ui/AddExistingItem":260,"ui/Command":268,"ui/Menu":272}],262:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _localUtils = require("localUtils");

var lu = _interopRequireWildcard(_localUtils);

var _app = require("app");

var _app2 = _interopRequireDefault(_app);

var _uiMainScreen = require("ui/MainScreen");

var _uiMainScreen2 = _interopRequireDefault(_uiMainScreen);

var _uiStartupScreen = require("ui/StartupScreen");

var _uiStartupScreen2 = _interopRequireDefault(_uiStartupScreen);

var _uiBackground = require("ui/Background");

var _uiBackground2 = _interopRequireDefault(_uiBackground);

var _uiTop = require("ui/Top");

var _uiTop2 = _interopRequireDefault(_uiTop);

var _uiBottom = require("ui/Bottom");

var _uiBottom2 = _interopRequireDefault(_uiBottom);

var _uiButton = require("ui/Button");

var _uiButton2 = _interopRequireDefault(_uiButton);

exports.default = function (_ref) {
	var _ref$appid = _ref.appid;
	var appid = _ref$appid === undefined ? "state" : _ref$appid;
	var IconTemplates = _ref.IconTemplates;

	var _App = (0, _app2.default)(appid);

	var app = _App.app;
	var local = _App.local;

	app.pageStarting = true;

	var MainScreen = app.load(_uiMainScreen2.default);
	var StartupScreen = app.load(_uiStartupScreen2.default);
	var Background = app.load(_uiBackground2.default);
	var Top = app.load(_uiTop2.default);
	var Bottom = app.load(_uiBottom2.default);
	var Button = app.load(_uiButton2.default);

	window._app = app;
	window._local = local;

	if (navigator.standalone) {
		// cookies.setItem( `standalone`, 1, Infinity ) --           
	} else {
			(0, _ra2.default)(function () {
				if (local.activeDeviceId && local.activeDeviceId.valueOf()) {
					var title = "TITLE_" + local.activeDeviceId;
					var icon = "ICON_" + local.activeDeviceId;
					global.screenTitle.setAttribute("content", title);
					if (local.activeDeviceId && local.activeDeviceId != "main") history.replaceState(null, title, "?appicon=" + icon);else history.replaceState(null, title, "?");
					// httpClient.post( `/cookie?appicon=${ icon }`, `` )
					// cookies.setItem( `appicon`, icon, Infinity )
					// LOG( local.activeDeviceId.blue )
				}
			});
		}

	var dialogContainer = __(
		"div",
		{ class: "dialogs under_top above_bottom" },
		__(
			"div",
			{ class: "background app_content_background" },
			__(
				"div",
				{ class: "background backing_sized_background" },
				__(
					"div",
					{ class: "background under_top_background" },
					__(
						"div",
						{ class: "background above_bottom_background" },
						__(Background, null)
					)
				)
			)
		)
	);

	var application = __(
		"div",
		{ class: function () {
				return "\n\t\tapplication\n\t\t" + (app.pageStarting ? "pageStarting" : "pageRunning") + "\n\t\t" + (app.initialLoading ? "JSONloading" : "JSONloaded") + "\n\t\t" + (app.initialized ? "alreadyRun" : "firstRun") + "\n\t\t" + (app.connectedToServer ? "appConnected" : "appDisconnected") + "\n\t\t" + "" /* app.credentials == null ? `showLogin` : `hideLogin` */ + "\n\t\t" + (app.templates ? "templatesLoaded" : "templatesLoading") + "\n\t\t" + (app.dialog && "dialog" + app.dialog) + "\n\t\t" + (app.dialog ? "dialogIsPresent" : "dialogIsAbsent") + "\n\t\tapp_labels_" + !!local.labels + "\n\t\tapp_editing_" + !!app.editing + "\n\t\tlayout_" + (lu.valueOf(app.windowSize) && lu.valueOf(app.windowSize).layout) + "\n\t\twindow_" + (lu.valueOf(app.windowSize) && lu.valueOf(app.windowSize).window) + "\n\t\ttheme" + app.themeName + "\n\t";
			} },
		__(Background, null),
		__(
			"div",
			{ class: "app_content" },
			__(
				"div",
				{ class: "backing_sized" },
				__(Top, null),
				__(Bottom, null),
				__(MainScreen, null),
				dialogContainer
			)
		),
		__(StartupScreen, null),
		__("div", { class: "loadingScreen" })
	);

	app.icons = IconTemplates.reduce(function (icons, template) {
		icons[template.dataset.name] = template;
		return icons;
	}, Object.create(null));

	var CloseError = function CloseError(attr, text) {
		return __(
			"p",
			{
				ontouch: function () {
					var error = app.error;
					app.dialog = "";
					app.error = null;
					attr.onclick && attr.onclick(error);
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			text
		);
	};

	var CloseDialog = function CloseDialog(attr, text) {
		return __(
			"p",
			{
				ontouch: function () {
					app.dialog = "";
					attr.onclick && attr.onclick();
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			text
		);
	};

	// dialogs
	var dialogTemplates = {

		ServiceDialog: function ServiceDialog() {
			var _context;

			return (_context = new Promise(function (resolve) {
				resolve(require("ui/ServiceDialog"));
			}), app.load).call(_context);
		},
		ContextMenu: function ContextMenu() {
			var _context2;

			return (_context2 = new Promise(function (resolve) {
				resolve(require("ui/ContextMenu"));
			}), app.load).call(_context2);
		},
		AddMenu: function AddMenu() {
			var _context3;

			return (_context3 = new Promise(function (resolve) {
				resolve(require("ui/AddMenu"));
			}), app.load).call(_context3);
		},
		ThemeMenu: function ThemeMenu() {
			var _context4;

			return (_context4 = new Promise(function (resolve) {
				resolve(require("ui/ThemeMenu"));
			}), app.load).call(_context4);
		},
		SearchItems: function SearchItems() {
			var _context5;

			return (_context5 = new Promise(function (resolve) {
				resolve(require("ui/SearchItems"));
			}), app.load).call(_context5);
		},
		SearchPictures: function SearchPictures() {
			var _context6;

			return (_context6 = new Promise(function (resolve) {
				resolve(require("ui/SearchPictures"));
			}), app.load).call(_context6);
		},
		AskNewName: function AskNewName() {
			var _context7;

			return (_context7 = new Promise(function (resolve) {
				resolve(require("ui/AskNewName"));
			}), app.load).call(_context7);
		},
		AskToLinkDevice: function AskToLinkDevice() {
			var _context8;

			return (_context8 = new Promise(function (resolve) {
				resolve(require("ui/AskToLinkDevice"));
			}), app.load).call(_context8);
		},

		AskIfDeviceHasBeenLinked: function AskIfDeviceHasBeenLinked() {
			return __(
				"div",
				null,
				__(
					"p",
					null,
					"   ?"
				),
				__(
					Button,
					{ onclick: "StopDeviceNotification" },
					""
				),
				__(
					Button,
					{ onclick: "AskToLinkDevice" },
					""
				)
			);
		},

		StopDeviceNotification: function StopDeviceNotification() {
			return __(
				"div",
				null,
				__(
					"p",
					null,
					",",
					__("br", null),
					"    ."
				),
				__(
					Button,
					null,
					""
				)
			);
		},

		ErrorNoCarrier: function ErrorNoCarrier() {
			return __(
				"div",
				{ class: "errorDialog" },
				__(
					"p",
					null,
					""
				),
				__(
					"p",
					null,
					"      ."
				),
				__(
					Button,
					null,
					""
				)
			);
		},

		ErrorUnlinkingDevice: function ErrorUnlinkingDevice() {
			return __(
				"div",
				{ class: "errorDialog" },
				__(
					"p",
					null,
					""
				),
				__(
					"p",
					null,
					"       ."
				),
				__(
					"p",
					null,
					"  ?"
				),
				__(
					"ul",
					null,
					__(
						CloseError,
						{ onclick: function (error) {
								return app.purgeItem(error.data.deviceId);
							}
						},
						__(
							"li",
							null,
							"    "
						)
					),
					__(
						CloseError,
						null,
						__(
							"li",
							null,
							" "
						)
					),
					__(
						CloseError,
						{ onclick: function (error) {
								return app.purgeItem(error.data.deviceId, true);
							}
						},
						__(
							"li",
							null,
							"   "
						)
					)
				)
			);
		},

		DeleteDevice: function DeleteDevice() {
			return __(
				"div",
				null,
				__(
					"p",
					null,
					({
						place: __(
							"span",
							null,
							" () \"",
							app.caption,
							"\"    ."
						),
						single: __(
							"span",
							null,
							" \"",
							app.caption,
							"\"    ."
						),
						group: __(
							"span",
							null,
							" \"",
							app.caption,
							"\"    ."
						)
					})[app.deviceType]
				),
				__(
					"ul",
					null,
					__(
						CloseDialog,
						{ class: "dangerousAction", onclick: function () {
								return app.purgeItem(app.activeDeviceId);
							}
						},
						__(
							"li",
							null,
							""
						)
					),
					__(
						CloseDialog,
						null,
						__(
							"li",
							null,
							" "
						)
					)
				)
			);
		},

		StateWait: function StateWait() {
			return __(
				"div",
				null,
				__(
					"p",
					null,
					"..."
				)
			);
		},

		AskToReset: function AskToReset() {
			return __(
				"div",
				null,
				__(
					"p",
					null,
					"   ,",
					__("br", null),
					"     ."
				),
				__(
					Button,
					{ class: "dangerousAction", onclick: app.reset },
					"",
					__("br", null),
					""
				)
			);
		}

	};

	// AddPlace,
	// AddDevice,
	(0, _ra2.default)(regeneratorRuntime.mark(function callee$1$0() {
		var dialogName, Template, control, state, dialog;
		return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
			while (1) switch (context$2$0.prev = context$2$0.next) {
				case 0:
					dialogName = app.dialog;

					if (dialogName) {
						context$2$0.next = 3;
						break;
					}

					return context$2$0.abrupt("return");

				case 3:
					if (Object.prototype.hasOwnProperty.call(dialogTemplates, dialogName)) {
						context$2$0.next = 7;
						break;
					}

					alert("Error: Could not find dialog named\n\"" + dialogName + "\"");
					_ra2.default.detach(function () {
						return app.dialog = "";
					});
					return context$2$0.abrupt("return");

				case 7:
					Template = dialogTemplates[dialogName];

					if (Template) {
						context$2$0.next = 10;
						break;
					}

					return context$2$0.abrupt("return");

				case 10:
					dialogTemplates[dialogName] = null;

					control = Template();

					if (!(typeof control.then == "function")) {
						context$2$0.next = 16;
						break;
					}

					context$2$0.next = 15;
					return control;

				case 15:
					control = context$2$0.sent;

				case 16:
					state = (0, _ra2.default)({
						get isActive() {
							return dialogName == app.dialog;
						},
						_timer: null,
						_activeState: false,
						get _activeChanged() {
							var _this = this;

							clearTimeout(this._timer);
							this._timer = null;
							if (this.isActive) this._timer = setTimeout(function () {
								return _this._activeState = true;
							});else this._activeState = false;
						},
						get _activeStateChanged() {
							if (this._activeState) {
								var input = control.querySelector("*[ autofocus ]");
								if (input) app.focus(input);
								control.dispatchEvent(new CustomEvent("dialogshow", { detail: null }));
							} else {
								var _iteratorNormalCompletion = true;
								var _didIteratorError = false;
								var _iteratorError = undefined;

								try {
									for (var _iterator = control.querySelectorAll("*:focus")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
										var elem = _step.value;

										elem.blur();
									}
								} catch (err) {
									_didIteratorError = true;
									_iteratorError = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion && _iterator["return"]) {
											_iterator["return"]();
										}
									} finally {
										if (_didIteratorError) {
											throw _iteratorError;
										}
									}
								}

								dialog.blur();
								control.dispatchEvent(new CustomEvent("dialoghide", { detail: null }));
							}
						}
					});
					dialog = __(
						"div",
						{ class: function () {
								return "\n\t\t\tmodalDialog\n\t\t\t" + dialogName + "\n\t\t\t" + (state.isActive ? "dialogShown" : "dialogHidden") + "\n\t\t";
							} },
						control
					);

					dialogContainer.appendChild(dialog);

				case 19:
				case "end":
					return context$2$0.stop();
			}
		}, callee$1$0, this);
	}));

	setTimeout(function () {
		return app.pageStarting = false;
	}, 1);

	return application;
};

module.exports = exports.default;
/*
  -  /    reflow,  
   /     .
*/

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"app":236,"localUtils":249,"ra":255,"ui/AddMenu":261,"ui/AskNewName":263,"ui/AskToLinkDevice":264,"ui/Background":265,"ui/Bottom":266,"ui/Button":267,"ui/ContextMenu":269,"ui/MainScreen":271,"ui/SearchItems":275,"ui/SearchPictures":276,"ui/ServiceDialog":277,"ui/StartupScreen":278,"ui/ThemeMenu":279,"ui/Top":280}],260:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _uiCommand = require("ui/Command");

var _uiCommand2 = _interopRequireDefault(_uiCommand);

exports.default = function (app) {
	var Command = app.load(_uiCommand2.default);
	return function (attr) {
		return __(Command, {
			message: "commandAddExistingItem",
			onclick: function () {
				app.dialog = "SearchItems";
				app.searchAction = function (itemId) {
					app.linkItem(app.activeDeviceId, itemId);
					app.dialog = "";
				};
				app.searchFilter = null;
				if (app.deviceType == "group") app.searchFilter = function (itemId) {
					var device = app.getDevice(itemId);
					return device && device.type == "single";
				};
			},
			_: attr
		});
	};
};

module.exports = exports.default;

},{"ui/Command":268}],263:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _htmlutils = require("htmlutils");

var htmlutils = _interopRequireWildcard(_htmlutils);

exports.default = function (app) {
	var $ = {};
	return __(
		"div",
		{ ondialogshow: function () {
				$.string.value = app.getMessage(app.getDevice(app.activeDeviceId));
				$.string.setSelectionRange(0, $.string.value.length);
			} },
		__(
			"p",
			null,
			":"
		),
		__(
			"form",
			{ onsubmit: function (event) {
					event && event.preventDefault();
					var name = $.string.value.trim();
					app.dialog = "";
					if (name) app.renameItem(app.activeDeviceId, name);
				} },
			$.string = __("textarea", { name: "string", cols: "35", rows: "2", autofocus: "autofocus" }),
			__(
				"p",
				null,
				__(
					"a",
					{ class: "button", href: "javascript:void(0)", target: "_self", ontouch: htmlutils.Submit },
					""
				)
			)
		)
	);
};

module.exports = exports.default;

},{"htmlutils":246}],264:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _co = require("co");

var co = _interopRequireWildcard(_co);

var _uiButton = require("ui/Button");

var _uiButton2 = _interopRequireDefault(_uiButton);

exports.default = function (app) {
	var Button = app.load(_uiButton2.default);
	return __(
		"div",
		null,
		__(
			"p",
			null,
			",",
			__("br", null),
			"   ",
			__("br", null),
			"  "
		),
		__(
			Button,
			{ onclick: function () {
					var placeId = app.linkingPlaceId || app.activeDeviceId;
					app.dialog = "StateWait";
					co.go(regeneratorRuntime.mark(function callee$2$0() {
						return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
							while (1) switch (context$3$0.prev = context$3$0.next) {
								case 0:
									context$3$0.next = 2;
									return app.command(placeId, "Link");

								case 2:
									app.dialog = "AskIfDeviceHasBeenLinked";
									app.linkingPlaceId = placeId;

								case 4:
								case "end":
									return context$3$0.stop();
							}
						}, callee$2$0, this);
					})).catch(function (error) {
						console.log(error);
						app.dialog = "ErrorNoCarrier";
					});
				}
			},
			""
		)
	);
};

module.exports = exports.default;

},{"co":238,"ui/Button":267}],266:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _htmlutils = require("htmlutils");

var htmlutils = _interopRequireWildcard(_htmlutils);

exports.default = function (app) {
	return function () {
		return __(
			"div",
			{ class: "bottom" },
			__(
				"div",
				{ class: "help",
					// onpress = { () => app.dialog = `ServiceDialog` }
					onpress: function () {
						var text = "";
						for (var i = 0; i < localStorage.length; ++i) {
							text += localStorage.key(i);
							text += "\n";
						}
						alert(text);
					}
					// ontap = { function () {
					// 	let c = this
					// 	let ret = []
					// 	while ( c ) {
					// 		let n = c.className
					// 		if ( n ) {
					// 			n = n.trim().split( /\s+/ )
					// 			if ( n[ 0 ] )
					// 				ret.push( n )
					// 		}
					// 		c = c.parentNode
					// 	}
					// 	alert( ret.reverse().map( ( n, i ) => n.map( c => `${ i + 1 } .${ c }` ).join( `\n` ) ).join( `\n` ) )
					// } }
				},
				__(
					"div",
					{ class: "backing" },
					__("div", { class: "help_img" })
				)
			),
			__(
				"div",
				{ class: "logo",
					onpress: function () {
						return app.dialog = "ContextMenu";
					},
					ontap: function (event) {
						if (event.shiftKey || event.srcEvent && event.srcEvent.shiftKey) return app.dialog = "ContextMenu";
						if (event.ctrlKey || event.srcEvent && event.srcEvent.ctrlKey) return app.dialog = "SearchItems";
						app.editing = false;
						app.dialog = "";
						app.go(app.main);
					}
				},
				__(
					"div",
					{ class: "backing" },
					__("div", { class: "menu_img" })
				)
			),
			__(
				"div",
				{ class: "back",
					ontouch: function () {
						if (app.editing) app.editing = false;else if (app.dialog) app.dialog = "";else app.back();
					}
				},
				__(
					"div",
					{ class: "backing" },
					__("div", { class: "back_img" })
				)
			)
		);
	};
};

module.exports = exports.default;

},{"htmlutils":246}],267:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (app) {
	return function (attr, content) {
		return __(
			"a",
			{ class: "button", href: "javascript:void(0)", target: "_self", ontouch: function (event) {
					event.preventDefault();
					if (typeof attr.onclick == "string") app.dialog = attr.onclick;else {
						app.dialog = "";
						attr.onclick && attr.onclick();
					}
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			content
		);
	};
};

module.exports = exports.default;

},{}],268:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _htmlutils = require("htmlutils");

var htmlutils = _interopRequireWildcard(_htmlutils);

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

exports.default = function (app) {
	return function (_ref) {
		var onclick = _ref.onclick;
		var url = _ref.url;
		var visible = _ref.visible;
		var enabled = _ref.enabled;
		var message = _ref.message;

		var content = app.message(message);
		var isEnabled = function isEnabled() {
			return (url || onclick) && (!enabled || enabled());
		};
		if (typeof visible == "string") {
			(function () {
				var deviceType = visible;
				visible = function () {
					return app.deviceType == deviceType;
				};
			})();
		}
		var ret = undefined;
		if (url && !onclick) ret = __(
			"a",
			{ href: url, rel: "external", target: "_blank" },
			content
		);else ret = __(
			"a",
			{ href: "javascript:void(0)", target: "_self", ontouch: function (event) {
					event.preventDefault();
					if (onclick && isEnabled()) {
						if (typeof onclick == "string") app.dialog = onclick;else {
							app.dialog = "";
							onclick();
						}
					}
				} },
			content
		);
		var isVisible = (0, _ra2.default)(function () {
			return visible == null || visible();
		});
		var root = __(
			"div",
			{ class: function () {
					return "\n\t\tcommand\n\t\t" + message + "\n\t\t" + (isEnabled() ? "enabled" : "disabled") + "\n\t\t" + (visible == null || visible() ? "itemVisible" : "itemHidden") + "\n\t";
				} },
			__(
				"div",
				{ class: "backing" },
				__(
					htmlutils.Centered,
					null,
					ret
				)
			)
		);
		root.isVisible = isVisible.valueOf.bind(isVisible);
		return root;
	};
};

module.exports = exports.default;

},{"htmlutils":246,"ra":255}],269:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _uiMenu = require("ui/Menu");

var _uiMenu2 = _interopRequireDefault(_uiMenu);

var _uiCommand = require("ui/Command");

var _uiCommand2 = _interopRequireDefault(_uiCommand);

var _uiAddExistingItem = require("ui/AddExistingItem");

var _uiAddExistingItem2 = _interopRequireDefault(_uiAddExistingItem);

exports.default = function (app, local) {
	var Menu = app.load(_uiMenu2.default);
	var Command = app.load(_uiCommand2.default);
	var AddExistingItem = app.load(_uiAddExistingItem2.default);
	return __(
		Menu,
		null,
		__(Command, {
			message: "commandSearchDevices",
			onclick: "SearchItems"
		}),
		__(Command, {
			message: "commandToFavourites",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.linkActiveToFavourites();
				app.notification("  ");
			}
		}),
		__(Command, {
			message: "commandLinkDevice",
			visible: "device",
			onclick: "AskToLinkDevice"
		}),
		__(Command, {
			message: "commandAdd",
			visible: function () {
				return !app.editing && app.deviceType == "place";
			},
			onclick: "AddMenu"
		}),
		__(AddExistingItem, {
			message: "commandAdd",
			visible: function () {
				return !app.editing && app.deviceType == "group";
			}
		}),
		__(Command, {
			message: "commandMoveIcons",
			visible: function () {
				return !app.editing && app.deviceType != "single";
			},
			onclick: function () {
				return app.editing = true;
			}
		}),
		__(Command, {
			message: "commandRenameItem",
			visible: function () {
				return !app.editing;
			},
			onclick: "AskNewName"
		}),
		__(Command, {
			message: "commandChangeIcon",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.dialog = "SearchPictures";
				app.searchAction = function (name) {
					if (name) app.changePicture(app.activeDeviceId, name);
					app.dialog = "";
				};
				app.searchFilter = null;
			}
		}),
		__(Command, {
			message: "commandChangeSkin",
			visible: function () {
				return app.activeDeviceId == app.main;
			},
			onclick: "ThemeMenu"
		}),
		__(Command, {
			message: "commandPurgeItem",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.dialog = "DeleteDevice";
				// app.purgeItem( app.activeDeviceId )
			}
		}),
		__(Command, {
			message: "commandShowLabels",
			visible: function () {
				return !local.labels && app.activeDeviceId == app.main;
			},
			onclick: function () {
				return local.labels = true;
			}
		}),
		__(Command, {
			message: "commandHideLabels",
			visible: function () {
				return local.labels && app.activeDeviceId == app.main;
			},
			onclick: function () {
				return local.labels = false;
			}
		}),
		__(Command, {
			message: "commandResetToFactorySettings",
			visible: function () {
				return app.activeDeviceId == app.main;
			},
			enabled: function () {
				return window.location.hostname != "test.sh.neroelectronics.by";
			},
			onclick: "AskToReset"
		})
	);
};

module.exports = exports.default;

},{"ui/AddExistingItem":260,"ui/Command":268,"ui/Menu":272}],270:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _co = require("co");

var co = _interopRequireWildcard(_co);

var _diff = require("diff");

var Diff = _interopRequireWildcard(_diff);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var _localUtils = require("localUtils");

var lu = _interopRequireWildcard(_localUtils);

var _htmlutils = require("htmlutils");

var htmlutils = _interopRequireWildcard(_htmlutils);

var _commands = require("commands");

var commands = _interopRequireWildcard(_commands);

exports.default = function (app, local) {
	return function (_ref) {
		var placeId = _ref.placeId;
		var iconId = _ref.iconId;
		var iconDescr = _ref.iconDescr;
		var position = _ref.position;

		var icon = undefined,
		    image = undefined;
		var isMouse = false;

		var placeRect = htmlutils.tickCache(function () {
			var x = icon.parentNode;
			var r = undefined;
			while ((r = x.getBoundingClientRect(), !r.width || !r.height)) x = x.parentNode;
			return r;
		});

		var relPoint = function relPoint(p) {
			var r = placeRect();
			return {
				x: (p.x - r.left) / r.width * 100,
				y: (p.y - r.top) / r.height * 100
			};
		};

		var getPoint = function getPoint(data) {
			return relPoint({ x: data.pageX, y: data.pageY });
		};

		var getLeftTop = function getLeftTop(data) {
			var p = data.getBoundingClientRect();
			return relPoint({ x: p.left, y: p.top });
		};

		var imageHeight = htmlutils.tickCache(function () {
			if (!isMouse) return icon.getBoundingClientRect().height;
			if (opts.iconData) {
				if (opts.iconData.deviceImageGetHeight) {
					var r = opts.iconData.deviceImageGetHeight();
					if (r) return r;
				}
				var h = opts.iconData.getElementsByClassName("device_image_height")[0];
				if (h != null && h.getBoundingClientRect) {
					var r = h.getBoundingClientRect().height;
					if (r) return r;
				}
				for (var i = 0; i < opts.iconData.childNodes.length; ++i) {
					var r = opts.iconData.childNodes.item(i);
					if (r.getBoundingClientRect) {
						r = r.getBoundingClientRect().height;
						if (r) return r;
					}
				}
			}
			return image.getBoundingClientRect().height;
		});

		var opts = (0, _ra2.default)({

			get iconName() {
				return iconDescr && iconDescr.valueOf() && iconDescr.valueOf().icon || null;
			},
			get iconTemplate() {
				return this.iconName && app.icons && Object.prototype.hasOwnProperty.call(app.icons, this.iconName) && app.icons[this.iconName] || null;
			},
			iconData: null,
			get updateIconDataState() {
				var data = this.iconData;
				if (data && data.deviceSetState) data.deviceSetState(this.state);
			},

			get dimmering() {
				var i = iconDescr == null ? null : iconDescr.valueOf();
				var id = i == null ? null : i.dimmering == null ? null : !!i.dimmering;
				if (id != null) return id;
				if (i != null && i.type === "place") return false;
				return true;
			},

			iconCommand: function iconCommand(cmd, data) {
				return app.iconCommand(iconDescr, iconId, cmd, data);
			},

			isDimmering: false,
			moving: false,
			moved: false,
			x: null,
			y: null,

			get present() {
				return !!(iconDescr.get("content") || iconDescr.get("group"));
			},
			state: 0,
			onning: false,
			offing: false,
			final: true,
			errorneous: false,
			get updateState() {
				var d = iconDescr && iconDescr.valueOf();
				if (!d) return 0;
				if (d.clientstate != null) {
					this.onning = false;
					this.offing = false;
					this.final = false;
					this.state = d.clientstate;
				} else if (d.newstate_timestamp && (!d.state_timestamp || d.newstate_timestamp > d.state_timestamp)) {
					var fonning = d.newstate >= d.state;
					this.onning = fonning;
					this.offing = !fonning;
					this.final = false;
					this.state = d.newstate;
				} else {
					this.onning = false;
					this.offing = false;
					this.final = true;
					this.state = d.state;
				}
				this.errorneous = !!d.errorneous;
			}
		});

		var MOVE_PAGE_DIST = 0.1;
		var MOVE_SIDE_DIST = 0.25;

		function compareIndex(a, b) {
			return a.index - b.index;
		}

		var move = regeneratorRuntime.mark(function move(start, next) {
			var changes, currentPosition, done, hover, p, r, fingerShift, _loop, pt, _ret, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step;

			return regeneratorRuntime.wrap(function move$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						if (opts.moving) opts.moving.kill("restarting by another finger");

						changes = app.dbcache.open();
						currentPosition = position.valueOf();
						done = false;
						hover = (0, _ra2.default)({
							savedId: null,
							cachedId: null,
							id: null,
							position: null,

							updateApp: function updateApp(value) {
								if (this.savedId) app.hover = Diff.apply(app.hover, _defineProperty({}, this.savedId, _defineProperty({}, placeId, _defineProperty({}, iconId, value))));
							},

							// TODO: insert debounce mechanism just into ra
							get updateCache() {
								// debounce id changing
								this.cachedId = this.id;
							},

							get saveId() {
								this.updateApp(null);
								this.savedId = this.cachedId;
								this.updateApp(true);
							}
						});

						co.defer(function () {
							hover.id = null;
							done = true;
							changes.close();
							if (opts.moving == co.current) {
								opts.moving = null;
								opts.moved = false;
							}
						});

						(0, _ra2.default)(co.wrap(function () {
							return !done && !app.editing && co.current.kill();
						}));

						p = getPoint(start);
						r = getLeftTop(icon);

						opts.moving = co.current;
						opts.moved = false;
						fingerShift = {
							x: r.x - p.x,
							y: r.y - p.y
						};

						opts.x = r.x;
						opts.y = r.y;

						_loop = function (pt) {
							var finger = getPoint(pt);
							var corner = {
								x: finger.x + fingerShift.x,
								y: finger.y + fingerShift.y
							};
							if (opts.x != corner.x || opts.y != corner.y) opts.moved = true;
							opts.x = corner.x;
							opts.y = corner.y;

							var pageSize = {
								x: app.pageWidth,
								y: app.pageHeight
							};
							var cellSize = {
								x: 100 / pageSize.x,
								y: 100 / pageSize.y
							};
							var index = {
								x: Math.min(pageSize.x - 1, Math.max(0, Math.floor(finger.x / cellSize.x))),
								y: Math.min(pageSize.y - 1, Math.max(0, Math.floor(finger.y / cellSize.y)))
							};
							var inCell = {
								x: finger.x / cellSize.x - index.x,
								y: finger.y / cellSize.y - index.y
							};

							var placePosition = index.x + index.y * pageSize.x + (local.placesPages[placeId] || 0) * pageSize.x * pageSize.y;

							var isInCenter = inCell.x > MOVE_SIDE_DIST && inCell.x < 1 - MOVE_SIDE_DIST && inCell.y > MOVE_SIDE_DIST && inCell.y < 1 - MOVE_SIDE_DIST;

							if (!isInCenter || hover.position != placePosition) hover.id = null;
							hover.position = placePosition;

							if (pt.type != "stop") return "continue";

							hover.id = null;

							if (inCell > 1 - MOVE_PAGE_DIST && cellSize.x == pageSize.x - 1) {
								// TODO: scroll page right
								return "continue";
							}
							if (inCell < MOVE_PAGE_DIST && cellSize.x == pageSize.x - 1) {
								// TODO: scroll page left
								return "continue";
							}

							var place = lu.get(changes, "result", "content", placeId, "content");
							if (!place || !place[iconId]) return {
									v: undefined
								};
							var keys = lodash.keys(place).map(function (key) {
								return { key: key, index: place[key].index };
							}).sort(compareIndex);

							var newIndex = undefined;

							if (placePosition < 0) {
								if (currentPosition <= 0) return "continue";
								newIndex = keys[0].index - 1;
							} else if (placePosition > keys.length - 1) {
								if (currentPosition >= keys.length - 1) return "continue";
								newIndex = keys[keys.length - 1].index + 1;
							} else {
								if (currentPosition == placePosition) return "continue";
								if (isInCenter) {
									// TODO
									hover.id = keys[placePosition].key;
									var srcDevice = iconDescr && iconDescr.valueOf();
									var srcType = srcDevice && iconDescr.valueOf().type;
									var dstDevice = app.getDevice(hover.id);
									var dstType = dstDevice && dstDevice.type;
									// TODO: allow dstType == `single` && srcType == `single`
									if (false || srcType == "group" && dstType == "group" || srcType == "group" && dstType == "place" || srcType == "single" && dstType == "group" || srcType == "single" && dstType == "place") return "continue";
									hover.id = null;
								}
								if (inCell.x > 0.5) {
									if (currentPosition == placePosition + 1) return "continue";
									if (index.x == pageSize.x - 1 && currentPosition > placePosition) return "continue";
									if (placePosition >= keys.length - 1) newIndex = keys[placePosition].index + 1;else newIndex = (keys[placePosition].index + keys[placePosition + 1].index) / 2;
								} else {
									if (currentPosition == placePosition - 1) return "continue";
									if (index.x == 0 && currentPosition < placePosition) return "continue";
									if (placePosition <= 0) newIndex = keys[placePosition].index - 1;else newIndex = (keys[placePosition].index + keys[placePosition - 1].index) / 2;
								}
							}

							var newPosition = keys.map(function (k) {
								return k.key != iconId ? k : { key: k.key, index: newIndex };
							}).sort(compareIndex).findIndex(function (k) {
								return k.key == iconId;
							});

							if (currentPosition == newPosition) return "continue";

							currentPosition = newPosition;
							changes.update({ content: _defineProperty({}, placeId, { content: _defineProperty({}, iconId, {
										__present__: true,
										index: newIndex
									}) }) });
						};

						pt = undefined;

					case 16:
						context$3$0.next = 18;
						return next;

					case 18:
						if (!(pt = context$3$0.sent)) {
							context$3$0.next = 28;
							break;
						}

						_ret = _loop(pt);
						context$3$0.t0 = _ret;
						context$3$0.next = context$3$0.t0 === "continue" ? 23 : 24;
						break;

					case 23:
						return context$3$0.abrupt("continue", 26);

					case 24:
						if (!(typeof _ret === "object")) {
							context$3$0.next = 26;
							break;
						}

						return context$3$0.abrupt("return", _ret.v);

					case 26:
						context$3$0.next = 16;
						break;

					case 28:
						done = true;

						if (hover.id) {
							context$3$0.next = 37;
							break;
						}

						context$3$0.next = 32;
						return co.sleep();

					case 32:
						context$3$0.next = 34;
						return app.serverDevices.update(changes.transform());

					case 34:
						changes.close();
						context$3$0.next = 38;
						break;

					case 37:
						(function () {
							changes.close();
							var srcType = iconDescr && iconDescr.valueOf() && iconDescr.valueOf().type;
							var dstDevice = app.getDevice(hover.id);
							var dstType = dstDevice && dstDevice.type;

							if (dstType == "place" || srcType == "single" && dstType == "group") app.linkItem(hover.id, iconId);else if (srcType == "group" && dstType == "group") {
								_iteratorNormalCompletion = true;
								_didIteratorError = false;
								_iteratorError = undefined;

								try {
									for (_iterator = lodash.keys(iconDescr.valueOf().content)[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
										var i = _step.value;

										app.linkItem(hover.id, i);
									}
								} catch (err) {
									_didIteratorError = true;
									_iteratorError = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion && _iterator["return"]) {
											_iterator["return"]();
										}
									} finally {
										if (_didIteratorError) {
											throw _iteratorError;
										}
									}
								}
							}

							var copy = icon.cloneNode(true);
							// copy.querySelector( `.image` ).style.backgroundColor = `red`
							copy.classList.add("transition_off");
							var parent = icon.parentNode;
							parent.appendChild(copy);
							global.getComputedStyle(copy); // force reflow
							copy.classList.remove("transition_off");
							copy.classList.add("transition_on");
							global.getComputedStyle(copy); // force reflow
							setTimeout(function () {
								return copy.classList.add("null_size");
							}, 100);
							setTimeout(function () {
								return parent.removeChild(copy);
							}, 3000);

							// icon.querySelector( `.image` ).style.backgroundColor = `green`
							icon.classList.add("transition_off");
							global.getComputedStyle(icon); // force reflow
							icon.classList.add("null_size");
							setScreenPosition(icon.style, getCurrentScreenPosition());
							global.getComputedStyle(icon); // force reflow
							icon.classList.remove("transition_off");
							global.getComputedStyle(icon); // force reflow

							// TODO
							// let newPlace = app.getDevice( hover.id )
							// if ( newPlace && newPlace.type == `single` ) {
							// 	app.linkingDevices = [ hover.id, iconId ]
							// 	app.dialog = `CreatePlaceOrGroup`
							// }
							// else
							// app.insertInto( hover.id, iconId, placeId )
						})();

					case 38:
					case "end":
						return context$3$0.stop();
				}
			}, move, this);
		});

		var dimm = regeneratorRuntime.mark(function dimm(next) {
			var changes;
			return regeneratorRuntime.wrap(function dimm$(context$3$0) {
				var _this = this;

				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						changes = app.dbcache.open();
						context$3$0.prev = 1;
						return context$3$0.delegateYield(regeneratorRuntime.mark(function callee$3$0() {
							var state, initialDimmeringState, pt, delta;
							return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
								while (1) switch (context$4$0.prev = context$4$0.next) {
									case 0:
										state = undefined;

										opts.isDimmering = true;
										initialDimmeringState = iconDescr && iconDescr.get("state");
										pt = undefined;

									case 4:
										context$4$0.next = 6;
										return next;

									case 6:
										if (!(pt = context$4$0.sent)) {
											context$4$0.next = 11;
											break;
										}

										if (pt.detail.type == "swipe") {
											if (pt.detail.direction == "up") state = 1;else state = 0;
										} else {
											delta = -pt.deltaY / (imageHeight() * 1.0) /* move multiplyer */;

											state = Math.min(1, Math.max(0, initialDimmeringState + delta));
											if (state == 0 || state == 1) initialDimmeringState = state - delta;
										}
										changes.update(function (db) {
											return commands.SetState.db({ mode: "client" }, db, iconId, state);
										});

									case 9:
										context$4$0.next = 4;
										break;

									case 11:
										if (!(state != null)) {
											context$4$0.next = 14;
											break;
										}

										context$4$0.next = 14;
										return opts.iconCommand("Set", state);

									case 14:
									case "end":
										return context$4$0.stop();
								}
							}, callee$3$0, _this);
						})(), "t0", 3);

					case 3:
						context$3$0.prev = 3;

						changes.close();
						opts.isDimmering = false;
						return context$3$0.finish(3);

					case 7:
					case "end":
						return context$3$0.stop();
				}
			}, dimm, this, [[1,, 3, 7]]);
		});

		function getCurrentScreenPosition(shift) {
			var i = lu.valueOf(position);
			var mw = app.menuWidth || 100;
			var mh = app.menuHeight || 100;
			var ph = app.pageHeight || 1;
			var pw = app.pageWidth || 1;
			var ps = pw * ph;
			var pi = i % ps;
			var p = (i - pi) / ps;
			var w = pi % pw;
			var h = (pi - w) / pw;
			var img_size = Math.min(mw / pw, mh / ph);
			var margin = {
				x: (mw - img_size * pw) / (pw + 1),
				y: (mh - img_size * ph) / (ph + 1)
			};
			w = w * (img_size + margin.x) + margin.x + mw * p;
			h = h * (img_size + margin.y) + margin.y;
			if (shift) {
				w += shift.x;
				h += shift.y;
			}
			return { x: w, y: h, w: img_size, h: img_size };
		}
		function getCurrentScreenPosition_(shift) {
			var i = lu.valueOf(position);
			var ph = app.pageHeight || 1;
			var pw = app.pageWidth || 1;
			var ps = pw * ph;
			var pi = i % ps;
			var p = (i - pi) / ps;
			var w = pi % pw;
			var h = (pi - w) / pw;
			w += pw * p;
			if (shift) {
				w += shift.x;
				h += shift.y;
			}
			return { x: w * 100 / pw, y: h * 100 / ph };
		}

		function setScreenPosition(style, pt) {
			style.left = pt.x + "px";
			style.top = pt.y + "px";
			if (pt.w) {
				style.width = pt.w + "px";
				style.height = pt.h + "px";
			}
			style.position = "absolute";
			style.fontSize = pt.h * 0.09 + "px";
			return style;
		}
		function setScreenPosition_(style, pt) {
			style.left = pt.x + "%";
			style.top = pt.y + "%";
			return style;
		}

		return __(
			"div",
			{
				oncreate: function (e) {
					return icon = e.target;
				},
				onmousedown: function () {
					return isMouse = true;
				},
				onwheel: function (e) {
					return console.log(e.deltaY, e.deltaMode, e);
				},
				class: function () {
					return "\n\t\t\ticon\n\t\t\t" + (opts.onning && "onning") + "\n\t\t\t" + (opts.offing && "offing") + "\n\t\t\t" + (opts.final && "final") + "\n\t\t\t" + (opts.errorneous && "errorneous") + "\n\t\t\t" + (opts.dimmering.valueOf() ? "dimmering" : "switching") + "\n\t\t\t" + iconId + "\n\t\t\ticon_moving_" + !!opts.moving + "\n\t\t\ticon_moved_" + (!!opts.moving && !!opts.moved) + "\n\t\t\ticon_destination_" + !!(app.hover && app.hover[iconId]) + "\n\t\t";
				},
				style: regeneratorRuntime.mark(function callee$2$0() {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!app.editing) {
									context$3$0.next = 5;
									break;
								}

								context$3$0.next = 3;
								return co.sleep();

							case 3:
								context$3$0.next = 5;
								return co.requestAnimationFrame;

							case 5:
								return context$3$0.abrupt("return", setScreenPosition({}, opts.moving ? opts : getCurrentScreenPosition()));

							case 6:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this);
				})
			},
			__(
				"div",
				{ class: "backing" },
				__(
					"div",
					{ class: function () {
							return "\n\t\t\ticonControl\n\t\t\t" + ("state" + (opts.present ? "Present" : "Absent")) + "\n\t\t\t" + ("state" + (Math.round((opts.present ? opts.state : 0) * 100) + 1000).toString().slice(1)) + "\n\t\t\t" + ("state" + (Math.round((opts.present ? opts.state : 0) * 100) ? "On" : "Off")) + "\n\t\t\t" + (!opts.isDimmering ? "smoothing" : "") + "\n\t\t\t" + (opts.iconTemplate && opts.iconTemplate.className || "") + "\n\t\t";
						},
						ontouch: htmlutils.preventDefault,
						ontap: function () {
							return !app.editing && opts.iconCommand("Short");
						},
						onpress: function () {
							return !app.editing && opts.iconCommand("Long");
						},
						onpan: regeneratorRuntime.mark(function callee$2$0(data) {
							var next, pt;
							return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
								while (1) switch (context$3$0.prev = context$3$0.next) {
									case 0:
										if (!app.editing) {
											context$3$0.next = 21;
											break;
										}

										next = data.detail.lock();
										context$3$0.prev = 2;
										pt = undefined;

									case 4:
										context$3$0.next = 6;
										return next;

									case 6:
										if (!(pt = context$3$0.sent)) {
											context$3$0.next = 16;
											break;
										}

										if (!(pt.detail.pressed === false)) {
											context$3$0.next = 9;
											break;
										}

										return context$3$0.abrupt("return");

									case 9:
										if (!(pt.detail.pressed == null)) {
											context$3$0.next = 11;
											break;
										}

										return context$3$0.abrupt("continue", 14);

									case 11:
										context$3$0.next = 13;
										return move(pt, next);

									case 13:
										return context$3$0.abrupt("break", 16);

									case 14:
										context$3$0.next = 4;
										break;

									case 16:
										context$3$0.prev = 16;

										data.detail.unlock(next);
										return context$3$0.finish(16);

									case 19:
										context$3$0.next = 25;
										break;

									case 21:
										if (!(data.detail.direction == "up" || data.detail.direction == "down")) {
											context$3$0.next = 25;
											break;
										}

										// dimmering
										data.stopPropagation();
										context$3$0.next = 25;
										return dimm(data.detail.next);

									case 25:
									case "end":
										return context$3$0.stop();
								}
							}, callee$2$0, this, [[2,, 16, 19]]);
						})
					},
					__("span", { class: "label_state" }),
					__(
						"div",
						{ class: "image", oncreate: function (e) {
								return image = e.target;
							} },
						__(
							"div",
							{ class: "svg" },
							function () {
								return opts.iconData = opts.iconTemplate && htmlutils.importComponent(opts.iconTemplate) || null;
							}
						)
					),
					__(
						"span",
						{ class: "iconLabel text_lightning" },
						function () {
							return (iconDescr.get(local.language) || iconDescr.get("ru") || iconDescr.get("en")).toLowerCase();
						}
					)
				),
				__("div", { class: "deleteSign", ontouchstart: function () {
						return app.deleteItem(placeId, iconId);
					}, onmousedown: function () {
						return app.deleteItem(placeId, iconId);
					} })
			)
		);
	};
};

module.exports = exports.default;

// TODO: all ra structures must be linked to the current thread and must link all there tick procs to the current thread and so update all there ticks on subsequent yield and also update them all while finishing thread either normal or abnormal and then such ra structures must be destroyed to unlink from any external dependency. This must be done via implementing co.nextTick in terms like iojs.process.nextTick - nextTick callbacks must be processed before yielding subsequent result. So it is possible to let exceptions be raised in proper way. And it means that if possible nextTick callbacks will fire just after request for next yield.

//    left  top     transition

// moving

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"co":238,"commands":239,"diff":243,"htmlutils":246,"localUtils":249,"lodash":232,"ra":255}],265:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _colorString = require("color-string");

var cs = _interopRequireWildcard(_colorString);

exports.default = function (app) {
	return function () {
		return __(
			"div",
			{ style: " position: absolute; left: 0; top: 0; right: 0; bottom: 0; transform: scale( 1, -1 );\n" },
			__("img", { src: function () {
					return app.theme.background;
				}, style: " width: 100%; transform: scale( 1, -1 ); border: none; " }),
			__("div", { style: function () {
					return "\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tmin-height: 10cm;\n\t\ttransform: translate( 0, -3cm );\n\t\tbackground: linear-gradient( to bottom, " + cs.rgbString(cs.getRgb(app.theme.fill), 0) + ", " + cs.rgbString(cs.getRgb(app.theme.fill), 1) + " 3cm );\n\t";
				} })
		);
	};
};

module.exports = exports.default;

},{"color-string":219}],271:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _uid = require("uid");

var _uid2 = _interopRequireDefault(_uid);

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _uiPlace = require("ui/Place");

var _uiPlace2 = _interopRequireDefault(_uiPlace);

exports.default = function (app, local) {

	var Place = app.load(_uiPlace2.default);

	return function () {
		var marked2$0 = [pan].map(regeneratorRuntime.mark);

		var instanceID = (0, _uid2.default)();

		function pan(next) {
			var lastDeltaX, page, size, deviceid, data, deltaX, device, initialShift, shift;
			return regeneratorRuntime.wrap(function pan$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						lastDeltaX = undefined, page = undefined, size = undefined;
						deviceid = app.activeDeviceId;

						app.placesShifts.defineProperty(deviceid);
						local.placesPages.defineProperty(deviceid);
						context$3$0.prev = 4;
						data = undefined;

					case 6:
						context$3$0.next = 8;
						return next;

					case 8:
						if (!(data = context$3$0.sent)) {
							context$3$0.next = 24;
							break;
						}

						if (data.lastDeltaX) lastDeltaX = data.lastDeltaX;
						deltaX = data.deltaX;
						device = app.getDevice(deviceid);

						if (!(!device || !device.content)) {
							context$3$0.next = 14;
							break;
						}

						return context$3$0.abrupt("return");

					case 14:
						size = Math.ceil(Object.keys(device.content).length / (app.pageWidth * app.pageHeight));

						if (!(size == 0)) {
							context$3$0.next = 17;
							break;
						}

						return context$3$0.abrupt("continue", 22);

					case 17:
						page = local.placesPages[deviceid] || 0;
						initialShift = -page * app.menuWidth;
						shift = data.deltaX;

						if (shift > 0 && page == 0 || shift < 0 && page == size - 1) shift /= 3;
						app.placesShifts[deviceid] = shift;

					case 22:
						context$3$0.next = 6;
						break;

					case 24:
						if (lastDeltaX) {
							if (lastDeltaX > 0 && page > 0) local.placesPages[deviceid] = page - 1;else if (lastDeltaX < 0 && page < size - 1) local.placesPages[deviceid] = page + 1;
						}

					case 25:
						context$3$0.prev = 25;

						app.placesShifts[deviceid] = 0;
						return context$3$0.finish(25);

					case 28:
					case "end":
						return context$3$0.stop();
				}
			}, marked2$0[0], this, [[4,, 25, 28]]);
		}

		return __(
			"div",
			null,
			__(
				"style",
				{ class: "style" },
				function () {
					return "\n\t\t\t\t." + instanceID + " .icon {\n\t\t\t\t\twidth: " + 100 / app.pageWidth + "%;\n\t\t\t\t\theight: " + 100 / app.pageHeight + "%;\n\t\t\t\t}\n\t\t\t";
				}
			),
			__("div", { class: function () {
					return "under_top above_bottom menu " + instanceID + " " + app.activeDeviceId;
				},
				onpan: regeneratorRuntime.mark(function callee$2$0(data) {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!(data.detail.direction == "left" || data.detail.direction == "right")) {
									context$3$0.next = 3;
									break;
								}

								data.stopPropagation();
								return context$3$0.delegateYield(pan(event.detail.next), "t0", 3);

							case 3:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this);
				}),
				oncreate: function () {
					var _this = this;

					setInterval(function () {
						var rect = _this.getBoundingClientRect();
						app.menuWidth = rect.width;
						app.menuHeight = rect.height;
					}, 100);
					var shown = Object.create(null);
					(0, _ra2.default)(function () {
						var id = app.activeDeviceId;
						if (!id || shown[id]) return;
						app.placesShifts.defineProperty(id);
						local.placesPages.defineProperty(id);
						shown[id] = true;
						// TODO: remove <Place/> when such a place is actually removed from database
						_this.appendChild(__(Place, { placeId: id, placeDescr: (0, _ra2.default)(function () {
								return app.getDevice(id);
							}) }));
					});
				}
			})
		);
	};
};

module.exports = exports.default;

// TODO: no transition while panning

},{"ra":255,"ui/Place":274,"uid":281}],273:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _uiApplication = require("ui/Application");

var _uiApplication2 = _interopRequireDefault(_uiApplication);

exports.default = function (_ref) {
	var IconTemplates = _ref.IconTemplates;
	return __(
		"span",
		null,
		__(
			"style",
			null,
			" ",
			".application { position: fixed !important; } } ",
			" "
		),
		__(_uiApplication2.default, { IconTemplates: IconTemplates })
	);
};

module.exports = exports.default;

},{"ui/Application":262}],274:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var _localUtils = require("localUtils");

var lu = _interopRequireWildcard(_localUtils);

var _uiIcon = require("ui/Icon");

var _uiIcon2 = _interopRequireDefault(_uiIcon);

exports.default = function (app, local) {

	var Icon = app.load(_uiIcon2.default);

	return function (_ref) {
		var placeId = _ref.placeId;
		var placeDescr = _ref.placeDescr;

		var ids = (0, _ra2.default)(function () {
			var content = placeDescr.get("content");
			return _ra2.default.Array(lodash.keys(content).sort(function (a, b) {
				return lu.compare(content[a].index, content[b].index);
			}));
		});
		var content = _ra2.default.map(ids, function (iconId, position) {
			return __(Icon, {
				placeId: placeId,
				iconId: iconId,
				position: position,
				iconDescr: (0, _ra2.default)(function () {
					return app.getDevice(iconId);
				})
			});
		});
		return __(
			"div",
			null,
			__(
				"style",
				null,
				"\n\t\t\t\t." + placeId + " .place." + placeId + " {\n\t\t\t\t\tdisplay: initial;\n\t\t\t\t}\n\t\t\t"
			),
			__(
				"div",
				{ class: "place " + placeId, style: {
						transform: function transform() {
							return "translateX( " + (-(local.placesPages[placeId] || 0) * app.menuWidth + app.placesShifts[placeId] || 0) + "px )";
						}
					} },
				function () {
					return content;
				}
			)
		);
	};
};

module.exports = exports.default;

},{"localUtils":249,"lodash":232,"ra":255,"ui/Icon":270}],275:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var _DamerauLevenshtein = require("DamerauLevenshtein");

var _DamerauLevenshtein2 = _interopRequireDefault(_DamerauLevenshtein);

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var _localUtils = require("localUtils");

var lu = _interopRequireWildcard(_localUtils);

var _iscroll = require("iscroll");

var _iscroll2 = _interopRequireDefault(_iscroll);

var notAChar = function notAChar(char) {
	return char <= " " || char == "-";
};

var fuzzy = function fuzzy(mask, text) {
	return (0, _DamerauLevenshtein2.default)(mask.toUpperCase(), text.toUpperCase(), {
		replace: Infinity,
		delete: function _delete(char) {
			return notAChar(char) ? 1e-2 : Infinity;
		},
		insert: function insert(char) {
			return notAChar(char) ? 1e-2 : 1;
		},
		transpose: 1
	});
};

function watch(data, cb) {
	var v = undefined;
	return function () {
		if (v == null) _ra2.default.detach(function () {
			v = (0, _ra2.default)(data);
			(0, _ra2.default)(function () {
				v.valueOf();
				cb();
			});
		});
		return v.valueOf();
	};
}

exports.default = function (app) {
	var opts = undefined,
	    $ = {};

	var SearchItem = function SearchItem(_ref) {
		var placeId = _ref.placeId;
		return __(
			"div",
			{ class: "searchItem " + placeId, onscrolltap: function () {
					return opts.goto(placeId);
				} },
			__(
				"span",
				{ class: "caption" },
				function () {
					return opts.placeInfos[placeId].caption;
				}
			),
			__(
				"span",
				{ class: "places" },
				function () {
					return opts.placeInfos[placeId].ptext;
				}
			),
			__("span", { class: "cmdDeleteFromProgram" }),
			__("span", { class: "cmdAppend" })
		);
	};

	opts = (0, _ra2.default)({
		goto: function goto(id) {
			if (!id) return;
			var placeInfo = opts.placeInfos[id];
			~(app.searchAction || app.go)(id, placeInfo && placeInfo.places);
		},
		get deviceIds() {
			return _ra2.default.Array(app.deviceIds.filter(function (id) {
				return id != app.main;
			}));
		},
		get placeInfos() {
			var cache = Object.create(null);
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = app.deviceIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var id = _step.value;

					var info = app.getDevice(id);
					cache[id] = {
						info: info,
						caption: id == app.main ? "" : app.getMessage(info),
						places: []
					};
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator["return"]) {
						_iterator["return"]();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = app.deviceIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var id = _step2.value;
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = lodash.keys(cache[id].info.content)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var key = _step4.value;

							if (cache[key]) cache[key].places.push(id);
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
								_iterator4["return"]();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
						_iterator2["return"]();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var ret = Object.create(null);
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = app.deviceIds[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var id = _step3.value;

					var c = cache[id];
					var ptext = c.places.map(function (id) {
						return cache[id].caption;
					}).join(", ");
					if (ptext) ptext = " (" + ptext + ")";
					ret[id] = { id: id, caption: c.caption || "<***>", places: c.places, ptext: ptext };
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
						_iterator3["return"]();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			return _ra2.default.JSON(ret);
		},
		get labels() {
			return _ra2.default.keymap(opts.live.deviceIds, function (placeId) {
				return __(SearchItem, { placeId: placeId });
			});
		},
		get filtered() {
			var value = $.mask.raValue;
			var arr = [];
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = this.deviceIds.filter(app.searchFilter || Boolean)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var id = _step5.value;

					var i = opts.placeInfos[id];
					var key = [];
					if (value) {
						key.push(fuzzy(value, i.caption),
						// ??? Math.max( ...i.places.map( id => fuzzy( value, opts.placeInfos[ id ].caption ) ) ),
						fuzzy(value, i.caption + " " + i.ptext));
						if (key.every(function (k) {
							return Math.abs(k) == Infinity;
						})) continue;
					}
					key.push(i.caption.toUpperCase());
					arr.push({ id: id, key: key });
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
						_iterator5["return"]();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			return _ra2.default.Array(arr.sort(function (a, b) {
				return lodash.zip(a.key, b.key).map(function (pair) {
					return lu.compare.apply(lu, _toConsumableArray(pair));
				}).reduce(function (a, b) {
					return a || b;
				});
			}).map(function (a) {
				return a.id;
			}));
		},
		get items() {
			var _this = this;

			return _ra2.default.Array(this.filtered.map(function (id) {
				return _this.labels.get(id);
			}));
		}
	});
	window._search = opts;
	return __(
		"div",
		{
			ondialogshow: function () {
				$.scroller && $.scroller.refresh();
				// TODO: ,     ?
				$.mask.raValue = "";
			}
		},
		__(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					opts.goto(opts.filtered[0]);
				}
			},
			__("input", { name: "mask", type: "text", autofocus: "autofocus", oncreate: function (event) {
					return $.mask = event.target;
				} }),
			__(
				"div",
				{ class: "scroll", oncreate: function (event) {
						return $.scroll = event.target;
					} },
				__(
					"div",
					null,
					__(
						"div",
						{ class: "items" },
						watch(function () {
							return opts.items;
						}, function () {
							return setTimeout(function () {
								if (!$.scroller) $.scroller = new _iscroll2.default($.scroll, {
									mouseWheel: true,
									scrollbars: true,
									tap: "scrolltap"
								});else $.scroller.refresh();
							}, 100);
						})
					),
					__("div", { class: "scrollAreaBottomFiller" })
				)
			)
		)
	);
};

module.exports = exports.default;

},{"DamerauLevenshtein":233,"iscroll":248,"localUtils":249,"lodash":232,"ra":255}],272:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

exports.default = function () {
	return function (attr, content) {
		console.log(content, content && content.constructor);
		var visibility = [].concat(_toConsumableArray(content.children)).map(function (c) {
			return c.isVisible;
		}).filter(Boolean);
		return __(
			"div",
			{
				class: function () {
					return "count" + visibility.filter(function (v) {
						return v();
					}).length;
				},
				_: attr
			},
			content
		);
	};
};

module.exports = exports.default;

},{}],276:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var _DamerauLevenshtein = require("DamerauLevenshtein");

var _DamerauLevenshtein2 = _interopRequireDefault(_DamerauLevenshtein);

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

var _localUtils = require("localUtils");

var lu = _interopRequireWildcard(_localUtils);

var _htmlutils = require("htmlutils");

var htmlutils = _interopRequireWildcard(_htmlutils);

var _iscroll = require("iscroll");

var _iscroll2 = _interopRequireDefault(_iscroll);

var notAChar = function notAChar(char) {
	return char <= " " || char == "-";
};

var fuzzy = function fuzzy(mask, text) {
	return (0, _DamerauLevenshtein2.default)(mask.toUpperCase(), text.toUpperCase(), {
		replace: Infinity,
		delete: function _delete(char) {
			return notAChar(char) ? 1e-2 : Infinity;
		},
		insert: function insert(char) {
			return notAChar(char) ? 1e-2 : 1;
		},
		transpose: 1
	});
};

function watch(data, cb) {
	var v = undefined;
	return function () {
		if (v == null) _ra2.default.detach(function () {
			v = (0, _ra2.default)(data);
			(0, _ra2.default)(function () {
				v.valueOf();
				cb();
			});
		});
		return v.valueOf();
	};
}

exports.default = function (app) {
	var opts = undefined,
	    $ = {};

	var SearchItem = function SearchItem(templateName) {
		return(
			// TODO: change ${ templateName } to some invalid identifier like ${ _IS_NOT_DECLARED_ } and varidy that browser console will show some error
			__(
				"div",
				{ class: "searchItem searchPic " + templateName, onscrolltap: function () {
						return opts.goto(templateName);
					} },
				[] || __(
					"span",
					{ class: "img" },
					htmlutils.importComponent(app.icons[templateName])
				),
				__(
					"span",
					{ class: "caption" },
					templateName
				),
				__("span", { class: "cmdDeleteFromProgram" }),
				__("span", { class: "cmdAppend" })
			)
		);
	};

	opts = (0, _ra2.default)({
		goto: function goto(templateName) {
			if (!templateName) return;
			app.searchAction(templateName);
		},
		get templateNames() {
			return _ra2.default.Array(Object.keys(app.icons));
		},
		// get templates() { return ra.Array( this.templateNames.map( templateName => app.icons[ templateName ] ) ) },
		// TODO: change opts.live.templateNames to some constant like {} and verify that browser console will show some error
		get labels() {
			return _ra2.default.keymap(opts.live.templateNames, function (templateName) {
				return SearchItem(templateName);
			});
		},
		get filtered() {
			var value = $.mask.raValue;
			var arr = [];
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.templateNames.filter(app.searchFilter || Boolean)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var id = _step.value;

					var key = [];
					if (value) {
						key.push(fuzzy(value, id));
						if (key.every(function (k) {
							return Math.abs(k) == Infinity;
						})) continue;
					}
					key.push(id.toUpperCase());
					arr.push({ id: id, key: key });
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator["return"]) {
						_iterator["return"]();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return _ra2.default.Array(arr.sort(function (a, b) {
				return lodash.zip(a.key, b.key).map(function (pair) {
					return lu.compare.apply(lu, _toConsumableArray(pair));
				}).reduce(function (a, b) {
					return a || b;
				});
			}).map(function (a) {
				return a.id;
			}));
		},
		get items() {
			var _this = this;

			return _ra2.default.Array(this.filtered.map(function (id) {
				return _this.labels.get(id);
			}));
		}
	});
	window._search = opts;
	return __(
		"div",
		{
			ondialogshow: function () {
				$.scroller && $.scroller.refresh();
				// TODO: ,     ?
				$.mask.raValue = "";
			}
		},
		__(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					opts.goto(opts.filtered[0]);
				}
			},
			__("input", { name: "mask", type: "text", autofocus: "autofocus", oncreate: function (event) {
					return $.mask = event.target;
				} }),
			__(
				"div",
				{ class: "scroll", oncreate: function (event) {
						return $.scroll = event.target;
					} },
				__(
					"div",
					null,
					__(
						"div",
						{ class: "items" },
						watch(function () {
							return opts.items;
						}, function () {
							return setTimeout(function () {
								if (!$.scroller) $.scroller = new _iscroll2.default($.scroll, {
									mouseWheel: true,
									scrollbars: true,
									tap: "scrolltap"
								});else $.scroller.refresh();
							}, 100);
						})
					),
					__("div", { class: "scrollAreaBottomFiller" })
				)
			)
		)
	);
};

module.exports = exports.default;

},{"DamerauLevenshtein":233,"htmlutils":246,"iscroll":248,"localUtils":249,"lodash":232,"ra":255}],277:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _htmlutils = require("htmlutils");

var htmlutils = _interopRequireWildcard(_htmlutils);

exports.default = function (app) {
	var json = undefined;
	return __(
		"div",
		{ ondialogshow: function () {
				return json.value = JSON.stringify(app.getDevice(app.activeDeviceId), null, 3);
			} },
		__(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					var text = json.value.trim() || null;
					try {
						text = text && JSON.parse(text);
					} catch (error) {
						return alert(error);
					}
					debugger;
					if (text) app.saveDevice(app.activeDeviceId, text);
					app.dialog = "";
				}
			},
			__("textarea", {
				name: "json",
				autofocus: "autofocus",
				oncreate: function (event) {
					return json = event.target;
				},
				style: {
					position: "absolute",
					left: 0,
					right: 0,
					top: "10mm",
					bottom: "15mm",
					fontSize: "50%"
				}
			}),
			__(
				"a",
				{
					class: "save",
					href: "javascript:void(0)",
					target: "_self",
					ontouch: htmlutils.Submit,
					style: {
						position: "absolute",
						display: "block",
						left: 0,
						right: 0,
						height: "10mm",
						bottom: "0"
					}
				},
				"Save"
			)
		)
	);
};

module.exports = exports.default;

},{"htmlutils":246}],278:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _uiBackground = require("ui/Background");

var _uiBackground2 = _interopRequireDefault(_uiBackground);

exports.default = function (app) {
	var Background = app.load(_uiBackground2.default);
	return function () {
		return __(
			"div",
			{ class: "startupScreen" },
			__(Background, null),
			__(
				"div",
				{ class: "app_content" },
				__(
					"div",
					{ class: "backing_sized" },
					__(
						"p",
						null,
						"   ",
						__("br", null),
						" !"
					),
					__(
						"div",
						{ class: "templates" },
						__(
							"p",
							null,
							",  ,    :"
						),
						__(
							"ul",
							{ class: "houseTemplates" },
							function () {
								return (app.templates || []).concat([{
									menu: "   ",
									ru: " ",
									en: "Home",
									type: "place"
								}]).map(function (houseTemplate) {
									return __(
										"li",
										{ class: "houseTemplate", ontouch: function () {
												return app.setTemplate(houseTemplate);
											} },
										houseTemplate.menu || app.getMessage(houseTemplate)
									);
								});
							}
						)
					),
					__("div", { class: "loading" })
				)
			)
		);
	};
};

module.exports = exports.default;

},{"ui/Background":265}],280:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _htmlutils = require("htmlutils");

var htmlutils = _interopRequireWildcard(_htmlutils);

exports.default = function (app) {
	return function () {
		return __(
			"div",
			{ class: "top" },
			__(
				"div",
				{ class: "backing" },
				__(
					htmlutils.Centered,
					null,
					function () {
						return app.caption.trim().replace(/(\r|\n|\s)+/g, " ").toLowerCase().slice(0, 18);
					}
				)
			)
		);
	};
};

module.exports = exports.default;

},{"htmlutils":246}],281:[function(require,module,exports){
"use strict";

var counter = 0;

module.exports = function uid(obj) {
	var i = (++counter).toString(36);
	var r = parseInt((1 + Math.random()).toString().slice(2, 17)).toString(36);
	var id = (r.length + 9).toString(36) + r + i;
	if (obj == null) return id;else {
		obj.uid = id;
		return obj;
	}
};

},{}],282:[function(require,module,exports){
(function (Buffer){
/*
post /devices {"P":1}
*/
"use strict";

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

require("browser-nexttick");

require("platform");

require("htmlpolyfill");

require("track");

require("gesture");

require("colors");

var _localUtils = require("localUtils");

var lu = _interopRequireWildcard(_localUtils);

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var _co = require("co");

var co = _interopRequireWildcard(_co);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

// import "touchLog"
// import "touchShow"
// import "touches"

var _components = require("components");

var components = _interopRequireWildcard(_components);

Object.assign(window, { lu: lu, ra: _ra2.default, co: co, lodash: lodash });

window._ = {
	Buffer: Object.assign(Buffer, { parse: function parse(str) {
			var ret = [];
			str.replace(/\b\w\w?\b/g, function (x) {
				return ret.push(Number.parseInt("0x" + x));
			});
			return new Buffer(ret);
		} }),
	debug: function debug(f) {
		debugger;
		return f();
	}
};
new Promise(function (resolve) {
	resolve(require("netro/modem"));
}).then(function (m) {
	return window._.modem = m;
});
new Promise(function (resolve) {
	resolve(require("devdb"));
}).then(function (m) {
	return window._.devdb = m;
});
new Promise(function (resolve) {
	resolve(require("ra"));
}).then(function (m) {
	return window._.ra = m;
});
new Promise(function (resolve) {
	resolve(require("co"));
}).then(function (m) {
	return window._.co = m;
});

function preventDefault(event) {
	if (event.target && event.target.getAttribute("rel") == "external") return;
	var _arr = [window.HTMLInputElement, window.HTMLTextAreaElement, window.HTMLOptionElement, window.HTMLButtonElement];
	for (var _i = 0; _i < _arr.length; _i++) {
		var C = _arr[_i];
		if (event.target instanceof C) return;
	} // attempt to use native scrolling - unsuccessfull
	// let C = event.target
	// while ( C && C.classList ) {
	// 	if ( C.classList.contains( `scroll` ) )
	// 		return
	// 	C = C.parentNode
	// }
	event.preventDefault();
}

var _arr2 = ["touchstart", "touchmove", "touchend", "touchcancel"];
for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	var type = _arr2[_i2];
	window.addEventListener(type, preventDefault);
}var LOG = function LOG(str) {
	// if ( String( str ) == `undefined` )
	// 	debugger
	console.log.apply(console, arguments);
	window._ALERT && window._ALERT(str);
	var xhr = new XMLHttpRequest();
	xhr.open("POST", "/log?" + encodeURIComponent(str));
	xhr.onerror = lodash.noop;
	xhr.send();
	return str;
};
window.LOG = LOG;

window.addEventListener("error", function onError(e) {
	if (!e.message.match(404) && !onError.processing) {
		onError.processing = true;
		try {
			LOG(e.message.red + " at " + e.lineno + ":" + e.colno + " in " + e.filename);
		} finally {
			onError.processing = false;
		}
	}
});

var onerror = window.onerror;
window.onerror = function (message, url, line, column, error) {
	var ret = undefined;
	if (error) {
		LOG("stack: " + error.stack);
	}
	if (onerror) {
		try {
			window.onerror = onerror;
			ret = onerror.apply(this, arguments);
		} finally {
			onerror = window.onerror;
		}
	}
	return ret;
};
window.__ = components.createElement;

function script(text) {
	var script = document.createElement("script");
	script.appendChild(document.createTextNode(text));
	return script;
}

co.go(regeneratorRuntime.mark(function callee$0$0() {
	var html, data, tmp, children, i;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				html = window.cacheUrlResource("./main.html");
				context$1$0.next = 3;
				return html;

			case 3:
				html = context$1$0.sent;
				data = document.createDocumentFragment();
				tmp = document.createElement("div");

				tmp.innerHTML = html;
				tmp = tmp.children[0];
				children = [];

				for (i = 0; i < tmp.childNodes.length; ++i) {
					children.push(tmp.childNodes[i]);
				}children.forEach(function (c) {
					return tmp.removeChild(c);
				});
				children.forEach(function (c) {
					if (c instanceof HTMLScriptElement) c = script(c.innerHTML);
					data.appendChild(c);
				});

				document.body.appendChild(data);

			case 13:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
}));

// window.addEventListener( // TODO:   .      
// 	`message`,
// 	event => {
// 		if ( event && event.data && event.data.what == `urlResourceUpdated` )
// 			window.setTimeout(
// 				() => window.location.reload(),
// 				1000
// 			)
// 	},
// 	false
// )

}).call(this,require("buffer").Buffer)

},{"browser-nexttick":237,"buffer":215,"co":238,"colors":225,"components":240,"devdb":242,"gesture":244,"htmlpolyfill":245,"localUtils":249,"lodash":232,"netro/modem":251,"platform":254,"ra":255,"track":259}],279:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _uiMenu = require("ui/Menu");

var _uiMenu2 = _interopRequireDefault(_uiMenu);

var _uiCommand = require("ui/Command");

var _uiCommand2 = _interopRequireDefault(_uiCommand);

var _lodash = require("lodash");

var lodash = _interopRequireWildcard(_lodash);

exports.default = function (app) {
	var Menu = app.load(_uiMenu2.default);
	var Command = app.load(_uiCommand2.default);
	//TODO: check that exception is seen when changing app.getMessage( theme ) to getMessage( theme )
	//TODO:        ,   .
	return __(
		Menu,
		null,
		lodash.pairs(app.themes).map(function (_ref) {
			var _ref2 = _slicedToArray(_ref, 2);

			var name = _ref2[0];
			var theme = _ref2[1];
			return __(Command, {
				message: app.getMessage(theme.caption),
				onclick: function () {
					return app.themeName = name;
				}
			});
		})
	);
};

module.exports = exports.default;

},{"lodash":232,"ui/Command":268,"ui/Menu":272}],283:[function(require,module,exports){
(function (process,Buffer){
// Can not use https://www.npmjs.com/package/websocket-stream
// because it uses ws, which is not pure javascript

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var _stream = require("stream");

var _stream2 = _interopRequireDefault(_stream);

exports.default = function (websocket) {
	if (typeof websocket == "string") websocket = new WebSocket(websocket);
	// websocket.binaryType = `arraybuffer`
	function closeWebsocket() {
		websocket.close();
	}
	function setEvents() {
		websocket.onerror = onerror;
		websocket.onclose = onclose;
		websocket.onmessage = onmessage;
	}
	function onerror(event) {
		ret.emit("error", event);
		process.nextTick(closeWebsocket);
	}
	function onclose() {
		ret.push(null);
	}
	function onmessage(event) {
		ret.push(new Buffer(event.data));
	}
	function send(chunk, encoding, callback) {
		try {
			{
				var str = undefined;
				// convert to string if possible for debugging purpose
				// TODO: do this under condition of debug version or debugging
				if (typeof chunk != "string" && Buffer.compare(new Buffer(str = String(chunk)), new Buffer([].concat(_toConsumableArray(chunk)))) == 0) chunk = str;
			}
			websocket.send(chunk);
		} catch (error) {
			return callback(error);
		}
		callback();
	}
	function closed(callback) {
		callback(new Error("websocket is closed"));
	}
	var ret = new _stream2.default.Duplex({
		read: function read() {/* no-op */},
		write: function write(chunk, encoding, callback) {
			if (websocket.readyState == WebSocket.CONNECTING) {
				websocket.onclose = function (event) {
					onclose(event);
					closed(callback);
				};
				websocket.onerror = function (event) {
					callback(event);
				};
				websocket.onopen = function () {
					setEvents();
					send(chunk, encoding, callback);
				};
			} else if (websocket.readyState == WebSocket.OPEN) send(chunk, encoding, callback);else closed(callback);
		}
	});
	setEvents();
	ret.on("finish", closeWebsocket);
	return ret;
};

module.exports = exports.default;

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":192,"buffer":215,"stream":210}],285:[function(require,module,exports){
(function (global){
require( "webpage" )
require( "ui/OneApp" )
global.require = function r( name ) {
					global.require = null
					try {
						return require.apply( this, arguments )
					}
					finally {
						global.require = r
					}
				}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"ui/OneApp":273,"webpage":282}],284:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _ra = require("ra");

var _ra2 = _interopRequireDefault(_ra);

var windowSize = (0, _ra2.default)({
	width: 1,
	height: 1,
	ppmm: 1,
	widthmm: 1,
	heightmm: 1,
	pixelRatio: 1,
	orientation: 0,
	layout: "vertical",
	window: "browser"
}).setName("windowSize");

exports.default = windowSize;

window.addEventListener("resize", updateSize);

// let orientations = {}

var cm = document.createElement("div");
cm.style.left = "0";
cm.style.top = "0";
cm.style.width = "10cm";
cm.style.height = "10cm";
cm.style.position = "fixed";
cm.style.zIndex = "-9999";
document.body.appendChild(cm);
var ppmm = cm.clientWidth / 100;
document.body.removeChild(cm);

updateSize();

function updateSize() {

	var width = window.innerWidth;
	var height = window.innerHeight;

	var orientation = (window.orientation || 0) % 360;
	if (orientation < 0) orientation += 360;

	windowSize.width = width;
	windowSize.height = height;
	windowSize.ppmm = ppmm;
	windowSize.widthmm = width / ppmm;
	windowSize.heightmm = height / ppmm;
	windowSize.pixelRatio = window.devicePixelRatio || 1;
	windowSize.orientation = orientation;
	windowSize.layout = width <= height ? "vertical" : "horizontal";
	windowSize.window = window.navigator.standalone ? "app" : "browser";
}
module.exports = exports.default;

},{"ra":255}]},{},[186,285])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvSlNPTlN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9KU09OU3RyZWFtL25vZGVfbW9kdWxlcy9qc29ucGFyc2UvanNvbnBhcnNlLmpzIiwibm9kZV9tb2R1bGVzL0pTT05TdHJlYW0vbm9kZV9tb2R1bGVzL3Rocm91Z2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9saWIvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY29sbGVjdGlvbi10by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvcmUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY3R4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmRvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmZpeC1yZS13a3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZmxhZ3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmdldC1uYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaGFzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmhpZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pbnZva2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmlzLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLml0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmtleW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmxpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQubG9nMXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQubWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLm1peC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLm9iamVjdC10by1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5wYXJ0aWFsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnBhdGguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQucHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5yZWRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5yZXBsYWNlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zYW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnNldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnN0cmljdC1uZXcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnN0cmluZy1jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnN0cmluZy1wYWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc3RyaW5nLXJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdHJpbmctdHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdXBwb3J0LWRlc2MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudGFnLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnRhc2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudG8taW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC50by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnRvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC50by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudWlkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnVuc2NvcGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQud2tzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZ2V4cC5lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtbGVmdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtcmlnaHQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2pzLmFycmF5LnN0YXRpY3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbGlmeS9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLXN0cmluZy9jb2xvci1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29sb3Itc3RyaW5nL25vZGVfbW9kdWxlcy9jb2xvci1uYW1lL2luZGV4Lmpzb24iLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9jb2xvcnMuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9jdXN0b20vdHJhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL2N1c3RvbS96YWxnby5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL2V4dGVuZFN0cmluZ1Byb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvbWFwcy9hbWVyaWNhLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvbWFwcy9yYWluYm93LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvbWFwcy9yYW5kb20uanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9tYXBzL3plYnJhLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvc3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvc3lzdGVtL3N1cHBvcnRzLWNvbG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW5kZXguanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvRGFtZXJhdUxldmVuc2h0ZWluLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL0pTT05EdXBsZXguanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvSlNPTmxvY2FsLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2FwcC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9icm93c2VyLW5leHR0aWNrLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvbW1hbmRzLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvbXBvbmVudHMuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvZGJjYWNoZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9kZXZkYi5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9kaWZmLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2dlc3R1cmUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvaHRtbHBvbHlmaWxsLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2h0bWx1dGlscy5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9odHRwQ2xpZW50LmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2lzY3JvbGwuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvbG9jYWxVdGlscy5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9sb2cuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvbmV0cm8vbW9kZW0uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvbmV0cm8vbW9kZW1jcmMuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvcGluZ3BvbmdTdHJlYW0uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvcGxhdGZvcm0uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvcmEuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvc2YuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvc3BhcnNlcXVldWUuanMiLCJzcmMvdGhlbWVzLmpzb24iLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdHJhY2suanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQWRkRXhpc3RpbmdJdGVtLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL0FkZE1lbnUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQXBwbGljYXRpb24uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQXNrTmV3TmFtZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9Bc2tUb0xpbmtEZXZpY2UuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQmFja2dyb3VuZC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9Cb3R0b20uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQnV0dG9uLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL0NvbW1hbmQuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQ29udGV4dE1lbnUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvSWNvbi5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9NYWluU2NyZWVuLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL01lbnUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvT25lQXBwLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1BsYWNlLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1NlYXJjaEl0ZW1zLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1NlYXJjaFBpY3R1cmVzLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1NlcnZpY2VEaWFsb2cuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvU3RhcnR1cFNjcmVlbi5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9UaGVtZU1lbnUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvVG9wLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpZC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy93ZWJwYWdlLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3dlYnNvY2tldFN0cmVhbS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy93aW5kb3dTaXplLmpzIiwidG1wL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTs7QUNGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzb0JBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy83QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOURBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3L0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0dBQUE7RUFDN0QsQ0FBQTtDQUNEOztBQUVELENBQUMsQ0FBQSxTQUFTLEtBQUssR0FBRztBQUNqQixLQUNBLEdBQUcsR0FBRyxHQUFHLENBQUUsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUU7S0FDdEIsR0FBRyxHQUFHLEdBQUcsQ0FBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBRTtLQUN0QixHQUFHLEdBQUcsR0FBRyxDQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFFOzs7QUFFdEIsSUFBRyxHQUFHLEdBQUcsQ0FBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBRTtLQUN0QixHQUFHLEdBQUcsR0FBRyxDQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFFO0tBQ3RCLEdBQUcsR0FBRyxHQUFHLENBQUUsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUU7S0FDdEIsSUFBSSxHQUFHLEdBQUcsQ0FBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBRTtLQUN2QixFQUFFLEdBQUcsR0FBRyxDQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFFO0tBQ3JCLEVBQUUsR0FBRyxHQUFHLENBQUUsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUU7Ozs7O0FBSXJCLFNBQVEsR0FBRyxHQUFHLENBQUUsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFFO0tBQzlCLEVBQUUsR0FBRyxJQUFJLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRTtLQUNsQixFQUFFLEdBQUcsSUFBSSxDQUFFLENBQUMsR0FBRyxDQUFDLENBQUU7S0FDbEIsR0FBRyxHQUFHLElBQUksQ0FBRSxFQUFFLEdBQUcsQ0FBQyxDQUFFO0tBQ3BCLEdBQUcsR0FBRyxJQUFJLENBQUUsRUFBRSxHQUFHLENBQUMsQ0FBRTtLQUNwQixHQUFHLEdBQUcsSUFBSSxDQUFFLEVBQUUsR0FBRyxDQUFDLENBQUU7S0FDcEIsS0FBSyxHQUFHLElBQUksQ0FBRSxDQUFDLEdBQUcs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LFdBQVUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFVLG9CQUFvQixDQUFBO0NBQ25FOzs7OztBQ2xERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG5cbnZhciBQYXJzZXIgPSByZXF1aXJlKCdqc29ucGFyc2UnKVxuICAsIHRocm91Z2ggPSByZXF1aXJlKCd0aHJvdWdoJylcblxuLypcblxuICB0aGUgdmFsdWUgb2YgdGhpcy5zdGFjayB0aGF0IGNyZWF0aW9uaXgncyBqc29ucGFyc2UgaGFzIGlzIHdlaXJkLlxuXG4gIGl0IG1ha2VzIHRoaXMgY29kZSB1Z2x5LCBidXQgaGlzIHByb2JsZW0gaXMgd2F5IGhhcmRlciB0aGF0IG1pbmUsXG4gIHNvIGknbGwgZm9yZ2l2ZSBoaW0uXG5cbiovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAocGF0aCwgbWFwKSB7XG5cbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICB2YXIgc3RyZWFtID0gdGhyb3VnaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGNodW5rKVxuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rKVxuICAgIHBhcnNlci53cml0ZShjaHVuaylcbiAgfSxcbiAgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihkYXRhKVxuICAgICAgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgc3RyZWFtLnF1ZXVlKG51bGwpXG4gIH0pXG5cbiAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBwYXRoKVxuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZSA9PT0gJyonKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZWxzZSBpZiAoZSA9PT0gJycpIC8vICcuLicuc3BsaXQoJy4nKSByZXR1cm5zIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICByZXR1cm4ge3JlY3Vyc2U6IHRydWV9XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBlXG4gICAgfSlcblxuXG4gIHZhciBjb3VudCA9IDAsIF9rZXlcbiAgaWYoIXBhdGggfHwgIXBhdGgubGVuZ3RoKVxuICAgIHBhdGggPSBudWxsXG5cbiAgcGFyc2VyLm9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMucm9vdClcbiAgICAgIHN0cmVhbS5yb290ID0gdmFsdWVcblxuICAgIGlmKCEgcGF0aCkgcmV0dXJuXG5cbiAgICB2YXIgaSA9IDAgLy8gaXRlcmF0ZXMgb24gcGF0aFxuICAgIHZhciBqICA9IDAgLy8gaXRlcmF0ZXMgb24gc3RhY2tcbiAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpXVxuICAgICAgdmFyIGNcbiAgICAgIGorK1xuXG4gICAgICBpZiAoa2V5ICYmICFrZXkucmVjdXJzZSkge1xuICAgICAgICBjID0gKGogPT09IHRoaXMuc3RhY2subGVuZ3RoKSA/IHRoaXMgOiB0aGlzLnN0YWNrW2pdXG4gICAgICAgIGlmICghYykgcmV0dXJuXG4gICAgICAgIGlmICghIGNoZWNrKGtleSwgYy5rZXkpKSByZXR1cm5cbiAgICAgICAgaSsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKytcbiAgICAgICAgdmFyIG5leHRLZXkgPSBwYXRoW2ldXG4gICAgICAgIGlmICghIG5leHRLZXkpIHJldHVyblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGMgPSAoaiA9PT0gdGhpcy5zdGFjay5sZW5ndGgpID8gdGhpcyA6IHRoaXMuc3RhY2tbal1cbiAgICAgICAgICBpZiAoIWMpIHJldHVyblxuICAgICAgICAgIGlmIChjaGVjayhuZXh0S2V5LCBjLmtleSkpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIHRoaXMuc3RhY2tbal0udmFsdWUgPSBudWxsXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBqKytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICAgIGlmIChqICE9PSB0aGlzLnN0YWNrLmxlbmd0aCkgcmV0dXJuXG5cbiAgICBjb3VudCArK1xuICAgIHZhciBhY3R1YWxQYXRoID0gdGhpcy5zdGFjay5zbGljZSgxKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5rZXkgfSkuY29uY2F0KFt0aGlzLmtleV0pXG4gICAgdmFyIGRhdGEgPSB0aGlzLnZhbHVlW3RoaXMua2V5XVxuICAgIGlmKG51bGwgIT0gZGF0YSlcbiAgICAgIGlmKG51bGwgIT0gKGRhdGEgPSBtYXAgPyBtYXAoZGF0YSwgYWN0dWFsUGF0aCkgOiBkYXRhKSlcbiAgICAgICAgc3RyZWFtLnF1ZXVlKGRhdGEpXG4gICAgZGVsZXRlIHRoaXMudmFsdWVbdGhpcy5rZXldXG4gICAgZm9yKHZhciBrIGluIHRoaXMuc3RhY2spXG4gICAgICB0aGlzLnN0YWNrW2tdLnZhbHVlID0gbnVsbFxuICB9XG4gIHBhcnNlci5fb25Ub2tlbiA9IHBhcnNlci5vblRva2VuO1xuXG4gIHBhcnNlci5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAgIHBhcnNlci5fb25Ub2tlbih0b2tlbiwgdmFsdWUpO1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHN0cmVhbS5yb290KSB7XG4gICAgICAgIGlmKCFwYXRoKVxuICAgICAgICAgIHN0cmVhbS5xdWV1ZShzdHJlYW0ucm9vdClcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICBzdHJlYW0ucm9vdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwYXJzZXIub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZihlcnIubWVzc2FnZS5pbmRleE9mKFwiYXQgcG9zaXRpb25cIikgPiAtMSlcbiAgICAgIGVyci5tZXNzYWdlID0gXCJJbnZhbGlkIEpTT04gKFwiICsgZXJyLm1lc3NhZ2UgKyBcIilcIjtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cblxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxuZnVuY3Rpb24gY2hlY2sgKHgsIHkpIHtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgeClcbiAgICByZXR1cm4geSA9PSB4XG4gIGVsc2UgaWYgKHggJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHguZXhlYylcbiAgICByZXR1cm4geC5leGVjKHkpXG4gIGVsc2UgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHgpXG4gICAgcmV0dXJuIHhcbiAgZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHgpXG4gICAgcmV0dXJuIHgoeSlcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9wLCBzZXAsIGNsLCBpbmRlbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDBcbiAgaWYgKG9wID09PSBmYWxzZSl7XG4gICAgb3AgPSAnJ1xuICAgIHNlcCA9ICdcXG4nXG4gICAgY2wgPSAnJ1xuICB9IGVsc2UgaWYgKG9wID09IG51bGwpIHtcblxuICAgIG9wID0gJ1tcXG4nXG4gICAgc2VwID0gJ1xcbixcXG4nXG4gICAgY2wgPSAnXFxuXVxcbidcblxuICB9XG5cbiAgLy9lbHNlLCB3aGF0IGV2ZXIgeW91IGxpa2VcblxuICB2YXIgc3RyZWFtXG4gICAgLCBmaXJzdCA9IHRydWVcbiAgICAsIGFueURhdGEgPSBmYWxzZVxuICBzdHJlYW0gPSB0aHJvdWdoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgYW55RGF0YSA9IHRydWVcbiAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIGluZGVudClcbiAgICBpZihmaXJzdCkgeyBmaXJzdCA9IGZhbHNlIDsgc3RyZWFtLnF1ZXVlKG9wICsganNvbil9XG4gICAgZWxzZSBzdHJlYW0ucXVldWUoc2VwICsganNvbilcbiAgfSxcbiAgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZighYW55RGF0YSlcbiAgICAgIHN0cmVhbS5xdWV1ZShvcClcbiAgICBzdHJlYW0ucXVldWUoY2wpXG4gICAgc3RyZWFtLnF1ZXVlKG51bGwpXG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5leHBvcnRzLnN0cmluZ2lmeU9iamVjdCA9IGZ1bmN0aW9uIChvcCwgc2VwLCBjbCwgaW5kZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAwXG4gIGlmIChvcCA9PT0gZmFsc2Upe1xuICAgIG9wID0gJydcbiAgICBzZXAgPSAnXFxuJ1xuICAgIGNsID0gJydcbiAgfSBlbHNlIGlmIChvcCA9PSBudWxsKSB7XG5cbiAgICBvcCA9ICd7XFxuJ1xuICAgIHNlcCA9ICdcXG4sXFxuJ1xuICAgIGNsID0gJ1xcbn1cXG4nXG5cbiAgfVxuXG4gIC8vZWxzZSwgd2hhdCBldmVyIHlvdSBsaWtlXG5cbiAgdmFyIGZpcnN0ID0gdHJ1ZVxuICAgICwgYW55RGF0YSA9IGZhbHNlXG4gIHN0cmVhbSA9IHRocm91Z2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBhbnlEYXRhID0gdHJ1ZVxuICAgIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YVswXSkgKyAnOicgKyBKU09OLnN0cmluZ2lmeShkYXRhWzFdLCBudWxsLCBpbmRlbnQpXG4gICAgaWYoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZSA7IHRoaXMucXVldWUob3AgKyBqc29uKX1cbiAgICBlbHNlIHRoaXMucXVldWUoc2VwICsganNvbilcbiAgfSxcbiAgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZighYW55RGF0YSkgdGhpcy5xdWV1ZShvcClcbiAgICB0aGlzLnF1ZXVlKGNsKVxuXG4gICAgdGhpcy5xdWV1ZShudWxsKVxuICB9KVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxuaWYoIW1vZHVsZS5wYXJlbnQgJiYgcHJvY2Vzcy50aXRsZSAhPT0gJ2Jyb3dzZXInKSB7XG4gIHByb2Nlc3Muc3RkaW5cbiAgICAucGlwZShleHBvcnRzLnBhcnNlKHByb2Nlc3MuYXJndlsyXSkpXG4gICAgLnBpcGUoZXhwb3J0cy5zdHJpbmdpZnkoJ1snLCAnLFxcbicsICddXFxuJywgMikpXG4gICAgLnBpcGUocHJvY2Vzcy5zdGRvdXQpXG59XG4iLCIvKmdsb2JhbCBCdWZmZXIqL1xuLy8gTmFtZWQgY29uc3RhbnRzIHdpdGggdW5pcXVlIGludGVnZXIgdmFsdWVzXG52YXIgQyA9IHt9O1xuLy8gVG9rZW5zXG52YXIgTEVGVF9CUkFDRSAgICA9IEMuTEVGVF9CUkFDRSAgICA9IDB4MTtcbnZhciBSSUdIVF9CUkFDRSAgID0gQy5SSUdIVF9CUkFDRSAgID0gMHgyO1xudmFyIExFRlRfQlJBQ0tFVCAgPSBDLkxFRlRfQlJBQ0tFVCAgPSAweDM7XG52YXIgUklHSFRfQlJBQ0tFVCA9IEMuUklHSFRfQlJBQ0tFVCA9IDB4NDtcbnZhciBDT0xPTiAgICAgICAgID0gQy5DT0xPTiAgICAgICAgID0gMHg1O1xudmFyIENPTU1BICAgICAgICAgPSBDLkNPTU1BICAgICAgICAgPSAweDY7XG52YXIgVFJVRSAgICAgICAgICA9IEMuVFJVRSAgICAgICAgICA9IDB4NztcbnZhciBGQUxTRSAgICAgICAgID0gQy5GQUxTRSAgICAgICAgID0gMHg4O1xudmFyIE5VTEwgICAgICAgICAgPSBDLk5VTEwgICAgICAgICAgPSAweDk7XG52YXIgU1RSSU5HICAgICAgICA9IEMuU1RSSU5HICAgICAgICA9IDB4YTtcbnZhciBOVU1CRVIgICAgICAgID0gQy5OVU1CRVIgICAgICAgID0gMHhiO1xuLy8gVG9rZW5pemVyIFN0YXRlc1xudmFyIFNUQVJUICAgPSBDLlNUQVJUICAgPSAweDExO1xudmFyIFNUT1AgICAgPSBDLlNUT1AgICAgPSAweDEyO1xudmFyIFRSVUUxICAgPSBDLlRSVUUxICAgPSAweDIxO1xudmFyIFRSVUUyICAgPSBDLlRSVUUyICAgPSAweDIyO1xudmFyIFRSVUUzICAgPSBDLlRSVUUzICAgPSAweDIzO1xudmFyIEZBTFNFMSAgPSBDLkZBTFNFMSAgPSAweDMxO1xudmFyIEZBTFNFMiAgPSBDLkZBTFNFMiAgPSAweDMyO1xudmFyIEZBTFNFMyAgPSBDLkZBTFNFMyAgPSAweDMzO1xudmFyIEZBTFNFNCAgPSBDLkZBTFNFNCAgPSAweDM0O1xudmFyIE5VTEwxICAgPSBDLk5VTEwxICAgPSAweDQxO1xudmFyIE5VTEwyICAgPSBDLk5VTEwyICAgPSAweDQyO1xudmFyIE5VTEwzICAgPSBDLk5VTEwzICAgPSAweDQzO1xudmFyIE5VTUJFUjEgPSBDLk5VTUJFUjEgPSAweDUxO1xudmFyIE5VTUJFUjIgPSBDLk5VTUJFUjIgPSAweDUyO1xudmFyIE5VTUJFUjMgPSBDLk5VTUJFUjMgPSAweDUzO1xudmFyIE5VTUJFUjQgPSBDLk5VTUJFUjQgPSAweDU0O1xudmFyIE5VTUJFUjUgPSBDLk5VTUJFUjUgPSAweDU1O1xudmFyIE5VTUJFUjYgPSBDLk5VTUJFUjYgPSAweDU2O1xudmFyIE5VTUJFUjcgPSBDLk5VTUJFUjcgPSAweDU3O1xudmFyIE5VTUJFUjggPSBDLk5VTUJFUjggPSAweDU4O1xudmFyIFNUUklORzEgPSBDLlNUUklORzEgPSAweDYxO1xudmFyIFNUUklORzIgPSBDLlNUUklORzIgPSAweDYyO1xudmFyIFNUUklORzMgPSBDLlNUUklORzMgPSAweDYzO1xudmFyIFNUUklORzQgPSBDLlNUUklORzQgPSAweDY0O1xudmFyIFNUUklORzUgPSBDLlNUUklORzUgPSAweDY1O1xudmFyIFNUUklORzYgPSBDLlNUUklORzYgPSAweDY2O1xuLy8gUGFyc2VyIFN0YXRlc1xudmFyIFZBTFVFICAgPSBDLlZBTFVFICAgPSAweDcxO1xudmFyIEtFWSAgICAgPSBDLktFWSAgICAgPSAweDcyO1xuLy8gUGFyc2VyIE1vZGVzXG52YXIgT0JKRUNUICA9IEMuT0JKRUNUICA9IDB4ODE7XG52YXIgQVJSQVkgICA9IEMuQVJSQVkgICA9IDB4ODI7XG5cblxuZnVuY3Rpb24gUGFyc2VyKCkge1xuICB0aGlzLnRTdGF0ZSA9IFNUQVJUO1xuICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHRoaXMuc3RyaW5nID0gdW5kZWZpbmVkOyAvLyBzdHJpbmcgZGF0YVxuICB0aGlzLnVuaWNvZGUgPSB1bmRlZmluZWQ7IC8vIHVuaWNvZGUgZXNjYXBlc1xuXG4gIC8vIEZvciBudW1iZXIgcGFyc2luZ1xuICB0aGlzLm5lZ2F0aXZlID0gdW5kZWZpbmVkO1xuICB0aGlzLm1hZ25hdHVkZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5leHBvbmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5uZWdhdGl2ZUV4cG9uZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLm51bWJlckxlbmd0aCA9IDA7XG4gIFxuICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5tb2RlID0gdW5kZWZpbmVkO1xuICB0aGlzLnN0YWNrID0gW107XG4gIHRoaXMuc3RhdGUgPSBWQUxVRTtcbiAgdGhpcy5ieXRlc19yZW1haW5pbmcgPSAwOyAvLyBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGluIG11bHRpIGJ5dGUgdXRmOCBjaGFyIHRvIHJlYWQgYWZ0ZXIgc3BsaXQgYm91bmRhcnlcbiAgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IDA7IC8vIGJ5dGVzIGluIG11bHRpIGJ5dGUgdXRmOCBjaGFyIHRvIHJlYWRcbiAgdGhpcy50ZW1wX2J1ZmZzID0geyBcIjJcIjogbmV3IEJ1ZmZlcigyKSwgXCIzXCI6IG5ldyBCdWZmZXIoMyksIFwiNFwiOiBuZXcgQnVmZmVyKDQpIH07IC8vIGZvciByZWJ1aWxkaW5nIGNoYXJzIHNwbGl0IGJlZm9yZSBib3VuZGFyeSBpcyByZWFjaGVkXG5cbiAgLy8gU3RyZWFtIG9mZnNldFxuICB0aGlzLm9mZnNldCA9IC0xO1xufVxuXG4vLyBTbG93IGNvZGUgdG8gc3RyaW5nIGNvbnZlcnRlciAob25seSB1c2VkIHdoZW4gdGhyb3dpbmcgc3ludGF4IGVycm9ycylcblBhcnNlci50b2tuYW0gPSBmdW5jdGlvbiAoY29kZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKEMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKENba2V5XSA9PT0gY29kZSkgeyByZXR1cm4ga2V5OyB9XG4gIH1cbiAgcmV0dXJuIGNvZGUgJiYgKFwiMHhcIiArIGNvZGUudG9TdHJpbmcoMTYpKTtcbn1cblxudmFyIHByb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcbnByb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfTtcbnByb3RvLmNoYXJFcnJvciA9IGZ1bmN0aW9uIChidWZmZXIsIGkpIHtcbiAgdGhpcy50U3RhdGUgPSBTVE9QO1xuICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIEpTT04uc3RyaW5naWZ5KFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyW2ldKSkgKyBcIiBhdCBwb3NpdGlvbiBcIiArIGkgKyBcIiBpbiBzdGF0ZSBcIiArIFBhcnNlci50b2tuYW0odGhpcy50U3RhdGUpKSk7XG59O1xucHJvdG8ud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSBcInN0cmluZ1wiKSBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gIHZhciBuO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGhpcy50U3RhdGUgPT09IFNUQVJUKXtcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgaWYobiA9PT0gMHg3Yil7IHRoaXMub25Ub2tlbihMRUZUX0JSQUNFLCBcIntcIik7IC8vIHtcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4N2QpeyB0aGlzLm9uVG9rZW4oUklHSFRfQlJBQ0UsIFwifVwiKTsgLy8gfVxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg1Yil7IHRoaXMub25Ub2tlbihMRUZUX0JSQUNLRVQsIFwiW1wiKTsgLy8gW1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg1ZCl7IHRoaXMub25Ub2tlbihSSUdIVF9CUkFDS0VULCBcIl1cIik7IC8vIF1cbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4M2EpeyB0aGlzLm9uVG9rZW4oQ09MT04sIFwiOlwiKTsgIC8vIDpcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4MmMpeyB0aGlzLm9uVG9rZW4oQ09NTUEsIFwiLFwiKTsgLy8gLFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg3NCl7IHRoaXMudFN0YXRlID0gVFJVRTE7ICAvLyB0XG4gICAgICB9ZWxzZSBpZihuID09PSAweDY2KXsgdGhpcy50U3RhdGUgPSBGQUxTRTE7ICAvLyBmXG4gICAgICB9ZWxzZSBpZihuID09PSAweDZlKXsgdGhpcy50U3RhdGUgPSBOVUxMMTsgLy8gblxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgyMil7IHRoaXMuc3RyaW5nID0gXCJcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyAvLyBcIlxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgyZCl7IHRoaXMubmVnYXRpdmUgPSB0cnVlOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjE7IC8vIC1cbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4MzApeyB0aGlzLm1hZ25hdHVkZSA9IDA7IHRoaXMudFN0YXRlID0gTlVNQkVSMjsgLy8gMFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmIChuID4gMHgzMCAmJiBuIDwgMHg0MCkgeyAvLyAxLTlcbiAgICAgICAgICB0aGlzLm1hZ25hdHVkZSA9IG4gLSAweDMwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjM7XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMHgyMCB8fCBuID09PSAweDA5IHx8IG4gPT09IDB4MGEgfHwgbiA9PT0gMHgwZCkge1xuICAgICAgICAgIC8vIHdoaXRlc3BhY2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBTVFJJTkcxKXsgLy8gQWZ0ZXIgb3BlbiBxdW90ZVxuICAgICAgbiA9IGJ1ZmZlcltpXTsgLy8gZ2V0IGN1cnJlbnQgYnl0ZSBmcm9tIGJ1ZmZlclxuICAgICAgLy8gY2hlY2sgZm9yIGNhcnJ5IG92ZXIgb2YgYSBtdWx0aSBieXRlIGNoYXIgc3BsaXQgYmV0d2VlbiBkYXRhIGNodW5rc1xuICAgICAgLy8gJiBmaWxsIHRlbXAgYnVmZmVyIGl0IHdpdGggc3RhcnQgb2YgdGhpcyBkYXRhIGNodW5rIHVwIHRvIHRoZSBib3VuZGFyeSBsaW1pdCBzZXQgaW4gdGhlIGxhc3QgaXRlcmF0aW9uXG4gICAgICBpZiAodGhpcy5ieXRlc19yZW1haW5pbmcgPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5ieXRlc19yZW1haW5pbmc7IGorKykge1xuICAgICAgICAgIHRoaXMudGVtcF9idWZmc1t0aGlzLmJ5dGVzX2luX3NlcXVlbmNlXVt0aGlzLmJ5dGVzX2luX3NlcXVlbmNlIC0gdGhpcy5ieXRlc19yZW1haW5pbmcgKyBqXSA9IGJ1ZmZlcltqXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmluZyArPSB0aGlzLnRlbXBfYnVmZnNbdGhpcy5ieXRlc19pbl9zZXF1ZW5jZV0udG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IHRoaXMuYnl0ZXNfcmVtYWluaW5nID0gMDtcbiAgICAgICAgaSA9IGkgKyBqIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc19yZW1haW5pbmcgPT09IDAgJiYgbiA+PSAxMjgpIHsgLy8gZWxzZSBpZiBubyByZW1haW5kZXIgYnl0ZXMgY2FycmllZCBvdmVyLCBwYXJzZSBtdWx0aSBieXRlICg+PTEyOCkgY2hhcnMgb25lIGF0IGEgdGltZVxuICAgICAgICBpZiAobiA8PSAxOTMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcIkludmFsaWQgVVRGLTggY2hhcmFjdGVyIGF0IHBvc2l0aW9uIFwiICsgaSArIFwiIGluIHN0YXRlIFwiICsgUGFyc2VyLnRva25hbSh0aGlzLnRTdGF0ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG4gPj0gMTk0KSAmJiAobiA8PSAyMjMpKSB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gMjtcbiAgICAgICAgaWYgKChuID49IDIyNCkgJiYgKG4gPD0gMjM5KSkgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IDM7XG4gICAgICAgIGlmICgobiA+PSAyNDApICYmIChuIDw9IDI0NCkpIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSA0O1xuICAgICAgICBpZiAoKHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgKyBpKSA+IGJ1ZmZlci5sZW5ndGgpIHsgLy8gaWYgYnl0ZXMgbmVlZGVkIHRvIGNvbXBsZXRlIGNoYXIgZmFsbCBvdXRzaWRlIGJ1ZmZlciBsZW5ndGgsIHdlIGhhdmUgYSBib3VuZGFyeSBzcGxpdFxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDw9IChidWZmZXIubGVuZ3RoIC0gMSAtIGkpOyBrKyspIHtcbiAgICAgICAgICAgIHRoaXMudGVtcF9idWZmc1t0aGlzLmJ5dGVzX2luX3NlcXVlbmNlXVtrXSA9IGJ1ZmZlcltpICsga107IC8vIGZpbGwgdGVtcCBidWZmZXIgb2YgY29ycmVjdCBzaXplIHdpdGggYnl0ZXMgYXZhaWxhYmxlIGluIHRoaXMgY2h1bmtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ieXRlc19yZW1haW5pbmcgPSAoaSArIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UpIC0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICBpID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdHJpbmcgKz0gYnVmZmVyLnNsaWNlKGksIChpICsgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaSA9IGkgKyB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlIC0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuID09PSAweDIyKSB7IHRoaXMudFN0YXRlID0gU1RBUlQ7IHRoaXMub25Ub2tlbihTVFJJTkcsIHRoaXMuc3RyaW5nKTsgdGhpcy5vZmZzZXQgKz0gQnVmZmVyLmJ5dGVMZW5ndGgodGhpcy5zdHJpbmcsICd1dGY4JykgKyAxOyB0aGlzLnN0cmluZyA9IHVuZGVmaW5lZDsgfVxuICAgICAgZWxzZSBpZiAobiA9PT0gMHg1YykgeyB0aGlzLnRTdGF0ZSA9IFNUUklORzI7IH1cbiAgICAgIGVsc2UgaWYgKG4gPj0gMHgyMCkgeyB0aGlzLnN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pOyB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFNUUklORzIpeyAvLyBBZnRlciBiYWNrc2xhc2hcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZihuID09PSAweDIyKXsgdGhpcy5zdHJpbmcgKz0gXCJcXFwiXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NWMpeyB0aGlzLnN0cmluZyArPSBcIlxcXFxcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4MmYpeyB0aGlzLnN0cmluZyArPSBcIlxcL1wiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2Mil7IHRoaXMuc3RyaW5nICs9IFwiXFxiXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDY2KXsgdGhpcy5zdHJpbmcgKz0gXCJcXGZcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NmUpeyB0aGlzLnN0cmluZyArPSBcIlxcblwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg3Mil7IHRoaXMuc3RyaW5nICs9IFwiXFxyXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDc0KXsgdGhpcy5zdHJpbmcgKz0gXCJcXHRcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NzUpeyB0aGlzLnVuaWNvZGUgPSBcIlwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzM7XG4gICAgICB9ZWxzZXsgXG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyBcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFNUUklORzMgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzQgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzUgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzYpeyAvLyB1bmljb2RlIGhleCBjb2Rlc1xuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIC8vIDAtOSBBLUYgYS1mXG4gICAgICBpZiAoKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgfHwgKG4gPiAweDQwICYmIG4gPD0gMHg0NikgfHwgKG4gPiAweDYwICYmIG4gPD0gMHg2NikpIHtcbiAgICAgICAgdGhpcy51bmljb2RlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG4gICAgICAgIGlmICh0aGlzLnRTdGF0ZSsrID09PSBTVFJJTkc2KSB7XG4gICAgICAgICAgdGhpcy5zdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh0aGlzLnVuaWNvZGUsIDE2KSk7XG4gICAgICAgICAgdGhpcy51bmljb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpO1xuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSMSl7IC8vIGFmdGVyIG1pbnVzXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgdGhpcy5udW1iZXJMZW5ndGgrKztcbiAgICAgIGlmIChuID09PSAweDMwKSB7IHRoaXMubWFnbmF0dWRlID0gMDsgdGhpcy50U3RhdGUgPSBOVU1CRVIyOyB9XG4gICAgICBlbHNlIGlmIChuID4gMHgzMCAmJiBuIDwgMHg0MCkgeyB0aGlzLm1hZ25hdHVkZSA9IG4gLSAweDMwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjM7IH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpO1xuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSMil7IC8vICogQWZ0ZXIgaW5pdGlhbCB6ZXJvXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgdGhpcy5udW1iZXJMZW5ndGgrKztcbiAgICAgIGlmKG4gPT09IDB4MmUpeyAvLyAuXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwLjE7IHRoaXMudFN0YXRlID0gTlVNQkVSNDtcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NjUgfHwgIG4gPT09IDB4NDUpeyAvLyBlL0VcbiAgICAgICAgdGhpcy5leHBvbmVudCA9IDA7IHRoaXMudFN0YXRlID0gTlVNQkVSNjtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUQVJUO1xuICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCAwKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5udW1iZXJMZW5ndGggLSAxO1xuICAgICAgICB0aGlzLm51bWJlckxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVIzKXsgLy8gKiBBZnRlciBkaWdpdCAoYmVmb3JlIHBlcmlvZClcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICB0aGlzLm51bWJlckxlbmd0aCsrO1xuICAgICAgaWYobiA9PT0gMHgyZSl7IC8vIC5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDAuMTsgdGhpcy50U3RhdGUgPSBOVU1CRVI0O1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2NSB8fCBuID09PSAweDQ1KXsgLy8gZS9FXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSAwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjY7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgeyB0aGlzLm1hZ25hdHVkZSA9IHRoaXMubWFnbmF0dWRlICogMTAgKyBuIC0gMHgzMDsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUQVJUOyBcbiAgICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSAtdGhpcy5tYWduYXR1ZGU7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCB0aGlzLm1hZ25hdHVkZSk7IFxuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHRoaXMubnVtYmVyTGVuZ3RoIC0gMTtcbiAgICAgICAgICB0aGlzLm51bWJlckxlbmd0aCA9IDA7XG4gICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVI0KXsgLy8gQWZ0ZXIgcGVyaW9kXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgdGhpcy5udW1iZXJMZW5ndGgrKztcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMubWFnbmF0dWRlICs9IHRoaXMucG9zaXRpb24gKiAobiAtIDB4MzApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uIC89IDEwO1xuICAgICAgICB0aGlzLnRTdGF0ZSA9IE5VTUJFUjU7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTUJFUjUpeyAvLyAqIEFmdGVyIGRpZ2l0IChhZnRlciBwZXJpb2QpXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgdGhpcy5udW1iZXJMZW5ndGgrKztcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMubWFnbmF0dWRlICs9IHRoaXMucG9zaXRpb24gKiAobiAtIDB4MzApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uIC89IDEwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobiA9PT0gMHg2NSB8fCBuID09PSAweDQ1KSB7IHRoaXMuZXhwb25lbnQgPSAwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjY7IH0gLy8gRS9lXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy50U3RhdGUgPSBTVEFSVDsgXG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSAtdGhpcy5tYWduYXR1ZGU7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCB0aGlzLm5lZ2F0aXZlID8gLXRoaXMubWFnbmF0dWRlIDogdGhpcy5tYWduYXR1ZGUpOyBcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5udW1iZXJMZW5ndGggLSAxO1xuICAgICAgICB0aGlzLm51bWJlckxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpLS07IFxuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNil7IC8vIEFmdGVyIEVcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICB0aGlzLm51bWJlckxlbmd0aCsrO1xuICAgICAgaWYgKG4gPT09IDB4MmIgfHwgbiA9PT0gMHgyZCkgeyAvLyArLy1cbiAgICAgICAgaWYgKG4gPT09IDB4MmQpIHsgdGhpcy5uZWdhdGl2ZUV4cG9uZW50ID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLnRTdGF0ZSA9IE5VTUJFUjc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHtcbiAgICAgICAgdGhpcy5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQgKiAxMCArIChuIC0gMHgzMCk7XG4gICAgICAgIHRoaXMudFN0YXRlID0gTlVNQkVSODtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpO1xuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNyl7IC8vIEFmdGVyICsvLVxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIHRoaXMubnVtYmVyTGVuZ3RoKys7XG4gICAgICBpZiAobiA+PSAweDMwICYmIG4gPCAweDQwKSB7IC8vIDAtOVxuICAgICAgICB0aGlzLmV4cG9uZW50ID0gdGhpcy5leHBvbmVudCAqIDEwICsgKG4gLSAweDMwKTtcbiAgICAgICAgdGhpcy50U3RhdGUgPSBOVU1CRVI4O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVI4KXsgLy8gKiBBZnRlciBkaWdpdCAoYWZ0ZXIgKy8tKVxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIHRoaXMubnVtYmVyTGVuZ3RoKys7XG4gICAgICBpZiAobiA+PSAweDMwICYmIG4gPCAweDQwKSB7IC8vIDAtOVxuICAgICAgICB0aGlzLmV4cG9uZW50ID0gdGhpcy5leHBvbmVudCAqIDEwICsgKG4gLSAweDMwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZUV4cG9uZW50KSB7XG4gICAgICAgICAgdGhpcy5leHBvbmVudCA9IC10aGlzLmV4cG9uZW50O1xuICAgICAgICAgIHRoaXMubmVnYXRpdmVFeHBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hZ25hdHVkZSAqPSBNYXRoLnBvdygxMCwgdGhpcy5leHBvbmVudCk7XG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlKSB7IFxuICAgICAgICAgIHRoaXMubWFnbmF0dWRlID0gLXRoaXMubWFnbmF0dWRlO1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50U3RhdGUgPSBTVEFSVDtcbiAgICAgICAgdGhpcy5vblRva2VuKE5VTUJFUiwgdGhpcy5tYWduYXR1ZGUpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLm51bWJlckxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubnVtYmVyTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGktLTsgXG4gICAgICB9IFxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gVFJVRTEpeyAvLyByXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDcyKSB7IHRoaXMudFN0YXRlID0gVFJVRTI7IH1cbiAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gVFJVRTIpeyAvLyB1XG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDc1KSB7IHRoaXMudFN0YXRlID0gVFJVRTM7IH1cbiAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gVFJVRTMpeyAvLyBlXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDY1KSB7IHRoaXMudFN0YXRlID0gU1RBUlQ7IHRoaXMub25Ub2tlbihUUlVFLCB0cnVlKTsgdGhpcy5vZmZzZXQrPSAzOyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IEZBTFNFMSl7IC8vIGFcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NjEpIHsgdGhpcy50U3RhdGUgPSBGQUxTRTI7IH1cbiAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0UyKXsgLy8gbFxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2YykgeyB0aGlzLnRTdGF0ZSA9IEZBTFNFMzsgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBGQUxTRTMpeyAvLyBzXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDczKSB7IHRoaXMudFN0YXRlID0gRkFMU0U0OyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IEZBTFNFNCl7IC8vIGVcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NjUpIHsgdGhpcy50U3RhdGUgPSBTVEFSVDsgdGhpcy5vblRva2VuKEZBTFNFLCBmYWxzZSk7IHRoaXMub2Zmc2V0Kz0gNDsgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVUxMMSl7IC8vIHVcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NzUpIHsgdGhpcy50U3RhdGUgPSBOVUxMMjsgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVUxMMil7IC8vIGxcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBOVUxMMzsgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVUxMMyl7IC8vIGxcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBTVEFSVDsgdGhpcy5vblRva2VuKE5VTEwsIG51bGwpOyB0aGlzLm9mZnNldCArPSAzOyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9XG4gIH1cbn07XG5wcm90by5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAvLyBPdmVycmlkZSB0aGlzIHRvIGdldCBldmVudHNcbn07XG5cbnByb3RvLnBhcnNlRXJyb3IgPSBmdW5jdGlvbiAodG9rZW4sIHZhbHVlKSB7XG4gIHRoaXMudFN0YXRlID0gU1RPUDtcbiAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBQYXJzZXIudG9rbmFtKHRva2VuKSArICh2YWx1ZSA/IChcIihcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArIFwiKVwiKSA6IFwiXCIpICsgXCIgaW4gc3RhdGUgXCIgKyBQYXJzZXIudG9rbmFtKHRoaXMuc3RhdGUpKSk7XG59O1xucHJvdG8ucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdGFjay5wdXNoKHt2YWx1ZTogdGhpcy52YWx1ZSwga2V5OiB0aGlzLmtleSwgbW9kZTogdGhpcy5tb2RlfSk7XG59O1xucHJvdG8ucG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICB2YXIgcGFyZW50ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgdGhpcy52YWx1ZSA9IHBhcmVudC52YWx1ZTtcbiAgdGhpcy5rZXkgPSBwYXJlbnQua2V5O1xuICB0aGlzLm1vZGUgPSBwYXJlbnQubW9kZTtcbiAgdGhpcy5lbWl0KHZhbHVlKTtcbiAgaWYgKCF0aGlzLm1vZGUpIHsgdGhpcy5zdGF0ZSA9IFZBTFVFOyB9XG59O1xucHJvdG8uZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodGhpcy5tb2RlKSB7IHRoaXMuc3RhdGUgPSBDT01NQTsgfVxuICB0aGlzLm9uVmFsdWUodmFsdWUpO1xufTtcbnByb3RvLm9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLy8gT3ZlcnJpZGUgbWVcbn07ICBcbnByb3RvLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbHVlKSB7XG4gIGlmKHRoaXMuc3RhdGUgPT09IFZBTFVFKXtcbiAgICBpZih0b2tlbiA9PT0gU1RSSU5HIHx8IHRva2VuID09PSBOVU1CRVIgfHwgdG9rZW4gPT09IFRSVUUgfHwgdG9rZW4gPT09IEZBTFNFIHx8IHRva2VuID09PSBOVUxMKXtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVbdGhpcy5rZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQodmFsdWUpOyAgXG4gICAgfWVsc2UgaWYodG9rZW4gPT09IExFRlRfQlJBQ0Upe1xuICAgICAgdGhpcy5wdXNoKCk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0aGlzLmtleV0gPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zdGF0ZSA9IEtFWTtcbiAgICAgIHRoaXMubW9kZSA9IE9CSkVDVDtcbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gTEVGVF9CUkFDS0VUKXtcbiAgICAgIHRoaXMucHVzaCgpO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWVbdGhpcy5rZXldID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmtleSA9IDA7XG4gICAgICB0aGlzLm1vZGUgPSBBUlJBWTtcbiAgICAgIHRoaXMuc3RhdGUgPSBWQUxVRTtcbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gUklHSFRfQlJBQ0Upe1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7XG4gICAgICAgIHRoaXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWVsc2UgaWYodG9rZW4gPT09IFJJR0hUX0JSQUNLRVQpe1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gQVJSQVkpIHtcbiAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICB9XG4gIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT09IEtFWSl7XG4gICAgaWYgKHRva2VuID09PSBTVFJJTkcpIHtcbiAgICAgIHRoaXMua2V5ID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXRlID0gQ09MT047XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gUklHSFRfQlJBQ0UpIHtcbiAgICAgIHRoaXMucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICB9XG4gIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT09IENPTE9OKXtcbiAgICBpZiAodG9rZW4gPT09IENPTE9OKSB7IHRoaXMuc3RhdGUgPSBWQUxVRTsgfVxuICAgIGVsc2UgeyByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7IH1cbiAgfWVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gQ09NTUEpe1xuICAgIGlmICh0b2tlbiA9PT0gQ09NTUEpIHsgXG4gICAgICBpZiAodGhpcy5tb2RlID09PSBBUlJBWSkgeyB0aGlzLmtleSsrOyB0aGlzLnN0YXRlID0gVkFMVUU7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7IHRoaXMuc3RhdGUgPSBLRVk7IH1cblxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IFJJR0hUX0JSQUNLRVQgJiYgdGhpcy5tb2RlID09PSBBUlJBWSB8fCB0b2tlbiA9PT0gUklHSFRfQlJBQ0UgJiYgdGhpcy5tb2RlID09PSBPQkpFQ1QpIHtcbiAgICAgIHRoaXMucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICB9XG4gIH1lbHNle1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgfVxufTtcblxuUGFyc2VyLkMgPSBDO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcjtcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG4vLyB0aHJvdWdoXG4vL1xuLy8gYSBzdHJlYW0gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJlLWVtaXQgdGhlIGlucHV0LlxuLy8gdXNlZnVsIGZvciBhZ2dyZWdhdGluZyBhIHNlcmllcyBvZiBjaGFuZ2luZyBidXQgbm90IGVuZGluZyBzdHJlYW1zIGludG8gb25lIHN0cmVhbSlcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCwgb3B0cykge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMucXVldWUoZGF0YSkgfVxuICBlbmQgPSBlbmQgfHwgZnVuY3Rpb24gKCkgeyB0aGlzLnF1ZXVlKG51bGwpIH1cblxuICB2YXIgZW5kZWQgPSBmYWxzZSwgZGVzdHJveWVkID0gZmFsc2UsIGJ1ZmZlciA9IFtdLCBfZW5kZWQgPSBmYWxzZVxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbS53cml0YWJsZSA9IHRydWVcbiAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG5cbi8vICBzdHJlYW0uYXV0b1BhdXNlICAgPSAhKG9wdHMgJiYgb3B0cy5hdXRvUGF1c2UgICA9PT0gZmFsc2UpXG4gIHN0cmVhbS5hdXRvRGVzdHJveSA9ICEob3B0cyAmJiBvcHRzLmF1dG9EZXN0cm95ID09PSBmYWxzZSlcblxuICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHdyaXRlLmNhbGwodGhpcywgZGF0YSlcbiAgICByZXR1cm4gIXN0cmVhbS5wYXVzZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKGJ1ZmZlci5sZW5ndGggJiYgIXN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgIGlmKG51bGwgPT09IGRhdGEpXG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5xdWV1ZSA9IHN0cmVhbS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbi8vICAgIGNvbnNvbGUuZXJyb3IoZW5kZWQpXG4gICAgaWYoX2VuZGVkKSByZXR1cm4gc3RyZWFtXG4gICAgaWYoZGF0YSA9PT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3IvcnVudGltZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC9wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi8kLnRvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXg7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vJC5pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IEFycmF5KGxlbmd0aCkgOiBJU19GSUxURVIgPyBbXSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59OyIsIi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi8kLmlvYmplY3QnKVxuICAsIGVudW1LZXlzID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBTeW1ib2woKSBpbiBPYmplY3QuYXNzaWduKHt9KTsgLy8gT2JqZWN0LmFzc2lnbiBhdmFpbGFibGUgYW5kIFN5bWJvbCBpcyBuYXRpdmVcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgbCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGkgPSAxO1xuICB3aGlsZShsID4gaSl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2krK10pXG4gICAgICAsIGtleXMgICA9IGVudW1LZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopVFtrZXkgPSBrZXlzW2orK11dID0gU1trZXldO1xuICB9XG4gIHJldHVybiBUO1xufSA6IE9iamVjdC5hc3NpZ247IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IChPID0gT2JqZWN0KGl0KSlbVEFHXSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaGlkZSAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIGN0eCAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIHNwZWNpZXMgICAgICA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzJylcbiAgLCBzdHJpY3ROZXcgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZGVmaW5lZCAgICAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKVxuICAsIGZvck9mICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHN0ZXAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLXN0ZXAnKVxuICAsIElEICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKSgnaWQnKVxuICAsICRoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBTVVBQT1JUX0RFU0MgPSByZXF1aXJlKCcuLyQuc3VwcG9ydC1kZXNjJylcbiAgLCBTSVpFICAgICAgICAgPSBTVVBQT1JUX0RFU0MgPyAnX3MnIDogJ3NpemUnXG4gICwgaWQgICAgICAgICAgID0gMDtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCEkaGFzKGl0LCBJRCkpe1xuICAgIC8vIGNhbid0IHNldCBpZCB0byBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBpZFxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBvYmplY3QgaWRcbiAgICBoaWRlKGl0LCBJRCwgKytpZCk7XG4gIC8vIHJldHVybiBvYmplY3QgaWQgd2l0aCBwcmVmaXhcbiAgfSByZXR1cm4gJ08nICsgaXRbSURdO1xufTtcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBzdHJpY3ROZXcodGhhdCwgQywgTkFNRSk7XG4gICAgICB0aGF0Ll9pID0gJC5jcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZXF1aXJlKCcuLyQubWl4JykoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0sIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKFNVUFBPUlRfREVTQykkLnNldERlc2MoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgcmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc3BlY2llcyhDKTtcbiAgICBzcGVjaWVzKHJlcXVpcmUoJy4vJC5jb3JlJylbTkFNRV0pOyAvLyBmb3Igd3JhcHBlclxuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBmb3JPZiAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgY2xhc3NvZiA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvck9mKHRoaXMsIGZhbHNlLCBhcnIucHVzaCwgYXJyKTtcbiAgICByZXR1cm4gYXJyO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIGFuT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHN0cmljdE5ldyAgICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBmb3JPZiAgICAgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBtZXRob2QgICAgICAgPSByZXF1aXJlKCcuLyQuYXJyYXktbWV0aG9kcycpXG4gICwgV0VBSyAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpKCd3ZWFrJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCAkaGFzICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGlzT2JqZWN0XG4gICwgZmluZCAgICAgICAgID0gbWV0aG9kKDUpXG4gICwgZmluZEluZGV4ICAgID0gbWV0aG9kKDYpXG4gICwgaWQgICAgICAgICAgID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIGZyb3plbiBrZXlzXG52YXIgZnJvemVuU3RvcmUgPSBmdW5jdGlvbih0aGF0KXtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgRnJvemVuU3RvcmUpO1xufTtcbnZhciBGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kRnJvemVuID0gZnVuY3Rpb24oc3RvcmUsIGtleSl7XG4gIHJldHVybiBmaW5kKHN0b3JlLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuRnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGVudHJ5ID0gZmluZEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KXJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiAhIWZpbmRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBmaW5kRnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYoZW50cnkpZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmKH5pbmRleCl0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIHN0cmljdE5ldyh0aGF0LCBDLCBOQU1FKTtcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIGZyb3plbiBvYmplY3RzXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlcXVpcmUoJy4vJC5taXgnKShDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKCFpc0V4dGVuc2libGUoa2V5KSlyZXR1cm4gZnJvemVuU3RvcmUodGhpcylbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiAkaGFzKGtleSwgV0VBSykgJiYgJGhhcyhrZXlbV0VBS10sIHRoaXMuX2kpICYmIGRlbGV0ZSBrZXlbV0VBS11bdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIWlzRXh0ZW5zaWJsZShrZXkpKXJldHVybiBmcm96ZW5TdG9yZSh0aGlzKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuICRoYXMoa2V5LCBXRUFLKSAmJiAkaGFzKGtleVtXRUFLXSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShhbk9iamVjdChrZXkpKSl7XG4gICAgICBmcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRoYXMoa2V5LCBXRUFLKSB8fCBoaWRlKGtleSwgV0VBSywge30pO1xuICAgICAga2V5W1dFQUtdW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZnJvemVuU3RvcmU6IGZyb3plblN0b3JlLFxuICBXRUFLOiBXRUFLXG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgJGRlZiAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGZvck9mICAgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBzdHJpY3ROZXcgID0gcmVxdWlyZSgnLi8kLnN0cmljdC1uZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZXF1aXJlKCcuLyQucmVkZWYnKShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7IHJldHVybiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IH1cbiAgICAgIDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpeyByZXR1cm4gZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyB9XG4gICAgICA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKXsgcmV0dXJuIGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgfVxuICAgICAgOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSl7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlcXVpcmUoJy4vJC5taXgnKShDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3QgID0gbmV3IENcbiAgICAgICwgY2hhaW4gPSBpbnN0W0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSlcbiAgICAgICwgYnVnZ3laZXJvO1xuICAgIC8vIHdyYXAgZm9yIGluaXQgY29sbGVjdGlvbnMgZnJvbSBpdGVyYWJsZVxuICAgIGlmKCFyZXF1aXJlKCcuLyQuaXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgbmV3IEMoaXRlcik7IH0pKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgICBzdHJpY3ROZXcodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBuZXcgQmFzZTtcbiAgICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIElTX1dFQUsgfHwgaW5zdC5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwga2V5KXtcbiAgICAgIGJ1Z2d5WmVybyA9IDEgLyBrZXkgPT09IC1JbmZpbml0eTtcbiAgICB9KTtcbiAgICAvLyBmaXggY29udmVydGluZyAtMCBrZXkgdG8gKzBcbiAgICBpZihidWdneVplcm8pe1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgLy8gKyBmaXggLmFkZCAmIC5zZXQgZm9yIGNoYWluaW5nXG4gICAgaWYoYnVnZ3laZXJvIHx8IGNoYWluICE9PSBpbnN0KWZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZihJU19XRUFLICYmIHByb3RvLmNsZWFyKWRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vJC50YWcnKShDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGRlZigkZGVmLkcgKyAkZGVmLlcgKyAkZGVmLkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTsiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH0gcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn07IiwidmFyIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsIGhpZGUgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgJHJlZGVmICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZicpXG4gICwgUFJPVE9UWVBFICA9ICdwcm90b3R5cGUnO1xudmFyIGN0eCA9IGZ1bmN0aW9uKGZuLCB0aGF0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xudmFyICRkZWYgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwXG4gICAgLCBpc0dsb2JhbCA9IHR5cGUgJiAkZGVmLkdcbiAgICAsIGlzUHJvdG8gID0gdHlwZSAmICRkZWYuUFxuICAgICwgdGFyZ2V0ICAgPSBpc0dsb2JhbCA/IGdsb2JhbCA6IHR5cGUgJiAkZGVmLlNcbiAgICAgICAgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGV4cG9ydHMgID0gaXNHbG9iYWwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgaWYoaXNHbG9iYWwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICEodHlwZSAmICRkZWYuRikgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgaWYodHlwZSAmICRkZWYuQiAmJiBvd24pZXhwID0gY3R4KG91dCwgZ2xvYmFsKTtcbiAgICBlbHNlIGV4cCA9IGlzUHJvdG8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmKHRhcmdldCAmJiAhb3duKSRyZWRlZih0YXJnZXQsIGtleSwgb3V0KTtcbiAgICAvLyBleHBvcnRcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KWhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmKGlzUHJvdG8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRkZWYuRiA9IDE7ICAvLyBmb3JjZWRcbiRkZWYuRyA9IDI7ICAvLyBnbG9iYWxcbiRkZWYuUyA9IDQ7ICAvLyBzdGF0aWNcbiRkZWYuUCA9IDg7ICAvLyBwcm90b1xuJGRlZi5CID0gMTY7IC8vIGJpbmRcbiRkZWYuVyA9IDMyOyAvLyB3cmFwXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWY7IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gJC5pc0VudW1cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07IiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5leHBtMSB8fCBmdW5jdGlvbiBleHBtMSh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGxlbmd0aCwgZXhlYyl7XG4gIHZhciBkZWZpbmVkICA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJylcbiAgICAsIFNZTUJPTCAgID0gcmVxdWlyZSgnLi8kLndrcycpKEtFWSlcbiAgICAsIG9yaWdpbmFsID0gJydbS0VZXTtcbiAgaWYocmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKXtcbiAgICByZXF1aXJlKCcuLyQucmVkZWYnKShTdHJpbmcucHJvdG90eXBlLCBLRVksIGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCBvcmlnaW5hbCkpO1xuICAgIHJlcXVpcmUoJy4vJC5oaWRlJykoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24oc3RyaW5nLCBhcmcpeyByZXR1cm4gb3JpZ2luYWwuY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbihzdHJpbmcpeyByZXR1cm4gb3JpZ2luYWwuY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCAgID0gYW5PYmplY3QodGhpcylcbiAgICAsIHJlc3VsdCA9ICcnO1xuICBpZih0aGF0Lmdsb2JhbClyZXN1bHQgKz0gJ2cnO1xuICBpZih0aGF0Lmlnbm9yZUNhc2UpcmVzdWx0ICs9ICdpJztcbiAgaWYodGhhdC5tdWx0aWxpbmUpcmVzdWx0ICs9ICdtJztcbiAgaWYodGhhdC51bmljb2RlKXJlc3VsdCArPSAndSc7XG4gIGlmKHRoYXQuc3RpY2t5KXJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59OyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuLyQuaXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vJC50by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvcjtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICB9XG59OyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b1N0cmluZyAgPSB7fS50b1N0cmluZ1xuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBnZXROYW1lcyAgPSByZXF1aXJlKCcuLyQnKS5nZXROYW1lcztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnZXROYW1lcyhpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICBpZih3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJylyZXR1cm4gZ2V0V2luZG93TmFtZXMoaXQpO1xuICByZXR1cm4gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSk7XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9IFVOREVGSU5FRCAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gVU5ERUZJTkVEICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLnN1cHBvcnQtZGVzYycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuICQuc2V0RGVzYyhvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwiLy8gaW5kZXhlZCBvYmplY3QsIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gMCBpbiBPYmplY3QoJ3onKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAoSXRlcmF0b3JzLkFycmF5IHx8IEFycmF5LnByb3RvdHlwZVtJVEVSQVRPUl0pID09PSBpdDtcbn07IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBmbG9vciAgICA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCl7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTsiLCIvLyBodHRwOi8vanNwZXJmLmNvbS9jb3JlLWpzLWlzb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSBudWxsICYmICh0eXBlb2YgaXQgPT0gJ29iamVjdCcgfHwgdHlwZW9mIGl0ID09ICdmdW5jdGlvbicpO1xufTsiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLyQnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKSgxLG5leHQpfSk7XG4gIHJlcXVpcmUoJy4vJC50YWcnKShDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICA9IHJlcXVpcmUoJy4vJC5saWJyYXJ5JylcbiAgLCAkZGVmICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcmVkZWYgICAgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWYnKVxuICAsIGhpZGUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBTWU1CT0xfSVRFUkFUT1IgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCBCVUdHWSAgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgICA9ICd2YWx1ZXMnO1xudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0Upe1xuICByZXF1aXJlKCcuLyQuaXRlci1jcmVhdGUnKShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBwcm90byAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCBfbmF0aXZlICA9IHByb3RvW1NZTUJPTF9JVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsIF9kZWZhdWx0ID0gX25hdGl2ZSB8fCBjcmVhdGVNZXRob2QoREVGQVVMVClcbiAgICAsIG1ldGhvZHMsIGtleTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZihfbmF0aXZlKXtcbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSByZXF1aXJlKCcuLyQnKS5nZXRQcm90byhfZGVmYXVsdC5jYWxsKG5ldyBCYXNlKSk7XG4gICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgIHJlcXVpcmUoJy4vJC50YWcnKShJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAvLyBGRiBmaXhcbiAgICBpZighTElCUkFSWSAmJiBoYXMocHJvdG8sIEZGX0lURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBTWU1CT0xfSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZighTElCUkFSWSB8fCBGT1JDRSloaWRlKHByb3RvLCBTWU1CT0xfSVRFUkFUT1IsIF9kZWZhdWx0KTtcbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSBfZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgICAgICAgID8gX2RlZmF1bHQgOiBjcmVhdGVNZXRob2QoS0VZUyksXG4gICAgICB2YWx1ZXM6ICBERUZBVUxUID09IFZBTFVFUyA/IF9kZWZhdWx0IDogY3JlYXRlTWV0aG9kKFZBTFVFUyksXG4gICAgICBlbnRyaWVzOiBERUZBVUxUICE9IFZBTFVFUyA/IF9kZWZhdWx0IDogY3JlYXRlTWV0aG9kKCdlbnRyaWVzJylcbiAgICB9O1xuICAgIGlmKEZPUkNFKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpJHJlZGVmKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRkZWYoJGRlZi5QICsgJGRlZi5GICogQlVHR1ksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG59OyIsInZhciBTWU1CT0xfSVRFUkFUT1IgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgICAgPSBmYWxzZTtcbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtTWU1CT0xfSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgaWYoIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltTWU1CT0xfSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgc2FmZSA9IHRydWU7IH07XG4gICAgYXJyW1NZTUJPTF9JVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgJE9iamVjdCA9IE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcbiAgZ2V0UHJvdG86ICAgJE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgaXNFbnVtOiAgICAge30ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBzZXREZXNjOiAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICBzZXREZXNjczogICAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXG4gIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcbiAgZ2V0TmFtZXM6ICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICBnZXRTeW1ib2xzOiAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgZWFjaDogICAgICAgW10uZm9yRWFjaFxufTsiLCJ2YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7IiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpe1xyXG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcclxufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXHJcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuLyQudGFzaycpLnNldFxyXG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXHJcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuLyQuY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXHJcbiAgLCBoZWFkLCBsYXN0LCBub3RpZnk7XHJcblxyXG52YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xyXG4gIHZhciBwYXJlbnQsIGRvbWFpbjtcclxuICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSl7XHJcbiAgICBwcm9jZXNzLmRvbWFpbiA9IG51bGw7XHJcbiAgICBwYXJlbnQuZXhpdCgpO1xyXG4gIH1cclxuICB3aGlsZShoZWFkKXtcclxuICAgIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xyXG4gICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xyXG4gICAgaGVhZC5mbi5jYWxsKCk7IC8vIDwtIGN1cnJlbnRseSB3ZSB1c2UgaXQgb25seSBmb3IgUHJvbWlzZSAtIHRyeSAvIGNhdGNoIG5vdCByZXF1aXJlZFxyXG4gICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XHJcbiAgICBoZWFkID0gaGVhZC5uZXh0O1xyXG4gIH0gbGFzdCA9IHVuZGVmaW5lZDtcclxuICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XHJcbn1cclxuXHJcbi8vIE5vZGUuanNcclxuaWYoaXNOb2RlKXtcclxuICBub3RpZnkgPSBmdW5jdGlvbigpe1xyXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XHJcbiAgfTtcclxuLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXHJcbn0gZWxzZSBpZihPYnNlcnZlcil7XHJcbiAgdmFyIHRvZ2dsZSA9IDFcclxuICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xyXG4gIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xyXG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XHJcbiAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAtdG9nZ2xlO1xyXG4gIH07XHJcbi8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XHJcbi8vIC0gc2V0SW1tZWRpYXRlXHJcbi8vIC0gTWVzc2FnZUNoYW5uZWxcclxuLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xyXG4vLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxyXG4vLyAtIHNldFRpbWVvdXRcclxufSBlbHNlIHtcclxuICBub3RpZnkgPSBmdW5jdGlvbigpe1xyXG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxyXG4gICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc2FwKGZuKXtcclxuICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCwgZG9tYWluOiBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW59O1xyXG4gIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcclxuICBpZighaGVhZCl7XHJcbiAgICBoZWFkID0gdGFzaztcclxuICAgIG5vdGlmeSgpO1xyXG4gIH0gbGFzdCA9IHRhc2s7XHJcbn07IiwidmFyICRyZWRlZiA9IHJlcXVpcmUoJy4vJC5yZWRlZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYyl7XG4gIGZvcih2YXIga2V5IGluIHNyYykkcmVkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICAgLCBmbiAgID0gKHJlcXVpcmUoJy4vJC5jb3JlJykuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRkZWYoJGRlZi5TICsgJGRlZi5GICogcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwidmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KGl0KVxuICAgICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBBcnJheShsZW5ndGgpXG4gICAgICAsIGtleTtcbiAgICBpZihpc0VudHJpZXMpd2hpbGUobGVuZ3RoID4gaSlyZXN1bHRbaV0gPSBba2V5ID0ga2V5c1tpKytdLCBPW2tleV1dO1xuICAgIGVsc2Ugd2hpbGUobGVuZ3RoID4gaSlyZXN1bHRbaV0gPSBPW2tleXNbaSsrXV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07IiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIFJlZmxlY3QgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpe1xuICB2YXIga2V5cyAgICAgICA9ICQuZ2V0TmFtZXMoYW5PYmplY3QoaXQpKVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCAgICAgID0gcmVxdWlyZSgnLi8kLnBhdGgnKVxuICAsIGludm9rZSAgICA9IHJlcXVpcmUoJy4vJC5pbnZva2UnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgcGFyZ3MgID0gQXJyYXkobGVuZ3RoKVxuICAgICwgaSAgICAgID0gMFxuICAgICwgXyAgICAgID0gcGF0aC5fXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigocGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciB0aGF0ICAgID0gdGhpc1xuICAgICAgLCBfbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBqID0gMCwgayA9IDAsIGFyZ3M7XG4gICAgaWYoIWhvbGRlciAmJiAhX2xlbmd0aClyZXR1cm4gaW52b2tlKGZuLCBwYXJncywgdGhhdCk7XG4gICAgYXJncyA9IHBhcmdzLnNsaWNlKCk7XG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gajsgaisrKWlmKGFyZ3Nbal0gPT09IF8pYXJnc1tqXSA9IGFyZ3VtZW50c1trKytdO1xuICAgIHdoaWxlKF9sZW5ndGggPiBrKWFyZ3MucHVzaChhcmd1bWVudHNbaysrXSk7XG4gICAgcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCIvLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZ1xuLy8gZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG52YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIFNSQyAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi8kLmNvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICBpZih0eXBlb2YgdmFsID09ICdmdW5jdGlvbicpe1xuICAgIGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgICBpZighKCduYW1lJyBpbiB2YWwpKXZhbC5uYW1lID0ga2V5O1xuICB9XG4gIGlmKE8gPT09IGdsb2JhbCl7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGlmKCFzYWZlKWRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlZ0V4cCwgcmVwbGFjZSl7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uKHBhcnQpe1xuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xuICB9IDogcmVwbGFjZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gU3RyaW5nKGl0KS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBnZXREZXNjICA9IHJlcXVpcmUoJy4vJCcpLmdldERlc2NcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgPyBmdW5jdGlvbihidWdneSwgc2V0KXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZXQgPSByZXF1aXJlKCcuLyQuY3R4JykoRnVuY3Rpb24uY2FsbCwgZ2V0RGVzYyhPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgICBzZXQoe30sIFtdKTtcbiAgICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICAgIHJldHVybiBPO1xuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDKXtcbiAgaWYocmVxdWlyZSgnLi8kLnN1cHBvcnQtZGVzYycpICYmICEoU1BFQ0lFUyBpbiBDKSkkLnNldERlc2MoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgVHlwZUVycm9yKG5hbWUgKyBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsXG4gICAgICB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJylcbiAgLCBjb2YgICAgID0gcmVxdWlyZSgnLi8kLmNvZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSl7XG4gIGlmKGNvZihzZWFyY2hTdHJpbmcpID09ICdSZWdFeHAnKXRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLXN0cmluZy1wYWQtbGVmdC1yaWdodFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgcmVwZWF0ICAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLXJlcGVhdCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCl7XG4gIHZhciBTICAgICAgICAgICAgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAsIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoXG4gICAgLCBmaWxsU3RyICAgICAgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZylcbiAgICAsIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGgpcmV0dXJuIFM7XG4gIGlmKGZpbGxTdHIgPT0gJycpZmlsbFN0ciA9ICcgJztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGhcbiAgICAsIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pc3RyaW5nRmlsbGVyID0gbGVmdFxuICAgID8gc3RyaW5nRmlsbGVyLnNsaWNlKHN0cmluZ0ZpbGxlci5sZW5ndGggLSBmaWxsTGVuKVxuICAgIDogc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi8kLnRvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KXtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKVxuICAgICwgcmVzID0gJydcbiAgICAsIG4gICA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTsiLCIvLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGZ1bmN0aW9uKHN0cmluZywgVFlQRSl7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZihUWVBFICYgMSlzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZihUWVBFICYgMilzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxudmFyICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKVxuICAsIHNwYWNlcyAgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgICAgICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJ1xuICAsIHNwYWNlICAgPSAnWycgKyBzcGFjZXMgKyAnXSdcbiAgLCBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1J1xuICAsIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJylcbiAgLCBydHJpbSAgID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZXhwICA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWModHJpbSk7XG4gICRkZWYoJGRlZi5QICsgJGRlZi5GICogcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KSwgJ1N0cmluZycsIGV4cCk7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaGFzICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIGhpZGUgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgVEFHICA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSloaWRlKGl0LCBUQUcsIHRhZyk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmRvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0bmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vJC5jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdG5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdCl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdG5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59OyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTsiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcclxudmFyIElPYmplY3QgPSByZXF1aXJlKCcuLyQuaW9iamVjdCcpXHJcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xyXG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vJC50by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vJC53a3MnKSgndW5zY29wYWJsZXMnKTtcbmlmKCEoVU5TQ09QQUJMRVMgaW4gW10pKXJlcXVpcmUoJy4vJC5oaWRlJykoQXJyYXkucHJvdG90eXBlLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICBbXVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59OyIsInZhciBzdG9yZSAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJykoJ3drcycpXG4gICwgU3ltYm9sID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLlN5bWJvbDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFN5bWJvbCAmJiBTeW1ib2xbbmFtZV0gfHwgKFN5bWJvbCB8fCByZXF1aXJlKCcuLyQudWlkJykpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07IiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdIHx8IGl0WydAQGl0ZXJhdG9yJ10gfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIFNVUFBPUlRfREVTQyAgICAgPSByZXF1aXJlKCcuLyQuc3VwcG9ydC1kZXNjJylcbiAgLCBjcmVhdGVEZXNjICAgICAgID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKVxuICAsIGh0bWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBoYXMgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgY29mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRkZWYgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpbnZva2UgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgYXJyYXlNZXRob2QgICAgICA9IHJlcXVpcmUoJy4vJC5hcnJheS1tZXRob2RzJylcbiAgLCBJRV9QUk9UTyAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpKCdfX3Byb3RvX18nKVxuICAsIGlzT2JqZWN0ICAgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgICAgICAgID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCB0b0ludGVnZXIgICAgICAgID0gcmVxdWlyZSgnLi8kLnRvLWludGVnZXInKVxuICAsIHRvSW5kZXggICAgICAgICAgPSByZXF1aXJlKCcuLyQudG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgICAgICAgPSByZXF1aXJlKCcuLyQudG8tbGVuZ3RoJylcbiAgLCBJT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmlvYmplY3QnKVxuICAsIGZhaWxzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZmFpbHMnKVxuICAsIE9iamVjdFByb3RvICAgICAgPSBPYmplY3QucHJvdG90eXBlXG4gICwgQSAgICAgICAgICAgICAgICA9IFtdXG4gICwgX3NsaWNlICAgICAgICAgICA9IEEuc2xpY2VcbiAgLCBfam9pbiAgICAgICAgICAgID0gQS5qb2luXG4gICwgZGVmaW5lUHJvcGVydHkgICA9ICQuc2V0RGVzY1xuICAsIGdldE93bkRlc2NyaXB0b3IgPSAkLmdldERlc2NcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gJC5zZXREZXNjc1xuICAsICRpbmRleE9mICAgICAgICAgPSByZXF1aXJlKCcuLyQuYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBmYWN0b3JpZXMgICAgICAgID0ge31cbiAgLCBJRThfRE9NX0RFRklORTtcblxuaWYoIVNVUFBPUlRfREVTQyl7XG4gIElFOF9ET01fREVGSU5FID0gIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGNlbCgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG4gIH0pO1xuICAkLnNldERlc2MgPSBmdW5jdGlvbihPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICAgIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpYW5PYmplY3QoTylbUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgIHJldHVybiBPO1xuICB9O1xuICAkLmdldERlc2MgPSBmdW5jdGlvbihPLCBQKXtcbiAgICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgICAgcmV0dXJuIGdldE93bkRlc2NyaXB0b3IoTywgUCk7XG4gICAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICAgIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghT2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChPLCBQKSwgT1tQXSk7XG4gIH07XG4gICQuc2V0RGVzY3MgPSBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oTywgUHJvcGVydGllcyl7XG4gICAgYW5PYmplY3QoTyk7XG4gICAgdmFyIGtleXMgICA9ICQuZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpID0gMFxuICAgICAgLCBQO1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpJC5zZXREZXNjKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICAgIHJldHVybiBPO1xuICB9O1xufVxuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhU1VQUE9SVF9ERVNDLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuNiAvIDE1LjIuMy4zIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkLmdldERlc2MsXG4gIC8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkLnNldERlc2MsXG4gIC8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogZGVmaW5lUHJvcGVydGllc1xufSk7XG5cbiAgLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGtleXMxID0gKCdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLCcgK1xuICAgICAgICAgICAgJ3RvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnKS5zcGxpdCgnLCcpXG4gIC8vIEFkZGl0aW9uYWwga2V5cyBmb3IgZ2V0T3duUHJvcGVydHlOYW1lc1xuICAsIGtleXMyID0ga2V5czEuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJylcbiAgLCBrZXlzTGVuMSA9IGtleXMxLmxlbmd0aDtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGNlbCgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGtleXNMZW4xXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZSgnPHNjcmlwdD5kb2N1bWVudC5GPU9iamVjdDwvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdC5wcm90b3R5cGVba2V5czFbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcbnZhciBjcmVhdGVHZXRLZXlzID0gZnVuY3Rpb24obmFtZXMsIGxlbmd0aCl7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3Qpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICAgLCBpICAgICAgPSAwXG4gICAgICAsIHJlc3VsdCA9IFtdXG4gICAgICAsIGtleTtcbiAgICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICAgIH4kaW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG52YXIgRW1wdHkgPSBmdW5jdGlvbigpe307XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbiAgZ2V0UHJvdG90eXBlT2Y6ICQuZ2V0UHJvdG8gPSAkLmdldFByb3RvIHx8IGZ1bmN0aW9uKE8pe1xuICAgIE8gPSB0b09iamVjdChPKTtcbiAgICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xuICB9LFxuICAvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICQuZ2V0TmFtZXMgPSAkLmdldE5hbWVzIHx8IGNyZWF0ZUdldEtleXMoa2V5czIsIGtleXMyLmxlbmd0aCwgdHJ1ZSksXG4gIC8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICQuY3JlYXRlID0gJC5jcmVhdGUgfHwgZnVuY3Rpb24oTywgLyo/Ki9Qcm9wZXJ0aWVzKXtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmKE8gIT09IG51bGwpe1xuICAgICAgRW1wdHkucHJvdG90eXBlID0gYW5PYmplY3QoTyk7XG4gICAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHNoaW1cbiAgICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICAgIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gICAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbiAgfSxcbiAgLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG4gIGtleXM6ICQuZ2V0S2V5cyA9ICQuZ2V0S2V5cyB8fCBjcmVhdGVHZXRLZXlzKGtleXMxLCBrZXlzTGVuMSwgZmFsc2UpXG59KTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uKEYsIGxlbiwgYXJncyl7XG4gIGlmKCEobGVuIGluIGZhY3Rvcmllcykpe1xuICAgIGZvcih2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKW5baV0gPSAnYVsnICsgaSArICddJztcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH1cbiAgcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxuLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxuJGRlZigkZGVmLlAsICdGdW5jdGlvbicsIHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0IC8qLCBhcmdzLi4uICovKXtcbiAgICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAgICwgcGFydEFyZ3MgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoX3NsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICAgIH07XG4gICAgaWYoaXNPYmplY3QoZm4ucHJvdG90eXBlKSlib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9XG59KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xudmFyIGJ1Z2d5U2xpY2UgPSBmYWlscyhmdW5jdGlvbigpe1xuICBpZihodG1sKV9zbGljZS5jYWxsKGh0bWwpO1xufSk7XG5cbiRkZWYoJGRlZi5QICsgJGRlZi5GICogYnVnZ3lTbGljZSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24oYmVnaW4sIGVuZCl7XG4gICAgdmFyIGxlbiAgID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpXG4gICAgICAsIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmKGtsYXNzID09ICdBcnJheScpcmV0dXJuIF9zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCAgPSB0b0luZGV4KGJlZ2luLCBsZW4pXG4gICAgICAsIHVwVG8gICA9IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIHNpemUgICA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydClcbiAgICAgICwgY2xvbmVkID0gQXJyYXkoc2l6ZSlcbiAgICAgICwgaSAgICAgID0gMDtcbiAgICBmb3IoOyBpIDwgc2l6ZTsgaSsrKWNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiAoSU9iamVjdCAhPSBPYmplY3QpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIF9qb2luLmFwcGx5KElPYmplY3QodGhpcyksIGFyZ3VtZW50cyk7XG4gIH1cbn0pO1xuXG4vLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxuJGRlZigkZGVmLlMsICdBcnJheScsIHtpc0FycmF5OiBmdW5jdGlvbihhcmcpeyByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5JzsgfX0pO1xuXG52YXIgY3JlYXRlQXJyYXlSZWR1Y2UgPSBmdW5jdGlvbihpc1JpZ2h0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrZm4sIG1lbW8pe1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyAgICAgID0gSU9iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDIpZm9yKDs7KXtcbiAgICAgIGlmKGluZGV4IGluIE8pe1xuICAgICAgICBtZW1vID0gT1tpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGlmKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpe1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKWlmKGluZGV4IGluIE8pe1xuICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgT1tpbmRleF0sIGluZGV4LCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59O1xudmFyIG1ldGhvZGl6ZSA9IGZ1bmN0aW9uKCRmbil7XG4gIHJldHVybiBmdW5jdGlvbihhcmcxLyosIGFyZzIgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZm4odGhpcywgYXJnMSwgYXJndW1lbnRzWzFdKTtcbiAgfTtcbn07XG4kZGVmKCRkZWYuUCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogJC5lYWNoID0gJC5lYWNoIHx8IG1ldGhvZGl6ZShhcnJheU1ldGhvZCgwKSksXG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogbWV0aG9kaXplKGFycmF5TWV0aG9kKDEpKSxcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IG1ldGhvZGl6ZShhcnJheU1ldGhvZCgyKSksXG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBtZXRob2RpemUoYXJyYXlNZXRob2QoMykpLFxuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IG1ldGhvZGl6ZShhcnJheU1ldGhvZCg0KSksXG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBjcmVhdGVBcnJheVJlZHVjZShmYWxzZSksXG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogY3JlYXRlQXJyYXlSZWR1Y2UodHJ1ZSksXG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IG1ldGhvZGl6ZSgkaW5kZXhPZiksXG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24oZWwsIGZyb21JbmRleCAvKiA9IEBbKi0xXSAqLyl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gbGVuZ3RoIC0gMTtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSlpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoZnJvbUluZGV4KSk7XG4gICAgaWYoaW5kZXggPCAwKWluZGV4ID0gdG9MZW5ndGgobGVuZ3RoICsgaW5kZXgpO1xuICAgIGZvcig7aW5kZXggPj0gMDsgaW5kZXgtLSlpZihpbmRleCBpbiBPKWlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gaW5kZXg7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcblxuLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXG4kZGVmKCRkZWYuUywgJ0RhdGUnLCB7bm93OiBmdW5jdGlvbigpeyByZXR1cm4gK25ldyBEYXRlOyB9fSk7XG5cbnZhciBseiA9IGZ1bmN0aW9uKG51bSl7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufTtcblxuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbi8vIFBoYW50b21KUyBhbmQgb2xkIHdlYmtpdCBoYWQgYSBicm9rZW4gRGF0ZSBpbXBsZW1lbnRhdGlvbi5cbnZhciBkYXRlICAgICAgID0gbmV3IERhdGUoLTVlMTMgLSAxKVxuICAsIGJyb2tlbkRhdGUgPSAhKGRhdGUudG9JU09TdHJpbmcgJiYgZGF0ZS50b0lTT1N0cmluZygpID09ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonXG4gICAgICAmJiBmYWlscyhmdW5jdGlvbigpeyBuZXcgRGF0ZShOYU4pLnRvSVNPU3RyaW5nKCk7IH0pKTtcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogYnJva2VuRGF0ZSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpe1xuICAgIGlmKCFpc0Zpbml0ZSh0aGlzKSl0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgICB2YXIgZCA9IHRoaXNcbiAgICAgICwgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKVxuICAgICAgLCBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICAgLCBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICAgIHJldHVybiBzICsgKCcwMDAwMCcgKyBNYXRoLmFicyh5KSkuc2xpY2UocyA/IC02IDogLTQpICtcbiAgICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICAgJzonICsgbHooZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKG0gPiA5OSA/IG0gOiAnMCcgKyBseihtKSkgKyAnWic7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuLyQudG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpO1xuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4gIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xuICAgIHZhciBPICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbiAgID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIHRvICAgID0gdG9JbmRleCh0YXJnZXQsIGxlbilcbiAgICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgICAsIGVuZCAgID0gYXJndW1lbnRzWzJdXG4gICAgICAsIGZpbiAgID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBjb3VudCA9IE1hdGgubWluKGZpbiAtIGZyb20sIGxlbiAtIHRvKVxuICAgICAgLCBpbmMgICA9IDE7XG4gICAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcbiAgICAgIGluYyAgPSAtMTtcbiAgICAgIGZyb20gPSBmcm9tICsgY291bnQgLSAxO1xuICAgICAgdG8gICA9IHRvICAgKyBjb3VudCAtIDE7XG4gICAgfVxuICAgIHdoaWxlKGNvdW50LS0gPiAwKXtcbiAgICAgIGlmKGZyb20gaW4gTylPW3RvXSA9IE9bZnJvbV07XG4gICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIHRvICAgKz0gaW5jO1xuICAgICAgZnJvbSArPSBpbmM7XG4gICAgfSByZXR1cm4gTztcbiAgfVxufSk7XG5yZXF1aXJlKCcuLyQudW5zY29wZScpKCdjb3B5V2l0aGluJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0JylcbiAgLCB0b0luZGV4ICA9IHJlcXVpcmUoJy4vJC50by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuLyQudG8tbGVuZ3RoJyk7XG4kZGVmKCRkZWYuUCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbiAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcywgdHJ1ZSlcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoYXJndW1lbnRzWzFdLCBsZW5ndGgpXG4gICAgICAsIGVuZCAgICA9IGFyZ3VtZW50c1syXVxuICAgICAgLCBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpO1xuICAgIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcbiAgICByZXR1cm4gTztcbiAgfVxufSk7XG5yZXF1aXJlKCcuLyQudW5zY29wZScpKCdmaWxsJyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgS0VZICAgID0gJ2ZpbmRJbmRleCdcbiAgLCAkZGVmICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBmb3JjZWQgPSB0cnVlXG4gICwgJGZpbmQgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKSg2KTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgS0VZICAgID0gJ2ZpbmQnXG4gICwgJGRlZiAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgZm9yY2VkID0gdHJ1ZVxuICAsICRmaW5kICA9IHJlcXVpcmUoJy4vJC5hcnJheS1tZXRob2RzJykoNSk7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCAkZGVmICAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheS1pdGVyJylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vJC50by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogIXJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBtYXBmbiAgID0gYXJndW1lbnRzWzFdXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKG1hcHBpbmcpbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCkpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHNldFVuc2NvcGUgPSByZXF1aXJlKCcuLyQudW5zY29wZScpXG4gICwgc3RlcCAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuc2V0VW5zY29wZSgna2V5cycpO1xuc2V0VW5zY29wZSgndmFsdWVzJyk7XG5zZXRVbnNjb3BlKCdlbnRyaWVzJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqIHJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCJyZXF1aXJlKCcuLyQuc3BlY2llcycpKEFycmF5KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaXNPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIEhBU19JTlNUQU5DRSAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2hhc0luc3RhbmNlJylcbiAgLCBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZighKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkkLnNldERlc2MoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZih0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZShPID0gJC5nZXRQcm90byhPKSlpZih0aGlzLnByb3RvdHlwZSA9PT0gTylyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufX0pOyIsInZhciBzZXREZXNjICAgID0gcmVxdWlyZSgnLi8kJykuc2V0RGVzY1xuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgaGFzICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIEZQcm90byAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGVcbiAgLCBuYW1lUkUgICAgID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvXG4gICwgTkFNRSAgICAgICA9ICduYW1lJztcbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vJC5zdXBwb3J0LWRlc2MnKSAmJiBzZXREZXNjKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKXtcbiAgICB2YXIgbWF0Y2ggPSAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpXG4gICAgICAsIG5hbWUgID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIGhhcyh0aGlzLCBOQU1FKSB8fCBzZXREZXNjKHRoaXMsIE5BTUUsIGNyZWF0ZURlc2MoNSwgbmFtZSkpO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHNbMF0pOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGRlZiAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgbG9nMXAgID0gcmVxdWlyZSgnLi8kLmxvZzFwJylcbiAgLCBzcXJ0ICAgPSBNYXRoLnNxcnRcbiAgLCAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuXG4vLyBWOCBidWcgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDkgXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICEoJGFjb3NoICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTApLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuZnVuY3Rpb24gYXNpbmgoeCl7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuJGRlZigkZGVmLlMsICdNYXRoJywge2FzaW5oOiBhc2luaH0pOyIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgc2lnbiA9IHJlcXVpcmUoJy4vJC5zaWduJyk7XG5cbiRkZWYoJGRlZi5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KXtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KXtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgZXhwICA9IE1hdGguZXhwO1xuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7ZXhwbTE6IHJlcXVpcmUoJy4vJC5leHBtMScpfSk7IiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBzaWduICA9IHJlcXVpcmUoJy4vJC5zaWduJylcbiAgLCBwb3cgICA9IE1hdGgucG93XG4gICwgRVBTSUxPTiAgID0gcG93KDIsIC01MilcbiAgLCBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKVxuICAsIE1BWDMyICAgICA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpXG4gICwgTUlOMzIgICAgID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cblxuJGRlZigkZGVmLlMsICdNYXRoJywge1xuICBmcm91bmQ6IGZ1bmN0aW9uIGZyb3VuZCh4KXtcbiAgICB2YXIgJGFicyAgPSBNYXRoLmFicyh4KVxuICAgICAgLCAkc2lnbiA9IHNpZ24oeClcbiAgICAgICwgYSwgcmVzdWx0O1xuICAgIGlmKCRhYnMgPCBNSU4zMilyZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICAgIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgICBpZihyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KXJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICAgIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGFicyAgPSBNYXRoLmFicztcblxuJGRlZigkZGVmLlMsICdNYXRoJywge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSAgPSAwXG4gICAgICAsIGkgICAgPSAwXG4gICAgICAsIGxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGxhcmcgPSAwXG4gICAgICAsIGFyZywgZGl2O1xuICAgIHdoaWxlKGkgPCBsZW4pe1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmKGxhcmcgPCBhcmcpe1xuICAgICAgICBkaXYgID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtICA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYoYXJnID4gMCl7XG4gICAgICAgIGRpdiAgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuLy8gV2ViS2l0IGZhaWxzIHdpdGggYmlnIG51bWJlcnNcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE1hdGguaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNTtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJTlQxNiAmIHhuXG4gICAgICAsIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlMsICdNYXRoJywge2xvZzFwOiByZXF1aXJlKCcuLyQubG9nMXAnKX0pOyIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7c2lnbjogcmVxdWlyZSgnLi8kLnNpZ24nKX0pOyIsIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGV4cG0xID0gcmVxdWlyZSgnLi8kLmV4cG0xJylcbiAgLCBleHAgICA9IE1hdGguZXhwO1xuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBleHBtMSA9IHJlcXVpcmUoJy4vJC5leHBtMScpXG4gICwgZXhwICAgPSBNYXRoLmV4cDtcblxuJGRlZigkZGVmLlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpe1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxuICAgICAgLCBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpe1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBjb2YgICAgICAgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGZhaWxzICAgICAgPSByZXF1aXJlKCcuLyQuZmFpbHMnKVxuICAsIE5VTUJFUiAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgPSBnbG9iYWxbTlVNQkVSXVxuICAsIEJhc2UgICAgICAgPSAkTnVtYmVyXG4gICwgcHJvdG8gICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgPSBjb2YoJC5jcmVhdGUocHJvdG8pKSA9PSBOVU1CRVI7XG52YXIgdG9QcmltaXRpdmUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBmbiwgdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIG51bWJlclwiKTtcbn07XG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGlzT2JqZWN0KGl0KSlpdCA9IHRvUHJpbWl0aXZlKGl0KTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIgJiYgaXQuY2hhckNvZGVBdCgwKSA9PSA0OCl7XG4gICAgdmFyIGJpbmFyeSA9IGZhbHNlO1xuICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgIGNhc2UgNjYgOiBjYXNlIDk4ICA6IGJpbmFyeSA9IHRydWU7XG4gICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByZXR1cm4gcGFyc2VJbnQoaXQuc2xpY2UoMiksIGJpbmFyeSA/IDIgOiA4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5pZighKCROdW1iZXIoJzBvMScpICYmICROdW1iZXIoJzBiMScpKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIoaXQpe1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbigpeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBuZXcgQmFzZSh0b051bWJlcihpdCkpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICAkLmVhY2guY2FsbChyZXF1aXJlKCcuLyQuc3VwcG9ydC1kZXNjJykgPyAkLmdldE5hbWVzKEJhc2UpIDogKFxuICAgICAgLy8gRVMzOlxuICAgICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICAgKS5zcGxpdCgnLCcpLCBmdW5jdGlvbihrZXkpe1xuICAgICAgaWYoaGFzKEJhc2UsIGtleSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKXtcbiAgICAgICAgJC5zZXREZXNjKCROdW1iZXIsIGtleSwgJC5nZXREZXNjKEJhc2UsIGtleSkpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuLyQucmVkZWYnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59IiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ051bWJlcicsIHtFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpfSk7IiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZGVmICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBfaXNGaW5pdGUgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRkZWYoJGRlZi5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpe1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlMsICdOdW1iZXInLCB7aXNJbnRlZ2VyOiByZXF1aXJlKCcuLyQuaXMtaW50ZWdlcicpfSk7IiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZGVmICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpc0ludGVnZXIgPSByZXF1aXJlKCcuLyQuaXMtaW50ZWdlcicpXG4gICwgYWJzICAgICAgID0gTWF0aC5hYnM7XG5cbiRkZWYoJGRlZi5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcil7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlMsICdOdW1iZXInLCB7TUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZn0pOyIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5TLCAnTnVtYmVyJywge01JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmfSk7IiwiLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ051bWJlcicsIHtwYXJzZUZsb2F0OiBwYXJzZUZsb2F0fSk7IiwiLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5TLCAnTnVtYmVyJywge3BhcnNlSW50OiBwYXJzZUludH0pOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlMgKyAkZGVmLkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuLyQuYXNzaWduJyl9KTsiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vJC5vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKGl0KSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vJC5vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ipe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiByZXF1aXJlKCcuLyQuZ2V0LW5hbWVzJykuZ2V0O1xufSk7IiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vJC5vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oJGdldFByb3RvdHlwZU9mKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbigkaXNFeHRlbnNpYmxlKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbigkaXNGcm96ZW4pe1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uKCRpc1NlYWxlZCl7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtcbiAgaXM6IHJlcXVpcmUoJy4vJC5zYW1lJylcbn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oJGtleXMpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vJC5vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24oJHByZXZlbnRFeHRlbnNpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhpdCkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKGl0KSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXR9KTsiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsIHRlc3QgICAgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi8kLndrcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpe1xuICByZXF1aXJlKCcuLyQucmVkZWYnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIExJQlJBUlkgICAgPSByZXF1aXJlKCcuLyQubGlicmFyeScpXG4gICwgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjbGFzc29mICAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsICRkZWYgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgc3RyaWN0TmV3ICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBmb3JPZiAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc2V0UHJvdG8gICA9IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXRcbiAgLCBzYW1lICAgICAgID0gcmVxdWlyZSgnLi8kLnNhbWUnKVxuICAsIHNwZWNpZXMgICAgPSByZXF1aXJlKCcuLyQuc3BlY2llcycpXG4gICwgU1BFQ0lFUyAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpXG4gICwgUkVDT1JEICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKSgncmVjb3JkJylcbiAgLCBhc2FwICAgICAgID0gcmVxdWlyZSgnLi8kLm1pY3JvdGFzaycpXG4gICwgUFJPTUlTRSAgICA9ICdQcm9taXNlJ1xuICAsIHByb2Nlc3MgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIFAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBXcmFwcGVyO1xuXG52YXIgdGVzdFJlc29sdmUgPSBmdW5jdGlvbihzdWIpe1xuICB2YXIgdGVzdCA9IG5ldyBQKGZ1bmN0aW9uKCl7fSk7XG4gIGlmKHN1Yil0ZXN0LmNvbnN0cnVjdG9yID0gT2JqZWN0O1xuICByZXR1cm4gUC5yZXNvbHZlKHRlc3QpID09PSB0ZXN0O1xufTtcblxudmFyIHVzZU5hdGl2ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciB3b3JrcyA9IGZhbHNlO1xuICBmdW5jdGlvbiBQMih4KXtcbiAgICB2YXIgc2VsZiA9IG5ldyBQKHgpO1xuICAgIHNldFByb3RvKHNlbGYsIFAyLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdHJ5IHtcbiAgICB3b3JrcyA9IFAgJiYgUC5yZXNvbHZlICYmIHRlc3RSZXNvbHZlKCk7XG4gICAgc2V0UHJvdG8oUDIsIFApO1xuICAgIFAyLnByb3RvdHlwZSA9ICQuY3JlYXRlKFAucHJvdG90eXBlLCB7Y29uc3RydWN0b3I6IHt2YWx1ZTogUDJ9fSk7XG4gICAgLy8gYWN0dWFsIEZpcmVmb3ggaGFzIGJyb2tlbiBzdWJjbGFzcyBzdXBwb3J0LCB0ZXN0IHRoYXRcbiAgICBpZighKFAyLnJlc29sdmUoNSkudGhlbihmdW5jdGlvbigpe30pIGluc3RhbmNlb2YgUDIpKXtcbiAgICAgIHdvcmtzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFjdHVhbCBWOCBidWcsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTYyXG4gICAgaWYod29ya3MgJiYgcmVxdWlyZSgnLi8kLnN1cHBvcnQtZGVzYycpKXtcbiAgICAgIHZhciB0aGVuYWJsZVRoZW5Hb3R0ZW4gPSBmYWxzZTtcbiAgICAgIFAucmVzb2x2ZSgkLnNldERlc2Moe30sICd0aGVuJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHRoZW5hYmxlVGhlbkdvdHRlbiA9IHRydWU7IH1cbiAgICAgIH0pKTtcbiAgICAgIHdvcmtzID0gdGhlbmFibGVUaGVuR290dGVuO1xuICAgIH1cbiAgfSBjYXRjaChlKXsgd29ya3MgPSBmYWxzZTsgfVxuICByZXR1cm4gd29ya3M7XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1Byb21pc2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKHVzZU5hdGl2ZSA/IGNsYXNzb2YoaXQpID09ICdQcm9taXNlJyA6IFJFQ09SRCBpbiBpdCk7XG59O1xudmFyIHNhbWVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGEsIGIpe1xuICAvLyBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIGlmKExJQlJBUlkgJiYgYSA9PT0gUCAmJiBiID09PSBXcmFwcGVyKXJldHVybiB0cnVlO1xuICByZXR1cm4gc2FtZShhLCBiKTtcbn07XG52YXIgZ2V0Q29uc3RydWN0b3IgPSBmdW5jdGlvbihDKXtcbiAgdmFyIFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXTtcbiAgcmV0dXJuIFMgIT0gdW5kZWZpbmVkID8gUyA6IEM7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHJlY29yZCwgaXNSZWplY3Qpe1xuICBpZihyZWNvcmQubilyZXR1cm47XG4gIHJlY29yZC5uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcmVjb3JkLmM7XG4gIGFzYXAoZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSByZWNvcmQudlxuICAgICAgLCBvayAgICA9IHJlY29yZC5zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdCl7XG4gICAgICB2YXIgY2IgPSBvayA/IHJlYWN0Lm9rIDogcmVhY3QuZmFpbFxuICAgICAgICAsIHJldCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGNiKXtcbiAgICAgICAgICBpZighb2spcmVjb3JkLmggPSB0cnVlO1xuICAgICAgICAgIHJldCA9IGNiID09PSB0cnVlID8gdmFsdWUgOiBjYih2YWx1ZSk7XG4gICAgICAgICAgaWYocmV0ID09PSByZWFjdC5QKXtcbiAgICAgICAgICAgIHJlYWN0LnJlaihUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJldCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJldCwgcmVhY3QucmVzLCByZWFjdC5yZWopO1xuICAgICAgICAgIH0gZWxzZSByZWFjdC5yZXMocmV0KTtcbiAgICAgICAgfSBlbHNlIHJlYWN0LnJlaih2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgIHJlYWN0LnJlaihlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgY2hhaW4ubGVuZ3RoID0gMDtcbiAgICByZWNvcmQubiA9IGZhbHNlO1xuICAgIGlmKGlzUmVqZWN0KXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmKGlzVW5oYW5kbGVkKHJlY29yZC5wKSl7XG4gICAgICAgIGlmKGlzTm9kZSl7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcmVjb3JkLnApO1xuICAgICAgICB9IGVsc2UgaWYoZ2xvYmFsLmNvbnNvbGUgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IHJlY29yZC5hID0gdW5kZWZpbmVkO1xuICAgIH0sIDEpO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdmFyIHJlY29yZCA9IHByb21pc2VbUkVDT1JEXVxuICAgICwgY2hhaW4gID0gcmVjb3JkLmEgfHwgcmVjb3JkLmNcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlYWN0O1xuICBpZihyZWNvcmQuaClyZXR1cm4gZmFsc2U7XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0ID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdC5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdC5QKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciByZWNvcmQgPSB0aGlzO1xuICBpZihyZWNvcmQuZClyZXR1cm47XG4gIHJlY29yZC5kID0gdHJ1ZTtcbiAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcbiAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgcmVjb3JkLnMgPSAyO1xuICByZWNvcmQuYSA9IHJlY29yZC5jLnNsaWNlKCk7XG4gIG5vdGlmeShyZWNvcmQsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBhc2FwKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge3I6IHJlY29yZCwgZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZC52ID0gdmFsdWU7XG4gICAgICByZWNvcmQucyA9IDE7XG4gICAgICBub3RpZnkocmVjb3JkLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7cjogcmVjb3JkLCBkOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighdXNlTmF0aXZlKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgdmFyIHJlY29yZCA9IHtcbiAgICAgIHA6IHN0cmljdE5ldyh0aGlzLCBQLCBQUk9NSVNFKSwgICAgICAgICAvLyA8LSBwcm9taXNlXG4gICAgICBjOiBbXSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgICBhOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICAgIHM6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgICAgZDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICAgIHY6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgaDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGhhbmRsZWQgcmVqZWN0aW9uXG4gICAgICBuOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gICAgfTtcbiAgICB0aGlzW1JFQ09SRF0gPSByZWNvcmQ7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgcmVjb3JkLCAxKSwgY3R4KCRyZWplY3QsIHJlY29yZCwgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbChyZWNvcmQsIGVycik7XG4gICAgfVxuICB9O1xuICByZXF1aXJlKCcuLyQubWl4JykoUC5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIFMgPSBhbk9iamVjdChhbk9iamVjdCh0aGlzKS5jb25zdHJ1Y3RvcilbU1BFQ0lFU107XG4gICAgICB2YXIgcmVhY3QgPSB7XG4gICAgICAgIG9rOiAgIHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlLFxuICAgICAgICBmYWlsOiB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICA/IG9uUmVqZWN0ZWQgIDogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgcHJvbWlzZSA9IHJlYWN0LlAgPSBuZXcgKFMgIT0gdW5kZWZpbmVkID8gUyA6IFApKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgICAgcmVhY3QucmVzID0gYUZ1bmN0aW9uKHJlcyk7XG4gICAgICAgIHJlYWN0LnJlaiA9IGFGdW5jdGlvbihyZWopO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVjb3JkID0gdGhpc1tSRUNPUkRdO1xuICAgICAgcmVjb3JkLmMucHVzaChyZWFjdCk7XG4gICAgICBpZihyZWNvcmQuYSlyZWNvcmQuYS5wdXNoKHJlYWN0KTtcbiAgICAgIGlmKHJlY29yZC5zKW5vdGlmeShyZWNvcmQsIGZhbHNlKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBleHBvcnRcbiRkZWYoJGRlZi5HICsgJGRlZi5XICsgJGRlZi5GICogIXVzZU5hdGl2ZSwge1Byb21pc2U6IFB9KTtcbnJlcXVpcmUoJy4vJC50YWcnKShQLCBQUk9NSVNFKTtcbnNwZWNpZXMoUCk7XG5zcGVjaWVzKFdyYXBwZXIgPSByZXF1aXJlKCcuLyQuY29yZScpW1BST01JU0VdKTtcblxuLy8gc3RhdGljc1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbihyZXMsIHJlail7IHJlaihyKTsgfSk7XG4gIH1cbn0pO1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAoIXVzZU5hdGl2ZSB8fCB0ZXN0UmVzb2x2ZSh0cnVlKSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgcmV0dXJuIGlzUHJvbWlzZSh4KSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcylcbiAgICAgID8geCA6IG5ldyB0aGlzKGZ1bmN0aW9uKHJlcyl7IHJlcyh4KTsgfSk7XG4gIH1cbn0pO1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhKHVzZU5hdGl2ZSAmJiByZXF1aXJlKCcuLyQuaXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXtcbiAgUC5hbGwoaXRlcilbJ2NhdGNoJ10oZnVuY3Rpb24oKXt9KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxuICAgICAgLCB2YWx1ZXMgPSBbXTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCB2YWx1ZXMucHVzaCwgdmFsdWVzKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoXG4gICAgICAgICwgcmVzdWx0cyAgID0gQXJyYXkocmVtYWluaW5nKTtcbiAgICAgIGlmKHJlbWFpbmluZykkLmVhY2guY2FsbCh2YWx1ZXMsIGZ1bmN0aW9uKHByb21pc2UsIGluZGV4KXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzKHJlc3VsdHMpO1xuICAgICAgICB9LCByZWopO1xuICAgICAgfSk7XG4gICAgICBlbHNlIHJlcyhyZXN1bHRzKTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyA9IGdldENvbnN0cnVjdG9yKHRoaXMpO1xuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihyZXMsIHJlail7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihyZXMsIHJlaik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7IiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGRlZiAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgX2FwcGx5ID0gRnVuY3Rpb24uYXBwbHk7XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KXtcbiAgICByZXR1cm4gX2FwcGx5LmNhbGwodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpO1xuICB9XG59KTsiLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYmluZCAgICAgID0gRnVuY3Rpb24uYmluZCB8fCByZXF1aXJlKCcuLyQuY29yZScpLkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHNcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEoUmVmbGVjdC5jb25zdHJ1Y3QoZnVuY3Rpb24oKXt9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYoVGFyZ2V0ID09IG5ld1RhcmdldCl7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgaWYoYXJncyAhPSB1bmRlZmluZWQpc3dpdGNoKGFuT2JqZWN0KGFyZ3MpLmxlbmd0aCl7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQ7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvICAgID0gbmV3VGFyZ2V0LnByb3RvdHlwZVxuICAgICAgLCBpbnN0YW5jZSA9ICQuY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICwgcmVzdWx0ICAgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG5cbi8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2VcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSgkLnNldERlc2Moe30sIDEsIHt2YWx1ZTogMX0pLCAxLCB7dmFsdWU6IDJ9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgICQuc2V0RGVzYyh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgZ2V0RGVzYyAgPSByZXF1aXJlKCcuLyQnKS5nZXREZXNjXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gZ2V0RGVzYyhhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZGVmICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW10gICAgICAgLy8ga2V5c1xuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vJC5pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ID0gdGhpc1xuICAgICwga2V5cyA9IHRoYXQuX2tcbiAgICAsIGtleTtcbiAgZG8ge1xuICAgIGlmKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHt2YWx1ZToga2V5LCBkb25lOiBmYWxzZX07XG59KTtcblxuJGRlZigkZGVmLlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpe1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xuXG4kZGVmKCRkZWYuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiAkLmdldERlc2MoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTsiLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGRlZiAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBnZXRQcm90byA9IHJlcXVpcmUoJy4vJCcpLmdldFByb3RvXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCl7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTsiLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgJGRlZiAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleS8qLCByZWNlaXZlciovKXtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl1cbiAgICAsIGRlc2MsIHByb3RvO1xuICBpZihhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcilyZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYoZGVzYyA9ICQuZ2V0RGVzYyh0YXJnZXQsIHByb3BlcnR5S2V5KSlyZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYoaXNPYmplY3QocHJvdG8gPSAkLmdldFByb3RvKHRhcmdldCkpKXJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHtnZXQ6IGdldH0pOyIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7IiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGRlZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGFuT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGRlZigkZGVmLlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTsiLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlMsICdSZWZsZWN0Jywge293bktleXM6IHJlcXVpcmUoJy4vJC5vd24ta2V5cycpfSk7IiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZGVmICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYoJHByZXZlbnRFeHRlbnNpb25zKSRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgc2V0UHJvdG8gPSByZXF1aXJlKCcuLyQuc2V0LXByb3RvJyk7XG5cbmlmKHNldFByb3RvKSRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pe1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBoYXMgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgJGRlZiAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWLyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxuICAgICwgb3duRGVzYyAgPSAkLmdldERlc2MoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXG4gICAgLCBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZighb3duRGVzYyl7XG4gICAgaWYoaXNPYmplY3QocHJvdG8gPSAkLmdldFByb3RvKHRhcmdldCkpKXtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmKGhhcyhvd25EZXNjLCAndmFsdWUnKSl7XG4gICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gJC5nZXREZXNjKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgY3JlYXRlRGVzYygwKTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgICQuc2V0RGVzYyhyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHtzZXQ6IHNldH0pOyIsInZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBnbG9iYWwgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgY29mICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRmbGFncyAgPSByZXF1aXJlKCcuLyQuZmxhZ3MnKVxuICAsICRSZWdFeHAgPSBnbG9iYWwuUmVnRXhwXG4gICwgQmFzZSAgICA9ICRSZWdFeHBcbiAgLCBwcm90byAgID0gJFJlZ0V4cC5wcm90b3R5cGVcbiAgLCByZSAgICAgID0gL2EvZ1xuICAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0XG4gICwgQ09SUkVDVF9ORVcgPSBuZXcgJFJlZ0V4cChyZSkgIT09IHJlXG4gIC8vIFJlZ0V4cCBhbGxvd3MgYSByZWdleCB3aXRoIGZsYWdzIGFzIHRoZSBwYXR0ZXJuXG4gICwgQUxMT1dTX1JFX1dJVEhfRkxBR1MgPSBmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gJFJlZ0V4cChyZSwgJ2knKSA9PSAnL2EvaSc7XG4gICAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICB9KCk7XG5cbmlmKHJlcXVpcmUoJy4vJC5zdXBwb3J0LWRlc2MnKSl7XG4gIGlmKCFDT1JSRUNUX05FVyB8fCAhQUxMT1dTX1JFX1dJVEhfRkxBR1Mpe1xuICAgICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocGF0dGVybiwgZmxhZ3Mpe1xuICAgICAgdmFyIHBhdHRlcm5Jc1JlZ0V4cCAgPSBjb2YocGF0dGVybikgPT0gJ1JlZ0V4cCdcbiAgICAgICAgLCBmbGFnc0lzVW5kZWZpbmVkID0gZmxhZ3MgPT09IHVuZGVmaW5lZDtcbiAgICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mICRSZWdFeHApICYmIHBhdHRlcm5Jc1JlZ0V4cCAmJiBmbGFnc0lzVW5kZWZpbmVkKXJldHVybiBwYXR0ZXJuO1xuICAgICAgcmV0dXJuIENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGF0dGVybklzUmVnRXhwICYmICFmbGFnc0lzVW5kZWZpbmVkID8gcGF0dGVybi5zb3VyY2UgOiBwYXR0ZXJuLCBmbGFncylcbiAgICAgICAgOiBuZXcgQmFzZShwYXR0ZXJuSXNSZWdFeHAgPyBwYXR0ZXJuLnNvdXJjZSA6IHBhdHRlcm5cbiAgICAgICAgICAsIHBhdHRlcm5Jc1JlZ0V4cCAmJiBmbGFnc0lzVW5kZWZpbmVkID8gJGZsYWdzLmNhbGwocGF0dGVybikgOiBmbGFncyk7XG4gICAgfTtcbiAgICAkLmVhY2guY2FsbCgkLmdldE5hbWVzKEJhc2UpLCBmdW5jdGlvbihrZXkpe1xuICAgICAga2V5IGluICRSZWdFeHAgfHwgJC5zZXREZXNjKCRSZWdFeHAsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgICByZXF1aXJlKCcuLyQucmVkZWYnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbiAgfVxufVxuXG5yZXF1aXJlKCcuLyQuc3BlY2llcycpKCRSZWdFeHApOyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbnZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5pZihyZXF1aXJlKCcuLyQuc3VwcG9ydC1kZXNjJykgJiYgLy4vZy5mbGFncyAhPSAnZycpJC5zZXREZXNjKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vJC5mbGFncycpXG59KTsiLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuLyQuZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIE1BVENIKXtcbiAgLy8gMjEuMS4zLjExIFN0cmluZy5wcm90b3R5cGUubWF0Y2gocmVnZXhwKVxuICByZXR1cm4gZnVuY3Rpb24gbWF0Y2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9O1xufSk7IiwiLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuLyQuZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2Upe1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH07XG59KTsiLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi8kLmZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgU0VBUkNIKXtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYXJjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfTtcbn0pOyIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vJC5maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgU1BMSVQsICRzcGxpdCl7XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50c1swXSk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJGF0ICA9IHJlcXVpcmUoJy4vJC5zdHJpbmctYXQnKShmYWxzZSk7XG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuLyQudG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICA9IHJlcXVpcmUoJy4vJC5zdHJpbmctY29udGV4dCcpO1xuXG4vLyBzaG91bGQgdGhyb3cgZXJyb3Igb24gcmVnZXhcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogIXJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7ICdxJy5lbmRzV2l0aCgvLi8pOyB9KSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsICdlbmRzV2l0aCcpXG4gICAgICAsIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzWzFdXG4gICAgICAsIGxlbiAgICA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxuICAgICAgLCBlbmQgICAgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7IiwidmFyICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCB0b0luZGV4ID0gcmVxdWlyZSgnLi8kLnRvLWluZGV4JylcbiAgLCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICwgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzID0gW11cbiAgICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBpICAgPSAwXG4gICAgICAsIGNvZGU7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYodG9JbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBjb250ZXh0ID0gcmVxdWlyZSgnLi8kLnN0cmluZy1jb250ZXh0Jyk7XG5cbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgJ2luY2x1ZGVzJykuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTsiLCJ2YXIgJGRlZiAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vJC50by1sZW5ndGgnKTtcblxuJGRlZigkZGVmLlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdylcbiAgICAgICwgbGVuID0gdG9MZW5ndGgodHBsLmxlbmd0aClcbiAgICAgICwgc2xuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgPSBbXVxuICAgICAgLCBpICAgPSAwO1xuICAgIHdoaWxlKGxlbiA+IGkpe1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZihpIDwgc2xuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsInZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vJC5zdHJpbmctcmVwZWF0Jylcbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWNvbnRleHQnKTtcblxuLy8gc2hvdWxkIHRocm93IGVycm9yIG9uIHJlZ2V4XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqICFyZXF1aXJlKCcuLyQuZmFpbHMnKShmdW5jdGlvbigpeyAncScuc3RhcnRzV2l0aCgvLi8pOyB9KSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgdmFyIHRoYXQgICA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCAnc3RhcnRzV2l0aCcpXG4gICAgICAsIGluZGV4ICA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50c1sxXSwgdGhhdC5sZW5ndGgpKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vJC5zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIFNVUFBPUlRfREVTQyAgID0gcmVxdWlyZSgnLi8kLnN1cHBvcnQtZGVzYycpXG4gICwgJGRlZiAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcmVkZWYgICAgICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZicpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJylcbiAgLCBzZXRUYWcgICAgICAgICA9IHJlcXVpcmUoJy4vJC50YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQud2tzJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5rZXlvZicpXG4gICwgJG5hbWVzICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2V0LW5hbWVzJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vJC5lbnVtLWtleXMnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vJC5wcm9wZXJ0eS1kZXNjJylcbiAgLCBnZXREZXNjICAgICAgICA9ICQuZ2V0RGVzY1xuICAsIHNldERlc2MgICAgICAgID0gJC5zZXREZXNjXG4gICwgX2NyZWF0ZSAgICAgICAgPSAkLmNyZWF0ZVxuICAsIGdldE5hbWVzICAgICAgID0gJG5hbWVzLmdldFxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsIHNldHRlciAgICAgICAgID0gZmFsc2VcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgaXNFbnVtICAgICAgICAgPSAkLmlzRW51bVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCB1c2VOYXRpdmUgICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdC5wcm90b3R5cGU7XG5cbnZhciBzZXRTeW1ib2xEZXNjID0gU1VQUE9SVF9ERVNDID8gZnVuY3Rpb24oKXsgLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkXG4gIHRyeSB7XG4gICAgcmV0dXJuIF9jcmVhdGUoc2V0RGVzYyh7fSwgSElEREVOLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzZXREZXNjKHRoaXMsIEhJRERFTiwge3ZhbHVlOiBmYWxzZX0pW0hJRERFTl07XG4gICAgICB9XG4gICAgfSkpW0hJRERFTl0gfHwgc2V0RGVzYztcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gICAgICB2YXIgcHJvdG9EZXNjID0gZ2V0RGVzYyhPYmplY3RQcm90bywga2V5KTtcbiAgICAgIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgICAgIHNldERlc2MoaXQsIGtleSwgRCk7XG4gICAgICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKXNldERlc2MoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbiAgICB9O1xuICB9XG59KCkgOiBzZXREZXNjO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2wucHJvdG90eXBlKTtcbiAgc3ltLl9rID0gdGFnO1xuICBTVVBQT1JUX0RFU0MgJiYgc2V0dGVyICYmIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKXNldERlc2MoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIHNldERlc2MoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSk7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV1cbiAgICA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b0lPYmplY3QoaXQpLCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIXVzZU5hdGl2ZSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHJldHVybiB3cmFwKHVpZChhcmd1bWVudHNbMF0pKTtcbiAgfTtcbiAgJHJlZGVmKCRTeW1ib2wucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkLmNyZWF0ZSAgICAgPSAkY3JlYXRlO1xuICAkLmlzRW51bSAgICAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICQuZ2V0RGVzYyAgICA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICQuc2V0RGVzYyAgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgJC5zZXREZXNjcyAgID0gJGRlZmluZVByb3BlcnRpZXM7XG4gICQuZ2V0TmFtZXMgICA9ICRuYW1lcy5nZXQgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgJC5nZXRTeW1ib2xzID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihTVVBQT1JUX0RFU0MgJiYgIXJlcXVpcmUoJy4vJC5saWJyYXJ5Jykpe1xuICAgICRyZWRlZihPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxufVxuXG4vLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgaW4gb2JqZWN0cyB0byBKU09OIGFzIG51bGxcbmlmKCF1c2VOYXRpdmUgfHwgcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFt7YTogJFN5bWJvbCgpfSwgWyRTeW1ib2woKV1dKSAhPSAnW3t9LFtudWxsXV0nO1xufSkpJHJlZGVmKCRTeW1ib2wucHJvdG90eXBlLCAndG9KU09OJywgZnVuY3Rpb24gdG9KU09OKCl7XG4gIGlmKHVzZU5hdGl2ZSAmJiBpc09iamVjdCh0aGlzKSlyZXR1cm4gdGhpcztcbn0pO1xuXG52YXIgc3ltYm9sU3RhdGljcyA9IHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufTtcbi8vIDE5LjQuMi4yIFN5bWJvbC5oYXNJbnN0YW5jZVxuLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxuLy8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXG4vLyAxOS40LjIuNiBTeW1ib2wubWF0Y2hcbi8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXG4vLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXG4vLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcbi8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcbi8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcbi8vIDE5LjQuMi4xMyBTeW1ib2wudG9TdHJpbmdUYWdcbi8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcbiQuZWFjaC5jYWxsKChcbiAgICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLCcgK1xuICAgICdzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuICApLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgc3ltID0gd2tzKGl0KTtcbiAgICBzeW1ib2xTdGF0aWNzW2l0XSA9IHVzZU5hdGl2ZSA/IHN5bSA6IHdyYXAoc3ltKTtcbiAgfVxuKTtcblxuc2V0dGVyID0gdHJ1ZTtcblxuJGRlZigkZGVmLkcgKyAkZGVmLlcsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuJGRlZigkZGVmLlMsICdTeW1ib2wnLCBzeW1ib2xTdGF0aWNzKTtcblxuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB3ZWFrICAgICAgICAgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi13ZWFrJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBmcm96ZW5TdG9yZSAgPSB3ZWFrLmZyb3plblN0b3JlXG4gICwgV0VBSyAgICAgICAgID0gd2Vhay5XRUFLXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBpc09iamVjdFxuICAsIHRtcCAgICAgICAgICA9IHt9O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnV2Vha01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzWzBdKTsgfTtcbn0sIHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICBpZihpc09iamVjdChrZXkpKXtcbiAgICAgIGlmKCFpc0V4dGVuc2libGUoa2V5KSlyZXR1cm4gZnJvemVuU3RvcmUodGhpcykuZ2V0KGtleSk7XG4gICAgICBpZihoYXMoa2V5LCBXRUFLKSlyZXR1cm4ga2V5W1dFQUtdW3RoaXMuX2ldO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCBrZXksIHZhbHVlKTtcbiAgfVxufSwgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmKG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICAkLmVhY2guY2FsbChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZXF1aXJlKCcuLyQucmVkZWYnKShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGxlYWt5IG1hcFxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIHZhciByZXN1bHQgPSBmcm96ZW5TdG9yZSh0aGlzKVtrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24td2VhaycpO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnV2Vha1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzWzBdKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkaW5jbHVkZXMgPSByZXF1aXJlKCcuLyQuYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcbiRkZWYoJGRlZi5QLCAnQXJyYXknLCB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21lbmljL0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi8kLnVuc2NvcGUnKSgnaW5jbHVkZXMnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5QLCAnTWFwJywge3RvSlNPTjogcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pOyIsIi8vIGh0dHA6Ly9nb28uZ2wvWGtCcmpEXG52YXIgJGRlZiAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkZW50cmllcyA9IHJlcXVpcmUoJy4vJC5vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpe1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vOTM1Mzc4MVxudmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBvd25LZXlzICAgID0gcmVxdWlyZSgnLi8kLm93bi1rZXlzJylcbiAgLCB0b0lPYmplY3QgID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpO1xuXG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAgICwgc2V0RGVzYyA9ICQuc2V0RGVzY1xuICAgICAgLCBnZXREZXNjID0gJC5nZXREZXNjXG4gICAgICAsIGtleXMgICAgPSBvd25LZXlzKE8pXG4gICAgICAsIHJlc3VsdCAgPSB7fVxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXksIEQ7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiBpKXtcbiAgICAgIEQgPSBnZXREZXNjKE8sIGtleSA9IGtleXNbaSsrXSk7XG4gICAgICBpZihrZXkgaW4gcmVzdWx0KXNldERlc2MocmVzdWx0LCBrZXksIGNyZWF0ZURlc2MoMCwgRCkpO1xuICAgICAgZWxzZSByZXN1bHRba2V5XSA9IEQ7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCIvLyBodHRwOi8vZ29vLmdsL1hrQnJqRFxudmFyICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkdmFsdWVzID0gcmVxdWlyZSgnLi8kLm9iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KXtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JleEV4cC5lc2NhcGVcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHJlICA9IHJlcXVpcmUoJy4vJC5yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuJGRlZigkZGVmLlMsICdSZWdFeHAnLCB7ZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoaXQpeyByZXR1cm4gJHJlKGl0KTsgfX0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUCwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4ndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykodHJ1ZSk7XG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRwYWQgPSByZXF1aXJlKCcuLyQuc3RyaW5nLXBhZCcpO1xuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIHBhZExlZnQ6IGZ1bmN0aW9uIHBhZExlZnQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHBhZCA9IHJlcXVpcmUoJy4vJC5zdHJpbmctcGFkJyk7XG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgcGFkUmlnaHQ6IGZ1bmN0aW9uIHBhZFJpZ2h0KG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi8kLnN0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuLyQuc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSk7IiwiLy8gSmF2YVNjcmlwdCAxLjYgLyBTdHJhd21hbiBhcnJheSBzdGF0aWNzIHNoaW1cbnZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJEFycmF5ICA9IHJlcXVpcmUoJy4vJC5jb3JlJykuQXJyYXkgfHwgQXJyYXlcbiAgLCBzdGF0aWNzID0ge307XG52YXIgc2V0U3RhdGljcyA9IGZ1bmN0aW9uKGtleXMsIGxlbmd0aCl7XG4gICQuZWFjaC5jYWxsKGtleXMuc3BsaXQoJywnKSwgZnVuY3Rpb24oa2V5KXtcbiAgICBpZihsZW5ndGggPT0gdW5kZWZpbmVkICYmIGtleSBpbiAkQXJyYXkpc3RhdGljc1trZXldID0gJEFycmF5W2tleV07XG4gICAgZWxzZSBpZihrZXkgaW4gW10pc3RhdGljc1trZXldID0gcmVxdWlyZSgnLi8kLmN0eCcpKEZ1bmN0aW9uLmNhbGwsIFtdW2tleV0sIGxlbmd0aCk7XG4gIH0pO1xufTtcbnNldFN0YXRpY3MoJ3BvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMnLCAxKTtcbnNldFN0YXRpY3MoJ2luZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMnLCAzKTtcbnNldFN0YXRpY3MoJ2pvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZiwnICtcbiAgICAgICAgICAgJ3JlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGwnKTtcbiRkZWYoJGRlZi5TLCAnQXJyYXknLCBzdGF0aWNzKTsiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgSXRlcmF0b3JzICAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIE5MICAgICAgICAgID0gZ2xvYmFsLk5vZGVMaXN0XG4gICwgSFRDICAgICAgICAgPSBnbG9iYWwuSFRNTENvbGxlY3Rpb25cbiAgLCBOTFByb3RvICAgICA9IE5MICYmIE5MLnByb3RvdHlwZVxuICAsIEhUQ1Byb3RvICAgID0gSFRDICYmIEhUQy5wcm90b3R5cGVcbiAgLCBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9ycy5IVE1MQ29sbGVjdGlvbiA9IEl0ZXJhdG9ycy5BcnJheTtcbmlmKE5MICYmICEoSVRFUkFUT1IgaW4gTkxQcm90bykpaGlkZShOTFByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuaWYoSFRDICYmICEoSVRFUkFUT1IgaW4gSFRDUHJvdG8pKWhpZGUoSFRDUHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7IiwidmFyICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHRhc2sgPSByZXF1aXJlKCcuLyQudGFzaycpO1xuJGRlZigkZGVmLkcgKyAkZGVmLkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAgICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTsiLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsICRkZWYgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgcGFydGlhbCAgICA9IHJlcXVpcmUoJy4vJC5wYXJ0aWFsJylcbiAgLCBuYXZpZ2F0b3IgID0gZ2xvYmFsLm5hdmlnYXRvclxuICAsIE1TSUUgICAgICAgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHNldCl7XG4gIHJldHVybiBNU0lFID8gZnVuY3Rpb24oZm4sIHRpbWUgLyosIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBzZXQoaW52b2tlKFxuICAgICAgcGFydGlhbCxcbiAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgIHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbilcbiAgICApLCB0aW1lKTtcbiAgfSA6IHNldDtcbn07XG4kZGVmKCRkZWYuRyArICRkZWYuQiArICRkZWYuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogIHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTsiLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM1Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVnZXhwLmVzY2FwZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvanMuYXJyYXkuc3RhdGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvJC5jb3JlJyk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoXG4gICAgICBpbm5lckZuLCBzZWxmIHx8IG51bGwsXG4gICAgICBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSlcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF3YWl0QXJndW1lbnQoYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBd2FpdEFyZ3VtZW50KGFyZykge1xuICAgIHRoaXMuYXJnID0gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAvLyBUaGlzIGludm9rZSBmdW5jdGlvbiBpcyB3cml0dGVuIGluIGEgc3R5bGUgdGhhdCBhc3N1bWVzIHNvbWVcbiAgICAvLyBjYWxsaW5nIGZ1bmN0aW9uIChvciBQcm9taXNlKSB3aWxsIGhhbmRsZSBleGNlcHRpb25zLlxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IGdlbmVyYXRvclttZXRob2RdKGFyZyk7XG4gICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50XG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihpbnZva2VOZXh0LCBpbnZva2VUaHJvdylcbiAgICAgICAgOiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIGludm9rZU5leHQgPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwibmV4dFwiKTtcbiAgICB2YXIgaW52b2tlVGhyb3cgPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwidGhyb3dcIik7XG4gICAgdmFyIGludm9rZVJldHVybiA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJyZXR1cm5cIik7XG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciBlbnF1ZXVlUmVzdWx0ID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBpbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgICB9KSA6IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKGludm9rZShtZXRob2QsIGFyZykpO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZW5xdWV1ZVJlc3VsdCBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieVxuICAgICAgLy8gbGF0ZXIgaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgcHJldmlvdXNQcm9taXNlID0gZW5xdWV1ZVJlc3VsdFtcImNhdGNoXCJdKGZ1bmN0aW9uKGlnbm9yZWQpe30pO1xuXG4gICAgICByZXR1cm4gZW5xdWV1ZVJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL3BvbHlmaWxsXCIpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtY29yZS9wb2x5ZmlsbFwiKTtcbiIsbnVsbCwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKipcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgQnVmZmVyXG4gKlxuICogQXV0aG9yOiAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBMaWNlbnNlOiAgTUlUXG4gKlxuICogYG5wbSBpbnN0YWxsIGlzLWJ1ZmZlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmXG4gICAgKG9iai5faXNCdWZmZXIgfHwgLy8gRm9yIFNhZmFyaSA1LTcgKG1pc3NpbmcgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgIChvYmouY29uc3RydWN0b3IgJiZcbiAgICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKVxuICAgICkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpXG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKXt0cnl7XG4gIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG59Y2F0Y2goXyl7fWZpbmFsbHl7XG4gIGlmICghU3RyZWFtKVxuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbn19KCkpXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ3V0aWwnKTtcbmlmIChkZWJ1ZyAmJiBkZWJ1Zy5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKVxuICAgIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udClcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH1cblxuICBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgaWYgKHJldCAhPT0gbnVsbClcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpICYmXG4gICAgICB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKVxuICAgICAgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiZcbiAgICAgICAgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSlcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLFxuICAgICAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbilcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfTsgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZClcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKXt0cnl7XG4gIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG59Y2F0Y2goXyl7fWZpbmFsbHl7XG4gIGlmICghU3RyZWFtKVxuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbn19KCkpXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpe3RyeSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gIGdldDogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgJyArXG4gICAgICAnX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCkgaW5zdGVhZC4nKVxufSk7XG59Y2F0Y2goXyl7fX0oKSk7XG5cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG5cbiAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgJiZcbiAgICAgIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpXG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLFxuJ3VjczInLCAndWNzLTInLCd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddXG4uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KVxuICAgIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtcbiAgZWxzZVxuICAgIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgZWxzZVxuICAgIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzTmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgY2JzID0gW107XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBjYnMucHVzaChlbnRyeS5jYWxsYmFjayk7XG4gICAgICBidWZmZXIucHVzaChlbnRyeSk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbClcbiAgICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzTmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihhcmcpO1xufVxuZXhwb3J0cy5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59IiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcblxuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gIH1cbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gIH0pO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcbiAqICAgICBvbiBvYmplY3RzLlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCB8IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kIHwgMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0KSB7XG4gIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgYnl0ZU9mZnNldCA+Pj0gMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG4gIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldCwgMClcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nIGFsd2F5cyBmYWlsc1xuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0KSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltieXRlT2Zmc2V0ICsgaV0gPT09IHZhbFtmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWwubGVuZ3RoKSByZXR1cm4gYnl0ZU9mZnNldCArIGZvdW5kSW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDAgfCAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8qIE1JVCBsaWNlbnNlICovXG52YXIgY29sb3JOYW1lcyA9IHJlcXVpcmUoJ2NvbG9yLW5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICBnZXRSZ2JhOiBnZXRSZ2JhLFxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcbiAgIGdldFJnYjogZ2V0UmdiLFxuICAgZ2V0SHNsOiBnZXRIc2wsXG4gICBnZXRId2I6IGdldEh3YixcbiAgIGdldEFscGhhOiBnZXRBbHBoYSxcblxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXG4gICByZ2JTdHJpbmc6IHJnYlN0cmluZyxcbiAgIHJnYmFTdHJpbmc6IHJnYmFTdHJpbmcsXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxuICAgcGVyY2VudGFTdHJpbmc6IHBlcmNlbnRhU3RyaW5nLFxuICAgaHNsU3RyaW5nOiBoc2xTdHJpbmcsXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxuICAgaHdiU3RyaW5nOiBod2JTdHJpbmcsXG4gICBrZXl3b3JkOiBrZXl3b3JkXG59XG5cbmZ1bmN0aW9uIGdldFJnYmEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGFiYnIgPSAgL14jKFthLWZBLUYwLTldezN9KSQvLFxuICAgICAgIGhleCA9ICAvXiMoW2EtZkEtRjAtOV17Nn0pJC8sXG4gICAgICAgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvLFxuICAgICAgIHBlciA9IC9ecmdiYT9cXChcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvLFxuICAgICAgIGtleXdvcmQgPSAvKFxcRCspLztcblxuICAgdmFyIHJnYiA9IFswLCAwLCAwXSxcbiAgICAgICBhID0gMSxcbiAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpXSArIG1hdGNoW2ldLCAxNik7XG4gICAgICB9XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChoZXgpKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChyZ2JhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2kgKyAxXSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChwZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG1hdGNoW2kgKyAxXSkgKiAyLjU1KTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGtleXdvcmQpKSB7XG4gICAgICBpZiAobWF0Y2hbMV0gPT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgICAgcmdiID0gY29sb3JOYW1lc1ttYXRjaFsxXV07XG4gICAgICBpZiAoIXJnYikge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgfVxuXG4gICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgcmdiW2ldID0gc2NhbGUocmdiW2ldLCAwLCAyNTUpO1xuICAgfVxuICAgaWYgKCFhICYmIGEgIT0gMCkge1xuICAgICAgYSA9IDE7XG4gICB9XG4gICBlbHNlIHtcbiAgICAgIGEgPSBzY2FsZShhLCAwLCAxKTtcbiAgIH1cbiAgIHJnYlszXSA9IGE7XG4gICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBnZXRIc2xhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBoc2wgPSAvXmhzbGE/XFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICBzID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgbCA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCBzLCBsLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SHdiKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBod2IgPSAvXmh3YlxcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGh3Yik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHcgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBiID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZ2Ioc3RyaW5nKSB7XG4gICB2YXIgcmdiYSA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIHJldHVybiByZ2JhICYmIHJnYmEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEhzbChzdHJpbmcpIHtcbiAgdmFyIGhzbGEgPSBnZXRIc2xhKHN0cmluZyk7XG4gIHJldHVybiBoc2xhICYmIGhzbGEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEFscGhhKHN0cmluZykge1xuICAgdmFyIHZhbHMgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICBpZiAodmFscykge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHNsYShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRId2Ioc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG59XG5cbi8vIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIGhleFN0cmluZyhyZ2IpIHtcbiAgIHJldHVybiBcIiNcIiArIGhleERvdWJsZShyZ2JbMF0pICsgaGV4RG91YmxlKHJnYlsxXSlcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiWzJdKTtcbn1cblxuZnVuY3Rpb24gcmdiU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChyZ2JhWzNdICE9PSB1bmRlZmluZWQgPyByZ2JhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdXG4gICAgICAgICAgICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudFN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG5cbiAgIHJldHVybiBcInJnYihcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlLCBcIiArIChhbHBoYSB8fCByZ2JhWzNdIHx8IDEpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbFN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAoaHNsYVszXSAmJiBoc2xhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbChcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChoc2xhWzNdICE9PSB1bmRlZmluZWQgPyBoc2xhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2xhKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSwgXCJcbiAgICAgICAgICAgKyBhbHBoYSArIFwiKVwiO1xufVxuXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxuLy8gKGh3YiBoYXZlIGFscGhhIG9wdGlvbmFsICYgMSBpcyBkZWZhdWx0IHZhbHVlKVxuZnVuY3Rpb24gaHdiU3RyaW5nKGh3YiwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChod2JbM10gIT09IHVuZGVmaW5lZCA/IGh3YlszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHdiKFwiICsgaHdiWzBdICsgXCIsIFwiICsgaHdiWzFdICsgXCIlLCBcIiArIGh3YlsyXSArIFwiJVwiXG4gICAgICAgICAgICsgKGFscGhhICE9PSB1bmRlZmluZWQgJiYgYWxwaGEgIT09IDEgPyBcIiwgXCIgKyBhbHBoYSA6IFwiXCIpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn1cblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gc2NhbGUobnVtLCBtaW4sIG1heCkge1xuICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxuXG5cbi8vY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG52YXIgcmV2ZXJzZU5hbWVzID0ge307XG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZXMpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWVzW25hbWVdXSA9IG5hbWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59IiwiLypcblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbk9yaWdpbmFsIExpYnJhcnkgXG4gIC0gQ29weXJpZ2h0IChjKSBNYXJhayBTcXVpcmVzXG5cbkFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eVxuIC0gQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgY29sb3JzID0ge307XG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGNvbG9ycztcblxuY29sb3JzLnRoZW1lcyA9IHt9O1xuXG52YXIgYW5zaVN0eWxlcyA9IGNvbG9ycy5zdHlsZXMgPSByZXF1aXJlKCcuL3N0eWxlcycpO1xudmFyIGRlZmluZVByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG5cbmNvbG9ycy5zdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnLi9zeXN0ZW0vc3VwcG9ydHMtY29sb3JzJyk7XG5cbmlmICh0eXBlb2YgY29sb3JzLmVuYWJsZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgY29sb3JzLmVuYWJsZWQgPSBjb2xvcnMuc3VwcG9ydHNDb2xvcjtcbn1cblxuY29sb3JzLnN0cmlwQ29sb3JzID0gY29sb3JzLnN0cmlwID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIChcIlwiICsgc3RyKS5yZXBsYWNlKC9cXHgxQlxcW1xcZCttL2csICcnKTtcbn07XG5cblxudmFyIHN0eWxpemUgPSBjb2xvcnMuc3R5bGl6ZSA9IGZ1bmN0aW9uIHN0eWxpemUgKHN0ciwgc3R5bGUpIHtcbiAgaWYgKCFjb2xvcnMuZW5hYmxlZCkge1xuICAgIHJldHVybiBzdHIrJyc7XG4gIH1cblxuICByZXR1cm4gYW5zaVN0eWxlc1tzdHlsZV0ub3BlbiArIHN0ciArIGFuc2lTdHlsZXNbc3R5bGVdLmNsb3NlO1xufVxuXG52YXIgbWF0Y2hPcGVyYXRvcnNSZSA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZztcbnZhciBlc2NhcGVTdHJpbmdSZWdleHAgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkKF9zdHlsZXMpIHtcbiAgdmFyIGJ1aWxkZXIgPSBmdW5jdGlvbiBidWlsZGVyKCkge1xuICAgIHJldHVybiBhcHBseVN0eWxlLmFwcGx5KGJ1aWxkZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGJ1aWxkZXIuX3N0eWxlcyA9IF9zdHlsZXM7XG4gIC8vIF9fcHJvdG9fXyBpcyB1c2VkIGJlY2F1c2Ugd2UgbXVzdCByZXR1cm4gYSBmdW5jdGlvbiwgYnV0IHRoZXJlIGlzXG4gIC8vIG5vIHdheSB0byBjcmVhdGUgYSBmdW5jdGlvbiB3aXRoIGEgZGlmZmVyZW50IHByb3RvdHlwZS5cbiAgYnVpbGRlci5fX3Byb3RvX18gPSBwcm90bztcbiAgcmV0dXJuIGJ1aWxkZXI7XG59XG5cbnZhciBzdHlsZXMgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmV0ID0ge307XG4gIGFuc2lTdHlsZXMuZ3JleSA9IGFuc2lTdHlsZXMuZ3JheTtcbiAgT2JqZWN0LmtleXMoYW5zaVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgYW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzW2tleV0uY2xvc2UpLCAnZycpO1xuICAgIHJldFtrZXldID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBidWlsZCh0aGlzLl9zdHlsZXMuY29uY2F0KGtleSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufSkoKTtcblxudmFyIHByb3RvID0gZGVmaW5lUHJvcHMoZnVuY3Rpb24gY29sb3JzKCkge30sIHN0eWxlcyk7XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gYXJnc0xlbiAhPT0gMCAmJiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGFyZ3NMZW4gPiAxKSB7XG4gICAgZm9yICh2YXIgYSA9IDE7IGEgPCBhcmdzTGVuOyBhKyspIHtcbiAgICAgIHN0ciArPSAnICcgKyBhcmdzW2FdO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29sb3JzLmVuYWJsZWQgfHwgIXN0cikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgbmVzdGVkU3R5bGVzID0gdGhpcy5fc3R5bGVzO1xuXG4gIHZhciBpID0gbmVzdGVkU3R5bGVzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBjb2RlID0gYW5zaVN0eWxlc1tuZXN0ZWRTdHlsZXNbaV1dO1xuICAgIHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBhcHBseVRoZW1lICh0aGVtZSkge1xuICBmb3IgKHZhciBzdHlsZSBpbiB0aGVtZSkge1xuICAgIChmdW5jdGlvbihzdHlsZSl7XG4gICAgICBjb2xvcnNbc3R5bGVdID0gZnVuY3Rpb24oc3RyKXtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVtZVtzdHlsZV0gPT09ICdvYmplY3QnKXtcbiAgICAgICAgICB2YXIgb3V0ID0gc3RyO1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhlbWVbc3R5bGVdKXtcbiAgICAgICAgICAgIG91dCA9IGNvbG9yc1t0aGVtZVtzdHlsZV1baV1dKG91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yc1t0aGVtZVtzdHlsZV1dKHN0cik7XG4gICAgICB9O1xuICAgIH0pKHN0eWxlKVxuICB9XG59XG5cbmNvbG9ycy5zZXRUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSkge1xuICBpZiAodHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBjb2xvcnMudGhlbWVzW3RoZW1lXSA9IHJlcXVpcmUodGhlbWUpO1xuICAgICAgYXBwbHlUaGVtZShjb2xvcnMudGhlbWVzW3RoZW1lXSk7XG4gICAgICByZXR1cm4gY29sb3JzLnRoZW1lc1t0aGVtZV07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXBwbHlUaGVtZSh0aGVtZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0W25hbWVdID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBidWlsZChbbmFtZV0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG52YXIgc2VxdWVuY2VyID0gZnVuY3Rpb24gc2VxdWVuY2VyIChtYXAsIHN0cikge1xuICB2YXIgZXhwbG9kZWQgPSBzdHIuc3BsaXQoXCJcIiksIGkgPSAwO1xuICBleHBsb2RlZCA9IGV4cGxvZGVkLm1hcChtYXApO1xuICByZXR1cm4gZXhwbG9kZWQuam9pbihcIlwiKTtcbn07XG5cbi8vIGN1c3RvbSBmb3JtYXR0ZXIgbWV0aG9kc1xuY29sb3JzLnRyYXAgPSByZXF1aXJlKCcuL2N1c3RvbS90cmFwJyk7XG5jb2xvcnMuemFsZ28gPSByZXF1aXJlKCcuL2N1c3RvbS96YWxnbycpO1xuXG4vLyBtYXBzXG5jb2xvcnMubWFwcyA9IHt9O1xuY29sb3JzLm1hcHMuYW1lcmljYSA9IHJlcXVpcmUoJy4vbWFwcy9hbWVyaWNhJyk7XG5jb2xvcnMubWFwcy56ZWJyYSA9IHJlcXVpcmUoJy4vbWFwcy96ZWJyYScpO1xuY29sb3JzLm1hcHMucmFpbmJvdyA9IHJlcXVpcmUoJy4vbWFwcy9yYWluYm93Jyk7XG5jb2xvcnMubWFwcy5yYW5kb20gPSByZXF1aXJlKCcuL21hcHMvcmFuZG9tJylcblxuZm9yICh2YXIgbWFwIGluIGNvbG9ycy5tYXBzKSB7XG4gIChmdW5jdGlvbihtYXApe1xuICAgIGNvbG9yc1ttYXBdID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlcihjb2xvcnMubWFwc1ttYXBdLCBzdHIpO1xuICAgIH1cbiAgfSkobWFwKVxufVxuXG5kZWZpbmVQcm9wcyhjb2xvcnMsIGluaXQoKSk7IiwibW9kdWxlWydleHBvcnRzJ10gPSBmdW5jdGlvbiBydW5UaGVUcmFwICh0ZXh0LCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSBcIlwiO1xuICB0ZXh0ID0gdGV4dCB8fCBcIlJ1biB0aGUgdHJhcCwgZHJvcCB0aGUgYmFzc1wiO1xuICB0ZXh0ID0gdGV4dC5zcGxpdCgnJyk7XG4gIHZhciB0cmFwID0ge1xuICAgIGE6IFtcIlxcdTAwNDBcIiwgXCJcXHUwMTA0XCIsIFwiXFx1MDIzYVwiLCBcIlxcdTAyNDVcIiwgXCJcXHUwMzk0XCIsIFwiXFx1MDM5YlwiLCBcIlxcdTA0MTRcIl0sXG4gICAgYjogW1wiXFx1MDBkZlwiLCBcIlxcdTAxODFcIiwgXCJcXHUwMjQzXCIsIFwiXFx1MDI2ZVwiLCBcIlxcdTAzYjJcIiwgXCJcXHUwZTNmXCJdLFxuICAgIGM6IFtcIlxcdTAwYTlcIiwgXCJcXHUwMjNiXCIsIFwiXFx1MDNmZVwiXSxcbiAgICBkOiBbXCJcXHUwMGQwXCIsIFwiXFx1MDE4YVwiLCBcIlxcdTA1MDBcIiAsIFwiXFx1MDUwMVwiICxcIlxcdTA1MDJcIiwgXCJcXHUwNTAzXCJdLFxuICAgIGU6IFtcIlxcdTAwY2JcIiwgXCJcXHUwMTE1XCIsIFwiXFx1MDE4ZVwiLCBcIlxcdTAyNThcIiwgXCJcXHUwM2EzXCIsIFwiXFx1MDNiZVwiLCBcIlxcdTA0YmNcIiwgXCJcXHUwYTZjXCJdLFxuICAgIGY6IFtcIlxcdTA0ZmFcIl0sXG4gICAgZzogW1wiXFx1MDI2MlwiXSxcbiAgICBoOiBbXCJcXHUwMTI2XCIsIFwiXFx1MDE5NVwiLCBcIlxcdTA0YTJcIiwgXCJcXHUwNGJhXCIsIFwiXFx1MDRjN1wiLCBcIlxcdTA1MGFcIl0sXG4gICAgaTogW1wiXFx1MGYwZlwiXSxcbiAgICBqOiBbXCJcXHUwMTM0XCJdLFxuICAgIGs6IFtcIlxcdTAxMzhcIiwgXCJcXHUwNGEwXCIsIFwiXFx1MDRjM1wiLCBcIlxcdTA1MWVcIl0sXG4gICAgbDogW1wiXFx1MDEzOVwiXSxcbiAgICBtOiBbXCJcXHUwMjhkXCIsIFwiXFx1MDRjZFwiLCBcIlxcdTA0Y2VcIiwgXCJcXHUwNTIwXCIsIFwiXFx1MDUyMVwiLCBcIlxcdTBkNjlcIl0sXG4gICAgbjogW1wiXFx1MDBkMVwiLCBcIlxcdTAxNGJcIiwgXCJcXHUwMTlkXCIsIFwiXFx1MDM3NlwiLCBcIlxcdTAzYTBcIiwgXCJcXHUwNDhhXCJdLFxuICAgIG86IFtcIlxcdTAwZDhcIiwgXCJcXHUwMGY1XCIsIFwiXFx1MDBmOFwiLCBcIlxcdTAxZmVcIiwgXCJcXHUwMjk4XCIsIFwiXFx1MDQ3YVwiLCBcIlxcdTA1ZGRcIiwgXCJcXHUwNmRkXCIsIFwiXFx1MGU0ZlwiXSxcbiAgICBwOiBbXCJcXHUwMWY3XCIsIFwiXFx1MDQ4ZVwiXSxcbiAgICBxOiBbXCJcXHUwOWNkXCJdLFxuICAgIHI6IFtcIlxcdTAwYWVcIiwgXCJcXHUwMWE2XCIsIFwiXFx1MDIxMFwiLCBcIlxcdTAyNGNcIiwgXCJcXHUwMjgwXCIsIFwiXFx1MDQyZlwiXSxcbiAgICBzOiBbXCJcXHUwMGE3XCIsIFwiXFx1MDNkZVwiLCBcIlxcdTAzZGZcIiwgXCJcXHUwM2U4XCJdLFxuICAgIHQ6IFtcIlxcdTAxNDFcIiwgXCJcXHUwMTY2XCIsIFwiXFx1MDM3M1wiXSxcbiAgICB1OiBbXCJcXHUwMWIxXCIsIFwiXFx1MDU0ZFwiXSxcbiAgICB2OiBbXCJcXHUwNWQ4XCJdLFxuICAgIHc6IFtcIlxcdTA0MjhcIiwgXCJcXHUwNDYwXCIsIFwiXFx1MDQ3Y1wiLCBcIlxcdTBkNzBcIl0sXG4gICAgeDogW1wiXFx1MDRiMlwiLCBcIlxcdTA0ZmVcIiwgXCJcXHUwNGZjXCIsIFwiXFx1MDRmZFwiXSxcbiAgICB5OiBbXCJcXHUwMGE1XCIsIFwiXFx1MDRiMFwiLCBcIlxcdTA0Y2JcIl0sXG4gICAgejogW1wiXFx1MDFiNVwiLCBcIlxcdTAyNDBcIl1cbiAgfVxuICB0ZXh0LmZvckVhY2goZnVuY3Rpb24oYyl7XG4gICAgYyA9IGMudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY2hhcnMgPSB0cmFwW2NdIHx8IFtcIiBcIl07XG4gICAgdmFyIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpO1xuICAgIGlmICh0eXBlb2YgdHJhcFtjXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmVzdWx0ICs9IHRyYXBbY11bcmFuZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBjO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG5cbn1cbiIsIi8vIHBsZWFzZSBub1xubW9kdWxlWydleHBvcnRzJ10gPSBmdW5jdGlvbiB6YWxnbyh0ZXh0LCBvcHRpb25zKSB7XG4gIHRleHQgPSB0ZXh0IHx8IFwiICAgaGUgaXMgaGVyZSAgIFwiO1xuICB2YXIgc291bCA9IHtcbiAgICBcInVwXCIgOiBbXG4gICAgICAnzI0nLCAnzI4nLCAnzIQnLCAnzIUnLFxuICAgICAgJ8y/JywgJ8yRJywgJ8yGJywgJ8yQJyxcbiAgICAgICfNkicsICfNlycsICfNkScsICfMhycsXG4gICAgICAnzIgnLCAnzIonLCAnzYInLCAnzJMnLFxuICAgICAgJ8yIJywgJ82KJywgJ82LJywgJ82MJyxcbiAgICAgICfMgycsICfMgicsICfMjCcsICfNkCcsXG4gICAgICAnzIAnLCAnzIEnLCAnzIsnLCAnzI8nLFxuICAgICAgJ8ySJywgJ8yTJywgJ8yUJywgJ8y9JyxcbiAgICAgICfMiScsICfNoycsICfNpCcsICfNpScsXG4gICAgICAnzaYnLCAnzacnLCAnzagnLCAnzaknLFxuICAgICAgJ82qJywgJ82rJywgJ82sJywgJ82tJyxcbiAgICAgICfNricsICfNrycsICfMvicsICfNmycsXG4gICAgICAnzYYnLCAnzJonXG4gICAgXSxcbiAgICBcImRvd25cIiA6IFtcbiAgICAgICfMlicsICfMlycsICfMmCcsICfMmScsXG4gICAgICAnzJwnLCAnzJ0nLCAnzJ4nLCAnzJ8nLFxuICAgICAgJ8ygJywgJ8ykJywgJ8ylJywgJ8ymJyxcbiAgICAgICfMqScsICfMqicsICfMqycsICfMrCcsXG4gICAgICAnzK0nLCAnzK4nLCAnzK8nLCAnzLAnLFxuICAgICAgJ8yxJywgJ8yyJywgJ8yzJywgJ8y5JyxcbiAgICAgICfMuicsICfMuycsICfMvCcsICfNhScsXG4gICAgICAnzYcnLCAnzYgnLCAnzYknLCAnzY0nLFxuICAgICAgJ82OJywgJ82TJywgJ82UJywgJ82VJyxcbiAgICAgICfNlicsICfNmScsICfNmicsICfMoydcbiAgICBdLFxuICAgIFwibWlkXCIgOiBbXG4gICAgICAnzJUnLCAnzJsnLCAnzIAnLCAnzIEnLFxuICAgICAgJ82YJywgJ8yhJywgJ8yiJywgJ8ynJyxcbiAgICAgICfMqCcsICfMtCcsICfMtScsICfMticsXG4gICAgICAnzZwnLCAnzZ0nLCAnzZ4nLFxuICAgICAgJ82fJywgJ82gJywgJ82iJywgJ8y4JyxcbiAgICAgICfMtycsICfNoScsICcg0oknXG4gICAgXVxuICB9LFxuICBhbGwgPSBbXS5jb25jYXQoc291bC51cCwgc291bC5kb3duLCBzb3VsLm1pZCksXG4gIHphbGdvID0ge307XG5cbiAgZnVuY3Rpb24gcmFuZG9tTnVtYmVyKHJhbmdlKSB7XG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZSk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBmdW5jdGlvbiBpc19jaGFyKGNoYXJhY3Rlcikge1xuICAgIHZhciBib29sID0gZmFsc2U7XG4gICAgYWxsLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgYm9vbCA9IChpID09PSBjaGFyYWN0ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBib29sO1xuICB9XG4gIFxuXG4gIGZ1bmN0aW9uIGhlQ29tZXModGV4dCwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSAnJywgY291bnRzLCBsO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnNbXCJ1cFwiXSA9ICAgdHlwZW9mIG9wdGlvbnNbXCJ1cFwiXSAgICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnNbXCJ1cFwiXSAgIDogdHJ1ZTtcbiAgICBvcHRpb25zW1wibWlkXCJdID0gIHR5cGVvZiBvcHRpb25zW1wibWlkXCJdICAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zW1wibWlkXCJdICA6IHRydWU7XG4gICAgb3B0aW9uc1tcImRvd25cIl0gPSB0eXBlb2Ygb3B0aW9uc1tcImRvd25cIl0gIT09ICd1bmRlZmluZWQnID8gb3B0aW9uc1tcImRvd25cIl0gOiB0cnVlO1xuICAgIG9wdGlvbnNbXCJzaXplXCJdID0gdHlwZW9mIG9wdGlvbnNbXCJzaXplXCJdICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnNbXCJzaXplXCJdIDogXCJtYXhpXCI7XG4gICAgdGV4dCA9IHRleHQuc3BsaXQoJycpO1xuICAgIGZvciAobCBpbiB0ZXh0KSB7XG4gICAgICBpZiAoaXNfY2hhcihsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHRleHRbbF07XG4gICAgICBjb3VudHMgPSB7XCJ1cFwiIDogMCwgXCJkb3duXCIgOiAwLCBcIm1pZFwiIDogMH07XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuc2l6ZSkge1xuICAgICAgY2FzZSAnbWluaSc6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcig4KTtcbiAgICAgICAgY291bnRzLm1pZCA9IHJhbmRvbU51bWJlcigyKTtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoOCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWF4aSc6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcigxNikgKyAzO1xuICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDQpICsgMTtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoNjQpICsgMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudHMudXAgPSByYW5kb21OdW1iZXIoOCkgKyAxO1xuICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDYpIC8gMjtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoOCkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGFyciA9IFtcInVwXCIsIFwibWlkXCIsIFwiZG93blwiXTtcbiAgICAgIGZvciAodmFyIGQgaW4gYXJyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFycltkXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDw9IGNvdW50c1tpbmRleF07IGkrKykge1xuICAgICAgICAgIGlmIChvcHRpb25zW2luZGV4XSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgc291bFtpbmRleF1bcmFuZG9tTnVtYmVyKHNvdWxbaW5kZXhdLmxlbmd0aCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIGRvbid0IHN1bW1vbiBoaW1cbiAgcmV0dXJuIGhlQ29tZXModGV4dCwgb3B0aW9ucyk7XG59XG4iLCJ2YXIgY29sb3JzID0gcmVxdWlyZSgnLi9jb2xvcnMnKTtcblxubW9kdWxlWydleHBvcnRzJ10gPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy9cbiAgLy8gRXh0ZW5kcyBwcm90b3R5cGUgb2YgbmF0aXZlIHN0cmluZyBvYmplY3QgdG8gYWxsb3cgZm9yIFwiZm9vXCIucmVkIHN5bnRheFxuICAvL1xuICB2YXIgYWRkUHJvcGVydHkgPSBmdW5jdGlvbiAoY29sb3IsIGZ1bmMpIHtcbiAgICBTdHJpbmcucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oY29sb3IsIGZ1bmMpO1xuICB9O1xuXG4gIHZhciBzZXF1ZW5jZXIgPSBmdW5jdGlvbiBzZXF1ZW5jZXIgKG1hcCwgc3RyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXhwbG9kZWQgPSB0aGlzLnNwbGl0KFwiXCIpLCBpID0gMDtcbiAgICAgICAgZXhwbG9kZWQgPSBleHBsb2RlZC5tYXAobWFwKTtcbiAgICAgICAgcmV0dXJuIGV4cGxvZGVkLmpvaW4oXCJcIik7XG4gICAgICB9XG4gIH07XG5cbiAgYWRkUHJvcGVydHkoJ3N0cmlwJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2xvcnMuc3RyaXAodGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KCdzdHJpcENvbG9ycycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29sb3JzLnN0cmlwKHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcInRyYXBcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLnRyYXAodGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwiemFsZ29cIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLnphbGdvKHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcInplYnJhXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGNvbG9ycy56ZWJyYSh0aGlzKTtcbiAgfSk7XG5cbiAgYWRkUHJvcGVydHkoXCJyYWluYm93XCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGNvbG9ycy5yYWluYm93KHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcInJhbmRvbVwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBjb2xvcnMucmFuZG9tKHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcImFtZXJpY2FcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLmFtZXJpY2EodGhpcyk7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZGVmYXVsdCBzdHlsZXMgYW5kIGNvbG9yc1xuICAvL1xuICB2YXIgeCA9IE9iamVjdC5rZXlzKGNvbG9ycy5zdHlsZXMpO1xuICB4LmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgYWRkUHJvcGVydHkoc3R5bGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb2xvcnMuc3R5bGl6ZSh0aGlzLCBzdHlsZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFwcGx5VGhlbWUodGhlbWUpIHtcbiAgICAvL1xuICAgIC8vIFJlbWFyazogVGhpcyBpcyBhIGxpc3Qgb2YgbWV0aG9kcyB0aGF0IGV4aXN0XG4gICAgLy8gb24gU3RyaW5nIHRoYXQgeW91IHNob3VsZCBub3Qgb3ZlcndyaXRlLlxuICAgIC8vXG4gICAgdmFyIHN0cmluZ1Byb3RvdHlwZUJsYWNrbGlzdCA9IFtcbiAgICAgICdfX2RlZmluZUdldHRlcl9fJywgJ19fZGVmaW5lU2V0dGVyX18nLCAnX19sb29rdXBHZXR0ZXJfXycsICdfX2xvb2t1cFNldHRlcl9fJywgJ2NoYXJBdCcsICdjb25zdHJ1Y3RvcicsXG4gICAgICAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJywgJ2NoYXJDb2RlQXQnLFxuICAgICAgJ2luZGV4T2YnLCAnbGFzdEluZGV4b2YnLCAnbGVuZ3RoJywgJ2xvY2FsZUNvbXBhcmUnLCAnbWF0Y2gnLCAncmVwbGFjZScsICdzZWFyY2gnLCAnc2xpY2UnLCAnc3BsaXQnLCAnc3Vic3RyaW5nJyxcbiAgICAgICd0b0xvY2FsZUxvd2VyQ2FzZScsICd0b0xvY2FsZVVwcGVyQ2FzZScsICd0b0xvd2VyQ2FzZScsICd0b1VwcGVyQ2FzZScsICd0cmltJywgJ3RyaW1MZWZ0JywgJ3RyaW1SaWdodCdcbiAgICBdO1xuXG4gICAgT2JqZWN0LmtleXModGhlbWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGlmIChzdHJpbmdQcm90b3R5cGVCbGFja2xpc3QuaW5kZXhPZihwcm9wKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3dhcm46ICcucmVkICsgKCdTdHJpbmcucHJvdG90eXBlJyArIHByb3ApLm1hZ2VudGEgKyAnIGlzIHByb2JhYmx5IHNvbWV0aGluZyB5b3UgZG9uXFwndCB3YW50IHRvIG92ZXJyaWRlLiBJZ25vcmluZyBzdHlsZSBuYW1lJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZih0aGVtZVtwcm9wXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29sb3JzW3Byb3BdID0gY29sb3JzW3RoZW1lW3Byb3BdXTtcbiAgICAgICAgICBhZGRQcm9wZXJ0eShwcm9wLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3JzW3RoZW1lW3Byb3BdXSh0aGlzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhZGRQcm9wZXJ0eShwcm9wLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGhlbWVbcHJvcF0ubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgcmV0ID0gY29sb3JzW3RoZW1lW3Byb3BdW3RdXShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29sb3JzLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbG9ycy50aGVtZXNbdGhlbWVdID0gcmVxdWlyZSh0aGVtZSk7XG4gICAgICAgIGFwcGx5VGhlbWUoY29sb3JzLnRoZW1lc1t0aGVtZV0pO1xuICAgICAgICByZXR1cm4gY29sb3JzLnRoZW1lc1t0aGVtZV07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlUaGVtZSh0aGVtZSk7XG4gICAgfVxuICB9O1xuXG59OyIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuL2NvbG9ycycpO1xubW9kdWxlWydleHBvcnRzJ10gPSBjb2xvcnM7XG5cbi8vIFJlbWFyazogQnkgZGVmYXVsdCwgY29sb3JzIHdpbGwgYWRkIHN0eWxlIHByb3BlcnRpZXMgdG8gU3RyaW5nLnByb3RvdHlwZVxuLy9cbi8vIElmIHlvdSBkb24ndCB3aXNoIHRvIGV4dGVuZCBTdHJpbmcucHJvdG90eXBlIHlvdSBjYW4gZG8gdGhpcyBpbnN0ZWFkIGFuZCBuYXRpdmUgU3RyaW5nIHdpbGwgbm90IGJlIHRvdWNoZWRcbi8vXG4vLyAgIHZhciBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZSk7XG4vLyAgIGNvbG9ycy5yZWQoXCJmb29cIilcbi8vXG4vL1xucmVxdWlyZSgnLi9leHRlbmRTdHJpbmdQcm90b3R5cGUnKSgpOyIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuLi9jb2xvcnMnKTtcblxubW9kdWxlWydleHBvcnRzJ10gPSAoZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICAgIGlmKGxldHRlciA9PT0gXCIgXCIpIHJldHVybiBsZXR0ZXI7XG4gICAgc3dpdGNoKGklMykge1xuICAgICAgY2FzZSAwOiByZXR1cm4gY29sb3JzLnJlZChsZXR0ZXIpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gY29sb3JzLndoaXRlKGxldHRlcilcbiAgICAgIGNhc2UgMjogcmV0dXJuIGNvbG9ycy5ibHVlKGxldHRlcilcbiAgICB9XG4gIH1cbn0pKCk7IiwidmFyIGNvbG9ycyA9IHJlcXVpcmUoJy4uL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByYWluYm93Q29sb3JzID0gWydyZWQnLCAneWVsbG93JywgJ2dyZWVuJywgJ2JsdWUnLCAnbWFnZW50YSddOyAvL1JvWSBHIEJpVlxuICByZXR1cm4gZnVuY3Rpb24gKGxldHRlciwgaSwgZXhwbG9kZWQpIHtcbiAgICBpZiAobGV0dGVyID09PSBcIiBcIikge1xuICAgICAgcmV0dXJuIGxldHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbG9yc1tyYWluYm93Q29sb3JzW2krKyAlIHJhaW5ib3dDb2xvcnMubGVuZ3RoXV0obGV0dGVyKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG4iLCJ2YXIgY29sb3JzID0gcmVxdWlyZSgnLi4vY29sb3JzJyk7XG5cbm1vZHVsZVsnZXhwb3J0cyddID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF2YWlsYWJsZSA9IFsndW5kZXJsaW5lJywgJ2ludmVyc2UnLCAnZ3JleScsICd5ZWxsb3cnLCAncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAnd2hpdGUnLCAnY3lhbicsICdtYWdlbnRhJ107XG4gIHJldHVybiBmdW5jdGlvbihsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gICAgcmV0dXJuIGxldHRlciA9PT0gXCIgXCIgPyBsZXR0ZXIgOiBjb2xvcnNbYXZhaWxhYmxlW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChhdmFpbGFibGUubGVuZ3RoIC0gMSkpXV0obGV0dGVyKTtcbiAgfTtcbn0pKCk7IiwidmFyIGNvbG9ycyA9IHJlcXVpcmUoJy4uL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uIChsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gIHJldHVybiBpICUgMiA9PT0gMCA/IGxldHRlciA6IGNvbG9ycy5pbnZlcnNlKGxldHRlcik7XG59OyIsIi8qXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgc3R5bGVzID0ge307XG5tb2R1bGVbJ2V4cG9ydHMnXSA9IHN0eWxlcztcblxudmFyIGNvZGVzID0ge1xuICByZXNldDogWzAsIDBdLFxuXG4gIGJvbGQ6IFsxLCAyMl0sXG4gIGRpbTogWzIsIDIyXSxcbiAgaXRhbGljOiBbMywgMjNdLFxuICB1bmRlcmxpbmU6IFs0LCAyNF0sXG4gIGludmVyc2U6IFs3LCAyN10sXG4gIGhpZGRlbjogWzgsIDI4XSxcbiAgc3RyaWtldGhyb3VnaDogWzksIDI5XSxcblxuICBibGFjazogWzMwLCAzOV0sXG4gIHJlZDogWzMxLCAzOV0sXG4gIGdyZWVuOiBbMzIsIDM5XSxcbiAgeWVsbG93OiBbMzMsIDM5XSxcbiAgYmx1ZTogWzM0LCAzOV0sXG4gIG1hZ2VudGE6IFszNSwgMzldLFxuICBjeWFuOiBbMzYsIDM5XSxcbiAgd2hpdGU6IFszNywgMzldLFxuICBncmF5OiBbOTAsIDM5XSxcbiAgZ3JleTogWzkwLCAzOV0sXG5cbiAgYmdCbGFjazogWzQwLCA0OV0sXG4gIGJnUmVkOiBbNDEsIDQ5XSxcbiAgYmdHcmVlbjogWzQyLCA0OV0sXG4gIGJnWWVsbG93OiBbNDMsIDQ5XSxcbiAgYmdCbHVlOiBbNDQsIDQ5XSxcbiAgYmdNYWdlbnRhOiBbNDUsIDQ5XSxcbiAgYmdDeWFuOiBbNDYsIDQ5XSxcbiAgYmdXaGl0ZTogWzQ3LCA0OV0sXG5cbiAgLy8gbGVnYWN5IHN0eWxlcyBmb3IgY29sb3JzIHByZSB2MS4wLjBcbiAgYmxhY2tCRzogWzQwLCA0OV0sXG4gIHJlZEJHOiBbNDEsIDQ5XSxcbiAgZ3JlZW5CRzogWzQyLCA0OV0sXG4gIHllbGxvd0JHOiBbNDMsIDQ5XSxcbiAgYmx1ZUJHOiBbNDQsIDQ5XSxcbiAgbWFnZW50YUJHOiBbNDUsIDQ5XSxcbiAgY3lhbkJHOiBbNDYsIDQ5XSxcbiAgd2hpdGVCRzogWzQ3LCA0OV1cblxufTtcblxuT2JqZWN0LmtleXMoY29kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdmFsID0gY29kZXNba2V5XTtcbiAgdmFyIHN0eWxlID0gc3R5bGVzW2tleV0gPSBbXTtcbiAgc3R5bGUub3BlbiA9ICdcXHUwMDFiWycgKyB2YWxbMF0gKyAnbSc7XG4gIHN0eWxlLmNsb3NlID0gJ1xcdTAwMWJbJyArIHZhbFsxXSArICdtJztcbn0pOyIsIi8qXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgYXJndiA9IHByb2Nlc3MuYXJndjtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndi5pbmRleE9mKCctLW5vLWNvbG9yJykgIT09IC0xIHx8XG4gICAgYXJndi5pbmRleE9mKCctLWNvbG9yPWZhbHNlJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyZ3YuaW5kZXhPZignLS1jb2xvcicpICE9PSAtMSB8fFxuICAgIGFyZ3YuaW5kZXhPZignLS1jb2xvcj10cnVlJykgIT09IC0xIHx8XG4gICAgYXJndi5pbmRleE9mKCctLWNvbG9yPWFsd2F5cycpICE9PSAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoJ0NPTE9SVEVSTScgaW4gcHJvY2Vzcy5lbnYpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5URVJNID09PSAnZHVtYicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0pKCk7IiwiLyoqXG4gKiBAbGljZW5zZVxuICogbG9kYXNoIDMuMTAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiAtZCAtbyAuL2luZGV4LmpzYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnMy4xMC4xJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB3cmFwcGVyIG1ldGFkYXRhLiAqL1xuICB2YXIgQklORF9GTEFHID0gMSxcbiAgICAgIEJJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBDVVJSWV9GTEFHID0gOCxcbiAgICAgIENVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFBBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBBUllfRkxBRyA9IDEyOCxcbiAgICAgIFJFQVJHX0ZMQUcgPSAyNTY7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2AuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB3aGVuIGEgZnVuY3Rpb24gYmVjb21lcyBob3QuICovXG4gIHZhciBIT1RfQ09VTlQgPSAxNTAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbiAgdmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5fCM5Nik7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ2BdL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcblxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcblxcXFxdfFxcXFwuKSo/KVxcMilcXF0vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXBhdHRlcm5zKVxuICAgKiBhbmQgdGhvc2Ugb3V0bGluZWQgYnkgW2BFc2NhcGVSZWdFeHBQYXR0ZXJuYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZXNjYXBlcmVnZXhwcGF0dGVybikuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFycyA9IC9eWzohLF18W1xcXFxeJC4qKz8oKVtcXF17fXxcXC9dfCheWzAtOWEtZkEtRm5ydHV2eF0pfChbXFxuXFxyXFx1MjAyOFxcdTIwMjldKS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFycyA9IFJlZ0V4cChyZVJlZ0V4cENoYXJzLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS4gKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gL1tcXHUwMzAwLVxcdTAzNmZcXHVmZTIwLVxcdWZlMjNdL2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLiAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUhhc0hleFByZWZpeCA9IC9eMFt4WF0vO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL15cXGQrJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4xID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGRlXFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgdG8gY3JlYXRlIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVXb3JkcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdXBwZXIgPSAnW0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZV0nLFxuICAgICAgICBsb3dlciA9ICdbYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmXSsnO1xuXG4gICAgcmV0dXJuIFJlZ0V4cCh1cHBlciArICcrKD89JyArIHVwcGVyICsgbG93ZXIgKyAnKXwnICsgdXBwZXIgKyAnPycgKyBsb3dlciArICd8JyArIHVwcGVyICsgJyt8WzAtOV0rJywgJ2cnKTtcbiAgfSgpKTtcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0FycmF5QnVmZmVyJywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWF0aCcsICdOdW1iZXInLFxuICAgICdPYmplY3QnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLFxuICAgICdwYXJzZUZsb2F0JywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJ1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y0MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlQyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJ2AnOiAnJiM5NjsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiLFxuICAgICcmIzk2Oyc6ICdgJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgcmVnZXhlcy4gKi9cbiAgdmFyIHJlZ2V4cEVzY2FwZXMgPSB7XG4gICAgJzAnOiAneDMwJywgJzEnOiAneDMxJywgJzInOiAneDMyJywgJzMnOiAneDMzJywgJzQnOiAneDM0JyxcbiAgICAnNSc6ICd4MzUnLCAnNic6ICd4MzYnLCAnNyc6ICd4MzcnLCAnOCc6ICd4MzgnLCAnOSc6ICd4MzknLFxuICAgICdBJzogJ3g0MScsICdCJzogJ3g0MicsICdDJzogJ3g0MycsICdEJzogJ3g0NCcsICdFJzogJ3g0NScsICdGJzogJ3g0NicsXG4gICAgJ2EnOiAneDYxJywgJ2InOiAneDYyJywgJ2MnOiAneDYzJywgJ2QnOiAneDY0JywgJ2UnOiAneDY1JywgJ2YnOiAneDY2JyxcbiAgICAnbic6ICd4NmUnLCAncic6ICd4NzInLCAndCc6ICd4NzQnLCAndSc6ICd4NzUnLCAndic6ICd4NzYnLCAneCc6ICd4NzgnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gb2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgJiYgc2VsZjtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHdpbmRvd2AuICovXG4gIHZhciBmcmVlV2luZG93ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93ICYmIHdpbmRvdy5PYmplY3QgJiYgd2luZG93O1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzICYmIGZyZWVFeHBvcnRzO1xuXG4gIC8qKlxuICAgKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgYHRoaXNgIHZhbHVlIGlzIHVzZWQgaWYgaXQncyB0aGUgZ2xvYmFsIG9iamVjdCB0byBhdm9pZCBHcmVhc2Vtb25rZXknc1xuICAgKiByZXN0cmljdGVkIGB3aW5kb3dgIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBgd2luZG93YCBvYmplY3QgaXMgdXNlZC5cbiAgICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCAoKGZyZWVXaW5kb3cgIT09ICh0aGlzICYmIHRoaXMud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHwgZnJlZVNlbGYgfHwgdGhpcztcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNvbXBhcmVBc2NlbmRpbmdgIHdoaWNoIGNvbXBhcmVzIHZhbHVlcyBhbmRcbiAgICogc29ydHMgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIgd2l0aG91dCBndWFyYW50ZWVpbmcgYSBzdGFibGUgc29ydC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQ29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICB2YXIgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNVbmRlZiA9IHZhbHVlID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWU7XG5cbiAgICAgIHZhciBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgICBvdGhJc1VuZGVmID0gb3RoZXIgPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcjtcblxuICAgICAgaWYgKCh2YWx1ZSA+IG90aGVyICYmICFvdGhJc051bGwpIHx8ICF2YWxJc1JlZmxleGl2ZSB8fFxuICAgICAgICAgICh2YWxJc051bGwgJiYgIW90aElzVW5kZWYgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgKHZhbElzVW5kZWYgJiYgb3RoSXNSZWZsZXhpdmUpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKCh2YWx1ZSA8IG90aGVyICYmICF2YWxJc051bGwpIHx8ICFvdGhJc1JlZmxleGl2ZSB8fFxuICAgICAgICAgIChvdGhJc051bGwgJiYgIXZhbElzVW5kZWYgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgKG90aElzVW5kZWYgJiYgdmFsSXNSZWZsZXhpdmUpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0Z1bmN0aW9uYCB3aXRob3V0IHN1cHBvcnQgZm9yIGVudmlyb25tZW50c1xuICAgKiB3aXRoIGluY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gQXZvaWQgYSBDaGFrcmEgSklUIGJ1ZyBpbiBjb21wYXRpYmlsaXR5IG1vZGVzIG9mIElFIDExLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvaXNzdWVzLzE2MjEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCdzIG5vdCBvbmUuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICAgKiBmb3IgYG51bGxgIG9yIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6ICh2YWx1ZSArICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltTGVmdGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAqIG9mIGBzdHJpbmdgIHRoYXQgaXMgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgVGhlIGNoYXJhY3RlcnMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzTGVmdEluZGV4KHN0cmluZywgY2hhcnMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNoYXJzLmluZGV4T2Yoc3RyaW5nLmNoYXJBdChpbmRleCkpID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1SaWdodGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAgICogb2YgYHN0cmluZ2AgdGhhdCBpcyBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFycyBUaGUgY2hhcmFjdGVycyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCBjaGFycykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBjaGFycy5pbmRleE9mKHN0cmluZy5jaGFyQXQoaW5kZXgpKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnNvcnRCeWAgdG8gY29tcGFyZSB0cmFuc2Zvcm1lZCBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24gYW5kIHN0YWJsZVxuICAgKiBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGJhc2VDb21wYXJlQXNjZW5kaW5nKG9iamVjdC5jcml0ZXJpYSwgb3RoZXIuY3JpdGVyaWEpIHx8IChvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5zb3J0QnlPcmRlcmAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAgICpcbiAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gICAqIGEgdmFsdWUgaXMgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBpZiBpdHMgY29ycmVzcG9uZGluZyBvcmRlciBpcyBcImFzY1wiLCBhbmRcbiAgICogZGVzY2VuZGluZyBpZiBcImRlc2NcIi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbltdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICByZXR1cm4gcmVzdWx0ICogKChvcmRlciA9PT0gJ2FzYycgfHwgb3JkZXIgPT09IHRydWUpID8gMSA6IC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvL1xuICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIGZ1bmN0aW9uIGRlYnVyckxldHRlcihsZXR0ZXIpIHtcbiAgICByZXR1cm4gZGVidXJyZWRMZXR0ZXJzW2xldHRlcl07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIoY2hyKSB7XG4gICAgcmV0dXJuIGh0bWxFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVSZWdFeHBgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgcmVnZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGVhZGluZ0NoYXIgVGhlIGNhcHR1cmUgZ3JvdXAgZm9yIGEgbGVhZGluZyBjaGFyYWN0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aGl0ZXNwYWNlQ2hhciBUaGUgY2FwdHVyZSBncm91cCBmb3IgYSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHBDaGFyKGNociwgbGVhZGluZ0NoYXIsIHdoaXRlc3BhY2VDaGFyKSB7XG4gICAgaWYgKGxlYWRpbmdDaGFyKSB7XG4gICAgICBjaHIgPSByZWdleHBFc2NhcGVzW2Nocl07XG4gICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlQ2hhcikge1xuICAgICAgY2hyID0gc3RyaW5nRXNjYXBlc1tjaHJdO1xuICAgIH1cbiAgICByZXR1cm4gJ1xcXFwnICsgY2hyO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBOYU5gIGlzIGZvdW5kIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgYE5hTmAsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMCA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAob3RoZXIgIT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGB0cmltbWVkTGVmdEluZGV4YCBhbmQgYHRyaW1tZWRSaWdodEluZGV4YCB0byBkZXRlcm1pbmUgaWYgYVxuICAgKiBjaGFyYWN0ZXIgY29kZSBpcyB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gY2hhckNvZGUgVGhlIGNoYXJhY3RlciBjb2RlIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgY2hhckNvZGVgIGlzIHdoaXRlc3BhY2UsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzU3BhY2UoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gKChjaGFyQ29kZSA8PSAxNjAgJiYgKGNoYXJDb2RlID49IDkgJiYgY2hhckNvZGUgPD0gMTMpIHx8IGNoYXJDb2RlID09IDMyIHx8IGNoYXJDb2RlID09IDE2MCkgfHwgY2hhckNvZGUgPT0gNTc2MCB8fCBjaGFyQ29kZSA9PSA2MTU4IHx8XG4gICAgICAoY2hhckNvZGUgPj0gODE5MiAmJiAoY2hhckNvZGUgPD0gODIwMiB8fCBjaGFyQ29kZSA9PSA4MjMyIHx8IGNoYXJDb2RlID09IDgyMzMgfHwgY2hhckNvZGUgPT0gODIzOSB8fCBjaGFyQ29kZSA9PSA4Mjg3IHx8IGNoYXJDb2RlID09IDEyMjg4IHx8IGNoYXJDb2RlID09IDY1Mjc5KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIG9wdGltaXplZCBmb3Igc29ydGVkIGFycmF5cyB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHNlZW4sXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICBpZiAoIWluZGV4IHx8IHNlZW4gIT09IGNvbXB1dGVkKSB7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUxlZnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltbWVkTGVmdEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgaXNTcGFjZShzdHJpbmcuY2hhckNvZGVBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltUmlnaHRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGlzU3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gdXNpbmcgYGNvbnRleHRgIHRvIG1vY2sgYERhdGUjZ2V0VGltZWAgdXNlIGluIGBfLm5vd2BcbiAgICogdmFyIG1vY2sgPSBfLnJ1bkluQ29udGV4dCh7XG4gICAqICAgJ0RhdGUnOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7ICdnZXRUaW1lJzogZ2V0VGltZU1vY2sgfTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBvciBjcmVhdGluZyBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qc1xuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAvLyBBdm9pZCBpc3N1ZXMgd2l0aCBzb21lIEVTMyBlbnZpcm9ubWVudHMgdGhhdCBhdHRlbXB0IHRvIHVzZSB2YWx1ZXMsIG5hbWVkXG4gICAgLy8gYWZ0ZXIgYnVpbHQtaW4gY29uc3RydWN0b3JzIGxpa2UgYE9iamVjdGAsIGZvciB0aGUgY3JlYXRpb24gb2YgbGl0ZXJhbHMuXG4gICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDExLjEuNSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIE5hdGl2ZSBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBOdW1iZXIgPSBjb250ZXh0Lk51bWJlcixcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIHN0cmluZ1Byb3RvID0gU3RyaW5nLnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5QnVmZmVyID0gY29udGV4dC5BcnJheUJ1ZmZlcixcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIHBhcnNlRmxvYXQgPSBjb250ZXh0LnBhcnNlRmxvYXQsXG4gICAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSBnZXROYXRpdmUoQXJyYXksICdpc0FycmF5JyksXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyksXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlTm93ID0gZ2V0TmF0aXZlKERhdGUsICdub3cnKSxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIGAtSW5maW5pdHlgIGFuZCBgSW5maW5pdHlgLiAqL1xuICAgIHZhciBORUdBVElWRV9JTkZJTklUWSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgUE9TSVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICAgIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICAgICAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG4gICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsIGFuZCBmdW5jdGlvbnMgY2FuXG4gICAgICogYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlIG9yIG1heSByZXR1cm4gYVxuICAgICAqIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiByZXR1cm5pbmcgdGhlIHVud3JhcHBlZFxuICAgICAqIHZhbHVlLiBFeHBsaWNpdCBjaGFpbmluZyBtYXkgYmUgZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuIFRoZSBleGVjdXRpb24gb2ZcbiAgICAgKiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgZXhlY3V0aW9uIGlzIGRlZmVycmVkIHVudGlsIGBfI3ZhbHVlYFxuICAgICAqIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi4gU2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHN0cmF0ZWd5IHdoaWNoIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGNhbiBoZWxwXG4gICAgICogdG8gYXZvaWQgdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBkYXRhIHN0cnVjdHVyZXMgYW5kIGdyZWF0bHkgcmVkdWNlIHRoZVxuICAgICAqIG51bWJlciBvZiBpdGVyYXRlZSBleGVjdXRpb25zLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHJldmVyc2VgLCBgc2hpZnRgLCBgc2xpY2VgLCBgc29ydGAsXG4gICAgICogYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmlyc3RgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGBwbHVja2AsIGByZWplY3RgLCBgcmVzdGAsIGByZXZlcnNlYCxcbiAgICAgKiBgc2xpY2VgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRvQXJyYXlgLFxuICAgICAqIGFuZCBgd2hlcmVgXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgbWV0aG9kcyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXRgLCBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCxcbiAgICAgKiBgY2FsbGJhY2tgLCBgY2hhaW5gLCBgY2h1bmtgLCBgY29tbWl0YCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbnN0YW50YCxcbiAgICAgKiBgY291bnRCeWAsIGBjcmVhdGVgLCBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCxcbiAgICAgKiBgZGVmZXJgLCBgZGVsYXlgLCBgZGlmZmVyZW5jZWAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wUmlnaHRXaGlsZWAsXG4gICAgICogYGRyb3BXaGlsZWAsIGBmaWxsYCwgYGZpbHRlcmAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCxcbiAgICAgKiBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLFxuICAgICAqIGBmdW5jdGlvbnNgLCBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsXG4gICAgICogYGludm9rZWAsIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsXG4gICAgICogYG1hdGNoZXNQcm9wZXJ0eWAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsXG4gICAgICogYG1vZEFyZ3NgLCBgbmVnYXRlYCwgYG9taXRgLCBgb25jZWAsIGBwYWlyc2AsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsXG4gICAgICogYHBhcnRpdGlvbmAsIGBwaWNrYCwgYHBsYW50YCwgYHBsdWNrYCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsXG4gICAgICogYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJlYXJnYCwgYHJlamVjdGAsIGByZW1vdmVgLCBgcmVzdGAsIGByZXN0UGFyYW1gLFxuICAgICAqIGByZXZlcnNlYCwgYHNldGAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNvcnRCeUFsbGAsXG4gICAgICogYHNvcnRCeU9yZGVyYCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLFxuICAgICAqIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0b1BsYWluT2JqZWN0YCxcbiAgICAgKiBgdHJhbnNmb3JtYCwgYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdmFsdWVzYCxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB6aXBgLCBgemlwT2JqZWN0YCwgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsb25lYCwgYGNsb25lRGVlcGAsXG4gICAgICogYGRlYnVycmAsIGBlbmRzV2l0aGAsIGBlc2NhcGVgLCBgZXNjYXBlUmVnRXhwYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCxcbiAgICAgKiBgZmluZEtleWAsIGBmaW5kTGFzdGAsIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpbmRXaGVyZWAsIGBmaXJzdGAsXG4gICAgICogYGZsb29yYCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCwgYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLFxuICAgICAqIGBpblJhbmdlYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLFxuICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAgYGlzRnVuY3Rpb25gLCBgaXNNYXRjaGAsXG4gICAgICogYGlzTmF0aXZlYCwgYGlzTmFOYCwgYGlzTnVsbGAsIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCxcbiAgICAgKiBgaXNSZWdFeHBgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgaXNUeXBlZEFycmF5YCwgYGpvaW5gLCBga2ViYWJDYXNlYCxcbiAgICAgKiBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1pbmAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLFxuICAgICAqIGBub3dgLCBgcGFkYCwgYHBhZExlZnRgLCBgcGFkUmlnaHRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLFxuICAgICAqIGByZWR1Y2VSaWdodGAsIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkTGFzdEluZGV4YCwgYHN0YXJ0Q2FzZWAsXG4gICAgICogYHN0YXJ0c1dpdGhgLCBgc3VtYCwgYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUxlZnRgLCBgdHJpbVJpZ2h0YCwgYHRydW5jYCxcbiAgICAgKiBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kIGBzYW1wbGVgIHdpbGwgcmV0dXJuIGEgd3JhcHBlZCB2YWx1ZSB3aGVuIGBuYCBpcyBwcm92aWRlZCxcbiAgICAgKiBvdGhlcndpc2UgYW4gdW53cmFwcGVkIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZVxuICAgICAqIHdyYXBwZWQucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBuKSB7XG4gICAgICogICByZXR1cm4gdG90YWwgKyBuO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYSB3cmFwcGVkIHZhbHVlXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX2NoYWluX18nKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgYWxsIGNoYWluaW5nIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGNoYWluaW5nIGZvciBhbGwgd3JhcHBlciBtZXRob2RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthY3Rpb25zPVtdXSBBY3Rpb25zIHRvIHBlZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwsIGFjdGlvbnMpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBhY3Rpb25zIHx8IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBlbnZpcm9ubWVudCBmZWF0dXJlIGZsYWdzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpLiBDaGFuZ2UgdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2VcbiAgICAgKiBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBQT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gYXJyYXlDb3B5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGFycmF5Q29weSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gYXJyYXlDb3B5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8IGFyckxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgfHwgKGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoKGlzUmlnaHQgJiYgaXNBcnIpID8gYXJyYXkucmV2ZXJzZSgpIDogYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuICAgICAgICBpbmRleCArPSBkaXI7XG5cbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXG4gICAgICAgICAgICAgIGl0ZXJhdGVlID0gZGF0YS5pdGVyYXRlZSxcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS92YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBuYW1lIENhY2hlXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwRGVsZXRlKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNhY2hlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBHZXQoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ID09ICdfX3Byb3RvX18nID8gdW5kZWZpbmVkIDogdGhpcy5fX2RhdGFfX1trZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGNhY2hlZCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgIT0gJ19fcHJvdG9fXycgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9fZGF0YV9fLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYHZhbHVlYCB0byBga2V5YCBvZiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSAhPSAnX19wcm90b19fJykge1xuICAgICAgICB0aGlzLl9fZGF0YV9fW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gICAgICB0aGlzLmRhdGEgPSB7ICdoYXNoJzogbmF0aXZlQ3JlYXRlKG51bGwpLCAnc2V0JzogbmV3IFNldCB9O1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRoaXMucHVzaCh2YWx1ZXNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNhY2hlYCBtaW1pY2tpbmcgdGhlIHJldHVybiBzaWduYXR1cmUgb2ZcbiAgICAgKiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGNhY2hlLmRhdGEsXG4gICAgICAgICAgcmVzdWx0ID0gKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpID8gZGF0YS5zZXQuaGFzKHZhbHVlKSA6IGRhdGEuaGFzaFt2YWx1ZV07XG5cbiAgICAgIHJldHVybiByZXN1bHQgPyAwIDogLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcHVzaFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBkYXRhLnNldC5hZGQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5oYXNoW3ZhbHVlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBqb2luaW5nIGBhcnJheWAgd2l0aCBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gam9pbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gam9pbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlDb25jYXQoYXJyYXksIG90aGVyKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoSW5kZXggPSAtMSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoICsgb3RoTGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK290aEluZGV4IDwgb3RoTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleCsrXSA9IG90aGVyW290aEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5Q29weShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlRXh0cmVtdW1gIGZvciBhcnJheXMgd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gZXhWYWx1ZSBUaGUgaW5pdGlhbCBleHRyZW11bSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBjb21wdXRlZCA9IGV4VmFsdWUsXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSAraXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKSkge1xuICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRGcm9tQXJyYXldIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRGcm9tQXJyYXldIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc3VtYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy4uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHQgKz0gK2l0ZXJhdGVlKGFycmF5W2xlbmd0aF0pIHx8IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduYCB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3RWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlVmFsdWUgOiBvYmplY3RWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduRGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IGlnbm9yZXNcbiAgICAgKiBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWVzIHdoZW4gY2hlY2tpbmcgaWYgYSBwcm9wZXJ0eSBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgb2JqZWN0IGFuZCBzb3VyY2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduT3duRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgcmV0dXJuIChvYmplY3RWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSlcbiAgICAgICAgPyBzb3VyY2VWYWx1ZVxuICAgICAgICA6IG9iamVjdFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5hc3NpZ25gIGZvciBjdXN0b21pemluZyBhc3NpZ25lZCB2YWx1ZXMgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLCBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgXG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIodmFsdWUsIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKTtcblxuICAgICAgICBpZiAoKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHx8XG4gICAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcbiAgICAgKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlQ29weShzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBzdHJpbmcgY29sbGVjdGlvbnNcbiAgICAgKiBhbmQgaW5kaXZpZHVhbCBrZXkgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIG9yIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KGNvbGxlY3Rpb24sIHByb3BzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc05pbCA9IGNvbGxlY3Rpb24gPT0gbnVsbCxcbiAgICAgICAgICBpc0FyciA9ICFpc05pbCAmJiBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSxcbiAgICAgICAgICBsZW5ndGggPSBpc0FyciA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShwcm9wc0xlbmd0aCk7XG5cbiAgICAgIHdoaWxlKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXNJbmRleChrZXksIGxlbmd0aCkgPyBjb2xsZWN0aW9uW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGlzTmlsID8gdW5kZWZpbmVkIDogY29sbGVjdGlvbltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvcHkoc291cmNlLCBwcm9wcywgb2JqZWN0KSB7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jYWxsYmFja2Agd2hpY2ggc3VwcG9ydHMgc3BlY2lmeWluZyB0aGVcbiAgICAgKiBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmICh0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNBcmcgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gZnVuY1xuICAgICAgICAgIDogYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGZ1bmMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNBcmcgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHByb3BlcnR5KGZ1bmMpXG4gICAgICAgIDogYmFzZU1hdGNoZXNQcm9wZXJ0eShmdW5jLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZ1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgYHZhbHVlYCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0KSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWc7XG5cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbG9uZWFibGVUYWdzW3RhZ11cbiAgICAgICAgICAgID8gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKVxuICAgICAgICAgICAgOiAob2JqZWN0ID8gdmFsdWUgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lLlxuICAgICAgc3RhY2tBLnB1c2godmFsdWUpO1xuICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIChpc0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChpc09iamVjdChwcm90b3R5cGUpKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwge307XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kZWxheWAgYW5kIGBfLmRlZmVyYCB3aGljaCBhY2NlcHRzIGFuIGluZGV4XG4gICAgICogb2Ygd2hlcmUgdG8gc2xpY2UgdGhlIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyBUaGUgYXJndW1lbnRzIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kaWZmZXJlbmNlYCB3aGljaCBhY2NlcHRzIGEgc2luZ2xlIGFycmF5XG4gICAgICogb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaW5kZXhPZiA9PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBjYWNoZSA9IChpc0NvbW1vbiAmJiB2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpID8gY3JlYXRlQ2FjaGUodmFsdWVzKSA6IG51bGwsXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIHZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlLCAwKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBleHRyZW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaCB2YWx1ZVxuICAgICAqIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZSBpcyByYW5rZWQuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IGV4VmFsdWUgVGhlIGluaXRpYWwgZXh0cmVtdW0gdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gZXhWYWx1ZSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gK2l0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKSB8fCAoY3VycmVudCA9PT0gZXhWYWx1ZSAmJiBjdXJyZW50ID09PSByZXN1bHQpKSB7XG4gICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogKCtlbmQgfHwgMCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKGVuZCA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHdoaWxlIChzdGFydCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZGAsIGBfLmZpbmRMYXN0YCwgYF8uZmluZEtleWAsIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZywgd2hpY2ggaXRlcmF0ZXNcbiAgICAgKiBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyB0aGUgcHJvdmlkZWQgYGVhY2hGdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRLZXldIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnRcbiAgICAgKiAgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmluZChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jLCByZXRLZXkpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXRLZXkgPyBrZXkgOiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIGFkZGVkIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nXG4gICAgICogZmxhdHRlbmluZyBhbmQgc3BlY2lmeWluZyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMtbGlrZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICAgICAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAgIChpc1N0cmljdCB8fCBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBpc0RlZXAsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9ySW5gIGFuZCBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXNcbiAgICAgKiBvdmVyIGBvYmplY3RgIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvclxuICAgICAqIGVhY2ggcHJvcGVydHkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseVxuICAgICAqIHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25SaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIHRob3NlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iamVjdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0cmluZyBwYXRoc1xuICAgICAqIGFuZCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdGhLZXldIFRoZSBrZXkgcmVwcmVzZW50YXRpb24gb2YgcGF0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgsIHBhdGhLZXkpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGF0aEtleSAhPT0gdW5kZWZpbmVkICYmIHBhdGhLZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBwYXRoID0gW3BhdGhLZXldO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtwYXRoW2luZGV4KytdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzYCBiaW5kaW5nXG4gICAgICogYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICAgICAgaWYgKCFvYmpJc0Fycikge1xuICAgICAgICBvYmpUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmpUYWcgPT0gYXJnc1RhZykge1xuICAgICAgICAgIG9ialRhZyA9IG9iamVjdFRhZztcbiAgICAgICAgfSBlbHNlIGlmIChvYmpUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgb2JqSXNBcnIgPSBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvdGhJc0Fycikge1xuICAgICAgICBvdGhUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG90aGVyKTtcbiAgICAgICAgaWYgKG90aFRhZyA9PSBhcmdzVGFnKSB7XG4gICAgICAgICAgb3RoVGFnID0gb2JqZWN0VGFnO1xuICAgICAgICB9IGVsc2UgaWYgKG90aFRhZyAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgICBvdGhJc0FyciA9IGlzVHlwZWRBcnJheShvdGhlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIShvYmpJc0FyciB8fCBvYmpJc09iaikpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMb29zZSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LCBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXIsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGV0ZWN0aW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgc2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jSk8uXG4gICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgYG9iamVjdGAgYW5kIGBvdGhlcmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgc3RhY2tBLnB1c2gob2JqZWN0KTtcbiAgICAgIHN0YWNrQi5wdXNoKG90aGVyKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IChvYmpJc0FyciA/IGVxdWFsQXJyYXlzIDogZXF1YWxPYmplY3RzKShvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcblxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIHRydWUpIDogcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2VzIG5vdCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHZhciBrZXkgPSBtYXRjaERhdGFbMF1bMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG1hdGNoRGF0YVswXVsxXTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gdmFsdWUgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiB0b09iamVjdChvYmplY3QpKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkocGF0aCksXG4gICAgICAgICAgaXNDb21tb24gPSBpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpLFxuICAgICAgICAgIHBhdGhLZXkgPSAocGF0aCArICcnKTtcblxuICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBwYXRoS2V5O1xuICAgICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuICAgICAgICBpZiAoKGlzQXJyIHx8ICFpc0NvbW1vbikgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgIG9iamVjdCA9IHBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleSA9IGxhc3QocGF0aCk7XG4gICAgICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlXG4gICAgICAgICAgPyAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIG9iamVjdCkpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqZWN0W2tleV0sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICAgICAqIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgaXNTcmNBcnIgPSBpc0FycmF5TGlrZShzb3VyY2UpICYmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNUeXBlZEFycmF5KHNvdXJjZSkpLFxuICAgICAgICAgIHByb3BzID0gaXNTcmNBcnIgPyB1bmRlZmluZWQgOiBrZXlzKHNvdXJjZSk7XG5cbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCBzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAga2V5ID0gc3JjVmFsdWU7XG4gICAgICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3RMaWtlKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGlzQ29tbW9uID0gcmVzdWx0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHJlc3VsdCAhPT0gdW5kZWZpbmVkIHx8IChpc1NyY0FyciAmJiAhKGtleSBpbiBvYmplY3QpKSkgJiZcbiAgICAgICAgICAgICAgKGlzQ29tbW9uIHx8IChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGgsXG4gICAgICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBzcmNWYWx1ZSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gc3RhY2tCW2xlbmd0aF07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGlzQ29tbW9uID0gcmVzdWx0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHNyY1ZhbHVlKSAmJiAoaXNBcnJheShzcmNWYWx1ZSkgfHwgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiAoaXNBcnJheUxpa2UodmFsdWUpID8gYXJyYXlDb3B5KHZhbHVlKSA6IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpc0FyZ3VtZW50cyh2YWx1ZSlcbiAgICAgICAgICAgID8gdG9QbGFpbk9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGVcbiAgICAgIC8vIGl0IHdpdGggaXRzIG1lcmdlZCB2YWx1ZS5cbiAgICAgIHN0YWNrQS5wdXNoKHNyY1ZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgb2JqZWN0W2tleV0gPSBtZXJnZUZ1bmMocmVzdWx0LCBzcmNWYWx1ZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgdmFyIHBhdGhLZXkgPSAocGF0aCArICcnKTtcbiAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCwgcGF0aEtleSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXggYXJndW1lbnRzIGFuZCBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGluZGV4ICE9IHByZXZpb3VzICYmIGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZ1xuICAgICAqIGFuZCByZXR1cm5pbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgICAqIHVzaW5nIHRoZSBwcm92aWRlZCBgZWFjaEZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRGcm9tQ29sbGVjdGlvbiBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnRcbiAgICAgKiAgb2YgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21Db2xsZWN0aW9uLCBlYWNoRnVuYykge1xuICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEZyb21Db2xsZWN0aW9uXG4gICAgICAgICAgPyAoaW5pdEZyb21Db2xsZWN0aW9uID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiAoK2VuZCB8fCAwKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lXG4gICAgICogdGhlIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5T3JkZXJgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBnZXRDYWxsYmFjaygpLFxuICAgICAgICAgIGluZGV4ID0gLTE7XG5cbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHsgcmV0dXJuIGNhbGxiYWNrKGl0ZXJhdGVlKTsgfSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHsgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTsgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgKz0gK2l0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikgfHwgMDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gaW5kZXhPZiA9PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpc0xhcmdlID0gaXNDb21tb24gJiYgbGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUsXG4gICAgICAgICAgc2VlbiA9IGlzTGFyZ2UgPyBjcmVhdGVDYWNoZSgpIDogbnVsbCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgMCkgPCAwKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqIG9mIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZHJvcFJpZ2h0V2hpbGVgLCBgXy5kcm9wV2hpbGVgLCBgXy50YWtlUmlnaHRXaGlsZWAsXG4gICAgICogYW5kIGBfLnRha2VXaGlsZWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiYgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zW2luZGV4XTtcbiAgICAgICAgcmVzdWx0ID0gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuXG4gICAgICAgICAgaWYgKChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkgJiYgY29tcHV0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiaW5hcnlJbmRleGAgZXhjZXB0IHRoYXQgaXQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvclxuICAgICAqIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNVbmRlZiA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBpc0RlZiA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZDtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gaXNSZWZsZXhpdmUgfHwgcmV0SGlnaGVzdDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBpc1JlZmxleGl2ZSAmJiBpc0RlZiAmJiAocmV0SGlnaGVzdCB8fCBjb21wdXRlZCAhPSBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmKSB7XG4gICAgICAgICAgc2V0TG93ID0gaXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgaXNEZWYpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXB1dGVkID09IG51bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBhbmQgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGdpdmVuIGFycmF5IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIuYnl0ZUxlbmd0aCksXG4gICAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG5cbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpIHtcbiAgICAgIHZhciBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycykge1xuICAgICAgdmFyIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGFyZ3NMZW5ndGggKyByaWdodExlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uY291bnRCeWAsIGBfLmdyb3VwQnlgLCBgXy5pbmRleEJ5YCwgb3IgYF8ucGFydGl0aW9uYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBhY2N1bXVsYXRvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSB0aGUgYWNjdW11bGF0b3Igb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uYXNzaWduYCwgYF8uZGVmYXVsdHNgLCBvciBgXy5tZXJnZWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzW2xlbmd0aCAtIDJdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgNSk7XG4gICAgICAgICAgbGVuZ3RoIC09IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiB0aGlzQXJnID09ICdmdW5jdGlvbicgPyB0aGlzQXJnIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGxlbmd0aCAtPSAoY3VzdG9taXplciA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG4gICAgICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IHRvT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIGBfLmZvckluYCBvciBgXy5mb3JJblJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IHRvT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBpbnZva2VzIGl0IHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZFdyYXBwZXIoZnVuYywgdGhpc0FyZykge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYFNldGAgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgY2FjaGUgb2JqZWN0IGlmIGBTZXRgIGlzIHN1cHBvcnRlZCwgZWxzZSBgbnVsbGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUodmFsdWVzKSB7XG4gICAgICByZXR1cm4gKG5hdGl2ZUNyZWF0ZSAmJiBTZXQpID8gbmV3IFNldENhY2hlKHZhbHVlcykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGNvbXBvdW5kIHdvcmRzIG91dCBvZiB0aGUgd29yZHMgaW4gYVxuICAgICAqIGdpdmVuIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFycmF5ID0gd29yZHMoZGVidXJyKHN0cmluZykpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhyZXN1bHQsIGFycmF5W2luZGV4XSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3JXcmFwcGVyKEN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuXG4gICAgICAgIC8vIFNlZSBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnIFRoZSBjdXJyeSBiaXQgZmxhZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmbGFnKSB7XG4gICAgICBmdW5jdGlvbiBjdXJyeUZ1bmMoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChmdW5jLCBhcml0eSwgZ3VhcmQpKSB7XG4gICAgICAgICAgYXJpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXBwZXIoZnVuYywgZmxhZywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlGdW5jLnBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJ5RnVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZGVmYXVsdHNgIG9yIGBfLmRlZmF1bHRzRGVlcGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVmYXVsdHMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdHMoYXNzaWduZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gYXJnc1swXTtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goY3VzdG9taXplcik7XG4gICAgICAgIHJldHVybiBhc3NpZ25lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLm1heGAgb3IgYF8ubWluYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IGV4VmFsdWUgVGhlIGluaXRpYWwgZXh0cmVtdW0gdmFsdWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZXh0cmVtdW0gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRXh0cmVtdW0oY29tcGFyYXRvciwgZXhWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICBpZiAoaXRlcmF0ZWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBhcnJheUV4dHJlbXVtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBjb21wYXJhdG9yLCBleFZhbHVlKTtcbiAgICAgICAgICBpZiAoIShjb2xsZWN0aW9uLmxlbmd0aCAmJiByZXN1bHQgPT09IGV4VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUV4dHJlbXVtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBjb21wYXJhdG9yLCBleFZhbHVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlRmluZEluZGV4KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KTtcbiAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGNvbGxlY3Rpb25baW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlRmluZChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRJbmRleGAgb3IgYF8uZmluZExhc3RJbmRleGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZEluZGV4KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZEtleWAgb3IgYF8uZmluZExhc3RLZXlgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYmplY3RGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZEtleShvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgcmV0dXJuIGJhc2VGaW5kKG9iamVjdCwgcHJlZGljYXRlLCBvYmplY3RGdW5jLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIsXG4gICAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IDAsXG4gICAgICAgICAgICBmdW5jcyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF3cmFwcGVyICYmIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnUgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyAtMSA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJiBkYXRhWzFdID09IChBUllfRkxBRyB8IENVUlJZX0ZMQUcgfCBQQVJUSUFMX0ZMQUcgfCBSRUFSR19GTEFHKSAmJiAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKSA/IHdyYXBwZXJbZnVuY05hbWVdKCkgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8uZm9yRWFjaGAgb3IgYF8uZm9yRWFjaFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGFycmF5RnVuYywgZWFjaEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgPT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gYXJyYXlGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKVxuICAgICAgICAgIDogZWFjaEZ1bmMoY29sbGVjdGlvbiwgYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8uZm9ySW5gIG9yIGBfLmZvckluUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYmplY3RGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9ySW4ob2JqZWN0RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0RnVuYyhvYmplY3QsIGl0ZXJhdGVlLCBrZXlzSW4pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvck93bmAgb3IgYF8uZm9yT3duUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYmplY3RGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9yT3duKG9iamVjdEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0ZWUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdEZ1bmMob2JqZWN0LCBpdGVyYXRlZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8ubWFwS2V5c2Agb3IgYF8ubWFwVmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNYXBLZXlzXSBTcGVjaWZ5IG1hcHBpbmcga2V5cyBpbnN0ZWFkIG9mIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtYXAgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0TWFwcGVyKGlzTWFwS2V5cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgdmFyIG1hcHBlZCA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gICAgICAgICAga2V5ID0gaXNNYXBLZXlzID8gbWFwcGVkIDoga2V5O1xuICAgICAgICAgIHZhbHVlID0gaXNNYXBLZXlzID8gdmFsdWUgOiBtYXBwZWQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8ucGFkTGVmdGAgb3IgYF8ucGFkUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgcGFkZGluZyBmcm9tIHRoZSByaWdodC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkRGlyKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIChmcm9tUmlnaHQgPyBzdHJpbmcgOiAnJykgKyBjcmVhdGVQYWRkaW5nKHN0cmluZywgbGVuZ3RoLCBjaGFycykgKyAoZnJvbVJpZ2h0ID8gJycgOiBzdHJpbmcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucGFydGlhbGAgb3IgYF8ucGFydGlhbFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnIFRoZSBwYXJ0aWFsIGJpdCBmbGFnLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWwgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmbGFnKSB7XG4gICAgICB2YXIgcGFydGlhbEZ1bmMgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgcGFydGlhbEZ1bmMucGxhY2Vob2xkZXIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBmbGFnLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcnRpYWxGdW5jO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8ucmVkdWNlYCBvciBgXy5yZWR1Y2VSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGFycmF5RnVuYywgZWFjaEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIGluaXRGcm9tQXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnID09PSB1bmRlZmluZWQgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGFycmF5RnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpXG4gICAgICAgICAgOiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXksIGVhY2hGdW5jKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBpbnZva2VzIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBwZXJgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWRXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIEFSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBCSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIEJJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiBDVVJSWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiBDVVJSWV9CT1VORF9GTEFHLFxuICAgICAgICAgIGlzQ3VycnlSaWdodCA9IGJpdG1hc2sgJiBDVVJSWV9SSUdIVF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgLy8gQXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IHVzZSBkaXNxdWFsaWZ5aW5nIG9wdGltaXphdGlvbnMgYnlcbiAgICAgICAgLy8gY29udmVydGluZyBpdCB0byBhbiBhcnJheSBiZWZvcmUgcHJvdmlkaW5nIGl0IHRvIG90aGVyIGZ1bmN0aW9ucy5cbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJ5IHx8IGlzQ3VycnlSaWdodCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHdyYXBwZXIucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgIGFyZ3NIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgbGVuZ3RoIC09IGFyZ3NIb2xkZXJzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIHZhciBuZXdBcmdQb3MgPSBhcmdQb3MgPyBhcnJheUNvcHkoYXJnUG9zKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBuZXdBcml0eSA9IG5hdGl2ZU1heChhcml0eSAtIGxlbmd0aCwgMCksXG4gICAgICAgICAgICAgICAgbmV3c0hvbGRlcnMgPSBpc0N1cnJ5ID8gYXJnc0hvbGRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGFyZ3NIb2xkZXJzLFxuICAgICAgICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IGFyZ3MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBhcmdzO1xuXG4gICAgICAgICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gUEFSVElBTF9GTEFHIDogUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gUEFSVElBTF9SSUdIVF9GTEFHIDogUEFSVElBTF9GTEFHKTtcblxuICAgICAgICAgICAgaWYgKCFpc0N1cnJ5Qm91bmQpIHtcbiAgICAgICAgICAgICAgYml0bWFzayAmPSB+KEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBbZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld3NIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LCBuZXdIb2xkZXJzUmlnaHQsIG5ld0FyZ1BvcywgYXJ5LCBuZXdBcml0eV0sXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuXG4gICAgICAgICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgaWYgKGFyZ1Bvcykge1xuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyByZXF1aXJlZCBmb3IgYHN0cmluZ2AgYmFzZWQgb24gdGhlIGdpdmVuIGBsZW5ndGhgLlxuICAgICAqIFRoZSBgY2hhcnNgIHN0cmluZyBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjcmVhdGUgcGFkZGluZyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWQgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cbiAgICAgIGlmIChzdHJMZW5ndGggPj0gbGVuZ3RoIHx8ICFuYXRpdmVJc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBzdHJMZW5ndGg7XG4gICAgICBjaGFycyA9IGNoYXJzID09IG51bGwgPyAnICcgOiAoY2hhcnMgKyAnJyk7XG4gICAgICByZXR1cm4gcmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKHBhZExlbmd0aCAvIGNoYXJzLmxlbmd0aCkpLnNsaWNlKDAsIHBhZExlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBpbnZva2VzIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiB0aGUgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy4gU2VlIGBjcmVhdGVXcmFwcGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWxXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIEJJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIC8vIEF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCB1c2UgZGlzcXVhbGlmeWluZyBvcHRpbWl6YXRpb25zIGJ5XG4gICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCBgZnVuY2AuXG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uY2VpbGAsIGBfLmZsb29yYCwgb3IgYF8ucm91bmRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAwIDogKCtwcmVjaXNpb24gfHwgMCk7XG4gICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICBwcmVjaXNpb24gPSBwb3coMTAsIHByZWNpc2lvbik7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uc29ydGVkSW5kZXhgIG9yIGBfLnNvcnRlZExhc3RJbmRleGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbmRleCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTb3J0ZWRJbmRleChyZXRIaWdoZXN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSk7XG4gICAgICAgIHJldHVybiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBjYWxsYmFjayA9PT0gYmFzZUNhbGxiYWNrKVxuICAgICAgICAgID8gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KVxuICAgICAgICAgIDogYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGNhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKSwgcmV0SGlnaGVzdCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgIDI1NiAtIGBfLmFyeWBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihQQVJUSUFMX0ZMQUcgfCBQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggLT0gKGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDApO1xuICAgICAgaWYgKGJpdG1hc2sgJiBQQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpLFxuICAgICAgICAgIG5ld0RhdGEgPSBbZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgICAgYXJpdHkgPSBuZXdEYXRhWzldO1xuICAgICAgfVxuICAgICAgbmV3RGF0YVs5XSA9IGFyaXR5ID09IG51bGxcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IChuYXRpdmVNYXgoYXJpdHkgLSBsZW5ndGgsIDApIHx8IDApO1xuXG4gICAgICBpZiAoYml0bWFzayA9PSBCSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmRXcmFwcGVyKG5ld0RhdGFbMF0sIG5ld0RhdGFbMl0pO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBQQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoQklORF9GTEFHIHwgUEFSVElBTF9GTEFHKSkgJiYgIW5ld0RhdGFbNF0ubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWxXcmFwcGVyLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWRXcmFwcGVyLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIGFycmF5cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc0xvb3NlICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihpc0xvb3NlID8gb3RoVmFsdWUgOiBhcnJWYWx1ZSwgaXNMb29zZSA/IGFyclZhbHVlIDogb3RoVmFsdWUsIGluZGV4KSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChpc0xvb3NlKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsLlxuICAgICAgICAgIHJldHVybiArb2JqZWN0ID09ICtvdGhlcjtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuICAgICAgICAgIHJldHVybiAob2JqZWN0ICE9ICtvYmplY3QpXG4gICAgICAgICAgICA/IG90aGVyICE9ICtvdGhlclxuICAgICAgICAgICAgOiBvYmplY3QgPT0gK290aGVyO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzIHByaW1pdGl2ZXMgYW5kIHN0cmluZ1xuICAgICAgICAgIC8vIG9iamVjdHMgYXMgZXF1YWwuIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xMC42LjQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzTG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNMb29zZSA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc0xvb3NlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKGlzTG9vc2UgPyBvdGhWYWx1ZSA6IG9ialZhbHVlLCBpc0xvb3NlPyBvYmpWYWx1ZSA6IG90aFZhbHVlLCBrZXkpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSA6IHJlc3VsdCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKCFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiY2FsbGJhY2tcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmNhbGxiYWNrYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VDYWxsYmFja2AgZnVuY3Rpb24uIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdGhlIGNob3NlbiBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZCBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLmNhbGxiYWNrIHx8IGNhbGxiYWNrO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBjYWxsYmFjayA/IGJhc2VDYWxsYmFjayA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmdDb3VudCA/IHJlc3VsdChmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMubmFtZSxcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImluZGV4T2ZcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmluZGV4T2ZgIG1ldGhvZCBpc1xuICAgICAqIGN1c3RvbWl6ZWQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRoZSBjaG9zZW4gZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmQgaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufG51bWJlcn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mIHx8IGluZGV4T2Y7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGluZGV4T2YgPyBiYXNlSW5kZXhPZiA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uID8gcmVzdWx0KGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICAgICAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhaXJzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdWzJdID0gaXNTdHJpY3RDb21wYXJhYmxlKHJlc3VsdFtsZW5ndGhdWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1zIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAvLyBBZGQgYXJyYXkgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICAgICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICghKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IpKSB7XG4gICAgICAgIEN0b3IgPSBPYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICByZXR1cm4gYnVmZmVyQ2xvbmUob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICB2YXIgYnVmZmVyID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoaXNEZWVwID8gYnVmZmVyQ2xvbmUoYnVmZmVyKSA6IGJ1ZmZlciwgb2JqZWN0LmJ5dGVPZmZzZXQsIG9iamVjdC5sZW5ndGgpO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3Iob2JqZWN0LnNvdXJjZSwgcmVGbGFncy5leGVjKG9iamVjdCkpO1xuICAgICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSBvYmplY3QubGFzdEluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlUGF0aChvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiAhaXNLZXkocGF0aCwgb2JqZWN0KSkge1xuICAgICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICBwYXRoID0gbGFzdChwYXRoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbcGF0aF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogZnVuYy5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSA/ICt2YWx1ZSA6IC0xO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICAgICAgcmV0dXJuIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICgodHlwZSA9PSAnc3RyaW5nJyAmJiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpKSB8fCB0eXBlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdCB8fCAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gdG9PYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpO1xuICAgICAgaWYgKCEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyByZXF1aXJlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmQgYF8ucmVhcmdgXG4gICAgICogYXVnbWVudCBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmUgZXhlY3V0ZWQgaW1wb3J0YW50LFxuICAgICAqIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2UgYW4gZXhjZXB0aW9uIGZvciBhIHNhZmVcbiAgICAgKiBjb21tb24gY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWAgYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCBBUllfRkxBRztcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoc3JjQml0bWFzayA9PSBBUllfRkxBRyAmJiBiaXRtYXNrID09IENVUlJZX0ZMQUcpIHx8XG4gICAgICAgIChzcmNCaXRtYXNrID09IEFSWV9GTEFHICYmIGJpdG1hc2sgPT0gUkVBUkdfRkxBRyAmJiBkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pIHx8XG4gICAgICAgIChzcmNCaXRtYXNrID09IChBUllfRkxBRyB8IFJFQVJHX0ZMQUcpICYmIGJpdG1hc2sgPT0gQ1VSUllfRkxBRyk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIEJJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IChiaXRtYXNrICYgQklORF9GTEFHKSA/IDAgOiBDVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBhcnJheUNvcHkoc291cmNlWzRdKTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogYXJyYXlDb3B5KHNvdXJjZVs2XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIEFSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VWYWx1ZSBUaGUgc291cmNlIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3RWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlVmFsdWUgOiBtZXJnZShvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIG1lcmdlRGVmYXVsdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5waWNrYCB3aGljaCBwaWNrcyBgb2JqZWN0YCBwcm9wZXJ0aWVzIHNwZWNpZmllZFxuICAgICAqIGJ5IGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnlBcnJheShvYmplY3QsIHByb3BzKSB7XG4gICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucGlja2Agd2hpY2ggcGlja3MgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYFxuICAgICAqIHJldHVybnMgdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBiYXNlRm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBhcnJheUNvcHkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5IGZ1bmN0aW9uXG4gICAgICogdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhbXAgPSBub3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlU2V0RGF0YShrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGg7XG5cbiAgICAgIHZhciBhbGxvd0luZGV4ZXMgPSAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS1saWtlIG9iamVjdCBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gb2JqZWN0IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBwcm9wZXJ0eSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZVRvU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gd3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyXG4gICAgICAgID8gd3JhcHBlci5jbG9uZSgpXG4gICAgICAgIDogbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18sIGFycmF5Q29weSh3cmFwcGVyLl9fYWN0aW9uc19fKSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgY29sbGVjdGlvbmAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IGNvbnRhaW5pbmcgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgobmF0aXZlRmxvb3Ioc2l6ZSkgfHwgMSwgMSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlclxuICAgICAqIHByb3ZpZGVkIGFycmF5cyB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheXMgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzEsIDIsIDNdLCBbNCwgMl0pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoaXNPYmplY3RMaWtlKGFycmF5KSAmJiBpc0FycmF5TGlrZShhcnJheSkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgZmFsc2UsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIG4gPSBsZW5ndGggLSAoK24gfHwgMCk7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4XSwgJyonLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCA4XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIudXNlciA9PSAnYmFybmV5JztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBmaW5kSW5kZXggPSBjcmVhdGVGaW5kSW5kZXgoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIudXNlciA9PSAncGViYmxlcyc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0SW5kZXggPSBjcmVhdGVGaW5kSW5kZXgodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5maXJzdChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5LiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgdGhlIGFycmF5IGlzIHJlY3Vyc2l2ZWx5XG4gICAgICogZmxhdHRlbmVkLCBvdGhlcndpc2UgaXQgaXMgb25seSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCAzLCBbNF1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBpc0RlZXBgXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgMywgWzRdXV0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIGlzRGVlcCwgZ3VhcmQpKSB7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBpc0RlZXApIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVjdXJzaXZlbHkgZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCAzLCBbNF1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIHRydWUpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZSBvZmZzZXRcbiAgICAgKiBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBzb3J0ZWQgcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGBcbiAgICAgKiBwZXJmb3JtcyBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tIG9yIGB0cnVlYFxuICAgICAqICB0byBwZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgZnJvbUluZGV4YFxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIHBlcmZvcm1pbmcgYSBiaW5hcnkgc2VhcmNoXG4gICAgICogXy5pbmRleE9mKFsxLCAxLCAyLCAyXSwgMiwgdHJ1ZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCkgOiBmcm9tSW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiZcbiAgICAgICAgICAgICh2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IGFycmF5W2luZGV4XSkgOiAoYXJyYXlbaW5kZXhdICE9PSBhcnJheVtpbmRleF0pKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHJldHVybiBkcm9wUmlnaHQoYXJyYXksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgb2YgdGhlIHByb3ZpZGVkXG4gICAgICogYXJyYXlzIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMl0sIFs0LCAyXSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaW5kZXhPZiA9PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlzW290aEluZGV4XSA9IGlzQXJyYXlMaWtlKHZhbHVlID0gYXJyYXlzW290aEluZGV4XSkgPyB2YWx1ZSA6IFtdO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gKGlzQ29tbW9uICYmIHZhbHVlLmxlbmd0aCA+PSAxMjApID8gY3JlYXRlQ2FjaGUob3RoSW5kZXggJiYgdmFsdWUpIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IGFycmF5c1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoKHNlZW4gPyBjYWNoZUluZGV4T2Yoc2VlbiwgdmFsdWUpIDogaW5kZXhPZihyZXN1bHQsIHZhbHVlLCAwKSkgPCAwKSB7XG4gICAgICAgICAgdmFyIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcnJheXNbb3RoSW5kZXhdLCB2YWx1ZSwgMCkpIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tXG4gICAgICogIG9yIGB0cnVlYCB0byBwZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGZyb21JbmRleGBcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gcGVyZm9ybWluZyBhIGJpbmFyeSBzZWFyY2hcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAxLCAyLCAyXSwgMiwgdHJ1ZSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogbmF0aXZlTWluKGZyb21JbmRleCB8fCAwLCBsZW5ndGggLSAxKSkgKyAxO1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgaW5kZXggPSBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBvdGhlcikgOiAob3RoZXIgIT09IG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleE9mTmFOKGFycmF5LCBpbmRleCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHByb3ZpZGVkIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAyLCAzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbCgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFycmF5ID0gYXJnc1swXTtcblxuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpKSA+IC0xKSB7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmRleGVzIGFuZCByZXR1cm5zXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIEluZGV4ZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZlxuICAgICAqIGluZGV4ZXMgb3IgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLFxuICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFs1LCAxMCwgMTUsIDIwXTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnB1bGxBdChhcnJheSwgMSwgMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzUsIDE1XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsxMCwgMjBdXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgaW5kZXhlcyA9IGJhc2VGbGF0dGVuKGluZGV4ZXMpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMuc29ydChiYXNlQ29tcGFyZUFzY2VuZGluZykpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdGFpbFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoYXJyYXkpIHtcbiAgICAgIHJldHVybiBkcm9wKGFycmF5LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2YgYEFycmF5I3NsaWNlYCB0byBzdXBwb3J0IG5vZGVcbiAgICAgKiBsaXN0cyBpbiBJRSA8IDkgYW5kIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGRcbiAgICAgKiBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuIElmIGFuIGl0ZXJhdGVlXG4gICAgICogZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWBcbiAgICAgKiB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbNCwgNCwgNSwgNV0sIDUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBkaWN0ID0geyAnZGF0YSc6IHsgJ3RoaXJ0eSc6IDMwLCAnZm9ydHknOiA0MCwgJ2ZpZnR5JzogNTAgfSB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYW4gaXRlcmF0ZWUgZnVuY3Rpb25cbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndGhpcnR5JywgJ2ZpZnR5J10sICdmb3J0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmRhdGFbd29yZF07XG4gICAgICogfSwgZGljdCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvcnRlZEluZGV4KFt7ICd4JzogMzAgfSwgeyAneCc6IDUwIH1dLCB7ICd4JzogNDAgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgdmFyIHNvcnRlZEluZGV4ID0gY3JlYXRlU29ydGVkSW5kZXgoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgdmFyIHNvcnRlZExhc3RJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgbiA9IGxlbmd0aCAtICgrbiB8fCAwKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZX0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIG9mIHRoZSBwcm92aWRlZCBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDRdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgZmFsc2UsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gUHJvdmlkaW5nIGB0cnVlYCBmb3IgYGlzU29ydGVkYCBwZXJmb3JtcyBhIGZhc3RlciBzZWFyY2ggYWxnb3JpdGhtXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuIElmIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yXG4gICAgICogZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHVuaXF1ZW5lc3NcbiAgICAgKiBpcyBjb21wdXRlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bmlxdWVcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZF0gU3BlY2lmeSB0aGUgYXJyYXkgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBpc1NvcnRlZGBcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDJdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDEuNSwgMl0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjVdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8udW5pcShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzU29ydGVkICE9IG51bGwgJiYgdHlwZW9mIGlzU29ydGVkICE9ICdib29sZWFuJykge1xuICAgICAgICB0aGlzQXJnID0gaXRlcmF0ZWU7XG4gICAgICAgIGl0ZXJhdGVlID0gaXNJdGVyYXRlZUNhbGwoYXJyYXksIGlzU29ydGVkLCB0aGlzQXJnKSA/IHVuZGVmaW5lZCA6IGlzU29ydGVkO1xuICAgICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soKTtcbiAgICAgIGlmICghKGl0ZXJhdGVlID09IG51bGwgJiYgY2FsbGJhY2sgPT09IGJhc2VDYWxsYmFjaykpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSBjYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGlzU29ydGVkICYmIGdldEluZGV4T2YoKSA9PSBiYXNlSW5kZXhPZilcbiAgICAgICAgPyBzb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSlcbiAgICAgICAgOiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBpdGVyYXRlZSB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpO1xuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGdyb3VwLCBpdGVyYXRlZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBwcm92aWRlZCB2YWx1ZXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzEsIDIsIDEsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2UoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZSBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMSwgMl0sIFs0LCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24geG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKGFycmF5KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgID8gYXJyYXlQdXNoKGJhc2VEaWZmZXJlbmNlKHJlc3VsdCwgYXJyYXkpLCBiYXNlRGlmZmVyZW5jZShhcnJheSwgcmVzdWx0KSlcbiAgICAgICAgICAgIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgPyBiYXNlVW5pcShyZXN1bHQpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGUgc2Vjb25kIGVsZW1lbnRzXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gcmVzdFBhcmFtKHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnBhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXNcbiAgICAgKiBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgdmFsdWVzLiBQcm92aWRlIGVpdGhlciBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksXG4gICAgICogZS5nLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gIG9yIHR3byBhcnJheXMsIG9uZSBvZiBwcm9wZXJ0eSBuYW1lc1xuICAgICAqIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgb2JqZWN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoW1snZnJlZCcsIDMwXSwgWydiYXJuZXknLCA0MF1dKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzID8gcHJvcHMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKGxlbmd0aCAmJiAhdmFsdWVzICYmICFpc0FycmF5KHByb3BzWzBdKSkge1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gaXRlcmF0ZWUgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgXy5hZGQpO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMiA/IGFycmF5c1tsZW5ndGggLSAyXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0aGlzQXJnID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGxlbmd0aCA+IDIgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbGVuZ3RoIC09IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlZSA9IChsZW5ndGggPiAxICYmIHR5cGVvZiB0aGlzQXJnID09ICdmdW5jdGlvbicpID8gKC0tbGVuZ3RoLCB0aGlzQXJnKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFycmF5cy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUsIHRoaXNBcmcpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgICByZXR1cm4gY2hyLnVzZXIgKyAnIGlzICcgKyBjaHIuYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnNcbiAgICAgKiBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yLCB0aGlzQXJnKSB7XG4gICAgICBpbnRlcmNlcHRvci5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvciwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZXhwbGljaXQgbWV0aG9kIGNoYWluaW5nIG9uIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8odXNlcnMpLmZpcnN0KCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gd2l0aCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8odXNlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW5lZCBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBqb2luaW5nIGEgd3JhcHBlZCBhcnJheSB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb25jYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLmNvbmNhdCgyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHdyYXBwZWQudmFsdWUoKSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgd3JhcHBlckNvbmNhdCA9IHJlc3RQYXJhbShmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHZhbHVlcyA9IGJhc2VGbGF0dGVuKHZhbHVlcyk7XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheUNvbmNhdChpc0FycmF5KGFycmF5KSA/IGFycmF5IDogW3RvT2JqZWN0KGFycmF5KV0sIHZhbHVlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW5lZCBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLnBvdyh2YWx1ZSwgMik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSBbMywgNF07XG4gICAgICogdmFyIG90aGVyV3JhcHBlZCA9IHdyYXBwZWQucGxhbnQob3RoZXIpO1xuICAgICAqXG4gICAgICogb3RoZXJXcmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSB3cmFwcGVkIGFycmF5IHNvIHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcblxuICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh3cmFwcGVkICYmIHdyYXBwZWQuX19kaXJfXyA8IDApID8gdmFsdWUgOiB2YWx1ZS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIHRoZSByZXN1bHQgb2YgY29lcmNpbmcgdGhlIHVud3JhcHBlZCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBuYW1lIHRvU3RyaW5nXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb2VyY2VkIHN0cmluZyB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZSgpICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbmVkIHNlcXVlbmNlIHRvIGV4dHJhY3QgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgcnVuLCB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleXMsIG9yIGluZGV4ZXMsXG4gICAgICogb2YgYGNvbGxlY3Rpb25gLiBLZXlzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2Yga2V5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW118c3RyaW5nfHN0cmluZ1tdKX0gW3Byb3BzXSBUaGUgcHJvcGVydHkgbmFtZXNcbiAgICAgKiAgb3IgaW5kZXhlcyBvZiBlbGVtZW50cyB0byBwaWNrLCBzcGVjaWZpZWQgaW5kaXZpZHVhbGx5IG9yIGluIGFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwaWNrZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXQoWydhJywgJ2InLCAnYyddLCBbMCwgMl0pO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIF8uYXQoWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ10sIDAsIDIpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIHZhciBhdCA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBwcm9wcykge1xuICAgICAgcmV0dXJuIGJhc2VBdChjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihwcm9wcykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyArK3Jlc3VsdFtrZXldIDogKHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFsbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzQsIDUsIDZdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbNCwgNl1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChiYXNlRWFjaFJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCBhbmQgdGhlXG4gICAgICogc291cmNlIG9iamVjdCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaGFzIGVxdWl2YWxlbnQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KF8uZmluZFdoZXJlKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KF8uZmluZFdoZXJlKHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRXaGVyZShjb2xsZWN0aW9uLCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmaW5kKGNvbGxlY3Rpb24sIGJhc2VNYXRjaGVzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gICAgICogYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiIHByb3BlcnR5XG4gICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAgICogbWF5IGJlIHVzZWQgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDJdKS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKG4pO1xuICAgICAqIH0pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlIGZyb20gbGVmdCB0byByaWdodCBhbmQgcmV0dXJucyB0aGUgYXJyYXlcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2cobiwga2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUta2V5IHBhaXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciBmb3JFYWNoID0gY3JlYXRlRm9yRWFjaChhcnJheUVhY2gsIGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMl0pLmZvckVhY2hSaWdodChmdW5jdGlvbihuKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhuKTtcbiAgICAgKiB9KS52YWx1ZSgpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICovXG4gICAgdmFyIGZvckVhY2hSaWdodCA9IGNyZWF0ZUZvckVhY2goYXJyYXlFYWNoUmlnaHQsIGJhc2VFYWNoUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLmZsb29yKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZSBvZmZzZXRcbiAgICAgKiBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbnRhaW5zLCBpbmNsdWRlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBtYXRjaGluZyBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygncGViYmxlcycsICdlYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pIDogMDtcbiAgICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgICAgICBjb2xsZWN0aW9uID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ICE9ICdudW1iZXInIHx8IChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbCh0YXJnZXQsIGZyb21JbmRleCwgZ3VhcmQpKSkge1xuICAgICAgICBmcm9tSW5kZXggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogKGZyb21JbmRleCB8fCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAodHlwZW9mIGNvbGxlY3Rpb24gPT0gJ3N0cmluZycgfHwgIWlzQXJyYXkoY29sbGVjdGlvbikgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHRhcmdldCwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6ICghIWxlbmd0aCAmJiBnZXRJbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIga2V5RGF0YSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5RGF0YSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5RGF0YSwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvYmplY3QuY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZnJvbUNoYXJDb2RlKG9iamVjdC5jb2RlKTtcbiAgICAgKiB9LCBTdHJpbmcpO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIgaW5kZXhCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYG1ldGhvZE5hbWVgIGlzIGEgZnVuY3Rpb24gaXQgaXNcbiAgICAgKiBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgaXNQcm9wID0gaXNLZXkocGF0aCksXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBwYXRoIDogKChpc1Byb3AgJiYgdmFsdWUgIT0gbnVsbCkgPyB2YWx1ZVtwYXRoXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGZ1bmMgPyBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKSA6IGludm9rZVBhdGgodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocm91Z2hcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNhbGxiYWNrYCwgYGNodW5rYCwgYGNsb25lYCwgYGNyZWF0ZWAsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCxcbiAgICAgKiBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLCBgZmlsbGAsIGBmbGF0dGVuYCwgYGludmVydGAsIGBtYXhgLCBgbWluYCxcbiAgICAgKiBgcGFyc2VJbnRgLCBgc2xpY2VgLCBgc29ydEJ5YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRlbXBsYXRlYCwgYHRyaW1gLFxuICAgICAqIGB0cmltTGVmdGAsIGB0cmltUmlnaHRgLCBgdHJ1bmNgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHNhbXBsZWAsIGBzb21lYCxcbiAgICAgKiBgc3VtYCwgYHVuaXFgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbGxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHRpbWVzVGhyZWUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFsxLCAyXSwgdGltZXNUaHJlZSk7XG4gICAgICogLy8gPT4gWzMsIDZdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogMSwgJ2InOiAyIH0sIHRpbWVzVGhyZWUpO1xuICAgICAqIC8vID0+IFszLCA2XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHdoaWxlIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFtbMSwgM10sIFsyXV1cbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKFsxLjIsIDIuMywgMy40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3IobikgJSAyO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFtbMS4yLCAzLjRdLCBbMi4zXV1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBtYXBwZXIgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgcmV0dXJuIF8ucGx1Y2soYXJyYXksICd1c2VyJyk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pLCBtYXBwZXIpO1xuICAgICAqIC8vID0+IFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnLCBmYWxzZSksIG1hcHBlcik7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyksIG1hcHBlcik7XG4gICAgICogLy8gPT4gW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYHBhdGhgIGZyb20gYWxsIGVsZW1lbnRzIGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2sodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiB2YXIgdXNlckluZGV4ID0gXy5pbmRleEJ5KHVzZXJzLCAndXNlcicpO1xuICAgICAqIF8ucGx1Y2sodXNlckluZGV4LCAnYWdlJyk7XG4gICAgICogLy8gPT4gWzM2LCA0MF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwbHVjayhjb2xsZWN0aW9uLCBwYXRoKSB7XG4gICAgICByZXR1cm4gbWFwKGNvbGxlY3Rpb24sIHByb3BlcnR5KHBhdGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IHByb3ZpZGVkIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgc29ydEJ5QWxsYCxcbiAgICAgKiBhbmQgYHNvcnRCeU9yZGVyYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRsLCBpbmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbih0b3RhbCwgbikge1xuICAgICAqICAgcmV0dXJuIHRvdGFsICsgbjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbiwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG4gKiAzO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHJlZHVjZSA9IGNyZWF0ZVJlZHVjZShhcnJheVJlZHVjZSwgYmFzZUVhY2gpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgdmFyIHJlZHVjZVJpZ2h0ID0gY3JlYXRlUmVkdWNlKGFycmF5UmVkdWNlUmlnaHQsIGJhc2VFYWNoUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWplY3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBvciBgbmAgcmFuZG9tIGVsZW1lbnRzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBjb2xsZWN0aW9uID0gdG9JdGVyYWJsZShjb2xsZWN0aW9uKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID4gMCA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0b0FycmF5KGNvbGxlY3Rpb24pLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgbiA9IG5hdGl2ZU1pbihuIDwgMCA/IDAgOiAoK24gfHwgMCksIGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRbcmFuZF07XG5cbiAgICAgICAgcmVzdWx0W3JhbmRdID0gcmVzdWx0W2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzYW1wbGUoY29sbGVjdGlvbiwgUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pIDogMDtcbiAgICAgIHJldHVybiBpc0xlbmd0aChsZW5ndGgpID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFzIHNvb24gYXMgaXQgZmluZHMgYSBwYXNzaW5nIHZhbHVlIGFuZCBkb2VzIG5vdCBpdGVyYXRlXG4gICAgICogb3ZlciB0aGUgZW50aXJlIGNvbGxlY3Rpb24uIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFueVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoaXMgbWV0aG9kIHBlcmZvcm1zXG4gICAgICogYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mIGVxdWFsIGVsZW1lbnRzLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIE1hdGguc2luKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5zaW4obik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5zb3J0QnkodXNlcnMsICd1c2VyJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBjb21wYXJlQXNjZW5kaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgY2FuIHNvcnQgYnkgbXVsdGlwbGUgaXRlcmF0ZWVzXG4gICAgICogb3IgcHJvcGVydHkgbmFtZXMuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGFuIGl0ZXJhdGVlIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXXxPYmplY3R8T2JqZWN0W118c3RyaW5nfHN0cmluZ1tdKX0gaXRlcmF0ZWVzXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieSwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgdmFsdWVzIG9yIGFycmF5cyBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQyIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5QWxsKHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDJdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeUFsbCh1c2VycywgJ3VzZXInLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLmZsb29yKGNoci5hZ2UgLyAxMCk7XG4gICAgICogfSksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQyXV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5QWxsID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgZ3VhcmQgPSBpdGVyYXRlZXNbMl07XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBpdGVyYXRlZXMubGVuZ3RoID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5T3JkZXIoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlBbGxgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZVxuICAgICAqIHNvcnQgb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbFxuICAgICAqIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBhIHZhbHVlIGlzIHNvcnRlZCBpblxuICAgICAqIGFzY2VuZGluZyBvcmRlciBpZiBpdHMgY29ycmVzcG9uZGluZyBvcmRlciBpcyBcImFzY1wiLCBhbmQgZGVzY2VuZGluZyBpZiBcImRlc2NcIi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGFuIGl0ZXJhdGVlIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFuW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDIgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gc29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICogXy5tYXAoXy5zb3J0QnlPcmRlcih1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0Ml1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5T3JkZXIoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpKSB7XG4gICAgICAgIG9yZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5T3JkZXIoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCBhbmQgdGhlXG4gICAgICogc291cmNlIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayhfLndoZXJlKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAncGV0cyc6IFsnZGlubyddIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2hlcmUoY29sbGVjdGlvbiwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGJhc2VNYXRjaGVzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAgICAgKiAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gbG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgZnVuY3Rpb24gdG8gYmUgaW52b2tlZFxuICAgICAqL1xuICAgIHZhciBub3cgPSBuYXRpdmVOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQgaXMgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSBuO1xuICAgICAgICAgIG4gPSBmdW5jO1xuICAgICAgICAgIGZ1bmMgPSB0ZW1wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbiA9IG5hdGl2ZUlzRmluaXRlKG4gPSArbikgPyBuIDogMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gYG5gIGFyZ3VtZW50cyBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgbiwgZ3VhcmQpKSB7XG4gICAgICAgIG4gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbmF0aXZlTWF4KCtuIHx8IDAsIDApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQgaXMgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeSgnI2FkZCcpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBhbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSBuO1xuICAgICAgICAgIG4gPSBmdW5jO1xuICAgICAgICAgIGZ1bmMgPSB0ZW1wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYF8uYmluZGAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgIHRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBiaW5kLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgYml0bWFzayB8PSBQQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLiBNZXRob2QgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBtZXRob2QgbmFtZXMuIElmIG5vIG1ldGhvZCBuYW1lcyBhcmUgcHJvdmlkZWQgYWxsIGVudW1lcmFibGUgZnVuY3Rpb25cbiAgICAgKiBwcm9wZXJ0aWVzLCBvd24gYW5kIGluaGVyaXRlZCwgb2YgYG9iamVjdGAgYXJlIGJvdW5kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFttZXRob2ROYW1lc10gVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZCxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgbWV0aG9kIG5hbWVzIG9yIGFycmF5cyBvZiBtZXRob2QgbmFtZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnb25DbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3KTtcbiAgICAgKiBqUXVlcnkoJyNkb2NzJykub24oJ2NsaWNrJywgdmlldy5vbkNsaWNrKTtcbiAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gdGhlIGVsZW1lbnQgaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIG1ldGhvZE5hbWVzID0gbWV0aG9kTmFtZXMubGVuZ3RoID8gYmFzZUZsYXR0ZW4obWV0aG9kTmFtZXMpIDogZnVuY3Rpb25zKG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IG1ldGhvZE5hbWVzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBjcmVhdGVXcmFwcGVyKG9iamVjdFtrZXldLCBCSU5EX0ZMQUcsIG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgYW5kIHByZXBlbmRzXG4gICAgICogYW55IGFkZGl0aW9uYWwgYF8uYmluZEtleWAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXG4gICAgICogbWV0aG9kcyB0aGF0IG1heSBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LlxuICAgICAqIFNlZSBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ3VzZXInOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZEtleSA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gQklORF9GTEFHIHwgQklORF9LRVlfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgYmluZEtleS5wbGFjZWhvbGRlcik7XG4gICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgYXJndW1lbnRzIG9mIGBmdW5jYCB0aGF0IHdoZW5cbiAgICAgKiBjYWxsZWQgZWl0aGVyIGludm9rZXMgYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhbGwgYGZ1bmNgIGFyZ3VtZW50c1xuICAgICAqIGhhdmUgYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBvZiB0aGVcbiAgICAgKiByZW1haW5pbmcgYGZ1bmNgIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWRcbiAgICAgKiBpZiBgZnVuYy5sZW5ndGhgIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgdmFyIGN1cnJ5ID0gY3JlYXRlQ3VycnkoQ1VSUllfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgdmFyIGN1cnJ5UmlnaHQgPSBjcmVhdGVDdXJyeShDVVJSWV9SSUdIVF9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGludm9jYXRpb25zLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdFxuICAgICAqIGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwOi8vZHJ1cGFsbW90aW9uLmNvbS9hcnRpY2xlL2RlYm91bmNlLWFuZC10aHJvdHRsZS12aXN1YWwtZXhwbGFuYXRpb24pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZVxuICAgICAqICBkZWxheWVkIGJlZm9yZSBpdCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gY2FuY2VsIGEgZGVib3VuY2VkIGNhbGxcbiAgICAgKiB2YXIgdG9kb0NoYW5nZXMgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAxMDAwKTtcbiAgICAgKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMudG9kbywgdG9kb0NoYW5nZXMpO1xuICAgICAqXG4gICAgICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLCBmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICogICBpZiAoXy5maW5kKGNoYW5nZXMsIHsgJ3VzZXInOiAndG9kbycsICd0eXBlJzogJ2RlbGV0ZSd9KSkge1xuICAgICAqICAgICB0b2RvQ2hhbmdlcy5jYW5jZWwoKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9LCBbJ2RlbGV0ZSddKTtcbiAgICAgKlxuICAgICAqIC8vIC4uLmF0IHNvbWUgcG9pbnQgYG1vZGVscy50b2RvYCBpcyBjaGFuZ2VkXG4gICAgICogbW9kZWxzLnRvZG8uY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgKlxuICAgICAqIC8vIC4uLmJlZm9yZSAxIHNlY29uZCBoYXMgcGFzc2VkIGBtb2RlbHMudG9kb2AgaXMgZGVsZXRlZFxuICAgICAqIC8vIHdoaWNoIGNhbmNlbHMgdGhlIGRlYm91bmNlZCBgdG9kb0NoYW5nZXNgIGNhbGxcbiAgICAgKiBkZWxldGUgbW9kZWxzLnRvZG87XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgbWF4VGltZW91dElkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHdhaXQgPCAwID8gMCA6ICgrd2FpdCB8fCAwKTtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgbmF0aXZlTWF4KCtvcHRpb25zLm1heFdhaXQgfHwgMCwgd2FpdCk7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2FsbGVkID0gMDtcbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb21wbGV0ZShpc0NhbGxlZCwgaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWxheWVkKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgICBjb21wbGV0ZSh0cmFpbGluZ0NhbGwsIG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1heERlbGF5ZWQoKSB7XG4gICAgICAgIGNvbXBsZXRlKHRyYWlsaW5nLCB0aW1lb3V0SWQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN0YW1wID0gbm93KCk7XG4gICAgICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgICAgICBpZiAobWF4V2FpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtYXhUaW1lb3V0SWQgJiYgIWxlYWRpbmcpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IG1heFdhaXQgLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKSxcbiAgICAgICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiBtYXhXYWl0O1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gbG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIHZhciBkZWZlciA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHByb3ZpZGVkXG4gICAgICogZnVuY3Rpb25zIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNzXSBGdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coXy5hZGQsIHNxdWFyZSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGJhY2tmbG93LCBjb21wb3NlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNzXSBGdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChzcXVhcmUsIF8uYWRkKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgY29lcmNlZCB0byBhIHN0cmluZyBhbmQgdXNlZCBhcyB0aGVcbiAgICAgKiBjYWNoZSBrZXkuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZSBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemluZyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVwcGVyQ2FzZSA9IF8ubWVtb2l6ZShmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBzdHJpbmcudG9VcHBlckNhc2UoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHVwcGVyQ2FzZSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqXG4gICAgICogLy8gbW9kaWZ5aW5nIHRoZSByZXN1bHQgY2FjaGVcbiAgICAgKiB1cHBlckNhc2UuY2FjaGUuc2V0KCdmcmVkJywgJ0JBUk5FWScpO1xuICAgICAqIHVwcGVyQ2FzZSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdCQVJORVknXG4gICAgICpcbiAgICAgKiAvLyByZXBsYWNpbmcgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ3VzZXInOiAnYmFybmV5JyB9O1xuICAgICAqIHZhciBpZGVudGl0eSA9IF8ubWVtb2l6ZShfLmlkZW50aXR5KTtcbiAgICAgKlxuICAgICAqIGlkZW50aXR5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogaWRlbnRpdHkob3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKiB2YXIgaWRlbnRpdHkgPSBfLm1lbW9pemUoXy5pZGVudGl0eSk7XG4gICAgICpcbiAgICAgKiBpZGVudGl0eShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIGlkZW50aXR5KG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IG1lbW9pemUuQ2FjaGU7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcnVucyBlYWNoIGFyZ3VtZW50IHRocm91Z2ggYSBjb3JyZXNwb25kaW5nXG4gICAgICogdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXNdIFRoZSBmdW5jdGlvbnMgdG8gdHJhbnNmb3JtXG4gICAgICogYXJndW1lbnRzLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBmdW5jdGlvbnMgb3IgYXJyYXlzIG9mIGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgbW9kZGVkID0gXy5tb2RBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgc3F1YXJlLCBkb3VibGVkKTtcbiAgICAgKlxuICAgICAqIG1vZGRlZCgxLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKlxuICAgICAqIG1vZGRlZCg1LCAxMCk7XG4gICAgICogLy8gPT4gWzI1LCAyMF1cbiAgICAgKi9cbiAgICB2YXIgbW9kQXJncyA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gYmFzZUZsYXR0ZW4odHJhbnNmb3Jtcyk7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAhYXJyYXlFdmVyeSh0cmFuc2Zvcm1zLCBiYXNlSXNGdW5jdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJlc3RQYXJhbShmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdKGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNhbGwuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyBgaW5pdGlhbGl6ZWAgaW52b2tlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0XG4gICAgICogaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gY3JlYXRlUGFydGlhbChQQVJUSUFMX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBjcmVhdGVQYXJ0aWFsKFBBUlRJQUxfUklHSFRfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLFxuICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCAyLCAwLCAxKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIHZhciBtYXAgPSBfLnJlYXJnKF8ubWFwLCBbMSwgMF0pO1xuICAgICAqIG1hcChmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDM7XG4gICAgICogfSwgWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV1cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYmFzZUZsYXR0ZW4oaW5kZXhlcykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3RQYXJhbShmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3RQYXJhbShmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogKCtzdGFydCB8fCAwKSwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdFtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3RhcnQpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCByZXN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gcmVzdDtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZSBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjMpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvU3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYSBQcm9taXNlXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcnJheSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBpbnZvY2F0aW9ucy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZVxuICAgICAqIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZVxuICAgICAqIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cDovL2RydXBhbG1vdGlvbi5jb20vYXJ0aWNsZS9kZWJvdW5jZS1hbmQtdGhyb3R0bGUtdmlzdWFsLWV4cGxhbmF0aW9uKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGNhbmNlbCBhIHRyYWlsaW5nIHRocm90dGxlZCBjYWxsXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHsgJ2xlYWRpbmcnOiBsZWFkaW5nLCAnbWF4V2FpdCc6ICt3YWl0LCAndHJhaWxpbmcnOiB0cmFpbGluZyB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZVxuICAgICAqIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICB3cmFwcGVyID0gd3JhcHBlciA9PSBudWxsID8gaWRlbnRpdHkgOiB3cmFwcGVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIod3JhcHBlciwgUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIFt2YWx1ZV0sIFtdKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIGFyZSBjbG9uZWQsXG4gICAgICogb3RoZXJ3aXNlIHRoZXkgYXJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnQ7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdF0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0pLlxuICAgICAqIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmQgb2JqZWN0cyBjcmVhdGVkIGJ5XG4gICAgICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICAgICAqIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2ggYXMgZnVuY3Rpb25zLCBET00gbm9kZXMsXG4gICAgICogTWFwcywgU2V0cywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKHVzZXJzKTtcbiAgICAgKiBzaGFsbG93WzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUodXNlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZWwgPT09IGRvY3VtZW50LmJvZHlcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGVsLm5vZGVOYW1lXG4gICAgICogLy8gPT4gQk9EWVxuICAgICAqIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoaXNEZWVwICYmIHR5cGVvZiBpc0RlZXAgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIpKSB7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGlzRGVlcCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjdXN0b21pemVyO1xuICAgICAgICBjdXN0b21pemVyID0gaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAxKSlcbiAgICAgICAgOiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWRcbiAgICAgKiB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nXG4gICAgICogaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnQ7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdF0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0pLlxuICAgICAqIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmQgb2JqZWN0cyBjcmVhdGVkIGJ5XG4gICAgICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICAgICAqIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2ggYXMgZnVuY3Rpb25zLCBET00gbm9kZXMsXG4gICAgICogTWFwcywgU2V0cywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKHVzZXJzKTtcbiAgICAgKiBkZWVwWzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXAoZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGVsID09PSBkb2N1bWVudC5ib2R5XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBlbC5ub2RlTmFtZVxuICAgICAqIC8vID0+IEJPRFlcbiAgICAgKiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAxKSlcbiAgICAgICAgOiBiYXNlQ2xvbmUodmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ3QodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ3RlKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5VGFnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICEhdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZW1wdHkuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBlbXB0eSB1bmxlc3MgaXQgaXMgYW5cbiAgICAgKiBgYXJndW1lbnRzYCBvYmplY3QsIGFycmF5LCBzdHJpbmcsIG9yIGpRdWVyeS1saWtlIGNvbGxlY3Rpb24gd2l0aCBhIGxlbmd0aFxuICAgICAqIGdyZWF0ZXIgdGhhbiBgMGAgb3IgYW4gb2JqZWN0IHdpdGggb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc1N0cmluZyh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gIWtleXModmFsdWUpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZFxuICAgICAqIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgb3RoZXIgWywgaW5kZXh8a2V5XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuICAgICAqIGFyZSAqKm5vdCoqIHN1cHBvcnRlZC4gUHJvdmlkZSBhIGN1c3RvbWl6ZXIgZnVuY3Rpb24gdG8gZXh0ZW5kIHN1cHBvcnRcbiAgICAgKiBmb3IgY29tcGFyaW5nIG90aGVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlcVxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBvYmplY3QgPT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChhcnJheSwgb3RoZXIsIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAqICAgaWYgKF8uZXZlcnkoW3ZhbHVlLCBvdGhlcl0sIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL15oKD86aXxlbGxvKSQvKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGVycm9yVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNmaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgxMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShPYmplY3QoMTApKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgICAgIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvIGRldGVybWluZSBpZlxuICAgICAqIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWRcbiAgICAgKiBpdCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBvdGhlciwgaW5kZXh8a2V5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgcHJvcGVydGllcyBvZiBhcnJheXMsIGJvb2xlYW5zLFxuICAgICAqIGBEYXRlYCBvYmplY3RzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gRnVuY3Rpb25zXG4gICAgICogYW5kIERPTSBub2RlcyBhcmUgKipub3QqKiBzdXBwb3J0ZWQuIFByb3ZpZGUgYSBjdXN0b21pemVyIGZ1bmN0aW9uIHRvIGV4dGVuZFxuICAgICAqIHN1cHBvcnQgZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gXy5ldmVyeShbdmFsdWUsIG90aGVyXSwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCAvXmgoPzppfGVsbG8pJC8pIHx8IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMykgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbm90IHRoZSBzYW1lIGFzIFtgaXNOYU5gXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNClcbiAgICAgKiB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3IgYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1lcmljIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lIGhvc3Qgb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZSBjbGFzc2lmaWVkXG4gICAgICogYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDguNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzguNCcpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFzc3VtZXMgb2JqZWN0cyBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvclxuICAgICAqIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciBDdG9yO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBub24gYE9iamVjdGAgb2JqZWN0cy5cbiAgICAgIGlmICghKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0VGFnICYmICFpc0FyZ3VtZW50cyh2YWx1ZSkpIHx8XG4gICAgICAgICAgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY29uc3RydWN0b3InKSAmJiAoQ3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yLCB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmICEoQ3RvciBpbnN0YW5jZW9mIEN0b3IpKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSUUgPCA5IGl0ZXJhdGVzIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGJlZm9yZSBvd24gcHJvcGVydGllcy4gSWYgdGhlIGZpcnN0XG4gICAgICAvLyBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QncyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkXG4gICAgICAvLyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAgICAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuICAgICAgLy8gb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICBiYXNlRm9ySW4odmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbHQodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbHRlKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTtcbiAgICAgKiB9KDEsIDIsIDMpKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWUgPyBnZXRMZW5ndGgodmFsdWUpIDogMDtcbiAgICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ29weSh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAgICAgKiBkb24ndCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzXG4gICAgICogb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGBjdXN0b21pemVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kXG4gICAgICogc291cmNlIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIG1lcmdpbmcgaXMgaGFuZGxlZFxuICAgICAqIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2RhdGEnOiBbeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ3VzZXInOiAnZnJlZCcgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGFnZXMgPSB7XG4gICAgICogICAnZGF0YSc6IFt7ICdhZ2UnOiAzNiB9LCB7ICdhZ2UnOiA0MCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKHVzZXJzLCBhZ2VzKTtcbiAgICAgKiAvLyA9PiB7ICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYXBwbGUnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYmFuYW5hJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnY2Fycm90J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KGEpKSB7XG4gICAgICogICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcnVpdHMnOiBbJ2FwcGxlJywgJ2JhbmFuYSddLCAndmVnZXRhYmxlcyc6IFsnYmVldCcsICdjYXJyb3QnXSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoYmFzZU1lcmdlKTtcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOlxuICAgICAqIChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmFzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogNDAgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQodmFsdWUpID8gb3RoZXIgOiB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBjdXN0b21pemVyXG4gICAgICAgID8gYXNzaWduV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcilcbiAgICAgICAgOiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XG4gICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID8gYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGNyZWF0ZURlZmF1bHRzKGFzc2lnbiwgYXNzaWduRGVmYXVsdHMpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICd1c2VyJzogeyAnbmFtZSc6ICdiYXJuZXknIH0gfSwgeyAndXNlcic6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiAzNiB9IH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9IH1cbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBjcmVhdGVEZWZhdWx0cyhtZXJnZSwgbWVyZ2VEZWZhdWx0cyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmRLZXkgPSBjcmVhdGVGaW5kS2V5KGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyBgcGViYmxlc2AgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyBgYmFybmV5YFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdEtleSA9IGNyZWF0ZUZpbmRLZXkoYmFzZUZvck93blJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBpbnZva2luZ1xuICAgICAqIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2EnLCAnYicsIGFuZCAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9ySW4gPSBjcmVhdGVGb3JJbihiYXNlRm9yKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdjJywgJ2InLCBhbmQgJ2EnIGFzc3VtaW5nIGBfLmZvckluIGAgbG9ncyAnYScsICdiJywgYW5kICdjJ1xuICAgICAqL1xuICAgIHZhciBmb3JJblJpZ2h0ID0gY3JlYXRlRm9ySW4oYmFzZUZvclJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW52b2tpbmcgYGl0ZXJhdGVlYFxuICAgICAqIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYScgYW5kICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciBmb3JPd24gPSBjcmVhdGVGb3JPd24oYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdiJyBhbmQgJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgYW5kICdiJ1xuICAgICAqL1xuICAgIHZhciBmb3JPd25SaWdodCA9IGNyZWF0ZUZvck93bihiYXNlRm9yT3duUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG1ldGhvZHNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWZ0ZXInLCAnYXJ5JywgJ2Fzc2lnbicsIC4uLl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyB1c2VkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgdG9QYXRoKHBhdGgpLCBwYXRoICsgJycpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogeyAnYyc6IDMgfSB9IH07XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHBhdGgpO1xuICAgICAgaWYgKCFyZXN1bHQgJiYgIWlzS2V5KHBhdGgpKSB7XG4gICAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICAgIG9iamVjdCA9IHBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gbGFzdChwYXRoKTtcbiAgICAgICAgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCAoaXNMZW5ndGgob2JqZWN0Lmxlbmd0aCkgJiYgaXNJbmRleChwYXRoLCBvYmplY3QubGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZSBwcm9wZXJ0eVxuICAgICAqIGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcyB1bmxlc3MgYG11bHRpVmFsdWVgIGlzIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpVmFsdWVdIEFsbG93IG11bHRpcGxlIHZhbHVlcyBwZXIga2V5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqXG4gICAgICogLy8gd2l0aCBgbXVsdGlWYWx1ZWBcbiAgICAgKiBfLmludmVydChvYmplY3QsIHRydWUpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0LCBtdWx0aVZhbHVlLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKG9iamVjdCwgbXVsdGlWYWx1ZSwgZ3VhcmQpKSB7XG4gICAgICAgIG11bHRpVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKCh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QpIHx8XG4gICAgICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuICAgICAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcblxuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gKGluZGV4ICsgJycpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShza2lwSW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgJiZcbiAgICAgICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIGBpdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgbWFwS2V5cyA9IGNyZWF0ZU9iamVjdE1hcHBlcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciBtYXBWYWx1ZXMgPSBjcmVhdGVPYmplY3RNYXBwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3ByZWRpY2F0ZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lcyB0byBvbWl0LCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eVxuICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb3BzWzBdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoYmFzZUZsYXR0ZW4ocHJvcHMpLCBTdHJpbmcpO1xuICAgICAgICByZXR1cm4gcGlja0J5QXJyYXkob2JqZWN0LCBiYXNlRGlmZmVyZW5jZShrZXlzSW4ob2JqZWN0KSwgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmVkaWNhdGUgPSBiaW5kQ2FsbGJhY2socHJvcHNbMF0sIHByb3BzWzFdLCAzKTtcbiAgICAgIHJldHVybiBwaWNrQnlDYWxsYmFjayhvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIHRoZSBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgLFxuICAgICAqIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhaXJzKHsgJ2Jhcm5leSc6IDM2LCAnZnJlZCc6IDQwIH0pO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhaXJzKG9iamVjdCkge1xuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy4gUHJvcGVydHlcbiAgICAgKiBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZiBwcm9wZXJ0eVxuICAgICAqIG5hbWVzLiBJZiBgcHJlZGljYXRlYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvciBlYWNoIHByb3BlcnR5IG9mIGBvYmplY3RgXG4gICAgICogcGlja2luZyB0aGUgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3ByZWRpY2F0ZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eVxuICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsICd1c2VyJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBfLmlzU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBwcm9wc1swXSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBiaW5kQ2FsbGJhY2socHJvcHNbMF0sIHByb3BzWzFdLCAzKSlcbiAgICAgICAgOiBwaWNrQnlBcnJheShvYmplY3QsIGJhc2VGbGF0dGVuKHByb3BzKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZCBpdHMgcmVzdWx0XG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYS5iLmMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3BhdGhdO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiAhaXNLZXkocGF0aCwgb2JqZWN0KSkge1xuICAgICAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgICAgICByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtsYXN0KHBhdGgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHJlc3VsdCkgPyByZXN1bHQuY2FsbChvYmplY3QpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBwYXRoYCBvbiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYFxuICAgICAqIGRvZXMgbm90IGV4aXN0IGl0IGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGF1Z21lbnQuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICd4WzBdLnkueicsIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG4gICAgICBwYXRoID0gKG9iamVjdFtwYXRoS2V5XSAhPSBudWxsIHx8IGlzS2V5KHBhdGgsIG9iamVjdCkpID8gW3BhdGhLZXldIDogdG9QYXRoKHBhdGgpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICAgICAgICBpZiAoaXNPYmplY3QobmVzdGVkKSkge1xuICAgICAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIG5lc3RlZFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXN0ZWRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXN0ZWRba2V5XSA9IGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge307XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93biBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydGllcyB0aHJvdWdoIGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uIHBvdGVudGlhbGx5IG11dGF0aW5nXG4gICAgICogdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9uc1xuICAgICAqIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihyZXN1bHQsIG4sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBuICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpO1xuXG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGJhc2VDcmVhdGUoaXNGdW5jdGlvbihDdG9yKSA/IEN0b3IucHJvdG90eXBlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWydoJywgJ2knXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0byBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCBpdCBpcyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBuYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSArZW5kIHx8IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIHZhbHVlIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCAoaW5jbHVzaXZlKS4gSWYgb25seSBvbmVcbiAgICAgKiBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlciBpcyByZXR1cm5lZC5cbiAgICAgKiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBtaW5gIG9yIGBtYXhgIGFyZSBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnRcbiAgICAgKiBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiBpc0l0ZXJhdGVlQ2FsbChtaW4sIG1heCwgZmxvYXRpbmcpKSB7XG4gICAgICAgIG1heCA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIG5vTWluID0gbWluID09IG51bGwsXG4gICAgICAgICAgbm9NYXggPSBtYXggPT0gbnVsbDtcblxuICAgICAgaWYgKGZsb2F0aW5nID09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vTWF4ICYmIHR5cGVvZiBtaW4gPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtaW47XG4gICAgICAgICAgbWluID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWF4ID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWF4O1xuICAgICAgICAgIG5vTWF4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vTWluICYmIG5vTWF4KSB7XG4gICAgICAgIG1heCA9IDE7XG4gICAgICAgIG5vTWF4ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBtaW4gPSArbWluIHx8IDA7XG4gICAgICBpZiAobm9NYXgpIHtcbiAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4ID0gK21heCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IG1pbiAlIDEgfHwgbWF4ICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKG1pbiArIChyYW5kICogKG1heCAtIG1pbiArIHBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIG1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICh3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENhcGl0YWxpemVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgKHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nIFtsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVyc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogdG8gYmFzaWMgbGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmcgW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4xLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gKHRhcmdldCArICcnKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBuYXRpdmVNaW4ocG9zaXRpb24gPCAwID8gMCA6ICgrcG9zaXRpb24gfHwgMCksIGxlbmd0aCk7XG5cbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuaW5kZXhPZih0YXJnZXQsIHBvc2l0aW9uKSA9PSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBcIidcIiwgYW5kIFwiXFxgXCIsIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsIGNoYXJhY3RlcnNcbiAgICAgKiB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBTZWUgW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQmFja3RpY2tzIGFyZSBlc2NhcGVkIGJlY2F1c2UgaW4gSW50ZXJuZXQgRXhwbG9yZXIgPCA5LCB0aGV5IGNhbiBicmVhayBvdXRcbiAgICAgKiBvZiBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuIFNlZSBbIzU5XShodHRwczovL2h0bWw1c2VjLm9yZy8jNTkpLFxuICAgICAqIFsjMTAyXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTAyKSwgWyMxMDhdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDgpLCBhbmRcbiAgICAgKiBbIzEzM10oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEzMykgb2YgdGhlIFtIVE1MNSBTZWN1cml0eSBDaGVhdHNoZWV0XShodHRwczovL2h0bWw1c2VjLm9yZy8pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXMgW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKVxuICAgICAqIHRvIHJlZHVjZSBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgLy8gUmVzZXQgYGxhc3RJbmRleGAgYmVjYXVzZSBpbiBJRSA8IDkgYFN0cmluZyNyZXBsYWNlYCBkb2VzIG5vdC5cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJcXFwiLCBcIi9cIiwgXCJeXCIsIFwiJFwiLCBcIi5cIiwgXCJ8XCIsIFwiP1wiLFxuICAgICAqIFwiKlwiLCBcIitcIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiIGFuZCBcIn1cIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczpcXC9cXC9sb2Rhc2hcXC5jb21cXC9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXJzLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXJzLCBlc2NhcGVSZWdFeHBDaGFyKVxuICAgICAgICA6IChzdHJpbmcgfHwgJyg/OiknKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuICAgICAqIC8vID0+ICdfLWFiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gK2xlbmd0aDtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoc3RyTGVuZ3RoID49IGxlbmd0aCB8fCAhbmF0aXZlSXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMixcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gbmF0aXZlRmxvb3IobWlkKSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IG5hdGl2ZUNlaWwobWlkKTtcblxuICAgICAgY2hhcnMgPSBjcmVhdGVQYWRkaW5nKCcnLCByaWdodExlbmd0aCwgY2hhcnMpO1xuICAgICAgcmV0dXJuIGNoYXJzLnNsaWNlKDAsIGxlZnRMZW5ndGgpICsgc3RyaW5nICsgY2hhcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICB2YXIgcGFkTGVmdCA9IGNyZWF0ZVBhZERpcigpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgdmFyIHBhZFJpZ2h0ID0gY3JlYXRlUGFkRGlyKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGEgaGV4YWRlY2ltYWwsXG4gICAgICogaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZSBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI0UpXG4gICAgICogb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgLy8gRmlyZWZveCA8IDIxIGFuZCBPcGVyYSA8IDE1IGZvbGxvdyBFUzMgZm9yIGBwYXJzZUludGAuXG4gICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gdHJpbSBsZWFkaW5nIDxCT00+IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzEwOSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIDogcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdHJpbShzdHJpbmcpO1xuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHN0cmluZywgcmFkaXggfHwgKHJlSGFzSGV4UHJlZml4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG4gICAgICogLy8gPT4gJyoqKidcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICAgICAqIC8vID0+ICcnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBuID0gK247XG4gICAgICBpZiAobiA8IDEgfHwgIXN0cmluZyB8fCAhbmF0aXZlSXNGaW5pdGUobikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgKHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogbmF0aXZlTWluKHBvc2l0aW9uIDwgMCA/IDAgOiAoK3Bvc2l0aW9uIHx8IDApLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIHN0cmluZy5sYXN0SW5kZXhPZih0YXJnZXQsIHBvc2l0aW9uKSA9PSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBwcm92aWRlZCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGVdIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzXSBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZV0gVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlXSBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtvdGhlck9wdGlvbnNdIEVuYWJsZXMgdGhlIGxlZ2FjeSBgb3B0aW9uc2AgcGFyYW0gc2lnbmF0dXJlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUxcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUyBkZWxpbWl0ZXIgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIGRlZmF1bHQgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlclxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHRcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IGZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3JcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgYSBzdGFjayB0cmFjZVxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGN3ZCwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIG90aGVyT3B0aW9ucykge1xuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvbiAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAob3RoZXJPcHRpb25zICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgb3RoZXJPcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gb3RoZXJPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduV2l0aChiYXNlQXNzaWduKHt9LCBvdGhlck9wdGlvbnMgfHwgb3B0aW9ucyksIHNldHRpbmdzLCBhc3NpZ25Pd25EZWZhdWx0cyk7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduV2l0aChiYXNlQXNzaWduKHt9LCBvcHRpb25zLmltcG9ydHMpLCBzZXR0aW5ncy5pbXBvcnRzLCBhc3NpZ25Pd25EZWZhdWx0cyksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoJ3NvdXJjZVVSTCcgaW4gb3B0aW9uc1xuICAgICAgICAgID8gb3B0aW9ucy5zb3VyY2VVUkxcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgcmVxdWlyZXMgcmV0dXJuaW5nIHRoZSBgbWF0Y2hgXG4gICAgICAgIC8vIHN0cmluZyBpbiBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKS5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UodHJpbW1lZExlZnRJbmRleChzdHJpbmcpLCB0cmltbWVkUmlnaHRJbmRleChzdHJpbmcpICsgMSk7XG4gICAgICB9XG4gICAgICBjaGFycyA9IChjaGFycyArICcnKTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCBjaGFycyksIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIGNoYXJzKSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUxlZnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1MZWZ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJpbmc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgY2hhcnMsIGd1YXJkKSA6IGNoYXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSh0cmltbWVkTGVmdEluZGV4KHN0cmluZykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShjaGFyc0xlZnRJbmRleChzdHJpbmcsIChjaGFycyArICcnKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1SaWdodCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbVJpZ2h0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1SaWdodChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCAoY2hhcnMgKyAnJykpICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdCBvciBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywgMjQpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG4uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuYyhzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gKCtvcHRpb25zLmxlbmd0aCB8fCAwKSA6IGxlbmd0aDtcbiAgICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9ICtvcHRpb25zIHx8IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gb21pc3Npb24ubGVuZ3RoO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgbmV3RW5kLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIChyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSB8fCAnJykgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09IG51bGwgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKHNlcGFyYXRvciwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBgJiMzOTtgLCBhbmQgYCYjOTY7YCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWwgSFRNTFxuICAgICAqIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpKSB7XG4gICAgICAgIHBhdHRlcm4gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybiB8fCByZVdvcmRzKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9yc1xuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUgdGhlXG4gICAgICogY3JlYXRlZCBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2BcbiAgICAgKiBpcyBhbiBvYmplY3QgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpblxuICAgICAqIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGl0ZXJhdGVlXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3cmFwIHRvIGNyZWF0ZSBjdXN0b20gY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8uY2FsbGJhY2sgPSBfLndyYXAoXy5jYWxsYmFjaywgZnVuY3Rpb24oY2FsbGJhY2ssIGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhmdW5jKTtcbiAgICAgKiAgIGlmICghbWF0Y2gpIHtcbiAgICAgKiAgICAgcmV0dXJuIGNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcpO1xuICAgICAqICAgfVxuICAgICAqICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0J1xuICAgICAqICAgICAgID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdXG4gICAgICogICAgICAgOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhZ2VfX2d0MzYnKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsbGJhY2soZnVuYywgdGhpc0FyZywgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChmdW5jLCB0aGlzQXJnLCBndWFyZCkpIHtcbiAgICAgICAgdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdExpa2UoZnVuYylcbiAgICAgICAgPyBtYXRjaGVzKGZ1bmMpXG4gICAgICAgIDogYmFzZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICAgICAqXG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlbiBvYmplY3RcbiAgICAgKiBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRm9yIGNvbXBhcmluZyBhIHNpbmdsZVxuICAgICAqIG93biBvciBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWUgc2VlIGBfLm1hdGNoZXNQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLm1hdGNoZXMoeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBwYXRoYCBvbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIF8ubWF0Y2hlc1Byb3BlcnR5KCd1c2VyJywgJ2ZyZWQnKSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9uIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogXy5jb25zdGFudCgyKSB9IH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IF8uY29uc3RhbnQoMSkgfSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoJ2EuYi5jJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoXy5zb3J0Qnkob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InLCAnYyddKSksICdhLmIuYycpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSByZXN0UGFyYW0oZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaW52b2tlUGF0aChvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb24gYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gaW52b2tlUGF0aChvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiB0aGVuIG1ldGhvZHMgYXJlIGFkZGVkIHRvXG4gICAgICogaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhZGRlZFxuICAgICAqICBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHNvdXJjZSksXG4gICAgICAgICAgICBwcm9wcyA9IGlzT2JqID8ga2V5cyhzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWV0aG9kTmFtZXMgPSAocHJvcHMgJiYgcHJvcHMubGVuZ3RoKSA/IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCEobWV0aG9kTmFtZXMgPyBtZXRob2ROYW1lcy5sZW5ndGggOiBpc09iaikpIHtcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGZhbHNlO1xuICAgICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9IHRydWUsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY2hhaW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNoYWluID0gb3B0aW9ucy5jaGFpbjtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gbWV0aG9kTmFtZXNbaW5kZXhdLFxuICAgICAgICAgICAgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcblxuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IChmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuICAgICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gYXJyYXlDb3B5KHRoaXMuX19hY3Rpb25zX18pO1xuXG4gICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KGZ1bmMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHVuZGVmaW5lZGAgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogXy5ub29wKG9iamVjdCkgPT09IHVuZGVmaW5lZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9uIGFcbiAgICAgKiBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogMiB9IH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IDEgfSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iLmMnKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InLCAnYyddKSksICdhLmIuYycpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eShwYXRoKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSBwcm9wZXJ0eSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHRvUGF0aChwYXRoKSwgcGF0aCArICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQgaXQgaXNcbiAgICAgKiBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLiBJZiBgZW5kYCBpcyBsZXNzIHRoYW4gYHN0YXJ0YFxuICAgICAqIGEgemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgbnVtYmVycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBpZiAoc3RlcCAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogKCtzdGVwIHx8IDApO1xuXG4gICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9ICtlbmQgfHwgMDtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBgQXJyYXkobGVuZ3RoKWAgc28gZW5naW5lcyBsaWtlIENoYWtyYSBhbmQgVjggYXZvaWQgc2xvd2VyIG1vZGVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8veW91dHUuYmUvWEFxSXBHVThaWmsjdD0xN20yNXMgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgZnVuY3Rpb24gYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGludm9jYXRpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2LCBmYWxzZSkpO1xuICAgICAqIC8vID0+IFszLCA2LCA0XVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7XG4gICAgICogICBtYWdlLmNhc3RTcGVsbChuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBpbnZva2VzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMgd2l0aCBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmBcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikge1xuICAgICAqICAgdGhpcy5jYXN0KG4pO1xuICAgICAqIH0sIG1hZ2UpO1xuICAgICAqIC8vID0+IGFsc28gaW52b2tlcyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIG4gPSBuYXRpdmVGbG9vcihuKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSB0byBhdm9pZCBhIEpTQyBKSVQgYnVnIGluIFNhZmFyaSA4XG4gICAgICAvLyB3aGVyZSBgQXJyYXkoMClgIGlzIHRyZWF0ZWQgYXMgYEFycmF5KDEpYC5cbiAgICAgIGlmIChuIDwgMSB8fCAhbmF0aXZlSXNGaW5pdGUobikpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpKTtcblxuICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDEpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGlmIChpbmRleCA8IE1BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIHByb3ZpZGVkIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gYmFzZVRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgdG8gYWRkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGQoYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiAoK2F1Z2VuZCB8fCAwKSArICgrYWRkZW5kIHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYG5gIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYG5gIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGVtcHR5IG9yIGZhbHNleVxuICAgICAqIGAtSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IC1JbmZpbml0eVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXgodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2U7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXgodXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICAgICAqL1xuICAgIHZhciBtYXggPSBjcmVhdGVFeHRyZW11bShndCwgTkVHQVRJVkVfSU5GSU5JVFkpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbih1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWluKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqL1xuICAgIHZhciBtaW4gPSBjcmVhdGVFeHRyZW11bShsdCwgUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBgbmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgNl0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiBfLnN1bSh7ICdhJzogNCwgJ2InOiA2IH0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ24nOiA0IH0sXG4gICAgICogICB7ICduJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc3VtKG9iamVjdHMsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIG9iamVjdC5uO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc3VtKG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGl0ZXJhdGVlLmxlbmd0aCA9PSAxXG4gICAgICAgID8gYXJyYXlTdW0oaXNBcnJheShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pLCBpdGVyYXRlZSlcbiAgICAgICAgOiBiYXNlU3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGBNYXBgIGNhY2hlLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcEdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBTZXQ7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgU2V0YCBjYWNoZS5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIC8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm1vZEFyZ3MgPSBtb2RBcmdzO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gucGFpcnMgPSBwYWlycztcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmVzdFBhcmFtID0gcmVzdFBhcmFtO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRCeUFsbCA9IHNvcnRCeUFsbDtcbiAgICBsb2Rhc2guc29ydEJ5T3JkZXIgPSBzb3J0QnlPcmRlcjtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndoZXJlID0gd2hlcmU7XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guYmFja2Zsb3cgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmNvbGxlY3QgPSBtYXA7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbjtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBjYWxsYmFjaztcbiAgICBsb2Rhc2gubWV0aG9kcyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2gub2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC5zZWxlY3QgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLnRhaWwgPSByZXN0O1xuICAgIGxvZGFzaC51bmlxdWUgPSB1bmlxO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmluZFdoZXJlID0gZmluZFdoZXJlO1xuICAgIGxvZGFzaC5maXJzdCA9IGZpcnN0O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkTGVmdCA9IHBhZExlZnQ7XG4gICAgbG9kYXNoLnBhZFJpZ2h0ID0gcGFkUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuICAgIGxvZGFzaC50cmltUmlnaHQgPSB0cmltUmlnaHQ7XG4gICAgbG9kYXNoLnRydW5jID0gdHJ1bmM7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmVxID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guZGV0ZWN0ID0gZmluZDtcbiAgICBsb2Rhc2guZm9sZGwgPSByZWR1Y2U7XG4gICAgbG9kYXNoLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLmhlYWQgPSBmaXJzdDtcbiAgICBsb2Rhc2guaW5jbHVkZSA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCBmYWxzZSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIGNhcGFibGUgb2YgcmV0dXJuaW5nIHdyYXBwZWQgYW5kIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAoIXRoaXMuX19jaGFpbl9fICYmIG4gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2FtcGxlKHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGUodmFsdWUsIG4pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgICBpZiAoZmlsdGVyZWQgJiYgIWluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBuID0gbiA9PSBudWxsID8gMSA6IG5hdGl2ZU1heChuYXRpdmVGbG9vcihuKSB8fCAwLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoZmlsdGVyZWQpIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihyZXN1bHQuX190YWtlQ291bnRfXywgbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHsgJ3NpemUnOiBuLCAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSAhPSBMQVpZX01BUF9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHsgJ2l0ZXJhdGVlJzogZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDEpLCAndHlwZSc6IHR5cGUgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmZpcnN0YCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnZmlyc3QnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy5yZXN0YC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3Jlc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5wbHVja2AgYW5kIGBfLndoZXJlYC5cbiAgICBhcnJheUVhY2goWydwbHVjaycsICd3aGVyZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIG9wZXJhdGlvbk5hbWUgPSBpbmRleCA/ICdmaWx0ZXInIDogJ21hcCcsXG4gICAgICAgICAgY3JlYXRlQ2FsbGJhY2sgPSBpbmRleCA/IGJhc2VNYXRjaGVzIDogcHJvcGVydHk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzW29wZXJhdGlvbk5hbWVdKGNyZWF0ZUNhbGxiYWNrKHZhbHVlKSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMSk7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSAoK2VuZCB8fCAwKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlLCB0aGlzQXJnKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKFBPU0lUSVZFX0lORklOSVRZKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86Zmlyc3R8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbcmV0VW53cmFwcGVkID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV07XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gcmV0VW53cmFwcGVkID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gKHJldFVud3JhcHBlZCAmJiBjaGFpbkFsbClcbiAgICAgICAgICAgID8gbG9kYXNoRnVuYyh2YWx1ZSwgMSlbMF1cbiAgICAgICAgICAgIDogbG9kYXNoRnVuYy5hcHBseSh1bmRlZmluZWQsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFjdGlvbiA9IHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0sXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwpIHtcbiAgICAgICAgICBpZiAob25seUxhenkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbG9kYXNoRnVuYy5jYWxsKHVuZGVmaW5lZCwgdGhpcy52YWx1ZSgpKVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaChhY3Rpb24pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsnam9pbicsICdwb3AnLCAncHVzaCcsICdyZXBsYWNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3NwbGl0JywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSAoL14oPzpyZXBsYWNlfHNwbGl0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyBzdHJpbmdQcm90byA6IGFycmF5UHJvdG8pW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86am9pbnxwb3B8cmVwbGFjZXxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMudmFsdWUoKSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IGxvZGFzaEZ1bmMubmFtZSxcbiAgICAgICAgICAgIG5hbWVzID0gcmVhbE5hbWVzW2tleV0gfHwgKHJlYWxOYW1lc1trZXldID0gW10pO1xuXG4gICAgICAgIG5hbWVzLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWRXcmFwcGVyKHVuZGVmaW5lZCwgQklORF9LRVlfRkxBRykubmFtZV0gPSBbeyAnbmFtZSc6ICd3cmFwcGVyJywgJ2Z1bmMnOiB1bmRlZmluZWQgfV07XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBsYXp5IHdyYXBwZXIuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluaW5nIGZ1bmN0aW9ucyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbmNhdCA9IHdyYXBwZXJDb25jYXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuICAgIGxvZGFzaC5wcm90b3R5cGUucnVuID0gbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9uIGFsaWFzZXMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb2xsZWN0ID0gbG9kYXNoLnByb3RvdHlwZS5tYXA7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5oZWFkID0gbG9kYXNoLnByb3RvdHlwZS5maXJzdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnNlbGVjdCA9IGxvZGFzaC5wcm90b3R5cGUuZmlsdGVyO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudGFpbCA9IGxvZGFzaC5wcm90b3R5cGUucmVzdDtcblxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMgbGlrZSByLmpzIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgbG9kYXNoIHRvIHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gYW4gQU1EIGxvYWRlciBpcyBwcmVzZW50IHRvIGF2b2lkXG4gICAgLy8gZXJyb3JzIGluIGNhc2VzIHdoZXJlIGxvZGFzaCBpcyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGFuZCBub3QgaW50ZW5kZWRcbiAgICAvLyBhcyBhbiBBTUQgbW9kdWxlLiBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3JcbiAgICAvLyBtb3JlIGRldGFpbHMuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3QuXG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMgb3IgUmluZ29KUy5cbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIH1cbiAgICAvLyBFeHBvcnQgZm9yIFJoaW5vIHdpdGggQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIGEgYnJvd3NlciBvciBSaGluby5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLypcblx0Y29zdHM6IHtcblx0XHRkZWxldGU6IG51bWJlciB8IGZ1bmN0aW9uICggY2hhciApXG5cdFx0aW5zZXJ0OiBudW1iZXIgfCBmdW5jdGlvbiAoIGNoYXIgKVxuXHRcdHJlcGxhY2U6IG51bWJlciB8IGZ1bmN0aW9uICggd2hhdCwgYnkgKVxuXHRcdHRyYW5zcG9zZTogbnVtYmVyIHwgZnVuY3Rpb24gKCBsZWZ0LCByaWdodCApXG5cdH1cbiovXG5cbmZ1bmN0aW9uIGdldENvc3QoIGNvc3RzLCBvcCwgYSwgYiApIHtcblx0bGV0IGNvc3QgPSB0eXBlb2YgY29zdHMgPT0gYG9iamVjdGAgPyBjb3N0c1sgb3AgXSA6IGNvc3RzXG5cdHJldHVybiB0eXBlb2YgY29zdCA9PSBgZnVuY3Rpb25gID8gY29zdC5jYWxsKCBjb3N0cywgYSwgYiApIDogY29zdFxufVxuXG5leHBvcnQgZGVmYXVsdCAoIHMxLCBzMiwgY29zdHMgPSAxICkgPT4ge1xuXHRsZXQgZCA9IFtdXG5cdGZvciAoIGxldCBpID0gMDsgaSA8PSBzMS5sZW5ndGg7ICsraSApIHtcblx0XHRkWyBpIF0gPSBpIDwgMyA/IFtdIDogZFsgaSAtIDMgXSAvLyBzb21lIG9wdGltaXphdGlvblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSBzMi5sZW5ndGg7ICsraiApXG5cdFx0XHRkWyBpIF1bIGogXSA9XG5cdFx0XHRcdGkgPT0gMCAmJiBqID09IDAgP1xuXHRcdFx0XHRcdDBcblx0XHRcdFx0OiBpID09IDAgP1xuXHRcdFx0XHRcdGRbIGkgXVsgaiAtIDEgXSArIGdldENvc3QoIGNvc3RzLCBgaW5zZXJ0YCwgczJbIGogLSAxIF0gKVxuXHRcdFx0XHQ6IGogPT0gMCA/XG5cdFx0XHRcdFx0ZFsgaSAtIDEgXVsgaiBdICsgZ2V0Q29zdCggY29zdHMsIGBkZWxldGVgLCBzMVsgaSAtIDEgXSApXG5cdFx0XHRcdDogTWF0aC5taW4oXG5cdFx0XHRcdFx0ZFsgaSAtIDEgXVsgaiBdICsgZ2V0Q29zdCggY29zdHMsIGBkZWxldGVgLCBzMVsgaSAtIDEgXSApLFxuXHRcdFx0XHRcdGRbIGkgXVsgaiAtIDEgXSArIGdldENvc3QoIGNvc3RzLCBgaW5zZXJ0YCwgczJbIGogLSAxIF0gKSxcblx0XHRcdFx0XHRkWyBpIC0gMSBdWyBqIC0gMSBdICsgKCBzMVsgaSAtIDEgXSA9PSBzMlsgaiAtIDEgXSA/IDAgOiBnZXRDb3N0KCBjb3N0cywgYHJlcGxhY2VgLCBzMVsgaSAtIDEgXSwgczJbIGogLSAxIF0gKSApLFxuXHRcdFx0XHRcdCggaSA+IDEgJiYgaiA+IDEgJiYgczFbIGkgLSAxIF0gPT0gczJbIGogLSAyIF0gJiYgczFbIGkgLSAyIF0gPT0gczJbIGogLSAxIF0gKVxuXHRcdFx0XHRcdFx0PyBkWyBpIC0gMiBdWyBqIC0gMiBdICsgZ2V0Q29zdCggY29zdHMsIGB0cmFuc3Bvc2VgLCBzMVsgaSAtIDIgXSwgczFbIGkgLSAxIF0gKSA6IEluZmluaXR5XG5cdFx0XHRcdClcblx0fVxuXHRyZXR1cm4gZFsgczEubGVuZ3RoIF1bIHMyLmxlbmd0aCBdXG59XG4iLCJpbXBvcnQgKiBhcyBKU09OU3RyZWFtIGZyb20gXCJKU09OU3RyZWFtXCJcbmltcG9ydCAqIGFzIHNmIGZyb20gXCJzZlwiXG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IHNmLmR1cGxleGVyKCB7XG5cdHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSxcblx0d3JpdGFibGVPYmplY3RNb2RlOiB0cnVlLFxuXHRvdGhlclJlYWRhYmxlT2JqZWN0TW9kZTogZmFsc2UsXG5cdG90aGVyV3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZSxcbn0sIEpTT05TdHJlYW0uc3RyaW5naWZ5KCBmYWxzZSApLCBKU09OU3RyZWFtLnBhcnNlKCkgKVxuXG4vL1RPRE86IHBhc3RlIGEgYnVncmVwb3J0IHRoYXQgSlNPTlN0cmVhbS5wYXJzZSgpIHJldHVybnMgbm90IGFuIGluc3RhbmNlIG9mIHJlYWRhYmxlIC0tIGkgbWVhbiwgaXQgaGFzIG5vIHJlYWQoKSBtZXRob2QuXG4iLCJpbXBvcnQgcmEgZnJvbSBcInJhXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCBrZXksIGRlZmF1bHRzID0gbnVsbCApIHtcblx0bGV0IHJldCA9IHJhKCBkZWZhdWx0cyApXG5cdC5zZXRDb25zdCggXCJyZXNldFwiLCAoKSA9PiB7XG5cdFx0XHRsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgga2V5IClcblx0XHRcdHJldC5hc3NpZ24oIGRlZmF1bHRzIClcblx0XHRcdC8vIHJldC5sb2FkZWQgPSB0cnVlXG5cdFx0fVxuXHQpXG5cdC5zZXROYW1lKCBcImxvY2FsU3RvcmFnZS5cIiArIGtleSApXG5cdGxldCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgga2V5IClcblx0aWYgKCBzdG9yZWQgIT0gbnVsbCApXG5cdFx0cmV0LmFzc2lnbiggSlNPTi5wYXJzZSggc3RvcmVkICkgKVxuXHRyYSggKCkgPT4ge1xuXHRcdGlmICggcmV0LnZhbHVlT2YoKSAhPSBkZWZhdWx0cyApXG5cdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgga2V5LCBKU09OLnN0cmluZ2lmeSggcmV0ICkgKVxuXHR9IClcblx0cmV0dXJuIHJldFxufVxuIiwiLypcblxuVE9ETyAyMDE1LjAzLjI1INCjINCi0Jcg0L3QtSDQsdGL0LvQvjog0KDRjdC00LDQs9Cw0LLQsNC90YzQvdC1INC80LXRgdGG0LDRniDQvNCw0LPRh9GL0LzQsCDQv9Cw0YLRgNGN0LHQvdCw0LUg0YLQvtC70YzQutGWINC70LDQutCw0LvRjNC90LAg0Lcg0LDRgdC+0LHQvdGL0LzRliDQutCw0LzQsNC90LTQsNC80ZYg0LzQtdC90Y4gXCLQt9Cw0YXQsNCy0LDRhtGMINC00LvRjyDQt9C80L7RntGH0LDQvdCw0LPQsFwiINGWIFwi0LfQsNCz0YDRg9C30ZbRhtGMINC90LAg0Z7RgdC1INC/0YDRi9C70LDQtNGLXCIuXG5cbiovXG5pbXBvcnQgSlNPTmxvY2FsIGZyb20gXCJKU09ObG9jYWxcIlxuaW1wb3J0ICogYXMgbHUgZnJvbSBcImxvY2FsVXRpbHNcIlxuaW1wb3J0IHJhIGZyb20gXCJyYVwiXG5pbXBvcnQgKiBhcyBjbyBmcm9tIFwiY29cIlxuaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gXCJsb2Rhc2hcIlxuaW1wb3J0ICogYXMgRGlmZiBmcm9tIFwiZGlmZlwiXG5pbXBvcnQgVUlEIGZyb20gXCJ1aWRcIlxuaW1wb3J0ICogYXMgaHR0cENsaWVudCBmcm9tIFwiaHR0cENsaWVudFwiXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIlxuLy8gaW1wb3J0IGRldmljZUFjdGlvbnMgZnJvbSBcIm5ldHJvL2RldmljZUFjdGlvbnNcIlxuaW1wb3J0IHdlYnNvY2tldFN0cmVhbSBmcm9tIFwid2Vic29ja2V0U3RyZWFtXCJcbmltcG9ydCBwaW5ncG9uZ1N0cmVhbSBmcm9tIFwicGluZ3BvbmdTdHJlYW1cIlxuaW1wb3J0IEpTT05TdHJlYW0gZnJvbSBcIkpTT05EdXBsZXhcIlxuaW1wb3J0ICogYXMgc2YgZnJvbSBcInNmXCJcbmltcG9ydCAqIGFzIGRldmRiIGZyb20gXCJkZXZkYlwiXG5pbXBvcnQgKiBhcyBjb21tYW5kcyBmcm9tIFwiY29tbWFuZHNcIlxuaW1wb3J0IGRiY2FjaGUgZnJvbSBcImRiY2FjaGVcIlxuaW1wb3J0IHdpbmRvd1NpemUgZnJvbSBcIndpbmRvd1NpemVcIlxuXG5sZXQgV2ViU29ja2V0UmV0cnkgPSAxMDAwXG5sZXQgc2F2ZVBsYWNlc1RpbWVvdXQgPSAzMDAwXG5cbmZ1bmN0aW9uIHdlYnNvY2tldCggdXJsICkge1xuXHRyZXR1cm4gcGluZ3BvbmdTdHJlYW0oKS5zZXRPdGhlciggSlNPTlN0cmVhbSgpICkuc2V0T3RoZXIoIHdlYnNvY2tldFN0cmVhbSggdXJsICkgKVxufVxuXG5jbGFzcyBQZXJzaXN0ZW50V2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuXHRjb25zdHJ1Y3RvciAoIHVybCApIHtcblx0XHRzdXBlcigpXG5cdFx0dGhpcy5fd3MgPSBudWxsXG5cdFx0dGhpcy5fc2hlZHVsZWRDcmVhdGluZyA9IG51bGxcblx0XHR0aGlzLl9uZXh0Q3JlYXRlID0gLUluZmluaXR5XG5cdFx0dGhpcy5fb25lbmQgPSAoKSA9PiB0aGlzLl9jcmVhdGVIYW5kbGUoIHRydWUgKVxuXHRcdHRoaXMuX29uZXJyb3IgPSBlcnJvciA9PiB0aGlzLmVtaXQoIGBlcnJvcmAsIGVycm9yIClcblx0XHR0aGlzLl9vbmRhdGEgPSBtZXNzYWdlID0+IHRoaXMuZW1pdCggYG1lc3NhZ2VgLCBtZXNzYWdlIClcblx0XHR0aGlzLl91cmwgPSBudWxsXG5cdFx0dGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuXHRcdHRoaXMuY2xvc2VkID0gZmFsc2Vcblx0XHQvLyB0aGlzLnVzZXIgPSB1bmRlZmluZWRcblx0XHQvLyB0aGlzLmtleSA9IHVuZGVmaW5lZFxuXHRcdHRoaXMudXJsID0gdXJsXG5cdFx0Ly8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIGBfYXBwbGljYXRpb25fcmVzdW1lZGAgKVxuXHR9XG5cblx0Z2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuX3VybCB9XG5cdHNldCB1cmwoIHVybCApIHtcblx0XHRpZiAoIHRoaXMuX3VybCAhPSB1cmwgKSB7XG5cdFx0XHR0aGlzLl91cmwgPSB1cmxcblx0XHRcdHRoaXMuX2NyZWF0ZUhhbmRsZSgpXG5cdFx0fVxuXHR9XG5cblx0X2NsZWFySGFuZGxlKCkge1xuXHRcdGlmICggdGhpcy5fd3MgKSB7XG5cdFx0XHR0aGlzLl93cy5yZW1vdmVMaXN0ZW5lciggYGVuZGAsIHRoaXMuX29uZW5kIClcblx0XHRcdHRoaXMuX3dzLnJlbW92ZUxpc3RlbmVyKCBgZXJyb3JgLCB0aGlzLl9vbmVycm9yIClcblx0XHRcdHRoaXMuX3dzLnJlbW92ZUxpc3RlbmVyKCBgZGF0YWAsIHRoaXMuX29uZGF0YSApXG5cdFx0XHR0aGlzLl93cy5lbmQoKVxuXHRcdFx0dGhpcy5fd3MgPSBudWxsXG5cdFx0XHR0aGlzLmVtaXQoIGBwYXVzZWAgKVxuXHRcdH1cblx0XHRpZiAoIHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgKVxuXHRcdFx0dGhpcy5fc2hlZHVsZWRDcmVhdGluZyA9IG51bGxcblx0XHR9XG5cdH1cblxuXHRfb3BlbldlYlNvY2tldCgpIHtcblx0XHR0aGlzLl93cy5zZXRPdGhlciggd2Vic29ja2V0KCB0aGlzLl91cmwgKSApXG5cdFx0dGhpcy5lbWl0KCBgcmVzdW1lYCApXG5cdH1cblxuXHRfY3JlYXRlSGFuZGxlKCByZXRyeWluZyApIHtcblx0XHR0aGlzLl9jbGVhckhhbmRsZSgpXG5cdFx0aWYgKCB0aGlzLmNsb3NlZCB8fCAhdGhpcy5fdXJsIClcblx0XHRcdHJldHVyblxuXHRcdHRoaXMuX3dzID0gc2YuZHVwbGV4ZXIoIHNmLnRocm91Z2goKSwgc2YudGhyb3VnaCgpIClcblx0XHR0aGlzLl93cy5vbiggYGVuZGAsIHRoaXMuX29uZW5kIClcblx0XHR0aGlzLl93cy5vbiggYGVycm9yYCwgdGhpcy5fb25lcnJvciApXG5cdFx0dGhpcy5fd3Mub24oIGBkYXRhYCwgdGhpcy5fb25kYXRhIClcblx0XHRsZXQgdCA9IHRoaXMuX25leHRDcmVhdGVcblx0XHRsZXQgbiA9IERhdGUubm93KClcblx0XHR0aGlzLl9uZXh0Q3JlYXRlID0gbiArIFdlYlNvY2tldFJldHJ5XG5cdFx0aWYgKCAhcmV0cnlpbmcgfHwgbiA+PSB0IClcblx0XHRcdHRoaXMuX29wZW5XZWJTb2NrZXQoKVxuXHRcdGVsc2Vcblx0XHRcdHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgPSBzZXRUaW1lb3V0KCAoKSA9PiB0aGlzLl9vcGVuV2ViU29ja2V0KCksIHQgLSBuIClcblx0fVxuXG5cdHJlaW5pdCgpIHtcblx0XHR0aGlzLl93cyAmJiB0aGlzLl93cy5lbmQoKVxuXHR9XG5cblx0c2VuZCggZGF0YSApIHtcblx0XHRpZiAoICF0aGlzLl93cyApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBzb2NrZXQgaXMgbm90IG9wZW5gIClcblx0XHR0aGlzLl93cy53cml0ZSggZGF0YSApXG5cdH1cblxuXHRkZWxldGUoKSB7XG5cdFx0dGhpcy5jbG9zZSgpXG5cdH1cblxuXHRjbG9zZSgpIHtcblx0XHR0aGlzLmNsb3NlZCA9IHRydWVcblx0XHR0aGlzLl9jbGVhckhhbmRsZSgpXG5cdFx0dGhpcy5lbWl0KCBgY2xvc2VgIClcblx0fVxuXG5cdGFzayggcXVlc3Rpb24gKSB7IHJldHVybiBjby5nbyggdGhpczo6ZnVuY3Rpb24qICgpIHtcblx0XHRsZXQgaWQgPSBVSUQoKVxuXHRcdGxldCBwYWNrZXQgPSB0aGlzLmdldCggaWQgKVxuXHRcdHRoaXMuc2VuZCggeyBpZCwgcXVlc3Rpb24gfSApXG5cdFx0bGV0IG1lc3NhZ2UgPSB5aWVsZCBwYWNrZXRcblx0XHRpZiAoIG1lc3NhZ2UuZXJyb3IgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlLmVycm9yIClcblx0XHRyZXR1cm4gbWVzc2FnZS5hbnN3ZXJcblx0fSApIH1cblxuXHRnZXQoIHByZWRpY2F0ZSwgdGltZW91dCApIHsgcmV0dXJuIGNvLmdvKCB0aGlzOjpmdW5jdGlvbiogKCkge1xuXHRcdGlmICggdHlwZW9mIHByZWRpY2F0ZSA9PSBgc3RyaW5nYCB8fCB0eXBlb2YgcHJlZGljYXRlID09IGBudW1iZXJgICkge1xuXHRcdFx0bGV0IGlkID0gcHJlZGljYXRlXG5cdFx0XHRwcmVkaWNhdGUgPSBtc2cgPT4gbXNnLmlkID09IGlkXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhKCB0eXBlb2YgcHJlZGljYXRlID09IGBmdW5jdGlvbmAgKSApIHtcblx0XHRcdGxldCBwID0gcHJlZGljYXRlXG5cdFx0XHRwcmVkaWNhdGUgPSBtc2cgPT4gbG9kYXNoLmV2ZXJ5KCBwLCAoIHZhbHVlLCBrZXkgKSA9PiBtc2dbIGtleSBdID09IHZhbHVlIClcblx0XHR9XG5cdFx0bGV0IHsgZXZlbnQsIGRhdGEgfSA9IHlpZWxkIGNvLnJlY2VpdmUoIHRoaXMsIHsgY2xvc2U6IHRydWUsIHBhdXNlOiB0cnVlLCBtZXNzYWdlOiBwcmVkaWNhdGUsIHRpbWVvdXQ6IHRpbWVvdXQgfSApXG5cdFx0aWYgKCBldmVudCA9PSBgbWVzc2FnZWAgKVxuXHRcdFx0cmV0dXJuIGRhdGFcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGB0aW1lb3V0ICR7IHRoaXMuX3VybCB8fCBgd3M6Ly9gIH1gIClcblx0fSApIH1cbn1cblxuZnVuY3Rpb24gd3NDbGllbnQoIGFwcCwgdXJsICkge1xuXHRsZXQgd3MgPSBuZXcgUGVyc2lzdGVudFdlYlNvY2tldCgpXG5cdHJhKCAoKSA9PiB3cy51cmwgPSBhcHAubG9jYWxNb2RlbSAmJiAoIGFwcC5sb2NhbE1vZGVtICsgdXJsICkgKVxuXHR3cy5hY3RpdmUgPSByYS5vbiggd3MsIFsgYHBhdXNlYCwgYHJlc3VtZWAgXSwgKCkgPT4gd3MuY29ubmVjdGVkIClcblx0cmV0dXJuIHdzXG59XG5cbmZ1bmN0aW9uIHdzSlNPTmNsaWVudCggYXBwLCB1cmwgKSB7XG5cblx0bGV0IGpzb24gPSBKU09ObG9jYWwoIHVybCwgeyB1aWQ6IG51bGwgfSApXG5cdGxldCB3cyA9IHdzQ2xpZW50KCBhcHAsIHVybCApXG5cdGxldCBpbml0ID0gKCkgPT4gd3Muc2VuZCggeyBjaGFubmVsOiBgZGF0YWJhc2VgLCB3aGF0OiBgaW5pdGAsIGlkOiBqc29uLnVpZCB9IClcblx0bGV0IHJlc29sdmVycyA9IHt9XG5cblx0bGV0IGRvRXJyb3IgPSAoIG1lc3NhZ2UsIGRhdGEgKSA9PiB7IHRocm93IG5ldyBFcnJvciggYHdzSlNPTmNsaWVudDogJHsgbWVzc2FnZSB9OiAkeyBKU09OLnN0cmluZ2lmeSggZGF0YSApIH1gICkgfVxuXG5cdGx1Lm9uKCB3cywge1xuXHRcdHJlc3VtZTogaW5pdCxcblx0XHRtZXNzYWdlKCBtZXNzYWdlICkgeyBzd2l0Y2ggKCBtZXNzYWdlLndoYXQgKSB7XG5cdFx0XHRjYXNlIGBlcnJvcmA6XG5cdFx0XHRcdGRvRXJyb3IoIGBlcnJvciBmcm9tIHNlcnZlcmAsIG1lc3NhZ2UgKVxuXHRcdFx0Y2FzZSBgc2F2ZWRgOiB7XG5cdFx0XHRcdGxldCByZXNvbHZlID0gcmVzb2x2ZXJzWyBtZXNzYWdlLm1lc3NhZ2VJZCBdXG5cdFx0XHRcdGRlbGV0ZSByZXNvbHZlcnNbIG1lc3NhZ2UubWVzc2FnZUlkIF1cblx0XHRcdFx0cmVzb2x2ZSAmJiByZXNvbHZlKClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRjYXNlIGBkYXRhYDoge1xuXHRcdFx0XHRpZiAoIG1lc3NhZ2UucGFydGlhbCAmJiBtZXNzYWdlLnByZXZpb3VzICE9IGpzb24udWlkIClcblx0XHRcdFx0XHRpbml0KClcblx0XHRcdFx0ZWxzZSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggbWVzc2FnZSwgYGRhdGFgICkgKVxuXHRcdFx0XHRcdGpzb24uYXNzaWduKCBEaWZmLmFwcGx5KCBqc29uLnZhbHVlT2YoKSwgbWVzc2FnZS5kYXRhLCBtZXNzYWdlLnBhcnRpYWwgKSApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0ZG9FcnJvciggYHVua25vd24gbWVzc2FnZSBmcm9tIHNlcnZlcmAsIG1lc3NhZ2UgKVxuXHRcdH0gfSxcblx0XHRlcnJvcigpIHtcblx0XHRcdGFwcC5vbkNyZWRlbnRpYWxzKClcblx0XHR9LFxuXHR9IClcblxuXHRmdW5jdGlvbiBkb1JlamVjdCggbWVzc2FnZUlkLCByZWplY3QgKSB7XG5cdFx0ZGVsZXRlIHJlc29sdmVyc1sgbWVzc2FnZUlkIF1cblx0XHRyZWplY3QoKVxuXHR9XG5cblx0bGV0IHNhdmUgPSAoIHBhcnRpYWwsIGRhdGEgKSA9PiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cdFx0bGV0IG1lc3NhZ2VJZCA9IFVJRCgpXG5cdFx0cmVzb2x2ZXJzWyBtZXNzYWdlSWQgXSA9IHJlc29sdmVcblx0XHR3cy5zZW5kKCB7IGNoYW5uZWw6IGBkYXRhYmFzZWAsIHdoYXQ6IGBzYXZlYCwgZGF0YTogcGFydGlhbCA/IGRhdGEgOiBPYmplY3QuYXNzaWduKCB7IF9fcGFydGlhbF9fOiBmYWxzZSB9LCBkYXRhIHx8IHt9ICksIG1lc3NhZ2VJZCB9IClcblx0XHRzZXRUaW1lb3V0KCBkb1JlamVjdCwgc2F2ZVBsYWNlc1RpbWVvdXQsIG1lc3NhZ2VJZCwgcmVqZWN0IClcblx0fSApXG5cblx0cmV0dXJuIHtcblx0XHRkYXRhOiBqc29uLmdldFJlYWRPbmx5KCksXG5cdFx0YWN0aXZlOiB3cy5hY3RpdmUsXG5cdFx0c2VuZCggZGF0YSApIHsgcmV0dXJuIHNhdmUoIGZhbHNlLCBkYXRhICkgfSxcblx0XHR1cGRhdGUoIGRhdGEgKSB7IHJldHVybiBzYXZlKCB0cnVlLCBkYXRhICkgfSxcblx0XHRkZWxldGUoKSB7IHdzLmNsb3NlKCkgfSxcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBhcHBpZCA9PiB7XG5cbmxldCBsb2NhbERlZmF1bHRzID0ge1xuXHRhY3RpdmVEZXZpY2VJZDogYGAsXG5cdGxhbmd1YWdlOiBgcnVgLFxuXHRpY29uU2l6ZTogNDAsIC8vIG1pbGxpbWV0ZXJzXG5cdGxhYmVsczogdHJ1ZSxcblx0cGxhY2VzUGFnZXM6IHt9LFxuXHR0aGVtZU5hbWU6IGBgLFxufVxuXG5sZXQgbG9jYWwgPSBKU09ObG9jYWwoIGFwcGlkLCBsb2NhbERlZmF1bHRzIClcblxubGV0IGFwcCA9IHJhKCB7XG5cblx0X3Byb2Nlc3M6IHJhLlZhbHVlKCBwcm9jZXNzICksXG5cblx0Z2V0TWVzc2FnZSggZGF0YSApIHtcblx0XHRsZXQgbGFuZ3VhZ2UgPSBsb2NhbC5sYW5ndWFnZSB8fCBgcnVgXG5cdFx0cmV0dXJuIFsgbGFuZ3VhZ2UsIGBydWAsIGBlbmAsIGBieWAgXVxuXHRcdFx0LmZpbHRlciggbCA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRhdGEsIGwgKSApXG5cdFx0XHQubWFwKCBsID0+IGRhdGFbIGwgXSApXG5cdFx0XHRbIDAgXVxuXHR9LFxuXG5cdHRoZW1lczogU3lzdGVtLmltcG9ydCggYHRoZW1lc2AgKSxcblx0dGhlbWVOYW1lOiBudWxsLFxuXHRnZXQgZmlsbFRoZW1lTmFtZSgpIHtcblx0XHR0aGlzLnRoZW1lTmFtZSA9IGxvY2FsLmxpdmUudGhlbWVOYW1lLm5vVG91Y2goKSB8fCB0aGlzLnRoZW1lTmFtZSB8fCB0aGlzLnRoZW1lcyAmJiBPYmplY3Qua2V5cyggdGhpcy50aGVtZXMgKS5wb3AoKVxuXHR9LFxuXHRnZXQgc2F2ZVRoZW1lTmFtZSgpIHtcblx0XHRsb2NhbC50aGVtZU5hbWUgPSB0aGlzLnRoZW1lTmFtZVxuXHR9LFxuXHRnZXQgdGhlbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGhlbWVzICYmIHRoaXMudGhlbWVzWyB0aGlzLnRoZW1lTmFtZSBdIHx8IGZhbHNlXG5cdH0sXG5cblx0bWFyZ2luOiAwLjUvKm1tKi8gKiA5Ni8yNS40LFxuXHRwYWdlV2lkdGg6IDIsXG5cdHBhZ2VIZWlnaHQ6IDMsXG5cdHBhZ2VTdGFydGluZzogZmFsc2UsXG5cdGRpYWxvZzogYGAsXG5cdGVkaXRpbmc6IGZhbHNlLFxuXHRtb3Zpbmc6IDAsXG5cdGhpc3Rvcnk6IFtdLFxuXHRtZW51V2lkdGg6IDEwMCxcblx0bWVudUhlaWdodDogMTAwLFxuXG5cdGxvZ2dlZGluOiBmYWxzZSxcblx0Ly8gY3JlZGVudGlhbHM6IDEsXG5cdG9uQ3JlZGVudGlhbHMoKSB7XG5cdFx0dGhpcy5sb2dnZWRpbiA9IGZhbHNlXG5cdH0sXG5cblx0Z28oIHRvLCBwYXRoICkge1xuXHRcdGlmICggIXRvIClcblx0XHRcdHJldHVyblxuXHRcdGxldCBoID0gdGhpcy5oaXN0b3J5XG5cdFx0bGV0IGEgPSBsb2NhbC5hY3RpdmVEZXZpY2VJZFxuXHRcdGxldCBsXG5cdFx0d2hpbGUgKCBoLmxlbmd0aCAmJiAoIGwgPSBoWyBoLmxlbmd0aCAtIDEgXSwgbCA9PSB0byB8fCBsID09IGEgfHwgcGF0aCAmJiBwYXRoLmluZGV4T2YoIGwgKSA+PSAwICkgKVxuXHRcdFx0aC5wb3AoKVxuXHRcdGlmICggYSAhPSB0byApXG5cdFx0XHRoLnB1c2goIGEgKVxuXHRcdHBhdGggJiYgaC5wdXNoKCAuLi5wYXRoLmZpbHRlciggaWQgPT4gaWQgIT0gdGhpcy5tYWluICkucmV2ZXJzZSgpIClcblx0XHRsb2NhbC5hY3RpdmVEZXZpY2VJZCA9IHRvXG5cdFx0dGhpcy5kaWFsb2cgPSBgYFxuXHR9LFxuXG5cdGJhY2soKSB7XG5cdFx0d2hpbGUgKCB0aGlzLmhpc3RvcnkubGVuZ3RoICkge1xuXHRcdFx0bGV0IGRldmljZSA9IHRoaXMuaGlzdG9yeS5wb3AoKVxuXHRcdFx0aWYgKCB0aGlzLmdldERldmljZSggZGV2aWNlICkgKVxuXHRcdFx0XHRyZXR1cm4gbG9jYWwuYWN0aXZlRGV2aWNlSWQgPSBkZXZpY2Vcblx0XHR9XG5cdFx0bG9jYWwuYWN0aXZlRGV2aWNlSWQgPSB0aGlzLm1haW5cblx0fSxcblxuXHR3aW5kb3dTaXplOiB3aW5kb3dTaXplLmdldFJlYWRPbmx5KCksXG5cblx0cGxhY2VzU2hpZnRzOiB7XG5cdH0sXG5cblx0Ly8gVE9ETyDQsNCx0L3QsNGe0LvRj9GG0YwhISDRltC90YLRjdGA0YTQtdC50YHRiyDRj9C6INGC0L7Qu9GM0LrRliDRj9C90Ysg0Z4g0LzQsNC00Y3QvNCwINCw0LHQvdCw0Z7Qu9GP0Y7RhtGG0LAhIVxuXHRnZXQgbW9kZW1Mb2NhdGlvbnMoKSB7IHJldHVybiBodHRwQ2xpZW50LmdldCggYC9tb2RlbV9sb2NhdGlvbnNgICkgfSxcblxuXHRnZXQgbG9jYWxNb2RlbSgpIHsgcmV0dXJuIHRoaXMubW9kZW1Mb2NhdGlvbnMgJiYgdGhpcy5tb2RlbUxvY2F0aW9uc1sgMCBdID8gdGhpcy5tb2RlbUxvY2F0aW9uc1sgMCBdLnVybC5yZXBsYWNlKCAvXmh0dHAoPz1zP1xcOlxcL1xcLykvLCBgd3NgICkgOiBgYCB9LFxuXG5cdGdldCBkb0xvZ2luKCkgeyByZXR1cm4gdGhpczo6ZnVuY3Rpb24qICgpIHtcblx0XHR3aGlsZSAoICF0aGlzLmxvZ2dlZGluICYmIHRoaXMubW9kZW1Mb2NhdGlvbnMgKSB7XG5cdFx0XHRsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYHNjcmlwdGAgKVxuXHRcdFx0c2NyaXB0LnNyYyA9IGAkeyB0aGlzLm1vZGVtTG9jYXRpb25zWyAwIF0udXJsIH0vbG9naW4/JHsgVUlEKCkgfWBcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIHNjcmlwdCApXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR5aWVsZCBzY3JpcHRcblx0XHRcdFx0Ly8geWllbGQgUHJvbWlzZS5yYWNlKCBbIGNvLnByb21pc2UoIHNjcmlwdCApLCBjby50aW1lb3V0KCAxNTAwMCApIF0gKVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0Z2xvYmFsLkxPRyggYGVycm9yIHdoaWxlIHRyeWluZyB0byBsb2dpbjogJHsgZXJyb3IgJiYgZXJyb3IubWVzc2FnZSAmJiBlcnJvciB9YCApXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yIClcblx0XHRcdFx0eWllbGQgY28uc2xlZXAoIDMwMCApXG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggc2NyaXB0IClcblx0XHRcdH1cblx0XHRcdGdsb2JhbC5MT0coIGBsb2dnZWQgaW5gIClcblx0XHRcdHJhLmRldGFjaCggKCkgPT4gdGhpcy5sb2dnZWRpbiA9IHRydWUgKVxuXHRcdFx0Ly8gVE9ETzogdGhpcyBjb2RlIHdpdGggYW4gWE1MSHR0cFJlcXVlc3QgZG9lcyBub3Qgd29yayBvbiBpUGhvbmUgOigoKFxuXHRcdFx0Ly8gbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdFxuXHRcdFx0Ly8geGhyLm9wZW4oIGBQT1NUYCwgdGhpcy5tb2RlbUxvY2F0aW9uc1sgMCBdLnVybCArIGAvbG9naW5gLCB0cnVlLCBgbmVyb2AsIGAxMjNgIClcblx0XHRcdC8vIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG5cdFx0XHQvLyB0cnkge1xuXHRcdFx0Ly8gXHR4aHIuc2VuZCgpXG5cdFx0XHQvLyBcdHlpZWxkIHhoclxuXHRcdFx0Ly8gXHQvLyBhbGVydCggeGhyLnN0YXR1cyApXG5cdFx0XHQvLyBcdExPRyggKCBgYCArIHhoci5zdGF0dXMgKS5ibHVlIClcblx0XHRcdC8vIFx0aWYgKCB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDw9IDI5OSApXG5cdFx0XHQvLyBcdFx0cmV0dXJuIHJhLmRldGFjaCggKCkgPT4gdGhpcy5sb2dnZWRpbiA9IHRydWUgKVxuXHRcdFx0Ly8gfVxuXHRcdFx0Ly8gY2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdC8vIFx0Ly8gYWxlcnQoIGBFUlJgIClcblx0XHRcdC8vIFx0Y29uc29sZS5sb2coIGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gbG9naW5gLCBlcnJvciApXG5cdFx0XHQvLyB9XG5cdFx0XHQvLyB5aWVsZCBjby5zbGVlcCggMzAwIClcblx0XHR9XG5cdH0oKSB9LFxuXG5cdGxvZ2luKCBuYW1lLCBwd2QgKSB7fSxcblxuXHRnZXQgc2VydmVyRGV2aWNlcygpIHsgcmV0dXJuIHdzSlNPTmNsaWVudCggdGhpcywgYC9kYXRhYmFzZWAgKSB9LFxuXG5cdGRiY2FjaGU6IHJhLlZhbHVlKCBkYmNhY2hlKCkgKSxcblx0Z2V0IHVwZGF0ZURCQ2FjaGUoKSB7IHRoaXMuZGJjYWNoZS5zb3VyY2UgPSB0aGlzLnNlcnZlckRldmljZXMuZGF0YS52YWx1ZU9mKCkgfSxcblx0Z2V0IGRldmljZXMoKSB7IHJldHVybiB0aGlzLmRiY2FjaGUucmVzdWx0IHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKSB9LFxuXG5cdGdldCBjb21tYW5kcygpIHsgcmV0dXJuIHdzQ2xpZW50KCB0aGlzLCBgL2NvbW1hbmRzYCApIH0sXG5cdGdldCBjb25uZWN0ZWRUb1NlcnZlcigpIHsgcmV0dXJuIHRydWVcblx0XHQmJiB0aGlzLnNlcnZlckRldmljZXMuYWN0aXZlLnZhbHVlT2YoKVxuXHRcdCYmIHRoaXMuY29tbWFuZHMuYWN0aXZlLnZhbHVlT2YoKVxuXHR9LFxuXHRnZXQgd2FpdEZvclJlc3RhcnQoKSB7IHJldHVybiB0aGlzOjpmdW5jdGlvbiogKGFyZ3VtZW50KSB7XG5cdFx0eWllbGQgY28ucmVjZWl2ZSggdGhpcy5jb21tYW5kcywgeyBtZXNzYWdlOiBtZXNzYWdlID0+IG1lc3NhZ2UgJiYgbWVzc2FnZS5zZXJ2ZXJfY29tbWFuZCA9PSBgcmVzdGFydF9jbGllbnRgIH0gKVxuXHRcdHlpZWxkIGNvLnNsZWVwKCAxMDAgKVxuXHRcdGNvbnNvbGUud2FybiggYENMSUVOVF9SRVNUQVJUYCApXG5cdFx0d2luZG93LmNhY2hlZFVybFJlc291cmNlcyA9IG51bGxcblx0XHR5aWVsZCBQcm9taXNlLmFsbCggWyBjYWNoZVVybFJlc291cmNlKCBgLi9qcy9pbmRleC5qc2AgKSwgY2FjaGVVcmxSZXNvdXJjZSggYC4vbWFpbi5odG1sYCApIF0gKVxuXHRcdHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoIHRydWUgKVxuXHR9KCkgfSxcblxuXHRnZXQgbWFpbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kZXZpY2VzLm1haW5cblx0fSxcblxuXHRnZXREZXZpY2UoIGRldmljZUlkICkge1xuXHRcdHJldHVybiB0aGlzLmRldmljZXMuY29udGVudCAmJiB0aGlzLmRldmljZXMuY29udGVudFsgbHUudmFsdWVPZiggZGV2aWNlSWQgKSBdXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZURldmljZUlkKCkge1xuXHRcdHJldHVybiBsb2NhbC5hY3RpdmVEZXZpY2VJZCB8fCB0aGlzLm1haW5cblx0fSxcblxuXHRnZXQgYWN0aXZlRGV2aWNlKCkge1xuXHRcdHJldHVybiB0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZUNvbnRlbnRJZHMoKSB7XG5cdFx0bGV0IGRldmljZSA9IHRoaXMuYWN0aXZlRGV2aWNlXG5cdFx0cmV0dXJuIHJhLkFycmF5KCBsb2Rhc2gua2V5cyggZGV2aWNlICYmIGRldmljZS5jb250ZW50ICkuc29ydCggKCBhLCBiICkgPT4gZGV2aWNlLmNvbnRlbnRbIGEgXS5pbmRleCAtIGRldmljZS5jb250ZW50WyBiIF0uaW5kZXggKSApXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZUNvbnRlbnQoKSB7XG5cdFx0cmV0dXJuIHJhLkFycmF5KCB0aGlzLmFjdGl2ZUNvbnRlbnRJZHMubWFwKCB0aGlzLmdldERldmljZSApIClcblx0fSxcblxuXHRsaW5raW5nUGxhY2VJZDogbnVsbCxcblx0Z2V0IGNsZWFyTGlua2luZ1BsYWNlSWQoKSB7XG5cdFx0aWYgKCB0aGlzLmRpYWxvZyAhPSBgQXNrVG9MaW5rRGV2aWNlYCAmJiB0aGlzLmRpYWxvZyAhPSBgQXNrSWZEZXZpY2VIYXNCZWVuTGlua2VkYCApXG5cdFx0XHR0aGlzLmxpbmtpbmdQbGFjZUlkID0gbnVsbFxuXHR9LFxuXG5cdGdldCBjaGVja0lmVGltZVRvR29CYWNrKCkge1xuXHRcdC8vIGx1LnZhbHVlT2YoIHRoaXMucGxhY2VzIClcblx0XHRpZiAoICF0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApIClcblx0XHRcdHRoaXMuYmFjaygpXG5cdH0sXG5cblx0Z2V0IGNhcHRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWVzc2FnZSggdGhpcy5nZXREZXZpY2UoIHRoaXMuYWN0aXZlRGV2aWNlSWQgKSApIHx8IHRoaXMubWVzc2FnZSggYGZhdm9yaXRlc2AgKVxuXHR9LFxuXG5cdGdldCBkZXZpY2VUeXBlKCkge1xuXHRcdGxldCByZXQgPSB0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApXG5cdFx0aWYgKCAhcmV0IClcblx0XHRcdHJldCA9IHRoaXMuZ2V0RGV2aWNlKCB0aGlzLm1haW4gKVxuXHRcdHJldHVybiAoIHJldCAmJiByZXQudHlwZSApIHx8IGBwbGFjZWBcblx0fSxcblxuXHRnZXQgZGV2aWNlSWRzKCkge1xuXHRcdHJldHVybiByYS5BcnJheSggbG9kYXNoLmtleXMoIHRoaXMuZGV2aWNlcy5jb250ZW50ICkuc29ydCgpIClcblx0fSxcblxuXHRnZXQgaW5pdGlhbExvYWRpbmcoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRldmljZXMudWlkXG5cdH0sXG5cblx0Z2V0IGluaXRpYWxpemVkKCkge1xuXHRcdHJldHVybiAhdGhpcy5pbml0aWFsTG9hZGluZyAmJiAhIXRoaXMuZGV2aWNlcy5tYWluXG5cdH0sXG5cblx0c2V0RGF0YWJhc2UoIGRldmljZXMgKSB7XG5cdFx0dGhpcy5zZXJ2ZXJEZXZpY2VzLnNlbmQoIGRldmljZXMgKVxuXHR9LFxuXG5cdHJlc2V0KCkge1xuXHRcdGxvY2FsLnJlc2V0KClcblx0XHR0aGlzLnNldERhdGFiYXNlKCB7IHVpZDogVUlEKCkgfSApXG5cdFx0dGhpcy5kaWFsb2cgPSBgYFxuXHRcdHRoaXMuZWRpdGluZyA9IGZhbHNlXG5cdFx0dGhpcy5oaXN0b3J5Lmxlbmd0aCA9IDBcblx0fSxcblxuXHRzZXRUZW1wbGF0ZSggdGVtcGxhdGUgKSB7XG5cdFx0Y29uc29sZS5sb2coIHRlbXBsYXRlIClcblx0XHRsZXQgZGV2aWNlcyA9IHtcblx0XHRcdHVpZDogVUlEKCksXG5cdFx0XHRjb250ZW50OiB7fSxcblx0XHR9XG5cdFx0ZnVuY3Rpb24gY29weSggdGVtcGxhdGUsIGRldmljZSApIHtcblx0XHRcdE9iamVjdC5rZXlzKCB0ZW1wbGF0ZSApLmZvckVhY2goIGtleSA9PlxuXHRcdFx0XHRrZXkgIT0gYGltYWdlYCAmJiAvLyBUT0RPOiAhISEhISEhIVxuXHRcdFx0XHRrZXkgIT0gYGNvbnRlbnRgICYmXG5cdFx0XHRcdGtleSAhPSBgdHlwZWAgJiZcblx0XHRcdFx0KCBkZXZpY2VbIGtleSBdID0gdGVtcGxhdGVbIGtleSBdIClcblx0XHRcdClcblx0XHRcdHJldHVybiBkZXZpY2Vcblx0XHR9XG5cdFx0ZnVuY3Rpb24gd2FsayggdGVtcGxhdGUsIGlkICkge1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5jb250ZW50IHx8IHRlbXBsYXRlLnR5cGUgPT0gYHBsYWNlYCApIHtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSB7fVxuXHRcdFx0XHRkZXZpY2VzLmNvbnRlbnRbIGlkIF0gPSBjb3B5KCB0ZW1wbGF0ZSwgeyB0eXBlOiBgcGxhY2VgLCBjb250ZW50OiBjb250ZW50IH0gKVxuXHRcdFx0XHRsZXQgaW5kZXggPSAwXG5cdFx0XHRcdHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5mb3JFYWNoKCBwID0+XG5cdFx0XHRcdFx0Y29udGVudFsgd2FsayggcCwgVUlEKCkgKSBdID0geyBpbmRleDogaW5kZXgrKyB9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkZXZpY2VzLmNvbnRlbnRbIGlkIF0gPSBjb3B5KCB0ZW1wbGF0ZSwgeyB0eXBlOiBgc2luZ2xlYCB9IClcblx0XHRcdH1cblx0XHRcdHJldHVybiBpZFxuXHRcdH1cblx0XHRkZXZpY2VzLm1haW4gPSB3YWxrKCB0ZW1wbGF0ZSwgVUlEKCkgKVxuXHRcdHRoaXMuc2V0RGF0YWJhc2UoIGRldmljZXMgKVxuXHR9LFxuXG5cdGdldCB0ZW1wbGF0ZXMoKSB7IHJldHVybiB0aGlzOjpmdW5jdGlvbiogKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4geWllbGQgaHR0cENsaWVudC5nZXQoIGAvdGVtcGxhdGVzYCApXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gZXJyb3Jcblx0XHR9XG5cdH0oKSB9LFxuXG5cdGdldCBhbGxNZXNzYWdlcygpIHsgcmV0dXJuIHRoaXM6OmZ1bmN0aW9uKiAoKSB7XG5cdFx0cmV0dXJuIHlpZWxkIGh0dHBDbGllbnQuZ2V0KCBgL21lc3NhZ2VzYCApXG5cdH0oKSB9LFxuXG5cdGdldCBtZXNzYWdlcygpIHtcblx0XHRsZXQgYWxsTWVzc2FnZXMgPSB0aGlzLmFsbE1lc3NhZ2VzXG5cdFx0aWYgKCBhbGxNZXNzYWdlcyA9PSBudWxsIClcblx0XHRcdHJldHVyblxuXHRcdGxldCByZXQgPSB7fVxuXHRcdGxldCBsYW5ndWFnZSA9IGxvY2FsLmxhbmd1YWdlIHx8IGBydWBcblx0XHRsb2Rhc2guZm9yT3duKCBhbGxNZXNzYWdlcywgKCB2YWx1ZSwga2V5ICkgPT5cblx0XHRcdHJldFsga2V5IF0gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHZhbHVlLCBsYW5ndWFnZSApID8gdmFsdWVbIGxhbmd1YWdlIF0gOiBrZXkgKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRtZXNzYWdlKCBpZCApIHtcblx0XHRsZXQgcmV0ID0gdGhpcy5tZXNzYWdlcyAmJiB0aGlzLm1lc3NhZ2VzWyBpZCBdXG5cdFx0aWYgKCByZXQgPT0gbnVsbCApXG5cdFx0XHRyZXQgPSBpZFxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRub3RpZmljYXRpb24oIG1lc3NhZ2UgKSB7XG5cdFx0Ly8gYWxlcnQoIG1lc3NhZ2UgKVxuXHR9LFxuXG5cdHNhdmVEZXZpY2UoIGRldmljZUlkLCBkZXZpY2UgKSB7XG5cdFx0bGV0IGRpZmYgPSBEaWZmLm1ha2UoIHRoaXMuZ2V0RGV2aWNlKCBkZXZpY2VJZCApLCBkZXZpY2UgKVxuXHRcdHJldHVybiBkaWZmID09IG51bGwgPyBQcm9taXNlLnJlc29sdmUoKSA6IHRoaXMuc2VydmVyRGV2aWNlcy51cGRhdGUoIHsgY29udGVudDogeyBbIGRldmljZUlkIF06IGRpZmYgfSB9IClcblx0fSxcblxuXHRuZXdJbmRleCggaWNvbklkICkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyggdGhpcy5nZXREZXZpY2UoIGljb25JZCApLmNvbnRlbnQgfHwge30gKS5sZW5ndGggKyAxXG5cdH0sXG5cblx0bGlua0l0ZW0oIGljb25JZCwgaXRlbUlkLCBleHRyYSApIHsgcmV0dXJuIGNvLmdvKCB0aGlzOjpmdW5jdGlvbiogKCkge1xuXHRcdGlmICggaWNvbklkID09IGl0ZW1JZCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2Fubm90IGxpbmsgcGxhY2UgdG8gaXRzZWxmXCIgKVxuXHRcdGxldCBwbGFjZSA9IHRoaXMuZ2V0RGV2aWNlKCBpY29uSWQgKVxuXHRcdGxldCBkZXZpY2UgPSB0aGlzLmdldERldmljZSggaXRlbUlkIClcblx0XHRpZiAoIHBsYWNlLnR5cGUgPT0gYGdyb3VwYCApIHtcblx0XHRcdGlmICggIXBsYWNlLmdyb3VwIClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgaW50ZXJuYWwgZXJyb3I6IG5vIEdST1VQIG51bWJlciBmb3VuZGAgKVxuXHRcdFx0aWYgKCAhZGV2aWNlLmdyb3VwIClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgY2Fubm90IGFkZCB1bmxpbmtlZCBkZXZpY2UgdG8gYSBncm91cGAgKVxuXHRcdH1cblx0XHRsZXQgcmVjID0gdGhpcy5kYmNhY2hlLm9wZW4oKVxuXHRcdGNvLmRlZmVyKCByZWMuY2xvc2UgKVxuXHRcdGxldCBwYWNrZXQgPSB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXToge1xuXHRcdFx0X19wcmVzZW50X186IHRydWUsXG5cdFx0XHRjb250ZW50OiB7IFsgaXRlbUlkIF06IHsgaW5kZXg6IHRoaXMubmV3SW5kZXgoIGljb25JZCApIH0gfSxcblx0XHR9IH0gfVxuXHRcdGxldCByZXN1bHQgPSAhZXh0cmEgPyBwYWNrZXQgOiBEaWZmLm1lcmdlKCBleHRyYSwgcGFja2V0IClcblx0XHRyZWMudXBkYXRlKCByZXN1bHQgKVxuXHRcdGlmICggcGxhY2UudHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdHlpZWxkIHRoaXMuY29tbWFuZCggaXRlbUlkLCBgQXBwZW5kVG9gLCBwbGFjZS5ncm91cCApXG5cdFx0eWllbGQgdGhpcy5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggcmVzdWx0IClcblx0fSApIH0sXG5cblx0bGlua1RvRmF2b3VyaXRlcyggaXRlbUlkICkge1xuXHRcdHJldHVybiB0aGlzLmxpbmtJdGVtKCB0aGlzLm1haW4sIGl0ZW1JZCApXG5cdH0sXG5cblx0bGlua0FjdGl2ZVRvRmF2b3VyaXRlcyggaXRlbUlkICkge1xuXHRcdHJldHVybiB0aGlzLmxpbmtUb0Zhdm91cml0ZXMoIHRoaXMuYWN0aXZlRGV2aWNlSWQgKVxuXHR9LFxuXG5cdGFkZEl0ZW0oIGljb25JZCwgaXRlbSwgaWQgPSBVSUQoKSwgaW5kZXggPSBudWxsICkge1xuXHRcdHJldHVybiB0aGlzLnNlcnZlckRldmljZXMudXBkYXRlKCB7IGNvbnRlbnQ6IHtcblx0XHRcdFsgaWNvbklkIF06IHsgY29udGVudDogeyBbIGlkIF06IHsgaW5kZXg6IGluZGV4ICE9IG51bGwgPyBpbmRleCA6IHRoaXMubmV3SW5kZXgoIGljb25JZCApIH0gfSB9LFxuXHRcdFx0WyBpZCBdOiBpdGVtLFxuXHRcdH0gfSApXG5cdH0sXG5cblx0YWRkUGxhY2UoIGljb25JZCApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRJdGVtKCBpY29uSWQsIHtcblx0XHRcdHR5cGU6IGBwbGFjZWAsXG5cdFx0XHRydTogYNCf0L7QvNC10YnQtdC90LjQtWAsXG5cdFx0XHRlbjogYFJvb21gLFxuXHRcdH0gKVxuXHR9LFxuXG5cdGFkZERldmljZSggaWNvbklkICkge1xuXHRcdHJldHVybiB0aGlzLmFkZEl0ZW0oIGljb25JZCwge1xuXHRcdFx0dHlwZTogYHNpbmdsZWAsXG5cdFx0XHRydTogYNCj0YHRgtGA0L7QudGB0YLQstC+YCxcblx0XHRcdGVuOiBgRGV2aWNlYCxcblx0XHR9IClcblx0fSxcblxuXHRhZGRHcm91cCggaWNvbklkLCBpZCApIHsgcmV0dXJuIGNvLmdvKCB0aGlzOjpmdW5jdGlvbiogKCkge1xuXHRcdGlmICggIWlkIClcblx0XHRcdGlkID0gVUlEKClcblx0XHR5aWVsZCB0aGlzLmFkZEl0ZW0oIGljb25JZCwge1xuXHRcdFx0dHlwZTogYGdyb3VwYCxcblx0XHRcdHJ1OiBg0JPRgNGD0L/Qv9CwYCxcblx0XHRcdGVuOiBgR3JvdXBgLFxuXHRcdH0sIGlkIClcblx0XHR5aWVsZCB0aGlzLmNvbW1hbmQoIGlkLCBgUmVzZXJ2ZWAgKVxuXHRcdHJldHVybiBpZFxuXHR9ICkgfSxcblxuXHRkZWxldGVJdGVtKCBpY29uSWQsIGl0ZW1JZCApIHsgcmV0dXJuIGNvLmdvKCB0aGlzOjpmdW5jdGlvbiogKCkge1xuXHRcdGxldCBwbGFjZSA9IHRoaXMuZ2V0RGV2aWNlKCBpY29uSWQgKVxuXHRcdGxldCByZWMgPSB0aGlzLmRiY2FjaGUub3BlbigpXG5cdFx0Y28uZGVmZXIoIHJlYy5jbG9zZSApXG5cdFx0cmVjLnVwZGF0ZSggeyBjb250ZW50OiB7IFsgaWNvbklkIF06IHsgY29udGVudDogeyBbIGl0ZW1JZCBdOiBudWxsIH0gfSB9IH0gKVxuXHRcdGlmICggcGxhY2UudHlwZSA9PSBgZ3JvdXBgICYmIHBsYWNlLmdyb3VwIClcblx0XHRcdHlpZWxkIHRoaXMuY29tbWFuZCggaXRlbUlkLCBgUmVtb3ZlRnJvbWAsIHBsYWNlLmdyb3VwIClcblx0XHR5aWVsZCB0aGlzLnNlcnZlckRldmljZXMudXBkYXRlKCByZWMudHJhbnNmb3JtZXIoKSApXG5cdH0gKSB9LFxuXG5cdGluc2VydEludG8oIGljb25JZCwgaXRlbUlkLCBmcm9tSWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubGlua0l0ZW0oIGljb25JZCwgaXRlbUlkLCB7IGNvbnRlbnQ6IHsgWyBmcm9tSWQgXTogeyBjb250ZW50OiB7IFsgaXRlbUlkIF06IG51bGwgfSB9IH0gfSApXG5cdH0sXG5cblx0ZXJyb3JzOiBudWxsLFxuXHR0aHJvdyggZGlhbG9nLCBkYXRhLCByZXRyeSApIHtcblx0XHRpZiAoICFkaWFsb2cgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgYW4gZXJyb3IgaGFzIHRvIGhhdmUgaXRzIG93biBkaWFsb2dgIClcblx0XHR0aGlzLmVycm9ycyA9ICggdGhpcy5lcnJvcnMgfHwgW10gKS5jb25jYXQoIFsge1xuXHRcdFx0ZGlhbG9nLFxuXHRcdFx0ZGF0YSxcblx0XHRcdHJldHJ5LFxuXHRcdH0gXSApXG5cdH0sXG5cdGNsZWFyRXJyb3IoKSB7IHJhLmRldGFjaCggKCkgPT4ge1xuXHRcdGlmICggdGhpcy5lcnJvciApIHtcblx0XHRcdHRoaXMuZGlhbG9nID0gYGBcblx0XHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMgJiYgdGhpcy5lcnJvcnMuc2xpY2UoIDEgKVxuXHRcdH1cblx0fSApIH0sXG5cdGdldCBjaGVja0Vycm9yKCkge1xuXHRcdGlmICggIXRoaXMuZGlhbG9nIClcblx0XHRcdGlmICggdGhpcy5lcnJvcnMgJiYgdGhpcy5lcnJvcnMubGVuZ3RoICkgcmEuZGV0YWNoKCAoKSA9PiB7XG5cdFx0XHRcdGxldCBlcnJvciA9IHRoaXMuZXJyb3JzWyAwIF1cblx0XHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycyAmJiB0aGlzLmVycm9ycy5zbGljZSggMSApXG5cdFx0XHRcdHRoaXMuZGlhbG9nID0gZXJyb3IuZGlhbG9nXG5cdFx0XHRcdHRoaXMuZXJyb3IgPSBlcnJvclxuXHRcdFx0fSApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRoaXMuZXJyb3IgPSBudWxsXG5cdH0sXG5cdGVycm9yOiBudWxsLFxuXG5cdHB1cmdlSXRlbSggZGV2aWNlSWQsIGZvcmNlICkgeyByZXR1cm4gY28uZ28oIHRoaXM6OmZ1bmN0aW9uKiAoKSB7XG5cdFx0bGV0IGRldmljZSA9IHRoaXMuZ2V0RGV2aWNlKCBkZXZpY2VJZCApXG5cdFx0bGV0IHJlYyA9IHRoaXMuZGJjYWNoZS5vcGVuKClcblx0XHRjby5kZWZlciggdGhpczo6ZnVuY3Rpb24qICgpIHtcblx0XHRcdGlmICggZm9yY2UgKVxuXHRcdFx0XHR5aWVsZCByZWMuc2F2ZSgpXG5cdFx0XHRyZWMuY2xvc2UoKVxuXHRcdFx0Ly8gc2VydmVyIE1VU1Qgc2VuZCB1cyBhY3R1YWwgc3RhdGUgQkVGT1JFIHJldHVybmluZyByZXN1bHQgb2YgY29tbWFuZCBleGVjdXRpb25cblx0XHRcdGlmICggKCBsdS52YWx1ZU9mKCB0aGlzLnNlcnZlckRldmljZXMuZGF0YSApIHx8IDEgKVsgZGV2aWNlSWQgXSApXG5cdFx0XHRcdHRoaXMudGhyb3coIGBFcnJvclVubGlua2luZ0RldmljZWAsIHsgZGV2aWNlSWQgfSwgKVxuXHRcdH0gKVxuXHRcdHJlYy51cGRhdGUoIGRldmRiLkNsZWFyKCB0aGlzLmRldmljZXMsIGRldmljZUlkICkgKVxuXHRcdGxldCBjbWRcblx0XHRpZiAoIGRldmljZSAmJiBkZXZpY2UuZ3JvdXAgIT0gbnVsbCApXG5cdFx0XHRpZiAoIGRldmljZS50eXBlID09IGBncm91cGAgKVxuXHRcdFx0XHRjbWQgPSBgQ2xlYXJgXG5cdFx0XHRlbHNlIGlmICggZGV2aWNlLnR5cGUgPT0gYHNpbmdsZWAgKVxuXHRcdFx0XHRjbWQgPSBgVW5saW5rYFxuXHRcdGlmICggY21kIClcblx0XHRcdHlpZWxkIHRoaXMuY29tbWFuZCggZGV2aWNlSWQsIGNtZCApXG5cdFx0ZWxzZVxuXHRcdFx0eWllbGQgdGhpcy5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggcmVjLnRyYW5zZm9ybWVyKCkgKVxuXHR9ICkgfSxcblxuXHRyZW5hbWVJdGVtKCBpdGVtSWQsIG5hbWUgKSB7XG5cdFx0bGV0IHJldCA9IGxvZGFzaC5yZWR1Y2UoIHRoaXMuZ2V0RGV2aWNlKCBpdGVtSWQgKSwgKCByZXQsIF8sIGtleSApID0+IHtcblx0XHRcdGlmICgga2V5Lmxlbmd0aCA9PSAyIClcblx0XHRcdFx0cmV0WyBrZXkgXSA9IG51bGxcblx0XHRcdHJldHVybiByZXRcblx0XHR9LCB7fSApXG5cdFx0cmV0WyBsb2NhbERlZmF1bHRzLmxhbmd1YWdlIHx8IGBydWAgXSA9IG5hbWVcblx0XHRyZXR1cm4gdGhpcy5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggeyBjb250ZW50OiB7IFsgaXRlbUlkIF06IHJldCB9IH0gKVxuXHR9LFxuXG5cdGNoYW5nZVBpY3R1cmUoIGl0ZW1JZCwgaWNvbiApIHtcblx0XHRyZXR1cm4gdGhpcy5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggeyBjb250ZW50OiB7IFsgaXRlbUlkIF06IHsgaWNvbiB9IH0gfSApXG5cdH0sXG5cblx0Y29tbWFuZCggZGV2aWNlSWQsIGNtZCwgZGF0YSApIHtcblxuXHRcdC8vIGRlYnVnZ2VyXG5cblx0XHQvLyBUT0RPOlxuXHRcdC8vIGxldCBuZXdzdGF0ZSA9IGRldmljZUFjdGlvbnMuZ2V0TmV3U3RhdGUoIHRoaXMuZ2V0RGV2aWNlKCBkZXZpY2VJZCApLCBjbWQgKVxuXHRcdC8vIGlmICggbmV3c3RhdGUgIT0gbnVsbCApIHtcblx0XHQvLyB9XG5cdFx0cmV0dXJuIHRoaXMuY29tbWFuZHMuYXNrKCB7IGRldmljZTogZGV2aWNlSWQsIGNvbW1hbmQ6IGNtZCwgZGF0YTogZGF0YSB9ICkuZGV0YWNoKClcblx0fSxcblxuXHRpY29uQ29tbWFuZCggaWNvbiwgaWNvbklkLCBjbWQsIGRhdGEgKSB7XG5cdFx0Ly8gY29uc29sZS5sb2coIGljb24sIGljb25JZCwgY21kIClcblx0XHRpY29uID0gbHUudmFsdWVPZiggaWNvbiApXG5cdFx0aWYgKCBpY29uLnR5cGUgPT0gYHBsYWNlYCA/IGNtZCA9PSBgU2hvcnRgIDogY21kID09IGBMb25nYCApXG5cdFx0XHRyZXR1cm4gdGhpcy5nbyggaWNvbklkIClcblx0XHRpZiAoIGljb24udHlwZSAhPSBgcGxhY2VgICYmICFpY29uLmdyb3VwICkge1xuXHRcdFx0dGhpcy5kaWFsb2cgPSBgQXNrVG9MaW5rRGV2aWNlYFxuXHRcdFx0dGhpcy5saW5raW5nUGxhY2VJZCA9IGljb25JZFxuXHRcdFx0Ly8gcmV0dXJuIFByb21pc2UucmVqZWN0KCBuZXcgRXJyb3IoIGBkZXZpY2Ugbm90IGNvbmZpZ3VyZWRgICkgKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0fVxuXHRcdGlmICggY21kID09IGBTaG9ydGAgfHwgY21kID09IGBMb25nYCApIHtcblx0XHRcdGlmICggaWNvbiAmJiBpY29uLnN0YXRlICkge1xuXHRcdFx0XHRjbWQgPSBgU2V0YFxuXHRcdFx0XHRkYXRhID0gMFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNtZCA9IGBTZXRgXG5cdFx0XHRcdGRhdGEgPSAxXG5cdFx0XHR9XG5cdFx0XHQvLyBjbWQgPSBgQ29tZm9ydF8xYFxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5jb21tYW5kKCBpY29uSWQsIGNtZCwgZGF0YSApXG5cdH0sXG5cblx0Zm9jdXMoIG5vZGUgKSB7XG5cdFx0Ly8gbWFnaWMgYWN0aW9ucyB0byBmb3JjZSBhbGxvdyB0byBzaG93IGtleWJvYXJkIGJ5IGlucHV0LmZvY3VzKCkgb24gaU9TICggc28gZmFyIGNoZWNrZWQgaU9TIDggKVxuXHRcdHNldFRpbWVvdXQoICgpID0+IG5vZGUuZm9jdXMoKSwgNDAwIClcblx0fSxcblxuXHRzZWFyY2hBY3Rpb246IG51bGwsXG5cdHNlYXJjaEZpbHRlcjogbnVsbCxcblx0Z2V0IGNoZWNrU2VhcmNoRGlhbG9nKCkge1xuXHRcdGlmICggdGhpcy5kaWFsb2cgIT0gYFNlYXJjaEl0ZW1zYCAmJiB0aGlzLmRpYWxvZyAhPSBgU2VhcmNoUGljdHVyZXNgICkge1xuXHRcdFx0dGhpcy5zZWFyY2hBY3Rpb24gPSBudWxsXG5cdFx0XHR0aGlzLnNlYXJjaEZpbHRlciA9IG51bGxcblx0XHR9XG5cdH0sXG5cblx0aWNvbnM6IG51bGwsXG5cblx0bW9kdWxlczogbmV3IFdlYWtNYXAsXG5cdF9sb2FkKCBtb2R1bGUgKSB7XG5cdFx0aWYgKCBtb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBtb2R1bGUsIGBkZWZhdWx0YCApIClcblx0XHRcdG1vZHVsZSA9IG1vZHVsZS5kZWZhdWx0XG5cdFx0bGV0IHJldCA9IHRoaXMubW9kdWxlcy5nZXQoIG1vZHVsZSApXG5cdFx0aWYgKCByZXQgPT0gbnVsbCApIHtcblx0XHRcdHJldCA9IG1vZHVsZSggYXBwLCBsb2NhbCApXG5cdFx0XHR0aGlzLm1vZHVsZXMuc2V0KCBtb2R1bGUsIHJldCApXG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fSxcblx0bG9hZDogcmEuVmFsdWUoIGZ1bmN0aW9uICggbW9kdWxlID0gdGhpcyApIHtcblx0XHRpZiAoIHR5cGVvZiBtb2R1bGUudGhlbiA9PSBgZnVuY3Rpb25gIClcblx0XHRcdHJldHVybiBtb2R1bGUudGhlbiggYXBwLl9sb2FkIClcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gYXBwLl9sb2FkKCBtb2R1bGUgKVxuXHR9ICksXG5cblx0aG92ZXI6IG51bGwsXG5cblx0ZGVidWdnZXIoKSB7IGRlYnVnZ2VyIH0sXG5cbn0gKS5zZXROYW1lKCBgYXBwYCApXG5cbnJldHVybiB7IGFwcCwgbG9jYWwgfVxuXG59XG4iLCJsZXQgc2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0XG4vLyBsZXQgc2V0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWxcblxucHJvY2Vzcy5uZXh0VGljayA9IG5leHRUaWNrXG5cbmxldCBxdWV1ZSA9IFtdXG5sZXQgdGltZXIgPSBudWxsXG5sZXQgcHJvY2Vzc2luZyA9IGZhbHNlXG5sZXQgY3VycmVudCA9IDBcbmxldCBzZWNyZXQgPSBgcHJvY2Vzcy10aWNrLWAgKyBNYXRoLnJhbmRvbSgpXG5cbmxldCBpbnN0YWxsVGltZXIgPSBmdW5jdGlvbiAoKSB7IHRpbWVyID0gc2V0VGltZW91dCggb25UaW1lciwgMSApIH1cblxuaWYgKCB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBgbWVzc2FnZWAsIGZ1bmN0aW9uICggZXYgKSB7XG5cdFx0bGV0IHNvdXJjZSA9IGV2LnNvdXJjZTtcblx0XHRpZiAoICggc291cmNlID09IHdpbmRvdyB8fCBzb3VyY2UgPT0gbnVsbCApICYmIGV2LmRhdGEgPT0gc2VjcmV0ICkge1xuXHRcdFx0ZXYuc3RvcFByb3BhZ2F0aW9uKClcblx0XHRcdG9uVGltZXIoKVxuXHRcdH1cblx0fSApXG5cdGxldCBwb3N0TWVzc2FnZSA9IHdpbmRvdy5wb3N0TWVzc2FnZVxuXHRpbnN0YWxsVGltZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cG9zdE1lc3NhZ2UoIHNlY3JldCwgYCpgIClcblx0XHR0aW1lciA9IHRydWVcblx0fVxufVxuXG5mb3IgKCBsZXQgbmFtZSBvZiBbIGBzZXRUaW1lb3V0YCwgYHNldEludGVydmFsYCwgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgXSApIHtcblx0bGV0IHByb2MgPSBob29rTWV0aG9kKCB3aW5kb3csIG5hbWUsIGZ1bmN0aW9uICggaGFuZGxlciwgdGltZSApIHtcblx0XHRpZiAoIHR5cGVvZiBhcmd1bWVudHNbIDAgXSA9PSBgZnVuY3Rpb25gIClcblx0XHRcdGFyZ3VtZW50c1sgMCBdID0gZ2V0UHJveHkoIGFyZ3VtZW50c1sgMCBdIClcblx0XHRyZXR1cm4gcHJvYy5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0fSApXG59XG5cbiFbIHdpbmRvdywgZG9jdW1lbnQgXS5mb3JFYWNoKCBob29rRXZlbnRMaXN0ZW5lciApXG5cbmZ1bmN0aW9uIG9uVGltZXIoKSB7XG5cdHRpbWVyID0gbnVsbFxuXHRjaGVja1F1ZXVlKClcbn1cblxuZnVuY3Rpb24gZW5zdXJlVGltZXIoKSB7XG5cdGlmICggIXRpbWVyICYmICFwcm9jZXNzaW5nIClcblx0XHRpbnN0YWxsVGltZXIoKVxufVxuXG5uZXh0VGljay5fZGJnID0gbnVsbFxuZnVuY3Rpb24gREVCVUdHRVIoKSB7XG5cdGRlYnVnZ2VyXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKCBmdW4gKSB7XG5cdGlmICggbmV4dFRpY2suX2RiZyAmJiBuZXh0VGljay5fZGJnKCkgKVxuXHRcdERFQlVHR0VSKClcblx0bGV0IGFyZ3Ncblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblx0XHRhcmdzID0gW11cblx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kgKVxuXHRcdFx0YXJncy5wdXNoKCBhcmd1bWVudHNbIGkgXSApXG5cdFx0ZnVuID0gZnVuLmJpbmQoIG51bGwsIC4uLmFyZ3MgKVxuXHR9XG5cdHF1ZXVlLnB1c2goIGZ1biApXG5cdGVuc3VyZVRpbWVyKClcbn1cblxuZnVuY3Rpb24gY2hlY2tRdWV1ZSgpIHtcblx0aWYgKCAhcHJvY2Vzc2luZyAmJiBxdWV1ZS5sZW5ndGggPiAwIClcblx0XHRwcm9jZXNzUXVldWUoKVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XG5cdGN1cnJlbnQgPSAwXG5cdHByb2Nlc3NpbmcgPSB0cnVlXG5cdHRyeSB7XG5cdFx0bG9vcFF1ZXVlKClcblx0fVxuXHRmaW5hbGx5IHtcblx0XHQvLyBjb25zb2xlLmxvZyggYHRpY2tzOiBgICsgaW5kZXggKVxuXHRcdHByb2Nlc3NpbmcgPSBmYWxzZVxuXHRcdGlmICggcXVldWUubGVuZ3RoICkge1xuXHRcdFx0cXVldWUuc3BsaWNlKCAwLCBjdXJyZW50IClcblx0XHRcdGVuc3VyZVRpbWVyKClcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbG9vcFF1ZXVlKCkge1xuXHRpZiAoIG5leHRUaWNrLl9kYmcgJiYgbmV4dFRpY2suX2RiZygpIClcblx0XHRERUJVR0dFUigpXG5cdHdoaWxlICggY3VycmVudCA8IHF1ZXVlLmxlbmd0aCApIHtcblx0XHRpZiAoIGN1cnJlbnQgPj0gMHgxMDAwMCApIHtcblx0XHRcdHF1ZXVlLnNwbGljZSggMCwgY3VycmVudCApXG5cdFx0XHRjdXJyZW50ID0gMFxuXHRcdH1cblx0XHRxdWV1ZVsgY3VycmVudCsrIF0oKVxuXHRcdGlmICggbmV4dFRpY2suX2RiZyAmJiBuZXh0VGljay5fZGJnKCkgKVxuXHRcdFx0REVCVUdHRVIoKVxuXHR9XG5cdHF1ZXVlLmxlbmd0aCA9IDBcbn1cblxuZnVuY3Rpb24gZ2V0UHJveHkoIGhhbmRsZXIgKSB7XG5cdGZ1bmN0aW9uIHByb3h5KCkge1xuXHRcdGxldCByZXQgPSBoYW5kbGVyLmhhbmRsZUV2ZW50ID8gaGFuZGxlci5oYW5kbGVFdmVudC5hcHBseSggaGFuZGxlciwgYXJndW1lbnRzICkgOiBoYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHRcdGNoZWNrUXVldWUoKVxuXHRcdHJldHVybiByZXRcblx0fVxuXHRsZXQgcmV0XG5cdGlmICggKCByZXQgPSBoYW5kbGVyWyBzZWNyZXQgXSApICE9IG51bGwgKVxuXHRcdHJldHVybiByZXRcblx0ZWxzZSB7XG5cdFx0YXNzaWduUHJvcGVydHkoIHByb3h5LCBzZWNyZXQsIHByb3h5IClcblx0XHRyZXR1cm4gYXNzaWduUHJvcGVydHkoIGhhbmRsZXIsIHNlY3JldCwgcHJveHkgKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGhvb2tFdmVudExpc3RlbmVyKCBvYmogKSB7XG5cdGlmICggb2JqLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0bGV0IGFkZEV2ZW50TGlzdGVuZXIgPSBob29rTWV0aG9kKCBvYmosIGBhZGRFdmVudExpc3RlbmVyYCxcblx0XHRcdGZ1bmN0aW9uICggZXZlbnQsIGhhbmRsZXIgKSB7XG5cdFx0XHRcdGFyZ3VtZW50c1sgMSBdID0gZ2V0UHJveHkoIGFyZ3VtZW50c1sgMSBdIClcblx0XHRcdFx0cmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0XHR9IClcblx0XHRsZXQgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGhvb2tNZXRob2QoIG9iaiwgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLFxuXHRcdFx0ZnVuY3Rpb24gKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHNbIDEgXVsgc2VjcmV0IF0gKVxuXHRcdFx0XHRcdGFyZ3VtZW50c1sgMSBdID0gYXJndW1lbnRzWyAxIF1bIHNlY3JldCBdXG5cdFx0XHRcdHJldHVybiByZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHRcdFx0fSApXG5cdH1cbn1cblxuZnVuY3Rpb24gaG9va01ldGhvZCggb2JqLCBuYW1lLCBwcm94eSApIHtcblx0bGV0IHJldCA9IG9ialsgbmFtZSBdXG5cdGlmICggcmV0ICkge1xuXHRcdGFzc2lnblByb3BlcnR5KCBwcm94eSwgYHRvU3RyaW5nYCwgKCkgPT4gcmV0LnRvU3RyaW5nKCkgKVxuXHRcdG9ialsgbmFtZSBdID0gcHJveHlcblx0fVxuXHRyZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb3BlcnR5KCBvYmosIG5hbWUsIHZhbHVlICkge1xuXHRpZiAoIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSApXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIG5hbWUsIHsgdmFsdWUgfSApXG5cdGVsc2Vcblx0XHRvYmpbIG5hbWUgXSA9IHZhbHVlXG5cdHJldHVybiB2YWx1ZVxufVxuIiwibGV0IGNvQ3VycmVudCA9IG51bGwsIGNvR2xvYmFsID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5leHBvcnQgeyBjb0N1cnJlbnQgYXMgY3VycmVudCwgY29HbG9iYWwgYXMgZ2xvYmFsIH1cblxubGV0IF9kZWJ1ZyA9IG51bGxcbmxldCBfa2lsbGRlYnVnID0gIXRydWVcbmxldCBERUJVR0dFUiA9ICgpID0+IHsgZGVidWdnZXIgfVxuXG5mdW5jdGlvbiBfX2RlYnVnKCB0aHJlYWQgPSBjb0N1cnJlbnQsIGRlYnVnID0gdHJ1ZSApIHtcblx0cmV0dXJuIGRlYnVnID8gKCBfZGVidWcgfHwgKCBfZGVidWcgPSBuZXcgV2Vha1NldCApICkuYWRkKCB0aHJlYWQgKSA6IF9kZWJ1ZyAmJiBfZGVidWcuZGVsZXRlKCB0aHJlYWQgKVxufVxuZXhwb3J0IHsgX19kZWJ1ZyBhcyBfZGVidWcgfVxuXG5leHBvcnQgY29uc3QgZ28gPSAoIGZ1biwgLi4uYXJncyApID0+IHtcblx0aWYgKCB0eXBlb2YgZnVuID09IGBmdW5jdGlvbmAgKVxuXHRcdGZ1biA9IGZ1biggLi4uYXJncyApXG5cdGlmICggdHlwZW9mIGZ1bi5uZXh0ICE9IGBmdW5jdGlvbmAgKSB7XG5cdFx0bGV0IHZhbHVlID0gZnVuXG5cdFx0ZnVuID0ge1xuXHRcdFx0bmV4dCgpIHtcblx0XHRcdFx0bGV0IHJldCA9IHsgdmFsdWUsIGRvbmU6ICF2YWx1ZSB9XG5cdFx0XHRcdHZhbHVlID0gbnVsbFxuXHRcdFx0XHRyZXR1cm4gcmV0XG5cdFx0XHR9LFxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbmV3IFRocmVhZCggZnVuLCBmYWxzZSApXG59XG5cbmV4cG9ydCBjb25zdCBmdW5jID0gZnVuY3Rpb24gKCBmdW4gKSB7XG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+PSAyIClcblx0XHRmdW4gPSBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQuY2FsbCggYXJndW1lbnRzLCAoIGcsIGYgKSA9PiBmKCBnICkgKVxuXHRyZXR1cm4gZnVuY3Rpb24gcHJvYygpIHtcblx0XHRyZXR1cm4gbmV3IFRocmVhZCggZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSwgdHJ1ZSApXG5cdH1cbn1cblxuZXhwb3J0IGNvbnN0IGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICggZnVuICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gcHJvYygpIHtcblx0XHRsZXQgcmV0ID0gbmV3IFRocmVhZCggZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSwgdHJ1ZSApXG5cdFx0cmV0LndhaXRGb3JJbnB1dCgpXG5cdFx0cmV0dXJuIHJldFxuXHR9XG59XG5cbi8vIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBlcnJvciwgdGhlIHNlY29uZCBvbmUgaXMgYSByZXN1bHRcbmV4cG9ydCBjb25zdCBjYmZ1bmMgPSBmdW5XaXRoQ0IgPT4gZnVuY3Rpb24gKCAuLi5hcmdzICkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT5cblx0XHR0aGlzOjpmdW5XaXRoQ0IoIC4uLmFyZ3MsICggZXJyb3IsIHZhbHVlICkgPT4gZXJyb3IgPT0gbnVsbCA/IHJlc29sdmUoIHZhbHVlICkgOiByZWplY3QoIGVycm9yICkgKVxuXHQpXG59XG5cbmxldCBraWxsYWJsZVByb21pc2UgPSBjYWxsYmFjayA9PiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cdC8vIHJldHVybiBjYWxsYmFjayggcmVzb2x2ZSwgcmVqZWN0IClcblx0bGV0IGRvbmUgPSBmYWxzZVxuXHRsZXQgbWFrZVByb2MgPSBwcm9jID0+IHZhbHVlID0+IHtcblx0XHRpZiAoIGRvbmUgKVxuXHRcdFx0cmV0dXJuXG5cdFx0ZG9uZSA9IHRydWVcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHByb2MoIHZhbHVlIClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRkZWYuY2xvc2UoKVxuXHRcdFx0a2lsbCAmJiBraWxsKClcblx0XHR9XG5cdH1cblx0bGV0IGNhbGxfcmVqZWN0ID0gbWFrZVByb2MoIHJlamVjdCApXG5cdGxldCBkZWYgPSBkZWZlciggY2FsbF9yZWplY3QgKVxuXHRsZXQga2lsbCA9IGNhbGxiYWNrKCBtYWtlUHJvYyggcmVzb2x2ZSApLCBjYWxsX3JlamVjdCApXG59IClcblxuZXhwb3J0IGNvbnN0IHJlY2VpdmUgPSAoIGVtaXR0ZXIsIGV2ZW50cyApID0+IGtpbGxhYmxlUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cdGxldCBoYW5kbGVycyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRsZXQgdGltZXJcblx0Zm9yICggbGV0IGV2ZW50IGluIGV2ZW50cyApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBldmVudHMsIGV2ZW50ICkgKSB7XG5cdFx0bGV0IHByZWRpY2F0ZSA9IGV2ZW50c1sgZXZlbnQgXVxuXHRcdGlmICggcHJlZGljYXRlID09IG51bGwgKVxuXHRcdFx0Ly9cblx0XHRcdC8vIGFsbG93IHNpbXBsZXIgZXZlbnRzIGRlZmluaW5nIGxpa2Vcblx0XHRcdC8vXG5cdFx0XHQvLyB5aWVsZCBjby5yZWNlaXZlKCBvYmosIHsgZGF0YTogdHJ1ZSwgdGltZW91dDogZ2V0VGltZW91dCggLi4uICkgfSApXG5cdFx0XHQvL1xuXHRcdFx0Ly8gaW5zdGVhZCBvZlxuXHRcdFx0Ly9cblx0XHRcdC8vIGxldCBldmVudHMgPSB7IGRhdGE6IHRydWUgfVxuXHRcdFx0Ly8gaWYgKCBnZXRUaW1lb3V0KCAuLi4gKSAhPSBudWxsICkgZXZlbnRzLnRpbWVvdXQgPSBnZXRUaW1lb3V0KCAuLi4gKVxuXHRcdFx0Ly8geWllbGQgY28ucmVjZWl2ZSggb2JqLCBldmVudHMgKVxuXHRcdFx0Ly9cblx0XHRcdGNvbnRpbnVlXG5cdFx0aWYgKCBldmVudCA9PSBgdGltZW91dGAgKVxuXHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCAoKSA9PiByZXNvbHZlKCB7IGV2ZW50OiBgdGltZW91dGAsIGRhdGE6IG51bGwgfSApLCBwcmVkaWNhdGUgKVxuXHRcdGVsc2Vcblx0XHRcdGVtaXR0ZXIuYWRkTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyc1sgZXZlbnQgXSA9IGRhdGEgPT4ge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBwcmVkaWNhdGUgIT0gYGZ1bmN0aW9uYCB8fCBwcmVkaWNhdGUoIGRhdGEgKSApXG5cdFx0XHRcdFx0cmVzb2x2ZSggeyBldmVudCwgZGF0YSB9IClcblx0XHRcdH0gKVxuXHR9XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCAhaGFuZGxlcnMgKVxuXHRcdFx0cmV0dXJuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aW1lciApXG5cdFx0Zm9yICggbGV0IGV2ZW50IGluIGhhbmRsZXJzIClcblx0XHRcdGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyc1sgZXZlbnQgXSApXG5cdFx0aGFuZGxlcnMgPSBudWxsXG5cdH1cbn0gKVxuXG5sZXQgY2JQcm9taXNlc1xuXG5leHBvcnQgY29uc3QgY2IgPSBmID0+IHtcblx0aWYgKCAhY2JQcm9taXNlcyApXG5cdFx0Y2JQcm9taXNlcyA9IG5ldyBXZWFrTWFwXG5cdGVsc2UgaWYgKCBjYlByb21pc2VzLmhhcyggY29HbG9iYWwgKSApXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgY28ud2FpdCBtdXN0IGJlIGNhbGxlZCBhZnRlciBwcmV2aW91cyBjby5jYiBjYWxsYCApXG5cdGxldCByZXQgPSBudWxsXG5cdGNiUHJvbWlzZXMuc2V0KCBjb0dsb2JhbCwgbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4gcmV0ID0gKCBlcnJvciwgcmVzdWx0ICkgPT4gZXJyb3IgPyByZWplY3QoIGVycm9yICkgOiByZXNvbHZlKCByZXN1bHQgKSApIClcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnQgY29uc3Qgd2FpdCA9ICgpID0+IHtcblx0bGV0IHJldCA9IGNiUHJvbWlzZXMgJiYgY2JQcm9taXNlcy5nZXQoIGNvR2xvYmFsIClcblx0aWYgKCAhcmV0IClcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGBjby53YWl0IG11c3QgYmUgY2FsbGVkIGFmdGVyIGNvLmNiIGNhbGxgIClcblx0Y2JQcm9taXNlcy5kZWxldGUoIGNvR2xvYmFsIClcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnQgY29uc3Qgc2xlZXAgPSBtaWxsaXNlY29uZHMgPT4gKCB7IHRoZW46IHJlc29sdmUgPT4ge1xuXHRsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCByZXNvbHZlLCBtaWxsaXNlY29uZHMgKVxuXHRyZXR1cm4geyBraWxsKCkgeyBjbGVhclRpbWVvdXQoIHRpbWVyICkgfSB9XG59IH0gKVxuXG5leHBvcnQgY29uc3QgdGljayA9IHNsZWVwKCAxIClcblxuZXhwb3J0IGNvbnN0IHRpbWVvdXQgPSBtaWxsaXNlY29uZHMgPT4gKCB7IHRoZW46ICggXywgcmVqZWN0ICkgPT4ge1xuXHRsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCByZWplY3QsIG1pbGxpc2Vjb25kcyApXG5cdHJldHVybiB7IGtpbGwoKSB7IGNsZWFyVGltZW91dCggdGltZXIgKSB9IH1cbn0gfSApXG5cbmV4cG9ydCBjb25zdCBwcm9taXNlID0gdmFsdWUgPT4gUHJvbWlzZS5hbGwoIFsgZ28oIGZ1bmN0aW9uKiAoKSB7XG5cdHlpZWxkIHZhbHVlXG59ICkgXSApXG5cbmNvbnN0IGNvUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0geyB0aGVuOiByZXNvbHZlID0+IHtcblx0aWYgKCB0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRsZXQgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJlc29sdmUgKVxuXHRcdHJldHVybiB7IGtpbGwoKSB7IGNhbmNlbEFuaW1hdGlvbkZyYW1lKCBmcmFtZSApIH0gfVxuXHR9XG5cdGVsc2Vcblx0XHRyZXR1cm4gc2xlZXAoIDEgKS50aGVuKCByZXNvbHZlIClcbn0gfVxuZXhwb3J0IHsgY29SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIH1cblxuZXhwb3J0IGNvbnN0IHdyYXAgPSBwcm9jID0+IGNvQ3VycmVudCA/IGNvQ3VycmVudC53cmFwKCBwcm9jICkgOiBwcm9jXG5cbmxldCByZXNvbHZlZCA9IGRvIHtcblx0bGV0IHJlc29sdmUgPSAoIHZhbHVlLCBjYWxsYmFjayApID0+IGNhbGxiYWNrKCB2YWx1ZSApXG5cdHZhbHVlID0+ICggeyB0aGVuOiByZXNvbHZlLmJpbmQoIG51bGwsIHZhbHVlICkgfSApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkKCkge1xuXHRsZXQgc3RyZWFtID0gdGhpc1xuXHRsZXQgdmFsdWUgPSBzdHJlYW0ucmVhZCgpXG5cdGlmICggdmFsdWUgIT0gbnVsbCB8fCAhc3RyZWFtLnJlYWRhYmxlIClcblx0XHRyZXR1cm4gcmVzb2x2ZWQoIHZhbHVlIClcblx0cmV0dXJuIHJlY2VpdmUoIHN0cmVhbSwgeyByZWFkYWJsZTogdHJ1ZSB9ICkudGhlbiggKCkgPT4gc3RyZWFtLnJlYWQoKSApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZSggZGF0YSwgY2h1bmsgICkge1xuXHRsZXQgc3RyZWFtID0gdGhpc1xuXHRpZiAoIHN0cmVhbS53cml0ZSggZGF0YSwgY2h1bmsgKSApXG5cdFx0cmV0dXJuIG51bGxcblx0ZWxzZVxuXHRcdHJldHVybiByZWNlaXZlKCBzdHJlYW0sIHsgZHJhaW46IHRydWUsIGVuZDogdHJ1ZSwgZmluaXNoOiB0cnVlIH0gKVxufVxuXG5sZXQgcmV0aHJvdyA9IGUgPT4ge1xuXHRwcm9jZXNzLm5leHRUaWNrKCAoKSA9PiB7IHRocm93IGUgfSApXG59XG5cbmxldCBub29wID0gKCkgPT4ge31cblxuZnVuY3Rpb24gaXRlcmF0b3JGYWlsZWQoIGVycm9yICkge1xuXHRyZXR1cm4geyBkb25lOiB0cnVlLCBpdGVyYXRvckZhaWxlZDogdHJ1ZSwgdmFsdWU6IGVycm9yIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JOZXh0KCBpdGVyYXRvciwgcmVzdWx0ICkge1xuXHR0cnkge1xuXHRcdHJldHVybiBpdGVyYXRvci5uZXh0KCByZXN1bHQgKVxuXHR9XG5cdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0cmV0dXJuIGl0ZXJhdG9yRmFpbGVkKCBlcnJvciApXG5cdH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JUaHJvdyggaXRlcmF0b3IsIHJlc3VsdCApIHtcblx0aWYgKCAhaXRlcmF0b3IudGhyb3cgKVxuXHRcdHJldHVybiBpdGVyYXRvckZhaWxlZCggcmVzdWx0IClcblx0dHJ5IHtcblx0XHRyZXR1cm4gaXRlcmF0b3IudGhyb3coIHJlc3VsdCApXG5cdH1cblx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRyZXR1cm4gaXRlcmF0b3JGYWlsZWQoIGVycm9yIClcblx0fVxufVxuXG5jb25zdCBET05FID0geyBkb25lOiB0cnVlIH1cblxuZXhwb3J0IGNsYXNzIEVLaWxsIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvciggbWVzc2FnZSA9IGBraWxsYCApIHtcblx0XHRzdXBlciggbWVzc2FnZSApXG5cdH1cbn1cblxubGV0IEZJTkFMSVpJTkcgPSBuZXcgRUtpbGwoIGBmaW5hbGl6aW5nYCApXG5cbmZ1bmN0aW9uIGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciwgdmFsdWUgKSB7XG5cdGlmICggaXRlcmF0b3IucmV0dXJuICkge1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgdiA9IGl0ZXJhdG9yLnJldHVybiggdmFsdWUgKVxuXHRcdFx0aWYgKCAhdiB8fCAhdi5kb25lIClcblx0XHRcdFx0cmV0aHJvdyggbmV3IEVycm9yKCBgdGhyZWFkIGhhcyBlYXRlbiByZXR1cm4oKWAgKSApXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXRocm93KCBuZXcgRXJyb3IoIGB0aHJlYWQgaGFzIGVhdGVuIHJldHVybigpIGFuZCB0aHJvd24gYW4gZXhjZXB0aW9uYCApIClcblx0XHRcdHJldHVybiBpdGVyYXRvckZhaWxlZCggZXJyb3IgKVxuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggaXRlcmF0b3IudGhyb3cgKSB7XG5cdFx0bGV0IGUgPSBuZXcgRUtpbGxcblx0XHRsZXQgdiA9IGl0ZXJhdG9yVGhyb3coIGl0ZXJhdG9yLCBlIClcblx0XHRpZiAoICF2IHx8ICF2LmRvbmUgfHwgIXYuaXRlcmF0b3JGYWlsZWQgKVxuXHRcdFx0cmV0aHJvdyggbmV3IEVycm9yKCBgdGhyZWFkIGhhcyBlYXRlbiBFS2lsbGAgKSApXG5cdFx0ZWxzZSBpZiAoIHYudmFsdWUgIT0gZSApXG5cdFx0XHRyZXR1cm4gdlxuXHR9XG5cdHJldHVybiBET05FXG59XG5cbmZ1bmN0aW9uIGtpbGxJdGVyYXRvciggaXRlcmF0b3IsIHZhbHVlICkge1xuXHRpZiAoIGl0ZXJhdG9yICkge1xuXHRcdGxldCByZXMgPSBpdGVyYXRvclJldHVybiggaXRlcmF0b3IsIHZhbHVlIClcblx0XHRpZiAoIHJlcy5kb25lICYmIHJlcy5pdGVyYXRvckZhaWxlZCApXG5cdFx0XHRyZXRocm93KCByZXMudmFsdWUgKVxuXHR9XG5cdHJldHVybiBET05FXG59XG5cbi8vIFRocmVhZFxuXG5sZXQgZHVtbXlJdGVyYXRvciA9IHtcblx0bmV4dDogKCkgPT4gRE9ORSxcblx0dGhyb3c6IGVycm9yID0+IHsgdGhyb3cgZXJyb3IgfSxcblx0cmV0dXJuOiB2YWx1ZSA9PiAoIHsgdmFsdWUsIGRvbmU6IHRydWUgfSApLFxufVxuXG5leHBvcnQgY29uc3QgZGVmZXIgPSBwcm9jID0+IHtcblx0aWYgKCB0eXBlb2YgcHJvYyAhPSBgZnVuY3Rpb25gIClcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGBvbmx5IGZ1bmN0aW9ucyBjYW4gYmUgZGVmZXJyZWRgIClcblx0bGV0IHRocmVhZCA9IGNvQ3VycmVudFxuXHRpZiAoICF0aHJlYWQgfHwgIXRocmVhZC5fY3VycmVudCApXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgbm90IGluIGEgdGhyZWFkYCApXG5cdGxldCBpdGVyYXRvciA9IGR1bW15SXRlcmF0b3Jcblx0ZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoKSB7XG5cdFx0aWYgKCBwcm9jICkge1xuXHRcdFx0Ly8gS2VlcCBpbiBtaW5kIGV4Y2VwdGlvbnMuIFNhdmUgc3RhdGUgY29uc2lzdGVudCBpbiBjYXNlIG9mIGV4Y2VwdGlvbiBpbiBwcm9jKCkuXG5cdFx0XHRsZXQgcCA9IHByb2Ncblx0XHRcdHByb2MgPSBudWxsXG5cdFx0XHRsZXQgaSA9IHAoKVxuXHRcdFx0aWYgKCBpICYmIHR5cGVvZiBpLm5leHQgPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRcdGl0ZXJhdG9yID0gaVxuXHRcdFx0ZGVmZXJSZWMuX2l0ZXJhdG9yID0gaXRlcmF0b3Jcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZXJhdG9yXG5cdH1cblx0bGV0IGxhenlJdGVyYXRvclByb3h5ID0ge1xuXHRcdG5leHQ6IHZhbHVlID0+IGNyZWF0ZUl0ZXJhdG9yKCkubmV4dCggdmFsdWUgKSxcblx0XHR0aHJvdzogZXJyb3IgPT4ge1xuXHRcdFx0Y3JlYXRlSXRlcmF0b3IoKVxuXHRcdFx0cmV0dXJuIGl0ZXJhdG9yLnRocm93ID8gaXRlcmF0b3IudGhyb3coIGVycm9yICkgOiBkdW1teUl0ZXJhdG9yLnRocm93KCBlcnJvciApXG5cdFx0fSxcblx0XHRyZXR1cm46IHZhbHVlID0+IHtcblx0XHRcdGlmICggcHJvYyApXG5cdFx0XHRcdC8vIGxldCBkZWZmZXJlZCBpdGVyYXRvciBkbyBhdCBsZWFzdCBvbmUgc3RlcFxuXHRcdFx0XHRjcmVhdGVJdGVyYXRvcigpLm5leHQoIHVuZGVmaW5lZCApXG5cdFx0XHRpZiAoIGl0ZXJhdG9yLnJldHVybiApXG5cdFx0XHRcdHJldHVybiBpdGVyYXRvci5yZXR1cm4oIHZhbHVlIClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoIGl0ZXJhdG9yLnRocm93ICkgIWZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsZXQgZWtpbGwgPSBuZXcgRUtpbGwoIGByZXR1cm5gIClcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aXRlcmF0b3IudGhyb3coIGVraWxsIClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0XHRcdGlmICggZXJyb3IgIT0gZWtpbGwgKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSgpXG5cdFx0XHRcdHJldHVybiBkdW1teUl0ZXJhdG9yLnJldHVybiggdmFsdWUgKVxuXHRcdFx0fVxuXHRcdH0sXG5cdH1cblx0bGV0IGRlZmVyUmVjID0gbmV3IEl0ZXJhdG9yUmVjKCB0aHJlYWQsIGxhenlJdGVyYXRvclByb3h5LCB0aHJlYWQuX2N1cnJlbnQuX2NhbGxlciApXG5cdHRocmVhZC5fc3RhY2sucHVzaCggZGVmZXJSZWMgKVxuXHRyZXR1cm4geyBjbG9zZSgpIHsgcHJvYyA9IG51bGwgfSB9XG59XG5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IHByb2MgPT4gY29DdXJyZW50ID8gY29DdXJyZW50Lm5leHRUaWNrKCBwcm9jICkgOiBwcm9jZXNzLm5leHRUaWNrKCBwcm9jIClcblxuY2xhc3MgSXRlcmF0b3JSZWMge1xuXHRjb25zdHJ1Y3RvciggdGhyZWFkLCBpdGVyYXRvciwgY2FsbGVyICkge1xuXHRcdHRoaXMuX3RocmVhZCA9IHRocmVhZFxuXHRcdHRoaXMuX2NhbGxlciA9IGNhbGxlclxuXHRcdHRoaXMuX2l0ZXJhdG9yID0gaXRlcmF0b3Jcblx0XHR0aGlzLl9tZXRob2QgPSBpdGVyYXRvck5leHRcblx0XHR0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZFxuXHRcdHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbnVsbFxuXHRcdHRoaXMuX25leHQgPSA6OnRoaXMuX25leHRcblx0XHR0aGlzLl90aHJvdyA9IDo6dGhpcy5fdGhyb3dcblx0XHR0aGlzLl9jYiA9IDo6dGhpcy5fY2Jcblx0fVxuXG5cdF9zdG9yZSggdmFsdWUsIGlzRXJyb3IgKSB7XG5cdFx0aWYgKCBpc0Vycm9yICkge1xuXHRcdFx0aWYgKCB0aGlzLl9tZXRob2QgPT0gaXRlcmF0b3JUaHJvdyApXG5cdFx0XHRcdHJldGhyb3coIHRoaXMuX3ZhbHVlIClcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5fbWV0aG9kID0gaXRlcmF0b3JUaHJvd1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIGlmICggdGhpcy5fbWV0aG9kID09IG51bGwgKSB7XG5cdFx0XHR0aGlzLl9tZXRob2QgPSBpdGVyYXRvck5leHRcblx0XHRcdHRoaXMuX3ZhbHVlID0gdmFsdWVcblx0XHR9XG5cdH1cblx0X29udmFsdWUoIG1ldGhvZCwgdmFsdWUgKSB7XG5cdFx0aWYgKCBfZGVidWcgJiYgX2RlYnVnLmhhcyggdGhpcy5fdGhyZWFkICkgKSBERUJVR0dFUigpXG5cdFx0dGhpcy5fY3VycmVudFByb21pc2UgPSBudWxsXG5cdFx0aWYgKCB0aGlzLl90aHJlYWQgKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlXG5cdFx0XHR0aGlzLl9tZXRob2QgPSBtZXRob2Rcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soIHRoaXMuX3RocmVhZC5fcHJvY2Vzc0l0ZXJhdG9yIClcblx0XHR9XG5cdH1cblx0X25leHQoIHZhbHVlICkge1xuXHRcdHRoaXMuX29udmFsdWUoIGl0ZXJhdG9yTmV4dCwgdmFsdWUgKVxuXHR9XG5cdF90aHJvdyggZXJyb3IgKSB7XG5cdFx0aWYgKCAhdGhpcy5fdGhyZWFkIClcblx0XHRcdHJldGhyb3coIGVycm9yIClcblx0XHR0aGlzLl9vbnZhbHVlKCBpdGVyYXRvclRocm93LCBlcnJvciApXG5cdH1cblx0X2NiKCBlcnJvciwgZGF0YSApIHtcblx0XHRpZiAoIGVycm9yIClcblx0XHRcdHRoaXMuX3Rocm93KCBlcnJvciApXG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5fbmV4dCggZGF0YSApXG5cdH1cbn1cblxuZnVuY3Rpb24gX29uc3VjY2VzcyggZXZlbnQgKSB7XG5cdHRoaXMuX25leHQoIGV2ZW50LnRhcmdldC5yZXN1bHQgKVxufVxuXG5mdW5jdGlvbiBfb25sb2FkKCBldmVudCApIHtcblx0dGhpcy5fbmV4dCggZXZlbnQudGFyZ2V0IClcbn1cblxuZnVuY3Rpb24gX29uZXJyb3IoIGV2ZW50ICkge1xuXHR0aGlzLl90aHJvdyggZXZlbnQudGFyZ2V0LmVycm9yIHx8IGV2ZW50IClcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2soIG4gPSAwLCBtID0gMCApIHtcblx0dHJ5IHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwieHh4XCIgKVxuXHR9XG5cdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0cmV0dXJuIGVycm9yLnN0YWNrLnNwbGl0KCBgXFxuYCApLmZpbHRlciggQm9vbGVhbiApLnNsaWNlKCAzICsgbiwgbSA/IC1tIDogSW5maW5pdHkgKVxuXHR9XG59XG5cbmNsYXNzIENoaWxkIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9vd25lciA9IG51bGxcblx0fVxuXG5cdF9raWxsKCkge1xuXHRcdHRoaXMuZGV0YWNoKClcblx0fVxuXG5cdGRldGFjaCgpIHtcblx0XHRpZiAoIHRoaXMuX293bmVyIClcblx0XHRcdHRoaXMuX293bmVyLl91bmxpbmtDaGlsZCggdGhpcyApXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGF0dGFjaCggb3duZXIgKSB7XG5cdFx0b3duZXIuX2xpbmtDaGlsZCggdGhpcyApXG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFRocmVhZCBleHRlbmRzIENoaWxkIHtcblxuXHRjb25zdHJ1Y3RvciggaXRlcmF0b3IsIHN0YW5kYWxvbmUgKSB7XG5cdFx0c3VwZXIoKVxuXHRcdHRoaXMuX2RiZyA9IGdldFN0YWNrKClcblx0XHR0aGlzLl9wcm9jZXNzVGlja3MgPSA6OnRoaXMuX3Byb2Nlc3NUaWNrc1xuXHRcdHRoaXMuX3Byb2Nlc3NJdGVyYXRvciA9IDo6dGhpcy5fcHJvY2Vzc0l0ZXJhdG9yXG5cdFx0dGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcblx0XHRcdHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlXG5cdFx0XHR0aGlzLl9yZWplY3QgPSByZWplY3Rcblx0XHR9IClcblx0XHRsZXQgaXQgPSBuZXcgSXRlcmF0b3JSZWMoIHRoaXMsIG51bGwsIG51bGwgKVxuXHRcdGl0Ll9tZXRob2QgPSBudWxsXG5cdFx0dGhpcy5fc3RhY2sgPSBbIGl0LCBuZXcgSXRlcmF0b3JSZWMoIHRoaXMsIGl0ZXJhdG9yLCBpdCApIF1cblx0XHR0aGlzLl90aWNrcyA9IFtdXG5cdFx0dGhpcy5faW5kZXggPSAwXG5cdFx0dGhpcy5fY3VycmVudCA9IG51bGxcblx0XHR0aGlzLl9zdGFydGVkID0gZmFsc2Vcblx0XHR0aGlzLl9raWxsaW5nID0gbnVsbFxuXHRcdHRoaXMuX2NoaWxkcmVuID0gbnVsbFxuXHRcdHRoaXMuZ2xvYmFsID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0aWYgKCAhc3RhbmRhbG9uZSAmJiBjb0N1cnJlbnQgKVxuXHRcdFx0dGhpcy5hdHRhY2goIGNvQ3VycmVudCApXG5cdFx0cHJvY2Vzcy5uZXh0VGljayggdGhpcy5fcHJvY2Vzc0l0ZXJhdG9yIClcblx0fVxuXG5cdHdhaXRGb3JJbnB1dCgpIHtcblx0XHRpZiAoIHRoaXMuX3RpY2tzLmxlbmd0aCA+IDAgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgdW5wbGFubmVkIGJlaGF2aW91cjogdGlja3MgYWxzbyBtdXN0IGJlIGRvbmUgb24gd2FpdEZvcklucHV0LCBidXQgdGhpcyBpcyBub3QgaW1wbGVtZW50ZWRgIClcblx0XHRpZiAoICF0aGlzLl9zdGFydGVkICkge1xuXHRcdFx0dGhpcy5fcHJvY2Vzc0l0ZXJhdG9yKClcblx0XHRcdGlmICggdGhpcy5fc3RhY2subGVuZ3RoID4gMCAmJiAhdGhpcy5fa2lsbGluZyApXG5cdFx0XHRcdHRoaXMuX3N0YWNrLnB1c2goIG51bGwgKSAvLyBjb21wZW5zYXRlIGV4dHJhIF9wcm9jZXNzSXRlcmF0b3IgY2FsbC5cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdG5leHRUaWNrKCB0aWNrICkge1xuXHRcdGlmICggcHJvY2Vzcy5uZXh0VGljay5fZGJnICYmIHByb2Nlc3MubmV4dFRpY2suX2RiZygpIClcblx0XHRcdERFQlVHR0VSKClcblx0XHRpZiAoIHRoaXMuX3RpY2tzLmxlbmd0aCA9PSAwIClcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soIHRoaXMuX3Byb2Nlc3NUaWNrcyApXG5cdFx0dGhpcy5fdGlja3MucHVzaCggdGljayApXG5cdH1cblxuXHR0aGVuKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCApIHtcblx0XHRyZXR1cm4gdGhpcy5fYXR0YWNoUHJvbWlzZSggdGhpcy5fcHJvbWlzZS50aGVuKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCApIClcblx0fVxuXG5cdGNhdGNoKCBvblJlamVjdGVkICkge1xuXHRcdHJldHVybiB0aGlzLl9hdHRhY2hQcm9taXNlKCB0aGlzLl9wcm9taXNlLmNhdGNoKCBvblJlamVjdGVkICkgKVxuXHR9XG5cblx0aXNGaW5pc2hlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RhY2subGVuZ3RoID09IDBcblx0fVxuXG5cdHRocm93KCBlcnJvciApIHtcblx0XHRpZiAoIHRoaXMuX2N1cnJlbnQgKVxuXHRcdFx0dGhyb3cgZXJyb3Jcblx0XHR0aGlzLl9jaGVja0ZpbmlzaGVkKClcblx0XHRsZXQgaXQgPSB0aGlzLl9zdGFjay5wb3AoKVxuXHRcdGxldCBqdCA9IG5ldyBJdGVyYXRvclJlYyggdGhpcywgaXQuX2l0ZXJhdG9yLCBpdC5fY2FsbGVyIClcblx0XHRpdC5fdGhyZWFkID0gaXQuX2l0ZXJhdG9yID0gaXQuX2NhbGxlciA9IG51bGxcblx0XHR0aGlzLl9zdGFjay5wdXNoKCBqdCApXG5cdFx0anQuX3Rocm93KCBlcnJvciApXG5cdH1cblxuXHRmaW5pc2goIHByb2MgKSB7XG5cdFx0dHJ5IHsgdGhpcy5yZXR1cm4oIHByb2MoKSApIH0gY2F0Y2ggKCBlICkgeyB0aGlzLmtpbGwoIGUgKSB9XG5cdH1cblxuXHRyZXR1cm4oIHJlc3VsdCApIHtcblx0XHRyZXR1cm4gdGhpcy5fa2lsbGluZ0J5VXNlciggcmVzdWx0LCBmYWxzZSApXG5cdH1cblxuXHRraWxsKCByZWFzb24gKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2tpbGxpbmdCeVVzZXIoIHJlYXNvbiwgdHJ1ZSApXG5cdH1cblxuXHRraWxsQ2hpbGRyZW4oIHJlYXNvbiApIHtcblx0XHRpZiAoIHRoaXMuX2NoaWxkcmVuICkge1xuXHRcdFx0Zm9yICggbGV0IGMgb2YgdGhpcy5fY2hpbGRyZW4gKSB7XG5cdFx0XHRcdGlmICggX2RlYnVnICYmIF9kZWJ1Zy5oYXMoIGMgKSApIERFQlVHR0VSKClcblx0XHRcdFx0aWYgKCBfa2lsbGRlYnVnICYmICFjLl9raWxsaW5nICkgREVCVUdHRVIoKVxuXHRcdFx0XHRjLl9vd25lciA9IG51bGxcblx0XHRcdFx0Yy5fa2lsbCggcmVhc29uLCByZWFzb24gIT09IHVuZGVmaW5lZCApXG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGlsZHJlbi5jbGVhcigpXG5cdFx0fVxuXHR9XG5cblx0cHJvcG9nYXRlQ2hpbGRyZW5Ub093bmVyKCkge1xuXHRcdGlmICggIXRoaXMuX2NoaWxkcmVuIClcblx0XHRcdHJldHVyblxuXHRcdGlmICggdGhpcy5fb3duZXIgKVxuXHRcdFx0Zm9yICggbGV0IGMgb2YgdGhpcy5fY2hpbGRyZW4gKSB7XG5cdFx0XHRcdGMuX293bmVyID0gbnVsbFxuXHRcdFx0XHR0aGlzLl9vd25lci5fbGlua0NoaWxkKCBjIClcblx0XHRcdH1cblx0XHR0aGlzLl9jaGlsZHJlbi5jbGVhcigpXG5cdH1cblxuXHRfbGlua0NoaWxkKCBjaGlsZCApIHtcblx0XHRpZiAoIHRoaXMuX2tpbGxpbmcgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgQ1JFQVRJTkcgQ0hJTEQgV0hJTEUgS0lMTElORyBPV05FUiEhIWAgKVxuXHRcdGlmICggY2hpbGQuX293bmVyICE9IG51bGwgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgY2hpbGQgYWxyZWFkeSBsaW5rZWRgIClcblx0XHRpZiAoICF0aGlzLl9jaGlsZHJlbiApXG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IG5ldyBTZXQoKVxuXHRcdGNoaWxkLl9vd25lciA9IHRoaXNcblx0XHR0aGlzLl9jaGlsZHJlbi5hZGQoIGNoaWxkIClcblx0fVxuXG5cdF91bmxpbmtDaGlsZCggY2hpbGQgKSB7XG5cdFx0aWYgKCBjaGlsZC5fb3duZXIgIT0gdGhpcyApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBub3QgYSBjaGlsZGAgKVxuXHRcdGNoaWxkLl9vd25lciA9IG51bGxcblx0XHRpZiAoICF0aGlzLl9raWxsaW5nICYmIHRoaXMuX2NoaWxkcmVuIClcblx0XHRcdHRoaXMuX2NoaWxkcmVuLmRlbGV0ZSggY2hpbGQgKVxuXHR9XG5cblx0X3Byb2Nlc3NUaWNrcygpIHtcblx0XHRpZiAoIF9kZWJ1ZyAmJiBfZGVidWcuaGFzKCB0aGlzICkgKSBERUJVR0dFUigpXG5cdFx0bGV0IHByZXZpb3VzVGhyZWFkID0gY29DdXJyZW50XG5cdFx0bGV0IHByZXZpb3VzR2xvYmFsID0gY29HbG9iYWxcblx0XHRjb0dsb2JhbCA9IHRoaXMuZ2xvYmFsXG5cdFx0Y29DdXJyZW50ID0gdGhpc1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl9jYWxsVGlja3MoKSAvLyBtb3ZlIGxvb3AgdG8gdGhlIGZ1bmN0aW9uIHcvbyB0cnkvZmluYWxseSB0byBhbGxvdyBvcHRpbWl6YXRpb25zXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0Y29HbG9iYWwgPSBwcmV2aW91c0dsb2JhbFxuXHRcdFx0Y29DdXJyZW50ID0gcHJldmlvdXNUaHJlYWRcblx0XHRcdGlmICggdGhpcy5fdGlja3MubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0dGhpcy5fdGlja3Muc3BsaWNlKCAwLCB0aGlzLl9pbmRleCApXG5cdFx0XHRcdHByb2Nlc3MubmV4dFRpY2soIHRoaXMuX3Byb2Nlc3NUaWNrcyApXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0X2NhbGxUaWNrcygpIHtcblx0XHRpZiAoIHByb2Nlc3MubmV4dFRpY2suX2RiZyAmJiBwcm9jZXNzLm5leHRUaWNrLl9kYmcoKSApXG5cdFx0XHRERUJVR0dFUigpXG5cdFx0bGV0IHQgPSB0aGlzLl90aWNrc1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHQubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHR0aGlzLl9pbmRleCA9IGkgKyAxXG5cdFx0XHR0WyBpIF0oKVxuXHRcdFx0aWYgKCBwcm9jZXNzLm5leHRUaWNrLl9kYmcgJiYgcHJvY2Vzcy5uZXh0VGljay5fZGJnKCkgKVxuXHRcdFx0XHRERUJVR0dFUigpXG5cdFx0fVxuXHRcdHQubGVuZ3RoID0gMFxuXHR9XG5cblx0Y2FsbCggcHJvYyApIHtcblx0XHRsZXQgcHJldmlvdXNUaHJlYWQgPSBjb0N1cnJlbnRcblx0XHRsZXQgcHJldmlvdXNHbG9iYWwgPSBjb0dsb2JhbFxuXHRcdGNvR2xvYmFsID0gdGhpcy5nbG9iYWxcblx0XHRjb0N1cnJlbnQgPSB0aGlzXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBwcm9jKClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRjb0dsb2JhbCA9IHByZXZpb3VzR2xvYmFsXG5cdFx0XHRjb0N1cnJlbnQgPSBwcmV2aW91c1RocmVhZFxuXHRcdH1cblx0fVxuXG5cdHdyYXAoIHByb2MgKSB7XG5cdFx0bGV0IHNlbGYgPSB0aGlzXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY2FsbCggKCkgPT4gcHJvYy5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKSB9XG5cdH1cblxuXHRfZmluYWxpemUoIGl0ICkge1xuXHRcdGlmICggIXRoaXMuX2tpbGxpbmcgKVxuXHRcdFx0dGhpcy5fa2lsbGluZyA9IEZJTkFMSVpJTkdcblx0XHRpZiAoIGl0Ll9tZXRob2QgPT0gaXRlcmF0b3JOZXh0IClcblx0XHRcdHRoaXMuX3Jlc29sdmUoIGl0Ll92YWx1ZSApXG5cdFx0ZWxzZSAvLyBpdC5fbWV0aG9kID09IGl0ZXJhdG9yVGhyb3cgb3IgaXQuX21ldGhvZCA9PSBudWxsICggd2hlbiBraWxsaW5nIClcblx0XHRcdHRoaXMuX3JlamVjdCggaXQuX3ZhbHVlIClcblx0XHRpZiAoIHRoaXMuX293bmVyIClcblx0XHRcdHRoaXMuX293bmVyLl91bmxpbmtDaGlsZCggdGhpcyApXG5cdFx0dGhpcy5raWxsQ2hpbGRyZW4oIGl0Ll9tZXRob2QgPT0gaXRlcmF0b3JOZXh0ID8gdW5kZWZpbmVkIDogaXQuX3ZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogaXQuX3ZhbHVlIClcblx0XHQvLyBfcHJvbWlzZSBtdXN0IGJlIGxlZnQgdG8gc3RvcmUgdGhyZWFkIHJlc3VsdFxuXHRcdHRoaXMuX3Jlc29sdmUgPSBudWxsXG5cdFx0dGhpcy5fcmVqZWN0ID0gbnVsbFxuXHRcdHRoaXMuX2N1cnJlbnQgPSBudWxsXG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBudWxsXG5cdFx0dGhpcy5fb3duZXIgPSBudWxsXG5cdH1cblxuXHRfcHJvY2Vzc0l0ZXJhdG9yKCkge1xuXHRcdGlmICggX2RlYnVnICYmIF9kZWJ1Zy5oYXMoIHRoaXMgKSApIERFQlVHR0VSKClcblx0XHR0aGlzLl9zdGFydGVkID0gdHJ1ZVxuXHRcdGlmICggdGhpcy5fc3RhY2subGVuZ3RoID09IDAgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCB0aGlzLl90aWNrcy5sZW5ndGggPiAwICkge1xuXHRcdFx0Ly8gZG8gYW55IHRpY2tzIGJlZm9yZSB5aWVsZGluZ1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayggdGhpcy5fcHJvY2Vzc0l0ZXJhdG9yIClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRsZXQgaXQgPSB0aGlzLl9zdGFjay5wb3AoKVxuXHRcdGlmICggIWl0IClcblx0XHRcdHJldHVybiAvLyBnb3QgY29tcGVuc2F0ZWQgZXh0cmEgX3Byb2Nlc3NJdGVyYXRvciBjYWxsLiBzZWUgd2FpdEZvcklucHV0LlxuXHRcdGlmICggIXRoaXMuX2tpbGxpbmcgJiYgaXQuX21ldGhvZCA9PSBudWxsICkge1xuXHRcdFx0ZGVidWdnZXJcblx0XHRcdHRocm93IG5ldyBFcnJvciggYGl0Ll9tZXRob2QgY2Fubm90IGJlIG51bGxgIClcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9zdGFjay5sZW5ndGggPT0gMCApIHtcblx0XHRcdHRoaXMuX2ZpbmFsaXplKCBpdCApXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dGhpcy5fY3VycmVudCA9IGl0XG5cdFx0bGV0IG1ldGhvZCwgdmFsdWVcblx0XHRpZiAoICF0aGlzLl9raWxsaW5nICkge1xuXHRcdFx0bWV0aG9kID0gaXQuX21ldGhvZFxuXHRcdFx0dmFsdWUgPSBpdC5fdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtZXRob2QgPSBraWxsSXRlcmF0b3Jcblx0XHRcdHZhbHVlID0gdW5kZWZpbmVkXG5cdFx0fVxuXHRcdGl0Ll9tZXRob2QgPSBudWxsXG5cdFx0aXQuX3ZhbHVlID0gbnVsbFxuXHRcdGl0Ll9jdXJyZW50UHJvbWlzZSA9IG51bGxcblx0XHRsZXQgcHJldmlvdXNUaHJlYWQgPSBjb0N1cnJlbnRcblx0XHRsZXQgcHJldmlvdXNHbG9iYWwgPSBjb0dsb2JhbFxuXHRcdGNvR2xvYmFsID0gdGhpcy5nbG9iYWxcblx0XHRjb0N1cnJlbnQgPSB0aGlzXG5cdFx0bGV0IHYgPSBtZXRob2QoIGl0Ll9pdGVyYXRvciwgdmFsdWUgKVxuXHRcdGNvR2xvYmFsID0gcHJldmlvdXNHbG9iYWxcblx0XHRjb0N1cnJlbnQgPSBwcmV2aW91c1RocmVhZFxuXHRcdHRoaXMuX2N1cnJlbnQgPSBudWxsXG5cdFx0aWYgKCB0aGlzLl9raWxsaW5nICkge1xuXHRcdFx0aWYgKCB2LmRvbmUgJiYgdi5pdGVyYXRvckZhaWxlZCAmJiB2LnZhbHVlICE9IHRoaXMuX2tpbGxpbmcgKVxuXHRcdFx0XHRyZXRocm93KCB2LnZhbHVlIClcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soIHRoaXMuX3Byb2Nlc3NJdGVyYXRvciApXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0aWYgKCB2LmRvbmUgKSB7XG5cdFx0XHRpdC5fY2FsbGVyLl9zdG9yZSggdi52YWx1ZSwgdi5pdGVyYXRvckZhaWxlZCApXG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKCB0aGlzLl9wcm9jZXNzSXRlcmF0b3IgKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHRoaXMuX3N0YWNrLnB1c2goIGl0IClcblx0XHRpZiAoIHYudmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdGlmICggdHlwZW9mIHYudmFsdWUudGhlbiA9PSBgZnVuY3Rpb25gICkge1xuXHRcdFx0XHRsZXQgcCA9IHYudmFsdWUudGhlbiggaXQuX25leHQsIGl0Ll90aHJvdyApXG5cdFx0XHRcdGlmICggcCAmJiB0eXBlb2YgcC5raWxsID09IGBmdW5jdGlvbmAgKVxuXHRcdFx0XHRcdGl0Ll9jdXJyZW50UHJvbWlzZSA9IHBcblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiB2LnZhbHVlLmtpbGwgPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRcdFx0aXQuX2N1cnJlbnRQcm9taXNlID0gdi52YWx1ZVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHYudmFsdWUubmV4dCA9PSBgZnVuY3Rpb25gICkge1xuXHRcdFx0XHR0aGlzLl9zdGFjay5wdXNoKCBuZXcgSXRlcmF0b3JSZWMoIHRoaXMsIHYudmFsdWUsIGl0ICkgKVxuXHRcdFx0XHRwcm9jZXNzLm5leHRUaWNrKCB0aGlzLl9wcm9jZXNzSXRlcmF0b3IgKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHYudmFsdWUgPT0gYG9iamVjdGAgKSB7XG5cdFx0XHRcdGlmICggYG9uZXJyb3JgIGluIHYudmFsdWUgJiYgIXYudmFsdWUub25lcnJvciApIHtcblx0XHRcdFx0XHRpZiAoIGBvbmxvYWRgIGluIHYudmFsdWUgJiYgIXYudmFsdWUub25sb2FkICkge1xuXHRcdFx0XHRcdFx0di52YWx1ZS5vbmxvYWQgPSBpdDo6X29ubG9hZFxuXHRcdFx0XHRcdFx0di52YWx1ZS5vbmVycm9yID0gaXQ6Ol9vbmVycm9yXG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBgb25zdWNjZXNzYCBpbiB2LnZhbHVlICYmICF2LnZhbHVlLm9uc3VjY2VzcyApIHtcblx0XHRcdFx0XHRcdHYudmFsdWUub25zdWNjZXNzID0gaXQ6Ol9vbnN1Y2Nlc3Ncblx0XHRcdFx0XHRcdHYudmFsdWUub25lcnJvciA9IGl0Ojpfb25lcnJvclxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBUT0RPOiB0aHJvdyBhIHR5cGUgZXJyb3IgaGVyZVxuXHRcdH1cblx0XHRpdC5fbmV4dCggdW5kZWZpbmVkIClcblx0fVxuXG5cdF9hdHRhY2hQcm9taXNlKCBwcm9taXNlICkge1xuXHRcdHByb21pc2Uua2lsbCA9IDo6dGhpcy5fa2lsbFxuXHRcdHJldHVybiBwcm9taXNlXG5cdH1cblxuXHRfa2lsbGluZ0J5VXNlciggcmVhc29uLCBpc0Vycm9yICkge1xuXHRcdHRoaXMuX2tpbGwoIHJlYXNvbiwgaXNFcnJvciApXG5cdFx0aWYgKCB0aGlzLl9jdXJyZW50IClcblx0XHRcdHRocm93IHRoaXMuX2tpbGxpbmdcblx0XHRyZXR1cm4gdGhpcy50aGVuKCBub29wLCBub29wIClcblx0fVxuXG5cdF9raWxsKCByZWFzb24sIGlzRXJyb3IgKSB7XG5cdFx0aWYgKCBfZGVidWcgJiYgX2RlYnVnLmhhcyggdGhpcyApICkgREVCVUdHRVIoKVxuXHRcdGlmICggIXRoaXMuX2tpbGxpbmcgKSB7XG5cdFx0XHRpZiAoIF9raWxsZGVidWcgKSBERUJVR0dFUigpXG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKCB0aGlzLl9wcm9jZXNzSXRlcmF0b3IgKVxuXHRcdFx0dGhpcy5fa2lsbGluZyA9IG5ldyBFS2lsbCggcmVhc29uIClcblx0XHRcdGlmICggdGhpcy5fb3duZXIgKVxuXHRcdFx0XHR0aGlzLl9vd25lci5fdW5saW5rQ2hpbGQoIHRoaXMgKVxuXHRcdFx0dGhpcy5raWxsQ2hpbGRyZW4oICFpc0Vycm9yID8gdW5kZWZpbmVkIDogcmVhc29uID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVhc29uIClcblx0XHRcdGlmICggdGhpcy5fc3RhY2subGVuZ3RoID4gMCApXG5cdFx0XHRcdHRoaXMuX3N0YWNrWyAwIF0uX3N0b3JlKCByZWFzb24sIGlzRXJyb3IgKVxuXHRcdH1cblx0fVxuXG5cdF9jaGVja0ZpbmlzaGVkKCkge1xuXHRcdGlmICggdGhpcy5pc0ZpbmlzaGVkKCkgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgdGhyZWFkIGlzIGFscmVhZHkgZmluaXNoZWRgIClcblx0fVxuXG59XG5cbmxldCBwVFJVRSA9IFByb21pc2UucmVzb2x2ZSggdHJ1ZSApXG5sZXQgcEZBTFNFID0gUHJvbWlzZS5yZXNvbHZlKCBmYWxzZSApXG5sZXQgcFVOREVGSU5FRCA9IFByb21pc2UucmVzb2x2ZSgpXG5sZXQgcERPTkUgPSBQcm9taXNlLnJlc29sdmUoIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG51bGwgfSApXG5sZXQgcE5FVkVSID0geyB0aGVuOiBfID0+IHt9IH1cblxubGV0IHlpZWxkYWJsZSA9IHZhbHVlID0+IHZhbHVlICYmICggdHlwZW9mIHZhbHVlLnRoZW4gPT0gYGZ1bmN0aW9uYCB8fCB0eXBlb2YgdmFsdWUubmV4dCA9PSBgZnVuY3Rpb25gIClcbmxldCBwcm9taXNpZnkgPSB2YWx1ZSA9PiB5aWVsZGFibGUoIHZhbHVlICkgPyB2YWx1ZSA6IFByb21pc2UucmVzb2x2ZSggdmFsdWUgKVxubGV0IEFORCA9IGRhdGEgPT4gZGF0YS5ldmVyeSggQm9vbGVhbiApXG5cbmZ1bmN0aW9uIHNlbmRSZXR1cm4oKSB7XG5cdHRoaXMgJiYgcHJvY2Vzcy5uZXh0VGljayggKCkgPT4gdGhpcy5yZXR1cm4oKSApXG59XG5cbmZ1bmN0aW9uIHRocm93VGltZW91dCgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCBgdGltZW91dGAgKVxufVxuXG4vKlxuU3RyZWFtIGhhcyBtdWx0aXBsZSBBUElzLlxuUGlwZSBoYXMgb25seSBvbmUgc2ltcGxlIEFQSS5cbnBpcGUubmV4dCgpIHJldHVybnMgUHJvbWlzZSB3aGljaCBldmFsdWF0ZXMgdG8gaXRlcmF0b3IubmV4dC1saWtlIG9iamVjdCAtIHsgQm9vbGVhbiBkb25lLCBPYmplY3QgdmFsdWUgfVxucGlwZS5wdXNoKCB2YWx1ZSApIHJldHVybnMgUHJvbWlzZSB3aGljaCBldmFsdWF0ZXMgdG8gQm9vbGVhbi4gRmFsc2UgaXMgcmV0dXJuZWQgaWYgYSBwaXBlIGlzIGNsb3NlZC5cbnBpcGUucmVhZCgpIHJldHVybnMgUHJvbWlzZS4gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHBpcGUucmVhZCgpIHRlcm1pbmF0ZXMgY2FsbGluZyB0aHJlYWQuIE9uZSBtdXN0IGRvIGZpbmFsaXplIGFjdGlvbnMgaW4gY28uZGVmZXIgb3IgdHJ5L2ZpbmFsbHkuXG5waXBlLndyaXRlKCB2YWx1ZSApIHJldHVybnMgUHJvbWlzZSB3aGljaCBldmFsdWF0ZXMgd2hlbiBkYXRhIGlzIGFjdHVhbGx5IHdyaXR0ZW4uIElmIHBpcGUgaXMgZW5kZWQgdGhlbiBwaXBlLndyaXRlIHRlcm1pbmF0ZXMgdGhyZWFkLiBPbmUgbXVzdCBkbyBmaW5hbGl6ZSBhY3Rpb25zIGluIGNvLmRlZmVyIG9yIHRyeS9maW5hbGx5LlxuKi9cblxuY2xhc3MgRW5kIHtcblxuXHRjb25zdHJ1Y3RvciggcGlwZSApIHtcblx0XHR0aGlzLl9waXBlID0gcGlwZVxuXHR9XG5cblx0Y2xvc2UoKSB7XG5cdFx0aWYgKCB0aGlzLl9waXBlICkge1xuXHRcdFx0dGhpcy5fcGlwZS5jbG9zZSgpXG5cdFx0XHR0aGlzLl9waXBlID0gbnVsbFxuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBQaXBlRGF0YSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fZGF0YSA9IFtdXG5cdFx0dGhpcy5fcmVhZGVycyA9IFtdXG5cdH1cblxuXHRjbG9zZSgpIHtcblx0XHRpZiAoIHRoaXMuX2RhdGEgKSB7XG5cdFx0XHRmb3IgKCBsZXQgeyByZWplY3QgfSBvZiB0aGlzLl9kYXRhICkgcmVqZWN0KClcblx0XHRcdHRoaXMuX2RhdGEgPSBudWxsXG5cdFx0fVxuXHRcdGlmICggdGhpcy5fcmVhZGVycyApIHtcblx0XHRcdGZvciAoIGxldCB7IHJlamVjdCB9IG9mIHRoaXMuX3JlYWRlcnMgKSByZWplY3QoKVxuXHRcdFx0dGhpcy5fcmVhZGVycyA9IG51bGxcblx0XHR9XG5cdH1cbn1cblxuaW1wb3J0ICogYXMgc3RyZWFtIGZyb20gXCJzdHJlYW1cIlxuXG5jbGFzcyBSZWFkYWJsZSBleHRlbmRzIEVuZCB7XG5cblx0bmV4dCgpIHtcblx0XHRpZiAoICF0aGlzLl9waXBlIHx8ICF0aGlzLl9waXBlLl9kYXRhIClcblx0XHRcdHJldHVybiBwRE9ORVxuXHRcdGlmICggdGhpcy5fcGlwZS5fZGF0YS5sZW5ndGggKSB7XG5cdFx0XHRsZXQgY2VsbCA9IHRoaXMuX3BpcGUuX2RhdGEuc2hpZnQoKVxuXHRcdFx0Y2VsbC5yZXNvbHZlKClcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBjZWxsLmRhdGEgfSApXG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB0aGlzLl9waXBlLl9yZWFkZXJzLnB1c2goIHsgcmVzb2x2ZTogdmFsdWUgPT4gcmVzb2x2ZSggeyBkb25lOiBmYWxzZSwgdmFsdWUgfSApLCByZWplY3Q6ICgpID0+IHJlc29sdmUoIERPTkUgKSB9ICkgKVxuXHR9XG5cblx0cmVhZCggdGhyZWFkID0gY29DdXJyZW50ICkge1xuXHRcdGlmICggIXRoaXMuX3BpcGUgfHwgIXRoaXMuX3BpcGUuX2RhdGEgKSB7XG5cdFx0XHR0aHJlYWQ6OnNlbmRSZXR1cm4oKVxuXHRcdFx0cmV0dXJuIHBORVZFUlxuXHRcdH1cblx0XHRpZiAoIHRoaXMuX3BpcGUuX2RhdGEubGVuZ3RoICkge1xuXHRcdFx0bGV0IGNlbGwgPSB0aGlzLl9waXBlLl9kYXRhLnNoaWZ0KClcblx0XHRcdGNlbGwucmVzb2x2ZSgpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBjZWxsLmRhdGEgKVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoIHJlc29sdmUgPT4gdGhpcy5fcGlwZS5fcmVhZGVycy5wdXNoKCB7IHJlc29sdmUsIHJlamVjdDogdGhyZWFkOjpzZW5kUmV0dXJuIH0gKSApXG5cdH1cblxuXHRwaXBlKCAuLi5kZXN0aW5hdGlvbnMgKSB7XG5cdFx0aWYgKCAhZGVzdGluYXRpb25zLmxlbmd0aCApXG5cdFx0XHRyZXR1cm4gdGhpcy5jbG9zZSgpXG5cdFx0Z28oIHRoaXM6OmZ1bmN0aW9uKiAoKSB7XG5cdFx0XHRkZWZlciggKCkgPT4gdGhpcy5jbG9zZSgpIClcblx0XHRcdGZvciAoIGxldCBkZXN0IG9mIGRlc3RpbmF0aW9ucyApXG5cdFx0XHRcdGRlZmVyKCAoKSA9PiBkZXN0LmNsb3NlKCkgKVxuXHRcdFx0aWYgKCBkZXN0aW5hdGlvbnMubGVuZ3RoID09IDEgKSB7XG5cdFx0XHRcdGxldCBkZXN0ID0gZGVzdGluYXRpb25zWyAwIF1cblx0XHRcdFx0Zm9yICg7Oykge1xuXHRcdFx0XHRcdHlpZWxkIGRlc3Qud3JpdGUoIHlpZWxkIHRoaXMucmVhZCgpIClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZvciAoOzspIHtcblx0XHRcdFx0XHRsZXQgdmFsdWUgPSB5aWVsZCB0aGlzLnJlYWQoKVxuXHRcdFx0XHRcdGZvciAoIGxldCBwcm9taXNlIG9mIGRlc3RpbmF0aW9ucy5tYXAoIGRlc3QgPT4gZGVzdC53cml0ZSggdmFsdWUgKSApIClcblx0XHRcdFx0XHRcdHlpZWxkIHByb21pc2Vcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKS5kZXRhY2goKVxuXHR9XG5cblx0dHJhbnNmb3JtKCBmdW4gKSB7XG5cdFx0bGV0IHJldCA9IG5ldyBQaXBlXG5cdFx0bGV0IHNyZWFkID0gdGhpc1xuXHRcdGxldCBzd3JpdGUgPSByZXQuaW5cblx0XHRnbyggZnVuY3Rpb24qICgpIHtcblx0XHRcdGRlZmVyKCAoKSA9PiByZXQuY2xvc2UoKSApXG5cdFx0XHR5aWVsZCBmdW4oIHNyZWFkLCBzd3JpdGUgKVxuXHRcdH0gKS5kZXRhY2goKVxuXHRcdHJldHVybiByZXQub3V0XG5cdH1cblxuXHRtYXAoIGZ1biApIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0oIGZ1bmN0aW9uKiAoIHNpbiwgc291dCApIHtcblx0XHRcdGZvciAoOzspIHtcblx0XHRcdFx0bGV0IHZhbHVlID0geWllbGQgc2luLnJlYWQoKVxuXHRcdFx0XHR5aWVsZCBzb3V0LndyaXRlKCB5aWVsZCBwcm9taXNpZnkoIGZ1biggdmFsdWUgKSApIClcblx0XHRcdH1cblx0XHR9IClcblx0fVxuXG5cdGZpbHRlciggZnVuICkge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybSggZnVuY3Rpb24qICggc2luLCBzb3V0ICkge1xuXHRcdFx0Zm9yICg7Oykge1xuXHRcdFx0XHRsZXQgdmFsdWUgPSB5aWVsZCBzaW4ucmVhZCgpXG5cdFx0XHRcdGlmICggeWllbGQgcHJvbWlzaWZ5KCBmdW4oIHZhbHVlICkgKSApXG5cdFx0XHRcdFx0eWllbGQgc291dC53cml0ZSggdmFsdWUgKVxuXHRcdFx0fVxuXHRcdH0gKVxuXHR9XG5cblx0Y3JlYXRlU3RyZWFtKCBvcHRpb25zICkge1xuXHRcdGxldCByZXQgPSBuZXcgc3RyZWFtLlJlYWRhYmxlKCBPYmplY3QuYXNzaWduKCB7IG9iamVjdE1vZGU6IHRydWUgfSwgb3B0aW9ucyApIClcblx0XHRsZXQgcmVhZCA9IHJldC5fcmVhZCA9ICgpID0+IHRoaXMubmV4dCgpLnRoZW4oICggeyBkb25lLCB2YWx1ZSB9ICkgPT4ge1xuXHRcdFx0aWYgKCBkb25lIClcblx0XHRcdFx0cmV0LnB1c2goIG51bGwgKVxuXHRcdFx0ZWxzZSBpZiAoIHJldC5wdXNoKCB2YWx1ZSApIClcblx0XHRcdFx0cmVhZCgpXG5cdFx0fSApXG5cdFx0cmV0dXJuIHJldFxuXHR9XG59XG5cbmNsYXNzIFdyaXRhYmxlIGV4dGVuZHMgRW5kIHtcblxuXHRwdXNoKCBkYXRhICkge1xuXHRcdGlmICggIXRoaXMuX3BpcGUgfHwgIXRoaXMuX3BpcGUuX3JlYWRlcnMgKVxuXHRcdFx0cmV0dXJuIHBGQUxTRVxuXHRcdGlmICggdGhpcy5fcGlwZS5fcmVhZGVycy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9waXBlLl9yZWFkZXJzLnNoaWZ0KCkucmVzb2x2ZSggZGF0YSApXG5cdFx0XHRyZXR1cm4gcFRSVUVcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKCByZXNvbHZlID0+IHRoaXMuX3BpcGUuX2RhdGEucHVzaCggeyByZXNvbHZlOiAoKSA9PiByZXNvbHZlKCB0cnVlICksIHJlamVjdDogKCkgPT4gcmVzb2x2ZSggZmFsc2UgKSwgZGF0YSB9ICkgKVxuXHR9XG5cblx0d3JpdGUoIGRhdGEsIHRocmVhZCA9IGNvQ3VycmVudCApIHtcblx0XHRpZiAoICF0aGlzLl9waXBlIHx8ICF0aGlzLl9waXBlLl9yZWFkZXJzICkge1xuXHRcdFx0dGhyZWFkOjpzZW5kUmV0dXJuKClcblx0XHRcdHJldHVybiBwTkVWRVJcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9waXBlLl9yZWFkZXJzLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX3BpcGUuX3JlYWRlcnMuc2hpZnQoKS5yZXNvbHZlKCBkYXRhIClcblx0XHRcdHJldHVybiBwVU5ERUZJTkVEXG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB0aGlzLl9waXBlLl9kYXRhLnB1c2goIHsgcmVzb2x2ZSwgcmVqZWN0OiB0aHJlYWQ6OnNlbmRSZXR1cm4sIGRhdGEgfSApIClcblx0fVxuXG5cdGNyZWF0ZVN0cmVhbSggb3B0aW9ucyApIHtcblx0XHRsZXQgcmV0ID0gbmV3IHN0cmVhbS5Xcml0YWJsZSggT2JqZWN0LmFzc2lnbiggeyBvYmplY3RNb2RlOiB0cnVlIH0sIG9wdGlvbnMgKSApXG5cdFx0cmV0Ll93cml0ZSA9ICggY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayApID0+IHRoaXMucHVzaCggY2h1bmsgKS50aGVuKCB3cml0dGVuID0+IHtcblx0XHRcdGNhbGxiYWNrKClcblx0XHRcdGlmICggIXdyaXR0ZW4gKVxuXHRcdFx0XHRyZXQuZW5kKClcblx0XHR9IClcblx0XHRyZXQub24oIGBlbmRgLCAoKSA9PiB0aGlzLmNsb3NlIClcblx0XHRyZXQub24oIGBmaW5pc2hgLCAoKSA9PiB0aGlzLmNsb3NlIClcblx0XHRyZXR1cm4gcmV0XG5cdH1cbn1cblxuLy8gbGV0IHN0YXRpY3MgPSBDbGFzcyA9PiB7XG5cdC8vIGxldCBzdGF0aWNzID0gQ2xhc3MucHJvdG90eXBlLl9zdGF0aWNzXG5cdC8vIGlmICggc3RhdGljcyApIGZvciAoIGxldCBuYW1lIG9mIHN0YXRpY3MgKVxuXHQvLyBcdENsYXNzWyBuYW1lIF0gPSAoIC4uLmFyZ3MgKSA9PiAoIG5ldyBDbGFzcyApWyBuYW1lIF0oIC4uLmFyZ3MgKVxuLy8gfVxuXG4vLyBsZXQgc3RhdGljX3ZlcnNpb24gPSAoIHByb3RvLCBuYW1lLCBkZXNjICkgPT4ge1xuLy8gXHRsZXQgc3RhdGljcyA9IHByb3RvLl9zdGF0aWNzIHx8ICggcHJvdG8uX3N0YXRpY3MgPSBbXSApXG4vLyBcdHN0YXRpY3MucHVzaCggbmFtZSApXG4vLyB9XG5cbi8vIEBzdGF0aWNzXG5leHBvcnQgY2xhc3MgUGlwZSBleHRlbmRzIENoaWxkIHtcblxuXHRjb25zdHJ1Y3Rvciggd3JpdGFibGUsIHJlYWRhYmxlICkge1xuXHRcdHN1cGVyKClcblx0XHRpZiAoIHJlYWRhYmxlICYmIHdyaXRhYmxlICkge1xuXHRcdFx0dGhpcy5fZGF0YSA9IG51bGxcblx0XHRcdHRoaXMuaW4gPSB3cml0YWJsZVxuXHRcdFx0dGhpcy5vdXQgPSByZWFkYWJsZVxuXHRcdH1cblx0XHRlbHNlIGlmICggIXJlYWRhYmxlICYmICF3cml0YWJsZSApIHtcblx0XHRcdHRoaXMuX2RhdGEgPSBuZXcgUGlwZURhdGFcblx0XHRcdHRoaXMuaW4gPSBuZXcgV3JpdGFibGUoIHRoaXMuX2RhdGEgKVxuXHRcdFx0dGhpcy5vdXQgPSBuZXcgUmVhZGFibGUoIHRoaXMuX2RhdGEgKVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBQaXBlOiB3cm9uZyBwYXJhbWV0ZXJzYCApXG5cdFx0dGhpcy5jbG9zZSA9IDo6dGhpcy5fa2lsbFxuXHRcdGlmICggY29DdXJyZW50IClcblx0XHRcdHRoaXMuYXR0YWNoKCBjb0N1cnJlbnQgKVxuXHR9XG5cblx0X2tpbGwoKSB7XG5cdFx0c3VwZXIuX2tpbGwoKVxuXHRcdGlmICggdGhpcy5fZGF0YSApIHtcblx0XHRcdHRoaXMuX2RhdGEuY2xvc2UoKVxuXHRcdFx0dGhpcy5fZGF0YSA9IG51bGxcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmluICkge1xuXHRcdFx0dGhpcy5pbi5jbG9zZSgpXG5cdFx0XHR0aGlzLmluID0gbnVsbFxuXHRcdH1cblx0XHRpZiAoIHRoaXMub3V0ICkge1xuXHRcdFx0dGhpcy5vdXQuY2xvc2UoKVxuXHRcdFx0dGhpcy5vdXQgPSBudWxsXG5cdFx0fVxuXHR9XG5cblx0bWFrZUZ1bmMoIC4uLmFyZ3MgKSB7XG5cdFx0cmV0dXJuIFBpcGUubWFrZUZ1bmMoIHRoaXMuaW4sIHRoaXMub3V0LCAuLi5hcmdzIClcblx0fVxuXG5cdHN0YXRpYyBtYWtlRnVuYyggc3BhcmFtLCBzcmVzdWx0LCB0aW1lb3V0ID0gbnVsbCwgdGltZW91dFByb2MgPSB0aHJvd1RpbWVvdXQgKSB7XG5cdFx0cmV0dXJuIHZhbHVlID0+IHtcblx0XHRcdGxldCByZXQgPSBzcGFyYW0ud3JpdGUoIHZhbHVlICkudGhlbiggd3JhcCggKCkgPT4gc3Jlc3VsdC5yZWFkKCkgKSApXG5cdFx0XHRpZiAoIHRpbWVvdXQgKVxuXHRcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdFx0XHRcdGxldCB0ID0gc2V0VGltZW91dCggKCkgPT4geyB0cnkgeyByZXNvbHZlKCB0aW1lb3V0UHJvYygpICkgfSBjYXRjaCAoIGUgKSB7IHJlamVjdCggZSApIH0gfSwgdGltZW91dCApXG5cdFx0XHRcdFx0YWZ0ZXIoIHJldCwgKCkgPT4gY2xlYXJUaW1lb3V0KCB0ICkgKVxuXHRcdFx0XHRcdHJldC50aGVuKCByZXNvbHZlLCByZWplY3QgKVxuXHRcdFx0XHR9IClcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIHJldFxuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBjcmVhdGUoKSB7XG5cdFx0bGV0IHBpcGUgPSBuZXcgUGlwZVxuXHRcdGxldCBzdHJlYW0gPSB0aGlzXG5cdFx0c3RyZWFtLnBpcGUoIHBpcGUuaW4uY3JlYXRlU3RyZWFtKCkgKVxuXHRcdHJldHVybiBwaXBlLm91dFxuXHR9XG5cblx0ZnJvbVN0cmVhbSggc3RyZWFtICkge1xuXHRcdHN0cmVhbS5waXBlKCB0aGlzLmluLmNyZWF0ZVN0cmVhbSgpIClcblx0XHRyZXR1cm4gdGhpcy5vdXRcblx0fVxuXG5cdHN0YXRpYyBmcm9tU3RyZWFtKCBzdHJlYW0gKSB7XG5cdFx0cmV0dXJuICggbmV3IFBpcGUgKS5mcm9tU3RyZWFtKCBzdHJlYW0gKVxuXHR9XG5cblx0dG9TdHJlYW0oIGRlc3QsIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vdXQuY3JlYXRlU3RyZWFtKCBvcHRpb25zICkucGlwZSggZGVzdCApXG5cdFx0cmV0dXJuIHRoaXMuaW5cblx0fVxuXG5cdHN0YXRpYyB0b1N0cmVhbSggZGVzdCwgb3B0aW9ucyApIHtcblx0XHRyZXR1cm4gKCBuZXcgUGlwZSApLnRvU3RyZWFtKCBkZXN0LCBvcHRpb25zIClcblx0fVxuXG5cdHBpcGUoIC4uLmRlc3RpbmF0aW9ucyApIHtcblx0XHR0aGlzLm91dC5waXBlKCAuLi5kZXN0aW5hdGlvbnMgKVxuXHRcdHJldHVybiB0aGlzLmluXG5cdH1cblxuXHRzdGF0aWMgcGlwZSggLi4uZGVzdGluYXRpb25zICkge1xuXHRcdHJldHVybiAoIG5ldyBQaXBlICkucGlwZSggLi4uZGVzdGluYXRpb25zIClcblx0fVxuXG5cdHRyYW5zZm9ybSggZnVuICkge1xuXHRcdHJldHVybiBuZXcgUGlwZSggdGhpcy5pbiwgdGhpcy5vdXQudHJhbnNmb3JtKCBmdW4gKSApXG5cdH1cblxuXHRzdGF0aWMgdHJhbnNmb3JtKCBmdW4gKSB7XG5cdFx0cmV0dXJuICggbmV3IFBpcGUgKS50cmFuc2Zvcm0oIGZ1biApXG5cdH1cblxuXHRtYXAoIGZ1biApIHtcblx0XHRyZXR1cm4gbmV3IFBpcGUoIHRoaXMuaW4sIHRoaXMub3V0Lm1hcCggZnVuICkgKVxuXHR9XG5cblx0c3RhdGljIG1hcCggZnVuICkge1xuXHRcdHJldHVybiAoIG5ldyBQaXBlICkubWFwKCBmdW4gKVxuXHR9XG5cblx0ZmlsdGVyKCBmdW4gKSB7XG5cdFx0cmV0dXJuIG5ldyBQaXBlKCB0aGlzLmluLCB0aGlzLm91dC5maWx0ZXIoIGZ1biApIClcblx0fVxuXG5cdHN0YXRpYyBmaWx0ZXIoIGZ1biApIHtcblx0XHRyZXR1cm4gKCBuZXcgUGlwZSApLmZpbHRlciggZnVuIClcblx0fVxufVxuXG5QaXBlLk5VTEwgPSBuZXcgUGlwZVxuUGlwZS5OVUxMLmNsb3NlKClcblxubGV0IGFmdGVyID0gKCBwcm9taXNlLCBwcm9jICkgPT4ge1xuXHRsZXQgbm9SZXN1bHROb0FyZ3MgPSAoKSA9PiBwcm9jICYmIHByb2MoKSAmJiB1bmRlZmluZWRcblx0cmV0dXJuIHByb21pc2UudGhlbiggbm9SZXN1bHROb0FyZ3MsIG5vUmVzdWx0Tm9BcmdzIClcbn1cblxuZXhwb3J0IGNvbnN0IHN5bmNocm9uaXplZCA9IGZ1bmMgPT4ge1xuXHRsZXQgbG9jayA9IHBVTkRFRklORURcblx0cmV0dXJuIHZhbHVlID0+IHtcblx0XHRsZXQgb25yZWFkeSA9IGxvY2tcblx0XHRsZXQgcmV0ID0gZ28oIGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHR5aWVsZCBvbnJlYWR5XG5cdFx0XHRyZXR1cm4geWllbGQgZnVuYyggdmFsdWUgKVxuXHRcdH0gKVxuXHRcdGxvY2sgPSBhZnRlciggcmV0IClcblx0XHRyZXR1cm4gcmV0XG5cdH1cbn1cbiIsImltcG9ydCAqIGFzIERpZmYgZnJvbSBcImRpZmZcIlxuXG5leHBvcnQgY29uc3QgU2V0U3RhdGUgPSB7XG5cdGRiOiAoIG9wdGlvbnMsIGRiLCBpZCwgc3RhdGUgKSA9PiAoIHsgY29udGVudDogeyBbIGlkIF06IHtcblx0XHRfX3ByZXNlbnRfXzogdHJ1ZSxcblx0XHRbIGAkeyAoIG9wdGlvbnMgfHwgMCApLm1vZGUgfHwgYGAgfXN0YXRlYCBdOiBzdGF0ZSxcblx0XHRlcnJvcm5lb3VzOiBudWxsLFxuXHR9IH0gfSApLFxuXHRjbWQ6ICggZGIsIGlkLCBzdGF0ZSApID0+IHt9LFxufVxuIiwiaW1wb3J0ICogYXMgY28gZnJvbSBcImNvXCJcbmltcG9ydCByYSBmcm9tIFwicmFcIlxuaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gXCJsb2Rhc2hcIlxuaW1wb3J0ICogYXMgTG9nIGZyb20gXCJsb2dcIlxubGV0IGxvZyA9IExvZy5vcGVuKCBgdWlgIClcblxuZnVuY3Rpb24gdG9Ob2RlKCBjaGlsZCwgbm9kZSApIHtcblx0cmVzdGFydDogZm9yICg7Oykge1xuXHRcdGNoaWxkID0gY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnZhbHVlT2YgPT0gYGZ1bmN0aW9uYCA/IGNoaWxkLnZhbHVlT2YoKSA6IGNoaWxkXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBjaGlsZCApICkge1xuXHRcdFx0aWYgKCBjaGlsZC5sZW5ndGggPT0gMCApXG5cdFx0XHRcdHJldHVybiBudWxsXG5cdFx0XHRpZiAoIGNoaWxkLmxlbmd0aCA9PSAxICkge1xuXHRcdFx0XHRjaGlsZCA9IGNoaWxkWyAwIF1cblx0XHRcdFx0Y29udGludWUgcmVzdGFydFxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhbm9kZSApXG5cdFx0XHRcdG5vZGUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGNoaWxkLmZvckVhY2goIGNoaWxkID0+IHRvTm9kZSggY2hpbGQsIG5vZGUgKSApXG5cdFx0XHRjaGlsZCA9IG5vZGVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjaGlsZCA9PSBgc3RyaW5nYCApXG5cdFx0XHRcdGNoaWxkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIGNoaWxkIClcblx0XHRcdGlmICggbm9kZSApIHtcblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZCggY2hpbGQgKVxuXHRcdFx0XHRjaGlsZCA9IG5vZGVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNoaWxkXG5cdH1cbn1cblxubGV0IHJlcXVlc3RSZWZsb3cgPSB0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT0gYGZ1bmN0aW9uYCA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblxubGV0IHJlcXVlc3REb2N1bWVudFRvdWNoID0gZG8ge1xuXHQvLyB3b3JrYXJvdW5kIG9mIHdlYmxpdC9ibGluayBidWc6IHNvbWV0aW1lcyBkb2N1bWVudCBkb2VzIG5vdCB1cGRhdGUgaXRzIHN0YXRlIGFmdGVyIGNsYXNzTmFtZSBvZiBzb21lIGVsZW1lbnQgaXMgY2hhbmdlZFxuXHRsZXQgdGltZW91dFxuXHRsZXQgdG91Y2hEb2N1bWVudCA9ICgpID0+IHtcblx0XHR0aW1lb3V0ID0gbnVsbFxuXHRcdC8vIHRyeWluZyB0byBmb3JjZSByZWZsb3dcblx0XHRsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYGRpdmAgKVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IGBmaXhlZGBcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBkaXYuc3R5bGUuYm90dG9tID0gYDFweGBcblx0XHRkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gYDFweGBcblx0XHQvLyBUT0RPOiBBVFRFTlRJT046IGNoZWNrIHRoYXQgYWxwaGEtY2hhbm5lbCBkbyBub3QgZnJlZXplIGFuaW1hdGlvbnMgb24gcGFnZVxuXHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgcmdiYSggMCwgMCwgMCwgMC4wMSApYFxuXHRcdGRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gYG5vbmVgXG5cdFx0ZGl2LnN0eWxlLnpJbmRleCA9IDFlOTlcblx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBkaXYgKVxuXHRcdHNldFRpbWVvdXQoICgpID0+IGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIGRpdiApLCAxMDAgKSAvLyAxMDBtcyBzZWVtcyB0byBiZSBlbm91Z2guIGlmIGl0IGlzIGVxdWFsIHRvIDEgdGhhbiBubyBlZmZlY3QgaXMgcHJlc2VudC5cblx0fVxuXHQ7KCkgPT4gdGltZW91dCB8fCAoIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCB0b3VjaERvY3VtZW50ICkgKVxuXHQvLyA7KCkgPT4gdGltZW91dCB8fCAoIGxhdGVyKCB0b3VjaERvY3VtZW50ICksIHRpbWVvdXQgPSB0cnVlIClcbn1cblxubGV0IHdhaXRVbnRpbFJlZmxvdyA9IGRvIHtcblx0bGV0IGZyYW1lXG5cdGxldCByZWZsb3cgPSByZXNvbHZlID0+IHJlcXVlc3RSZWZsb3coICgpID0+IHtcblx0XHRmcmFtZSA9IG51bGxcblx0XHRyZXF1ZXN0RG9jdW1lbnRUb3VjaCgpXG5cdFx0cmVzb2x2ZSgpXG5cdH0gKVxuXHQ7KCkgPT4gZnJhbWUgfHwgKCBmcmFtZSA9IG5ldyBQcm9taXNlKCByZWZsb3cgKSApXG59XG5cbmZ1bmN0aW9uIGZjYWxjKCBmLCBjYiApIHtcblx0aWYgKCB0eXBlb2YgZiAhPSBgZnVuY3Rpb25gIClcblx0XHRjYiggZiApXG5cdGVsc2Uge1xuXHRcdGxldCBmaXJzdCA9IHRydWVcblx0XHRyYSggZnVuY3Rpb24qICgpIHtcblx0XHRcdGlmICggZmlyc3QgKSB7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2Vcblx0XHRcdFx0cmVxdWVzdERvY3VtZW50VG91Y2goKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR5aWVsZCB3YWl0VW50aWxSZWZsb3coKVxuXHRcdFx0bGV0IHJldCA9IGYoKVxuXHRcdFx0aWYgKCByZXQgJiYgcmV0Lm5leHQgJiYgcmV0LnRocm93IClcblx0XHRcdFx0cmV0ID0geWllbGQgcmV0XG5cdFx0XHRjYiggcmV0IClcblx0XHR9IClcblx0fVxufVxuXG5mdW5jdGlvbiBzZXRDb250ZW50KCBjb250cm9sLCBjb250ZW50LCBjYiA9IG51bGwgKSB7IGZjYWxjKCBjb250ZW50LCBjb250ZW50ID0+IHtcblx0bGV0IGMgPSB0b05vZGUoIGNvbnRlbnQgKVxuXHRpZiAoIGMgKSB7XG5cdFx0Y29udHJvbC5pbm5lckhUTUwgPSBgYFxuXHRcdGNvbnRyb2wuYXBwZW5kQ2hpbGQoIGMgKVxuXHR9XG5cdGVsc2Vcblx0XHRjb250cm9sLmlubmVySFRNTCA9IGBgXG5cdGNiICYmIGNiKClcbn0gKSB9XG5cbmZ1bmN0aW9uIHRvQXR0clN0cmluZyggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApXG5cdFx0cmV0dXJuIHZhbHVlLm1hcCggdG9BdHRyU3RyaW5nICkuam9pbiggYCBgIClcblx0ZWxzZSBpZiAoIHZhbHVlIClcblx0XHRyZXR1cm4gYCR7IHZhbHVlIH1gXG5cdGVsc2Vcblx0XHRyZXR1cm4gYGBcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ29udGVudCggY29udGVudCwgZiApIHtcblx0aWYgKCAhZiApXG5cdFx0ZiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRmb3IgKCBsZXQgYyBvZiBjb250ZW50ICkge1xuXHRcdGlmICggdHlwZW9mIGMgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdGxldCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYHNwYW5gIClcblx0XHRcdHNldENvbnRlbnQoIHAsIGMgKVxuXHRcdFx0Zi5hcHBlbmRDaGlsZCggcCApXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBjIGluc3RhbmNlb2YgTm9kZSApXG5cdFx0XHRmLmFwcGVuZENoaWxkKCBjIClcblx0XHRlbHNlIGlmICggYyAhPSBudWxsICYmIHR5cGVvZiBjICE9IGBzdHJpbmdgICYmICEoIGMgaW5zdGFuY2VvZiBTdHJpbmcgKSAmJiBjWyBTeW1ib2wuaXRlcmF0b3IgXSApXG5cdFx0XHRhcHBlbmRDb250ZW50KCBjLCBmIClcblx0XHRlbHNlXG5cdFx0XHRmLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggYyApIClcblx0fVxuXHRyZXR1cm4gZlxufVxuXG5sZXQgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIGZ1bmN0aW9uKiAoKSB7fSApXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoIG5hbWUsIGF0dHJpYnV0ZXMsIGNvbnRlbnQgKSB7XG5cdGlmICggdHlwZW9mIG5hbWUgPT0gYGZ1bmN0aW9uYCApXG5cdFx0cmV0dXJuIG5hbWUoIGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5fID8gT2JqZWN0LmFzc2lnbigge30sIGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMuXywgeyBfOiBudWxsIH0gKSA6ICggYXR0cmlidXRlcyB8fCBmYWxzZSApLCBhcHBlbmRDb250ZW50KCBjb250ZW50ICkgKVxuXHRsZXQgb25DcmVhdGVcblx0bGV0IHJldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIG5hbWUgKVxuXHRsZXQgY2xhc3NlcyA9IFtdXG5cdGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyggYXR0cmlidXRlcyApIHtcblx0XHRpZiAoIGF0dHJpYnV0ZXMgPT0gbnVsbCApXG5cdFx0XHRyZXR1cm5cblx0XHRmb3IgKCBsZXQgWyBuYW1lLCB2YWx1ZSBdIG9mIGxvZGFzaC5wYWlycyggYXR0cmlidXRlcyApICkge1xuXHRcdFx0aWYgKCBuYW1lID09IGBfYCApIHsgLy8gbm9vcFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG5hbWUgPT0gYGNsYXNzYCApXG5cdFx0XHRcdGNsYXNzZXMucHVzaCggdmFsdWUgKVxuXHRcdFx0ZWxzZSBpZiAoIG5hbWUgPT0gYHN0eWxlYCApXG5cdFx0XHRcdC8vIFRPRE86IHNtdGggbGlrZSB0byBcImNsYXNzXCIgYXR0cmlidXRlIC0gcGFyc2UgcGFyZW50IHN0eWxlIGFuZCB1cGRhdGUgaXRcblx0XHRcdFx0ZmNhbGMoIHZhbHVlLCB2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYHN0cmluZ2AgKVxuXHRcdFx0XHRcdFx0cmV0LnNldEF0dHJpYnV0ZSggYHN0eWxlYCwgdmFsdWUgKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGZvciAoIGxldCBbIG5hbWUsIHZhbHVlIF0gb2YgbG9kYXNoLnBhaXJzKCB2YWx1ZSApIClcblx0XHRcdFx0XHRcdFx0ZmNhbGMoIHZhbHVlLCB2YWx1ZSA9PiByZXQuc3R5bGVbIG5hbWUgXSA9IHZhbHVlIClcblx0XHRcdFx0fSApXG5cdFx0XHRlbHNlIGlmICggbmFtZSA9PSBgb25jcmVhdGVgIClcblx0XHRcdFx0b25DcmVhdGUgPSB2YWx1ZVxuXHRcdFx0ZWxzZSBpZiAoIG5hbWUubWF0Y2goIC9eb24vICkgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PSBgZnVuY3Rpb25gIClcblx0XHRcdFx0XHRcdHZhbHVlID0gWyB2YWx1ZSBdXG5cdFx0XHRcdFx0Zm9yICggbGV0IGhhbmRsZXIgb2YgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIE9iamVjdC5nZXRQcm90b3R5cGVPZiggaGFuZGxlciApID09IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIClcblx0XHRcdFx0XHRcdFx0aGFuZGxlciA9IGNvLmV2ZW50SGFuZGxlciggaGFuZGxlciApXG5cdFx0XHRcdFx0XHRyZXQuYWRkRXZlbnRMaXN0ZW5lciggbmFtZS5zbGljZSggYG9uYC5sZW5ndGggKSwgZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdFx0XHRcdFx0bG9nLmxvZyggYGV2ZW50YCwgbmFtZSwgZXZlbnQgKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpczo6aGFuZGxlciggZXZlbnQgKVxuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGZjYWxjKCB2YWx1ZSwgdmFsdWUgPT4ge1xuXHRcdFx0XHRcdHZhbHVlID0gdG9BdHRyU3RyaW5nKCB2YWx1ZSApXG5cdFx0XHRcdFx0aWYgKCByZXQuZ2V0QXR0cmlidXRlKCBuYW1lICkgIT0gdmFsdWUgKVxuXHRcdFx0XHRcdFx0cmV0LnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKVxuXHRcdFx0XHR9IClcblx0XHR9XG5cdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGF0dHJpYnV0ZXMsIGBfYCApIClcblx0XHRcdGFwcGx5QXR0cmlidXRlcyggYXR0cmlidXRlcy5fIClcblx0fVxuXHRhcHBseUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMgKVxuXHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdGxldCBjb3B5ID0gY2xhc3Nlcy5tYXAoICgpID0+IG51bGwgKVxuXHRcdGNsYXNzZXMuZm9yRWFjaCggKCBjLCBpICkgPT4gZmNhbGMoIGMsIGMgPT4ge1xuXHRcdFx0Y29weVsgaSBdID0gY1xuXHRcdFx0bGV0IGNsYXNzTmFtZSA9IHRvQXR0clN0cmluZyggY29weSApXG5cdFx0XHRcdC5yZXBsYWNlKCAvKF58XFxzfFxccnxcXG4pKG51bGx8dW5kZWZpbmVkfGZhbHNlfDB8XFwtMHxOYU4pKD89JHxcXHN8XFxyfFxcbikvZywgYGAgKVxuXHRcdFx0aWYgKCByZXQuY2xhc3NOYW1lICE9IGNsYXNzTmFtZSApXG5cdFx0XHRcdHJldC5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9ICkgKVxuXHR9XG5cdHN3aXRjaCAoIGNvbnRlbnQubGVuZ3RoICkge1xuXHRjYXNlIDA6XG5cdFx0YnJlYWtcblx0Y2FzZSAxOlxuXHRcdHNldENvbnRlbnQoIHJldCwgY29udGVudFsgMCBdIClcblx0XHRicmVha1xuXHRkZWZhdWx0OlxuXHRcdHJldC5hcHBlbmRDaGlsZCggYXBwZW5kQ29udGVudCggY29udGVudCApIClcblx0XHRicmVha1xuXHR9XG5cdGlmICggdHlwZW9mIG9uQ3JlYXRlID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0b25DcmVhdGUuY2FsbCggcmV0LCB7XG5cdFx0XHR0eXBlOiBgY3JlYXRlYCxcblx0XHRcdHRhcmdldDogcmV0LFxuXHRcdFx0c3JjRWxlbWVudDogcmV0LFxuXHRcdFx0Y3VycmVudFRhcmdldDogcmV0LFxuXHRcdH0gKVxuXHR9XG5cdHJldHVybiByZXRcbn1cblxubGV0IF9sYXN0TW9kdWxlXG5cbmV4cG9ydCB7IGNyZWF0ZUVsZW1lbnRGcm9tTW9kdWxlIGFzIGNyZWF0ZUVsZW1lbnQgfVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEZyb21Nb2R1bGUoIG5hbWUsIGF0dHJpYnV0ZXMsIC4uLmNvbnRlbnQgKSB7XG5cdGxldCByZXQgPSBjcmVhdGVFbGVtZW50KCBuYW1lLCBhdHRyaWJ1dGVzLCBjb250ZW50IClcblx0X2xhc3RNb2R1bGUgPSByZXRcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZCggbW9kdWxlICkge1xuXHRyZXR1cm4gbW9kdWxlICYmIG1vZHVsZS5jb21wb25lbnQgfHwgX2xhc3RNb2R1bGVcbn1cblxubGV0IHVwZGF0ZUlucHV0VmFsdWUgPSBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoICgpID0+IHRoaXMuX3JhVmFsdWUuYXNzaWduKCB0aGlzLnZhbHVlICkgKSB9XG5sZXQgcmFWYWx1ZSA9IHtcblx0Z2V0KCkge1xuXHRcdGlmICggIXRoaXMuX3JhVmFsdWUgKSByYS5kZXRhY2goICgpID0+IHtcblx0XHRcdHRoaXMuX3JhVmFsdWUgPSByYSgpXG5cdFx0XHR0aGlzLl9yYVZhbHVlLmFzc2lnbiggdGhpcy52YWx1ZSApXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGBjaGFuZ2VgLCB1cGRhdGVJbnB1dFZhbHVlIClcblx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggYGtleXByZXNzYCwgdXBkYXRlSW5wdXRWYWx1ZSApXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGBrZXlkb3duYCwgdXBkYXRlSW5wdXRWYWx1ZSApXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGBrZXl1cGAsIHVwZGF0ZUlucHV0VmFsdWUgKVxuXHRcdH0gKVxuXHRcdHJldHVybiB0aGlzLl9yYVZhbHVlLnZhbHVlT2YoKVxuXHR9LFxuXHRzZXQoIHZhbHVlICkge1xuXHRcdGlmICggdGhpcy52YWx1ZSAhPSB2YWx1ZSApIHtcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZVxuXHRcdFx0aWYgKCB0aGlzLl9yYVZhbHVlIClcblx0XHRcdFx0dGhpcy5fcmFWYWx1ZS5hc3NpZ24oIHRoaXMudmFsdWUgKVxuXHRcdH1cblx0fSxcbn1cblxuZm9yICggbGV0IEMgb2YgWyBIVE1MSW5wdXRFbGVtZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50IF0gKVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEMucHJvdG90eXBlLCBgcmFWYWx1ZWAsIHJhVmFsdWUgKVxuIiwiaW1wb3J0IHJhIGZyb20gXCJyYVwiXG5pbXBvcnQgKiBhcyBEaWZmIGZyb20gXCJkaWZmXCJcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGFwcGx5KCBzb3VyY2UsIHRyYW5zZm9ybWVyICkge1xuXHRyZXR1cm4gRGlmZi5hcHBseSggc291cmNlLCB0cmFuc2Zvcm1lciggc291cmNlICkgKVxufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1lciggdHJhbnNmb3JtZXIgKSB7XG5cdHJldHVybiB0eXBlb2YgdHJhbnNmb3JtZXIgPT0gYGZ1bmN0aW9uYCA/IHRyYW5zZm9ybWVyIDogKCkgPT4gdHJhbnNmb3JtZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuXHRsZXQgY2FjaGUgPSByYSgge1xuXHRcdHNvdXJjZTogbnVsbCxcblx0XHR0cmFuc2Zvcm1lcnM6IFsgcmEoIHtcblx0XHRcdGdldCByZXN1bHQoKSB7IHJldHVybiBjYWNoZS5zb3VyY2UgfSxcblx0XHR9ICkgXSxcblx0XHRnZXQgcmVzdWx0KCkgeyByZXR1cm4gY2FjaGUudHJhbnNmb3JtZXJzWyBjYWNoZS50cmFuc2Zvcm1lcnMubGVuZ3RoIC0gMSBdLnJlc3VsdCB9LFxuXHRcdG9wZW4oIHRyYW5zZm9ybWVyID0gbm9vcCApIHtcblx0XHRcdHRyYW5zZm9ybWVyID0gZ2V0VHJhbnNmb3JtZXIoIHRyYW5zZm9ybWVyIClcblx0XHRcdGxldCBpdGVtID0gcmEoIHtcblx0XHRcdFx0dHJhbnNmb3JtZXI6IHJhLlZhbHVlKCB0cmFuc2Zvcm1lciApLFxuXHRcdFx0XHRnZXQgaW5kZXgoKSB7IHJldHVybiBpdGVtICYmIGNhY2hlLnRyYW5zZm9ybWVycy5pbmRleE9mKCBpdGVtICkgfSxcblx0XHRcdFx0Z2V0IHNvdXJjZSgpIHsgcmV0dXJuIGl0ZW0gJiYgY2FjaGUudHJhbnNmb3JtZXJzWyBpdGVtLmluZGV4IC0gMSBdLnJlc3VsdCB9LFxuXHRcdFx0XHRnZXQgcmVzdWx0KCkge1xuXHRcdFx0XHRcdGlmICggIWl0ZW0gKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGxcblx0XHRcdFx0XHRsZXQgciA9IGFwcGx5KCBpdGVtLnNvdXJjZSwgaXRlbS50cmFuc2Zvcm1lciApXG5cdFx0XHRcdFx0aWYgKCBpdGVtLnJlc3VsdCApXG5cdFx0XHRcdFx0XHRyID0gRGlmZi5hcHBseSggaXRlbS5yZXN1bHQsIHIsIGZhbHNlIClcblx0XHRcdFx0XHRyZXR1cm4gclxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjbG9zZSgpIHtcblx0XHRcdFx0XHRpZiAoIGl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRjYWNoZS50cmFuc2Zvcm1lcnMgPSBjYWNoZS50cmFuc2Zvcm1lcnMuZmlsdGVyKCBpID0+IGkgIT0gaXRlbSApXG5cdFx0XHRcdFx0XHRpdGVtID0gbnVsbFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0dXBkYXRlKCBuZXdfdHJhbnNmb3JtZXIgKSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtZXIgPSBpdGVtLnRyYW5zZm9ybWVyID0gZ2V0VHJhbnNmb3JtZXIoIG5ld190cmFuc2Zvcm1lciApXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFwcGx5OiBkYiA9PiBhcHBseSggZGIsIHRyYW5zZm9ybWVyICksXG5cdFx0XHR9IClcblx0XHRcdGNhY2hlLnRyYW5zZm9ybWVycyA9IGNhY2hlLnRyYW5zZm9ybWVycy5jb25jYXQoIFsgaXRlbSBdIClcblx0XHRcdHJldHVybiBpdGVtXG5cdFx0fSxcblx0fSApXG5cdHJldHVybiBjYWNoZVxufVxuIiwiaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gXCJsb2Rhc2hcIlxuaW1wb3J0ICogYXMgRGlmZiBmcm9tIFwiZGlmZlwiXG5pbXBvcnQgVUlEIGZyb20gXCJ1aWRcIlxuXG5leHBvcnQgY29uc3QgVW5saW5rID0gKCBkZXZpY2VzLCBkZXZpY2VJZCApID0+IGxvZGFzaC5yZWR1Y2UoIGRldmljZXMuY29udGVudCwgKCByZXQsIHEsIGluZGV4ICkgPT4ge1xuXHRpZiAoIHEgKVxuXHRcdGlmICggaW5kZXggPT0gZGV2aWNlSWQgKVxuXHRcdFx0cmV0LmNvbnRlbnRbIGluZGV4IF0gPSBudWxsXG5cdFx0ZWxzZSBpZiAoIHEuY29udGVudCAmJiBxLmNvbnRlbnRbIGRldmljZUlkIF0gKVxuXHRcdFx0cmV0LmNvbnRlbnRbIGluZGV4IF0gPSB7IGNvbnRlbnQ6IHsgWyBkZXZpY2VJZCBdOiBudWxsIH0gfVxuXHRyZXR1cm4gcmV0XG59LCB7IGNvbnRlbnQ6IHt9IH0gKVxuXG5leHBvcnQgeyBVbmxpbmsgYXMgQ2xlYXIgfVxuXG5leHBvcnQgY29uc3QgU2V0ID0gKCBkZXZpY2VzLCBkZXZpY2VJZCwgZGF0YSApID0+IHtcblx0bGV0IGRldmljZSA9IGRldmljZXMuY29udGVudFsgZGV2aWNlSWQgXVxuXHRpZiAoICFkZXZpY2UgfHwgIWRldmljZS5ncm91cCApXG5cdFx0cmV0dXJuXG5cdGxldCByZXQgPSB7IGNvbnRlbnQ6IHsgWyBkZXZpY2VJZCBdOiBkYXRhIH0gfVxuXHRpZiAoIGRldmljZS50eXBlID09IGBncm91cGAgKVxuXHRcdHJldCA9IGxvZGFzaC5yZWR1Y2UoIGRldmljZS5jb250ZW50LCAoIHJldCwgcSwgaW5kZXggKSA9PiB7XG5cdFx0XHRpZiAoIHEgKVxuXHRcdFx0XHRyZXQuY29udGVudFsgaW5kZXggXSA9IGRhdGFcblx0XHRcdHJldHVybiByZXRcblx0XHR9LCByZXQgKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydCBjb25zdCBmaW5kRnJlZUdyb3VwID0gZGV2aWNlcyA9PiB7XG5cdGxldCBncm91cHMgPSBbXVxuXHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gMTAyMjsgKytpIClcblx0XHRncm91cHNbIGkgXSA9IGlcblx0bG9kYXNoLmZvckVhY2goIGRldmljZXMuY29udGVudCwgZGV2aWNlID0+IHsgZGV2aWNlICYmIE51bWJlci5pc0Zpbml0ZSggZGV2aWNlLmdyb3VwICkgJiYgKCBncm91cHNbIGRldmljZS5ncm91cCBdID0gZmFsc2UgKSB9IClcblx0Z3JvdXBzID0gZ3JvdXBzLmZpbHRlciggQm9vbGVhbiApXG5cdHJldHVybiAhZ3JvdXBzLmxlbmd0aCA/IG51bGwgOiBncm91cHNbIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiBncm91cHMubGVuZ3RoICkgJSBncm91cHMubGVuZ3RoIF1cbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFuRGF0YWJhc2UgPSBkZXZpY2VzID0+IHtcblx0bGV0IHJldCA9IGRldmljZXMgfHwge31cblx0ZnVuY3Rpb24gX3NhdmUoIGRpZmYgKSB7XG5cdFx0cmV0ID0gRGlmZi5hcHBseSggcmV0LCBkaWZmIClcblx0fVxuXHRmdW5jdGlvbiBfY2hhbmdlKCBwYXRoLCB2YWx1ZSApIHtcblx0XHRfc2F2ZSggcGF0aC5yZWR1Y2VSaWdodCggKCByZXQsIGtleSApID0+ICggeyBbIGtleSBdOiByZXQgfSApLCB2YWx1ZSApIClcblx0fVxuXHRmdW5jdGlvbiBhc3NpZ24oIC4uLnBhdGggKSB7XG5cdFx0X2NoYW5nZSggcGF0aCwgcGF0aC5wb3AoKSApXG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlKCAuLi5wYXRoICkge1xuXHRcdF9jaGFuZ2UoIHBhdGgsIG51bGwgKVxuXHR9XG5cblx0Ly8gbW92ZSByb290IGl0ZW1zIHRvIGNvbnRlbnRcblx0aWYgKCAhcmV0LmNvbnRlbnQgKVxuXHRcdGxvZGFzaC5mb3JFYWNoKCByZXQsICggcGxhY2UsIHBsYWNlSWQgKSA9PiB7XG5cdFx0XHRpZiAoIHBsYWNlICE9IG51bGwgJiYgdHlwZW9mIHBsYWNlICE9IGBvYmplY3RgIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRyZW1vdmUoIHBsYWNlSWQgKVxuXHRcdFx0YXNzaWduKCBgY29udGVudGAsIHBsYWNlSWQsIHBsYWNlIClcblx0XHR9IClcblx0ZWxzZSAvLyBUT0RPIGRlbGV0ZSBsYXRlclxuXHRcdGxvZGFzaC5mb3JFYWNoKCByZXQsICggcGxhY2UsIHBsYWNlSWQgKSA9PiB7XG5cdFx0XHRpZiAoIHBsYWNlICE9IG51bGwgJiYgdHlwZW9mIHBsYWNlICE9IGBvYmplY3RgIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRpZiAoIHBsYWNlSWQgPT0gYGNvbnRlbnRgIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRyZW1vdmUoIHBsYWNlSWQgKVxuXHRcdH0gKVxuXG5cdC8vIHJlbW92ZSBpdGVtcyB3aXRoIHdyb25nIHR5cGUgJiByZW1vdmUgZ3JvdXAgZnJvbSBwbGFjZXNcblx0bG9kYXNoLmZvckVhY2goIHJldC5jb250ZW50LCAoIHBsYWNlLCBwbGFjZUlkICkgPT4ge1xuXHRcdGlmICggcGxhY2UgPT0gbnVsbCB8fCB0eXBlb2YgcGxhY2UgIT0gYG9iamVjdGAgKVxuXHRcdFx0cmV0dXJuIHJlbW92ZSggYGNvbnRlbnRgLCBwbGFjZUlkICApXG5cdFx0aWYgKCBwbGFjZS50eXBlID09IGBkZXZpY2VgICkgLy8gVE9ETzogcmVtb3ZlIGxhdGVyXG5cdFx0XHRhc3NpZ24oIGBjb250ZW50YCwgcGxhY2VJZCwgYHR5cGVgLCBgc2luZ2xlYCApXG5cdFx0aWYgKCBwbGFjZS5kZXZpY2UgPT0gcGxhY2VJZCApXG5cdFx0XHRyZW1vdmUoIGBjb250ZW50YCwgcGxhY2VJZCwgYGRldmljZWAgKVxuXHRcdGVsc2UgaWYgKCAhKCBwbGFjZS50eXBlIHx8IGBgICkubWF0Y2goIC9eKHBsYWNlfGdyb3VwfHNpbmdsZSkkLyApIClcblx0XHRcdHJldHVybiByZW1vdmUoIGBjb250ZW50YCwgcGxhY2VJZCApXG5cdFx0aWYgKCBwbGFjZS5ncm91cCAhPSBudWxsICYmICggIU51bWJlci5pc0Zpbml0ZSggcGxhY2UuZ3JvdXAgKSB8fCBwbGFjZS50eXBlID09IGBwbGFjZWAgKSApXG5cdFx0XHRyZW1vdmUoIGBjb250ZW50YCwgcGxhY2VJZCwgYGdyb3VwYCApXG5cdH0gKVxuXG5cdC8vIGNyZWF0ZSBtYWluXG5cdGlmICggcmV0ICYmICggdHlwZW9mIHJldC5tYWluICE9IGBzdHJpbmdgIHx8ICFyZXQuY29udGVudCB8fCAhcmV0LmNvbnRlbnRbIHJldC5tYWluIF0gfHwgIXJldC5jb250ZW50WyByZXQubWFpbiBdLnR5cGUgKSApIHtcblx0XHRsZXQgbWFpbiA9IFVJRCgpXG5cdFx0bGV0IGkgPSAwXG5cdFx0bG9kYXNoLmZvckVhY2goIHJldC5jb250ZW50LCAoIHBsYWNlLCBrZXkgKSA9PiB7IGFzc2lnbiggYGNvbnRlbnRgLCBtYWluLCBgY29udGVudGAsIGtleSwgKytpICkgfSApXG5cdFx0aWYgKCByZXQuY29udGVudCAmJiByZXQuY29udGVudFsgbWFpbiBdICkge1xuXHRcdFx0YXNzaWduKCBgY29udGVudGAsIG1haW4sIGB0eXBlYCwgYHBsYWNlYCApXG5cdFx0XHRhc3NpZ24oIGBtYWluYCwgbWFpbiApXG5cdFx0fVxuXHR9XG5cblx0Ly8gcmVtb3ZlIGl0ZW1zIHdpdGggZHVwbGljYXRlIGdyb3VwXG5cdGxldCByZWFjaGFibGVcblx0ZnVuY3Rpb24gZ3JvdXBJbmRleCgga2V5ICkge1xuXHRcdGlmICggIXJlYWNoYWJsZSApIHtcblx0XHRcdHJlYWNoYWJsZSA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0bGV0IHJlYWNoYWJsZUtleXMgPSBbXVxuXHRcdFx0ZnVuY3Rpb24gcHVzaCgga2V5ICkge1xuXHRcdFx0XHRpZiAoICEoIGtleSBpbiByZWFjaGFibGUgKSAmJiByZXQuY29udGVudC5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0cmVhY2hhYmxlWyBrZXkgXSA9IHRydWVcblx0XHRcdFx0XHRyZWFjaGFibGVLZXlzLnB1c2goIGtleSApXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGtleVxuXHRcdFx0fVxuXHRcdFx0cHVzaCggcmV0Lm1haW4gKVxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcmVhY2hhYmxlS2V5cy5sZW5ndGg7ICsraSApIHtcblx0XHRcdFx0bGV0IHBsYWNlID0gcmV0LmNvbnRlbnRbIHJlYWNoYWJsZUtleXNbIGkgXSBdXG5cdFx0XHRcdGlmICggcGxhY2UgJiYgcGxhY2UuY29udGVudCApXG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoIHBsYWNlLmNvbnRlbnQgKS5mb3JFYWNoKCBwdXNoIClcblx0XHRcdH1cblx0XHR9XG5cdFx0bGV0IGkgPSAwXG5cdFx0aWYgKCByZXQuY29udGVudFsga2V5IF0udHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdGkgKz0gMlxuXHRcdGlmICgga2V5IGluIHJlYWNoYWJsZSApXG5cdFx0XHRpICs9IDFcblx0fVxuXG5cdGxldCBncm91cHMgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0bG9kYXNoLmZvckVhY2goIHJldC5jb250ZW50LCAoIHBsYWNlLCBrZXkgKSA9PiB7XG5cdFx0aWYgKCAhcGxhY2UgfHwgcGxhY2UuZ3JvdXAgPT0gbnVsbCApXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoICFncm91cHNbIHBsYWNlLmdyb3VwIF0gKVxuXHRcdFx0Z3JvdXBzWyBwbGFjZS5ncm91cCBdID0ga2V5XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoIGdyb3VwSW5kZXgoIGdyb3Vwc1sgcGxhY2UuZ3JvdXAgXSApIDwgZ3JvdXBJbmRleCgga2V5ICkgKSB7XG5cdFx0XHRcdHJlbW92ZSggYGNvbnRlbnRgLCBncm91cHNbIHBsYWNlLmdyb3VwIF0gKVxuXHRcdFx0XHRncm91cHNbIHBsYWNlLmdyb3VwIF0gPSBrZXlcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0cmVtb3ZlKCBgY29udGVudGAsIGtleSApXG5cdFx0fVxuXHR9IClcblxuXHQvLyBjaGVjayBjb250ZW50XG5cdGxvZGFzaC5mb3JFYWNoKCByZXQuY29udGVudCwgKCBwbGFjZSwga2V5ICkgPT4ge1xuXHRcdGlmICggIXBsYWNlIHx8IHBsYWNlLmNvbnRlbnQgPT0gbnVsbCApXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoIHR5cGVvZiBwbGFjZS5jb250ZW50ICE9IGBvYmplY3RgIClcblx0XHRcdHJldHVybiByZW1vdmUoIGBjb250ZW50YCwga2V5LCBgY29udGVudGAgKVxuXHRcdGxvZGFzaC5mb3JFYWNoKCBwbGFjZS5jb250ZW50LCAoIF8sIGNrZXkgKSA9PiB7XG5cdFx0XHRpZiAoICFyZXQuY29udGVudFsgY2tleSBdIHx8IHR5cGVvZiByZXQuY29udGVudFsgY2tleSBdICE9IGBvYmplY3RgIClcblx0XHRcdFx0cmVtb3ZlKCBgY29udGVudGAsIGtleSwgYGNvbnRlbnRgLCBja2V5IClcblx0XHR9IClcblx0XHRwbGFjZSA9IHJldC5jb250ZW50WyBrZXkgXSAvLyByZWFzc2lnbiBwbGFjZSBjYXVzZSBpdCBjb3VsZCBjaGFuZ2UgaW4gcHJldmlvdXMgZm9yRWFjaFxuXHRcdGxvZGFzaC5rZXlzKCBwbGFjZS5jb250ZW50IClcblx0XHQuc29ydCggKCBhLCBiICkgPT4gKCBwbGFjZS5jb250ZW50WyBhIF0uaW5kZXggfHwgMCApIC0gKCBwbGFjZS5jb250ZW50WyBiIF0uaW5kZXggfHwgMCApIClcblx0XHQuZm9yRWFjaCggKCBja2V5LCBpbmRleCApID0+IHtcblx0XHRcdGlmICggcGxhY2UuY29udGVudFsgY2tleSBdLmluZGV4ICE9IGluZGV4IClcblx0XHRcdFx0YXNzaWduKCBgY29udGVudGAsIGtleSwgYGNvbnRlbnRgLCBja2V5LCBgaW5kZXhgLCBpbmRleCApXG5cdFx0fSApXG5cdH0gKVxuXG5cdHJldHVybiBEaWZmLm1ha2UoIGRldmljZXMsIHJldCApXG59XG4iLCJsZXQgTGl0ZXJhbFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZigge30gKVxuXG5sZXQgaXNTZXQgPSBvYmogPT4ge1xuXHRpZiAoIG9iaiA9PSBudWxsIClcblx0XHRyZXR1cm4gZmFsc2Vcblx0bGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBvYmogKVxuXHRyZXR1cm4gcHJvdG8gPT09IExpdGVyYWxQcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGxcbn1cblxubGV0IE5PTl9QQVJUSUFMID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5OT05fUEFSVElBTC5fX3BhcnRpYWxfXyA9IGZhbHNlXG5cbmxldCBQQVJUSUFMID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2UoIGRlc3QsIHBhdGgsIGRpZmYsIHBhcnRpYWwgKSB7XG5cdGxldCB4ID0gZGVzdCwgcmRpZmYgPSB7fSwgcGRpZmYgPSByZGlmZlxuXHRmb3IgKCBsZXQgaW5kZXggb2YgcGF0aCApIHtcblx0XHR4ID0geFsgaW5kZXggXVxuXHRcdGlmICggeCA9PSBudWxsIClcblx0XHRcdHJldHVybiBkZXN0XG5cdFx0cGRpZmYgPSBwZGlmZlsgaW5kZXggXSA9IHt9XG5cdH1cblx0T2JqZWN0LmFzc2lnbiggcGRpZmYsIGRpZmYgKVxuXHRpZiAoIHBkaWZmLl9fcGFydGlhbF9fID09IG51bGwgJiYgcGFydGlhbCA9PT0gZmFsc2UgKVxuXHRcdHBkaWZmLl9fcGFydGlhbF9fID0gZmFsc2Vcblx0cmV0dXJuIGFwcGx5KCBkZXN0LCByZGlmZiApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseSggZGVzdCwgZGlmZiwgcGFydGlhbCApIHtcblxuXHRpZiAoIGRlc3QgPT0gbnVsbCAmJiBkaWZmICE9IG51bGwgJiYgZGlmZi5fX3ByZXNlbnRfXyApXG5cdFx0cmV0dXJuIGRlc3RcblxuXHRsZXQgcmV0ID0gZGVzdFxuXHRsZXQgY250ID0gMFxuXG5cdGZ1bmN0aW9uIGNvcHlEZXN0KCkge1xuXHRcdHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdGZvciAoIGxldCBrZXkgaW4gZGVzdCApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkZXN0LCBrZXkgKSApIHtcblx0XHRcdGxldCB2YWx1ZSA9IGRlc3RbIGtleSBdXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0cmV0WyBrZXkgXSA9IGRlc3RbIGtleSBdXG5cdFx0XHQrK2NudFxuXHRcdH1cblx0fVxuXG5cdGlmICggZGlmZiAmJiBkaWZmLl9fcGFydGlhbF9fID09PSBmYWxzZSApXG5cdFx0cGFydGlhbCA9IGZhbHNlXG5cblx0Zm9yICggbGV0IGtleSBpbiBkaWZmICkgaWYgKCBrZXkgIT0gYF9fcGFydGlhbF9fYCAmJiBrZXkgIT0gYF9fcHJlc2VudF9fYCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRpZmYsIGtleSApICkge1xuXHRcdGxldCB2YWx1ZSA9IGRpZmZbIGtleSBdXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdGNvbnRpbnVlXG5cdFx0aWYgKCB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBgb2JqZWN0YCApXG5cdFx0XHR2YWx1ZSA9IGFwcGx5KCByZXQgJiYgcmV0WyBrZXkgXSwgdmFsdWUsIHBhcnRpYWwgKVxuXHRcdGlmICggdmFsdWUgPT0gbnVsbCApIHtcblx0XHRcdGlmICggcmV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCByZXQsIGtleSApICkge1xuXHRcdFx0XHRpZiAoIHJldCA9PT0gZGVzdCApXG5cdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRkZWxldGUgcmV0WyBrZXkgXVxuXHRcdFx0XHQtLWNudFxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICggcmV0ID09IG51bGwgfHwgcmV0WyBrZXkgXSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggcmV0ID09PSBkZXN0IClcblx0XHRcdFx0XHRjb3B5RGVzdCgpXG5cdFx0XHRcdHJldFsga2V5IF0gPSB2YWx1ZVxuXHRcdFx0fVxuXHRcdFx0Y250ID0gSW5maW5pdHlcblx0XHR9XG5cdH1cblxuXHRpZiAoIHBhcnRpYWwgPT09IGZhbHNlIClcblx0XHRmb3IgKCBsZXQga2V5IGluIHJldCApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCByZXQsIGtleSApICkge1xuXHRcdFx0aWYgKCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkaWZmLCBrZXkgKSB8fCBkaWZmWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpZiAoIHJldCA9PT0gZGVzdCApXG5cdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRkZWxldGUgcmV0WyBrZXkgXVxuXHRcdFx0XHQtLWNudFxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjbnQgPSBJbmZpbml0eVxuXHRcdH1cblxuXHRpZiAoIHJldCAhPT0gZGVzdCAmJiBjbnQgPT0gMCApXG5cdFx0cmV0ID0gbnVsbFxuXG5cdHJldHVybiByZXRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKCBhLCBiICkge1xuXG5cdGlmICggYSA9PSBudWxsIClcblx0XHRhID0gTk9OX1BBUlRJQUxcblx0aWYgKCBiID09IG51bGwgKVxuXHRcdGIgPSBOT05fUEFSVElBTFxuXG5cdGlmICggYi5fX3BhcnRpYWxfXyA9PT0gZmFsc2UgKVxuXHRcdHJldHVybiBiXG5cblx0bGV0IHJldCA9IGFcblxuXHRmdW5jdGlvbiBjb3B5RGVzdCgpIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRmb3IgKCBsZXQga2V5IGluIGEgKSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggYSwga2V5ICkgKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBhWyBrZXkgXVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0Y29udGludWVcblx0XHRcdHJldFsga2V5IF0gPSBhWyBrZXkgXVxuXHRcdH1cblx0fVxuXG5cdGZvciAoIGxldCBrZXkgaW4gYiApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBiLCBrZXkgKSApIHtcblx0XHRsZXQgdmFsdWUgPSBiWyBrZXkgXVxuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRjb250aW51ZVxuXHRcdGlmICggdmFsdWUgPT0gbnVsbCApXG5cdFx0XHR2YWx1ZSA9IE5PTl9QQVJUSUFMXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYG9iamVjdGAgKSB7XG5cdFx0XHRsZXQgciA9IHJldCA/IHJldFsga2V5IF0gOiB1bmRlZmluZWRcblx0XHRcdGlmICggciA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0ciA9IFBBUlRJQUxcblx0XHRcdHZhbHVlID0gbWVyZ2UoIHIsIHZhbHVlIClcblx0XHR9XG5cdFx0aWYgKCByZXQgPT0gbnVsbCB8fCByZXRbIGtleSBdICE9PSB2YWx1ZSApIHtcblx0XHRcdGlmICggcmV0ID09PSBhIClcblx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0cmV0WyBrZXkgXSA9IHZhbHVlXG5cdFx0fVxuXHR9XG5cblx0aWYgKCByZXQgIT09IGEgJiYgdHlwZW9mIGEgIT0gYG9iamVjdGAgKVxuXHRcdHJldC5fX3BhcnRpYWxfXyA9IGZhbHNlXG5cblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZSggcHJldmlvdXMsIG5leHQgKSB7XG5cdGlmICggcHJldmlvdXMgPT09IG5leHQgKVxuXHRcdHJldHVybiB1bmRlZmluZWRcblx0bGV0IHJldCA9IHVuZGVmaW5lZFxuXHRmdW5jdGlvbiB0b0FycmF5KCBvYmogKSB7XG5cdFx0bGV0IHJldCA9IFtdXG5cdFx0Zm9yICggbGV0IGtleSBvZiBPYmplY3Qua2V5cyggb2JqICkgKVxuXHRcdFx0cmV0LnB1c2goIHsgdmFsdWU6IG9ialsga2V5IF0sIGtleSB9IClcblx0XHRyZXR1cm4gcmV0LnNvcnQoICggdjEsIHYyICkgPT5cblx0XHRcdHYxLmtleSA8IHYyLmtleSA/IC0xIDogdjEua2V5ID4gdjIua2V5ID8gMSA6IDAgKVxuXHR9XG5cdGxldCBwYSA9IHRvQXJyYXkoIHByZXZpb3VzIClcblx0bGV0IG5hID0gdG9BcnJheSggbmV4dCApXG5cdGxldCBwID0gcGEucG9wKClcblx0bGV0IG4gPSBuYS5wb3AoKVxuXHR3aGlsZSAoIHAgfHwgbiApIHtcblx0XHRpZiAoICFuIHx8IHAgJiYgcC5rZXkgPiBuLmtleSApIHtcblx0XHRcdGlmICggIXJldCApXG5cdFx0XHRcdHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0cmV0WyBwLmtleSBdID0gbnVsbCAvLyBkZWxldGluZ1xuXHRcdFx0cCA9IHBhLnBvcCgpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhcCB8fCBwLmtleSA8IG4ua2V5ICkge1xuXHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRyZXRbIG4ua2V5IF0gPSBuLnZhbHVlXG5cdFx0XHRuID0gbmEucG9wKClcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoIHAudmFsdWUgIT09IG4udmFsdWUgKSB7XG5cdFx0XHRcdGlmICggaXNTZXQoIHAudmFsdWUgKSAmJiBpc1NldCggbi52YWx1ZSApICkge1xuXHRcdFx0XHRcdGxldCBkaWZmID0gbWFrZSggcC52YWx1ZSwgbi52YWx1ZSApXG5cdFx0XHRcdFx0aWYgKCBkaWZmICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0XHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdFx0XHRyZXRbIG4ua2V5IF0gPSBkaWZmXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICggIXJldCApXG5cdFx0XHRcdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdFx0XHRyZXRbIG4ua2V5IF0gPSBuLnZhbHVlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHAgPSBwYS5wb3AoKVxuXHRcdFx0biA9IG5hLnBvcCgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXQgPyByZXQgOiB1bmRlZmluZWRcbn1cblxuLy8gVE9ETzpcblxuLy8gZnVuY3Rpb24gYXNzZXJ0KCB2YWx1ZSwgbWVzc2FnZSApIHtcbi8vIFx0aWYgKCAhdmFsdWUgKVxuLy8gXHRcdHRocm93IG5ldyBFcnJvciggYGAgKyBtZXNzYWdlIClcbi8vIH1cblxuLy8gZnVuY3Rpb24gdGVzdERpZmYoKSB7XG4vLyBcdGxldCBwID0geyBhOiAxLCB4OiB7IHU6IDkgfSB9XG4vLyBcdGxldCBxID0geyB4OiB7IGM6IDIgfSB9XG4vLyBcdGFzc2VydCggSlNPTi5zdHJpbmdpZnkoIHEgKSA9PSBKU09OLnN0cmluZ2lmeSggRGlmZi5hcHBseSggcCwgRGlmZi5tYWtlKCBwLCBxICkgKSApIClcbi8vIH1cblxuIiwiLypcblxuMjAxNC4wOS4yMlxuXG5pdCBzaG91bGQgYmUgYmV0dGVyIHRvIHVzZSBoYW1tZXIuanMsIGJ1dCBpIGNhbm5vdCB1c2UgaXQgd2l0aG91dCBwcm9ibGVtcyAtXG5oYW1tZXIuanMgb2Z0ZW4gZHJvcHMgZXZlbnRzLCB3aGlsZSBkaXJlY3QgYWRkRXZlbnRMaXN0ZW5lciBkb2VzIG5vdC5cblxuKi9cblxuaW1wb3J0ICogYXMgY28gZnJvbSBcImNvXCJcbmltcG9ydCBzcGFyc2VxdWV1ZSBmcm9tIFwic3BhcnNlcXVldWVcIlxuXG5sZXQgVFJBQ0Vcbi8vIGxldCBUQyA9IDBcbi8vIFRSQUNFID0gKCAuLi5pbmZvICkgPT4gTE9HKCBgJHsgKytUQyB9IGcgJHsgSlNPTi5zdHJpbmdpZnkoIGluZm8gKS5zbGljZSggMCwgMTAwICkgfWAuZ3JlZW4gKVxuXG5sZXQgU1dJUEVfVElNRU9VVCA9IDQwMCAvLyBtc1xubGV0IFBSRVNTX1RJTUVPVVQgPSA1MDAgLy8gbXNcbmxldCBQUkVTU19NT1ZFX09VVCA9IDIgLyogfm1tICovICogKCA5NiAvIDI1LjQgKVxuXG5mdW5jdGlvbiBzcXVhcmVEaXN0YW5jZSggcDEsIHAyICkge1xuXHRyZXR1cm4gKCBwMS5wYWdlWCAtIHAyLnBhZ2VYICkgKiAoIHAxLnBhZ2VYIC0gcDIucGFnZVggKSArICggcDEucGFnZVkgLSBwMi5wYWdlWSApICogKCBwMS5wYWdlWSAtIHAyLnBhZ2VZIClcbn1cblxuZnVuY3Rpb24gZ2V0WCggcCApIHsgcmV0dXJuIHAucGFnZVggfVxuZnVuY3Rpb24gZ2V0WSggcCApIHsgcmV0dXJuIHAucGFnZVkgfVxuZnVuY3Rpb24gaW5jcmVhc2luZyggdiwgaSwgcCApIHsgcmV0dXJuIGkgPT0gMCB8fCB2ID49IHBbIGkgLSAxIF0gfVxuZnVuY3Rpb24gZGVjcmVhc2luZyggdiwgaSwgcCApIHsgcmV0dXJuIGkgPT0gMCB8fCB2IDw9IHBbIGkgLSAxIF0gfVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2hgLCBjby5ldmVudEhhbmRsZXIoIGZ1bmN0aW9uKiAoIGV2ZW50ICkge1xuXG5cdGxldCBhbGxcblx0bGV0IHRyYWNlID0gWyBldmVudCBdXG5cdGxldCBsYXN0ID0gZXZlbnRcblx0bGV0IHByZXNzZWQgPSBudWxsXG5cdGxldCBzd2lwZWQgPSBmYWxzZVxuXG5cdGxldCBwYW4gPSBudWxsXG5cdGxldCBwYW5sb2NrID0gbnVsbFxuXHRsZXQgc2VudCA9IGV2ZW50XG5cblx0Y28uZGVmZXIoICgpID0+IHtcblx0XHRwYW5sb2NrICYmIHBhbmxvY2suZm9yRWFjaCggbG9jayA9PiBsb2NrLnF1ZXVlLmNsb3NlKCkgKVxuXHRcdHBhbiAmJiBwYW4ucXVldWUuY2xvc2UoKVxuXHR9IClcblxuXHRmdW5jdGlvbiBzZW5kKCB0eXBlLCBkaXJlY3Rpb24sIHB0LCBkZXRhaWwsIHR5cGVEaXJlY3Rpb24gKSB7XG5cdFx0VFJBQ0UgJiYgVFJBQ0UoIHR5cGUsIGFsbCApXG5cdFx0aWYgKCB0eXBlRGlyZWN0aW9uID09IG51bGwgKVxuXHRcdFx0dHlwZURpcmVjdGlvbiA9IGRpcmVjdGlvblxuXHRcdGlmICggIWRldGFpbCApXG5cdFx0XHRkZXRhaWwgPSB7fVxuXHRcdGRldGFpbC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25cblx0XHRkZXRhaWwucHJlc3NlZCA9IHByZXNzZWRcblx0XHRkZXRhaWwudHlwZSA9IHR5cGVcblx0XHRkZXRhaWwuc3RhcnQgPSBldmVudFxuXHRcdGRldGFpbC5vcmlnaW5hbCA9IHB0IHx8IGV2ZW50XG5cdFx0bGV0IHJldCA9IG5ldyBDdXN0b21FdmVudCggdHlwZSArICggdHlwZURpcmVjdGlvbiB8fCBgYCApLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbCB9IClcblx0XHRyZXQucGFnZVggPSBsYXN0LnBhZ2VYXG5cdFx0cmV0LnBhZ2VZID0gbGFzdC5wYWdlWVxuXHRcdHJldC5jbGllbnRYID0gbGFzdC5jbGllbnRYXG5cdFx0cmV0LmNsaWVudFkgPSBsYXN0LmNsaWVudFlcblx0XHRyZXQuc2NyZWVuWCA9IGxhc3Quc2NyZWVuWFxuXHRcdHJldC5zY3JlZW5ZID0gbGFzdC5zY3JlZW5ZXG5cdFx0cmV0LmRlbHRhWCA9IGxhc3QucGFnZVggLSBldmVudC5wYWdlWFxuXHRcdHJldC5kZWx0YVkgPSBsYXN0LnBhZ2VZIC0gZXZlbnQucGFnZVlcblx0XHRyZXQubGFzdERlbHRhWCA9IGxhc3QucGFnZVggLSBzZW50LnBhZ2VYXG5cdFx0cmV0Lmxhc3REZWx0YVkgPSBsYXN0LnBhZ2VZIC0gc2VudC5wYWdlWVxuXHRcdHNlbnQgPSBsYXN0XG5cdFx0cmV0LnByZXZlbnREZWZhdWx0ID0gKCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdGV2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KCByZXQgKVxuXHRcdHJldHVybiByZXRcblx0fVxuXG5cdGZ1bmN0aW9uIGVuc3VyZXBhbiggZGlyZWN0aW9uICkge1xuXHRcdGlmICggcGFuIClcblx0XHRcdHJldHVyblxuXHRcdHBhbiA9IHsgcXVldWU6IG5ldyBzcGFyc2VxdWV1ZSB9XG5cdFx0c2VuZCggYHBhbmAsIGRpcmVjdGlvbiwgbGFzdCwge1xuXHRcdFx0bmV4dDogcGFuLnF1ZXVlLFxuXHRcdFx0bG9jaygpIHtcblx0XHRcdFx0aWYgKCAhcGFubG9jayApXG5cdFx0XHRcdFx0cGFubG9jayA9IFtdXG5cdFx0XHRcdGxldCByZXQgPSB7IHF1ZXVlOiBuZXcgc3BhcnNlcXVldWUgfVxuXHRcdFx0XHRwYW5sb2NrLnB1c2goIHJldCApXG5cdFx0XHRcdHJldHVybiByZXQucXVldWVcblx0XHRcdH0sXG5cdFx0XHR1bmxvY2soIGxvY2sgKSB7XG5cdFx0XHRcdHBhbmxvY2sgPSBwYW5sb2NrLmZpbHRlciggbCA9PiBsICE9IGxvY2sgKVxuXHRcdFx0XHRsZXQgcCA9IHBhbmxvY2tbIDAgXSB8fCBwYW5cblx0XHRcdFx0aWYgKCBwLmRpcnR5ICkge1xuXHRcdFx0XHRcdHAuZGlydHkgPSBmYWxzZVxuXHRcdFx0XHRcdHNlbmRwYW4oIGBwYW5gLCBgdW5sb2NrZWRgIClcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9LCBgYCApXG5cdH1cblxuXHRmdW5jdGlvbiBzZW5kcGFuKCB0eXBlLCBkaXJlY3Rpb24sIHB0LCBkZXRhaWwgKSB7XG5cdFx0bGV0IGRhdGEgPSBzZW5kKCB0eXBlLCBkaXJlY3Rpb24sIHB0LCBkZXRhaWwgKVxuXHRcdGlmICggcGFuICkge1xuXHRcdFx0aWYgKCBwYW5sb2NrICYmIHBhbmxvY2subGVuZ3RoICkge1xuXHRcdFx0XHRwYW5sb2NrWyAwIF0ucXVldWUucHVzaCggZGF0YSApXG5cdFx0XHRcdHBhbmxvY2suZm9yRWFjaCggKCBwLCBpICkgPT4gaSA+IDAgJiYgKCBwLmRpcnR5ID0gdHJ1ZSApIClcblx0XHRcdFx0cGFuLmRpcnR5ID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwYW4ucXVldWUucHVzaCggZGF0YSApXG5cdFx0fVxuXHR9XG5cblx0bGV0IHByZXNzVGltZW91dFxuXHRsZXQgc3RvcHBlZFRpbWVvdXRcblx0Y28uZGVmZXIoICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQoIHByZXNzVGltZW91dCApXG5cdFx0Y2xlYXJUaW1lb3V0KCBzdG9wcGVkVGltZW91dCApXG5cdH0gKVxuXG5cdHByZXNzVGltZW91dCA9IHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRwcmVzc2VkID0gdHJ1ZVxuXHRcdHNlbmQoIGBwcmVzc2AgKVxuXHR9LCBQUkVTU19USU1FT1VUIClcblxuXHRmdW5jdGlvbiBzdGFydFN0b3BwZWRUaW1lb3V0KCkge1xuXHRcdGNsZWFyVGltZW91dCggc3RvcHBlZFRpbWVvdXQgKVxuXHRcdHN0b3BwZWRUaW1lb3V0ID0gc2V0VGltZW91dCggKCkgPT4ge1xuXHRcdFx0ZW5zdXJlcGFuKClcblx0XHRcdHNlbmRwYW4oIGBzdG9wYCApXG5cdFx0XHRzdGFydFN0b3BwZWRUaW1lb3V0KClcblx0XHR9LCBQUkVTU19USU1FT1VUIClcblx0fVxuXG5cdHN0YXJ0U3RvcHBlZFRpbWVvdXQoKVxuXG5cdFRSQUNFICYmIFRSQUNFKCBgZW50ZXJgLCB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSwgdDogZXZlbnQudGltZVN0YW1wIH0gKVxuXG5cdGxldCBzdG9wUG9pbnQgPSBldmVudFxuXG5cdGZvciAoIGxldCBwdDsgcHQgPSB5aWVsZCBldmVudC5kZXRhaWwubmV4dDsgKSB7XG5cdFx0aWYgKCBUUkFDRSApIHtcblx0XHRcdCggYWxsIHx8ICggYWxsID0gW10gKSApLnB1c2goIHsgeDogcHQucGFnZVgsIHk6IHB0LnBhZ2VZLCB0OiBwdC50aW1lU3RhbXAgLSBldmVudC50aW1lU3RhbXAgfSApXG5cdFx0XHRUUkFDRSggYG5leHRgLCBhbGwgKVxuXHRcdH1cblx0XHRpZiAoIGxhc3QudGltZVN0YW1wIC0gZXZlbnQudGltZVN0YW1wID4gU1dJUEVfVElNRU9VVCApXG5cdFx0XHR0cmFjZSA9IG51bGxcblxuXHRcdGxldCBsb25nbW92ZSA9IHNxdWFyZURpc3RhbmNlKCBwdCwgc3RvcFBvaW50ICkgPiBQUkVTU19NT1ZFX09VVCAqIFBSRVNTX01PVkVfT1VUXG5cdFx0aWYgKCBsb25nbW92ZSApIHtcblx0XHRcdHN0b3BQb2ludCA9IHB0XG5cdFx0XHRzdGFydFN0b3BwZWRUaW1lb3V0KClcblx0XHR9XG5cblx0XHRpZiAoIGxvbmdtb3ZlIHx8ICF0cmFjZSB8fCB0cmFjZS5sZW5ndGggPiAxICkge1xuXHRcdFx0aWYgKCBwcmVzc2VkID09IG51bGwgKSB7XG5cdFx0XHRcdHByZXNzZWQgPSBmYWxzZVxuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHByZXNzVGltZW91dCApXG5cdFx0XHR9XG5cdFx0XHRsZXQgZHggPSBwdC5wYWdlWCAtIGxhc3QucGFnZVhcblx0XHRcdGxldCBkeSA9IHB0LnBhZ2VZIC0gbGFzdC5wYWdlWVxuXHRcdFx0aWYgKCBkeCB8fCBkeSApIHtcblx0XHRcdFx0bGV0IHNpemV4ID0gTWF0aC5hYnMoIGR4IClcblx0XHRcdFx0bGV0IHNpemV5ID0gTWF0aC5hYnMoIGR5IClcblx0XHRcdFx0bGV0IHByZXYgPSBsYXN0XG5cdFx0XHRcdGlmICggdHJhY2UgKVxuXHRcdFx0XHRcdHRyYWNlLnB1c2goIGxhc3QgKVxuXHRcdFx0XHRsYXN0ID0gcHRcblx0XHRcdFx0bGV0IGRpcmVjdGlvbiA9IGBgXG5cdFx0XHRcdGlmICggc2l6ZXggPj0gc2l6ZXkgJiYgZHggPiAwIClcblx0XHRcdFx0XHRkaXJlY3Rpb24gPSBgcmlnaHRgXG5cdFx0XHRcdGVsc2UgaWYgKCBzaXpleCA+PSBzaXpleSAmJiBkeCA8IDAgKVxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9IGBsZWZ0YFxuXHRcdFx0XHRlbHNlIGlmICggc2l6ZXggPCBzaXpleSAmJiBkeSA+IDAgKVxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9IGBkb3duYFxuXHRcdFx0XHRlbHNlIGlmICggc2l6ZXggPCBzaXpleSAmJiBkeSA8IDAgKVxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9IGB1cGBcblx0XHRcdFx0ZW5zdXJlcGFuKCBkaXJlY3Rpb24gKVxuXHRcdFx0XHRzZW5kcGFuKCBgcGFuYCwgZGlyZWN0aW9uLCBsYXN0IClcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y2xlYXJUaW1lb3V0KCBwcmVzc1RpbWVvdXQgKVxuXHRpZiAoIGxhc3QudGltZVN0YW1wIC0gZXZlbnQudGltZVN0YW1wIDwgU1dJUEVfVElNRU9VVCAmJiB0cmFjZSAmJiB0cmFjZS5sZW5ndGggPiAyICkge1xuXHRcdC8vIHJlbW92ZSBmaXJzdCBwb2ludCB0byBlbGltaW5hdGUgdG91Y2ggYm91bmNpbmcgZWZmZWN0XG5cdFx0dHJhY2Uuc2hpZnQoKVxuXHRcdGxldCB0cmFjZVggPSB0cmFjZS5tYXAoIGdldFggKVxuXHRcdGxldCB0cmFjZVkgPSB0cmFjZS5tYXAoIGdldFkgKVxuXHRcdGxldCBib3VuZHMgPSB7XG5cdFx0XHR4OiBNYXRoLm1heCggLi4udHJhY2VYICkgLSBNYXRoLm1pbiggLi4udHJhY2VYICksXG5cdFx0XHR5OiBNYXRoLm1heCggLi4udHJhY2VZICkgLSBNYXRoLm1pbiggLi4udHJhY2VZICksXG5cdFx0fVxuXHRcdGxldCBkaXJlY3Rpb24gPSBgYFxuXHRcdGlmICggYm91bmRzLnggPiBib3VuZHMueSAmJiB0cmFjZVguZXZlcnkoIGluY3JlYXNpbmcgKSApXG5cdFx0XHRkaXJlY3Rpb24gPSBgcmlnaHRgXG5cdFx0ZWxzZSBpZiAoIGJvdW5kcy54ID4gYm91bmRzLnkgJiYgdHJhY2VYLmV2ZXJ5KCBkZWNyZWFzaW5nICkgKVxuXHRcdFx0ZGlyZWN0aW9uID0gYGxlZnRgXG5cdFx0ZWxzZSBpZiAoIGJvdW5kcy54IDwgYm91bmRzLnkgJiYgdHJhY2VZLmV2ZXJ5KCBpbmNyZWFzaW5nICkgKVxuXHRcdFx0ZGlyZWN0aW9uID0gYGRvd25gXG5cdFx0ZWxzZSBpZiAoIGJvdW5kcy54IDwgYm91bmRzLnkgJiYgdHJhY2VZLmV2ZXJ5KCBkZWNyZWFzaW5nICkgKVxuXHRcdFx0ZGlyZWN0aW9uID0gYHVwYFxuXHRcdGlmICggZGlyZWN0aW9uICkge1xuXHRcdFx0c3dpcGVkID0gdHJ1ZVxuXHRcdFx0c2VuZHBhbiggYHN3aXBlYCwgZGlyZWN0aW9uLCBsYXN0IClcblx0XHR9XG5cdH1cblx0aWYgKCAhcHJlc3NlZCAmJiAhc3dpcGVkICYmICFwYW4gKVxuXHRcdHNlbmRwYW4oIGB0YXBgIClcblx0VFJBQ0UgJiYgVFJBQ0UoIGBkb25lYCwgYWxsIClcbn0gKSApXG4iLCJsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgZGl2YCApLnN0eWxlXG5pZiAoICEoIGB0cmFuc2Zvcm1gIGluIHN0eWxlICkgJiYgKCBgd2Via2l0VHJhbnNmb3JtYCBpbiBzdHlsZSApICkge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHdpbmRvdy5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZSwgYHRyYW5zZm9ybWAsIHtcblx0XHRnZXQoKSB7IHJldHVybiB0aGlzLndlYmtpdFRyYW5zZm9ybSB9LFxuXHRcdHNldCggdmFsdWUgKSB7IHRoaXMud2Via2l0VHJhbnNmb3JtID0gdmFsdWUgfSxcblx0fSApXG59XG5cbmZ1bmN0aW9uKiBpdGVyYXRlT3Zlckl0ZW0oKSB7XG5cdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgKytpIClcblx0XHR5aWVsZCB0aGlzLml0ZW0oIGkgKVxufVxuXG5mb3IgKCBsZXQgQ2xhc3Mgb2YgWyBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24gXSApXG5cdGlmICggIUNsYXNzLnByb3RvdHlwZVsgU3ltYm9sLml0ZXJhdG9yIF0gKVxuXHRcdENsYXNzLnByb3RvdHlwZVsgU3ltYm9sLml0ZXJhdG9yIF0gPSBpdGVyYXRlT3Zlckl0ZW1cbiIsImV4cG9ydCBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IGV2ZW50ID0+IGV2ZW50ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuZXhwb3J0IGNvbnN0IFN1Ym1pdCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdGV2ZW50ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0bGV0IGMgPSB0aGlzXG5cdHdoaWxlICggYyAmJiAhKCBjIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50ICkgKVxuXHRcdGMgPSBjLnBhcmVudE5vZGVcblx0aWYgKCBjIClcblx0XHRjLmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudCggYHN1Ym1pdGAsIG51bGwgKSApXG5cdHJldHVybiBmYWxzZVxufVxuXG5jb25zdCBub0JvcmRlcnMgPSBgYm9yZGVyOiBub25lOyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7YFxuXG5leHBvcnQgY29uc3QgQ2VudGVyZWQgPSAoIGF0dHIsIGNvbnRlbnQgKSA9PiB7XG5cdGxldCBzdHlsZSA9IG5vQm9yZGVyc1xuXHRsZXQgdHJhbnNmb3JtID0gYGBcblx0c3dpdGNoICggYXR0ci5ob3Jpem9udGFsICkge1xuXHRjYXNlIGBsZWZ0YDpcblx0XHRzdHlsZSArPSBgdGV4dC1hbGlnbjogbGVmdDtgXG5cdFx0YnJlYWtcblx0Y2FzZSBgcmlnaHRgOlxuXHRcdHN0eWxlICs9IGB0ZXh0LWFsaWduOiByaWdodDtgXG5cdFx0YnJlYWtcblx0Y2FzZSBgY2VudGVyYDpcblx0Y2FzZSBgYDpcblx0Y2FzZSB1bmRlZmluZWQ6XG5cdGNhc2UgbnVsbDpcblx0XHRzdHlsZSArPSBgdGV4dC1hbGlnbjogY2VudGVyO2Bcblx0XHRicmVha1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IG5ldyBFcnJvciggYGF0dHIuaG9yaXpvbnRhbDogJHsgYXR0ci5ob3Jpem9udGFsIH1gIClcblx0fVxuXHRzd2l0Y2ggKCBhdHRyLnZlcnRpY2FsICkge1xuXHRjYXNlIGB0b3BgOlxuXHRcdHN0eWxlICs9IGB0b3A6IDA7YFxuXHRcdGJyZWFrXG5cdGNhc2UgYGJvdHRvbWA6XG5cdFx0c3R5bGUgKz0gYGJvdHRvbTogMDtgXG5cdFx0YnJlYWtcblx0Y2FzZSBgY2VudGVyYDpcblx0Y2FzZSBgYDpcblx0Y2FzZSB1bmRlZmluZWQ6XG5cdGNhc2UgbnVsbDpcblx0XHRzdHlsZSArPSBgdG9wOiA1MCU7YFxuXHRcdHRyYW5zZm9ybSArPSBgdHJhbnNsYXRlWSggLTUwJSApYFxuXHRcdGJyZWFrXG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgYXR0ci52ZXJ0aWNhbDogJHsgYXR0ci52ZXJ0aWNhbCB9YCApXG5cdH1cblx0aWYgKCB0cmFuc2Zvcm0gKVxuXHRcdHN0eWxlICs9IGB0cmFuc2Zvcm06ICR7IHRyYW5zZm9ybSB9OyAtd2Via2l0LXRyYW5zZm9ybTogJHsgdHJhbnNmb3JtIH07YFxuXHRyZXR1cm4gPGRpdiBzdHlsZSA9IHsgYCR7IG5vQm9yZGVycyB9IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHBvc2l0aW9uOiByZWxhdGl2ZTtgIH0gPjxkaXYgc3R5bGUgPSB7IGAkeyBzdHlsZSB9IHdpZHRoOiAxMDAlOyBwb3NpdGlvbjogYWJzb2x1dGU7YCB9ID57IGNvbnRlbnQgfTwvZGl2PjwvZGl2PlxufVxuXG5leHBvcnQgY29uc3QgaXNFbXB0eU5vZGUgPSBub2RlID0+XG5cdG5vZGUgaW5zdGFuY2VvZiBDb21tZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBnbG9iYWwuUHJvY2Vzc2luZ0luc3RydWN0aW9uIHx8IG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmICFub2RlLm5vZGVWYWx1ZS50cmltKClcblxuZXhwb3J0IGNvbnN0IGltcG9ydFRlbXBsYXRlID0gdGVtcGxhdGUgPT4gZG9jdW1lbnQuaW1wb3J0Tm9kZSggdGVtcGxhdGUuY29udGVudCwgdHJ1ZSApXG5cbmV4cG9ydCBjb25zdCBpbXBvcnRFbGVtZW50ID0gdGVtcGxhdGUgPT4ge1xuXHRsZXQgcmV0ID0gaW1wb3J0VGVtcGxhdGUoIHRlbXBsYXRlIClcblx0aWYgKCAhcmV0IClcblx0XHRyZXR1cm4gbnVsbFxuXHR3aGlsZSAoIHJldC5sYXN0Q2hpbGQgJiYgaXNFbXB0eU5vZGUoIHJldC5sYXN0Q2hpbGQgKSApXG5cdFx0cmV0LnJlbW92ZUNoaWxkKCByZXQubGFzdENoaWxkIClcblx0d2hpbGUgKCByZXQuZmlyc3RDaGlsZCAmJiBpc0VtcHR5Tm9kZSggcmV0LmZpcnN0Q2hpbGQgKSApXG5cdFx0cmV0LnJlbW92ZUNoaWxkKCByZXQuZmlyc3RDaGlsZCApXG5cdGlmICggIXJldC5maXJzdENoaWxkIClcblx0XHRyZXR1cm4gbnVsbFxuXHRpZiAoIHJldC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxIClcblx0XHRyZXR1cm4gcmV0LmNoaWxkTm9kZXMuaXRlbSggMCApXG5cdGxldCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYHNwYW5gIClcblx0cm9vdC5hcHBlbmRDaGlsZCggcmV0IClcblx0cmV0dXJuIHJvb3Rcbn1cblxuZXhwb3J0IGNvbnN0IGltcG9ydENvbXBvbmVudCA9IHRlbXBsYXRlID0+IHtcblx0bGV0IGRhdGEgPSBpbXBvcnRFbGVtZW50KCB0ZW1wbGF0ZSApXG5cdGlmICggZGF0YSApIHtcblx0XHRsZXQgaW5pdCA9IGRhdGEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggYGluaXRgIClbIDAgXVxuXHRcdGlmICggaW5pdCAmJiBpbml0LnR5cGUgPT0gYGluaXRgICkge1xuXHRcdFx0bGV0IGZpbml0ID0gbmV3IEZ1bmN0aW9uKCBgY29tcG9uZW50YCwgW10uc2xpY2UuY2FsbCggaW5pdC5jaGlsZE5vZGVzICkubWFwKCB4ID0+IHguZGF0YSB8fCBgYCApLmpvaW4oIGBgICkgKVxuXHRcdFx0ZmluaXQoIGRhdGEgKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgY29uc3QgdGlja0NhY2hlID0gZnVuID0+IHtcblx0bGV0IGNhY2hlZFJlc3VsdFxuXHRsZXQgY2FjaGVkID0gZmFsc2VcblxuXHRsZXQgY2xlYXJDYWNoZSA9ICgpID0+IHtcblx0XHRjYWNoZWRSZXN1bHQgPSBudWxsXG5cdFx0Y2FjaGVkID0gZmFsc2Vcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCAhY2FjaGVkICkge1xuXHRcdFx0Y2FjaGVkUmVzdWx0ID0gZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHRcdFx0Y2FjaGVkID0gdHJ1ZVxuXHRcdFx0c2V0SW1tZWRpYXRlKCBjbGVhckNhY2hlIClcblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlZFJlc3VsdFxuXHR9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVFdmVudCA9ICggdHlwZSwgZGV0YWlsLCBvbiApID0+IHtcblx0bGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCB0eXBlLCB7IGRldGFpbCwgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9IClcblx0aWYgKCBvbiApIHtcblx0XHRldmVudC5wYWdlWCA9IG9uLnBhZ2VYXG5cdFx0ZXZlbnQucGFnZVkgPSBvbi5wYWdlWVxuXHRcdGV2ZW50LmNsaWVudFggPSBvbi5jbGllbnRYXG5cdFx0ZXZlbnQuY2xpZW50WSA9IG9uLmNsaWVudFlcblx0XHRldmVudC5zY3JlZW5YID0gb24uc2NyZWVuWFxuXHRcdGV2ZW50LnNjcmVlblkgPSBvbi5zY3JlZW5ZXG5cdH1cblx0cmV0dXJuIGV2ZW50XG59XG5cbmV4cG9ydCBjb25zdCBzZW5kRXZlbnQgPSAoIHR5cGUsIGRldGFpbCwgb24gKSA9PiBvbi50YXJnZXQuZGlzcGF0Y2hFdmVudCggY3JlYXRlRXZlbnQoIHR5cGUsIGRldGFpbCwgb24gKSApXG4iLCJpbXBvcnQgKiBhcyBVUkwgZnJvbSBcInVybFwiXG5cbmV4cG9ydCBjb25zdCBnZXQgPSAoIHVybCwgZW5jb2RpbmcgKSA9PiB4aHIoIHsgbWV0aG9kOiBgR0VUYCwgdXJsLCBlbmNvZGluZyB9IClcblxuZXhwb3J0IGNvbnN0IHBvc3QgPSAoIHVybCwgZGF0YSwgZW5jb2RpbmcgKSA9PiB4aHIoIHsgbWV0aG9kOiBgUE9TVGAsIHVybCwgZGF0YSwgZW5jb2RpbmcgfSApXG5cbmV4cG9ydCBjb25zdCB4aHIgPSBvcHRpb25zID0+IHtcblx0bGV0IHsgbWV0aG9kLCB1cmwsIGVuY29kaW5nLCBkYXRhIH0gPSBvcHRpb25zXG5cdGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXHRpZiAoIGVuY29kaW5nID09IGBiaW5hcnlgIClcblx0XHR4aHIucmVzcG9uc2VUeXBlID0gYGFycmF5YnVmZmVyYFxuXHRlbHNlXG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IGB0ZXh0YFxuXHRsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcblx0XHRsZXQgb25lcnJvciA9IGVycm9yID0+IHtcblx0XHRcdGlmICggdHlwZW9mIGVycm9yID09IGBzdHJpbmdgICkge1xuXHRcdFx0XHRlcnJvciA9IG5ldyBFcnJvciggZXJyb3IgKVxuXHRcdFx0XHRlcnJvci5tZXRob2QgPSBtZXRob2Rcblx0XHRcdFx0ZXJyb3IudXJsID0gdXJsXG5cdFx0XHR9XG5cdFx0XHRnbG9iYWwuX0FMRVJUICYmIGdsb2JhbC5fQUxFUlQoIGB0cnkgYCArIGVycm9yICsgdXJsIClcblx0XHRcdHJlamVjdCggZXJyb3IgKVxuXHRcdH1cblx0XHR4aHIub250aW1lb3V0ID0gKCkgPT4gb25lcnJvciggbmV3IEVycm9yKCBgVElNRU9VVCAkeyB1cmwgfWAgKSApXG5cdFx0eGhyLm9uZXJyb3IgPSBlID0+IG9uZXJyb3IoIGUgfHwgYEVSUk9SYCApXG5cdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcblx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT0geGhyLkRPTkUgJiYgeGhyLnN0YXR1cyA9PSAwIClcblx0XHRcdFx0eGhyLm9udGltZW91dCgpXG5cdFx0fVxuXHRcdHhoci5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHQvLyBhbGVydCggeGhyLnN0YXR1cyApXG5cdFx0XHRpZiAoIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMjk5IClcblx0XHRcdFx0cmV0dXJuIHJlc29sdmUoIHhoci5yZXNwb25zZSA9PSBudWxsID8gbnVsbCA6IHhoci5yZXNwb25zZSApXG5cdFx0XHRpZiAoIHhoci5zdGF0dXMgPT0gNDAxICkge1xuXHRcdFx0XHQvLyBhcHBlbmQgc29tZSB0aGluZyB0byB0aGUgcGFnZSB0byBmb3JjZSBzdGFuZGFsb25lIGJyb3dzZXIgdG8gc2hvdyBsb2dpbiBkaWFsb2dcblx0XHRcdFx0bGV0IHN1cmwgPSBVUkwucGFyc2UoIHVybCApXG5cdFx0XHRcdGlmICggc3VybC5ob3N0ICkge1xuXHRcdFx0XHRcdHN1cmwgPSBgJHsgc3VybC5wcm90b2NvbCB9Ly8keyBzdXJsLmhvc3QgfS9kdW1teS4keyBNYXRoLnJhbmRvbSgpIH0uanNgXG5cdFx0XHRcdFx0bGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGBzY3JpcHRgIClcblx0XHRcdFx0XHRzY3JpcHQuc3JjID0gc3VybFxuXHRcdFx0XHRcdC8vIGFsZXJ0KCBzdXJsIClcblx0XHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBzY3JpcHQgKVxuXHRcdFx0XHRcdHNldFRpbWVvdXQoICgpID0+IGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIHNjcmlwdCApLCAxMDAwIClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b25lcnJvciggYCR7IHhoci5zdGF0dXMgfSAkeyB4aHIuc3RhdHVzVGV4dCB9YCApXG5cdFx0fVxuXHR9IClcblx0c3dpdGNoICggZW5jb2RpbmcgKSB7XG5cdGNhc2UgYGltbXV0YWJsZWA6XG5cdFx0cHJvbWlzZSA9IHByb21pc2UudGhlbiggZGF0YSA9PiBnbG9iYWwuSW1tdXRhYmxlLmZyb21KUyggSlNPTi5wYXJzZSggZGF0YSApICkgKVxuXHRcdGJyZWFrXG5cdGNhc2UgYGJpbmFyeWA6XG5cdFx0cHJvbWlzZSA9IHByb21pc2UudGhlbiggZGF0YSA9PiBuZXcgVWludDhBcnJheSggZGF0YSApIClcblx0XHRicmVha1xuXHRjYXNlIGB0ZXh0YDpcblx0XHRicmVha1xuXHRkZWZhdWx0OlxuXHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oIGRhdGEgPT4ge1xuXHRcdFx0bGV0IGFjdHVhbEVuY29kaW5nID0gZW5jb2Rpbmdcblx0XHRcdGlmICggIWFjdHVhbEVuY29kaW5nICkge1xuXHRcdFx0XHRsZXQgY3QgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoIGBjb250ZW50LXR5cGVgICkgfHwgYGBcblx0XHRcdFx0aWYgKCBjdC5tYXRjaCggL15hcHBsaWNhdGlvblxcL2pzb24vICkgKVxuXHRcdFx0XHRcdGFjdHVhbEVuY29kaW5nID0gYGpzb25gXG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKCBhY3R1YWxFbmNvZGluZyApIHtcblx0XHRcdGNhc2UgYGpzb25gOlxuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YVxuXHRcdH0gKVxuXHR9XG5cdHhoci5vcGVuKCBtZXRob2QgfHwgYEdFVGAsIHVybCApXG5cdHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG5cdHhoci5zZW5kKCBkYXRhIClcblx0eGhyLnRoZW4gPSA6OnByb21pc2UudGhlblxuXHR4aHIuY2F0Y2ggPSA6OnByb21pc2UuY2F0Y2hcblx0cmV0dXJuIHhoclxufVxuXG5leHBvcnQgY29uc3QgdXJsID0gKCB1cmwsIHBhcmFtcyApID0+IHtcblx0aWYgKCBwYXJhbXMgKSB7XG5cdFx0bGV0IGRlbGltZXRlciA9IGA/YFxuXHRcdGZvciAoIGxldCBrIG9mIE9iamVjdC5rZXlzKCBwYXJhbXMgKSApIHtcblx0XHRcdHVybCArPSBgJHsgZGVsaW1ldGVyIH0keyBlbmNvZGVVUklDb21wb25lbnQoIGsgKSB9PSR7IGVuY29kZVVSSUNvbXBvbmVudCggcGFyYW1zWyBrIF0gKSB9YFxuXHRcdFx0ZGVsaW1ldGVyID0gYCZgXG5cdFx0fVxuXHR9XG5cdHJldHVybiB1cmxcbn1cbiIsIi8qXG5cbnZhZHppbSB6aWVua2FcblxuMjAxNS4wNS4xMVxuYWRkZWQgdGhpcy5zdG9wcGVkVHJhbnNpdGlvbiB0byBub3QgdG8gZmlyZSB0YXAgd2hlbiBzY3JvbGxpbmcgaXMgc3RvcHBlZCBieSB0aGF0IHRhcC5cblxuICovXG5cbi8qISBpU2Nyb2xsIHY1LjEuMyB+IChjKSAyMDA4LTIwMTQgTWF0dGVvIFNwaW5lbGxpIH4gaHR0cDovL2N1YmlxLm9yZy9saWNlbnNlICovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIE1hdGgpIHtcbnZhciByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXHR8fFxuXHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHR8fFxuXHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVx0XHR8fFxuXHRmdW5jdGlvbiAoY2FsbGJhY2spIHsgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7IH07XG5cbnZhciB1dGlscyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBtZSA9IHt9O1xuXG5cdHZhciBfZWxlbWVudFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cdHZhciBfdmVuZG9yID0gKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmVuZG9ycyA9IFsndCcsICd3ZWJraXRUJywgJ01velQnLCAnbXNUJywgJ09UJ10sXG5cdFx0XHR0cmFuc2Zvcm0sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB2ZW5kb3JzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdHRyYW5zZm9ybSA9IHZlbmRvcnNbaV0gKyAncmFuc2Zvcm0nO1xuXHRcdFx0aWYgKCB0cmFuc2Zvcm0gaW4gX2VsZW1lbnRTdHlsZSApIHJldHVybiB2ZW5kb3JzW2ldLnN1YnN0cigwLCB2ZW5kb3JzW2ldLmxlbmd0aC0xKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pKCk7XG5cblx0ZnVuY3Rpb24gX3ByZWZpeFN0eWxlIChzdHlsZSkge1xuXHRcdGlmICggX3ZlbmRvciA9PT0gZmFsc2UgKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKCBfdmVuZG9yID09PSAnJyApIHJldHVybiBzdHlsZTtcblx0XHRyZXR1cm4gX3ZlbmRvciArIHN0eWxlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3R5bGUuc3Vic3RyKDEpO1xuXHR9XG5cblx0bWUuZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uIGdldFRpbWUgKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG5cblx0bWUuZXh0ZW5kID0gZnVuY3Rpb24gKHRhcmdldCwgb2JqKSB7XG5cdFx0Zm9yICggdmFyIGkgaW4gb2JqICkge1xuXHRcdFx0dGFyZ2V0W2ldID0gb2JqW2ldO1xuXHRcdH1cblx0fTtcblxuXHRtZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChlbCwgdHlwZSwgZm4sIGNhcHR1cmUpIHtcblx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCAhIWNhcHR1cmUpO1xuXHR9O1xuXG5cdG1lLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuXHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sICEhY2FwdHVyZSk7XG5cdH07XG5cblx0bWUucHJlZml4UG9pbnRlckV2ZW50ID0gZnVuY3Rpb24gKHBvaW50ZXJFdmVudCkge1xuXHRcdHJldHVybiB3aW5kb3cuTVNQb2ludGVyRXZlbnQgPyBcblx0XHRcdCdNU1BvaW50ZXInICsgcG9pbnRlckV2ZW50LmNoYXJBdCg5KS50b1VwcGVyQ2FzZSgpICsgcG9pbnRlckV2ZW50LnN1YnN0cigxMCk6XG5cdFx0XHRwb2ludGVyRXZlbnQ7XG5cdH07XG5cblx0bWUubW9tZW50dW0gPSBmdW5jdGlvbiAoY3VycmVudCwgc3RhcnQsIHRpbWUsIGxvd2VyTWFyZ2luLCB3cmFwcGVyU2l6ZSwgZGVjZWxlcmF0aW9uKSB7XG5cdFx0dmFyIGRpc3RhbmNlID0gY3VycmVudCAtIHN0YXJ0LFxuXHRcdFx0c3BlZWQgPSBNYXRoLmFicyhkaXN0YW5jZSkgLyB0aW1lLFxuXHRcdFx0ZGVzdGluYXRpb24sXG5cdFx0XHRkdXJhdGlvbjtcblxuXHRcdGRlY2VsZXJhdGlvbiA9IGRlY2VsZXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gMC4wMDA2IDogZGVjZWxlcmF0aW9uO1xuXG5cdFx0ZGVzdGluYXRpb24gPSBjdXJyZW50ICsgKCBzcGVlZCAqIHNwZWVkICkgLyAoIDIgKiBkZWNlbGVyYXRpb24gKSAqICggZGlzdGFuY2UgPCAwID8gLTEgOiAxICk7XG5cdFx0ZHVyYXRpb24gPSBzcGVlZCAvIGRlY2VsZXJhdGlvbjtcblxuXHRcdGlmICggZGVzdGluYXRpb24gPCBsb3dlck1hcmdpbiApIHtcblx0XHRcdGRlc3RpbmF0aW9uID0gd3JhcHBlclNpemUgPyBsb3dlck1hcmdpbiAtICggd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApICkgOiBsb3dlck1hcmdpbjtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoZGVzdGluYXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9IGVsc2UgaWYgKCBkZXN0aW5hdGlvbiA+IDAgKSB7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IHdyYXBwZXJTaXplID8gd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApIDogMDtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoY3VycmVudCkgKyBkZXN0aW5hdGlvbjtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVzdGluYXRpb246IE1hdGgucm91bmQoZGVzdGluYXRpb24pLFxuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0fTtcblx0fTtcblxuXHR2YXIgX3RyYW5zZm9ybSA9IF9wcmVmaXhTdHlsZSgndHJhbnNmb3JtJyk7XG5cblx0bWUuZXh0ZW5kKG1lLCB7XG5cdFx0aGFzVHJhbnNmb3JtOiBfdHJhbnNmb3JtICE9PSBmYWxzZSxcblx0XHRoYXNQZXJzcGVjdGl2ZTogX3ByZWZpeFN0eWxlKCdwZXJzcGVjdGl2ZScpIGluIF9lbGVtZW50U3R5bGUsXG5cdFx0aGFzVG91Y2g6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyxcblx0XHRoYXNQb2ludGVyOiB3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudCwgLy8gSUUxMCBpcyBwcmVmaXhlZFxuXHRcdGhhc1RyYW5zaXRpb246IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvbicpIGluIF9lbGVtZW50U3R5bGVcblx0fSk7XG5cblx0Ly8gVGhpcyBzaG91bGQgZmluZCBhbGwgQW5kcm9pZCBicm93c2VycyBsb3dlciB0aGFuIGJ1aWxkIDUzNS4xOSAoYm90aCBzdG9jayBicm93c2VyIGFuZCB3ZWJ2aWV3KVxuXHRtZS5pc0JhZEFuZHJvaWQgPSAvQW5kcm9pZCAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uKSAmJiAhKC9DaHJvbWVcXC9cXGQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uKSk7XG5cblx0bWUuZXh0ZW5kKG1lLnN0eWxlID0ge30sIHtcblx0XHR0cmFuc2Zvcm06IF90cmFuc2Zvcm0sXG5cdFx0dHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbicpLFxuXHRcdHRyYW5zaXRpb25EdXJhdGlvbjogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uRHVyYXRpb24nKSxcblx0XHR0cmFuc2l0aW9uRGVsYXk6IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvbkRlbGF5JyksXG5cdFx0dHJhbnNmb3JtT3JpZ2luOiBfcHJlZml4U3R5bGUoJ3RyYW5zZm9ybU9yaWdpbicpXG5cdH0pO1xuXG5cdG1lLmhhc0NsYXNzID0gZnVuY3Rpb24gKGUsIGMpIHtcblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjICsgXCIoXFxcXHN8JClcIik7XG5cdFx0cmV0dXJuIHJlLnRlc3QoZS5jbGFzc05hbWUpO1xuXHR9O1xuXG5cdG1lLmFkZENsYXNzID0gZnVuY3Rpb24gKGUsIGMpIHtcblx0XHRpZiAoIG1lLmhhc0NsYXNzKGUsIGMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBuZXdjbGFzcyA9IGUuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG5cdFx0bmV3Y2xhc3MucHVzaChjKTtcblx0XHRlLmNsYXNzTmFtZSA9IG5ld2NsYXNzLmpvaW4oJyAnKTtcblx0fTtcblxuXHRtZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlLCBjKSB7XG5cdFx0aWYgKCAhbWUuaGFzQ2xhc3MoZSwgYykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgYyArIFwiKFxcXFxzfCQpXCIsICdnJyk7XG5cdFx0ZS5jbGFzc05hbWUgPSBlLmNsYXNzTmFtZS5yZXBsYWNlKHJlLCAnICcpO1xuXHR9O1xuXG5cdG1lLm9mZnNldCA9IGZ1bmN0aW9uIChlbCkge1xuXHRcdHZhciBsZWZ0ID0gLWVsLm9mZnNldExlZnQsXG5cdFx0XHR0b3AgPSAtZWwub2Zmc2V0VG9wO1xuXG5cdFx0Ly8ganNoaW50IC1XMDg0XG5cdFx0d2hpbGUgKGVsID0gZWwub2Zmc2V0UGFyZW50KSB7XG5cdFx0XHRsZWZ0IC09IGVsLm9mZnNldExlZnQ7XG5cdFx0XHR0b3AgLT0gZWwub2Zmc2V0VG9wO1xuXHRcdH1cblx0XHQvLyBqc2hpbnQgK1cwODRcblxuXHRcdHJldHVybiB7XG5cdFx0XHRsZWZ0OiBsZWZ0LFxuXHRcdFx0dG9wOiB0b3Bcblx0XHR9O1xuXHR9O1xuXG5cdG1lLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uID0gZnVuY3Rpb24gKGVsLCBleGNlcHRpb25zKSB7XG5cdFx0Zm9yICggdmFyIGkgaW4gZXhjZXB0aW9ucyApIHtcblx0XHRcdGlmICggZXhjZXB0aW9uc1tpXS50ZXN0KGVsW2ldKSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdG1lLmV4dGVuZChtZS5ldmVudFR5cGUgPSB7fSwge1xuXHRcdHRvdWNoc3RhcnQ6IDEsXG5cdFx0dG91Y2htb3ZlOiAxLFxuXHRcdHRvdWNoZW5kOiAxLFxuXG5cdFx0bW91c2Vkb3duOiAyLFxuXHRcdG1vdXNlbW92ZTogMixcblx0XHRtb3VzZXVwOiAyLFxuXG5cdFx0cG9pbnRlcmRvd246IDMsXG5cdFx0cG9pbnRlcm1vdmU6IDMsXG5cdFx0cG9pbnRlcnVwOiAzLFxuXG5cdFx0TVNQb2ludGVyRG93bjogMyxcblx0XHRNU1BvaW50ZXJNb3ZlOiAzLFxuXHRcdE1TUG9pbnRlclVwOiAzXG5cdH0pO1xuXG5cdG1lLmV4dGVuZChtZS5lYXNlID0ge30sIHtcblx0XHRxdWFkcmF0aWM6IHtcblx0XHRcdHN0eWxlOiAnY3ViaWMtYmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRyZXR1cm4gayAqICggMiAtIGsgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNpcmN1bGFyOiB7XG5cdFx0XHRzdHlsZTogJ2N1YmljLWJlemllcigwLjEsIDAuNTcsIDAuMSwgMSknLFx0Ly8gTm90IHByb3Blcmx5IFwiY2lyY3VsYXJcIiBidXQgdGhpcyBsb29rcyBiZXR0ZXIsIGl0IHNob3VsZCBiZSAoMC4wNzUsIDAuODIsIDAuMTY1LCAxKVxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoIDEgLSAoIC0tayAqIGsgKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YmFjazoge1xuXHRcdFx0c3R5bGU6ICdjdWJpYy1iZXppZXIoMC4xNzUsIDAuODg1LCAwLjMyLCAxLjI3NSknLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHZhciBiID0gNDtcblx0XHRcdFx0cmV0dXJuICggayA9IGsgLSAxICkgKiBrICogKCAoIGIgKyAxICkgKiBrICsgYiApICsgMTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGJvdW5jZToge1xuXHRcdFx0c3R5bGU6ICcnLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdGlmICggKCBrIC89IDEgKSA8ICggMSAvIDIuNzUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogayAqIGs7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGsgPCAoIDIgLyAyLjc1ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDEuNSAvIDIuNzUgKSApICogayArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGsgPCAoIDIuNSAvIDIuNzUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMi4yNSAvIDIuNzUgKSApICogayArIDAuOTM3NTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMi42MjUgLyAyLjc1ICkgKSAqIGsgKyAwLjk4NDM3NTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZWxhc3RpYzoge1xuXHRcdFx0c3R5bGU6ICcnLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHZhciBmID0gMC4yMixcblx0XHRcdFx0XHRlID0gMC40O1xuXG5cdFx0XHRcdGlmICggayA9PT0gMCApIHsgcmV0dXJuIDA7IH1cblx0XHRcdFx0aWYgKCBrID09IDEgKSB7IHJldHVybiAxOyB9XG5cblx0XHRcdFx0cmV0dXJuICggZSAqIE1hdGgucG93KCAyLCAtIDEwICogayApICogTWF0aC5zaW4oICggayAtIGYgLyA0ICkgKiAoIDIgKiBNYXRoLlBJICkgLyBmICkgKyAxICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRtZS50YXAgPSBmdW5jdGlvbiAoZSwgZXZlbnROYW1lKSB7XG5cdFx0dmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG5cdFx0ZXYuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0ZXYucGFnZVggPSBlLnBhZ2VYO1xuXHRcdGV2LnBhZ2VZID0gZS5wYWdlWTtcblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcblx0fTtcblxuXHRtZS5jbGljayA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0LFxuXHRcdFx0ZXY7XG5cblx0XHRpZiAoICEoLyhTRUxFQ1R8SU5QVVR8VEVYVEFSRUEpL2kpLnRlc3QodGFyZ2V0LnRhZ05hbWUpICkge1xuXHRcdFx0ZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblx0XHRcdGV2LmluaXRNb3VzZUV2ZW50KCdjbGljaycsIHRydWUsIHRydWUsIGUudmlldywgMSxcblx0XHRcdFx0dGFyZ2V0LnNjcmVlblgsIHRhcmdldC5zY3JlZW5ZLCB0YXJnZXQuY2xpZW50WCwgdGFyZ2V0LmNsaWVudFksXG5cdFx0XHRcdGUuY3RybEtleSwgZS5hbHRLZXksIGUuc2hpZnRLZXksIGUubWV0YUtleSxcblx0XHRcdFx0MCwgbnVsbCk7XG5cblx0XHRcdGV2Ll9jb25zdHJ1Y3RlZCA9IHRydWU7XG5cdFx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBtZTtcbn0pKCk7XG5cbmZ1bmN0aW9uIElTY3JvbGwgKGVsLCBvcHRpb25zKSB7XG5cdHRoaXMud3JhcHBlciA9IHR5cGVvZiBlbCA9PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpIDogZWw7XG5cdHRoaXMuc2Nyb2xsZXIgPSB0aGlzLndyYXBwZXIuY2hpbGRyZW5bMF07XG5cdHRoaXMuc2Nyb2xsZXJTdHlsZSA9IHRoaXMuc2Nyb2xsZXIuc3R5bGU7XHRcdC8vIGNhY2hlIHN0eWxlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcblxuXHR0aGlzLm9wdGlvbnMgPSB7XG5cblx0XHRyZXNpemVTY3JvbGxiYXJzOiB0cnVlLFxuXG5cdFx0bW91c2VXaGVlbFNwZWVkOiAyMCxcblxuXHRcdHNuYXBUaHJlc2hvbGQ6IDAuMzM0LFxuXG4vLyBJTlNFUlQgUE9JTlQ6IE9QVElPTlMgXG5cblx0XHRzdGFydFg6IDAsXG5cdFx0c3RhcnRZOiAwLFxuXHRcdHNjcm9sbFk6IHRydWUsXG5cdFx0ZGlyZWN0aW9uTG9ja1RocmVzaG9sZDogNSxcblx0XHRtb21lbnR1bTogdHJ1ZSxcblxuXHRcdGJvdW5jZTogdHJ1ZSxcblx0XHRib3VuY2VUaW1lOiA2MDAsXG5cdFx0Ym91bmNlRWFzaW5nOiAnJyxcblxuXHRcdHByZXZlbnREZWZhdWx0OiB0cnVlLFxuXHRcdHByZXZlbnREZWZhdWx0RXhjZXB0aW9uOiB7IHRhZ05hbWU6IC9eKElOUFVUfFRFWFRBUkVBfEJVVFRPTnxTRUxFQ1QpJC8gfSxcblxuXHRcdEhXQ29tcG9zaXRpbmc6IHRydWUsXG5cdFx0dXNlVHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1c2VUcmFuc2Zvcm06IHRydWVcblx0fTtcblxuXHRmb3IgKCB2YXIgaSBpbiBvcHRpb25zICkge1xuXHRcdHRoaXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0aW9uc1xuXHR0aGlzLnRyYW5zbGF0ZVogPSB0aGlzLm9wdGlvbnMuSFdDb21wb3NpdGluZyAmJiB1dGlscy5oYXNQZXJzcGVjdGl2ZSA/ICcgdHJhbnNsYXRlWigwKScgOiAnJztcblxuXHR0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiA9IHV0aWxzLmhhc1RyYW5zaXRpb24gJiYgdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb247XG5cdHRoaXMub3B0aW9ucy51c2VUcmFuc2Zvcm0gPSB1dGlscy5oYXNUcmFuc2Zvcm0gJiYgdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybTtcblxuXHR0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09PSB0cnVlID8gJ3ZlcnRpY2FsJyA6IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoO1xuXHR0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgPSAhdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggJiYgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0O1xuXG5cdC8vIElmIHlvdSB3YW50IGV2ZW50UGFzc3Rocm91Z2ggSSBoYXZlIHRvIGxvY2sgb25lIG9mIHRoZSBheGVzXG5cdHRoaXMub3B0aW9ucy5zY3JvbGxZID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ3ZlcnRpY2FsJyA/IGZhbHNlIDogdGhpcy5vcHRpb25zLnNjcm9sbFk7XG5cdHRoaXMub3B0aW9ucy5zY3JvbGxYID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ2hvcml6b250YWwnID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2Nyb2xsWDtcblxuXHQvLyBXaXRoIGV2ZW50UGFzc3Rocm91Z2ggd2UgYWxzbyBuZWVkIGxvY2tEaXJlY3Rpb24gbWVjaGFuaXNtXG5cdHRoaXMub3B0aW9ucy5mcmVlU2Nyb2xsID0gdGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgJiYgIXRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoO1xuXHR0aGlzLm9wdGlvbnMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID8gMCA6IHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkO1xuXG5cdHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmcgPSB0eXBlb2YgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyA9PSAnc3RyaW5nJyA/IHV0aWxzLmVhc2VbdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZ10gfHwgdXRpbHMuZWFzZS5jaXJjdWxhciA6IHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmc7XG5cblx0dGhpcy5vcHRpb25zLnJlc2l6ZVBvbGxpbmcgPSB0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyA9PT0gdW5kZWZpbmVkID8gNjAgOiB0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZztcblxuXHRpZiAoIHRoaXMub3B0aW9ucy50YXAgPT09IHRydWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnRhcCA9ICd0YXAnO1xuXHR9XG5cblx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rU2Nyb2xsYmFycyA9PSAnc2NhbGUnICkge1xuXHRcdHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uID0gZmFsc2U7XG5cdH1cblxuXHR0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb24gPyAtMSA6IDE7XG5cblx0aWYgKCB0aGlzLm9wdGlvbnMucHJvYmVUeXBlID09IDMgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gPSBmYWxzZTtcdH1cblxuLy8gSU5TRVJUIFBPSU5UOiBOT1JNQUxJWkFUSU9OXG5cblx0Ly8gU29tZSBkZWZhdWx0c1x0XG5cdHRoaXMueCA9IDA7XG5cdHRoaXMueSA9IDA7XG5cdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cdHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4vLyBJTlNFUlQgUE9JTlQ6IERFRkFVTFRTXG5cblx0dGhpcy5faW5pdCgpO1xuXHR0aGlzLnJlZnJlc2goKTtcblxuXHR0aGlzLnNjcm9sbFRvKHRoaXMub3B0aW9ucy5zdGFydFgsIHRoaXMub3B0aW9ucy5zdGFydFkpO1xuXHR0aGlzLmVuYWJsZSgpO1xufVxuXG5JU2Nyb2xsLnByb3RvdHlwZSA9IHtcblx0dmVyc2lvbjogJzUuMS4zJyxcblxuXHRfaW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMgfHwgdGhpcy5vcHRpb25zLmluZGljYXRvcnMgKSB7XG5cdFx0XHR0aGlzLl9pbml0SW5kaWNhdG9ycygpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLm1vdXNlV2hlZWwgKSB7XG5cdFx0XHR0aGlzLl9pbml0V2hlZWwoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dGhpcy5faW5pdFNuYXAoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyApIHtcblx0XHRcdHRoaXMuX2luaXRLZXlzKCk7XG5cdFx0fVxuXG4vLyBJTlNFUlQgUE9JTlQ6IF9pbml0XG5cblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcblxuXHRcdHRoaXMuX2V4ZWNFdmVudCgnZGVzdHJveScpO1xuXHR9LFxuXG5cdF90cmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggZS50YXJnZXQgIT0gdGhpcy5zY3JvbGxlciB8fCAhdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSgpO1xuXHRcdGlmICggIXRoaXMucmVzZXRQb3NpdGlvbih0aGlzLm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gUmVhY3QgdG8gbGVmdCBtb3VzZSBidXR0b24gb25seVxuXHRcdGlmICggdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT0gMSApIHtcblx0XHRcdGlmICggZS5idXR0b24gIT09IDAgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgKHRoaXMuaW5pdGlhdGVkICYmIHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdICE9PSB0aGlzLmluaXRpYXRlZCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgJiYgIXV0aWxzLmlzQmFkQW5kcm9pZCAmJiAhdXRpbHMucHJldmVudERlZmF1bHRFeGNlcHRpb24oZS50YXJnZXQsIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbikgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvaW50ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcblx0XHRcdHBvcztcblxuXHRcdHRoaXMuaW5pdGlhdGVkXHQ9IHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdO1xuXHRcdHRoaXMubW92ZWRcdFx0PSBmYWxzZTtcblx0XHR0aGlzLmRpc3RYXHRcdD0gMDtcblx0XHR0aGlzLmRpc3RZXHRcdD0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAwO1xuXG5cdFx0dGhpcy5fdHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdHRoaXMuc3RhcnRUaW1lID0gdXRpbHMuZ2V0VGltZSgpO1xuXG5cdFx0dGhpcy5zdG9wcGVkVHJhbnNpdGlvbiA9IGZhbHNlXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiB0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0dGhpcy5zdG9wcGVkVHJhbnNpdGlvbiA9IHRydWVcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHRcdHBvcyA9IHRoaXMuZ2V0Q29tcHV0ZWRQb3NpdGlvbigpO1xuXHRcdFx0dGhpcy5fdHJhbnNsYXRlKE1hdGgucm91bmQocG9zLngpLCBNYXRoLnJvdW5kKHBvcy55KSk7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH0gZWxzZSBpZiAoICF0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiB0aGlzLmlzQW5pbWF0aW5nICkge1xuXHRcdFx0dGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0YXJ0WCAgICA9IHRoaXMueDtcblx0XHR0aGlzLnN0YXJ0WSAgICA9IHRoaXMueTtcblx0XHR0aGlzLmFic1N0YXJ0WCA9IHRoaXMueDtcblx0XHR0aGlzLmFic1N0YXJ0WSA9IHRoaXMueTtcblx0XHR0aGlzLnBvaW50WCAgICA9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMucG9pbnRZICAgID0gcG9pbnQucGFnZVk7XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ2JlZm9yZVNjcm9sbFN0YXJ0Jyk7XG5cdH0sXG5cblx0X21vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkIHx8IHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdICE9PSB0aGlzLmluaXRpYXRlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCApIHtcdC8vIGluY3JlYXNlcyBwZXJmb3JtYW5jZSBvbiBBbmRyb2lkPyBUT0RPOiBjaGVjayFcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnRcdFx0PSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0ZGVsdGFYXHRcdD0gcG9pbnQucGFnZVggLSB0aGlzLnBvaW50WCxcblx0XHRcdGRlbHRhWVx0XHQ9IHBvaW50LnBhZ2VZIC0gdGhpcy5wb2ludFksXG5cdFx0XHR0aW1lc3RhbXBcdD0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0bmV3WCwgbmV3WSxcblx0XHRcdGFic0Rpc3RYLCBhYnNEaXN0WTtcblxuXHRcdHRoaXMucG9pbnRYXHRcdD0gcG9pbnQucGFnZVg7XG5cdFx0dGhpcy5wb2ludFlcdFx0PSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuZGlzdFhcdFx0Kz0gZGVsdGFYO1xuXHRcdHRoaXMuZGlzdFlcdFx0Kz0gZGVsdGFZO1xuXHRcdGFic0Rpc3RYXHRcdD0gTWF0aC5hYnModGhpcy5kaXN0WCk7XG5cdFx0YWJzRGlzdFlcdFx0PSBNYXRoLmFicyh0aGlzLmRpc3RZKTtcblxuXHRcdC8vIFdlIG5lZWQgdG8gbW92ZSBhdCBsZWFzdCAxMCBwaXhlbHMgZm9yIHRoZSBzY3JvbGxpbmcgdG8gaW5pdGlhdGVcblx0XHRpZiAoIHRpbWVzdGFtcCAtIHRoaXMuZW5kVGltZSA+IDMwMCAmJiAoYWJzRGlzdFggPCAxMCAmJiBhYnNEaXN0WSA8IDEwKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB5b3UgYXJlIHNjcm9sbGluZyBpbiBvbmUgZGlyZWN0aW9uIGxvY2sgdGhlIG90aGVyXG5cdFx0aWYgKCAhdGhpcy5kaXJlY3Rpb25Mb2NrZWQgJiYgIXRoaXMub3B0aW9ucy5mcmVlU2Nyb2xsICkge1xuXHRcdFx0aWYgKCBhYnNEaXN0WCA+IGFic0Rpc3RZICsgdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQgKSB7XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uTG9ja2VkID0gJ2gnO1x0XHQvLyBsb2NrIGhvcml6b250YWxseVxuXHRcdFx0fSBlbHNlIGlmICggYWJzRGlzdFkgPj0gYWJzRGlzdFggKyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZCApIHtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAndic7XHRcdC8vIGxvY2sgdmVydGljYWxseVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAnbic7XHRcdC8vIG5vIGxvY2tcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZGlyZWN0aW9uTG9ja2VkID09ICdoJyApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ3ZlcnRpY2FsJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ2hvcml6b250YWwnICkge1xuXHRcdFx0XHR0aGlzLmluaXRpYXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhWSA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5kaXJlY3Rpb25Mb2NrZWQgPT0gJ3YnICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICd2ZXJ0aWNhbCcgKSB7XG5cdFx0XHRcdHRoaXMuaW5pdGlhdGVkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGFYID0gMDtcblx0XHR9XG5cblx0XHRkZWx0YVggPSB0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgPyBkZWx0YVggOiAwO1xuXHRcdGRlbHRhWSA9IHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyBkZWx0YVkgOiAwO1xuXG5cdFx0bmV3WCA9IHRoaXMueCArIGRlbHRhWDtcblx0XHRuZXdZID0gdGhpcy55ICsgZGVsdGFZO1xuXG5cdFx0Ly8gU2xvdyBkb3duIGlmIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJpZXNcblx0XHRpZiAoIG5ld1ggPiAwIHx8IG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5vcHRpb25zLmJvdW5jZSA/IHRoaXMueCArIGRlbHRhWCAvIDMgOiBuZXdYID4gMCA/IDAgOiB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXHRcdGlmICggbmV3WSA+IDAgfHwgbmV3WSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdG5ld1kgPSB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy55ICsgZGVsdGFZIC8gMyA6IG5ld1kgPiAwID8gMCA6IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHR0aGlzLmRpcmVjdGlvblggPSBkZWx0YVggPiAwID8gLTEgOiBkZWx0YVggPCAwID8gMSA6IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gZGVsdGFZID4gMCA/IC0xIDogZGVsdGFZIDwgMCA/IDEgOiAwO1xuXG5cdFx0aWYgKCAhdGhpcy5tb3ZlZCApIHtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdmVkID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3RyYW5zbGF0ZShuZXdYLCBuZXdZKTtcblxuLyogUkVQTEFDRSBTVEFSVDogX21vdmUgKi9cblx0XHRpZiAoIHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gMzAwICkge1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSB0aW1lc3RhbXA7XG5cdFx0XHR0aGlzLnN0YXJ0WCA9IHRoaXMueDtcblx0XHRcdHRoaXMuc3RhcnRZID0gdGhpcy55O1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcm9iZVR5cGUgPT0gMSApIHtcblx0XHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcm9iZVR5cGUgPiAxICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHR9XG4vKiBSRVBMQUNFIEVORDogX21vdmUgKi9cblxuXHR9LFxuXG5cdF9lbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkIHx8IHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdICE9PSB0aGlzLmluaXRpYXRlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAmJiAhdXRpbHMucHJldmVudERlZmF1bHRFeGNlcHRpb24oZS50YXJnZXQsIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbikgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvaW50ID0gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0bW9tZW50dW1YLFxuXHRcdFx0bW9tZW50dW1ZLFxuXHRcdFx0ZHVyYXRpb24gPSB1dGlscy5nZXRUaW1lKCkgLSB0aGlzLnN0YXJ0VGltZSxcblx0XHRcdG5ld1ggPSBNYXRoLnJvdW5kKHRoaXMueCksXG5cdFx0XHRuZXdZID0gTWF0aC5yb3VuZCh0aGlzLnkpLFxuXHRcdFx0ZGlzdGFuY2VYID0gTWF0aC5hYnMobmV3WCAtIHRoaXMuc3RhcnRYKSxcblx0XHRcdGRpc3RhbmNlWSA9IE1hdGguYWJzKG5ld1kgLSB0aGlzLnN0YXJ0WSksXG5cdFx0XHR0aW1lID0gMCxcblx0XHRcdGVhc2luZyA9ICcnO1xuXG5cdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IDA7XG5cdFx0dGhpcy5pbml0aWF0ZWQgPSAwO1xuXHRcdHRoaXMuZW5kVGltZSA9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdC8vIHJlc2V0IGlmIHdlIGFyZSBvdXRzaWRlIG9mIHRoZSBib3VuZGFyaWVzXG5cdFx0aWYgKCB0aGlzLnJlc2V0UG9zaXRpb24odGhpcy5vcHRpb25zLmJvdW5jZVRpbWUpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8obmV3WCwgbmV3WSk7XHQvLyBlbnN1cmVzIHRoYXQgdGhlIGxhc3QgcG9zaXRpb24gaXMgcm91bmRlZFxuXG5cdFx0Ly8gd2Ugc2Nyb2xsZWQgbGVzcyB0aGFuIDEwIHBpeGVsc1xuXHRcdGlmICggIXRoaXMubW92ZWQgKSB7XG5cdFx0XHRpZiAoICF0aGlzLnN0b3BwZWRUcmFuc2l0aW9uICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy50YXAgKSB7XG5cdFx0XHRcdFx0dXRpbHMudGFwKGUsIHRoaXMub3B0aW9ucy50YXApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuY2xpY2sgKSB7XG5cdFx0XHRcdFx0dXRpbHMuY2xpY2soZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxDYW5jZWwnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2V2ZW50cy5mbGljayAmJiBkdXJhdGlvbiA8IDIwMCAmJiBkaXN0YW5jZVggPCAxMDAgJiYgZGlzdGFuY2VZIDwgMTAwICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdmbGljaycpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHN0YXJ0IG1vbWVudHVtIGFuaW1hdGlvbiBpZiBuZWVkZWRcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb21lbnR1bSAmJiBkdXJhdGlvbiA8IDMwMCApIHtcblx0XHRcdG1vbWVudHVtWCA9IHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IHV0aWxzLm1vbWVudHVtKHRoaXMueCwgdGhpcy5zdGFydFgsIGR1cmF0aW9uLCB0aGlzLm1heFNjcm9sbFgsIHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLndyYXBwZXJXaWR0aCA6IDAsIHRoaXMub3B0aW9ucy5kZWNlbGVyYXRpb24pIDogeyBkZXN0aW5hdGlvbjogbmV3WCwgZHVyYXRpb246IDAgfTtcblx0XHRcdG1vbWVudHVtWSA9IHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB1dGlscy5tb21lbnR1bSh0aGlzLnksIHRoaXMuc3RhcnRZLCBkdXJhdGlvbiwgdGhpcy5tYXhTY3JvbGxZLCB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy53cmFwcGVySGVpZ2h0IDogMCwgdGhpcy5vcHRpb25zLmRlY2VsZXJhdGlvbikgOiB7IGRlc3RpbmF0aW9uOiBuZXdZLCBkdXJhdGlvbjogMCB9O1xuXHRcdFx0bmV3WCA9IG1vbWVudHVtWC5kZXN0aW5hdGlvbjtcblx0XHRcdG5ld1kgPSBtb21lbnR1bVkuZGVzdGluYXRpb247XG5cdFx0XHR0aW1lID0gTWF0aC5tYXgobW9tZW50dW1YLmR1cmF0aW9uLCBtb21lbnR1bVkuZHVyYXRpb24pO1xuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IDE7XG5cdFx0fVxuXG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dmFyIHNuYXAgPSB0aGlzLl9uZWFyZXN0U25hcChuZXdYLCBuZXdZKTtcblx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0dGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdYIC0gc25hcC54KSwgMTAwMCksXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdZIC0gc25hcC55KSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXHRcdFx0bmV3WCA9IHNuYXAueDtcblx0XHRcdG5ld1kgPSBzbmFwLnk7XG5cblx0XHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXHRcdFx0ZWFzaW5nID0gdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX2VuZFxuXG5cdFx0aWYgKCBuZXdYICE9IHRoaXMueCB8fCBuZXdZICE9IHRoaXMueSApIHtcblx0XHRcdC8vIGNoYW5nZSBlYXNpbmcgZnVuY3Rpb24gd2hlbiBzY3JvbGxlciBnb2VzIG91dCBvZiB0aGUgYm91bmRhcmllc1xuXHRcdFx0aWYgKCBuZXdYID4gMCB8fCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYIHx8IG5ld1kgPiAwIHx8IG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRcdGVhc2luZyA9IHV0aWxzLmVhc2UucXVhZHJhdGljO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIHRpbWUsIGVhc2luZyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG5cblx0XHR0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQucmVmcmVzaCgpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nKTtcblx0fSxcblxuXHRyZXNldFBvc2l0aW9uOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHZhciB4ID0gdGhpcy54LFxuXHRcdFx0eSA9IHRoaXMueTtcblxuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgfHwgdGhpcy54ID4gMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCB8fCB0aGlzLnkgPiAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy55IDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHRpZiAoIHggPT0gdGhpcy54ICYmIHkgPT0gdGhpcy55ICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJmID0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodDtcdFx0Ly8gRm9yY2UgcmVmbG93XG5cblx0XHR0aGlzLndyYXBwZXJXaWR0aFx0PSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cdFx0dGhpcy53cmFwcGVySGVpZ2h0XHQ9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IHJlZnJlc2ggKi9cblxuXHRcdHRoaXMuc2Nyb2xsZXJXaWR0aFx0PSB0aGlzLnNjcm9sbGVyLm9mZnNldFdpZHRoO1xuXHRcdHRoaXMuc2Nyb2xsZXJIZWlnaHRcdD0gdGhpcy5zY3JvbGxlci5vZmZzZXRIZWlnaHQ7XG5cblx0XHR0aGlzLm1heFNjcm9sbFhcdFx0PSB0aGlzLndyYXBwZXJXaWR0aCAtIHRoaXMuc2Nyb2xsZXJXaWR0aDtcblx0XHR0aGlzLm1heFNjcm9sbFlcdFx0PSB0aGlzLndyYXBwZXJIZWlnaHQgLSB0aGlzLnNjcm9sbGVySGVpZ2h0O1xuXG4vKiBSRVBMQUNFIEVORDogcmVmcmVzaCAqL1xuXG5cdFx0dGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsXHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxYICYmIHRoaXMubWF4U2Nyb2xsWCA8IDA7XG5cdFx0dGhpcy5oYXNWZXJ0aWNhbFNjcm9sbFx0XHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxZICYmIHRoaXMubWF4U2Nyb2xsWSA8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgKSB7XG5cdFx0XHR0aGlzLm1heFNjcm9sbFggPSAwO1xuXHRcdFx0dGhpcy5zY3JvbGxlcldpZHRoID0gdGhpcy53cmFwcGVyV2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHRoaXMubWF4U2Nyb2xsWSA9IDA7XG5cdFx0XHR0aGlzLnNjcm9sbGVySGVpZ2h0ID0gdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdH1cblxuXHRcdHRoaXMuZW5kVGltZSA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXG5cdFx0dGhpcy53cmFwcGVyT2Zmc2V0ID0gdXRpbHMub2Zmc2V0KHRoaXMud3JhcHBlcik7XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ3JlZnJlc2gnKTtcblxuXHRcdHRoaXMucmVzZXRQb3NpdGlvbigpO1xuXG4vLyBJTlNFUlQgUE9JTlQ6IF9yZWZyZXNoXG5cblx0fSxcblxuXHRvbjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2goZm4pO1xuXHR9LFxuXG5cdG9mZjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5pbmRleE9mKGZuKTtcblxuXHRcdGlmICggaW5kZXggPiAtMSApIHtcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSxcblxuXHRfZXhlY0V2ZW50OiBmdW5jdGlvbiAodHlwZSkge1xuXHRcdGlmICggIXRoaXMuX2V2ZW50c1t0eXBlXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsID0gdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcblxuXHRcdGlmICggIWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdW2ldLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0eCA9IHRoaXMueCArIHg7XG5cdFx0eSA9IHRoaXMueSArIHk7XG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRzY3JvbGxUbzogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB1dGlscy5lYXNlLmNpcmN1bGFyO1xuXG5cdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRpbWUgPiAwO1xuXG5cdFx0aWYgKCAhdGltZSB8fCAodGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgZWFzaW5nLnN0eWxlKSApIHtcblx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbihlYXNpbmcuc3R5bGUpO1xuXHRcdFx0dGhpcy5fdHJhbnNpdGlvblRpbWUodGltZSk7XG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FuaW1hdGUoeCwgeSwgdGltZSwgZWFzaW5nLmZuKTtcblx0XHR9XG5cdH0sXG5cblx0c2Nyb2xsVG9FbGVtZW50OiBmdW5jdGlvbiAoZWwsIHRpbWUsIG9mZnNldFgsIG9mZnNldFksIGVhc2luZykge1xuXHRcdGVsID0gZWwubm9kZVR5cGUgPyBlbCA6IHRoaXMuc2Nyb2xsZXIucXVlcnlTZWxlY3RvcihlbCk7XG5cblx0XHRpZiAoICFlbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcG9zID0gdXRpbHMub2Zmc2V0KGVsKTtcblxuXHRcdHBvcy5sZWZ0IC09IHRoaXMud3JhcHBlck9mZnNldC5sZWZ0O1xuXHRcdHBvcy50b3AgIC09IHRoaXMud3JhcHBlck9mZnNldC50b3A7XG5cblx0XHQvLyBpZiBvZmZzZXRYL1kgYXJlIHRydWUgd2UgY2VudGVyIHRoZSBlbGVtZW50IHRvIHRoZSBzY3JlZW5cblx0XHRpZiAoIG9mZnNldFggPT09IHRydWUgKSB7XG5cdFx0XHRvZmZzZXRYID0gTWF0aC5yb3VuZChlbC5vZmZzZXRXaWR0aCAvIDIgLSB0aGlzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyKTtcblx0XHR9XG5cdFx0aWYgKCBvZmZzZXRZID09PSB0cnVlICkge1xuXHRcdFx0b2Zmc2V0WSA9IE1hdGgucm91bmQoZWwub2Zmc2V0SGVpZ2h0IC8gMiAtIHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRwb3MubGVmdCAtPSBvZmZzZXRYIHx8IDA7XG5cdFx0cG9zLnRvcCAgLT0gb2Zmc2V0WSB8fCAwO1xuXG5cdFx0cG9zLmxlZnQgPSBwb3MubGVmdCA+IDAgPyAwIDogcG9zLmxlZnQgPCB0aGlzLm1heFNjcm9sbFggPyB0aGlzLm1heFNjcm9sbFggOiBwb3MubGVmdDtcblx0XHRwb3MudG9wICA9IHBvcy50b3AgID4gMCA/IDAgOiBwb3MudG9wICA8IHRoaXMubWF4U2Nyb2xsWSA/IHRoaXMubWF4U2Nyb2xsWSA6IHBvcy50b3A7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkIHx8IHRpbWUgPT09IG51bGwgfHwgdGltZSA9PT0gJ2F1dG8nID8gTWF0aC5tYXgoTWF0aC5hYnModGhpcy54LXBvcy5sZWZ0KSwgTWF0aC5hYnModGhpcy55LXBvcy50b3ApKSA6IHRpbWU7XG5cblx0XHR0aGlzLnNjcm9sbFRvKHBvcy5sZWZ0LCBwb3MudG9wLCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXG5cdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSB0aW1lICsgJ21zJztcblxuXHRcdGlmICggIXRpbWUgJiYgdXRpbHMuaXNCYWRBbmRyb2lkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSAnMC4wMDFzJztcblx0XHR9XG5cblxuXHRcdGlmICggdGhpcy5pbmRpY2F0b3JzICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udHJhbnNpdGlvblRpbWUodGltZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cbi8vIElOU0VSVCBQT0lOVDogX3RyYW5zaXRpb25UaW1lXG5cblx0fSxcblxuXHRfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbl0gPSBlYXNpbmc7XG5cblxuXHRcdGlmICggdGhpcy5pbmRpY2F0b3JzICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKGVhc2luZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cbi8vIElOU0VSVCBQT0lOVDogX3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvblxuXG5cdH0sXG5cblx0X3RyYW5zbGF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy51c2VUcmFuc2Zvcm0gKSB7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IF90cmFuc2xhdGUgKi9cblxuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0gPSAndHJhbnNsYXRlKCcgKyB4ICsgJ3B4LCcgKyB5ICsgJ3B4KScgKyB0aGlzLnRyYW5zbGF0ZVo7XG5cbi8qIFJFUExBQ0UgRU5EOiBfdHJhbnNsYXRlICovXG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IE1hdGgucm91bmQoeCk7XG5cdFx0XHR5ID0gTWF0aC5yb3VuZCh5KTtcblx0XHRcdHRoaXMuc2Nyb2xsZXJTdHlsZS5sZWZ0ID0geCArICdweCc7XG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGUudG9wID0geSArICdweCc7XG5cdFx0fVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cblx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JzW2ldLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0fVxuXHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNsYXRlXG5cblx0fSxcblxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdHZhciBldmVudFR5cGUgPSByZW1vdmUgPyB1dGlscy5yZW1vdmVFdmVudCA6IHV0aWxzLmFkZEV2ZW50LFxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5vcHRpb25zLmJpbmRUb1dyYXBwZXIgPyB0aGlzLndyYXBwZXIgOiB3aW5kb3c7XG5cblx0XHRldmVudFR5cGUod2luZG93LCAnb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzKTtcblx0XHRldmVudFR5cGUod2luZG93LCAncmVzaXplJywgdGhpcyk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5jbGljayApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICdjbGljaycsIHRoaXMsIHRydWUpO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlTW91c2UgKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCAnbW91c2Vkb3duJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAnbW91c2VjYW5jZWwnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZXVwJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCB1dGlscy5oYXNQb2ludGVyICYmICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBvaW50ZXIgKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJkb3duJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmNhbmNlbCcpLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmICggdXRpbHMuaGFzVG91Y2ggJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlVG91Y2ggKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2hlbmQnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ3RyYW5zaXRpb25lbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ29UcmFuc2l0aW9uRW5kJywgdGhpcyk7XG5cdFx0ZXZlbnRUeXBlKHRoaXMuc2Nyb2xsZXIsICdNU1RyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0fSxcblxuXHRnZXRDb21wdXRlZFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuc2Nyb2xsZXIsIG51bGwpLFxuXHRcdFx0eCwgeTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeFt1dGlscy5zdHlsZS50cmFuc2Zvcm1dLnNwbGl0KCcpJylbMF0uc3BsaXQoJywgJyk7XG5cdFx0XHR4ID0gKyhtYXRyaXhbMTJdIHx8IG1hdHJpeFs0XSk7XG5cdFx0XHR5ID0gKyhtYXRyaXhbMTNdIHx8IG1hdHJpeFs1XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSArbWF0cml4LmxlZnQucmVwbGFjZSgvW14tXFxkLl0vZywgJycpO1xuXHRcdFx0eSA9ICttYXRyaXgudG9wLnJlcGxhY2UoL1teLVxcZC5dL2csICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyB4OiB4LCB5OiB5IH07XG5cdH0sXG5cblx0X2luaXRJbmRpY2F0b3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGludGVyYWN0aXZlID0gdGhpcy5vcHRpb25zLmludGVyYWN0aXZlU2Nyb2xsYmFycyxcblx0XHRcdGN1c3RvbVN0eWxlID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICE9ICdzdHJpbmcnLFxuXHRcdFx0aW5kaWNhdG9ycyA9IFtdLFxuXHRcdFx0aW5kaWNhdG9yO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5pbmRpY2F0b3JzID0gW107XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICkge1xuXHRcdFx0Ly8gVmVydGljYWwgc2Nyb2xsYmFyXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxZICkge1xuXHRcdFx0XHRpbmRpY2F0b3IgPSB7XG5cdFx0XHRcdFx0ZWw6IGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIoJ3YnLCBpbnRlcmFjdGl2ZSwgdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMpLFxuXHRcdFx0XHRcdGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZSxcblx0XHRcdFx0XHRkZWZhdWx0U2Nyb2xsYmFyczogdHJ1ZSxcblx0XHRcdFx0XHRjdXN0b21TdHlsZTogY3VzdG9tU3R5bGUsXG5cdFx0XHRcdFx0cmVzaXplOiB0aGlzLm9wdGlvbnMucmVzaXplU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRzaHJpbms6IHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGZhZGU6IHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRsaXN0ZW5YOiBmYWxzZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IuZWwpO1xuXHRcdFx0XHRpbmRpY2F0b3JzLnB1c2goaW5kaWNhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9yaXpvbnRhbCBzY3JvbGxiYXJcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbFggKSB7XG5cdFx0XHRcdGluZGljYXRvciA9IHtcblx0XHRcdFx0XHRlbDogY3JlYXRlRGVmYXVsdFNjcm9sbGJhcignaCcsIGludGVyYWN0aXZlLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyksXG5cdFx0XHRcdFx0aW50ZXJhY3RpdmU6IGludGVyYWN0aXZlLFxuXHRcdFx0XHRcdGRlZmF1bHRTY3JvbGxiYXJzOiB0cnVlLFxuXHRcdFx0XHRcdGN1c3RvbVN0eWxlOiBjdXN0b21TdHlsZSxcblx0XHRcdFx0XHRyZXNpemU6IHRoaXMub3B0aW9ucy5yZXNpemVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdHNocmluazogdGhpcy5vcHRpb25zLnNocmlua1Njcm9sbGJhcnMsXG5cdFx0XHRcdFx0ZmFkZTogdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGxpc3Rlblk6IGZhbHNlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvci5lbCk7XG5cdFx0XHRcdGluZGljYXRvcnMucHVzaChpbmRpY2F0b3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmluZGljYXRvcnMgKSB7XG5cdFx0XHQvLyBUT0RPOiBjaGVjayBjb25jYXQgY29tcGF0aWJpbGl0eVxuXHRcdFx0aW5kaWNhdG9ycyA9IGluZGljYXRvcnMuY29uY2F0KHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzKTtcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IGluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JzLnB1c2goIG5ldyBJbmRpY2F0b3IodGhpcywgaW5kaWNhdG9yc1tpXSkgKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBjaGVjayBpZiB3ZSBjYW4gdXNlIGFycmF5Lm1hcCAod2lkZSBjb21wYXRpYmlsaXR5IGFuZCBwZXJmb3JtYW5jZSBpc3N1ZXMpXG5cdFx0ZnVuY3Rpb24gX2luZGljYXRvcnNNYXAgKGZuKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoYXQuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdGZuLmNhbGwodGhhdC5pbmRpY2F0b3JzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyApIHtcblx0XHRcdHRoaXMub24oJ3Njcm9sbEVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLm9uKCdzY3JvbGxDYW5jZWwnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbignc2Nyb2xsU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMub24oJ2JlZm9yZVNjcm9sbFN0YXJ0JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKDEsIHRydWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGRlbGV0ZSB0aGlzLmluZGljYXRvcnM7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRXaGVlbDogZnVuY3Rpb24gKCkge1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ3doZWVsJywgdGhpcyk7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnbW91c2V3aGVlbCcsIHRoaXMpO1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy53cmFwcGVyLCAnd2hlZWwnLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMud3JhcHBlciwgJ21vdXNld2hlZWwnLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMud3JhcHBlciwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X3doZWVsOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHZhciB3aGVlbERlbHRhWCwgd2hlZWxEZWx0YVksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHRpZiAoIHRoaXMud2hlZWxUaW1lb3V0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGF0Ll9leGVjRXZlbnQoJ3Njcm9sbFN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gRXhlY3V0ZSB0aGUgc2Nyb2xsRW5kIGV2ZW50IGFmdGVyIDQwMG1zIHRoZSB3aGVlbCBzdG9wcGVkIHNjcm9sbGluZ1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLndoZWVsVGltZW91dCk7XG5cdFx0dGhpcy53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0XHR0aGF0LndoZWVsVGltZW91dCA9IHVuZGVmaW5lZDtcblx0XHR9LCA0MDApO1xuXG5cdFx0aWYgKCAnZGVsdGFYJyBpbiBlICkge1xuXHRcdFx0aWYgKGUuZGVsdGFNb2RlID09PSAxKSB7XG5cdFx0XHRcdHdoZWVsRGVsdGFYID0gLWUuZGVsdGFYICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHRcdFx0d2hlZWxEZWx0YVkgPSAtZS5kZWx0YVkgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hlZWxEZWx0YVggPSAtZS5kZWx0YVg7XG5cdFx0XHRcdHdoZWVsRGVsdGFZID0gLWUuZGVsdGFZO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhWCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gZS53aGVlbERlbHRhWCAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0XHR3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YVkgLyAxMjAgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YSAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0fSBlbHNlIGlmICggJ2RldGFpbCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gd2hlZWxEZWx0YVkgPSAtZS5kZXRhaWwgLyAzICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHdoZWVsRGVsdGFYICo9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbjtcblx0XHR3aGVlbERlbHRhWSAqPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb247XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWTtcblx0XHRcdHdoZWVsRGVsdGFZID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0bmV3WCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVg7XG5cdFx0XHRuZXdZID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdFx0aWYgKCB3aGVlbERlbHRhWCA+IDAgKSB7XG5cdFx0XHRcdG5ld1gtLTtcblx0XHRcdH0gZWxzZSBpZiAoIHdoZWVsRGVsdGFYIDwgMCApIHtcblx0XHRcdFx0bmV3WCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdoZWVsRGVsdGFZID4gMCApIHtcblx0XHRcdFx0bmV3WS0tO1xuXHRcdFx0fSBlbHNlIGlmICggd2hlZWxEZWx0YVkgPCAwICkge1xuXHRcdFx0XHRuZXdZKys7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRuZXdYID0gdGhpcy54ICsgTWF0aC5yb3VuZCh0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgPyB3aGVlbERlbHRhWCA6IDApO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBNYXRoLnJvdW5kKHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB3aGVlbERlbHRhWSA6IDApO1xuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJvYmVUeXBlID4gMSApIHtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsJyk7XG5cdFx0fVxuXG4vLyBJTlNFUlQgUE9JTlQ6IF93aGVlbFxuXHR9LFxuXG5cdF9pbml0U25hcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY3VycmVudFBhZ2UgPSB7fTtcblxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5zbmFwID09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnNuYXAgPSB0aGlzLnNjcm9sbGVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNuYXApO1xuXHRcdH1cblxuXHRcdHRoaXMub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSA9IDAsIGwsXG5cdFx0XHRcdG0gPSAwLCBuLFxuXHRcdFx0XHRjeCwgY3ksXG5cdFx0XHRcdHggPSAwLCB5LFxuXHRcdFx0XHRzdGVwWCA9IHRoaXMub3B0aW9ucy5zbmFwU3RlcFggfHwgdGhpcy53cmFwcGVyV2lkdGgsXG5cdFx0XHRcdHN0ZXBZID0gdGhpcy5vcHRpb25zLnNuYXBTdGVwWSB8fCB0aGlzLndyYXBwZXJIZWlnaHQsXG5cdFx0XHRcdGVsO1xuXG5cdFx0XHR0aGlzLnBhZ2VzID0gW107XG5cblx0XHRcdGlmICggIXRoaXMud3JhcHBlcldpZHRoIHx8ICF0aGlzLndyYXBwZXJIZWlnaHQgfHwgIXRoaXMuc2Nyb2xsZXJXaWR0aCB8fCAhdGhpcy5zY3JvbGxlckhlaWdodCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwID09PSB0cnVlICkge1xuXHRcdFx0XHRjeCA9IE1hdGgucm91bmQoIHN0ZXBYIC8gMiApO1xuXHRcdFx0XHRjeSA9IE1hdGgucm91bmQoIHN0ZXBZIC8gMiApO1xuXG5cdFx0XHRcdHdoaWxlICggeCA+IC10aGlzLnNjcm9sbGVyV2lkdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5wYWdlc1tpXSA9IFtdO1xuXHRcdFx0XHRcdGwgPSAwO1xuXHRcdFx0XHRcdHkgPSAwO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCB5ID4gLXRoaXMuc2Nyb2xsZXJIZWlnaHQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBhZ2VzW2ldW2xdID0ge1xuXHRcdFx0XHRcdFx0XHR4OiBNYXRoLm1heCh4LCB0aGlzLm1heFNjcm9sbFgpLFxuXHRcdFx0XHRcdFx0XHR5OiBNYXRoLm1heCh5LCB0aGlzLm1heFNjcm9sbFkpLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogc3RlcFgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogc3RlcFksXG5cdFx0XHRcdFx0XHRcdGN4OiB4IC0gY3gsXG5cdFx0XHRcdFx0XHRcdGN5OiB5IC0gY3lcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHkgLT0gc3RlcFk7XG5cdFx0XHRcdFx0XHRsKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eCAtPSBzdGVwWDtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsID0gdGhpcy5vcHRpb25zLnNuYXA7XG5cdFx0XHRcdGwgPSBlbC5sZW5ndGg7XG5cdFx0XHRcdG4gPSAtMTtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBpID09PSAwIHx8IGVsW2ldLm9mZnNldExlZnQgPD0gZWxbaS0xXS5vZmZzZXRMZWZ0ICkge1xuXHRcdFx0XHRcdFx0bSA9IDA7XG5cdFx0XHRcdFx0XHRuKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5wYWdlc1ttXSApIHtcblx0XHRcdFx0XHRcdHRoaXMucGFnZXNbbV0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR4ID0gTWF0aC5tYXgoLWVsW2ldLm9mZnNldExlZnQsIHRoaXMubWF4U2Nyb2xsWCk7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWF4KC1lbFtpXS5vZmZzZXRUb3AsIHRoaXMubWF4U2Nyb2xsWSk7XG5cdFx0XHRcdFx0Y3ggPSB4IC0gTWF0aC5yb3VuZChlbFtpXS5vZmZzZXRXaWR0aCAvIDIpO1xuXHRcdFx0XHRcdGN5ID0geSAtIE1hdGgucm91bmQoZWxbaV0ub2Zmc2V0SGVpZ2h0IC8gMik7XG5cblx0XHRcdFx0XHR0aGlzLnBhZ2VzW21dW25dID0ge1xuXHRcdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0XHR3aWR0aDogZWxbaV0ub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGVsW2ldLm9mZnNldEhlaWdodCxcblx0XHRcdFx0XHRcdGN4OiBjeCxcblx0XHRcdFx0XHRcdGN5OiBjeVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIHggPiB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRcdFx0XHRtKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UodGhpcy5jdXJyZW50UGFnZS5wYWdlWCB8fCAwLCB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZIHx8IDAsIDApO1xuXG5cdFx0XHQvLyBVcGRhdGUgc25hcCB0aHJlc2hvbGQgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkICUgMSA9PT0gMCApIHtcblx0XHRcdFx0dGhpcy5zbmFwVGhyZXNob2xkWCA9IHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRYID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLndpZHRoICogdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQpO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLmhlaWdodCAqIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2ZsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy54IC0gdGhpcy5zdGFydFgpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMueSAtIHRoaXMuc3RhcnRZKSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXG5cdFx0XHR0aGlzLmdvVG9QYWdlKFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYICsgdGhpcy5kaXJlY3Rpb25YLFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICsgdGhpcy5kaXJlY3Rpb25ZLFxuXHRcdFx0XHR0aW1lXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9uZWFyZXN0U25hcDogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAoICF0aGlzLnBhZ2VzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHg6IDAsIHk6IDAsIHBhZ2VYOiAwLCBwYWdlWTogMCB9O1xuXHRcdH1cblxuXHRcdHZhciBpID0gMCxcblx0XHRcdGwgPSB0aGlzLnBhZ2VzLmxlbmd0aCxcblx0XHRcdG0gPSAwO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZXhjZWVkZWQgdGhlIHNuYXAgdGhyZXNob2xkXG5cdFx0aWYgKCBNYXRoLmFicyh4IC0gdGhpcy5hYnNTdGFydFgpIDwgdGhpcy5zbmFwVGhyZXNob2xkWCAmJlxuXHRcdFx0TWF0aC5hYnMoeSAtIHRoaXMuYWJzU3RhcnRZKSA8IHRoaXMuc25hcFRocmVzaG9sZFkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50UGFnZTtcblx0XHR9XG5cblx0XHRpZiAoIHggPiAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fSBlbHNlIGlmICggeCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCB5ID4gMCApIHtcblx0XHRcdHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHkgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHR5ID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggeCA+PSB0aGlzLnBhZ2VzW2ldWzBdLmN4ICkge1xuXHRcdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsID0gdGhpcy5wYWdlc1tpXS5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IG0gPCBsOyBtKysgKSB7XG5cdFx0XHRpZiAoIHkgPj0gdGhpcy5wYWdlc1swXVttXS5jeSApIHtcblx0XHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpID09IHRoaXMuY3VycmVudFBhZ2UucGFnZVggKSB7XG5cdFx0XHRpICs9IHRoaXMuZGlyZWN0aW9uWDtcblxuXHRcdFx0aWYgKCBpIDwgMCApIHtcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCBpID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0XHRpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXG5cdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdH1cblxuXHRcdGlmICggbSA9PSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICkge1xuXHRcdFx0bSArPSB0aGlzLmRpcmVjdGlvblk7XG5cblx0XHRcdGlmICggbSA8IDAgKSB7XG5cdFx0XHRcdG0gPSAwO1xuXHRcdFx0fSBlbHNlIGlmICggbSA+PSB0aGlzLnBhZ2VzWzBdLmxlbmd0aCApIHtcblx0XHRcdFx0bSA9IHRoaXMucGFnZXNbMF0ubGVuZ3RoIC0gMTtcblx0XHRcdH1cblxuXHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHksXG5cdFx0XHRwYWdlWDogaSxcblx0XHRcdHBhZ2VZOiBtXG5cdFx0fTtcblx0fSxcblxuXHRnb1RvUGFnZTogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nO1xuXG5cdFx0aWYgKCB4ID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0eCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblxuXHRcdGlmICggeSA+PSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCApIHtcblx0XHRcdHkgPSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9XG5cblx0XHR2YXIgcG9zWCA9IHRoaXMucGFnZXNbeF1beV0ueCxcblx0XHRcdHBvc1kgPSB0aGlzLnBhZ2VzW3hdW3ldLnk7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhwb3NYIC0gdGhpcy54KSwgMTAwMCksXG5cdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHBvc1kgLSB0aGlzLnkpLCAxMDAwKVxuXHRcdFx0KSwgMzAwKSA6IHRpbWU7XG5cblx0XHR0aGlzLmN1cnJlbnRQYWdlID0ge1xuXHRcdFx0eDogcG9zWCxcblx0XHRcdHk6IHBvc1ksXG5cdFx0XHRwYWdlWDogeCxcblx0XHRcdHBhZ2VZOiB5XG5cdFx0fTtcblxuXHRcdHRoaXMuc2Nyb2xsVG8ocG9zWCwgcG9zWSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRuZXh0OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4Kys7XG5cblx0XHRpZiAoIHggPj0gdGhpcy5wYWdlcy5sZW5ndGggJiYgdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eSsrO1xuXHRcdH1cblxuXHRcdHRoaXMuZ29Ub1BhZ2UoeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRwcmV2OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4LS07XG5cblx0XHRpZiAoIHggPCAwICYmIHRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHRcdHktLTtcblx0XHR9XG5cblx0XHR0aGlzLmdvVG9QYWdlKHgsIHksIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0X2luaXRLZXlzOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRlZmF1bHQga2V5IGJpbmRpbmdzXG5cdFx0dmFyIGtleXMgPSB7XG5cdFx0XHRwYWdlVXA6IDMzLFxuXHRcdFx0cGFnZURvd246IDM0LFxuXHRcdFx0ZW5kOiAzNSxcblx0XHRcdGhvbWU6IDM2LFxuXHRcdFx0bGVmdDogMzcsXG5cdFx0XHR1cDogMzgsXG5cdFx0XHRyaWdodDogMzksXG5cdFx0XHRkb3duOiA0MFxuXHRcdH07XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBpZiB5b3UgZ2l2ZSBtZSBjaGFyYWN0ZXJzIEkgZ2l2ZSB5b3Uga2V5Y29kZVxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyA9PSAnb2JqZWN0JyApIHtcblx0XHRcdGZvciAoIGkgaW4gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldID0gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgPSB7fTtcblx0XHR9XG5cblx0XHRmb3IgKCBpIGluIGtleXMgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gfHwga2V5c1tpXTtcblx0XHR9XG5cblx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICdrZXlkb3duJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAna2V5ZG93bicsIHRoaXMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9rZXk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAsXHQvLyB3ZSBhcmUgdXNpbmcgdGhpcyBhbG90LCBiZXR0ZXIgdG8gY2FjaGUgaXRcblx0XHRcdG5ld1ggPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCA6IHRoaXMueCxcblx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWSA6IHRoaXMueSxcblx0XHRcdG5vdyA9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdHByZXZUaW1lID0gdGhpcy5rZXlUaW1lIHx8IDAsXG5cdFx0XHRhY2NlbGVyYXRpb24gPSAwLjI1MCxcblx0XHRcdHBvcztcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHBvcyA9IHRoaXMuZ2V0Q29tcHV0ZWRQb3NpdGlvbigpO1xuXG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoTWF0aC5yb3VuZChwb3MueCksIE1hdGgucm91bmQocG9zLnkpKTtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IG5vdyAtIHByZXZUaW1lIDwgMjAwID8gTWF0aC5taW4odGhpcy5rZXlBY2NlbGVyYXRpb24gKyBhY2NlbGVyYXRpb24sIDUwKSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBlLmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5wYWdlVXA6XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggKz0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZICs9IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucGFnZURvd246XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggLT0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZIC09IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MuZW5kOlxuXHRcdFx0XHRuZXdYID0gc25hcCA/IHRoaXMucGFnZXMubGVuZ3RoLTEgOiB0aGlzLm1heFNjcm9sbFg7XG5cdFx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5wYWdlc1swXS5sZW5ndGgtMSA6IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5ob21lOlxuXHRcdFx0XHRuZXdYID0gMDtcblx0XHRcdFx0bmV3WSA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MubGVmdDpcblx0XHRcdFx0bmV3WCArPSBzbmFwID8gLTEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MudXA6XG5cdFx0XHRcdG5ld1kgKz0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucmlnaHQ6XG5cdFx0XHRcdG5ld1ggLT0gc25hcCA/IC0xIDogNSArIHRoaXMua2V5QWNjZWxlcmF0aW9uPj4wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmRvd246XG5cdFx0XHRcdG5ld1kgLT0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggc25hcCApIHtcblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG5cdFx0dGhpcy5rZXlUaW1lID0gbm93O1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoZGVzdFgsIGRlc3RZLCBkdXJhdGlvbiwgZWFzaW5nRm4pIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdGFydFggPSB0aGlzLngsXG5cdFx0XHRzdGFydFkgPSB0aGlzLnksXG5cdFx0XHRzdGFydFRpbWUgPSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRkZXN0VGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuXG5cdFx0ZnVuY3Rpb24gc3RlcCAoKSB7XG5cdFx0XHR2YXIgbm93ID0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0XHRlYXNpbmc7XG5cblx0XHRcdGlmICggbm93ID49IGRlc3RUaW1lICkge1xuXHRcdFx0XHR0aGF0LmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQuX3RyYW5zbGF0ZShkZXN0WCwgZGVzdFkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCAhdGhhdC5yZXNldFBvc2l0aW9uKHRoYXQub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdFx0XHR0aGF0Ll9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRub3cgPSAoIG5vdyAtIHN0YXJ0VGltZSApIC8gZHVyYXRpb247XG5cdFx0XHRlYXNpbmcgPSBlYXNpbmdGbihub3cpO1xuXHRcdFx0bmV3WCA9ICggZGVzdFggLSBzdGFydFggKSAqIGVhc2luZyArIHN0YXJ0WDtcblx0XHRcdG5ld1kgPSAoIGRlc3RZIC0gc3RhcnRZICkgKiBlYXNpbmcgKyBzdGFydFk7XG5cdFx0XHR0aGF0Ll90cmFuc2xhdGUobmV3WCwgbmV3WSk7XG5cblx0XHRcdGlmICggdGhhdC5pc0FuaW1hdGluZyApIHtcblx0XHRcdFx0ckFGKHN0ZXApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoYXQub3B0aW9ucy5wcm9iZVR5cGUgPT0gMyApIHtcblx0XHRcdFx0dGhhdC5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRzdGVwKCk7XG5cdH0sXG5cblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0c3dpdGNoICggZS50eXBlICkge1xuXHRcdFx0Y2FzZSAndG91Y2hzdGFydCc6XG5cdFx0XHRjYXNlICdwb2ludGVyZG93bic6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJEb3duJzpcblx0XHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHRcdHRoaXMuX3N0YXJ0KGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNobW92ZSc6XG5cdFx0XHRjYXNlICdwb2ludGVybW92ZSc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJNb3ZlJzpcblx0XHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHRcdHRoaXMuX21vdmUoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndG91Y2hlbmQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcnVwJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlclVwJzpcblx0XHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0Y2FzZSAndG91Y2hjYW5jZWwnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmNhbmNlbCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJDYW5jZWwnOlxuXHRcdFx0Y2FzZSAnbW91c2VjYW5jZWwnOlxuXHRcdFx0XHR0aGlzLl9lbmQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnb3JpZW50YXRpb25jaGFuZ2UnOlxuXHRcdFx0Y2FzZSAncmVzaXplJzpcblx0XHRcdFx0dGhpcy5fcmVzaXplKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndHJhbnNpdGlvbmVuZCc6XG5cdFx0XHRjYXNlICd3ZWJraXRUcmFuc2l0aW9uRW5kJzpcblx0XHRcdGNhc2UgJ29UcmFuc2l0aW9uRW5kJzpcblx0XHRcdGNhc2UgJ01TVHJhbnNpdGlvbkVuZCc6XG5cdFx0XHRcdHRoaXMuX3RyYW5zaXRpb25FbmQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnd2hlZWwnOlxuXHRcdFx0Y2FzZSAnRE9NTW91c2VTY3JvbGwnOlxuXHRcdFx0Y2FzZSAnbW91c2V3aGVlbCc6XG5cdFx0XHRcdHRoaXMuX3doZWVsKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2tleWRvd24nOlxuXHRcdFx0XHR0aGlzLl9rZXkoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnY2xpY2snOlxuXHRcdFx0XHRpZiAoICFlLl9jb25zdHJ1Y3RlZCApIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0U2Nyb2xsYmFyIChkaXJlY3Rpb24sIGludGVyYWN0aXZlLCB0eXBlKSB7XG5cdHZhciBzY3JvbGxiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHRpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuXHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5Jztcblx0XHRpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9ICctd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDAuNSk7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuOSk7Ym9yZGVyLXJhZGl1czozcHgnO1xuXHR9XG5cblx0aW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdpU2Nyb2xsSW5kaWNhdG9yJztcblxuXHRpZiAoIGRpcmVjdGlvbiA9PSAnaCcgKSB7XG5cdFx0aWYgKCB0eXBlID09PSB0cnVlICkge1xuXHRcdFx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgKz0gJztoZWlnaHQ6N3B4O2xlZnQ6MnB4O3JpZ2h0OjJweDtib3R0b206MCc7XG5cdFx0XHRpbmRpY2F0b3Iuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHRcdH1cblx0XHRzY3JvbGxiYXIuY2xhc3NOYW1lID0gJ2lTY3JvbGxIb3Jpem9udGFsU2Nyb2xsYmFyJztcblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO3dpZHRoOjdweDtib3R0b206MnB4O3RvcDoycHg7cmlnaHQ6MXB4Jztcblx0XHRcdGluZGljYXRvci5zdHlsZS53aWR0aCA9ICcxMDAlJztcblx0XHR9XG5cdFx0c2Nyb2xsYmFyLmNsYXNzTmFtZSA9ICdpU2Nyb2xsVmVydGljYWxTY3JvbGxiYXInO1xuXHR9XG5cblx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgKz0gJztvdmVyZmxvdzpoaWRkZW4nO1xuXG5cdGlmICggIWludGVyYWN0aXZlICkge1xuXHRcdHNjcm9sbGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXHR9XG5cblx0c2Nyb2xsYmFyLmFwcGVuZENoaWxkKGluZGljYXRvcik7XG5cblx0cmV0dXJuIHNjcm9sbGJhcjtcbn1cblxuZnVuY3Rpb24gSW5kaWNhdG9yIChzY3JvbGxlciwgb3B0aW9ucykge1xuXHR0aGlzLndyYXBwZXIgPSB0eXBlb2Ygb3B0aW9ucy5lbCA9PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5lbCkgOiBvcHRpb25zLmVsO1xuXHR0aGlzLndyYXBwZXJTdHlsZSA9IHRoaXMud3JhcHBlci5zdHlsZTtcblx0dGhpcy5pbmRpY2F0b3IgPSB0aGlzLndyYXBwZXIuY2hpbGRyZW5bMF07XG5cdHRoaXMuaW5kaWNhdG9yU3R5bGUgPSB0aGlzLmluZGljYXRvci5zdHlsZTtcblx0dGhpcy5zY3JvbGxlciA9IHNjcm9sbGVyO1xuXG5cdHRoaXMub3B0aW9ucyA9IHtcblx0XHRsaXN0ZW5YOiB0cnVlLFxuXHRcdGxpc3Rlblk6IHRydWUsXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXHRcdHJlc2l6ZTogdHJ1ZSxcblx0XHRkZWZhdWx0U2Nyb2xsYmFyczogZmFsc2UsXG5cdFx0c2hyaW5rOiBmYWxzZSxcblx0XHRmYWRlOiBmYWxzZSxcblx0XHRzcGVlZFJhdGlvWDogMCxcblx0XHRzcGVlZFJhdGlvWTogMFxuXHR9O1xuXG5cdGZvciAoIHZhciBpIGluIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0fVxuXG5cdHRoaXMuc2l6ZVJhdGlvWCA9IDE7XG5cdHRoaXMuc2l6ZVJhdGlvWSA9IDE7XG5cdHRoaXMubWF4UG9zWCA9IDA7XG5cdHRoaXMubWF4UG9zWSA9IDA7XG5cblx0aWYgKCB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUgKSB7XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVUb3VjaCApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMuaW5kaWNhdG9yLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAndG91Y2hlbmQnLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVQb2ludGVyICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZU1vdXNlICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsICdtb3VzZWRvd24nLCB0aGlzKTtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlICkge1xuXHRcdHRoaXMud3JhcHBlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0gPSB0aGlzLnNjcm9sbGVyLnRyYW5zbGF0ZVo7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9IHV0aWxzLmlzQmFkQW5kcm9pZCA/ICcwLjAwMXMnIDogJzBtcyc7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGUub3BhY2l0eSA9ICcwJztcblx0fVxufVxuXG5JbmRpY2F0b3IucHJvdG90eXBlID0ge1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRzd2l0Y2ggKCBlLnR5cGUgKSB7XG5cdFx0XHRjYXNlICd0b3VjaHN0YXJ0Jzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJkb3duJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckRvd24nOlxuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0dGhpcy5fc3RhcnQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJtb3ZlJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlck1vdmUnOlxuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0dGhpcy5fbW92ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRjYXNlICdwb2ludGVydXAnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyVXAnOlxuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRjYXNlICd0b3VjaGNhbmNlbCc6XG5cdFx0XHRjYXNlICdwb2ludGVyY2FuY2VsJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckNhbmNlbCc6XG5cdFx0XHRjYXNlICdtb3VzZWNhbmNlbCc6XG5cdFx0XHRcdHRoaXMuX2VuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSApIHtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMuaW5kaWNhdG9yLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy5pbmRpY2F0b3IsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLmluZGljYXRvciwgJ21vdXNlZG93bicsIHRoaXMpO1xuXG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJ1cCcpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kZWZhdWx0U2Nyb2xsYmFycyApIHtcblx0XHRcdHRoaXMud3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lKCk7XG5cblx0XHR0aGlzLmluaXRpYXRlZCA9IHRydWU7XG5cdFx0dGhpcy5tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMubGFzdFBvaW50WFx0PSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLmxhc3RQb2ludFlcdD0gcG9pbnQucGFnZVk7XG5cblx0XHR0aGlzLnN0YXJ0VGltZVx0PSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVRvdWNoICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlUG9pbnRlciApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVNb3VzZSApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnYmVmb3JlU2Nyb2xsU3RhcnQnKTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0ZGVsdGFYLCBkZWx0YVksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0dGltZXN0YW1wID0gdXRpbHMuZ2V0VGltZSgpO1xuXG5cdFx0aWYgKCAhdGhpcy5tb3ZlZCApIHtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdmVkID0gdHJ1ZTtcblxuXHRcdGRlbHRhWCA9IHBvaW50LnBhZ2VYIC0gdGhpcy5sYXN0UG9pbnRYO1xuXHRcdHRoaXMubGFzdFBvaW50WCA9IHBvaW50LnBhZ2VYO1xuXG5cdFx0ZGVsdGFZID0gcG9pbnQucGFnZVkgLSB0aGlzLmxhc3RQb2ludFk7XG5cdFx0dGhpcy5sYXN0UG9pbnRZID0gcG9pbnQucGFnZVk7XG5cblx0XHRuZXdYID0gdGhpcy54ICsgZGVsdGFYO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBkZWx0YVk7XG5cblx0XHR0aGlzLl9wb3MobmV3WCwgbmV3WSk7XG5cblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5vcHRpb25zLnByb2JlVHlwZSA9PSAxICYmIHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gMzAwICkge1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSB0aW1lc3RhbXA7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuc2Nyb2xsZXIub3B0aW9ucy5wcm9iZVR5cGUgPiAxICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBpbmRpY2F0b3IuX21vdmVcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdF9lbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHZhciBzbmFwID0gdGhpcy5zY3JvbGxlci5fbmVhcmVzdFNuYXAodGhpcy5zY3JvbGxlci54LCB0aGlzLnNjcm9sbGVyLnkpO1xuXG5cdFx0XHR2YXIgdGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnNjcm9sbGVyLnggLSBzbmFwLngpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMuc2Nyb2xsZXIueSAtIHNuYXAueSksIDEwMDApXG5cdFx0XHRcdFx0KSwgMzAwKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNjcm9sbGVyLnggIT0gc25hcC54IHx8IHRoaXMuc2Nyb2xsZXIueSAhPSBzbmFwLnkgKSB7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWSA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHNuYXAueCwgc25hcC55LCB0aW1lLCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuYm91bmNlRWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubW92ZWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblx0fSxcblxuXHR0cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9IHRpbWUgKyAnbXMnO1xuXG5cdFx0aWYgKCAhdGltZSAmJiB1dGlscy5pc0JhZEFuZHJvaWQgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSAnMC4wMDFzJztcblx0XHR9XG5cdH0sXG5cblx0dHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb25dID0gZWFzaW5nO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICYmICF0aGlzLm9wdGlvbnMubGlzdGVuWSApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuZGlzcGxheSA9IHRoaXMuc2Nyb2xsZXIuaGFzSG9yaXpvbnRhbFNjcm9sbCA/ICdibG9jaycgOiAnbm9uZSc7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLmxpc3RlblkgJiYgIXRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5kaXNwbGF5ID0gdGhpcy5zY3JvbGxlci5oYXNWZXJ0aWNhbFNjcm9sbCA/ICdibG9jaycgOiAnbm9uZSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuZGlzcGxheSA9IHRoaXMuc2Nyb2xsZXIuaGFzSG9yaXpvbnRhbFNjcm9sbCB8fCB0aGlzLnNjcm9sbGVyLmhhc1ZlcnRpY2FsU2Nyb2xsID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuc2Nyb2xsZXIuaGFzSG9yaXpvbnRhbFNjcm9sbCAmJiB0aGlzLnNjcm9sbGVyLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0dXRpbHMuYWRkQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbEJvdGhTY3JvbGxiYXJzJyk7XG5cdFx0XHR1dGlscy5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsTG9uZVNjcm9sbGJhcicpO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5kZWZhdWx0U2Nyb2xsYmFycyAmJiB0aGlzLm9wdGlvbnMuY3VzdG9tU3R5bGUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLnJpZ2h0ID0gJzhweCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLmJvdHRvbSA9ICc4cHgnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHV0aWxzLnJlbW92ZUNsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxCb3RoU2Nyb2xsYmFycycpO1xuXHRcdFx0dXRpbHMuYWRkQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbExvbmVTY3JvbGxiYXInKTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjcm9sbGJhcnMgJiYgdGhpcy5vcHRpb25zLmN1c3RvbVN0eWxlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5yaWdodCA9ICcycHgnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5ib3R0b20gPSAnMnB4Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciByID0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodDtcdC8vIGZvcmNlIHJlZnJlc2hcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJXaWR0aCA9IHRoaXMud3JhcHBlci5jbGllbnRXaWR0aDtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnJlc2l6ZSApIHtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JXaWR0aCA9IE1hdGgubWF4KE1hdGgucm91bmQodGhpcy53cmFwcGVyV2lkdGggKiB0aGlzLndyYXBwZXJXaWR0aCAvICh0aGlzLnNjcm9sbGVyLnNjcm9sbGVyV2lkdGggfHwgdGhpcy53cmFwcGVyV2lkdGggfHwgMSkpLCA4KTtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMuaW5kaWNhdG9yV2lkdGggKyAncHgnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JXaWR0aCA9IHRoaXMuaW5kaWNhdG9yLmNsaWVudFdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1heFBvc1ggPSB0aGlzLndyYXBwZXJXaWR0aCAtIHRoaXMuaW5kaWNhdG9yV2lkdGg7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnY2xpcCcgKSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlYID0gLXRoaXMuaW5kaWNhdG9yV2lkdGggKyA4O1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WCA9IHRoaXMud3JhcHBlcldpZHRoIC0gODtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlYID0gMDtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVggPSB0aGlzLm1heFBvc1g7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2l6ZVJhdGlvWCA9IHRoaXMub3B0aW9ucy5zcGVlZFJhdGlvWCB8fCAodGhpcy5zY3JvbGxlci5tYXhTY3JvbGxYICYmICh0aGlzLm1heFBvc1ggLyB0aGlzLnNjcm9sbGVyLm1heFNjcm9sbFgpKTtcdFxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblkgKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJIZWlnaHQgPSB0aGlzLndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMucmVzaXplICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvckhlaWdodCA9IE1hdGgubWF4KE1hdGgucm91bmQodGhpcy53cmFwcGVySGVpZ2h0ICogdGhpcy53cmFwcGVySGVpZ2h0IC8gKHRoaXMuc2Nyb2xsZXIuc2Nyb2xsZXJIZWlnaHQgfHwgdGhpcy53cmFwcGVySGVpZ2h0IHx8IDEpKSwgOCk7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuaGVpZ2h0ID0gdGhpcy5pbmRpY2F0b3JIZWlnaHQgKyAncHgnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JIZWlnaHQgPSB0aGlzLmluZGljYXRvci5jbGllbnRIZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWSA9IHRoaXMud3JhcHBlckhlaWdodCAtIHRoaXMuaW5kaWNhdG9ySGVpZ2h0O1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ2NsaXAnICkge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WSA9IC10aGlzLmluZGljYXRvckhlaWdodCArIDg7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gODtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlZID0gMDtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVkgPSB0aGlzLm1heFBvc1k7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWSA9IHRoaXMud3JhcHBlckhlaWdodCAtIHRoaXMuaW5kaWNhdG9ySGVpZ2h0O1xuXHRcdFx0dGhpcy5zaXplUmF0aW9ZID0gdGhpcy5vcHRpb25zLnNwZWVkUmF0aW9ZIHx8ICh0aGlzLnNjcm9sbGVyLm1heFNjcm9sbFkgJiYgKHRoaXMubWF4UG9zWSAvIHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWSkpO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlUG9zaXRpb24oKTtcblx0fSxcblxuXHR1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB4ID0gdGhpcy5vcHRpb25zLmxpc3RlblggJiYgTWF0aC5yb3VuZCh0aGlzLnNpemVSYXRpb1ggKiB0aGlzLnNjcm9sbGVyLngpIHx8IDAsXG5cdFx0XHR5ID0gdGhpcy5vcHRpb25zLmxpc3RlblkgJiYgTWF0aC5yb3VuZCh0aGlzLnNpemVSYXRpb1kgKiB0aGlzLnNjcm9sbGVyLnkpIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuaWdub3JlQm91bmRhcmllcyApIHtcblx0XHRcdGlmICggeCA8IHRoaXMubWluQm91bmRhcnlYICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyApIHtcblx0XHRcdFx0XHR0aGlzLndpZHRoID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JXaWR0aCArIHgsIDgpO1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR4ID0gdGhpcy5taW5Cb3VuZGFyeVg7XG5cdFx0XHR9IGVsc2UgaWYgKCB4ID4gdGhpcy5tYXhCb3VuZGFyeVggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLmluZGljYXRvcldpZHRoIC0gKHggLSB0aGlzLm1heFBvc1gpLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG5cdFx0XHRcdFx0eCA9IHRoaXMubWF4UG9zWCArIHRoaXMuaW5kaWNhdG9yV2lkdGggLSB0aGlzLndpZHRoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHggPSB0aGlzLm1heEJvdW5kYXJ5WDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICYmIHRoaXMud2lkdGggIT0gdGhpcy5pbmRpY2F0b3JXaWR0aCApIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuaW5kaWNhdG9yV2lkdGg7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB5IDwgdGhpcy5taW5Cb3VuZGFyeVkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JIZWlnaHQgKyB5ICogMywgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0eSA9IHRoaXMubWluQm91bmRhcnlZO1xuXHRcdFx0fSBlbHNlIGlmICggeSA+IHRoaXMubWF4Qm91bmRhcnlZICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyApIHtcblx0XHRcdFx0XHR0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaW5kaWNhdG9ySGVpZ2h0IC0gKHkgLSB0aGlzLm1heFBvc1kpICogMywgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHRcdFx0eSA9IHRoaXMubWF4UG9zWSArIHRoaXMuaW5kaWNhdG9ySGVpZ2h0IC0gdGhpcy5oZWlnaHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSA9IHRoaXMubWF4Qm91bmRhcnlZO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgJiYgdGhpcy5oZWlnaHQgIT0gdGhpcy5pbmRpY2F0b3JIZWlnaHQgKSB7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyArIHRoaXMuc2Nyb2xsZXIudHJhbnNsYXRlWjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5sZWZ0ID0geCArICdweCc7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLnRvcCA9IHkgKyAncHgnO1xuXHRcdH1cblx0fSxcblxuXHRfcG9zOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggeCA8IDAgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB4ID4gdGhpcy5tYXhQb3NYICkge1xuXHRcdFx0eCA9IHRoaXMubWF4UG9zWDtcblx0XHR9XG5cblx0XHRpZiAoIHkgPCAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggeSA+IHRoaXMubWF4UG9zWSApIHtcblx0XHRcdHkgPSB0aGlzLm1heFBvc1k7XG5cdFx0fVxuXG5cdFx0eCA9IHRoaXMub3B0aW9ucy5saXN0ZW5YID8gTWF0aC5yb3VuZCh4IC8gdGhpcy5zaXplUmF0aW9YKSA6IHRoaXMuc2Nyb2xsZXIueDtcblx0XHR5ID0gdGhpcy5vcHRpb25zLmxpc3RlblkgPyBNYXRoLnJvdW5kKHkgLyB0aGlzLnNpemVSYXRpb1kpIDogdGhpcy5zY3JvbGxlci55O1xuXG5cdFx0dGhpcy5zY3JvbGxlci5zY3JvbGxUbyh4LCB5KTtcblx0fSxcblxuXHRmYWRlOiBmdW5jdGlvbiAodmFsLCBob2xkKSB7XG5cdFx0aWYgKCBob2xkICYmICF0aGlzLnZpc2libGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZmFkZVRpbWVvdXQpO1xuXHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBudWxsO1xuXG5cdFx0dmFyIHRpbWUgPSB2YWwgPyAyNTAgOiA1MDAsXG5cdFx0XHRkZWxheSA9IHZhbCA/IDAgOiAzMDA7XG5cblx0XHR2YWwgPSB2YWwgPyAnMScgOiAnMCc7XG5cblx0XHR0aGlzLndyYXBwZXJTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dID0gdGltZSArICdtcyc7XG5cblx0XHR0aGlzLmZhZGVUaW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0dGhpcy53cmFwcGVyU3R5bGUub3BhY2l0eSA9IHZhbDtcblx0XHRcdHRoaXMudmlzaWJsZSA9ICt2YWw7XG5cdFx0fSkuYmluZCh0aGlzLCB2YWwpLCBkZWxheSk7XG5cdH1cbn07XG5cbklTY3JvbGwudXRpbHMgPSB1dGlscztcblxuaWYgKCB0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IElTY3JvbGw7XG59IGVsc2Uge1xuXHR3aW5kb3cuSVNjcm9sbCA9IElTY3JvbGw7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsIE1hdGgpOyIsImltcG9ydCAqIGFzIGxvZGFzaCBmcm9tIFwibG9kYXNoXCJcblxubGV0IExpdGVyYWxQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIHt9IClcblxuZXhwb3J0IGNvbnN0IGR1bXBQcm9taXNlID0gcCA9PiBwLnRoZW4oXG5cdHJlc3VsdCA9PiBjb25zb2xlLmxvZyggYHJlc3VsdDpgLCByZXN1bHQgKSxcblx0ZXJyb3IgPT4gY29uc29sZS5lcnJvciggYGVycm9yOmAsIGVycm9yIClcbilcblxuZXhwb3J0IGZ1bmN0aW9uIGR1bXAoIG1zZywgdmFsdWUgKSB7XG5cdGNvbnNvbGUubG9nKCBtc2csIHZhbHVlIClcblx0cmV0dXJuIHZhbHVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBPYmooIG9iaiwgcHJvcHMgKSB7XG5cdGxldCByZXQgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIG9iaiApICksIG9iaiApXG5cdGxvZGFzaC5mb3JFYWNoKCBwcm9wcywgKCBmdW4sIGtleSApID0+IHsgcmV0WyBrZXkgXSA9IHR5cGVvZiBmdW4gPT0gYGZ1bmN0aW9uYCA/IGZ1biggb2JqWyBrZXkgXSApIDogZnVuIH0gKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0cyggbnVtLCAuLi5yZXN0cyApIHtcblx0bGV0IHJldCA9IFtdXG5cdGZvciAoIGxldCByIG9mIHJlc3RzICkge1xuXHRcdGxldCBuID0gbnVtICUgclxuXHRcdG51bSA9ICggbnVtIC0gbiApIC8gclxuXHRcdHJldC5wdXNoKCBuIClcblx0fVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWQoIHMsIG4sIHAgKSB7XG5cdHMgPSBTdHJpbmcoIHMgKVxuXHRsZXQgeCA9IGBgXG5cdG4gLT0gcy5sZW5ndGhcblx0d2hpbGUgKCBuID4gMCApIHtcblx0XHR4ICs9IHBcblx0XHQtLW5cblx0fVxuXHRyZXR1cm4geCArIHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWUoKSB7XG5cdGxldCBkID0gbmV3IERhdGUoKVxuXHRyZXR1cm4gYCR7IGQuZ2V0SG91cnMoKSB9OiR7IHBhZCggZC5nZXRNaW51dGVzKCksIDIsIDAgKSB9OiR7IHBhZCggZC5nZXRTZWNvbmRzKCksIDIsIDAgKSB9LiR7IHBhZCggZC5nZXRNaWxsaXNlY29uZHMoKSwgMywgMCApIH1gXG59XG5cbmV4cG9ydCBjb25zdCBzdGFjayA9ICgpID0+ICggbmV3IEVycm9yICkuc3RhY2tcblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbnMoIG9wdGlvbnMsIGRlZiApIHtcblx0bGV0IHJldCA9IHt9XG5cdGZvciAoIGxldCBpIGluIGRlZiApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkZWYsIGkgKSApXG5cdFx0aWYgKCBvcHRpb25zID09IG51bGwgKVxuXHRcdFx0cmV0WyBpIF0gPSBkZWZbIGkgXVxuXHRcdGVsc2Uge1xuXHRcdFx0bGV0IG9wID0gb3B0aW9uc1sgaSBdXG5cdFx0XHRpZiAoIG9wID09IG51bGwgKVxuXHRcdFx0XHRvcCA9IGRlZlsgaSBdXG5cdFx0XHRyZXRbIGkgXSA9IG9wXG5cdFx0fVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoIG9iaiwgZGVwdGggKSB7XG5cdGlmICggZGVwdGggPT0gbnVsbCApXG5cdFx0ZGVwdGggPSAxXG5cdGlmICggIW9iaiB8fCAhZGVwdGggfHwgZGVwdGggPCAxIClcblx0XHRyZXR1cm4gYGAgKyBvYmpcblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApXG5cdFx0cmV0dXJuICggYFsgYCArIG9iai5tYXAoIHggPT4gc3RyKCB4LCBkZXB0aCAtIDEgKSApLmpvaW4oIGAgYCApICsgYCBdYCApXG5cdGlmICggIW9iai5jb25zdHJ1Y3RvciB8fCBvYmouY29uc3RydWN0b3IgPT0gT2JqZWN0IClcblx0XHRyZXR1cm4gKCBgeyBgICsgT2JqZWN0LmtleXMoIG9iaiApLm1hcCggeCA9PiB4ICsgYD1gICsgc3RyKCBvYmpbIHggXSwgZGVwdGggLSAxICkgKS5qb2luKCBgIGAgKSArIGAgfWAgKVxuXHRyZXR1cm4gU3RyaW5nKCBvYmogKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PbmVMaW5lKCBvYmogKSB7XG5cdGxldCByZXQgPSBKU09OLnN0cmluZ2lmeSggb2JqIClcblx0cmV0ICs9IFwiXFxuXCJcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnlMaW5lcyggY2FsbGJhY2sgKSB7XG5cdGxldCBidWZmZXIgPSBgYFxuXHRyZXR1cm4gY2h1bmsgPT4ge1xuXHRcdGJ1ZmZlciArPSBTdHJpbmcoIGNodW5rIClcblx0XHRsZXQgcmV0ID0gYnVmZmVyLnNwbGl0KCBgXFxuYCApXG5cdFx0YnVmZmVyID0gcmV0LnBvcCgpXG5cdFx0cmV0LmZvckVhY2goIGNhbGxiYWNrIClcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnlKU09OKCBjYWxsYmFjayApIHtcblx0cmV0dXJuIGJ5TGluZXMoIGxpbmUgPT4gY2FsbGJhY2soIEpTT04ucGFyc2UoIGxpbmUudHJpbSgpICkgKSApXG59XG5cbmV4cG9ydCBjb25zdCB2YWx1ZU9mID0gdmFsID0+IHZhbCA9PSBudWxsID8gbnVsbCA6IHZhbC52YWx1ZU9mID09IG51bGwgPyB2YWwgOiB2YWwudmFsdWVPZigpXG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UaGlzKCkgeyByZXR1cm4gdGhpcyB9XG5leHBvcnQgY29uc3QgcmV0dXJuTnVsbCA9ICgpID0+IG51bGxcbmV4cG9ydCBjb25zdCByZXR1cm5UcnVlID0gKCkgPT4gdHJ1ZVxuZXhwb3J0IGNvbnN0IHJldHVybkZhbHNlID0gKCkgPT4gZmFsc2VcbmV4cG9ydCBjb25zdCByZXR1cm5aZXJvID0gKCkgPT4gMFxuZXhwb3J0IGNvbnN0IHJldHVybk9uZSA9ICgpID0+IDFcblxuZXhwb3J0IGNvbnN0IHByb21pc2VTdWNjZWVkZWQgPSBQcm9taXNlLnJlc29sdmUoKVxuZXhwb3J0IGNvbnN0IHByb21pc2VGYWlsZWQgPSBQcm9taXNlLnJlamVjdCgpXG5leHBvcnQgY29uc3QgcHJvbWlzZU51bGwgPSBQcm9taXNlLnJlc29sdmUoIG51bGwgKVxuZXhwb3J0IGNvbnN0IHByb21pc2VUcnVlID0gUHJvbWlzZS5yZXNvbHZlKCB0cnVlIClcbmV4cG9ydCBjb25zdCBwcm9taXNlRmFsc2UgPSBQcm9taXNlLnJlc29sdmUoIGZhbHNlIClcbmV4cG9ydCBjb25zdCBwcm9taXNlWmVybyA9IFByb21pc2UucmVzb2x2ZSggMCApXG5leHBvcnQgY29uc3QgcHJvbWlzZU9uZSA9IFByb21pc2UucmVzb2x2ZSggMSApXG5cbmV4cG9ydCBjb25zdCByZXR1cm5TdWNjZWVkZWQgPSAoKSA9PiBwcm9taXNlU3VjY2VlZGVkXG5leHBvcnQgY29uc3QgcmV0dXJuRmFpbGVkID0gKCkgPT4gcHJvbWlzZUZhaWxlZFxuZXhwb3J0IGNvbnN0IHJldHVybk51bGxQcm9taXNlID0gKCkgPT4gcHJvbWlzZU51bGxcbmV4cG9ydCBjb25zdCByZXR1cm5UcnVlUHJvbWlzZSA9ICgpID0+IHByb21pc2VUcnVlXG5leHBvcnQgY29uc3QgcmV0dXJuRmFsc2VQcm9taXNlID0gKCkgPT4gcHJvbWlzZUZhbHNlXG5leHBvcnQgY29uc3QgcmV0dXJuWmVyb1Byb21pc2UgPSAoKSA9PiBwcm9taXNlWmVyb1xuZXhwb3J0IGNvbnN0IHJldHVybk9uZVByb21pc2UgPSAoKSA9PiBwcm9taXNlT25lXG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuKCBwcm9taXNlLCBjYiApIHtcblx0aWYgKCBwcm9taXNlICE9IG51bGwgKVxuXHRcdHByb21pc2UudGhlbiggY2IsIGNiIClcblx0ZWxzZVxuXHRcdHByb2Nlc3MubmV4dFRpY2soIGNiIClcblx0cmV0dXJuIHByb21pc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhaXRGb3IoIHRpbWVvdXQsIGludGVydmFsLCBjYWxsYmFjayApIHtcblx0aWYgKCB0eXBlb2YgdGltZW91dCA9PSBgZnVuY3Rpb25gICkge1xuXHRcdGludGVydmFsID0gdGltZW91dFxuXHRcdHRpbWVvdXQgPSA1MDAwXG5cdH1cblx0aWYgKCB0eXBlb2YgaW50ZXJ2YWwgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRjYWxsYmFjayA9IGludGVydmFsXG5cdFx0aW50ZXJ2YWwgPSAyMDBcblx0fVxuXHRyZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdGxldCBzdGFydCA9IERhdGUubm93KClcblx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiBjaGVjaygpIHtcblx0XHRcdGxldCByZXRcblx0XHRcdGlmICggcmV0ID0gY2FsbGJhY2soKSApXG5cdFx0XHRcdHJlc29sdmUoIHJldCApXG5cdFx0XHRlbHNlIGlmICggRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCApXG5cdFx0XHRcdHJlamVjdCggbmV3IEVycm9yKCBgdGltZW91dGAgKSApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHNldFRpbWVvdXQoIGNoZWNrLCBpbnRlcnZhbCApXG5cdFx0fSwgaW50ZXJ2YWwgKVxuXHR9IClcbn1cblxuZXhwb3J0IGNvbnN0IGVtcHR5ID0gT2JqZWN0LmZyZWV6ZSggT2JqZWN0LmNyZWF0ZSggbnVsbCApIClcblxuZXhwb3J0IGZ1bmN0aW9uIEpTT05FcXVhbCggYSwgYiApIHtcblx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KCBhICkgPT0gSlNPTi5zdHJpbmdpZnkoIGIgKVxufVxuXG5leHBvcnQgeyBfbmV3IGFzIG5ldyB9XG5mdW5jdGlvbiBfbmV3KCAuLi5kZXNjZWRlbnRzICkge1xuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbigge30sIC4uLmRlc2NlZGVudHMgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbCggZnVuLCAuLi5hcmdzICkge1xuXHRyZXR1cm4gZnVuKCAuLi5hcmdzIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldGhyb3coIGUgKSB7IHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZSB9LCAxICkgfVxuXG4vLyBvcHRpbWl6YXRpb24gLS0gdXNpbmcgdHJ5L2NhdGNoIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uXG5leHBvcnQgeyBfY2F0Y2ggYXMgY2F0Y2ggfVxuZnVuY3Rpb24gX2NhdGNoKCBjYiwgcmV0ICkgeyB0cnkgeyByZXR1cm4gY2IoKSB9IGNhdGNoICggZSApIHsgcmV0dXJuIHJldCggZSApIH0gfVxuXG5leHBvcnQgZnVuY3Rpb24gY2F0Y2hNYXAoIGNiLCBtYXBSZXN1bHQsIG1hcEVycm9yICkge1xuXHRsZXQgcmVzdWx0XG5cdHRyeSB7XG5cdFx0cmVzdWx0ID0gY2IoKVxuXHR9XG5cdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0cmV0dXJuIG1hcEVycm9yKCBlcnJvciApXG5cdH1cblx0cmV0dXJuIG1hcFJlc3VsdCggcmVzdWx0IClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhdGNoQ2FsbCggY2IgKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHsgb2s6IHRydWUsIHJlc3VsdDogY2IoKSB9XG5cdH1cblx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRyZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBlcnJvciB9XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZSggdmFsdWUsIGluZGV4LCBhcnJheSApIHtcblx0cmV0dXJuIGluZGV4ID09IDAgfHwgdmFsdWUgIT0gYXJyYXlbIGluZGV4IC0gMSBdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBqb2luRGF0YSggYXJyYXkgKSB7XG5cdHJldHVybiBhcnJheS5sZW5ndGggPT0gMCA/XG5cdFx0YGBcblx0OiB0eXBlb2YgYXJyYXlbIDAgXSA9PSBgc3RyaW5nYCA/XG5cdFx0YXJyYXkuam9pbiggYGAgKVxuXHQ6IEJ1ZmZlci5pc0J1ZmZlciggYXJyYXlbIDAgXSApID9cblx0XHRCdWZmZXIuY29uY2F0KCBhcnJheSApXG5cdDpcblx0XHRhcnJheS5qb2luKCBgYCApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbiggZW1pdHRlciwgZXZlbnRzICkge1xuXHRsb2Rhc2guZm9yRWFjaCggZXZlbnRzLCAoIGhhbmRsZXIsIGV2ZW50ICkgPT4geyBlbWl0dGVyLm9uKCBldmVudCwgaGFuZGxlciApIH0gKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb2ZmKCBlbWl0dGVyLCBldmVudHMgKSB7XG5cdGxvZGFzaC5mb3JFYWNoKCBldmVudHMsICggaGFuZGxlciwgZXZlbnQgKSA9PiB7IGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyICkgfSApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcmVhZFN0cmVhbSggc3RyZWFtICkge1xuXHRyZXR1cm4geWllbGQgeyB0aGVuKCByZXNvbHZlLCByZWplY3QgKSB7XG5cdFx0bGV0IGNvbnRlbnQgPSBbXVxuXHRcdHN0cmVhbS5vbiggYGRhdGFgLCBjaHVuayA9PiBjb250ZW50LnB1c2goIGNodW5rICkgKVxuXHRcdHN0cmVhbS5vbiggYGVuZGAsICgpID0+IHJlc29sdmUoIGpvaW5EYXRhKCBjb250ZW50ICkgKSApXG5cdFx0c3RyZWFtLm9uKCBgZXJyb3JgLCByZWplY3QgKVxuXHR9IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZWFkSlNPTiggc3RyZWFtICkge1xuXHRyZXR1cm4gSlNPTi5wYXJzZSggeWllbGQgcmVhZFN0cmVhbSggc3RyZWFtICkgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlYWRDaHVuayggc3RyZWFtICkge1xuXHRyZXR1cm4geWllbGQgeyB0aGVuKCByZXNvbHZlLCByZWplY3QgKSB7XG5cdFx0c3RyZWFtLm9uKCBgZGF0YWAsIG9uRGF0YSApXG5cdFx0c3RyZWFtLm9uKCBgZW5kYCwgb25FbmQgKVxuXHRcdHN0cmVhbS5vbiggYGVycm9yYCwgb25FcnJvciApXG5cdFx0ZnVuY3Rpb24gZG9uZSgpIHtcblx0XHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lciggYGRhdGFgLCBvbkRhdGEgKVxuXHRcdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCBgZW5kYCwgb25FbmQgKVxuXHRcdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCBgZXJyb3JgLCBvbkVycm9yIClcblx0XHR9XG5cdFx0ZnVuY3Rpb24gb25EYXRhKCBjaHVuayApIHtcblx0XHRcdGRvbmUoKVxuXHRcdFx0cmVzb2x2ZSggY2h1bmsgKVxuXHRcdH1cblx0XHRmdW5jdGlvbiBvbkVuZCgpIHtcblx0XHRcdGRvbmUoKVxuXHRcdFx0cmVzb2x2ZSggbnVsbCApXG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG9uRXJyb3IoIGVycm9yICkge1xuXHRcdFx0ZG9uZSgpXG5cdFx0XHRyZWplY3QoIGVycm9yIClcblx0XHR9XG5cdH0gfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHkoIG9iaiwgbmFtZSwgZGVmYXVsdFZhbHVlICkge1xuXHRsZXQgcHJpdmF0ZU5hbWUgPSBgX2AgKyBuYW1lXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDIgKVxuXHRcdG9ialsgcHJpdmF0ZU5hbWUgXSA9IGRlZmF1bHRWYWx1ZVxuXHRvYmpbIG5hbWUgXSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09IDAgKVxuXHRcdFx0cmV0dXJuIG9ialsgcHJpdmF0ZU5hbWUgXVxuXHRcdGVsc2Uge1xuXHRcdFx0b2JqWyBwcml2YXRlTmFtZSBdID0gdmFsdWVcblx0XHRcdHJldHVybiBvYmpcblx0XHR9XG5cdH1cblx0cmV0dXJuIG9ialxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9sbGluZyggc3RyZWFtICkge1xuXHRsZXQgcmV0ID0ge1xuXHRcdHN0b3AoKSB7XG5cdFx0XHRpZiAoICFyZXQgKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdGlmICggcmV0Ll9wb2xsaW5nICE9IG51bGwgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggcmV0Ll9wb2xsaW5nIClcblx0XHRcdFx0cmV0Ll9wb2xsaW5nID0gbnVsbFxuXHRcdFx0fVxuXHRcdFx0cmV0ID0gbnVsbFxuXHRcdH0sXG5cdFx0X3BvbGxpbmc6IG51bGwsXG5cdFx0X3RyeVRvU2VuZENodW5rKCkge1xuXHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRyZXQuX3BvbGxpbmcgPSBudWxsXG5cdFx0XHRpZiAoICFzdHJlYW0ud3JpdGUoIHJldC5fY2h1bmsgKSApXG5cdFx0XHRcdHN0cmVhbS5vbmNlKCBgZHJhaW5gLCByZXQuX3RyeVRvU2VuZENodW5rIClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBzdHJlYW0uZmx1c2ggPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRcdFx0c3RyZWFtLmZsdXNoKClcblx0XHRcdFx0cmV0Ll9wb2xsaW5nID0gc2V0VGltZW91dCggcmV0Ll90cnlUb1NlbmRDaHVuaywgcmV0Ll9pbnRlcnZhbCApXG5cdFx0XHR9XG5cdFx0fSxcblx0fVxuXG5cdHByb3BlcnR5KCByZXQsIGBjaHVua2AsIGBcXG5gIClcblx0cHJvcGVydHkoIHJldCwgYGludGVydmFsYCwgNjAwMDAgKVxuXG5cdC8vIFRPRE86IHRoaXMgZXZlbnQgbmV2ZXIgZmlyZXMhIHdoYXQncyB0aGUgc2hpdD8gY2hlY2sgaXQhIG1heSBiZSB0aGUgcmVhc29uIGlzIC51c2UoIHJlcXVpcmUoIGBjb21wcmVzc2lvbmAgKSggeyB0aHJlc2hvbGQ6IDAgfSApICk/XG5cdHN0cmVhbS5vbmNlKCBgZW5kYCwgcmV0LnN0b3AgKVxuXHQvLyBUT0RPOiB0aGlzIGV2ZW50IG5ldmVyIGZpcmVzISB3aGF0J3MgdGhlIHNoaXQ/IGNoZWNrIGl0ISBtYXkgYmUgdGhlIHJlYXNvbiBpcyAudXNlKCByZXF1aXJlKCBgY29tcHJlc3Npb25gICkoIHsgdGhyZXNob2xkOiAwIH0gKSApP1xuXHRzdHJlYW0ub25jZSggYGNsb3NlYCwgcmV0LnN0b3AgKVxuXHQvLyBUT0RPOiB0aGlzIGV2ZW50IG5ldmVyIGZpcmVzISB3aGF0J3MgdGhlIHNoaXQ/IGNoZWNrIGl0ISBtYXkgYmUgdGhlIHJlYXNvbiBpcyAudXNlKCByZXF1aXJlKCBgY29tcHJlc3Npb25gICkoIHsgdGhyZXNob2xkOiAwIH0gKSApP1xuXHRzdHJlYW0ub25jZSggYGVycm9yYCwgcmV0LnN0b3AgKVxuXG5cdHByb2Nlc3MubmV4dFRpY2soIHJldC5fdHJ5VG9TZW5kQ2h1bmsgKVxuXG5cdHJldHVybiByZXRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2V0KCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKVxuXHRcdHJldHVybiBmYWxzZVxuXHRsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIG9iaiApXG5cdHJldHVybiBwcm90byA9PT0gTGl0ZXJhbFByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0U3RyaW5nKCBhcnJheSApIHtcblx0bGV0IHJldCA9IGBgXG5cdCFmdW5jdGlvbiB3YWxrKCBhcnJheSApIHtcblx0XHRpZiAoIHR5cGVvZiBhcnJheSAhPSBgb2JqZWN0YCApXG5cdFx0XHRyZXQgKz0gYXJyYXlcblx0XHRlbHNlIGlmICggYXJyYXkubGVuZ3RoICE9IG51bGwgKVxuXHRcdFx0YXJyYXkuZm9yRWFjaCggd2FsayApXG5cdFx0ZWxzZVxuXHRcdFx0Zm9yICggbGV0IHMgb2YgYXJyYXkgKVxuXHRcdFx0XHR3YWxrKCBzIClcblx0fSggYXJyYXkgKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0ZWREaWZmKCBmaXJzdCwgc2Vjb25kICkge1xuXHRsZXQgZmkgPSBmaXJzdFsgU3ltYm9sLml0ZXJhdG9yIF0oKVxuXHRsZXQgc2kgPSBzZWNvbmRbIFN5bWJvbC5pdGVyYXRvciBdKClcblx0bGV0IHJldCA9IHtcblx0XHRjb21tb246IFtdLFxuXHRcdGZpcnN0OiBbXSxcblx0XHRzZWNvbmQ6IFtdLFxuXHR9XG5cdGxldCBmdiA9IGZpLm5leHQoKSwgc3YgPSBzaS5uZXh0KClcblx0d2hpbGUgKCAhZnYuZG9uZSB8fCAhc3YuZG9uZSApIHtcblx0XHRpZiAoIHN2LmRvbmUgfHwgZnYudmFsdWUgPCBzdi52YWx1ZSApIHtcblx0XHRcdHJldC5maXJzdC5wdXNoKCBmdi52YWx1ZSApXG5cdFx0XHRmdiA9IGZpLm5leHQoKVxuXHRcdH1cblx0XHRlbHNlIGlmICggZnYuZG9uZSB8fCBmdi52YWx1ZSA+IHN2LnZhbHVlICkge1xuXHRcdFx0cmV0LnNlY29uZC5wdXNoKCBzdi52YWx1ZSApXG5cdFx0XHRzdiA9IHNpLm5leHQoKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldC5jb21tb24ucHVzaCggZnYudmFsdWUgKVxuXHRcdFx0ZnYgPSBmaS5uZXh0KClcblx0XHRcdHN2ID0gc2kubmV4dCgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmUoIGZ1biApIHtcblx0bGV0IG5vdyA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCBnbG9iYWwuRGF0ZVxuXHRsZXQgdCA9IG5vdy5ub3coKVxuXHR0cnkge1xuXHRcdHJldHVybiBmdW4oKVxuXHR9XG5cdGZpbmFsbHkge1xuXHRcdHQgPSAoIG5vdy5ub3coKSAtIHQgKSAvIDEwMDBcblx0XHRpZiAoIHQgPiAwICkge1xuXHRcdFx0bGV0IGkgPSAxXG5cdFx0XHR3aGlsZSAoIHQgPCAxMDAwICkge1xuXHRcdFx0XHRpICo9IDEwXG5cdFx0XHRcdHQgKj0gMTBcblx0XHRcdH1cblx0XHRcdHQgPSBNYXRoLnJvdW5kKCB0ICkgLyBpXG5cdFx0fVxuXHRcdGNvbnNvbGUubG9nKCB0IClcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNraXAoIGMsIGJ1ZiApIHtcblx0Zm9yICggbGV0IGIgb2YgYnVmICkge1xuXHRcdGlmICggYyA+IDAgKVxuXHRcdFx0LS1jXG5cdFx0ZWxzZVxuXHRcdFx0eWllbGQgYlxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogdGFrZSggYywgYnVmICkge1xuXHRmb3IgKCBsZXQgYiBvZiBidWYgKSB7XG5cdFx0aWYgKCBjID4gMCApIHtcblx0XHRcdC0tY1xuXHRcdFx0eWllbGQgYlxuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHRicmVha1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KCBidWYgKSB7XG5cdGxldCByZXQgPSBhcnJheSggYnVmIClcblx0aWYgKCByZXQgPT0gYnVmIClcblx0XHRyZXQgPSBidWYuc2xpY2UoKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheTEoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKVxuXHRcdHJldHVybiB2YWx1ZVxuXHRlbHNlXG5cdFx0cmV0dXJuIFsgdmFsdWUgXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXkoIGJ1ZiApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCBidWYgKSApXG5cdFx0cmV0dXJuIGJ1ZlxuXHRsZXQgcmV0ID0gW11cblx0aWYgKCAhYnVmWyBTeW1ib2wuaXRlcmF0b3IgXSApXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpIClcblx0XHRcdHJldC5wdXNoKCBidWZbIGkgXSApXG5cdGVsc2Vcblx0XHRmb3IgKCBsZXQgYiBvZiBidWYgKVxuXHRcdFx0cmV0LnB1c2goIGIgKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoIGJ1ZiApIHtcblx0aWYgKCBidWYgaW5zdGFuY2VvZiBCdWZmZXIgKVxuXHRcdHJldHVybiBidWZcblx0ZWxzZVxuXHRcdHJldHVybiBuZXcgQnVmZmVyKCBhcnJheSggYnVmICkgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmVjdG9yKCBidWYgKSB7XG5cdHJldHVybiBidWYgaW5zdGFuY2VvZiBCdWZmZXIgPyBidWYgOiBhcnJheSggYnVmIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBjb25jYXQoIGxpc3QgKSB7XG5cdGZvciAoIGxldCBsIG9mIGxpc3QgKSBmb3IgKCBsZXQgeCBvZiBsICkgeWllbGQgeFxufVxuXG5leHBvcnQgZnVuY3Rpb24gd29yZCggdyApIHtcblx0cmV0dXJuIFsgdyAmIDB4ZmYsICggdyA+PiA4ICkgJiAweGZmIF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGR3b3JkKCB3ICkge1xuXHRyZXR1cm4gWyB3ICYgMHhmZiwgKCB3ID4+IDggKSAmIDB4ZmYsICggdyA+PiAxNiApICYgMHhmZiwgKCB3ID4+IDI0ICkgJiAweGZmIF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VXb3JkKCBsbywgaGkgKSB7XG5cdHJldHVybiAoIGxvICYgMHhmZiApICsgKCBoaSAmIDB4ZmYgKSA8PCA4XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUVxdWFsKCBhLCBiICkge1xuXHRyZXR1cm4gYSAmJiBiICYmIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoICggYWksIGkgKSA9PiBhaSA9PSBiWyBpIF0gKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZSggYSwgYiApIHtcblx0aWYgKCBhID09IGIgKVxuXHRcdHJldHVybiAwXG5cdGlmICggYSA8IGIgKVxuXHRcdHJldHVybiAtMVxuXHRyZXR1cm4gMVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0bXMoIHZhbHVlICkge1xuXHRsZXQgcmV0ID0gYGBcblx0dmFsdWUgPSBNYXRoLnJvdW5kKCB2YWx1ZSApXG5cdGxldCBtcyA9IHZhbHVlICUgMTAwMFxuXHR2YWx1ZSAtPSBtc1xuXHR2YWx1ZSAvPSAxMDAwXG5cdGxldCBzID0gdmFsdWUgJSA2MFxuXHR2YWx1ZSAtPSBzXG5cdHZhbHVlIC89IDYwXG5cdGxldCBtID0gdmFsdWUgJSA2MFxuXHR2YWx1ZSAtPSBtXG5cdHZhbHVlIC89IDYwXG5cdGxldCBoID0gdmFsdWVcblx0cmV0ICs9IGggPyBoIDogYGBcblx0cmV0ICs9IHJldCA/IGA6YCArIHooIG0sIDIgKSA6IG0gPyBtIDogYGBcblx0cmV0ICs9IHJldCA/IGA6YCArIHooIHMsIDIgKSA6IHNcblx0cmV0ICs9IGAuYCArIHooIG1zLCAzIClcblx0cmV0dXJuIHJldFxuXHRmdW5jdGlvbiB6KCB2YWx1ZSwgbGVuICkge1xuXHRcdGxldCBzdHIgPSBTdHJpbmcoIHZhbHVlIClcblx0XHRsZXQgcmV0ID0gYGBcblx0XHRmb3IgKCBsZXQgaSA9IHN0ci5sZW5ndGg7IGkgPCBsZW47ICsraSApXG5cdFx0XHRyZXQgKz0gYDBgXG5cdFx0cmV0ICs9IHN0clxuXHRcdHJldHVybiByZXRcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KCBvYmosIC4uLnBhdGggKSB7XG5cdGZvciAoIGxldCBwIG9mIHBhdGggKVxuXHRcdGlmICggb2JqID09IG51bGwgKVxuXHRcdFx0YnJlYWtcblx0XHRlbHNlXG5cdFx0XHRvYmogPSBvYmpbIHAgXVxuXHRyZXR1cm4gb2JqXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW1pdENhbGxzKCBsaW1pdCwgcGVyaW9kLCBtZXNzYWdlICkge1xuXHRsZXQgY2FsbHMgPSAwXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCBjYWxscyA+PSBsaW1pdCApXG5cdFx0XHRpZiAoIG1lc3NhZ2UgKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IuY3JlYXRlKCBtZXNzYWdlIClcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0KytjYWxsc1xuXHRcdHNldFRpbWVvdXQoICgpID0+IC0tY2FsbHMsIHBlcmlvZCApXG5cdFx0cmV0dXJuIHRydWVcblx0fVxufVxuIiwiLy8gb3B0aW9uc1xuXG5sZXQgb3B0aW9ucyA9IHtcblx0bWluOiBgdHJhY2VgLFxuXHRsb2c6IDEsXG5cdHN0dWI6IHt9LFxuXHRzcnY6IHtcblx0XHR3czoge30sXG5cdFx0Ym9zczogMSYme30sXG5cdFx0bW9kZW06IDEmJntcblx0XHRcdHByb3h5OiAxJiZ7XG5cdFx0XHRcdGRhdGE6IDEmJnt9LFxuXHRcdFx0XHRsb2c6IDEmJnt9LFxuXHRcdFx0fSxcblx0XHR9LFxuXHR9LFxuXHRtb2RlbTogMSYme1xuXHRcdHRyYW5zZm9ybTogMSYme30sXG5cdH0sXG5cdGJvc3M6IDAmJnt9LFxuXHRodHRwOiAxJiZ7fSxcblx0dWk6IDAmJntcblx0XHRldmVudDogMCYme30sXG5cdH0sXG59XG5cbi8vIGVuZCBvZiBvcHRpb25zXG5cbmltcG9ydCBcImNvbG9yc1wiXG5cbmxldCBsb2dfc3RyZWFtID0gcHJvY2Vzcy5zdGRlcnIgfHwgeyB3cml0ZTogOjpjb25zb2xlLmxvZyB9XG5cbmxldCBwcmVmaXhlcyA9IHtcblx0dHJhY2U6IGBUUkFDRSBgLmdyZWVuLFxuXHRlcnJvcjogYEVSUk9SIGAueWVsbG93LFxuXHRmYXRhbDogYEZBVEFMIGAucmVkLFxufVxuXG5sZXQgdmFsdWVzID0ge31cbmxldCBjdXJyZW50ID0gMFxubGV0IG1haW4gPSBPYmplY3QuY3JlYXRlKCBudWxsIClcbmxldCBtZXRob2QgPSBuYW1lID0+IHtcblx0dmFsdWVzWyBuYW1lIF0gPSArK2N1cnJlbnRcblx0cmV0dXJuIG1haW5bIG5hbWUgXSA9IExvZy5iaW5kKCBudWxsLCBuYW1lIClcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUoIGtpbmQgKSB7XG5cdHJldHVybiB2YWx1ZXNbIGtpbmQgXSB8fCB2YWx1ZXMubG9nIHx8IDBcbn1cblxuZnVuY3Rpb24gTG9nKCkge1xuXHRsZXQgbCA9IG9wdGlvbnNcblx0aWYgKCBsID09PSBmYWxzZSB8fCBsID09PSAwIClcblx0XHRyZXR1cm5cblx0bGV0IGtpbmQgPSBhcmd1bWVudHNbIDAgXVxuXHRpZiAoIGdldFZhbHVlKCBraW5kICkgPCBnZXRWYWx1ZSggb3B0aW9ucy5taW4gKSApXG5cdFx0cmV0dXJuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kgKSB7XG5cdFx0bCA9IGxbIGFyZ3VtZW50c1sgaSBdIF1cblx0XHRpZiAoIGwgPT09IGZhbHNlIHx8IGwgPT09IDAgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCBsID09IG51bGwgKVxuXHRcdFx0YnJlYWtcblx0fVxuXHRsZXQgcGF0aCA9IGBgXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kgKSB7XG5cdFx0cGF0aCArPSBgIGBcblx0XHRwYXRoICs9IGFyZ3VtZW50c1sgaSBdXG5cdH1cblx0bGV0IG1zZyA9IGFyZ3VtZW50c1sgYXJndW1lbnRzLmxlbmd0aCAtIDEgXVxuXHRsb2dfc3RyZWFtLndyaXRlKCBgJHsgcHJlZml4ZXNbIGtpbmQgXSB8fCBgYCB9JHsgYCR7ICggbmV3IERhdGUgKS50b0lTT1N0cmluZygpLnJlcGxhY2UoIGBUYCwgYDtgICkucmVwbGFjZSggYFpgLCBgYCApIH0keyBwYXRoIH06YC5ncmF5IH0gJHsgbXNnIH1cXG5gIClcblx0bG9nX3N0cmVhbS5mbHVzaCAmJiBsb2dfc3RyZWFtLmZsdXNoKClcbn1cblxuLy8gb3JkZXIgb2YgbWV0aG9kcyBkb2VzIG1hdHRlci4gVGhlIGxhdGVyIHRoZSBpbXBvcnRhbnQuXG5leHBvcnQgY29uc3QgdHJhY2UgPSBtZXRob2QoIGB0cmFjZWAgKVxuZXhwb3J0IGNvbnN0IGxvZyA9IG1ldGhvZCggYGxvZ2AgKVxuZXhwb3J0IGNvbnN0IGVycm9yID0gbWV0aG9kKCBgZXJyb3JgIClcbmV4cG9ydCBjb25zdCBmYXRhbCA9IG1ldGhvZCggYGZhdGFsYCApXG5cbmV4cG9ydCBjb25zdCBvcGVuID0gZnVuY3Rpb24gb3BlbiggLi4uYXJncyApIHtcblx0bGV0IHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRyZXQub3BlbiA9IG9wZW5cblx0Zm9yICggbGV0IGtpbmQgaW4gbWFpbiApXG5cdFx0cmV0WyBraW5kIF0gPSB0aGlzWyBraW5kIF0uYmluZCggbnVsbCwgLi4uYXJncyApXG5cdHJldHVybiByZXRcbn0uYmluZCggbWFpbiApXG5cbmV4cG9ydCBjb25zdCBzZXRTdHJlYW0gPSBzdHJlYW0gPT4gbG9nX3N0cmVhbSA9IHN0cmVhbVxuXG5sb2coIGBsb2dgLCBgc3RhcnRgLCBKU09OLnN0cmluZ2lmeSggcHJvY2Vzcy5hcmd2ICkgKVxuIiwiLy8gaHR0cHM6Ly9rcHMuc2tldGNoLmJ5L3N2bi9kZWEvdHJhbnNjb2Rlcl9tNC9zcmMvRGVidWcvRXhlL1xuXG5pbXBvcnQgKiBhcyBzdHJlYW0gZnJvbSBcInN0cmVhbVwiXG5pbXBvcnQgKiBhcyBsb2Rhc2ggZnJvbSBcImxvZGFzaFwiXG5pbXBvcnQgKiBhcyBDUkMgZnJvbSBcIm5ldHJvL21vZGVtY3JjXCJcbmltcG9ydCAqIGFzIGNvIGZyb20gXCJjb1wiXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCJ1dGlsXCJcbmltcG9ydCAqIGFzIGx1IGZyb20gXCJsb2NhbFV0aWxzXCJcbmltcG9ydCAqIGFzIHNmIGZyb20gXCJzZlwiXG5cbmltcG9ydCAqIGFzIExvZyBmcm9tIFwibG9nXCJcbmxldCBtb2RlbV9sb2cgPSBMb2cub3BlbiggYG1vZGVtYCApXG5cbmNvbnN0IFVTQl9iRkxBR19EQVRBID0gMHg3ZVxuY29uc3QgVVNCX2JTVEFGX0RBVEEgPSAweDdkXG5jb25zdCBQUk9UT0NPTF9OVU1CRVIgPSAxXG5cbmNvbnN0IE1PREVNX1RJTUVPVVQgPSA5MDAwXG5cbmNsYXNzIE1vZGVtRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuY2xhc3MgTW9kZW1UaW1lb3V0IGV4dGVuZHMgTW9kZW1FcnJvciB7fVxuXG5sZXQgdGhyb3dNb2RlbVRpbWVvdXQgPSAoKSA9PiB7IHRocm93IG5ldyBNb2RlbVRpbWVvdXQoKSB9XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVtIHtcblxuXHRjb25zdHJ1Y3RvciggZHVwbGV4LCBsb2cgPSBtb2RlbV9sb2cgKSB7XG5cdFx0bGV0IG1vZGVtID0gc2YuRnVuYyggZHVwbGV4OjpzZi5jb25uZWN0KCBNb2RlbS5CaW5hcnlTdHJlYW0oIGxvZyApICksXG5cdFx0XHR7IHRpbWVvdXQ6IE1PREVNX1RJTUVPVVQsIHRocm93VGltZW91dDogdGhyb3dNb2RlbVRpbWVvdXQgfSApXG5cdFx0dGhpcy5sb2NrID0gY28uc3luY2hyb25pemVkKCBjYWxsYmFjayA9PiBjYWxsYmFjayggKCAuLi5hcmdzICkgPT4gbW9kZW0oIGFyZ3MgKSApIClcblx0fVxuXG5cdC8vIGNvbnN0cnVjdG9yKCBtaW4sIG1vdXQgPSBtaW4gKSB7XG5cdC8vIFx0bGV0IG1vZGVtID0gY28uUGlwZS5tYWtlRnVuYyhcblx0Ly8gXHRcdGNvLlBpcGUubWFwKCBNb2RlbS5tYXBUb0JpbmFyeSApLnRvU3RyZWFtKCBtb3V0ICksXG5cdC8vIFx0XHRtaW46OmNvLlBpcGUuY3JlYXRlKCkudHJhbnNmb3JtKCBNb2RlbS50cmFuc2Zvcm1Gcm9tQmluYXJ5ICksXG5cdC8vIFx0XHRNT0RFTV9USU1FT1VULFxuXHQvLyBcdFx0dGhyb3dNb2RlbVRpbWVvdXQsXG5cdC8vIFx0KVxuXHQvLyBcdHRoaXMubG9jayA9IGNvLnN5bmNocm9uaXplZCggY2FsbGJhY2sgPT4gY2FsbGJhY2soICggLi4uYXJncyApID0+IG1vZGVtKCBhcmdzICkgKSApXG5cdC8vIH1cblxuXHRzdGF0aWMgZW5jb2RlKCBjb21tYW5kLCBpbmZvICkge1xuXHRcdGlmICggdHlwZW9mIGNvbW1hbmQgIT0gYHN0cmluZ2AgKSB7XG5cdFx0XHRpbmZvID0gY29tbWFuZFxuXHRcdFx0Y29tbWFuZCA9IGluZm8uaWRcblx0XHR9XG5cdFx0bGV0IGFycmF5ID0gTW9kZW0uX2NvbW1hbmRzWyBjb21tYW5kIF0oIGluZm8gKVxuXHRcdGlmICggYXJyYXkubGVuZ3RoID4gMHhmZiApXG5cdFx0XHR0aHJvdyBuZXcgTW9kZW1FcnJvciggYHRvbyBsb25nIG1lc3NhZ2VgIClcblx0XHRhcnJheS51bnNoaWZ0KCAweGZmLCAweDAzLCBQUk9UT0NPTF9OVU1CRVIsIGFycmF5Lmxlbmd0aCApXG5cdFx0YXJyYXkucHVzaCggLi4ubHUud29yZCggQ1JDLmNhbGNfY3JjKCBhcnJheSApICkgKVxuXHRcdGxldCBidWZmZXIgPSBbIFVTQl9iRkxBR19EQVRBIF1cblx0XHRmb3IgKCBsZXQgZCBvZiBhcnJheSApIHtcblx0XHRcdGlmICggZCA9PSBVU0JfYkZMQUdfREFUQSB8fCBkID09IFVTQl9iU1RBRl9EQVRBIClcblx0XHRcdFx0YnVmZmVyLnB1c2goIFVTQl9iU1RBRl9EQVRBIClcblx0XHRcdGJ1ZmZlci5wdXNoKCBkIClcblx0XHR9XG5cdFx0cmV0dXJuIGx1LmJ1ZmZlciggYnVmZmVyIClcblx0fVxuXG5cdHN0YXRpYyBleHRyYWN0TWVzc2FnZSggZGF0YSApIHtcblx0XHRpZiAoIGRhdGEubGVuZ3RoIDwgNCApXG5cdFx0XHRyZXR1cm4gbnVsbFxuXHRcdGRhdGEgPSBsdS5hcnJheSggZGF0YSApXG5cdFx0aWYgKCAhKCBkYXRhWyAwIF0gPT0gVVNCX2JGTEFHX0RBVEEgJiYgZGF0YVsgMSBdID09IDB4ZmYgJiYgZGF0YVsgMiBdID09IDB4MDMgJiYgZGF0YVsgMyBdID09IFBST1RPQ09MX05VTUJFUiApIClcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdHJldHVybiBjaGVja0NSQyggZGF0YSwgQXBwbHlQMVJlYWRlcnMgKVxuXHR9XG5cblx0c3RhdGljIEJpbmFyeVN0cmVhbSggbG9nICkge1xuXHRcdHJldHVybiBzZi5kdXBsZXhlciggTW9kZW0uRnJvbUJpbmFyeSggbG9nICksIE1vZGVtLlRvQmluYXJ5KCBsb2cgKSApXG5cdH1cblxuXHRzdGF0aWMgQ29tbWFuZFN0cmVhbSggbG9nICkge1xuXHRcdHJldHVybiBCaW5hcnlTdHJlYW0oIGxvZyApLm90aGVyXG5cdH1cblxuXHRzdGF0aWMgVG9CaW5hcnkoIGxvZyApIHtcblx0XHRyZXR1cm4gbmV3IHN0cmVhbS5UcmFuc2Zvcm0oIHsgd3JpdGFibGVPYmplY3RNb2RlOiB0cnVlLCB0cmFuc2Zvcm0oIGNvbW1hbmQsIGVuY29kaW5nLCBjYWxsYmFjayApIHtcblx0XHRcdHRoaXMucHVzaCggTW9kZW0uZW5jb2RlKCAuLi5jb21tYW5kICkgKVxuXHRcdFx0Y2FsbGJhY2soKVxuXHRcdH0gfSApXG5cdH1cblxuXHRzdGF0aWMgRnJvbUJpbmFyeSggbG9nICkge1xuXG5cdFx0bGV0IGJ1ZmZlciA9IFtdXG5cdFx0bGV0IHN0YWYgPSBmYWxzZVxuXG5cdFx0cmV0dXJuIG5ldyBzdHJlYW0uVHJhbnNmb3JtKCB7IHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSwgdHJhbnNmb3JtKCBjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrICkge1xuXHRcdFx0bG9nICYmIGxvZy5sb2coIGB0cmFuc2Zvcm1gLCBgcmVjZWl2ZWRgLCB1dGlsLmluc3BlY3QoIGNodW5rICkgKVxuXHRcdFx0aWYgKCAhKCBjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlciApIClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgY2h1bmsgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBCdWZmZXJgIClcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgKytpICkge1xuXHRcdFx0XHRsZXQgZCA9IGNodW5rWyBpIF1cblx0XHRcdFx0aWYgKCBidWZmZXIubGVuZ3RoID09IDAgJiYgZCAhPSBVU0JfYkZMQUdfREFUQSApXG5cdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0aWYgKCBzdGFmICkge1xuXHRcdFx0XHRcdHN0YWYgPSBmYWxzZVxuXHRcdFx0XHRcdGJ1ZmZlci5wdXNoKCBkIClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggZCA9PSBVU0JfYlNUQUZfREFUQSApIHtcblx0XHRcdFx0XHRzdGFmID0gdHJ1ZVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGJ1ZmZlci5wdXNoKCBkIClcblx0XHRcdFx0bGV0IHNraXBwZWRcblx0XHRcdFx0bGV0IG1zZ1xuXHRcdFx0XHR3aGlsZSAoICggbXNnID0gTW9kZW0uZXh0cmFjdE1lc3NhZ2UoIGJ1ZmZlciApICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGlmICggIXNraXBwZWQgKVxuXHRcdFx0XHRcdFx0c2tpcHBlZCA9IFtdXG5cdFx0XHRcdFx0c2tpcHBlZC5wdXNoKCBidWZmZXJbIDAgXSApXG5cdFx0XHRcdFx0YnVmZmVyLnNoaWZ0KClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHNraXBwZWQgKVxuXHRcdFx0XHRcdGxvZyAmJiBsb2cubG9nKCBgdHJhbnNmb3JtYCwgYHNraXBwZWRgLCB1dGlsLmluc3BlY3QoIHNraXBwZWQgKSApXG5cdFx0XHRcdGlmICggbXNnICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0bG9nICYmIGxvZy5sb2coIGB0cmFuc2Zvcm1gLCBgcGFyc2VkYCwgdXRpbC5pbnNwZWN0KCBtc2cgKSApXG5cdFx0XHRcdFx0dGhpcy5wdXNoKCBtc2cgKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fSB9IClcblx0fVxufVxuXG4vLyBmdW5jdGlvbiBMT0coIG1zZywgYXJnICkge1xuLy8gXHRwcm9jZXNzLnN0ZGVyci53cml0ZSggbXNnICsgYCBgICsgKCBhcmcgJiYgYXJnLmluc3BlY3QgPyBhcmcuaW5zcGVjdCgpIDogSlNPTi5zdHJpbmdpZnkoIGFyZyApICkgKyBgXFxuYCApXG4vLyBcdHJldHVybiBhcmdcbi8vIH1cblxuTW9kZW0uRXJyb3IgPSBNb2RlbUVycm9yXG5Nb2RlbS5FVGltZW91dCA9IE1vZGVtVGltZW91dFxuXG5Nb2RlbS5fY29tbWFuZHMgPSB7fVxuXG5sZXQgZGF0YVNpemUgPSBieXRlKCA0IClcbmxldCBkYXRhQ1JDID0ge1xuXHRyZWFkOiBkYXRhID0+IHtcblx0XHRsZXQgc2l6ZSA9IGRhdGFTaXplLnJlYWQoIGRhdGEgKVxuXHRcdHJldHVybiBzaXplID09IG51bGwgPyBudWxsIDogcmVhZFdvcmQoIHNpemUgKyA1LCBkYXRhIClcblx0fSxcblx0d3JpdGU6IGRhdGEgPT4gd3JpdGVXb3JkKCBkYXRhU2l6ZS5yZWFkKCBkYXRhICksIGRhdGEgKSxcbn1cblxubGV0IGNtZDEgPSByZWNvcmQoIHsgbG86IGJ5dGUoIDcgLSA1ICksIGhpOiBieXRlKCA4IC0gNSApIH0gKVxuXG5mdW5jdGlvbiBjaGVja0NSQyggZGF0YSwgY2IgKSB7XG5cdGxldCBjcmMgPSBkYXRhQ1JDLnJlYWQoIGRhdGEgKVxuXHRpZiAoIGNyYyA9PSBudWxsIClcblx0XHRyZXR1cm4gbnVsbFxuXHRsZXQgc2l6ZSA9IGRhdGFTaXplLnJlYWQoIGRhdGEgKVxuXHRpZiAoIGNyYyAhPSBDUkMuY2FsY19jcmMoIGRhdGEuc2xpY2UoIDEsIDUgKyBzaXplICkgKSApXG5cdFx0cmV0dXJuIGZhbHNlXG5cdGxldCByZXQgPSBjYiggZGF0YS5zbGljZSggNSwgNSArIHNpemUgKSApXG5cdGlmICggcmV0IClcblx0XHRkYXRhLnNwbGljZSggMCwgNSArIHNpemUgKyAyIClcblx0ZWxzZVxuXHRcdHJldCA9IGZhbHNlXG5cdHJldHVybiByZXRcbn1cblxubGV0IFAxUmVhZGVycyA9IFtdXG5cbmZ1bmN0aW9uIEFwcGx5UDFSZWFkZXJzKCBkYXRhICkge1xuXHRpZiAoIGRhdGEubGVuZ3RoICE9IDggKVxuXHRcdHJldHVybiBmYWxzZVxuXHRsZXQgY21kID0gY21kMS5yZWFkKCBkYXRhIClcblx0bGV0IGMgPSBQMVJlYWRlcnNbIGNtZC5sbyBdXG5cdGxldCBmID0gYyAmJiAoIGNbIGNtZC5oaSBdID8gY1sgY21kLmhpIF0gOiBjLmFueSApXG5cdGlmICggIWYgKVxuXHRcdHJldHVybiBmYWxzZVxuXHRsZXQgcmV0ID0gZiggZGF0YSApXG5cdHJldHVybiByZXRcbn1cblxuTW9kZW0uV29ya19Nb2RlID0gMVxuTW9kZW0uSW5pdF9EZXZpY2VfTW9kZSA9IDJcbk1vZGVtLkV4dGVuZGVkX1dvcmtfTW9kZSA9IDNcblxuZnVuY3Rpb24gYml0KCBwb3MsIHNoaWZ0LCBtYXNrID0gMSApIHtcblx0cmV0dXJuIHtcblx0XHR3cml0ZSggZGF0YSwgdmFsdWUgKSB7XG5cdFx0XHRkYXRhWyBwb3MgXSA9ICggZGF0YVsgcG9zIF0gJiAoIH4oIG1hc2sgPDwgc2hpZnQgKSApICkgKyAoICggdmFsdWUgJiBtYXNrICkgPDwgc2hpZnQgKVxuXHRcdFx0cmV0dXJuIGRhdGFcblx0XHR9LFxuXHRcdHJlYWQoIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gZGF0YVsgcG9zIF0gPT0gbnVsbCA/IG51bGwgOiAoIGRhdGFbIHBvcyBdID4+IHNoaWZ0ICkgJiBtYXNrXG5cdFx0fSxcblx0fVxufVxuXG5mdW5jdGlvbiBieXRlKCBwb3MgKSB7XG5cdHJldHVybiB7XG5cdFx0d3JpdGUoIGRhdGEsIHZhbHVlICkge1xuXHRcdFx0ZGF0YVsgcG9zIF0gPSB2YWx1ZVxuXHRcdFx0cmV0dXJuIGRhdGFcblx0XHR9LFxuXHRcdHJlYWQoIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gZGF0YVsgcG9zIF1cblx0XHR9LFxuXHR9XG59XG5cbmZ1bmN0aW9uIHdyaXRlV29yZCggcG9zLCBkYXRhLCB2YWx1ZSApIHtcblx0ZGF0YVsgcG9zIF0gPSB2YWx1ZSAmIDB4ZmZcblx0ZGF0YVsgcG9zICsgMSBdID0gKCB2YWx1ZSA+PiA4ICkgJiAweGZmXG5cdHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHJlYWRXb3JkKCBwb3MsIGRhdGEgKSB7XG5cdHJldHVybiBkYXRhWyBwb3MgXSA9PSBudWxsIHx8IGRhdGFbIHBvcyArIDEgXSA9PSBudWxsID8gbnVsbCA6IGRhdGFbIHBvcyBdICsgKCBkYXRhWyBwb3MgKyAxIF0gPDwgOCApXG59XG5cbmZ1bmN0aW9uIHdvcmQoIHBvcyApIHtcblx0cmV0dXJuIHtcblx0XHR3cml0ZTogd3JpdGVXb3JkLmJpbmQoIG51bGwsIHBvcyApLFxuXHRcdHJlYWQ6IHJlYWRXb3JkLmJpbmQoIG51bGwsIHBvcyApLFxuXHR9XG59XG5cbmZ1bmN0aW9uIGR3b3JkKCBwb3MgKSB7XG5cdHJldHVybiB7XG5cdFx0d3JpdGUoIGRhdGEsIHZhbHVlICkge1xuXHRcdFx0ZGF0YVsgcG9zIF0gPSB2YWx1ZSAmIDB4ZmZcblx0XHRcdGRhdGFbIHBvcyArIDEgXSA9ICggdmFsdWUgPj4gOCApICYgMHhmZlxuXHRcdFx0ZGF0YVsgcG9zICsgMiBdID0gKCB2YWx1ZSA+PiAxNiApICYgMHhmZlxuXHRcdFx0ZGF0YVsgcG9zICsgMyBdID0gKCB2YWx1ZSA+PiAyNCApICYgMHhmZlxuXHRcdFx0cmV0dXJuIGRhdGFcblx0XHR9LFxuXHRcdHJlYWQoIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gZGF0YVsgcG9zIF0gPT0gbnVsbCB8fCBkYXRhWyBwb3MgKyAxIF0gPT0gbnVsbCB8fCBkYXRhWyBwb3MgKyAyIF0gPT0gbnVsbCB8fCBkYXRhWyBwb3MgKyAzIF0gPT0gbnVsbCA/IG51bGwgOiBkYXRhWyBwb3MgXSArICggZGF0YVsgcG9zICsgMSBdIDw8IDggKSArICggZGF0YVsgcG9zICsgMiBdIDw8IDE2ICkgKyAoIGRhdGFbIHBvcyArIDMgXSA8PCAyNCApXG5cdFx0fSxcblx0fVxufVxuXG5mdW5jdGlvbiByZWNvcmQoIHR5cGUgKSB7XG5cdHJldHVybiB7XG5cdFx0cmVhZDogZGF0YSA9PiB7XG5cdFx0XHRsZXQgcmV0ID0ge31cblx0XHRcdGZvciAoIGxldCBpIGluIHR5cGUgKSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggdHlwZSwgaSApIClcblx0XHRcdFx0cmV0WyBpIF0gPSB0eXBlWyBpIF0ucmVhZCggZGF0YSApXG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fSxcblx0XHR3cml0ZTogKCBkYXRhLCB2YWx1ZSApID0+IHtcblx0XHRcdGZvciAoIGxldCBpIGluIHR5cGUgKSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggdHlwZSwgaSApIClcblx0XHRcdFx0dHlwZVsgaSBdLndyaXRlKCBkYXRhLCB2YWx1ZVsgaSBdIClcblx0XHRcdHJldHVybiBkYXRhXG5cdFx0fSxcblx0XHRyZWM6IHR5cGUsXG5cdH1cbn1cblxuZnVuY3Rpb24gY29tcG9zZSggdDEsIHQyICkge1xuXHRyZXR1cm4ge1xuXHRcdHJlYWQ6IGRhdGEgPT4gdDEucmVhZCggdDIucmVhZCggZGF0YSApICksXG5cdFx0d3JpdGU6ICggZGF0YSwgdmFsdWUgKSA9PiB0Mi53cml0ZSggZGF0YSwgdDEud3JpdGUoIHZhbHVlICkgKSxcblx0fVxufVxuXG4hZnVuY3Rpb24gSW5pdDEoKSB7XG5cdGxldFxuXHRBQ0sgPSBiaXQoIDExIC0gNSwgNyApLFxuXHRESU0gPSBiaXQoIDExIC0gNSwgNiApLFxuXHRST0wgPSBiaXQoIDExIC0gNSwgNSApLFxuXHQvLyA9IGJpdCggMTEgLSA1LCA0ICksXG5cdFdDSyA9IGJpdCggMTEgLSA1LCAzICksXG5cdFJQTSA9IGJpdCggMTEgLSA1LCAyICksXG5cdERFTCA9IGJpdCggMTEgLSA1LCAxICksXG5cdFNHUlAgPSBiaXQoIDExIC0gNSwgMCApLFxuXHRETiA9IGJpdCggMTIgLSA1LCA3ICksXG5cdFVQID0gYml0KCAxMiAtIDUsIDYgKSxcblx0Ly8gPSBiaXQoIDEyIC0gNSwgNSApLFxuXHQvLyA9IGJpdCggMTIgLSA1LCA0ICksXG5cdC8vID0gYml0KCAxMiAtIDUsIDMgKSxcblx0UFJJT1JJVFkgPSBiaXQoIDEyIC0gNSwgMCwgNyApLFxuXHRfOCA9IGJ5dGUoIDggLSA1ICksXG5cdF85ID0gYnl0ZSggOSAtIDUgKSxcblx0XzEwID0gYnl0ZSggMTAgLSA1ICksXG5cdF8xMSA9IGJ5dGUoIDExIC0gNSApLFxuXHRfMTIgPSBieXRlKCAxMiAtIDUgKSxcblx0XzlfMTAgPSB3b3JkKCA5IC0gNSApLFxuXHRfOV8xMF8xMV8xMiA9IGR3b3JkKCA5IC0gNSApLFxuXHRncm91cCA9IHdvcmQoIDUgLSA1ICksXG5cdGNtZExvID0gY21kMS5yZWMubG8sXG5cdGNtZEhpID0gY21kMS5yZWMuaGksXG5cdGNvbnN0YW50cyA9IHsgY21kTG8sIGNtZEhpIH1cblxuXHRmdW5jdGlvbiBlbnVtZXJhdGlvbiggZW51bWVyYXRpb24gKSB7XG5cdFx0bGV0IHIgPSB7fVxuXHRcdGlmICggZW51bWVyYXRpb25bIFN5bWJvbC5pdGVyYXRvciBdICkge1xuXHRcdFx0bGV0IGkgPSAwXG5cdFx0XHRmb3IgKCBsZXQgbmFtZSBvZiBlbnVtZXJhdGlvbiApIHtcblx0XHRcdFx0aWYgKCBuYW1lICE9IG51bGwgKVxuXHRcdFx0XHRcdHJbIG5hbWUgXSA9IGlcblx0XHRcdFx0KytpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yICggbGV0IGkgaW4gZW51bWVyYXRpb24gKSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggZW51bWVyYXRpb24sIGkgKSApXG5cdFx0XHRcdHJbIGVudW1lcmF0aW9uWyBpIF0gXSA9IGlcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIHZhbHVlICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYG51bWJlcmAgKVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGlmICggU3RyaW5nKCBOdW1iZXIoIHZhbHVlICkgKSA9PSB2YWx1ZSApXG5cdFx0XHRcdHJldHVybiBOdW1iZXIoIHZhbHVlIClcblx0XHRcdGxldCByZXQgPSBlbnVtZXJhdGlvblsgdmFsdWUgXVxuXHRcdFx0aWYgKCByZXQgPT0gbnVsbCApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYHdyb25nIGNvbnN0YW50ICR7IHZhbHVlIH1gIClcblx0XHRcdHJldHVybiByZXRcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlYWQ6IHZhbHVlID0+IHtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0XHRsZXQgcmV0ID0gclsgdmFsdWUgXVxuXHRcdFx0XHRpZiAoIHJldCA9PSBudWxsIClcblx0XHRcdFx0XHRyZXQgPSB2YWx1ZVxuXHRcdFx0XHRyZXR1cm4gcmV0XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IHZhbHVlID0+IHtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0XHRsZXQgcmV0ID0gdmFsdWVcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApIClcblx0XHRcdFx0XHRyZXQgPSB2YWx1ZS5tYXAoIGdldFZhbHVlICkucmVkdWNlKCAoIGEsIGIgKSA9PiBhIHwgYiApXG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT0gYHN0cmluZ2AgKVxuXHRcdFx0XHRcdHJldCA9IGdldFZhbHVlKCB2YWx1ZSApXG5cdFx0XHRcdHJldHVybiByZXRcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVjKCBwcmVjaXNpb24gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlYWQ6IGMgPT4gYyA9PSBudWxsID8gbnVsbCA6IGMgKiBwcmVjaXNpb24sXG5cdFx0XHR3cml0ZTogYyA9PiBjID09IG51bGwgPyBudWxsIDogTWF0aC5yb3VuZCggYyAvIHByZWNpc2lvbiApLFxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxlZnRwYWQoIHN0ciwgbGVuLCBwYWQgPSBgIGAgKSB7XG5cdFx0bGV0IHAgPSBgYFxuXHRcdGxldCBsID0gbGVuIC0gc3RyLmxlbmd0aFxuXHRcdGlmICggIXBhZCApXG5cdFx0XHRyZXR1cm4gc3RyXG5cdFx0d2hpbGUgKCBsICYmIGwgPiAwICkge1xuXHRcdFx0cCArPSBwYWRcblx0XHRcdC0tbFxuXHRcdH1cblx0XHRyZXR1cm4gcCArIHN0clxuXHR9XG5cblx0ZnVuY3Rpb24gaGV4KCBsZW4gPSAwICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZWFkOiBjID0+IGMgPT0gbnVsbCA/IG51bGwgOiBsZWZ0cGFkKCBjLnRvU3RyaW5nKCAxNiApLCBsZW4sIGAwYCApLFxuXHRcdFx0d3JpdGU6IGMgPT4gYyA9PSBudWxsID8gbnVsbCA6IHBhcnNlSW50KCBjLCAxNiApLFxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldCggc2V0ICkge1xuXHRcdGZ1bmN0aW9uIGNoZWNrKCkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2V0ID09IGBzdHJpbmdgIClcblx0XHRcdFx0c2V0ID0gdHlwZXNbIHNldCBdXG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIHNldC5yZWFkICE9IGBmdW5jdGlvbmAgKVxuXHRcdFx0XHRzZXQgPSBlbnVtZXJhdGlvbiggc2V0IClcblx0XHRcdGNoZWNrID0gKCkgPT4ge31cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlYWQ6IHggPT4ge1xuXHRcdFx0XHRjaGVjaygpXG5cdFx0XHRcdGlmICggeCA9PSBudWxsIClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0XHRsZXQgaSA9IDBcblx0XHRcdFx0bGV0IHJldCA9IHt9XG5cdFx0XHRcdHdoaWxlICggeCApIHtcblx0XHRcdFx0XHRpZiAoIHggJiAxIClcblx0XHRcdFx0XHRcdHJldFsgc2V0LnJlYWQoIGkgKSBdID0gdHJ1ZVxuXHRcdFx0XHRcdCsraVxuXHRcdFx0XHRcdHggPj49IDFcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IHggPT4ge1xuXHRcdFx0XHRjaGVjaygpXG5cdFx0XHRcdGlmICggeCA9PSBudWxsIHx8IHR5cGVvZiB4ICE9IGBvYmplY3RgIClcblx0XHRcdFx0XHRyZXR1cm4geFxuXHRcdFx0XHRsZXQgcmV0ID0gMFxuXHRcdFx0XHRpZiAoICF4WyBTeW1ib2wuaXRlcmF0b3IgXSApXG5cdFx0XHRcdFx0eCA9IE9iamVjdC5rZXlzKCB4ICkuZmlsdGVyKCBpID0+IHhbIGkgXSApXG5cdFx0XHRcdGZvciAoIGxldCBpIG9mIHggKVxuXHRcdFx0XHRcdHJldCB8PSAxIDw8IHNldC53cml0ZSggaSApXG5cdFx0XHRcdHJldHVybiByZXRcblx0XHRcdH0sXG5cdFx0fVxuXHR9XG5cblx0bGV0IHR5cGVzID0ge1xuXHRcdEdST1VQOiBlbnVtZXJhdGlvbigge1xuXHRcdFx0QW55X0dyb3VwOiAwLFxuXHRcdH0gKSxcblx0XHRDTUQ6IGVudW1lcmF0aW9uKCB7XG5cdFx0XHROb25lOiAwLFxuXHRcdFx0U3RvcDogMSxcblx0XHRcdFVwOiAyLFxuXHRcdFx0RG93bjogMyxcblx0XHRcdENvbWZvcnRfMTogNCxcblx0XHRcdENvbWZvcnRfMjogNSxcblx0XHRcdFNjcmlwdDogNixcblx0XHRcdExvb3A6IDcsXG5cdFx0XHRTZXRfVG9fQ29tZm9ydDogOCxcblx0XHR9ICksXG5cdFx0VElNRTogZW51bWVyYXRpb24oIHtcblx0XHRcdFByZXNzZWRfMF9zZWM6IDEsXG5cdFx0XHRQcmVzc2VkXzBfNV9zZWM6IDIsXG5cdFx0XHRQcmVzc2VkXzFfc2VjOiAzLFxuXHRcdFx0UHJlc3NlZF80OiA0LFxuXHRcdFx0UmVsZWFzZWRfMF9zZWM6IDksXG5cdFx0XHRSZWxlYXNlZF8wXzVfc2VjOiAxMCxcblx0XHRcdFJlbGVhc2VkXzFfc2VjOiAxMSxcblx0XHRcdFJlbGVhc2VkXzRfc2VjOiAxMixcblx0XHR9ICksXG5cdFx0Ly8gQVRUUklCVVRFOiAuLi4sXG5cdFx0Q09NRk9SVDogcHJlYyggMC4wMDAxICksIC8vIDAuLjFcblx0XHRNT1ZFX1RJTUU6IHByZWMoIDAuMDEgKSwgLy8gc2Vjb25kc1xuXHRcdE1PREU6IGVudW1lcmF0aW9uKCBbXG5cdFx0XHRgSWdub3JlX0Zvcl9PdXRgLFxuXHRcdFx0YElkbGVgLFxuXHRcdFx0YFNldHRpbmdgLFxuXHRcdFx0YENvbWZvcnRfMWAsXG5cdFx0XHRgQ29tZm9ydF8yYCxcblx0XHRcdGBTZWxmX0dyb3VwYCxcblx0XHRcdGBSZW1vdGVgLFxuXHRcdFx0YFByb2dyYW1gLFxuXHRcdFx0YFNjcmlwdGAsXG5cdFx0XHRgQ29tZm9ydF9Gb3JfU2NyaXB0YCxcblx0XHRcdGBVcGRhdGVgLFxuXHRcdF0gKSxcblx0XHQvLyBNQVNLOiAuLi4sXG5cdFx0Ly8gTU9ERV9TRVRUSU5HOiAuLi4sXG5cdFx0Ly8gU1lTVEVNX1NFVFRJTkc6IC4uLixcblx0XHQvLyBDTURfU0VUVElORzogLi4uLFxuXHRcdEdST1VQX1NFVFRJTkc6IGVudW1lcmF0aW9uKCBbXG5cdFx0XHRgUmVjZWl2ZWRfQ21kX0lzX0V4ZWN1dGVkX09ubHlfTG9jYWxseWAsXG5cdFx0XHRgUmVjZWl2ZWRfQ21kX0lzX0V4ZWN1dGVkX0xvY2FsbHlfQW5kX0Zvcl9TZWxmX0dyb3VwYCxcblx0XHRdICksXG5cdFx0Ly8gREVGQVVMX1NFVFRJTkc6IC4uLixcblx0XHRLRVlQQURfU1RBVFVTOiBzZXQoIFtcblx0XHRcdGBLZXlfVXBfUHJlc3NlZGAsXG5cdFx0XHRgS2V5X1N0b3BfUHJlc3NlZGAsXG5cdFx0XHRgS2V5X0Rvd25fUHJlc3NlZGAsXG5cdFx0XHRgS2V5X0NvbWZvcnRfUHJlc3NlZGAsXG5cdFx0XHRgS2V5X0dyb3VwX1ByZXNzZWRgLFxuXHRcdFx0YEtleV9Qcm9ncmFtX1ByZXNzZWRgLFxuXHRcdFx0YEtleV9FeHRlcm5hbF8xX1ByZXNzZWRgLFxuXHRcdFx0YEtleV9FeHRlcm5hbF8yX1ByZXNzZWRgLFxuXHRcdF0gKSxcblx0XHRSRVNVTFQ6IGVudW1lcmF0aW9uKCB7XG5cdFx0XHRPSzogMSxcblx0XHRcdFBhY2tldF9FcnJvcjogMixcblx0XHRcdE1lbW9yeV9PdmVyZmxvdzogMyxcblx0XHRcdFBhY2tldF9NaXNzZWQ6IDQsXG5cdFx0XHRQYWNrZXRfTm90X0FsbG93ZWQ6IDUsXG5cdFx0XHRQYWNrZWRfYXBwbGVkX2F0X21vZGVtOiA2LFxuXHRcdFx0Q29ubmVjdGlvbl9lcnJvcjogNyxcblx0XHRcdENvbW1hbmRfaW5fcHJvZ3Jlc3M6IDgsXG5cdFx0XHRDb21tYW5kX2F1dGhfcmVxOiA5LFxuXHRcdFx0RGV2aWNlX0Vycm9yOiAxMCxcblx0XHR9ICksXG5cdFx0TEVWRUw6IHByZWMoIDAuMDAxICksIC8vIDAuLjFcblx0XHRNT0RFTV9NT0RFOiBlbnVtZXJhdGlvbigge1xuXHRcdFx0V29ya19Nb2RlOiAxLFxuXHRcdFx0SW5pdF9EZXZpY2VfTW9kZTogMixcblx0XHRcdEV4dGVuZGVkX1dvcmtfTW9kZTogMyxcblx0XHRcdEV4dGVuZGVkX0luaXRfTW9kZTogNCxcblx0XHRcdFJlc2V0X1Bhc3N3b3JkX01vZGU6IDUsXG5cdFx0XHRSU1NJX2NhdGNoX21vZGU6IDYsXG5cdFx0fSApLFxuXHRcdC8vIEdSUF9LRVlTOiAuLi4sXG5cdFx0Ly8gU0NFTl9HUlBfU0VUVElORzogLi4uLFxuXHRcdFBST1RPQ09MX05VTTogZW51bWVyYXRpb24oIHtcblx0XHRcdE5FUk9fSUlfU21hcnRIb21lOiAwLFxuXHRcdFx0SU5UUk9fSUlfU21hcnRIb21lOiAxLFxuXHRcdH0gKSxcblx0XHRQUk9UT0NPTFM6IHNldCggYFBST1RPQ09MX05VTWAgKSxcblx0XHRNT0RFTV9GVU5DVElPTlM6IHNldCgge30gKSxcblxuXHRcdC8vICEhISBUT0RPOiDRgNCw0LfQsNCx0YDQsNGG0YbQsCwg0YjRgtC+INC30LTQvtC70YzQvdGLINGe0Y/RntC70Y/RhtGMINGB0LDQsdC+0LkgQ1VSX0NPTkRJVElPTiAvIERFU1RfQ09ORElUSU9OXG5cdFx0Q1VSX0NPTkRJVElPTjogcHJlYyggMC4wMDAxICksIC8vIDAuLjFcblx0XHRERVNUX0NPTkRJVElPTjogcHJlYyggMC4wMDAxICksIC8vIDAuLjFcblx0XHRJRDogaGV4KCksXG5cdH1cblxuXHRmdW5jdGlvbiByZWdpc3RlclJlYWRlciggY21kTG8sIGNtZEhpLCByZWFkZXIgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY21kTG8gIT0gYG51bWJlcmAgKVxuXHRcdFx0dGhyb3cgbmV3IE1vZGVtRXJyb3IoIGB3cm9uZyBjbWRMb2AgKVxuXHRcdFAxUmVhZGVyc1sgY21kTG8gXSA9IFAxUmVhZGVyc1sgY21kTG8gXSB8fCBbXVxuXHRcdGlmICggdHlwZW9mIGNtZEhpICE9IGBudW1iZXJgIClcblx0XHRcdGNtZEhpID0gYGFueWBcblx0XHRQMVJlYWRlcnNbIGNtZExvIF1bIGNtZEhpIF0gPSByZWFkZXJcblx0fVxuXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyV3JpdGVyKCBpZCwgd3JpdGVyLCB0eXBlICkge1xuXHRcdGlmICggTW9kZW0uX2NvbW1hbmRzWyBpZCBdICkge1xuXHRcdFx0bGV0IG1zZyA9IGBkdXBsaWNhdGUgY29tbWFuZCBpZGVudGlmaWVyICR7IGlkIH1gXG5cdFx0XHRjb25zb2xlLmVycm9yKCBgcmVnaXN0ZXJXcml0ZXIgJHsgdXRpbC5pbnNwZWN0KCBtc2cgKSB9YCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApXG5cdFx0fVxuXHRcdE1vZGVtLl9jb21tYW5kc1sgaWQgXSA9IE9iamVjdC5hc3NpZ24oIGluZm8gPT4ge1xuXHRcdFx0bGV0IGRhdGEgPSBbXVxuXHRcdFx0ZGF0YS5sZW5ndGggPSA4XG5cdFx0XHR3cml0ZXIoIGRhdGEsIGluZm8gKVxuXHRcdFx0cmV0dXJuIGRhdGFcblx0XHR9LCB7IHR5cGUgfSApXG5cdH1cblxuXHRmdW5jdGlvbiBjb21tYW5kKCBpZCwgdHlwZSApIHtcblx0XHRsZXQgdCA9IHt9XG5cdFx0Zm9yICggbGV0IGkgaW4gdHlwZSApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB0eXBlLCBpICkgKSB7XG5cdFx0XHRsZXQgZiA9IHR5cGVbIGkgXVxuXHRcdFx0aWYgKCB0eXBlb2YgZiA9PSBgbnVtYmVyYCApIHtcblx0XHRcdFx0bGV0IHggPSBmXG5cdFx0XHRcdGxldCBjID0gY29uc3RhbnRzWyBpIF1cblx0XHRcdFx0aWYgKCAhYyApXG5cdFx0XHRcdFx0dGhyb3cgbmV3IE1vZGVtRXJyb3IoIGB3cm9uZyBjb25zdGFudCBpbiBjb21tYW5kIGRlZmluaXRpb25gIClcblx0XHRcdFx0ZiA9IHtcblx0XHRcdFx0XHRyZWFkOiAoKSA9PiB4LFxuXHRcdFx0XHRcdHdyaXRlOiBkYXRhID0+IGMud3JpdGUoIGRhdGEsIHggKSxcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlc1sgaSBdIClcblx0XHRcdFx0ZiA9IGNvbXBvc2UoIHR5cGVzWyBpIF0sIGYgKVxuXHRcdFx0dFsgaSBdID0gZlxuXHRcdH1cblx0XHRsZXQgcmVhZCA9IGZ1bmN0aW9uICggZGF0YSApIHtcblx0XHRcdGxldCByZXQgPSB7IGlkIH1cblx0XHRcdGZvciAoIGxldCBpIGluIHQgKSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggdCwgaSApIClcblx0XHRcdFx0cmV0WyBpIF0gPSB0WyBpIF0ucmVhZCggZGF0YSApXG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fVxuXHRcdHJlZ2lzdGVyUmVhZGVyKCB0eXBlLmNtZExvLCB0eXBlLmNtZEhpLCByZWFkIClcblx0XHRsZXQgd3JpdGUgPSBmdW5jdGlvbiAoIGRhdGEsIGluZm8gKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSBpbiB0ICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHQsIGkgKSApXG5cdFx0XHRcdHRbIGkgXS53cml0ZSggZGF0YSwgaW5mbyAmJiBpbmZvWyBpIF0gKVxuXHRcdFx0cmV0dXJuIGRhdGFcblx0XHR9XG5cdFx0cmVnaXN0ZXJXcml0ZXIoIGlkLCB3cml0ZSwgdHlwZSApXG5cdH1cblxuXHQvLyBJbml0aWFsIERldmljZVxuXHRjb21tYW5kKCBgV3JpdGVfR3JvdXBgLCB7IGdyb3VwLCBjbWRMbzogMSwgVElNRTogXzksIFdDSywgUlBNLCBERUwgfSApXG5cdGNvbW1hbmQoIGBXcml0ZV9TY3JpcHRgLCB7IGdyb3VwLCBjbWRMbzogMiwgY21kSGk6IDAsIFRJTUU6IF85LCBXQ0ssIFJQTSwgREVMIH0gKVxuXHRjb21tYW5kKCBgV3JpdGVfU2NyaXB0X1dpdGhfQ21kYCwgeyBncm91cCwgY21kTG86IDIsIENNRDogXzgsIFRJTUU6IF85LCBXQ0ssIFJQTSwgREVMIH0gKVxuXHRjb21tYW5kKCBgV3JpdGVfQnlfQWxsb3dhbmNlYCwgeyBncm91cCwgY21kTG86IDMsIFRJTUU6IF85IH0gKVxuXHRjb21tYW5kKCBgU3RvcF9Xcml0ZV9XaXRoX0Fja2AsIHsgZ3JvdXAsIGNtZExvOiA0IH0gKVxuXG5cdC8vUHJvZ3JhbW1pbmcgQ21kXG5cdGNvbW1hbmQoIGBXcml0ZV9Hcm91cF9Jbl9JZGxlYCwgeyBncm91cCwgY21kTG86IDUsIEdST1VQOiBfOV8xMCwgQUNLIH0gKVxuXHRjb21tYW5kKCBgQWxsb3dfR3JvdXBfV3JpdGluZ2AsIHsgZ3JvdXAsIGNtZExvOiA2LCBjbWRIaTogMCwgQUNLIH0gKVxuXHRjb21tYW5kKCBgQWxsb3dfU2NyaXB0X1dyaXRpbmdgLCB7IGdyb3VwLCBjbWRMbzogNiwgQ01EOiBfOCwgVElNRTogXzksIEFDSywgRElNLCBST0wgfSApXG5cdGNvbW1hbmQoIGBBbGxvd19TY3JpcHRfV2l0aF9Db21mb3J0X1dyaXRpbmdgLCB7IGdyb3VwLCBjbWRMbzogNiwgY21kSGk6IDMyLCBDT01GT1JUOiBfOV8xMCwgQUNLLCBETiwgVVAgfSApXG5cdGNvbW1hbmQoIGBDaGFuZ2VfU2NyaXB0X0ludG9fQ21kYCwgeyBncm91cCwgY21kTG86IDcsIENNRDogXzgsIFRJTUU6IF85LCBBQ0ssIERJTSwgUk9MIH0gKVxuXHRjb21tYW5kKCBgQ2hhbmdlX1NjcmlwdF9JbnRvX0NvbWZvcnRgLCB7IGdyb3VwLCBjbWRMbzogNywgY21kSGk6IDMyLCBDT01GT1JUOiBfOV8xMCwgQUNLLCBETiwgVVAgfSApXG5cdGNvbW1hbmQoIGBEZWxldGVfR3JvdXBfSW5fUHJvZ3JhbW1pbmdfTW9kZWAsIHsgZ3JvdXAsIGNtZExvOiA4LCBjbWRIaTogMSwgR1JPVVA6IF85XzEwLCBBQ0sgfSApXG5cdGNvbW1hbmQoIGBEZWxldGVfR3JvdXBfSW5fSWRsZV9Nb2RlYCwgeyBncm91cCwgY21kTG86IDgsIGNtZEhpOiAyLCBHUk9VUDogXzlfMTAsIEFDSyB9IClcblx0Y29tbWFuZCggYENsZWFyX0RldmljZV9NZW1vcnlfSW5fSWRsZV9Nb2RlYCwgeyBncm91cCwgY21kTG86IDgsIGNtZEhpOiAzLCBBQ0sgfSApXG5cblx0Ly8gQWN0aW9uIENtZFxuXHRjb21tYW5kKCBgU3RvcGAsICAgICAgeyBncm91cCwgY21kTG86IDE2LCBjbWRIaTogMSwgVElNRTogXzksIEFDSywgRElNLCBST0wsIFNHUlAsIFBSSU9SSVRZIH0gKVxuXHRjb21tYW5kKCBgVXBgLCAgICAgICAgeyBncm91cCwgY21kTG86IDE2LCBjbWRIaTogMiwgVElNRTogXzksIEFDSywgRElNLCBST0wsIFNHUlAsIFBSSU9SSVRZIH0gKVxuXHRjb21tYW5kKCBgRG93bmAsICAgICAgeyBncm91cCwgY21kTG86IDE2LCBjbWRIaTogMywgVElNRTogXzksIEFDSywgRElNLCBST0wsIFNHUlAsIFBSSU9SSVRZIH0gKVxuXHRjb21tYW5kKCBgU2V0X1RvX0NvbWZvcnRfMWAsIHsgZ3JvdXAsIGNtZExvOiAxNiwgY21kSGk6IDQsIFRJTUU6IF85LCBBQ0ssIERJTSwgUk9MLCBTR1JQLCBQUklPUklUWSB9IClcblx0Y29tbWFuZCggYFNldF9Ub19Db21mb3J0XzJgLCB7IGdyb3VwLCBjbWRMbzogMTYsIGNtZEhpOiA1LCBUSU1FOiBfOSwgQUNLLCBESU0sIFJPTCwgU0dSUCwgUFJJT1JJVFkgfSApXG5cdGNvbW1hbmQoIGBTY3JpcHRgLCAgICB7IGdyb3VwLCBjbWRMbzogMTYsIGNtZEhpOiA2LCBUSU1FOiBfOSwgQUNLLCBESU0sIFJPTCwgU0dSUCwgUFJJT1JJVFkgfSApXG5cdGNvbW1hbmQoIGBMb29wYCwgICAgICB7IGdyb3VwLCBjbWRMbzogMTYsIGNtZEhpOiA3LCBUSU1FOiBfOSwgQUNLLCBESU0sIFJPTCwgU0dSUCwgUFJJT1JJVFkgfSApXG5cdGNvbW1hbmQoIGBTZXRfVG9fQ29tZm9ydGAsIHsgZ3JvdXAsIGNtZExvOiAxNiwgY21kSGk6IDMyLCBDT01GT1JUOiBfOV8xMCwgQUNLLCBTR1JQLCBETiwgVVAsIFBSSU9SSVRZIH0gKVxuXHRjb21tYW5kKCBgU2NhbkNvZF9Gb3JfTW9kZXNgLCB7IGdyb3VwLCBjbWRMbzogMTcsIENNRDogXzgsIFRJTUU6IF85LCBNT0RFOiBfMTAsIEFDSywgRElNLCBST0wgfSApXG5cblx0Ly8gQ29udHJvbCBDbWRcblx0Y29tbWFuZCggYEdvVG9fTW9kZWAsIHsgZ3JvdXAsIGNtZExvOiAyNCwgY21kSGk6IDEsIFRvX01PREU6IF85LCBGcm9tX01PREU6IF8xMCwgQUNLIH0gKVxuXHRjb21tYW5kKCBgQ2hhbmdlX01vZGVfU2V0dGluZ2AsIHsgZ3JvdXAsIGNtZExvOiAyNCwgY21kSGk6IDIsIE1PREVfU0VUVElORzogXzksIE1BU0s6IF8xMCwgQUNLIH0gKVxuXHRjb21tYW5kKCBgQ2hhbmdlX1N5c3RlbV9TZXR0aW5nYCwgeyBncm91cCwgY21kTG86IDI0LCBjbWRIaTogMywgU1lTVEVNX1NFVFRJTkc6IF85LCBNQVNLOiBfMTAsIEFDSyB9IClcblx0Y29tbWFuZCggYENoYW5nZV9DbWRfU2V0dGluZ2AsIHsgZ3JvdXAsIGNtZExvOiAyNCwgY21kSGk6IDQsIENNRF9TRVRUSU5HOiBfOSwgTUFTSzogXzEwLCBBQ0sgfSApXG5cdGNvbW1hbmQoIGBDaGFuZ2VfR3JvdXBfU2V0dGluZ2AsIHsgZ3JvdXAsIGNtZExvOiAyNCwgY21kSGk6IDUsIEdST1VQX1NFVFRJTkc6IF85LCBNQVNLOiBfMTAsIEFDSyB9IClcblx0Y29tbWFuZCggYENoYW5nZV9Nb3ZlX1RpbWVgLCB7IGdyb3VwLCBjbWRMbzogMjQsIGNtZEhpOiA2LCBNT1ZFX1RJTUU6IF85XzEwLCBBQ0sgfSApXG5cdGNvbW1hbmQoIGBDaGFuZ2VfQ29tZm9ydF8xYCwgeyBncm91cCwgY21kTG86IDI0LCBjbWRIaTogNywgQ09NRk9SVDogXzlfMTAsIEFDSywgRE4sIFVQIH0gKVxuXHRjb21tYW5kKCBgQ2hhbmdlX0NvbWZvcnRfMmAsIHsgZ3JvdXAsIGNtZExvOiAyNCwgY21kSGk6IDgsIENPTUZPUlQ6IF85XzEwLCBBQ0ssIEROLCBVUCB9IClcblx0Y29tbWFuZCggYENoYW5nZV9TY3JpcHRfQ29tZm9ydGAsIHsgZ3JvdXAsIGNtZExvOiAyNCwgY21kSGk6IDksIENPTUZPUlQ6IF85XzEwLCBBQ0ssIEROLCBVUCB9IClcblx0Y29tbWFuZCggYFJlc2V0X1RvX0ZhY3RvcnlfU2V0dGluZ2AsIHsgZ3JvdXAsIGNtZExvOiAyNCwgY21kSGk6IDEwLCBERUZBVUxfU0VUVElORzogXzlfMTAsIEFDSyB9IClcblx0Y29tbWFuZCggYENoYW5nZV9Hcm91cF9TZXR0aW5nc19Gb3JfU2NlbmFyaW9fQ29udHJvbGAsIHsgZ3JvdXAsIGNtZExvOiAyNCwgY21kSGk6IDExLCBHUlBfS0VZUzogXzksIFNDRU5fR1JQX1NFVFRJTkc6IF8xMCwgQUNLIH0gKVxuXG5cdC8vIFJlcXVlc3RcdNCX0LDQv9GA0L7RgdGLXG5cdGZ1bmN0aW9uIHJlcXVlc3QoIGlkLCBmdW4sIHRUb01vZGVtLCB0RnJvbU1vZGVtICkge1xuXHRcdHRUb01vZGVtLmNtZExvID0gMzJcblx0XHR0VG9Nb2RlbS5jbWRIaSA9IGZ1blxuXHRcdHRGcm9tTW9kZW0uY21kTG8gPSAzM1xuXHRcdHRGcm9tTW9kZW0uY21kSGkgPSBmdW5cblx0XHRjb21tYW5kKCBpZCwgdFRvTW9kZW0gKVxuXHRcdGNvbW1hbmQoIGBhbnN3ZXJfJHsgaWQgfWAsIHRGcm9tTW9kZW0gKVxuXHR9XG5cblx0cmVxdWVzdCggYE1vZGVgLCAxLCB7IGdyb3VwIH0sIHsgZ3JvdXAsIE1PREU6IF85IH0gKVxuXHRyZXF1ZXN0KCBgTW9kZV9TZXR0aW5nYCwgMiwgeyBncm91cCB9LCB7IGdyb3VwLCBNT0RFX1NFVFRJTkc6IF85IH0gKVxuXHRyZXF1ZXN0KCBgU3lzdGVtX1NldHRpbmdgLCAzLCB7IGdyb3VwIH0sIHsgZ3JvdXAsIFNZU1RFTV9TRVRUSU5HOiBfOSB9IClcblx0cmVxdWVzdCggYENtZF9TZXR0aW5nYCwgNCwgeyBncm91cCB9LCB7IGdyb3VwLCBDTURfU0VUVElORzogXzkgfSApXG5cdHJlcXVlc3QoIGBHcm91cF9TZXR0aW5nYCwgNSwgeyBncm91cCB9LCB7IGdyb3VwLCBHUk9VUF9TRVRUSU5HOiBfOSB9IClcblx0cmVxdWVzdCggYE1vdmVfVGltZWAsIDYsIHsgZ3JvdXAgfSwgeyBncm91cCwgTU9WRV9USU1FOiBfOV8xMCB9IClcblx0cmVxdWVzdCggYENvbWZvcnRfMWAsIDcsIHsgZ3JvdXAgfSwgeyBncm91cCwgQ09NRk9SVDogXzlfMTAsIEROLCBVUCB9IClcblx0cmVxdWVzdCggYENvbWZvcnRfMmAsIDgsIHsgZ3JvdXAgfSwgeyBncm91cCwgQ09NRk9SVDogXzlfMTAsIEROLCBVUCB9IClcblx0cmVxdWVzdCggYFNjcmlwdF9Db21mb3J0YCwgOSwgeyBncm91cCB9LCB7IGdyb3VwLCBDT01GT1JUOiBfOV8xMCwgRE4sIFVQIH0gKVxuXHRyZXF1ZXN0KCBgS2V5cGFkX1N0YXR1c2AsIDEwLCB7IGdyb3VwIH0sIHsgZ3JvdXAsIEtFWVBBRF9TVEFUVVM6IF85IH0gKVxuXHRyZXF1ZXN0KCBgQ3VyX0NvbmRpdGlvbmAsIDExLCB7IGdyb3VwIH0sIHsgZ3JvdXAsIENVUl9DT05ESVRJT046IF85XzEwLCBETiwgVVAgfSApXG5cdHJlcXVlc3QoIGBEZXN0X0NvbmRpdGlvbmAsIDEyLCB7IGdyb3VwIH0sIHsgZ3JvdXAsIERFU1RfQ09ORElUSU9OOiBfOV8xMCwgRE4sIFVQIH0gKVxuXHRyZXF1ZXN0KCBgVmVyc2lvbl9IaWdoYCwgMTMsIHsgZ3JvdXAgfSwgeyBncm91cCwgUFJPRFVDVF9IQVJEOiBfOSwgUFJPRFVDVF9WQVJJQU5UOiBfMTAgfSApXG5cdHJlcXVlc3QoIGBWZXJzaW9uX0xvd2AsIDE0LCB7IGdyb3VwIH0sIHsgZ3JvdXAsIFBST0RVQ1RfVkVSU0lPTjogXzksIFBST0RVQ1RfSUQ6IF8xMCB9IClcblx0cmVxdWVzdCggYFJlc3VsdGAsIDE1LCB7IGdyb3VwIH0sIHsgZ3JvdXAsIFJFU1VMVDogXzkgfSApXG5cdHJlcXVlc3QoIGBTaWduYWxfTGV2ZWxgLCAxNiwgeyBncm91cCB9LCB7IGdyb3VwLCBMRVZFTDogXzlfMTAgfSApXG5cdHJlcXVlc3QoIGBGcmVlX0NlbGxfQ291bnRgLCAxNywge30sIHsgQ09VTlQ6IF85XzEwIH0gKVxuXHRyZXF1ZXN0KCBgVmVyc2lvbmAsIDE4LCB7fSwgeyBQUk9EVUNUX1ZFUlNJT046IF85LCBQUk9EVUNUX0lEOiBfMTAsIFBST0RVQ1RfSEFSRDogXzExLCBQUk9EVUNUX1ZBUklBTlQ6IF8xMiB9IClcblx0cmVxdWVzdCggYElkX0NlbGxfTnVtYmVyYCwgMTksIHt9LCB7IERFVl9OVU06IF85IH0gKVxuXHRyZXF1ZXN0KCBgU2NlbmFyaW9fQ29udHJvbF9Hcm91cF9TZXR0aW5nYCwgMjAsIHsgZ3JvdXAsIGtleTE6IF85IH0sIHsgZ3JvdXAsIEdSUF9LRVlTOiBfOSwgU0NFTl9HUlBfU0VUVElORzogXzEwIH0gKVxuXHRyZXF1ZXN0KCBgRnVuY3Rpb25zYCwgMjEsIHt9LCB7IFBST1RPQ09MUzogXzksIE1PREVNX0ZVTkNUSU9OUzogXzEwIH0gKVxuXHRyZXF1ZXN0KCBgSWRlbnRpZmllcmAsIDIyLCB7fSwgeyBJRDogXzlfMTBfMTFfMTIgfSApXG5cblx0Ly8g0KPQv9GA0LDQstC70LXQvdC40LUg0LzQvtC00LXQvNC+0Lxcblx0Y29tbWFuZCggYENoYW5nZV9tb2RlbV93b3JrX21vZGVgLCB7IGNtZExvOiAyNSwgY21kSGk6IDEsIE1PREVNX01PREU6IF85IH0gKVxuXHRjb21tYW5kKCBgRG9faWRfbnhfc3Vic3RpdHV0aW9uYCwgeyBjbWRMbzogMjUsIGNtZEhpOiAyLCBERVZfTlVNOiBfOV8xMCB9ICkgLy8gMHhmZmZmIC0gbW9kZW1cblx0Y29tbWFuZCggYERlbGV0ZV9pZF9ueF9vZl9kZXZpY2VgLCB7IGNtZExvOiAyNSwgY21kSGk6IDMsIERFVl9OVU06IF85XzEwIH0gKSAvLyAweGZmZmYgLSBhbGxcblx0Y29tbWFuZCggYENoYW5nZV9wcm90b2NvbGAsIHsgY21kTG86IDI1LCBjbWRIaTogNCwgUFJPVE9DT0xTOiBfOSB9IClcbn0oKVxuIiwiZXhwb3J0IGNvbnN0IGluaXRpYWxfY3JjID0gMHgwMDAwXG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfY3JjKCBjcmMsIGJ5dGUgKSB7XG5cdC8vINC90LUg0LfQvdCw0Y4sINC60LDQuiDRjdGC0L4g0LTQvtC70LbQvdC+INGA0LDQsdC+0YLQsNGC0YwsINC90LUg0LzQvtC1XG5cdC8vINGWINC90LUg0LzQsNGRINGC0LDQutGB0LDQvNCwIDopXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IDg7IGkrKyApIHtcblx0XHRpZiAoIGNyYyAmIDB4ODAwMCApIHtcblx0XHRcdGNyYyA8PD0gMVxuXHRcdFx0Y3JjICY9IDB4ZmZmZlxuXHRcdFx0aWYgKCBieXRlICYgMHgwMDAxIClcblx0XHRcdFx0Y3JjIHw9IDB4MDAwMVxuXHRcdFx0Y3JjIF49IDB4MTAyMVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGNyYyA8PD0gMVxuXHRcdFx0Y3JjICY9IDB4ZmZmZlxuXHRcdFx0aWYgKCBieXRlICYgMHgwMDAxIClcblx0XHRcdFx0Y3JjIHw9IDB4MDAwMVxuXHRcdH1cblx0XHRieXRlID0gYnl0ZSA+PiAxO1xuXHR9XG5cdHJldHVybiBjcmNcbn1cblxuZnVuY3Rpb24gaXRlcmFibGUoIGRhdGEgKSB7XG5cdGlmICggZGF0YVsgU3ltYm9sLml0ZXJhdG9yIF0gfHwgZGF0YS5uZXh0IClcblx0XHRyZXR1cm4gZGF0YVxuXHRlbHNlXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpIClcblx0XHRcdFx0eWllbGQgZGF0YVsgaSBdXG5cdFx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY19jcmMoIGRhdGEgKSB7XG5cdGxldCBjcmMgPSBpbml0aWFsX2NyY1xuXHRmb3IgKCBsZXQgdGVtcCBvZiBpdGVyYWJsZSggZGF0YSApIClcblx0XHRjcmMgPSB1cGRhdGVfY3JjKCBjcmMsIHRlbXAgKVxuXHRyZXR1cm4gY3JjXG59XG5cbmV4cG9ydCBmdW5jdGlvbiogYXBwZW5kX2NyYyggZGF0YSApIHtcblx0bGV0IGZpcnN0ID0gdHJ1ZVxuXHRsZXQgY3JjID0gaW5pdGlhbF9jcmNcblx0Zm9yICggbGV0IGIgb2YgaXRlcmFibGUoIGRhdGEgKSApIHtcblx0XHRjcmMgPSB1cGRhdGVfY3JjKCBjcmMsIGIgKVxuXHRcdHlpZWxkIGJcblx0XHRmaXJzdCA9IGZhbHNlXG5cdH1cblx0eWllbGQgY3JjICYgMHhmZlxuXHR5aWVsZCAoIGNyYyA+PiA4ICkgJiAweGZmXG59XG4iLCJpbXBvcnQgKiBhcyBzdHJlYW0gZnJvbSBcInN0cmVhbVwiXG5pbXBvcnQgKiBhcyBzZiBmcm9tIFwic2ZcIlxuaW1wb3J0IFVJRCBmcm9tIFwidWlkXCJcblxuY29uc3QgSU5URVJWQUwgPSA2MDAwMFxuY29uc3QgVElNRU9VVCA9IDkwMDBcbmNvbnN0IE1BWF9QSU5HUyA9IDIwMDBcblxuLy8gdGhpcyAtIGZpbHRlcmVkIHN0cmVhbVxuLy8gdGhpcy5vdGhlciAtIHN0cmVhbSB3aXRoIHBpbmdwb25nc1xuXG5leHBvcnQgZGVmYXVsdCAoIHsgbG9nID0gbnVsbCwgaW50ZXJ2YWwgPSBJTlRFUlZBTCwgdGltZW91dCA9IFRJTUVPVVQsIG1heHBpbmdzID0gTUFYX1BJTkdTIH0gPSBmYWxzZSApID0+IHtcblx0bGV0IHBpbmdzID0gbmV3IE1hcFxuXHRsZXQgd3JpdGVyID0gbmV3IHN0cmVhbS5UcmFuc2Zvcm0oIHsgb2JqZWN0TW9kZTogdHJ1ZSwgdHJhbnNmb3JtKCBkYXRhLCBjaHVuaywgY2FsbGJhY2sgKSB7XG5cdFx0d3JpdGVyLnB1c2goIGRhdGEgKVxuXHRcdHBpbmcoKVxuXHRcdGNhbGxiYWNrKClcblx0fSB9IClcblx0bGV0IHJlYWRlciA9IG5ldyBzdHJlYW0uVHJhbnNmb3JtKCB7IG9iamVjdE1vZGU6IHRydWUsIHRyYW5zZm9ybSggZGF0YSwgY2h1bmssIGNhbGxiYWNrICkge1xuXHRcdGlmICggZGF0YS53aGF0ID09IGBwaW5nYCApXG5cdFx0XHR3cml0ZXIucHVzaCggeyB3aGF0OiBgcG9uZ2AsIHBvbmc6IGRhdGEucGluZyB9IClcblx0XHRlbHNlIGlmICggZGF0YS53aGF0ID09IGBwb25nYCApXG5cdFx0XHRvbnBvbmcoIGRhdGEucG9uZyApXG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5wdXNoKCBkYXRhIClcblx0XHRjYWxsYmFjaygpXG5cdH0gfSApXG5cdHJlYWRlci5vbiggYGVuZGAsIGNsZWFudXAgKVxuXHRyZWFkZXIub24oIGBmaW5pc2hgLCBjbGVhbnVwIClcblx0d3JpdGVyLm9uKCBgZW5kYCwgY2xlYW51cCApXG5cdHdyaXRlci5vbiggYGZpbmlzaGAsIGNsZWFudXAgKVxuXHRsZXQgdGltZXJcblx0ZnVuY3Rpb24gb25UaW1lcigpIHtcblx0XHR0aW1lciA9IHNldFRpbWVvdXQoIG9uVGltZXIsIGludGVydmFsIClcblx0XHRwaW5nKClcblx0fVxuXHRvblRpbWVyKClcblx0ZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0XHRjbGVhclRpbWVvdXQoIHRpbWVyIClcblx0XHRwaW5ncyA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBvbnBvbmcoIGlkICkge1xuXHRcdGlmICggcGluZ3MuaGFzKCBpZCApICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCBwaW5ncy5nZXQoIGlkICkgKVxuXHRcdFx0cGluZ3MuZGVsZXRlKCBpZCApXG5cdFx0XHRpZiAoIHJldC53YWl0aW5nRm9yRmlyc3RQaW5nICkge1xuXHRcdFx0XHRyZXQud2FpdGluZ0ZvckZpcnN0UGluZyA9IGZhbHNlXG5cdFx0XHRcdHJldC5lbWl0KCBgb3BlbmAgKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwaW5nKCkge1xuXHRcdGlmICggIXBpbmdzIClcblx0XHRcdHJldHVyblxuXHRcdGlmICggcGluZ3Muc2l6ZSA+PSBtYXhwaW5ncyApIHtcblx0XHRcdGxvZyAmJiBsb2cuZXJyb3IoIGB0b28gbWFueSBwaW5nc2AgKVxuXHRcdFx0b250aW1lb3V0KClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRsZXQgaWQgPSBVSUQoKVxuXHRcdHdyaXRlci5wdXNoKCB7IHdoYXQ6IGBwaW5nYCwgcGluZzogaWQgfSApXG5cdFx0cGluZ3Muc2V0KCBpZCwgc2V0VGltZW91dCggKCkgPT4ge1xuXHRcdFx0bG9nICYmIGxvZy5lcnJvciggYHRpbWUgb3V0IG9uICR7IGlkIH1gIClcblx0XHRcdG9udGltZW91dCgpXG5cdFx0fSwgdGltZW91dCApIClcblx0fVxuXHRmdW5jdGlvbiBvbnRpbWVvdXQoKSB7XG5cdFx0d3JpdGVyLmVtaXQoIGBlcnJvcmAsIG5ldyBFcnJvciggYHRpbWVvdXRgICkgKVxuXHRcdHdyaXRlci5wdXNoKCBudWxsIClcblx0XHRyZWFkZXIucHVzaCggbnVsbCApXG5cdH1cblx0bGV0IHJldCA9IHNmLmR1cGxleGVyKCB3cml0ZXIsIHJlYWRlciApXG5cdHJldC53YWl0aW5nRm9yRmlyc3RQaW5nID0gdHJ1ZVxuXHRyZXR1cm4gcmV0XG59XG4iLCJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSggT2JqZWN0LnByb3RvdHlwZSwgYF9MT0dfYCwgeyB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHRjb25zb2xlLmxvZyggdGhpcyApXG5cdHJldHVybiB0aGlzXG59LCBjb25maWd1cmFibGU6IHRydWUgfSApXG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PSBgZnVuY3Rpb25gICYmIFN5bWJvbC5pdGVyYXRvciApIHtcblx0bGV0IHggPSBudWxsXG5cdHRyeSB7XG5cdFx0eCA9IGV2YWwuY2FsbCggbnVsbCwgYChmdW5jdGlvbiooKXt9KCkuY29uc3RydWN0b3IucHJvdG90eXBlKWAgKVxuXHR9IGNhdGNoICggXyApIHt9XG5cdGlmICggeCAmJiAheFsgU3ltYm9sLml0ZXJhdG9yIF0gKVxuXHRcdHhbIFN5bWJvbC5pdGVyYXRvciBdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyB9XG59XG4iLCIvKlxuXG5UT0RPOlxuXG4qIFdhcm5pbmcgaWYgYSBsaXZlIHByb3BlcnR5IGhhcyBub3QgYmVlbiByZWFkIGR1cmluZyB0aGUgbGlmZSB0aW1lIG9mIG9ic2VydmFibGUgdmFsdWUgb3IgZHVyaW5nIHNvbWUgcGVyaW9kIG9mIHRpbWUgKGUuZy4gMS0zMCBtaW51dGVzKSBzaW5jZSBjcmVhdGluZyB0aGF0IG9ic2VydmFibGUgdmFsdWUuXG5cbiogY2hlY2sgZm9yIGNoYW5nZXMgZHVyaW5nIGV4ZWN1dGlvbiBvZiAoZnVuY3Rpb24qKSBhbmQgcmVzdGFydCBjYWxjdWx1cy5cblxuXG5UT0RPIEJVRzpcbmxldCBhcHAgPSByYSgge1xuXHRtb3ZpbmcxOiB7XG5cdFx0YTogMSxcblx0XHRiOiAyLFxuXHRcdGM6IHtcblx0XHRcdGQ6IDMsXG5cdFx0fSxcblx0fSxcbn1cbl9hcHAubW92aW5nMS5hXG4xXG5fYXBwLm1vdmluZzEuYy5kXG4zXG5fYXBwLm1vdmluZzE9e2E6NH1cbk9iamVjdCB7YTogNH1cbl9hcHAubW92aW5nMS5jLmRcbjMgICAgICAgICAgICAgICAgICAgICAgIDwtLS0tLS0tLS0tLSAhISEgIE1VU1QgQkUgTlVMTCAhISEhXG5fYXBwLm1vdmluZzEuY1xuQ2VsbCB7X2lkOiBcImo4N3lxa29xcHB1dlwiLCBfdmFsdWU6IG51bGwsIF9lcnJvcjogbnVsbCwgX2lzVmFsdWVFcXVhbDogZnVuY3Rpb24sIF9pbml0aWFsaXplZDogdHJ1ZeKApn1cbl9hcHAubW92aW5nMS5jLnZhbHVlT2YoKVxubnVsbFxuXG5cbiovXG5cbmltcG9ydCAqIGFzIGNvIGZyb20gXCJjb1wiXG5pbXBvcnQgVUlEIGZyb20gXCJ1aWRcIlxuaW1wb3J0ICogYXMgRGlmZiBmcm9tIFwiZGlmZlwiXG5pbXBvcnQgKiBhcyBsb2Rhc2ggZnJvbSBcImxvZGFzaFwiXG5cbmxldCBBY3Rpb25zID0gbmV3IFdlYWtNYXBcbmxldCBWYWx1ZXMgPSBuZXcgV2Vha1NldFxuXG4vLyBsZXQgZGVidWdMb2cgPSBmYWxzZVxuXG5sZXQgY2hlY2tOdWxsID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZVxubGV0IGdldFZhbHVlID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZS52YWx1ZU9mID09IG51bGwgPyB2YWx1ZSA6IHZhbHVlLnZhbHVlT2YoKVxubGV0IGlzTGl0ZXJhbCA9IHZhbHVlID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBgb2JqZWN0YCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PSBPYmplY3RcblxuY2xhc3MgdXNlZFByb3BzR3VhcmQge31cblxuY2xhc3MgQWJzdHJhY3RHdWFyZCBleHRlbmRzIHVzZWRQcm9wc0d1YXJkIHt9XG5cbmZvciAoIGxldCBpIG9mIGB0b1N0cmluZyB2YWx1ZU9mIHRvTG9jYWxlU3RyaW5nIGhhc093blByb3BlcnR5IGlzUHJvdG90eXBlT2YgcHJvcGVydHlJc0VudW1lcmFibGVgLnNwbGl0KCBgIGAgKSApXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggQWJzdHJhY3RHdWFyZC5wcm90b3R5cGUsIGksIHsgdmFsdWU6IHt9WyBpIF0sIGVudW1lcmFibGU6IGZhbHNlIH0gKVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KCBBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSwgYCRuYW1lYCwgeyB2YWx1ZTogYDwuLi4+YCwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH0gKVxuXG5sZXQgaW52YWxpZEtleUNhbGwgPSBmdW5jdGlvbiAoIGtleSApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBgYWNjZXNzIHRvIGFuIHVuZGVjbGFyZWQgcHJvcGVydHkgXCIkeyB0aGlzLiRuYW1lIH0uJHsga2V5IH1cImAgKVxufVxuXG5sZXQgZ3VhcmRQcm9wID0ga2V5ID0+IHtcblx0aWYgKCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB1c2VkUHJvcHNHdWFyZC5wcm90b3R5cGUsIGtleSApICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdXNlZFByb3BzR3VhcmQucHJvdG90eXBlLCBrZXksIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG5cdFx0fSApXG5cdFx0Ly8gY29uc29sZS5sb2coIE9iamVjdC5rZXlzKCB1c2VkUHJvcHNHdWFyZC5wcm90b3R5cGUgKS5sZW5ndGggKVxuXHRcdC8vIGNvbnNvbGUubG9nKCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyggdXNlZFByb3BzR3VhcmQucHJvdG90eXBlICkubGVuZ3RoIClcblx0fVxufVxuXG4vLyDQndC1INC30YDQsNC30YPQvNC10LvQsCDRgtC+0LvQutCw0LwsINGP0Log0LPRjdGC0YsgUHJveHkg0L/RgNCw0YbRg9C1INGeINGP0LrQsNGB0YzRhtGWINC/0YDQsNGC0LDRgtGL0L/Rgy5cbi8vINCf0LDQutGD0LvRjCDRiNGC0L4sINC30LTQsNC10YbRhtCwLCDQv9Cw0LLQvtC00LfRltC90Ysg0L3QtSDQsNC00L/QsNCy0Y/QtNCw0Y7RhtGMINGB0YzQv9C10YbRi9GE0ZbQutCw0YbRi9GWICgyMDE0LjExLjI1KVxuXG4vLyBpZiAoIHR5cGVvZiBQcm94eSA9PSBcImZ1bmN0aW9uXCIgKSB7XG4vLyBcdEFic3RyYWN0R3VhcmQucHJvdG90eXBlID0gbmV3IFByb3h5KCBBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSwge1xuLy8gXHRcdGdldDogZnVuY3Rpb24gKCBfLCBrZXkgKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG4vLyBcdFx0c2V0OiBmdW5jdGlvbiAoIF8sIGtleSApIHsgaW52YWxpZEtleUNhbGwuY2FsbCggdGhpcywga2V5ICkgfSxcbi8vIFx0fSApXG4vLyB9XG5cbi8vIGlmICggZ2xvYmFsLkFQUF9ERUJVRyApIHtcbi8vIFx0Ly9cbi8vIFx0Ly8g0LDQsSfRj9Ge0LvQtdC90YzQvdC1INCw0LEn0LXQutGC0LAg0LcgfjcwMC04MDAg0YPQu9Cw0YHRjNGG0ZbQstCw0YHRjNGG0Y/RniDQtyDRhNGD0L3QutGG0YvRj9C80ZYg0YfRi9GC0LDQvdGM0L3Rjy/Qt9Cw0L/RltGB0YNcbi8vIFx0Ly8g0LfQsNC50LzQsNC1INGeIEdvb2dsZSBDaHJvbWUn0LUg0LrQsNC70Y8g0YLRgNCw0YbRltC90Ysg0YHQtdC60YPQvdC00YsuXG4vLyBcdC8vINCf0YDQsNCy0LXRgNCw0L3Ri9GPINGB0L/QvtGB0LDQsdGLOlxuLy8gXHQvLyAtINC00LDQsdCw0Z7Qu9C10L3RjNC90LUg0L/QsCDQsNC00L3Ri9C8INC/0YDQsNC3IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuLy8gXHQvLyAtINC00LDQsdCw0Z7Qu9C10L3RjNC90LUg0LPRg9GA0YLQsNC8INC/0YDQsNC3IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4vLyBcdC8vIC0g0LrQsNC80L/RltC70Y/RhtGL0Y8g0LfRi9GF0L7QtNC90ZbQutCwINC/0YDQsNC3INC70LDQutCw0LvRjNC90YsgZXZhbFxuLy8gXHQvLyAtINC60LDQvNC/0ZbQu9GP0YbRi9GPINC30YvRhdC+0LTQvdGW0LrQsCDQv9GA0LDQtyDQs9C70LDQsdCw0LvRjNC90YsgZXZhbFxuLy8gXHQvLyAtINC60LDQvNC/0ZbQu9GP0YbRi9GPINC30YvRhdC+0LTQvdGW0LrQsCDQv9GA0LDQtyDQtNCw0LHQsNGe0LvQtdC90YzQvdC1INGC0Y3Qs9GDIHNjcmlwdCDQtyDQt9GL0YXQvtC00L3RltC60LDQvFxuLy8gXHQvLyDQndC1INC/0YDQsNCy0LXRgNCw0L3Ri9GPINGB0L/QvtGB0LDQsdGLOlxuLy8gXHQvLyAtINC00LDQsdCw0Z7Qu9C10L3RjNC90LUg0YLRjdCz0YMgc2NyaXB0INC3INC/0LDQt9C90LDQutCw0Lkgc3JjXG4vLyBcdC8vINCf0LDQu9GP0L/RiNCw0LUg0YHRltGC0YPQsNGG0YvRjiAo0L3QsNC/0LDQu9C+0LLRgyk6XG4vLyBcdC8vIC0g0YHRgtCy0LDRgNGN0L3RjNC90LUg0LTQu9GPINC60L7QttC90LDQuSDRg9C70LDRgdGM0YbRltCy0LDRgdGM0YbRliDQvdC+0LLQsNCz0LAg0LDQsSfQtdC60YLQsCDRgdCwINGB0YLQsNGA0YvQvCDQsNCxJ9C10LrRgtCw0Lxcbi8vIFx0Ly8g0YMg0Y/QutCw0YHRjNGG0ZYg0L/RgNCw0YLQsNGC0YvQv9GDLiDQn9GA0Ysg0LPRjdGC0YvQvCDQtNC+0YHRgtGD0L8g0LTQsCDQvdC10LDQsSfRj9Ge0LvQtdC90YvRhSDRg9C70LDRgdGM0YbRltCy0LDRgdGM0YbRj9GeINC80L7QttCwXG4vLyBcdC8vINGB0YLQsNGG0Ywg0LDQtNC90L7RgdC90LAg0LTQvtGe0LPRltC8INC/0LAg0YfQsNGB0LUsINCw0LvQtSDQtiDQs9GN0YLQsCDQvdGPINGC0LDQuiDQstCw0LbQvdCwLCDQsdC+INGeINCy0YvQvdGW0LrRgyDRntGB0ZEg0LDQtNC90L5cbi8vIFx0Ly8g0LrRltC00LDQtdGG0YbQsCDQv9Cw0LzRi9C70LrQsC5cbi8vIFx0Ly9cbi8vIFx0Ly8g0JPQtdC90LXRgNCw0YbRi9GPINGC0Y3QutGB0YLRgyDQt9GL0YXQvtC00L3RltC60LAg0LDQtNCx0YvQstCw0LXRhtGG0LAg0ZbQvNCz0L3QtdC90L3QsC5cbi8vIFx0Ly9cbi8vIFx0Ly8g0JfRi9GF0L7QtNC30Y/Rh9GLINC3INCz0Y3RgtCw0LPQsCDRg9C70YPRh9Cw0YbRjCDRgdGC0YDQsNC20L3RltC60LDRniDQtNC+0YHRgtGD0L/RgyDQtNCwINC90LXQsNCxJ9GP0Z7Qu9C10L3Ri9GFINGD0LvQsNGB0YzRhtGW0LLQsNGB0YzRhtGP0Z5cbi8vIFx0Ly8g0YLRgNGN0LHQsCDRgtC+0LvRjNC60ZYg0L/RgNGLINCw0LTQu9Cw0LTRhtGLLlxuLy8gXHQvL1xuLy8gXHRBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSA9XG4vLyBcdFx0KCBnbG9iYWwuX19Vc2VkU2NyaXB0SWRlbnRpZmllcnNfXyArIGBgIClcbi8vIFx0XHQuc3BsaXQoIC9bXFxzLF0rLyApXG4vLyBcdFx0LnJlZHVjZSggKCBwcm90bywga2V5ICkgPT5cbi8vIFx0XHRcdE9iamVjdC5jcmVhdGUoIHByb3RvLCB7IFsga2V5IF06IHtcbi8vIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG4vLyBcdFx0XHRcdHNldDogZnVuY3Rpb24gKCBfICkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuLy8gXHRcdFx0fSB9ICksXG4vLyBcdFx0XHRBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSApXG4vLyB9XG5cbmxldCBFTVBUWV9BUlJBWSA9IFtdXG5PYmplY3QuZnJlZXplKCBFTVBUWV9BUlJBWSApXG5cbmNsYXNzIEltbXV0YWJsZUludGVyZmFjZSBleHRlbmRzIEFic3RyYWN0R3VhcmQge1xuXG5cdC8vIGRlYnVnZ2VyXG5cdGdldCBwcm9wcygpIHsgdGhyb3cgbmV3IEVycm9yKCBgYWNjZXNzIHRvIGRlcHJlY2F0ZWQgJ3Byb3BzJyBwcm9wZXJ0eSBkZXRlY3RlZGAgKSB9XG5cblx0Z2V0IGRlY2xhcmVkUHJvcGVydGllcygpIHsgcmV0dXJuIHRoaXMubGl2ZSB9XG5cblx0Z2V0IGxlbmd0aCgpIHsgbGV0IG0gPSB0aGlzLnZhbHVlT2YoKTsgcmV0dXJuIG0gPT0gbnVsbCA/IDAgOiBPYmplY3Qua2V5cyggbSApLmxlbmd0aCB9XG5cblx0Z2V0KCBrZXkgKSB7XG5cdFx0aWYgKCBrZXkgIT0gbnVsbCApIHtcblx0XHRcdGxldCBtID0gdGhpcy52YWx1ZU9mKClcblx0XHRcdGlmICggbSAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggbSwga2V5ICkgKVxuXHRcdFx0XHRyZXR1cm4gbVsga2V5IF1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGxcblx0fVxuXG5cdG1hcCggZnVuICkge1xuXHRcdGxldCBtID0gdGhpcy52YWx1ZU9mKClcblx0XHRyZXR1cm4gbSAmJiAoIEFycmF5LmlzQXJyYXkoIG0gKSA/IGxvZGFzaC5tYXAoIG0sIGZ1biApIDogbG9kYXNoLm1hcFZhbHVlcyggbSwgZnVuICkgKVxuXHR9XG5cblx0a2V5cygpIHtcblx0XHRsZXQgbSA9IHRoaXMudmFsdWVPZigpXG5cdFx0cmV0dXJuIG0gPT0gbnVsbCA/IEVNUFRZX0FSUkFZIDogT2JqZWN0LmtleXMoIG0gKVxuXHR9XG59XG5cbmNsYXNzIFJlYWRPbmx5Q2VsbCBleHRlbmRzIEltbXV0YWJsZUludGVyZmFjZSB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmVudCApIHtcblx0XHRzdXBlcigpXG5cdFx0dGhpcy5fcGFyZW50ID0gcGFyZW50XG5cdH1cblxuXHRnZXRSZWFkT25seSgpIHsgcmV0dXJuIHRoaXMgfVxuXHRnZXQgbGl2ZSgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5saXZlIH1cblxuXHR2YWx1ZU9mKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LnZhbHVlT2YuYXBwbHkoIHRoaXMuX3BhcmVudCwgYXJndW1lbnRzICkgfVxuXHRub1RvdWNoKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lm5vVG91Y2guYXBwbHkoIHRoaXMuX3BhcmVudCwgYXJndW1lbnRzICkgfVxuXHR0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC50b1N0cmluZy5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cdHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC50b0pTT04uYXBwbHkoIHRoaXMuX3BhcmVudCwgYXJndW1lbnRzICkgfVxuXHRnZXROYW1lKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LmdldE5hbWUuYXBwbHkoIHRoaXMuX3BhcmVudCwgYXJndW1lbnRzICkgfVxuXG59XG5cbmxldCBHZXR0ZXIgPSAoIGZ1biwgaXNWYWx1ZUVxdWFsICkgPT4ge1xuXHRsZXQgbGFzdFxuXHRsZXQgcmV0ID0gIWlzVmFsdWVFcXVhbCA/XG5cdFx0ZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSB9XG5cdDpcblx0XHRmdW5jdGlvbiAoKSB7XG5cdFx0XHRsZXQgcmV0ID0gZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHRcdFx0aWYgKCAhaXMoIGxhc3QsIHJldCwgaXNWYWx1ZUVxdWFsICkgKVxuXHRcdFx0XHRsYXN0ID0gcmV0XG5cdFx0XHRyZXR1cm4gbGFzdFxuXHRcdH1cblx0cmV0LmlzR2V0dGVyID0gdHJ1ZVxuXHRyZXR1cm4gcmV0XG59XG5cbmxldCBUeXBlID0gKCBmICkgPT4ge1xuXHRnLnR5cGVEZXNjcmlwdG9yID0gdHJ1ZVxuXHRyZXR1cm4gZ1xuXHRmdW5jdGlvbiBnKCkgeyByZXR1cm4gZi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgfVxufVxuXG5sZXQgcnVuR2V0dGVyID0gKCBjZWxsLCBnZXR0ZXIgKSA9PiBuZXcgQWN0aW9uKCBnZXR0ZXIsIGNlbGwgKVxuXG5sZXQgcnVuU2V0dGVyID0gKCBjZWxsLCBzZXR0ZXIgKSA9PiBuZXcgQWN0aW9uKCAoKSA9PiBzZXR0ZXIoIGNlbGwudmFsdWVPZigpICksIG51bGwgKVxuXG5mdW5jdGlvbiBpcyggYSwgYiwgaXNFcXVhbCApIHtcblx0cmV0dXJuIE9iamVjdC5pcyggYSwgYiApIHx8IGIgJiYgdHlwZW9mIGIuaXNFcXVhbFRvID09IGBmdW5jdGlvbmAgJiYgYi5pc0VxdWFsVG8oIGEgKSB8fCBhICYmIHR5cGVvZiBhLmlzRXF1YWxUbyA9PSBgZnVuY3Rpb25gICYmIGEuaXNFcXVhbFRvKCBiICkgfHwgdHlwZW9mIGlzRXF1YWwgPT0gYGZ1bmN0aW9uYCAmJiBpc0VxdWFsKCBhLCBiIClcbn1cblxuY2xhc3MgVGhpcyB7XG5cdHN0YXRpYyBjcmVhdGUoIHBhcmVudCwgdGhhdCApIHtcblx0XHRsZXQgcmV0ID0gbnVsbFxuXHRcdGlmICggIXBhcmVudCApXG5cdFx0XHRyZXQgPSBuZXcgVGhpc1xuXHRcdGVsc2Vcblx0XHRcdHJldCA9IE9iamVjdC5jcmVhdGUoIHBhcmVudCApXG5cdFx0cmV0LnZhbHVlT2YgPSAoKSA9PiB0aGF0LnZhbHVlT2YoKVxuXHRcdHJldC50b1N0cmluZyA9ICgpID0+IHRoYXQudG9TdHJpbmcoKVxuXHRcdHJldC50b0pTT04gPSAoKSA9PiB0aGF0LnRvSlNPTigpXG5cdFx0cmV0LmFzc2lnbiA9IHZhbHVlID0+IHRoYXQuYXNzaWduKCB2YWx1ZSApXG5cdFx0cmV0LnRocm93ID0gdmFsdWUgPT4gdGhhdC50aHJvdyggdmFsdWUgKVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggcmV0LCBgbGl2ZWAsIHsgZ2V0OiAoKSA9PiB0aGF0LmxpdmUgfSApXG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cdF9kZWZpbmVUaGF0UHJvcGVydHkoIGtleSwgdGhhdCApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIGtleSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldCgpIHsgcmV0dXJuIHRoYXRbIGtleSBdIH0sXG5cdFx0XHRzZXQoIHZhbHVlICkgeyB0aGF0WyBrZXkgXSA9IHZhbHVlIH0sXG5cdFx0fSApXG5cdH1cbn1cblxuY2xhc3MgQ2VsbCBleHRlbmRzIEltbXV0YWJsZUludGVyZmFjZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKVxuXHRcdHRoaXMuX2lkID0gVUlEKClcblx0XHR0aGlzLl90aGF0ID0gbnVsbFxuXHRcdHRoaXMuX3ZhbHVlID0gbnVsbFxuXHRcdHRoaXMuX2Vycm9yID0gbnVsbFxuXHRcdHRoaXMuX2lzVmFsdWVFcXVhbCA9IGlzXG5cdFx0dGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZVxuXHRcdHRoaXMuX2Zyb3plbiA9IGZhbHNlXG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2Vcblx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlXG5cdFx0dGhpcy5fbGl2ZSA9IG51bGxcblx0XHR0aGlzLl9saXZlQXJyYXkgPSBudWxsXG5cdFx0dGhpcy5fYWN0aW9uc0FyciA9IFtdXG5cdFx0dGhpcy5fcGFyZW50ID0gbnVsbFxuXHRcdHRoaXMuX25vdGlmeVdyaXR0ZW4oKVxuXHRcdFZhbHVlcy5hZGQoIHRoaXMgKVxuXHR9XG5cblx0dmFsdWVPZigpIHsgcmV0dXJuIHRoaXMuX3JlYWQoKSB9XG5cdGFzc2lnbiggdmFsdWUgKSB7IHJldHVybiB0aGlzLl93cml0ZSggdmFsdWUsIGZhbHNlLCBudWxsICkgfVxuXHR1cGRhdGUoIGRpZmYgKSB7IHJldHVybiB0aGlzLmFzc2lnbiggRGlmZi5hcHBseSggdGhpcy5ub1RvdWNoKCksIGRpZmYgKSApIH1cblx0dGhyb3coIHZhbHVlICkgeyByZXR1cm4gdGhpcy5fd3JpdGUoIG51bGwsIGZhbHNlLCB2YWx1ZSApIH1cblx0dG91Y2goKSB7IHRoaXMuX2ZpcmUoKSB9XG5cblx0bm9Ub3VjaCgpIHtcblx0XHRpZiAoIHRoaXMuX2RpcnR5IClcblx0XHRcdHRoaXMuX3VwZGF0ZVNlbGYoKVxuXHRcdGlmICggdGhpcy5fZXJyb3IgKVxuXHRcdFx0dGhyb3cgdGhpcy5fZXJyb3Jcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWVcblx0fVxuXG5cdGdldCBjaGFuZ2VkKCkge1xuXHRcdHJldHVybiB0aGlzLl9hY3Rpb25zQXJyICYmIHsgdGhlbjogcHJvYyA9PiB0aGlzLl9hY3Rpb25zQXJyLnB1c2goIHsgYWN0aW9uOiB7IF9maXJlOiAoKSA9PiBwcm9jZXNzLm5leHRUaWNrKCBwcm9jICkgfSB9ICkgfVxuXHR9XG5cblx0dGhlbiggbWFwdmFsdWUsIG1hcGVycm9yICkge1xuXHRcdGlmICggbWFwdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgbWFwdmFsdWUgIT0gYGZ1bmN0aW9uYCB8fCBtYXBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBtYXBlcnJvciAhPSBgZnVuY3Rpb25gIHx8IG1hcHZhbHVlID09IG51bGwgJiYgbWFwZXJyb3IgPT0gbnVsbCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGByYS50aGVuOiB3cm9uZyBwYXJhbWV0ZXJzYCApXG5cdFx0cmV0dXJuIHJhKCBtYXBlcnJvciA9PSBudWxsID8gKCkgPT4gbWFwdmFsdWUoIHRoaXMudmFsdWVPZigpICkgOiAoKSA9PiB7XG5cdFx0XHRsZXQgdmFsdWVcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52YWx1ZU9mKClcblx0XHRcdH1cblx0XHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdHJldHVybiBtYXBlcnJvciggZXJyb3IgKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcHZhbHVlID09IG51bGwgPyB2YWx1ZSA6IG1hcHZhbHVlKCB2YWx1ZSApXG5cdFx0fSApXG5cdH1cblxuXHRjYXRjaCggbWFwZXJyb3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMudGhlbiggbnVsbCwgbWFwZXJyb3IgKVxuXHR9XG5cblx0Y2xvc2UoKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0cmV0dXJuXG5cdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZVxuXHRcdHRoaXMuX2ZpcmUoKVxuXHRcdGlmICggdGhpcy5fcGFyZW50IClcblx0XHRcdHRoaXMuX3BhcmVudC5jbG9zZSgpXG5cdFx0aWYgKCB0aGlzLl9saXZlQXJyYXkgKSB7XG5cdFx0XHRmb3IgKCBsZXQgcCBvZiB0aGlzLl9saXZlQXJyYXkgKVxuXHRcdFx0XHRwLmNsb3NlKClcblx0XHRcdHRoaXMuX2xpdmVBcnJheSA9IG51bGxcblx0XHR9XG5cdFx0dGhpcy5fdmFsdWUgPSBudWxsXG5cdFx0dGhpcy5fZXJyb3IgPSBudWxsXG5cdFx0dGhpcy5fYWN0aW9uc0FyciA9IG51bGxcblx0XHR0aGlzLl9wYXJlbnQgPSBudWxsXG5cdH1cblxuXHRmcmVlemUoKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgfHwgdGhpcy5fZnJvemVuIClcblx0XHRcdHJldHVyblxuXHRcdHRoaXMuX2Zyb3plbiA9IHRydWVcblx0XHR0aGlzLl9maXJlKCkgLy8gVE9ETyDQtNC70Y8g0LLRi9C00LDQu9C10L3RjNC90Y8g0YHQv9Cw0YHRi9C70LDQuiDQsNCx0YvRgdGM0YbRltGB0Y8g0LHQtdC3IF9maXJlINGWINCw0LTQv9Cw0LLQtdC00L3QsCDQsdC10Lcg0LvRltGI0L3Rj9Cz0LAg0L/RgNCw0LPQvtC90YNcblx0XHRpZiAoIHRoaXMuX3BhcmVudCApXG5cdFx0XHR0aGlzLl9wYXJlbnQuZnJlZXplKClcblx0XHRpZiAoIHRoaXMuX2xpdmVBcnJheSApIHtcblx0XHRcdGZvciAoIGxldCBwIG9mIHRoaXMuX2xpdmVBcnJheSApXG5cdFx0XHRcdHAuZnJlZXplKClcblx0XHR9XG5cdH1cblxuXHRnZXQgbGl2ZSgpIHsgcmV0dXJuIHRoaXMuX2xpdmUgfVxuXG5cdGdldFJlYWRPbmx5KCkge1xuXHRcdHJldHVybiB0aGlzLl9yZWFkT25seSB8fCAoIHRoaXMuX3JlYWRPbmx5ID0gbmV3IFJlYWRPbmx5Q2VsbCggdGhpcyApIClcblx0fVxuXG5cdHRvU3RyaW5nKCAuLi5hcmdzICkge1xuXHRcdGxldCB2ID0gdGhpcy5fcmVhZCgpXG5cdFx0cmV0dXJuICggdiA9PSBudWxsICkgfHwgIXYudG9TdHJpbmcgPyBgYCArIHYgOiB2LnRvU3RyaW5nKCAuLi5hcmdzIClcblx0fVxuXG5cdHRvSlNPTiggLi4uYXJncyApIHtcblx0XHRsZXQgdiA9IHRoaXMuX3JlYWQoKVxuXHRcdHJldHVybiAoIHYgPT0gbnVsbCApIHx8ICF2LnRvSlNPTiA/IHYgOiB2LnRvSlNPTiggLi4uYXJncyApXG5cdH1cblxuXHR3aXRoKCBjYiApIHsgcmV0dXJuIGNiLmNhbGwoIHRoaXMuX2dldFRoYXQoKSApIH1cblxuXHRzZXROYW1lKCBuYW1lICkge1xuXHRcdHRoaXMuX25hbWUgPSBuYW1lXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGdldE5hbWUoKSB7XG5cdFx0bGV0IHJldCA9IHRoaXMuX25hbWUgfHwgdGhpcy5fa2V5XG5cdFx0bGV0IHAgPSB0aGlzLl9wYXJlbnRcblx0XHR3aGlsZSAoIHAgKSB7XG5cdFx0XHRyZXQgPSAoIHAuX25hbWUgfHwgcC5fa2V5ICkgKyBgLmAgKyByZXRcblx0XHRcdHAgPSBwLl9wYXJlbnRcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cblx0X2dldFRoYXQoKSB7XG5cdFx0aWYgKCAhdGhpcy5fdGhhdCApIHtcblx0XHRcdHRoaXMuX3RoYXQgPSBUaGlzLmNyZWF0ZSggdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fZ2V0VGhhdCgpLCB0aGlzIClcblx0XHRcdGlmICggdGhpcy5fbGl2ZSApXG5cdFx0XHRcdGZvciAoIGxldCBpIGluIHRoaXMuX2xpdmUgKVxuXHRcdFx0XHRcdHRoaXMuX3RoYXQuX2RlZmluZVRoYXRQcm9wZXJ0eSggaSwgdGhpcyApXG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl90aGF0XG5cdH1cblxuXHRkZWZpbmVQcm9wZXJ0eSgga2V5ICkge1xuXHRcdC8vIHBhc3Mga2V5ID09IGBgIHRvIG1ha2UgQ2VsbCBvYmplY3QsIG5vdCB2YWx1ZVxuXHRcdGlmICggIXRoaXMuX2xpdmUgKSB7XG5cdFx0XHR0aGlzLl9saXZlID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHR0aGlzLl9saXZlQXJyYXkgPSBbXVxuXHRcdH1cblx0XHRpZiAoICFrZXkgKVxuXHRcdFx0cmV0dXJuXG5cdFx0Z3VhcmRQcm9wKCBrZXkgKVxuXHRcdGxldCBjID0gdGhpcy5fbGl2ZVsga2V5IF1cblx0XHRpZiAoIGMgKVxuXHRcdFx0cmV0dXJuIGNcblx0XHRjID0gbmV3IENlbGwoKVxuXHRcdHRoaXMuX2xpdmVbIGtleSBdID0gY1xuXHRcdHRoaXMuX2xpdmVBcnJheS5wdXNoKCBjIClcblx0XHRjLl9rZXkgPSBrZXlcblx0XHRjLl9wYXJlbnQgPSB0aGlzXG5cdFx0Yy5fbGV2ZWwgPSAoIHRoaXMuX2xldmVsIHx8IDAgKSArIDFcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIGtleSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoIGMuX2xpdmUgKVxuXHRcdFx0XHRcdHJldHVybiBjXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gYy5fcmVhZCgpXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2YWx1ZSA9PiB7XG5cdFx0XHRcdGlmICggYy5fbGl2ZSApXG5cdFx0XHRcdFx0dmFsdWUgPSBnZXRWYWx1ZSggdmFsdWUgKVxuXHRcdFx0XHRjLl93cml0ZSggdmFsdWUsIGZhbHNlIClcblx0XHRcdH0sXG5cdFx0fSApXG5cdFx0aWYgKCB0aGlzLl90aGF0IClcblx0XHRcdHRoaXMuX3RoYXQuX2RlZmluZVRoYXRQcm9wZXJ0eSgga2V5LCB0aGlzIClcblx0XHRpZiAoIHRoaXMuX3ZhbHVlICE9IG51bGwgKVxuXHRcdFx0Yy5fd3JpdGUoIHRoaXMuX3ZhbHVlWyBrZXkgXSwgdHJ1ZSApXG5cdFx0cmV0dXJuIGNcblx0fVxuXG5cdGluaXQoIHZhbHVlICkge1xuXHRcdHRoaXMuX2luaXQoIHZhbHVlLCBmYWxzZSwgZmFsc2UgKVxuXHR9XG5cblx0c2V0Q29uc3QoIHByb3AsIHZhbHVlICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgcHJvcCwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6ICgpID0+IHZhbHVlIH0gKVxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRzZXRWYXIoIHByb3AsIHZhbHVlICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgcHJvcCwgeyBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSApXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdF9pbml0KCB2YWx1ZSwgcmVjdXJzaXZlLCBpc0dldHRlciwgaXNWYWx1ZUVxdWFsICkge1xuXHRcdGxldCBjZWxsID0gdGhpc1xuXHRcdGlmICggIXJlY3Vyc2l2ZSAmJiBjZWxsLl9pbml0aWFsaXplZCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBhbHJlYWR5IGluaXRpYWxpemVkYCApXG5cdFx0aWYgKCB0aGlzLl9wYXJlbnQgKVxuXHRcdFx0dGhpcy5fcGFyZW50Ll9kaXJ0eSA9IHRydWVcblx0XHRjZWxsLl9pbml0aWFsaXplZCA9IHRydWVcblx0XHRpZiAoIGlzVmFsdWVFcXVhbCApXG5cdFx0XHR0aGlzLl9pc1ZhbHVlRXF1YWwgPSBpc1ZhbHVlRXF1YWxcblx0XHR2YWx1ZSA9IGNoZWNrTnVsbCggdmFsdWUgKVxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09IGBmdW5jdGlvbmAgJiYgdmFsdWUudHlwZURlc2NyaXB0b3IgKVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSggY2VsbC5fa2V5IClcblx0XHRpZiAoIHZhbHVlID09IG51bGwgKSAvLyB3ZSBhcmUgYWxyZWFkeSBudWxsIGF0IHRoZSBwb2ludCBvZiBiaXJ0aFxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCBWYWx1ZXMuaGFzKCB2YWx1ZSApICkgLy8gZm9yY2UganVzdCBhIHZhbHVlXG5cdFx0XHRyZXR1cm4gY2VsbC5fdmFsdWUgPSB2YWx1ZVxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRpZiAoIGlzR2V0dGVyIHx8IHZhbHVlLmlzR2V0dGVyICkgLy8gZ2V0dGVyXG5cdFx0XHRcdHJ1bkdldHRlciggY2VsbCwgKCkgPT4gdmFsdWUuY2FsbCggY2VsbC5fcGFyZW50ICYmIGNlbGwuX3BhcmVudC5fZ2V0VGhhdCgpICkgKVxuXHRcdFx0ZWxzZSAvLyBtZXRob2Rcblx0XHRcdFx0Y2VsbC5fdmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5hcHBseSggY2VsbC5fcGFyZW50ICYmIGNlbGwuX3BhcmVudC5fZ2V0VGhhdCgpLCBhcmd1bWVudHMgKSB9XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0aWYgKCAhaXNMaXRlcmFsKCB2YWx1ZSApICkgeyAvLyBqdXN0IGEgdmFsdWUgb3IgYSBwcm9taXNlXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZS50aGVuID09IGBmdW5jdGlvbmAgKVxuXHRcdFx0XHR2YWx1ZS50aGVuKCA6OmNlbGwuYXNzaWduLCA6OmNlbGwudGhyb3cgKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjZWxsLl92YWx1ZSA9IHZhbHVlXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0Ly8gc3VicmVjb3JkIGRlc2NyaXB0aW9uXG5cdFx0aWYgKCByZWN1cnNpdmUgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgd3JvbmcgcGFyYW1ldGVyc2AgKVxuXHRcdGNlbGwuZGVmaW5lUHJvcGVydHkoKVxuXHRcdGZvciAoIGxldCBrZXkgaW4gdmFsdWUgKSB7XG5cdFx0XHRsZXQgZGVzY3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB2YWx1ZSwga2V5IClcblx0XHRcdGlmICggIWRlc2NyIClcblx0XHRcdFx0Y29udGludWVcblx0XHRcdGxldCBnZXQgPSBkZXNjci5nZXRcblx0XHRcdGxldCBzdWJWYWx1ZSA9IGRlc2NyLnZhbHVlXG5cdFx0XHRpZiAoIGRlc2NyLnNldCApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYHdyb25nIHBhcmFtZXRlcnNgIClcblx0XHRcdGVsc2UgaWYgKCBnZXQgKVxuXHRcdFx0XHRzdWJWYWx1ZSA9IGdldFxuXHRcdFx0aWYgKCBrZXkgPT0gYCRgIClcblx0XHRcdFx0Y2VsbC5faW5pdCggc3ViVmFsdWUsIHRydWUsICEhZ2V0IClcblx0XHRcdGVsc2Vcblx0XHRcdFx0Y2VsbC5kZWZpbmVQcm9wZXJ0eSgga2V5LCB0cnVlICkuX2luaXQoIHN1YlZhbHVlLCBmYWxzZSwgISFnZXQgKVxuXHRcdH1cblx0fVxuXG5cdF9yZWFkKCkge1xuXHRcdGlmICggdGhpcy5fZGlydHkgKVxuXHRcdFx0dGhpcy5fdXBkYXRlU2VsZigpXG5cdFx0bGV0IGFjdGlvbiA9IEFjdGlvbnMuZ2V0KCBjby5nbG9iYWwgKVxuXHRcdGlmICggYWN0aW9uICkge1xuXHRcdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0XHRhY3Rpb24uY2xvc2UoKVxuXHRcdFx0ZWxzZSBpZiAoICF0aGlzLl9mcm96ZW4gKVxuXHRcdFx0XHRhY3Rpb24ub25yZWFkKCB0aGlzIClcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9lcnJvciApXG5cdFx0XHR0aHJvdyB0aGlzLl9lcnJvclxuXHRcdHJldHVybiB0aGlzLl92YWx1ZVxuXHR9XG5cblx0X3dyaXRlKCBuZXdWYWx1ZSwgZG93biwgbmV3RXJyb3IgKSB7XG5cdFx0aWYgKCBuZXdFcnJvciA9PSBudWxsIClcblx0XHRcdG5ld0Vycm9yID0gbnVsbFxuXHRcdGlmICggdGhpcy5fZnJvemVuIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJUcnkgdG8gY2hhbmdlIGEgZnJvemVuIHZhbHVlXCIgKVxuXHRcdHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZVxuXHRcdHRoaXMuX2RpcnR5ID0gZmFsc2Vcblx0XHRuZXdWYWx1ZSA9IGNoZWNrTnVsbCggbmV3VmFsdWUgKVxuXHRcdGlmICggdGhpcy5fY2xvc2VkICkge1xuXHRcdFx0bGV0IGFjdGlvbiA9IEFjdGlvbnMuZ2V0KCBjby5nbG9iYWwgKVxuXHRcdFx0aWYgKCBhY3Rpb24gKVxuXHRcdFx0XHRhY3Rpb24uY2xvc2UoKVxuXHRcdH1cblx0XHRlbHNlIGlmICggIXRoaXMuX2lzVmFsdWVFcXVhbCggdGhpcy5fdmFsdWUsIG5ld1ZhbHVlICkgfHwgdGhpcy5fZXJyb3IgIT0gbmV3RXJyb3IgKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhgPmArdGhpcy4kbmFtZSkvL2RlYnVnZ2VyXG5cdFx0XHR0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlXG5cdFx0XHR0aGlzLl9lcnJvciA9IG5ld0Vycm9yXG5cdFx0XHRpZiAoIHRoaXMuX2xpdmUgKVxuXHRcdFx0XHRmb3IgKCBsZXQgcCBvZiB0aGlzLl9saXZlQXJyYXkgKVxuXHRcdFx0XHRcdHAuX3dyaXRlKCBuZXdWYWx1ZSAmJiBuZXdWYWx1ZVsgcC5fa2V5IF0sIHRydWUgKVxuXHRcdFx0dGhpcy5fZmlyZSgpXG5cdFx0XHRpZiAoICFkb3duICkge1xuXHRcdFx0XHRsZXQgcCA9IHRoaXMuX3BhcmVudFxuXHRcdFx0XHR3aGlsZSAoIHAgJiYgIXAuX2RpcnR5ICkge1xuXHRcdFx0XHRcdHAuX2RpcnR5ID0gdHJ1ZVxuXHRcdFx0XHRcdHAuX2ZpcmUoKVxuXHRcdFx0XHRcdHAgPSBwLl9wYXJlbnRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoICFkb3duIClcblx0XHRcdHRoaXMuX25vdGlmeVdyaXR0ZW4oKVxuXHRcdHJldHVybiBuZXdWYWx1ZVxuXHR9XG5cblx0X3VwZGF0ZVNlbGYoKSB7XG5cdFx0bGV0IGNudCA9IDBcblx0XHRsZXQgcmV0ID0ge31cblx0XHRmb3IgKCBsZXQga2V5IGluIHRoaXMuX3ZhbHVlICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHRoaXMuX3ZhbHVlLCBrZXkgKSApIHtcblx0XHRcdHJldFsga2V5IF0gPSB0aGlzLl92YWx1ZVsga2V5IF1cblx0XHRcdCsrY250XG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IHAgb2YgdGhpcy5fbGl2ZUFycmF5ICkge1xuXHRcdFx0aWYgKCBwLl9kaXJ0eSApXG5cdFx0XHRcdHAuX3VwZGF0ZVNlbGYoKVxuXHRcdFx0aWYgKCBwLl9lcnJvciApIHtcblx0XHRcdFx0dGhpcy5fZXJyb3IgPSBwLl9lcnJvclxuXHRcdFx0XHR0aGlzLl92YWx1ZSA9IG51bGxcblx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGxldCB2YWx1ZSA9IHAuX3ZhbHVlXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgKSB7XG5cdFx0XHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCByZXQsIHAuX2tleSApICkge1xuXHRcdFx0XHRcdGRlbGV0ZSByZXRbIHAuX2tleSBdXG5cdFx0XHRcdFx0LS1jbnRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldFsgcC5fa2V5IF0gPSB2YWx1ZVxuXHRcdFx0XHRjbnQgPSBJbmZpbml0eVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggY250ID09IDAgKVxuXHRcdFx0cmV0ID0gbnVsbFxuXG5cdFx0dGhpcy5fdmFsdWUgPSByZXRcblx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlXG5cdH1cblxuXHRkZWJ1ZyggY2IgKSB7XG5cdFx0dGhpcy5fYWN0aW9uc0Fyci5wdXNoKCB7IGFjdGlvbjogeyBfZmlyZTogY2IgfSB9IClcblx0fVxuXG5cdGRlYnVnZ2VyKCkge1xuXHRcdHRoaXMuZGVidWcoICgpID0+IHsgZGVidWdnZXIgfSApXG5cdH1cblxuXHRfZmlyZSgpIHtcblx0XHRsZXQgYVxuXHRcdGEgPSB0aGlzLl9hY3Rpb25zQXJyXG5cdFx0aWYgKCBhLmxlbmd0aCApIHtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGxldCBjID0gYVsgaSBdXG5cdFx0XHRcdGlmICggYy5hY3Rpb24gKVxuXHRcdFx0XHRcdGMuYWN0aW9uLl9maXJlKClcblx0XHRcdFx0Yy5wdXNoZWRDID0gZmFsc2Vcblx0XHRcdH1cblx0XHRcdGEubGVuZ3RoID0gMFxuXHRcdH1cblx0fVxuXG5cdF9ub3RpZnlXcml0dGVuKCkge1xuXHRcdGxldCBhY3Rpb24gPSBBY3Rpb25zLmdldCggY28uZ2xvYmFsIClcblx0XHRpZiAoIGFjdGlvbiApXG5cdFx0XHRhY3Rpb24ub253cml0dGVuKCB0aGlzIClcblx0fVxuXG59XG5cbmxldCByZXRocm93ID0gZXJyb3IgPT4gc2V0VGltZW91dCggKCkgPT4geyB0aHJvdyBlcnJvciB9LCAxIClcblxuY2xhc3MgQWN0aW9uIHtcblxuXHRjb25zdHJ1Y3RvciggZnVuLCBkZXN0ICkge1xuXHRcdHRoaXMuX2lkID0gVUlEKClcblx0XHR0aGlzLl9mdW4gPSBmdW5cblx0XHR0aGlzLl9kZXN0ID0gZGVzdFxuXHRcdHRoaXMuX2NlbGxTZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHR0aGlzLl9jZWxsU2V0U2l6ZSA9IDBcblx0XHR0aGlzLl9jZWxsQXJyID0gW11cblx0XHR0aGlzLl90aHJlYWQgPSBjby5nbyggOjp0aGlzLl9sb29wICkud2FpdEZvcklucHV0KClcblx0fVxuXG5cdCpfbG9vcCgpIHtcblx0XHRsZXQgbmV4dCA9IHsgdGhlbjogbmV4dCA9PiB7IHRoaXMuX29uY2hhbmdlID0gbmV4dCB9IH1cblx0XHRBY3Rpb25zLnNldCggY28uZ2xvYmFsLCB0aGlzIClcblx0XHRjby5kZWZlciggKCkgPT4ge1xuXHRcdFx0QWN0aW9ucy5kZWxldGUoIGNvLmdsb2JhbCApXG5cdFx0XHR0aGlzLl9maW5hbGl6ZSgpXG5cdFx0fSApXG5cdFx0eWllbGRcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHRpZiAoIHRoaXMuaXNDbG9zZWQoKSApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0dGhpcy5fYmVnaW4oKVxuXHRcdFx0bGV0IGlzRXJyb3IgPSBmYWxzZVxuXHRcdFx0bGV0IHJldFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0ID0gKCAwLCB0aGlzLl9mdW4gKSgpXG5cdFx0XHRcdGlmICggcmV0ICYmICFWYWx1ZXMuaGFzKCByZXQgKSAmJiAoIHJldC5uZXh0IHx8IHJldC50aGVuICkgKVxuXHRcdFx0XHRcdHJldCA9IHlpZWxkIHJldFxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0aXNFcnJvciA9IHRydWVcblx0XHRcdFx0cmV0ID0gZXJyb3Jcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5pc0Nsb3NlZCgpIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRpZiAoIHRoaXMuX2Rlc3QgKSB7XG5cdFx0XHRcdGlmICggaXNFcnJvciApXG5cdFx0XHRcdFx0dGhpcy5fZGVzdC50aHJvdyggcmV0IClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRoaXMuX2Rlc3QuYXNzaWduKCByZXQgKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICggaXNFcnJvciApXG5cdFx0XHRcdFx0cmV0aHJvdyggcmV0IClcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAoIHRoaXMuX2VuZCgpICkge1xuXHRcdFx0Y2FzZSBmYWxzZToge1xuXHRcdFx0XHQvLyBDdXJyZW50IHRocmVhZCBkb2Vzbid0IG5lZWQgYW55IG1vcmUuIExldCBpdCBiZSBnYXJiYWdlZCwgYnV0IGl0cyBjaGlsZHJlbiBtdXN0IGJlIHByZXNlcnZlZC5cblx0XHRcdFx0Y28uY3VycmVudC5wcm9wb2dhdGVDaGlsZHJlblRvT3duZXIoKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGNhc2UgdHJ1ZTpcblx0XHRcdFx0eWllbGQgbmV4dFxuXHRcdFx0Ly8gY2FzZSBudWxsOlxuXHRcdFx0XHQvKiBpbW1lZGlhdGUgcmVjYWxjdWxhdGlvbiAqL1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlzQ2xvc2VkKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY2VsbEFyclxuXHR9XG5cblx0Y2xvc2UoKSB7XG5cdFx0dGhpcy5fdGhyZWFkICYmIHRoaXMuX3RocmVhZC5raWxsKClcblx0fVxuXG5cdF9maW5hbGl6ZSgpIHtcblx0XHR0aGlzLl91bnN1YnNjcmliZSgpXG5cdFx0dGhpcy5fY2VsbFNldCA9IG51bGxcblx0XHR0aGlzLl9jZWxsQXJyID0gbnVsbFxuXHRcdHRoaXMuX2Z1biA9IG51bGxcblx0XHR0aGlzLl9kZXN0ID0gbnVsbFxuXHRcdHRoaXMuX3RocmVhZCA9IG51bGxcblx0fVxuXG5cdF9iZWdpbigpIHtcblx0XHR0aGlzLl91bnN1YnNjcmliZSgpXG5cdFx0Ly8gVE9ETzogZml4IGEgYnVnIGFuZCB1bmNvbW1lbnQgbmV4dCBsaW5lICEhIVxuXHRcdC8vIGNvLmN1cnJlbnQua2lsbENoaWxkcmVuKClcblx0fVxuXG5cdF91bnN1YnNjcmliZSgpIHtcblx0XHR0aGlzLl9vbmNoYW5nZSA9IG51bGxcblx0XHRsZXQgYSA9IHRoaXMuX2NlbGxBcnJcblx0XHRpZiAoIGEgKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpICkge1xuXHRcdFx0XHRsZXQgYyA9IGFbIGkgXVxuXHRcdFx0XHRjLmNlbGwgPSBudWxsXG5cdFx0XHRcdGMudmFsdWUgPSBudWxsXG5cdFx0XHRcdGMuZXJyb3IgPSBudWxsXG5cdFx0XHRcdGMuYWN0aW9uID0gbnVsbFxuXHRcdFx0XHRjLnJlYWQgPSBmYWxzZVxuXHRcdFx0XHRjLndyaXR0ZW4gPSBmYWxzZVxuXHRcdFx0XHRjLnB1c2hlZEEgPSBmYWxzZVxuXHRcdFx0XHQvLyBkbyBub3QgY2hhbmdlIGMucHVzaGVkQyBoZXJlISFcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5fY2VsbFNldFNpemUgPiAzMiAmJiBhLmxlbmd0aCA8IHRoaXMuX2NlbGxTZXRTaXplIC8gNCApIHtcblx0XHRcdFx0dGhpcy5fY2VsbFNldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHR0aGlzLl9jZWxsU2V0U2l6ZSA9IDBcblx0XHRcdH1cblx0XHRcdGEubGVuZ3RoID0gMFxuXHRcdH1cblx0fVxuXG5cdF9lbmQoKSB7XG5cdFx0bGV0IHJldCA9IGZhbHNlXG5cdFx0bGV0IGEgPSB0aGlzLl9jZWxsQXJyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSApIHtcblx0XHRcdGxldCBjID0gYVsgaSBdXG5cdFx0XHRpZiAoIGMud3JpdHRlbiApXG5cdFx0XHRcdGMuYWN0aW9uID0gbnVsbFxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICggIWMucHVzaGVkQyApIHtcblx0XHRcdFx0XHRjLmNlbGwuX2FjdGlvbnNBcnIucHVzaCggYyApXG5cdFx0XHRcdFx0Yy5wdXNoZWRDID0gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWlzKCBjLnZhbHVlLCBjLmNlbGwuX3ZhbHVlICkgfHwgYy5lcnJvciAhPSBjLmNlbGwuX2Vycm9yIClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0XHRjLmFjdGlvbiA9IHRoaXNcblx0XHRcdFx0cmV0ID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0Yy52YWx1ZSA9IG51bGxcblx0XHRcdGMuY2VsbCA9IG51bGxcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cblx0X2xpbmtDZWxsKCBjZWxsICkge1xuXHRcdGlmICggIXRoaXMuX2NlbGxTZXQgKVxuXHRcdFx0cmV0dXJuIC8vIFRPRE8gZGVidWdnZXIgd29ya2Fyb3VuZDogdGhpcy5fY2VsbFNldCBtdXN0IG5vdCBiZSBudWxsXG5cdFx0bGV0IGMgPSB0aGlzLl9jZWxsU2V0WyBjZWxsLl9pZCBdXG5cdFx0aWYgKCBjID09IG51bGwgKSB7XG5cdFx0XHRjID0gdGhpcy5fY2VsbFNldFsgY2VsbC5faWQgXSA9IHtcblx0XHRcdFx0Y2VsbDogbnVsbCxcblx0XHRcdFx0dmFsdWU6IG51bGwsXG5cdFx0XHRcdGVycm9yOiBudWxsLFxuXHRcdFx0XHRhY3Rpb246IG51bGwsXG5cdFx0XHRcdHJlYWQ6IGZhbHNlLFxuXHRcdFx0XHR3cml0dGVuOiBmYWxzZSxcblx0XHRcdFx0cHVzaGVkQTogZmFsc2UsXG5cdFx0XHRcdHB1c2hlZEM6IGZhbHNlLFxuXHRcdFx0fVxuXHRcdFx0Kyt0aGlzLl9jZWxsU2V0U2l6ZVxuXHRcdH1cblx0XHRpZiAoICFjLnB1c2hlZEEgKSB7XG5cdFx0XHR0aGlzLl9jZWxsQXJyLnB1c2goIGMgKVxuXHRcdFx0Yy5jZWxsID0gY2VsbFxuXHRcdFx0Yy5wdXNoZWRBID0gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gY1xuXHR9XG5cblx0b25yZWFkKCBjZWxsICkge1xuXHRcdGxldCBjID0gdGhpcy5fbGlua0NlbGwoIGNlbGwgKVxuXHRcdGlmICggIWMgKVxuXHRcdFx0cmV0dXJuIC8vIFRPRE8gZGVidWdnZXIgd29ya2Fyb3VuZDogdGhpcy5fbGlua0NlbGwgbXVzdCBub3QgcmV0dXJuIG51bGxcblx0XHRjLnJlYWQgPSB0cnVlXG5cdFx0Yy52YWx1ZSA9IGNlbGwuX3ZhbHVlXG5cdFx0Yy5lcnJvciA9IGNlbGwuX2Vycm9yXG5cdH1cblxuXHRvbndyaXR0ZW4oIGNlbGwgKSB7XG5cdFx0dGhpcy5fbGlua0NlbGwoIGNlbGwgKS53cml0dGVuID0gdHJ1ZVxuXHR9XG5cblx0X2ZpcmUoKSB7XG5cdFx0aWYgKCB0aGlzLl9vbmNoYW5nZSApXG5cdFx0XHR0aGlzLl90aHJlYWQubmV4dFRpY2soIHRoaXMuX29uY2hhbmdlIClcblx0XHR0aGlzLl91bnN1YnNjcmliZSgpXG5cdH1cblxufVxuXG5sZXQgbmV3UmVhY3RpdmUgPSAoIGdldHRlciwgaGFuZGxlcnMsIGlzVmFsdWVFcXVhbCApID0+IHtcblx0Zm9yICggbGV0IGggb2YgaGFuZGxlcnMgKVxuXHRcdGlmICggaCAhPSBudWxsICYmIHR5cGVvZiBoICE9IGBmdW5jdGlvbmAgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgd3JvbmcgcGFyYW1ldGVyc2AgKVxuXHRsZXQgY2VsbCA9IG5ldyBDZWxsKClcblx0aWYgKCBnZXR0ZXIgIT09IHVuZGVmaW5lZCApXG5cdFx0Y2VsbC5faW5pdCggZ2V0dGVyLCBmYWxzZSwgdHJ1ZSwgaXNWYWx1ZUVxdWFsIClcblx0Zm9yICggbGV0IGggb2YgaGFuZGxlcnMgKVxuXHRcdGggJiYgKCBoLmxlbmd0aCA/IHJ1blNldHRlciA6IHJ1bkdldHRlciApKCBjZWxsLCBoIClcblx0cmV0dXJuIGNlbGxcbn1cblxuLy8gbGV0IHJhX3Byb3AgPSBmdW5jdGlvbiAoIHRhcmdldCwgbmFtZSwgZGVzY3IgKSB7XG4vLyBcdC8vIGJvZHkuLi5cbi8vIH1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmEoIGZ1biApIHtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGFyZ3VtZW50cy5sZW5ndGggKVxuXHRcdC8vIHJldHVybiByYV9wcm9wKCBhcmd1bWVudHNbIDAgXSwgYXJndW1lbnRzWyAxIF0sIGFyZ3VtZW50c1sgMiBdIClcblx0fVxuXHRlbHNlXG5cdFx0cmV0dXJuIG5ld1JlYWN0aXZlKCBmdW4sIFtdIClcbn1cblxuZnVuY3Rpb24gQXJyYXlJc0VxdWFsVG8oIGEgKSB7XG5cdHJldHVybiAoIHRoaXMgPT0gYSApIHx8IEFycmF5LmlzQXJyYXkoIGEgKSAmJiB0aGlzLmxlbmd0aCA9PSBhLmxlbmd0aCAmJiB0aGlzLmV2ZXJ5KCAoIGUsIGkgKSA9PiBpcyggZSwgYVsgaSBdICkgKVxufVxuXG5mdW5jdGlvbiBKc29uSXNFcXVhbFRvKCBhICkge1xuXHRyZXR1cm4gKCB0aGlzID09IGEgKSB8fCBKU09OLnN0cmluZ2lmeSggdGhpcyApID09IEpTT04uc3RyaW5naWZ5KCBhIClcbn1cblxucmEucmEgPSByYVxuXG5yYS5pcyA9IGlzXG5cbnJhLkFycmF5ID0gYXJyYXkgPT4ge1xuXHRhcnJheS5pc0VxdWFsVG8gPSBBcnJheUlzRXF1YWxUb1xuXHRyZXR1cm4gYXJyYXlcbn1cblxucmEuSlNPTiA9IG9iaiA9PiB7XG5cdG9iai5pc0VxdWFsVG8gPSBKc29uSXNFcXVhbFRvXG5cdHJldHVybiBvYmpcbn1cblxucmEuVmFsdWUgPSBvYmogPT4ge1xuXHRpZiAoIG9iaiAmJiAoIHR5cGVvZiBvYmogPT0gYG9iamVjdGAgfHwgdHlwZW9mIG9iaiA9PSBgZnVuY3Rpb25gICkgKVxuXHRcdFZhbHVlcy5hZGQoIG9iaiApXG5cdHJldHVybiBvYmpcbn1cblxucmEuZGV0YWNoID0gZnVuID0+IHtcblx0bGV0IG9sZFxuXHRpZiAoIG9sZCA9IEFjdGlvbnMuZ2V0KCBjby5nbG9iYWwgKSApIHtcblx0XHRBY3Rpb25zLmRlbGV0ZSggY28uZ2xvYmFsIClcblx0XHR0cnkgeyByZXR1cm4gZnVuKCkgfSBmaW5hbGx5IHsgQWN0aW9ucy5zZXQoIGNvLmdsb2JhbCwgb2xkICkgfVxuXHR9XG5cdGVsc2Vcblx0XHRyZXR1cm4gZnVuKClcbn1cblxucmEub24gPSAoIGVtaXR0ZXIsIGV2ZW50LCBnZXR0ZXIgKSA9PiB7XG5cdGxldCByZXQgPSByYSgpXG5cdGxldCBoYW5kbGVyID0gZGF0YSA9PiByZXQuYXNzaWduKCBnZXR0ZXIoIGRhdGEgKSApXG5cdGlmICggZXZlbnQgPT0gYHN0cmluZ2AgKVxuXHRcdGVtaXR0ZXIub24oIGV2ZW50LCBoYW5kbGVyIClcblx0ZWxzZSBmb3IgKCBsZXQgZSBvZiBldmVudCApXG5cdFx0ZW1pdHRlci5vbiggZSwgaGFuZGxlciApXG5cdGhhbmRsZXIoKVxuXHRyZXR1cm4gcmV0XG59XG5cbnJhLkNlbGwgPSBDZWxsXG5yYS5JbW11dGFibGVJbnRlcmZhY2UgPSBJbW11dGFibGVJbnRlcmZhY2VcbnJhLkFic3RyYWN0R3VhcmQgPSBBYnN0cmFjdEd1YXJkXG5yYS5HZXR0ZXIgPSBHZXR0ZXJcbnJhLlR5cGUgPSBUeXBlXG5yYS5pbXBvcnRGcm9tID0gb2JzZXJ2YWJsZSA9PiBUeXBlKCBuYW1lID0+IEdldHRlciggKCkgPT4gb2JzZXJ2YWJsZS5saXZlWyBuYW1lIF0udmFsdWVPZigpICkgKVxuXG5mdW5jdGlvbiB0b0tleSggb2JqICkge1xuXHRpZiAoICF0b0tleS5LZXlzIClcblx0XHR0b0tleS5LZXlzID0gdHlwZW9mIFdlYWtNYXAgIT0gYHVuZGVmaW5lZGAgPyBuZXcgV2Vha01hcCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGxldCBpZCA9IGBfdG9fa2V5XyR7IFVJRCgpIH1gXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZXQoIG9iaiwgdmFsdWUgKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCBpZCwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR9ICkgfSxcblx0XHRcdFx0Z2V0KCBvYmogKSB7IHJldHVybiBvYmpbIGlkIF0gfSxcblx0XHRcdFx0aGFzKCBvYmogKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIG9iaiwgaWQgKSB9LFxuXHRcdFx0XHQvLyBkZWxldGUoIG9iaiApIHsgZGVsZXRlIG9ialsgaWQgXSB9LFxuXHRcdFx0fVxuXHRcdH0oKVxuXHRpZiAoIG9iaiAmJiAoIHR5cGVvZiBvYmogPT0gYG9iamVjdGAgfHwgdHlwZW9mIG9iaiA9PSBgZnVuY3Rpb25gICkgKSB7XG5cdFx0aWYgKCAhdG9LZXkuS2V5cy5oYXMoIG9iaiApIClcblx0XHRcdHRvS2V5LktleXMuc2V0KCBvYmosIFVJRCgpIClcblx0XHRyZXR1cm4gdG9LZXkuS2V5cy5nZXQoIG9iaiApXG5cdH1cblx0cmV0dXJuIHR5cGVvZiBvYmogKyBvYmpcbn1cblxucmEubWFrZUtleSA9ICggb2JqLCBrZXkgKSA9PiByYSggKCkgPT4gb2JqLmdldCgga2V5ICkgKVxuXG5yYS5tYXAgPSAoIGFycmF5LCBtYXBwZXIgKSA9PiB7XG5cdGlmICggISggYXJyYXkgaW5zdGFuY2VvZiBDZWxsICkgKVxuXHRcdHRocm93IG5ldyBFcnJvciggXCJyYS5tYXA6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjZWxsXCIgKVxuXHRsZXQgY2FjaGUgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0bGV0IHJldCA9IHJhKClcblx0cmEuZGV0YWNoKCAoKSA9PiByYSggKCkgPT4ge1xuXHRcdC8vIFRPRE8g0L/RgNCw0LLQtdGA0YvRhtGMLCDRiNGC0L4g0L/RgNGLIGFycmF5LmNsb3NlKCkg0LPRjdGC0LAg0YTRg9C90LrRhtGL0Y8g0LDQtNC/0YDQsNGG0L7RntCy0LDQtSDRliDQv9GA0YvQsdGW0LLQsNC1INGe0YHQtSBjYWNoZVtdLmluZGV4INGWIGNhY2hlW10ucHJvY1xuXHRcdGxldCBhID0gYXJyYXkudmFsdWVPZigpXG5cdFx0cmEuZGV0YWNoKCAoKSA9PiB7XG5cdFx0XHRsZXQgcmV0YXJyID0gW11cblx0XHRcdGxldCBpbmRleCA9IDBcblx0XHRcdGxvZGFzaC5mb3JFYWNoKCBjYWNoZSwgYyA9PiB7IGMuYWJhbmRvbmVkID0gdHJ1ZSB9IClcblx0XHRcdGEgJiYgYS5mb3JFYWNoKCB2YWx1ZSA9PiB7XG5cdFx0XHRcdGxldCBrZXkgPSB0b0tleSggdmFsdWUgKVxuXHRcdFx0XHRsZXQgY1xuXHRcdFx0XHRpZiAoICEoIGMgPSBjYWNoZVsga2V5IF0gKSApXG5cdFx0XHRcdFx0YyA9IGNhY2hlWyBrZXkgXSA9IHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGluZGV4OiByYSgpLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Yy5hYmFuZG9uZWQgPSBmYWxzZVxuXHRcdFx0XHRjLmluZGV4LmFzc2lnbiggaW5kZXgrKyApXG5cdFx0XHRcdGlmICggIWMucHJvYyApXG5cdFx0XHRcdFx0Yy5wcm9jID0gcmEoICgpID0+IG1hcHBlciggdmFsdWUsIGMuaW5kZXggKSApXG5cdFx0XHRcdHJldGFyci5wdXNoKCBjLnByb2MgKVxuXHRcdFx0fSApXG5cdFx0XHRsb2Rhc2gua2V5cyggY2FjaGUgKS5mb3JFYWNoKCBrZXkgPT4ge1xuXHRcdFx0XHRsZXQgYyA9IGNhY2hlWyBrZXkgXVxuXHRcdFx0XHRpZiAoIGMuYWJhbmRvbmVkICkge1xuXHRcdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5IF1cblx0XHRcdFx0XHRjLmluZGV4LmNsb3NlKClcblx0XHRcdFx0XHRjLnByb2MuY2xvc2UoKVxuXHRcdFx0XHR9XG5cdFx0XHR9IClcblx0XHRcdHJldC5hc3NpZ24oIHJhLkFycmF5KCByZXRhcnIgKSApXG5cdFx0fSApXG5cdH0gKSApXG5cdHJldHVybiByZXRcbn1cblxucmEua2V5bWFwID0gKCBhcnJheSwgbWFwcGVyICkgPT4ge1xuXHRsZXQgbWFwcGVkID0gcmEubWFwKCBhcnJheSwgbWFwcGVyIClcblx0cmV0dXJuIHJhKCAoKSA9PiBsb2Rhc2guemlwT2JqZWN0KCBhcnJheS52YWx1ZU9mKCksIG1hcHBlZC52YWx1ZU9mKCkgKSApXG59XG5cbi8vIHJhLnNsaWNlID0gKCBkZXN0LCBzb3VyY2UsIGtleXNWYXIgKSA9PiB7XG4vLyBcdHRocm93IG5ldyBFcnJvciggXCJtZXNzYWdlXCIgKVxuLy8gXHQvLyBUT0RPOiBvcHRpbWl6YXRpb25cbi8vIFx0aWYgKCAhKCBkZXN0IGluc3RhbmNlb2YgQ2VsbCApIClcbi8vIFx0XHRkZXN0ID0gcmEoIGRlc3QgKVxuLy8gXHRsZXQgY2FjaGVIb2xkZXIgPSByYSgpXG4vLyBcdHJhKCAoKSA9PiB7XG4vLyBcdFx0bGV0IGtleXMgPSBnZXRWYWx1ZSgga2V5c1ZhciApXG4vLyBcdFx0aWYgKCBrZXlzIClcbi8vIFx0XHRcdGtleXMuc29ydCgpXG4vLyBcdFx0cHJvY2Vzcy5uZXh0VGljayggKCkgPT4ge1xuLy8gXHRcdFx0bGV0IGMgPSByYSgpXG4vLyBcdFx0XHRsZXQgcyA9IGMuZGVmaW5lUHJvcGVydHkoIGBzb3VyY2VgIClcbi8vIFx0XHRcdGxldCBkID0gYy5kZWZpbmVQcm9wZXJ0eSggYGRlc3RgIClcbi8vIFx0XHRcdGtleXMgJiYga2V5cy5mb3JFYWNoKCBrID0+IHtcbi8vIFx0XHRcdFx0bGV0IHNrID0gcy5kZWZpbmVQcm9wZXJ0eSggayApXG4vLyBcdFx0XHRcdGxldCBkayA9IGQuZGVmaW5lUHJvcGVydHkoIGsgKVxuLy8gXHRcdFx0XHRyYSggKCkgPT4gZGsuYXNzaWduKCBzay52YWx1ZU9mKCkgKSApXG4vLyBcdFx0XHR9IClcbi8vIFx0XHRcdGxldCB0ID0gY2FjaGVIb2xkZXIudmFsdWVPZigpXG4vLyBcdFx0XHRjYWNoZUhvbGRlci5hc3NpZ24oIGMgKVxuLy8gXHRcdFx0dCAmJiB0LmNsb3NlKClcbi8vIFx0XHR9IClcbi8vIFx0fSApXG4vLyBcdHJhKCAoKSA9PiB7XG4vLyBcdFx0bGV0IGMgPSBjYWNoZUhvbGRlci52YWx1ZU9mKClcbi8vIFx0XHRjICYmIGMuc291cmNlICYmIGMuc291cmNlLmFzc2lnbiggc291cmNlLnZhbHVlT2YoKSApXG4vLyBcdH0gKVxuLy8gXHRyYSggKCkgPT4ge1xuLy8gXHRcdGxldCBjID0gY2FjaGVIb2xkZXIudmFsdWVPZigpXG4vLyBcdFx0ZGVzdC5hc3NpZ24oIGMgJiYgYy5kZXN0ICYmIGMuZGVzdC52YWx1ZU9mKCkgKVxuLy8gXHR9IClcbi8vIFx0cmV0dXJuIGRlc3Rcbi8vIH1cbiIsImltcG9ydCAqIGFzIHN0cmVhbSBmcm9tIFwic3RyZWFtXCJcblxuY2xhc3MgUGlwZSB7XG5cdGNvbnN0cnVjdG9yKCBfc3RyZWFtICkge1xuXHRcdHRoaXMuX3N0cmVhbSA9IF9zdHJlYW1cblx0fVxuXHRwaXBlKCAuLi5kZXN0ICkge1xuXHRcdHJldHVybiBuZXcgUGlwZSggdGhpcy5fc3RyZWFtLnBpcGUoIC4uLmRlc3QgKSApXG5cdH1cblx0aW5wdXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0cmVhbVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaXBlKCBkZXN0ICkge1xuXHRyZXR1cm4gbmV3IFBpcGUoIG5ldyBzdHJlYW0uUGFzc1Rocm91Z2ggKS5waXBlKCBkZXN0IClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb20oIHN0cmVhbSApIHtcblx0c3RyZWFtLnBpcGUoIHRoaXMgKVxuXHRyZXR1cm4gc3RyZWFtXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25uZWN0KCBkdXBsZXggKSB7XG5cdHRoaXMucGlwZSggZHVwbGV4IClcblx0ZHVwbGV4LnBpcGUoIHRoaXMgKVxuXHRyZXR1cm4gZHVwbGV4Lm90aGVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd1RpbWVvdXQoKSB7XG5cdHRocm93IG5ldyBFcnJvciggYHRpbWVvdXRgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE1hcCggbWFwICkge1xuXHRyZXR1cm4gbmV3IHN0cmVhbS5UcmFuc2Zvcm0oIHsgb2JqZWN0TW9kZTogdHJ1ZSwgdHJhbnNmb3JtKCBkYXRhLCBfLCBjYWxsYmFjayApIHtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy5wdXNoKCBtYXAoIGRhdGEgKSApXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHR0aGlzLmVtaXQoIGBlcnJvcmAsIGVycm9yIClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHR9IH0gKVxufVxuXG5leHBvcnQgY29uc3QgdGhyb3VnaCA9ICgpID0+IG5ldyBzdHJlYW0uUGFzc1Rocm91Z2goIHsgb2JqZWN0TW9kZTogdHJ1ZSB9IClcblxuZnVuY3Rpb24gbm90KCBmbGFnICkge1xuXHRpZiAoIGZsYWcgPT09IHRydWUgKVxuXHRcdHJldHVybiBmYWxzZVxuXHRpZiAoIGZsYWcgPT09IGZhbHNlIClcblx0XHRyZXR1cm4gdHJ1ZVxuXHRyZXR1cm4gZmxhZ1xufVxuXG5leHBvcnQgY2xhc3MgRHVwbGV4ZXIgZXh0ZW5kcyBzdHJlYW0uRHVwbGV4IHtcblx0Y29uc3RydWN0b3IoIC4uLmFyZ3MgLyogb3B0aW9ucyA9IG51bGwsIHdyaXRlciwgcmVhZGVyICovICkge1xuXHRcdGxldCBvcHRpb25zLCB3cml0ZXIsIHJlYWRlclxuXHRcdGlmICggIWFyZ3NbIDAgXSB8fCAhYXJnc1sgMCBdLl9yZWFkYWJsZVN0YXRlICYmICFhcmdzWyAwIF0uX3dyaXRhYmxlU3RhdGUgKVxuXHRcdFx0b3B0aW9ucyA9IGFyZ3Muc2hpZnQoKVxuXHRcdHdyaXRlciA9IGFyZ3Muc2hpZnQoKVxuXHRcdHJlYWRlciA9IGFyZ3Muc2hpZnQoKVxuXHRcdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgb3B0aW9ucyApXG5cdFx0bGV0IG90aGVyT3B0aW9ucyA9IHtcblx0XHRcdG9iamVjdE1vZGU6IG9wdGlvbnMub2JqZWN0TW9kZSxcblx0XHRcdHJlYWRhYmxlT2JqZWN0TW9kZTogb3B0aW9ucy5vdGhlcldyaXRhYmxlT2JqZWN0TW9kZSAhPSBudWxsID8gb3B0aW9ucy5vdGhlcldyaXRhYmxlT2JqZWN0TW9kZSA6IG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLFxuXHRcdFx0d3JpdGFibGVPYmplY3RNb2RlOiBvcHRpb25zLm90aGVyUmVhZGFibGVPYmplY3RNb2RlICE9IG51bGwgPyBvcHRpb25zLm90aGVyUmVhZGFibGVPYmplY3RNb2RlIDogb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUsXG5cdFx0fVxuXHRcdGlmICggcmVhZGVyICYmIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlID09IG51bGwgKVxuXHRcdFx0b3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgPSByZWFkZXIuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZVxuXHRcdGlmICggd3JpdGVyICYmIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlID09IG51bGwgKVxuXHRcdFx0b3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUgPSB3cml0ZXIuX3dyaXRhYmxlU3RhdGUub2JqZWN0TW9kZVxuXHRcdHN1cGVyKCBvcHRpb25zIClcblx0XHR0aGlzLl9vbmRhdGEgPSBkYXRhID0+IHtcblx0XHRcdGlmICggIXRoaXMucHVzaCggZGF0YSApICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuX3JlYWRlciApXG5cdFx0XHRcdFx0dGhpcy5fcmVhZGVyLnBhdXNlKClcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fb25lbmQgPSAoKSA9PiB0aGlzLnB1c2goIG51bGwgKVxuXHRcdHRoaXMuX29uZXJyb3IgPSBlcnJvciA9PiB0aGlzLmVtaXQoIGBlcnJvcmAsIGVycm9yIClcblx0XHR0aGlzLl93cml0ZV9jYWxsYmFjayA9IG51bGxcblx0XHR0aGlzLl9vbmRyYWluID0gKCkgPT4ge1xuXHRcdFx0bGV0IGNhbGxiYWNrID0gdGhpcy5fd3JpdGVfY2FsbGJhY2tcblx0XHRcdHRoaXMuX3dyaXRlX2NhbGxiYWNrID0gbnVsbFxuXHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuXHRcdH1cblx0XHR0aGlzLl9vdGhlck9wdGlvbnMgPSBvdGhlck9wdGlvbnNcblx0XHR0aGlzLm9uKCBgZmluaXNoYCwgKCkgPT4gdGhpcy5fd3JpdGVyLmVuZCgpIClcblx0XHR0aGlzLl90aGF0ID0gbnVsbFxuXHRcdHRoaXMuX290aGVyID0gbnVsbFxuXHRcdHRoaXMuc2V0U3RyZWFtcyggd3JpdGVyLCByZWFkZXIgKVxuXHR9XG5cdGdldCBvdGhlcigpIHtcblx0XHRpZiAoICF0aGlzLl90aGF0ICkge1xuXHRcdFx0bGV0IG90aGVyID0gbmV3IER1cGxleGVyKCB0aGlzLl9vdGhlck9wdGlvbnMsIHRoaXMuX3JlYWRlciwgdGhpcy5fd3JpdGVyIClcblx0XHRcdHRoaXMuX3RoYXQgPSBvdGhlclxuXHRcdFx0dGhpcy5fb3RoZXIgPSBvdGhlclxuXHRcdFx0b3RoZXIuX3RoYXQgPSB0aGlzXG5cdFx0XHRvdGhlci5fb3RoZXIgPSB0aGlzXG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9vdGhlclxuXHR9XG5cdHNldE90aGVyKCBvdGhlciApIHtcblx0XHR0aGlzLl9vdGhlciA9IHRoaXMub3RoZXI6OmNvbm5lY3QoIG90aGVyIClcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdF9yZWFkKCkge1xuXHRcdGlmICggdGhpcy5fcmVhZGVyIClcblx0XHRcdHRoaXMuX3JlYWRlci5yZXN1bWUoKVxuXHR9XG5cdF9kb193cml0ZSggZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdGhpcy5fd3JpdGVyLndyaXRlKCBkYXRhLCBlbmNvZGluZyApIClcblx0XHRcdGNhbGxiYWNrKClcblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX3dyaXRlX2NhbGxiYWNrID0gY2FsbGJhY2tcblx0XHRcdHRoaXMuX3dyaXRlci5vbmNlKCBgZHJhaW5gLCB0aGlzLl9vbmRyYWluIClcblx0XHR9XG5cdH1cblx0X3dyaXRlKCBkYXRhLCBlbmNvZGluZywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCB0aGlzLl93cml0ZXIgKVxuXHRcdFx0dGhpcy5fZG9fd3JpdGUoIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjayApXG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5vbmNlKCBgd3JpdGVyYCwgKCkgPT4gdGhpcy5fZG9fd3JpdGUoIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjayApIClcblx0fVxuXHRzZXRSZWFkYWJsZSggcmVhZGVyICkge1xuXHRcdGlmICggdGhpcy5fcmVhZGVyID09IHJlYWRlciApXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoIHRoaXMuX3JlYWRlciApIHtcblx0XHRcdHRoaXMuX3JlYWRlci5yZW1vdmVMaXN0ZW5lciggYGRhdGFgLCB0aGlzLl9vbmRhdGEgKVxuXHRcdFx0dGhpcy5fcmVhZGVyLnJlbW92ZUxpc3RlbmVyKCBgZW5kYCwgdGhpcy5fb25lbmQgKVxuXHRcdFx0dGhpcy5fcmVhZGVyLnJlbW92ZUxpc3RlbmVyKCBgZXJyb3JgLCB0aGlzLl9vbmVycm9yIClcblx0XHRcdHRoaXMuX3JlYWRlciA9IG51bGxcblx0XHR9XG5cdFx0aWYgKCByZWFkZXIgKSB7XG5cdFx0XHR0aGlzLl9yZWFkZXIgPSByZWFkZXJcblx0XHRcdHRoaXMuX3JlYWRlci5hZGRMaXN0ZW5lciggYGRhdGFgLCB0aGlzLl9vbmRhdGEgKVxuXHRcdFx0dGhpcy5fcmVhZGVyLmFkZExpc3RlbmVyKCBgZW5kYCwgdGhpcy5fb25lbmQgKVxuXHRcdFx0dGhpcy5fcmVhZGVyLmFkZExpc3RlbmVyKCBgZXJyb3JgLCB0aGlzLl9vbmVycm9yIClcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl90aGF0IClcblx0XHRcdHRoaXMuX3RoYXQuc2V0V3JpdGFibGUoIHJlYWRlciApXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRzZXRXcml0YWJsZSggd3JpdGVyICkge1xuXHRcdGlmICggdGhpcy5fd3JpdGVyID09IHdyaXRlciApXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoIHRoaXMuX3dyaXRlciApIHtcblx0XHRcdHRoaXMuX3dyaXRlci5yZW1vdmVMaXN0ZW5lciggYGVycm9yYCwgdGhpcy5fb25lcnJvciApXG5cdFx0XHR0aGlzLl93cml0ZXIucmVtb3ZlTGlzdGVuZXIoIGBkcmFpbmAsIHRoaXMuX29uZHJhaW4gKVxuXHRcdFx0dGhpcy5fd3JpdGVyID0gbnVsbFxuXHRcdFx0dGhpcy5fb25kcmFpbigpXG5cdFx0fVxuXHRcdGlmICggd3JpdGVyICkge1xuXHRcdFx0dGhpcy5fd3JpdGVyID0gd3JpdGVyXG5cdFx0XHR0aGlzLl93cml0ZXIuYWRkTGlzdGVuZXIoIGBlcnJvcmAsIHRoaXMuX29uZXJyb3IgKVxuXHRcdFx0dGhpcy5lbWl0KCBgd3JpdGVyYCApXG5cdFx0fVxuXHRcdGlmICggdGhpcy5fdGhhdCApXG5cdFx0XHR0aGlzLl90aGF0LnNldFJlYWRhYmxlKCB3cml0ZXIgKVxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0c2V0U3RyZWFtcyggd3JpdGVyLCByZWFkZXIgKSB7XG5cdFx0dGhpcy5zZXRXcml0YWJsZSggd3JpdGVyIClcblx0XHR0aGlzLnNldFJlYWRhYmxlKCByZWFkZXIgKVxuXHRcdHJldHVybiB0aGlzXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGR1cGxleGVyKCAuLi5hcmdzICkge1xuXHRyZXR1cm4gbmV3IER1cGxleGVyKCAuLi5hcmdzIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZCggcHJvYyApIHtcblx0aWYgKCAhcHJvYyApXG5cdFx0cmV0dXJuIGR1cGxleGVyKCBwcm9jZXNzLnN0ZG91dCwgcHJvY2Vzcy5zdGRpbiApXG5cdGVsc2Vcblx0XHRyZXR1cm4gZHVwbGV4ZXIoIHByb2Muc3RkaW4sIHByb2Muc3Rkb3V0IClcbn1cblxuY29uc3QgREVTVF9SRUFEWSA9IDBcbmNvbnN0IERFU1RfUEFVU0VEID0gMVxuY29uc3QgU1JDX1BBVVNFRCA9IDJcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlciggZmlsdGVycyApIHtcblx0Ly8gbGV0IHN0cmVhbXMgPSBBcnJheS5pc0FycmF5KCBmaWx0ZXJzICkgPyBbXSA6IHt9XG5cdGxldCBmID0gW11cblx0bGV0IHN1bSA9IHRocm91Z2goKVxuXHRsZXQgc3BsaXQgPSB0aHJvdWdoKClcblx0bGV0IGNvdW50ID0gMVxuXHRsZXQgb25lbmQgPSAoKSA9PiB7XG5cdFx0aWYgKCAwID09IC0tY291bnQgKVxuXHRcdFx0c3VtLmVuZCgpXG5cdH1cblx0bGV0IHBhdXNlZCA9IDBcblx0bGV0IG9uZHJhaW4gPSAoKSA9PiB7XG5cdFx0aWYgKCAwID09IC0tY291bnQgKVxuXHRcdFx0c3VtLmVuZCgpXG5cdH1cblx0cHJvY2Vzcy5uZXh0VGljayggb25lbmQgKVxuXHRmdW5jdGlvbiBjbGVhclBhdXNlZCggZmlsdGVyICkge1xuXHRcdGlmICggZmlsdGVyLnBhdXNlZCA9PSBTUkNfUEFVU0VEICkge1xuXHRcdFx0ZmlsdGVyLnBhdXNlZCA9IERFU1RfUkVBRFlcblx0XHRcdGlmICggMCA9PSAtLXBhdXNlZCApXG5cdFx0XHRcdHNwbGl0LnJlc3VtZSgpXG5cdFx0fVxuXHR9XG5cdGZvciAoIGxldCBuYW1lIG9mIE9iamVjdC5rZXlzKCBmaWx0ZXJzICkgKSB7XG5cdFx0bGV0IGZpbHRlciA9IGZpbHRlcnNbIG5hbWUgXVxuXHRcdC8vIGlmICggdHlwZW9mIGZpbHRlciA9PSBgZnVuY3Rpb25gIClcblx0XHQvLyBcdGZpbHRlciA9IHsgZmlsdGVyOiBmaWx0ZXIsIHN0cmVhbTogdGhyb3VnaCgpIH1cblx0XHQvLyBzdHJlYW1zWyBuYW1lIF0gPSBmaWx0ZXIuc3RyZWFtXG5cdFx0ZmlsdGVyID0geyBmaWx0ZXI6IGZpbHRlci5maWx0ZXIsIHN0cmVhbTogZmlsdGVyLnN0cmVhbSwgcGF1c2VkOiBERVNUX1JFQURZIH1cblx0XHRmLnB1c2goIGZpbHRlciApXG5cdFx0ZmlsdGVyLnN0cmVhbS5vbiggYGRyYWluYCwgKCkgPT4gY2xlYXJQYXVzZWQoIGZpbHRlciApIClcblx0XHRpZiAoIHR5cGVvZiBmaWx0ZXIuc3RyZWFtLnBpcGUgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdGZpbHRlci5zdHJlYW0ucGlwZSggc3VtLCB7IGVuZDogZmFsc2UgfSApXG5cdFx0XHQrK2NvdW50XG5cdFx0XHRmaWx0ZXIuc3RyZWFtLm9uKCBgZW5kYCwgb25lbmQgKVxuXHRcdH1cblx0fVxuXHRzcGxpdC5vbiggYGRhdGFgLCBkYXRhID0+IHtcblx0XHRmb3IgKCBsZXQgZmlsdGVyIG9mIGYgKVxuXHRcdFx0aWYgKCBmaWx0ZXIuZmlsdGVyKCBkYXRhICkgKSB7XG5cdFx0XHRcdGlmICggZmlsdGVyLnN0cmVhbS53cml0ZSggZGF0YSApIClcblx0XHRcdFx0XHRjbGVhclBhdXNlZCggZmlsdGVyIClcblx0XHRcdFx0ZWxzZSBpZiAoIGZpbHRlci5wYXVzZWQgPT0gREVTVF9SRUFEWSApXG5cdFx0XHRcdFx0ZmlsdGVyLnBhdXNlZCA9IERFU1RfUEFVU0VEXG5cdFx0XHRcdGVsc2UgaWYgKCBmaWx0ZXIucGF1c2VkID09IERFU1RfUEFVU0VEICkge1xuXHRcdFx0XHRcdGZpbHRlci5wYXVzZWQgPSBTUkNfUEFVU0VEXG5cdFx0XHRcdFx0aWYgKCAxID09ICsrcGF1c2VkIClcblx0XHRcdFx0XHRcdHNwbGl0LnBhdXNlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHR9IClcblx0c3BsaXQub24oIGBlbmRgLCAoKSA9PiB7XG5cdFx0Zm9yICggbGV0IHsgc3RyZWFtIH0gb2YgZiApXG5cdFx0XHRzdHJlYW0uZW5kKClcblx0fSApXG5cdGxldCByZXQgPSBuZXcgRHVwbGV4ZXIoIHNwbGl0LCBzdW0gKVxuXHQvLyByZXQuc3RyZWFtcyA9IHN0cmVhbXNcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnQgZnVuY3Rpb24gRnVuYyggZHVwbGV4LCB7IHRpbWVvdXQgPSBudWxsLCB0aW1lb3V0UHJvYyA9IHRocm93VGltZW91dCB9ID0ge30gKSB7XG5cdGxldCBwcm9taXNlcyA9IFtdXG5cdGxldCBzaGlmdCA9ICgpID0+IHtcblx0XHRsZXQgcmV0ID0gcHJvbWlzZXMuc2hpZnQoKVxuXHRcdGNsZWFyVGltZW91dCggcmV0LnRpbWVyIClcblx0XHRyZXR1cm4gcmV0XG5cdH1cblx0ZHVwbGV4Lm9uKCBgZGF0YWAsIHJlc3VsdCA9PiBzaGlmdCgpLnJlc29sdmUoIHJlc3VsdCApIClcblx0ZHVwbGV4Lm9uKCBgZXJyb3JgLCBlcnJvciA9PiB7XG5cdFx0d2hpbGUgKCBwcm9taXNlcy5sZW5ndGggKVxuXHRcdFx0c2hpZnQoKS5yZWplY3QoIGVycm9yIClcblx0fSApXG5cdGR1cGxleC5vbiggYGVuZGAsIGVycm9yID0+IHtcblx0XHR3aGlsZSAoIHByb21pc2VzLmxlbmd0aCApXG5cdFx0XHR0aW1lciggc2hpZnQoKSApXG5cdH0gKVxuXHRsZXQgdGltZXIgPSBwcm9taXNlID0+IHtcblx0XHR0cnkge1xuXHRcdFx0cHJvbWlzZS5yZXNvbHZlKCB0aHJvd1RpbWVvdXQoKSApXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRwcm9taXNlLnJlc29sdmUoIGVycm9yIClcblx0XHR9XG5cdH1cblx0bGV0IG9udGltZW91dCA9ICgpID0+IHRpbWVyKCBzaGlmdCgpIClcblx0cmV0dXJuIHZhbHVlID0+IHtcblx0XHRkdXBsZXgud3JpdGUoIHZhbHVlIClcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4gcHJvbWlzZXMucHVzaCgge1xuXHRcdFx0cmVzb2x2ZSxcblx0XHRcdHJlamVjdCxcblx0XHRcdHRpbWVyOiB0aW1lb3V0ICYmIHNldFRpbWVvdXQoIG9udGltZW91dCwgdGltZW91dCApLFxuXHRcdH0gKSApXG5cdH1cbn1cbiIsImZ1bmN0aW9uIHJldGhyb3coIGVycm9yICkge1xuXHRzZXRUaW1lb3V0KCAoKSA9PiB7IHRocm93IGVycm9yIH0gKVxufVxuXG5mdW5jdGlvbiBzYWZlRWFjaCggYXJyYXksIGNiICkge1xuXHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArK2kgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNiKCBhcnJheS5zaGlmdCgpIClcblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdHJldGhyb3coIGVycm9yIClcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BhcnNlUXVldWUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9jYnMgPSBbXVxuXHR9XG5cdHRoZW4oIGNiICkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkIClcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soICgpID0+IGNiKCB1bmRlZmluZWQgKSApXG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5fY2JzLnB1c2goIGNiIClcblx0fVxuXHRpc0Nsb3NlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkXG5cdH1cblx0Y2xvc2UoKSB7XG5cdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZVxuXHRcdHNhZmVFYWNoKCB0aGlzLl9jYnMsIGhhbmRsZXIgPT4gaGFuZGxlciggdW5kZWZpbmVkICkgKVxuXHR9XG5cdHB1c2goIGRhdGEgKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgcXVldWUgaXMgYXJlYWR5IGNsb3NlZGAgKVxuXHRcdHNhZmVFYWNoKCB0aGlzLl9jYnMsIGhhbmRsZXIgPT4gaGFuZGxlciggZGF0YSApIClcblx0fVxuXHRwdXNoY2IoIGRhdGEgKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgcXVldWUgaXMgYXJlYWR5IGNsb3NlZGAgKVxuXHRcdHNhZmVFYWNoKCB0aGlzLl9jYnMsIGhhbmRsZXIgPT4gaGFuZGxlciggZGF0YSgpICkgKVxuXHR9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiR3JlZW5cIjoge1xuXHRcdFwiY2FwdGlvblwiOiB7XG5cdFx0XHRcImVuXCI6IFwiR3JlZW5cIixcblx0XHRcdFwicnVcIjogXCLQl9C10LvRkdC90YvQuVwiLFxuXHRcdFx0XCJieVwiOiBcItCX0Y/Qu9GR0L3Ri1wiXG5cdFx0fSxcblx0XHRcImJhY2tncm91bmRcIjogXCJpbWcvdGhlbWUxLmpwZ1wiLFxuXHRcdFwiZmlsbFwiOiBcIiM0MkEwMDFcIixcblx0XHRcIm9mZlwiOiBcIiM0NTU5MDNcIlxuXHR9LFxuXHRcIkJsdWVcIjoge1xuXHRcdFwiY2FwdGlvblwiOiB7XG5cdFx0XHRcImVuXCI6IFwiQmx1ZVwiLFxuXHRcdFx0XCJydVwiOiBcItCT0L7Qu9GD0LHQvtC5XCIsXG5cdFx0XHRcImJ5XCI6IFwi0JHQu9Cw0LrRltGC0L3Ri1wiXG5cdFx0fSxcblx0XHRcImJhY2tncm91bmRcIjogXCJpbWcvdGhlbWUyLmpwZ1wiLFxuXHRcdFwiZmlsbFwiOiBcIiNFQkY1RjdcIixcblx0XHRcIm9mZlwiOiBcIiM0Qzc3OEZcIlxuXHR9LFxuXHRcIkRhcmtcIjoge1xuXHRcdFwiY2FwdGlvblwiOiB7XG5cdFx0XHRcImVuXCI6IFwiRGFya1wiLFxuXHRcdFx0XCJydVwiOiBcItCi0ZHQvNC90YvQuVwiLFxuXHRcdFx0XCJieVwiOiBcItCm0ZHQvNC90YtcIlxuXHRcdH0sXG5cdFx0XCJiYWNrZ3JvdW5kXCI6IFwiaW1nL3RoZW1lMy5qcGdcIixcblx0XHRcImZpbGxcIjogXCIjNDI1OTUxXCIsXG5cdFx0XCJvZmZcIjogXCIjM0E1MDUyXCJcblx0fVxufVxuIiwiLypcbmJ5IGRlc2lnbjpcbtCd0LUg0YHRgtCy0LDRgNCw0LXQvCDQvdGW0Y/QutGW0YUg0LHRg9GE0LXRgNCw0Z4g0LTQu9GPINC/0LDQtNC30LXQuSAo0L3QsNC60YjRgtCw0LvRgiB0b3VjaG1vdmUg0YbRliBtb3VzZW1vdmUpIC0g0L/QsNC00LfQtdGWINGe0YHRkSDQsNC00L3QviDQsNC70YzQsdC+INCw0L/RgNCw0YbQvtGe0LLQsNGO0YbRhtCwINGF0YPRgtC60LAsINCw0LvRjNCx0L4g0YLQvtC70YzQutGWINC30LDQudC80LDRjtGG0Ywg0LzQtdGB0YbQsCDRniDQsdGD0YTQtdGA0LDRhSDRliDQt9Cw0YLQsNGA0LzQvtC20LLQsNGO0YbRjCDQsNC/0YDQsNGG0L7RntC60YMsINC60LDQu9GWINCw0L/RgNCw0YbQvtGe0YjRh9GL0LrRliDRntGB0ZEg0LYg0L/RgNCw0YfQvdGD0YbRhtCwLlxuKi9cblxuaW1wb3J0IHNwYXJzZXF1ZXVlIGZyb20gXCJzcGFyc2VxdWV1ZVwiXG5cbmxldCB0cmFja3MgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblxuc2V0SW50ZXJ2YWwoICgpID0+IHtcblx0Zm9yICggbGV0IGlkZW50aWZpZXIgaW4gdHJhY2tzICkge1xuXHRcdGxldCB0cmFjayA9IHRyYWNrc1sgaWRlbnRpZmllciBdXG5cdFx0aWYgKCB0cmFjay5hYmFuZG9uZWQgKSB7XG5cdFx0XHQvLyBpZiAoIHRyYWNrLmhhbmRsZXIucmV0dXJuIClcblx0XHRcdC8vIFx0dHJhY2suaGFuZGxlci5yZXR1cm4oKVxuXHRcdFx0Ly8gZGVsZXRlIHRyYWNrc1sgaWRlbnRpZmllciBdXG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHRyYWNrLmFiYW5kb25lZCA9IHRydWVcblx0fVxufSwgNzAwMCApXG5cbmZ1bmN0aW9uIHB1c2hFdmVudCggdHJhY2ssIGV2ZW50ICkge1xuXHR0cmFjay5wb2ludHMucHVzaCggZXZlbnQgKVxuXHRpZiAoIHRyYWNrLnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0IClcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG59XG5cbmZ1bmN0aW9uIHN0b3BFdmVudHMoIHRyYWNrICkge1xuXHR0cmFjay5wb2ludHMuY2xvc2UoKVxufVxuXG5mdW5jdGlvbiBzdGFydFRyYWNrKCBpZGVudGlmaWVyLCBldmVudCApIHtcblx0bGV0IHBvaW50cyA9IG5ldyBzcGFyc2VxdWV1ZSgpXG5cdGxldCBkZXRhaWwgPSB7XG5cdFx0Y2FuY2VsRXZlbnQ6IG51bGwsXG5cdFx0bmV4dDogcG9pbnRzLFxuXHR9XG5cdGxldCB0cmFjayA9IHtcblx0XHRhYmFuZG9uZWQ6IGZhbHNlLFxuXHRcdGNsb3NlZDogZmFsc2UsXG5cdFx0ZGV0YWlsLFxuXHRcdHBvaW50cyxcblx0XHRwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG5cdH1cblx0dHJhY2tzWyBpZGVudGlmaWVyIF0gPSB0cmFja1xuXHRsZXQgcmV0ID0gbmV3IEN1c3RvbUV2ZW50KCBgdG91Y2hgLCB7IGRldGFpbCwgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9IClcblx0cmV0LnBhZ2VYID0gZXZlbnQucGFnZVhcblx0cmV0LnBhZ2VZID0gZXZlbnQucGFnZVlcblx0cmV0LmNsaWVudFggPSBldmVudC5jbGllbnRYXG5cdHJldC5jbGllbnRZID0gZXZlbnQuY2xpZW50WVxuXHRyZXQuc2NyZWVuWCA9IGV2ZW50LnNjcmVlblhcblx0cmV0LnNjcmVlblkgPSBldmVudC5zY3JlZW5ZXG5cdHJldC5wcmV2ZW50RGVmYXVsdCA9ICgpID0+IHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0dHJhY2sucHJldmVudERlZmF1bHQgPSB0cnVlXG5cdH1cblx0ZXZlbnQudGFyZ2V0LmRpc3BhdGNoRXZlbnQoIHJldCApXG5cdHB1c2hFdmVudCggdHJhY2ssIGV2ZW50IClcbn1cblxuZnVuY3Rpb24gb25FeGlzdGluZ1RyYWNrKCBmdW4gKSB7IHJldHVybiAoIGlkZW50aWZpZXIsIGFyZyApID0+IHtcblx0bGV0IHRyYWNrID0gdHJhY2tzWyBpZGVudGlmaWVyIF1cblx0aWYgKCAhdHJhY2sgKVxuXHRcdHJldHVyblxuXHR0cmFjay5hYmFuZG9uZWQgPSBmYWxzZVxuXHRmdW4oIHRyYWNrLCBhcmcgKVxufSB9XG5cbmxldCBjb250aW51ZVRyYWNrID0gb25FeGlzdGluZ1RyYWNrKCBwdXNoRXZlbnQgKVxuXG5sZXQgc3RvcFRyYWNrID0gb25FeGlzdGluZ1RyYWNrKCAoIHRyYWNrLCBldmVudCApID0+IHtcblx0cHVzaEV2ZW50KCB0cmFjaywgZXZlbnQgKVxuXHRzdG9wRXZlbnRzKCB0cmFjayApXG59IClcblxubGV0IHJlbW92ZVRyYWNrID0gb25FeGlzdGluZ1RyYWNrKCBzdG9wRXZlbnRzIClcblxubGV0IGNhbmNlbFRyYWNrID0gb25FeGlzdGluZ1RyYWNrKCAoIHRyYWNrLCBldmVudCApID0+IHtcblx0dHJhY2suZGV0YWlsLmNhbmNlbEV2ZW50ID0gZXZlbnRcblx0c3RvcEV2ZW50cyggdHJhY2sgKVxufSApXG5cbmZ1bmN0aW9uIGZvclRvdWNoZXMoIGV2ZW50LCBjYiApIHtcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyArK2kgKSB7XG5cdFx0bGV0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMuaXRlbSggaSApXG5cdFx0Y2IoIHRvdWNoLmlkZW50aWZpZXIsIHtcblx0XHRcdHR5cGU6IGB0b3VjaG1vdmVgLFxuXHRcdFx0aWRlbnRpZmllcjogdG91Y2guaWRlbnRpZmllcixcblx0XHRcdHRhcmdldDogdG91Y2gudGFyZ2V0LFxuXHRcdFx0c2NyZWVuWDogdG91Y2guc2NyZWVuWCxcblx0XHRcdHNjcmVlblk6IHRvdWNoLnNjcmVlblksXG5cdFx0XHRjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuXHRcdFx0Y2xpZW50WTogdG91Y2guY2xpZW50WSxcblx0XHRcdHBhZ2VYOiB0b3VjaC5wYWdlWCxcblx0XHRcdHBhZ2VZOiB0b3VjaC5wYWdlWSxcblx0XHRcdHJhZGl1c1g6IHRvdWNoLnJhZGl1c1gsXG5cdFx0XHRyYWRpdXNZOiB0b3VjaC5yYWRpdXNZLFxuXHRcdFx0cm90YXRpb25BbmdsZTogdG91Y2gucm90YXRpb25BbmdsZSxcblx0XHRcdGZvcmNlOiB0b3VjaC5mb3JjZSxcblx0XHRcdHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wLFxuXHRcdFx0cHJldmVudERlZmF1bHQ6IDo6ZXZlbnQucHJldmVudERlZmF1bHQsXG5cdFx0fSApXG5cdH1cblx0bGV0IGN1cnJlbnQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7ICsraSApXG5cdFx0Y3VycmVudFsgZXZlbnQudG91Y2hlcy5pdGVtKCBpICkuaWRlbnRpZmllciBdID0gdHJ1ZVxuXHRmb3IgKCBsZXQgaWRlbnRpZmllciBpbiB0cmFja3MgKVxuXHRcdGlmICggISggaWRlbnRpZmllciBpbiBjdXJyZW50ICkgKVxuXHRcdFx0cmVtb3ZlVHJhY2soIGlkZW50aWZpZXIgKVxuXHRcdGVsc2Vcblx0XHRcdHRyYWNrc1sgaWRlbnRpZmllciBdLmFiYW5kb25lZCA9IGZhbHNlXG59XG5cbmxldCBjb250YWluZXIgPSBkb2N1bWVudFxuXG4vLyBmdW5jdGlvbiBvbmV2ZW50KCBldmVudCApIHtcbi8vIFx0Y29uc29sZS5sb2coIGV2ZW50LnR5cGUsIGV2ZW50LnRhcmdldCApXG4vLyB9XG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgbW91c2Vkb3duYCwgZXZlbnQgPT4ge1xuXHQvLyBvbmV2ZW50KCBldmVudCApXG5cdGlmICggZXZlbnQuYnV0dG9uID09IDAgKVxuXHRcdHN0YXJ0VHJhY2soIGBtb3VzZWAsIGV2ZW50IClcblx0ZWxzZSBpZiAoICEoIGV2ZW50LmJ1dHRvbnMgJiAxICkgKVxuXHRcdHJlbW92ZVRyYWNrKCBgbW91c2VgIClcbn0gKVxuXG5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lciggYG1vdXNlbW92ZWAsIGV2ZW50ID0+IHtcblx0Ly8gb25ldmVudCggZXZlbnQgKVxuXHRpZiAoIGV2ZW50LmJ1dHRvbnMgJiAxIClcblx0XHRjb250aW51ZVRyYWNrKCBgbW91c2VgLCBldmVudCApXG5cdGVsc2Vcblx0XHRyZW1vdmVUcmFjayggYG1vdXNlYCApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGBtb3VzZXVwYCwgZXZlbnQgPT4ge1xuXHQvLyBvbmV2ZW50KCBldmVudCApXG5cdGlmICggZXZlbnQuYnV0dG9uID09IDAgKVxuXHRcdHN0b3BUcmFjayggYG1vdXNlYCwgZXZlbnQgKVxuXHRlbHNlIGlmICggISggZXZlbnQuYnV0dG9ucyAmIDEgKSApXG5cdFx0cmVtb3ZlVHJhY2soIGBtb3VzZWAgKVxufSApXG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2hzdGFydGAsIGV2ZW50ID0+IHtcblx0Ly8gb25ldmVudCggZXZlbnQgKVxuXHRmb3JUb3VjaGVzKCBldmVudCwgc3RhcnRUcmFjayApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGB0b3VjaG1vdmVgLCBldmVudCA9PiB7XG5cdC8vIG9uZXZlbnQoIGV2ZW50IClcblx0Zm9yVG91Y2hlcyggZXZlbnQsIGNvbnRpbnVlVHJhY2sgKVxufSApXG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2hlbmRgLCBldmVudCA9PiB7XG5cdC8vIG9uZXZlbnQoIGV2ZW50IClcblx0Zm9yVG91Y2hlcyggZXZlbnQsIHN0b3BUcmFjayApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGB0b3VjaGNhbmNlbGAsIGV2ZW50ID0+IHtcblx0Ly8gb25ldmVudCggZXZlbnQgKVxuXHRmb3JUb3VjaGVzKCBldmVudCwgY2FuY2VsVHJhY2sgKVxufSApXG4iLCJpbXBvcnQgRkNvbW1hbmQgZnJvbSBcInVpL0NvbW1hbmRcIlxuXG5leHBvcnQgZGVmYXVsdCBhcHAgPT4ge1xuXHRsZXQgQ29tbWFuZCA9IGFwcC5sb2FkKCBGQ29tbWFuZCApXG5cdHJldHVybiBhdHRyID0+IDxDb21tYW5kXG5cdFx0bWVzc2FnZSA9IFwiY29tbWFuZEFkZEV4aXN0aW5nSXRlbVwiXG5cdFx0b25jbGljayA9IHsgKCkgPT4ge1xuXHRcdFx0YXBwLmRpYWxvZyA9IGBTZWFyY2hJdGVtc2Bcblx0XHRcdGFwcC5zZWFyY2hBY3Rpb24gPSBpdGVtSWQgPT4ge1xuXHRcdFx0XHRhcHAubGlua0l0ZW0oIGFwcC5hY3RpdmVEZXZpY2VJZCwgaXRlbUlkIClcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHR9XG5cdFx0XHRhcHAuc2VhcmNoRmlsdGVyID0gbnVsbFxuXHRcdFx0aWYgKCBhcHAuZGV2aWNlVHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdFx0YXBwLnNlYXJjaEZpbHRlciA9IGl0ZW1JZCA9PiB7XG5cdFx0XHRcdFx0bGV0IGRldmljZSA9IGFwcC5nZXREZXZpY2UoIGl0ZW1JZCApXG5cdFx0XHRcdFx0cmV0dXJuIGRldmljZSAmJiBkZXZpY2UudHlwZSA9PSBgc2luZ2xlYFxuXHRcdFx0XHR9XG5cdFx0fSB9XG5cdFx0XyA9IHsgYXR0ciB9XG5cdC8+XG59XG4iLCJpbXBvcnQgRk1lbnUgZnJvbSBcInVpL01lbnVcIlxuaW1wb3J0IEZDb21tYW5kIGZyb20gXCJ1aS9Db21tYW5kXCJcbmltcG9ydCBGQWRkRXhpc3RpbmdJdGVtIGZyb20gXCJ1aS9BZGRFeGlzdGluZ0l0ZW1cIlxuXG5leHBvcnQgZGVmYXVsdCBhcHAgPT4ge1xuXHRsZXQgTWVudSA9IGFwcC5sb2FkKCBGTWVudSApXG5cdGxldCBDb21tYW5kID0gYXBwLmxvYWQoIEZDb21tYW5kIClcblx0bGV0IEFkZEV4aXN0aW5nSXRlbSA9IGFwcC5sb2FkKCBGQWRkRXhpc3RpbmdJdGVtIClcblx0cmV0dXJuIDxNZW51PlxuXHRcdDxBZGRFeGlzdGluZ0l0ZW0gLz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZENyZWF0ZU5ld0dyb3VwXCJcblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IHsgYXBwLmFkZEdyb3VwKCBhcHAuYWN0aXZlRGV2aWNlSWQgKSB9IH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkTmV3RGV2aWNlXCJcblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IGFwcC5hZGREZXZpY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCApIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkUGxhY2VcIlxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4ge1xuXHRcdFx0XHQvLyBhcHAuZGlhbG9nID0gYEFkZFBsYWNlYFxuXHRcdFx0XHRhcHAuYWRkUGxhY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCApXG5cdFx0XHR9IH1cblx0XHQvPlxuXHQ8L01lbnU+XG59XG4iLCJpbXBvcnQgcmEgZnJvbSBcInJhXCJcbmltcG9ydCAqIGFzIGx1IGZyb20gXCJsb2NhbFV0aWxzXCJcbmltcG9ydCBBcHAgZnJvbSBcImFwcFwiXG5pbXBvcnQgRk1haW5TY3JlZW4gZnJvbSBcInVpL01haW5TY3JlZW5cIlxuaW1wb3J0IEZTdGFydHVwU2NyZWVuIGZyb20gXCJ1aS9TdGFydHVwU2NyZWVuXCJcbmltcG9ydCBGQmFja2dyb3VuZCBmcm9tIFwidWkvQmFja2dyb3VuZFwiXG5pbXBvcnQgRlRvcCBmcm9tIFwidWkvVG9wXCJcbmltcG9ydCBGQm90dG9tIGZyb20gXCJ1aS9Cb3R0b21cIlxuaW1wb3J0IEZCdXR0b24gZnJvbSBcInVpL0J1dHRvblwiXG5cbmV4cG9ydCBkZWZhdWx0ICggeyBhcHBpZCA9IGBzdGF0ZWAsIEljb25UZW1wbGF0ZXMgfSApID0+IHtcblxuXHRsZXQgeyBhcHAsIGxvY2FsIH0gPSBBcHAoIGFwcGlkIClcblx0YXBwLnBhZ2VTdGFydGluZyA9IHRydWVcblxuXHRsZXQgTWFpblNjcmVlbiA9IGFwcC5sb2FkKCBGTWFpblNjcmVlbiApXG5cdGxldCBTdGFydHVwU2NyZWVuID0gYXBwLmxvYWQoIEZTdGFydHVwU2NyZWVuIClcblx0bGV0IEJhY2tncm91bmQgPSBhcHAubG9hZCggRkJhY2tncm91bmQgKVxuXHRsZXQgVG9wID0gYXBwLmxvYWQoIEZUb3AgKVxuXHRsZXQgQm90dG9tID0gYXBwLmxvYWQoIEZCb3R0b20gKVxuXHRsZXQgQnV0dG9uID0gYXBwLmxvYWQoIEZCdXR0b24gKVxuXG5cdHdpbmRvdy5fYXBwID0gYXBwXG5cdHdpbmRvdy5fbG9jYWwgPSBsb2NhbFxuXG5cdGlmICggbmF2aWdhdG9yLnN0YW5kYWxvbmUgKSB7XG5cdFx0Ly8gY29va2llcy5zZXRJdGVtKCBgc3RhbmRhbG9uZWAsIDEsIEluZmluaXR5ICkgLS0g0YPRgdGRINCw0LTQvdC+INC90LUg0L/QsNGB0YzQv9GP0LLQsNC10Lwg0L/QsNGB0YLQsNCy0ZbRhtGMINC60YPQutGDINC/0LXRgNCw0LQg0L/QtdGA0YjRi9C8INC30LLQsNGA0L7RgtCw0Lwg0LTQsCDRgdC10YDQstC10YDQsFxuXHR9XG5cdGVsc2Uge1xuXHRcdHJhKCAoKSA9PiB7XG5cdFx0XHRpZiAoIGxvY2FsLmFjdGl2ZURldmljZUlkICYmIGxvY2FsLmFjdGl2ZURldmljZUlkLnZhbHVlT2YoKSApIHtcblx0XHRcdFx0bGV0IHRpdGxlID0gYFRJVExFXyR7IGxvY2FsLmFjdGl2ZURldmljZUlkIH1gXG5cdFx0XHRcdGxldCBpY29uID0gYElDT05fJHsgbG9jYWwuYWN0aXZlRGV2aWNlSWQgfWBcblx0XHRcdFx0Z2xvYmFsLnNjcmVlblRpdGxlLnNldEF0dHJpYnV0ZSggYGNvbnRlbnRgLCB0aXRsZSApXG5cdFx0XHRcdGlmICggbG9jYWwuYWN0aXZlRGV2aWNlSWQgJiYgbG9jYWwuYWN0aXZlRGV2aWNlSWQgIT0gYG1haW5gIClcblx0XHRcdFx0XHRoaXN0b3J5LnJlcGxhY2VTdGF0ZSggbnVsbCwgdGl0bGUsIGA/YXBwaWNvbj0keyBpY29uIH1gKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUoIG51bGwsIHRpdGxlLCBgP2ApXG5cdFx0XHRcdC8vIGh0dHBDbGllbnQucG9zdCggYC9jb29raWU/YXBwaWNvbj0keyBpY29uIH1gLCBgYCApXG5cdFx0XHRcdC8vIGNvb2tpZXMuc2V0SXRlbSggYGFwcGljb25gLCBpY29uLCBJbmZpbml0eSApXG5cdFx0XHRcdC8vIExPRyggbG9jYWwuYWN0aXZlRGV2aWNlSWQuYmx1ZSApXG5cdFx0XHR9XG5cdFx0fSApXG5cdH1cblxuXHRsZXQgZGlhbG9nQ29udGFpbmVyID0gPGRpdiBjbGFzcyA9IFwiZGlhbG9ncyB1bmRlcl90b3AgYWJvdmVfYm90dG9tXCIgPlxuXHRcdDxkaXYgY2xhc3MgPSBcImJhY2tncm91bmQgYXBwX2NvbnRlbnRfYmFja2dyb3VuZFwiID5cblx0XHQ8ZGl2IGNsYXNzID0gXCJiYWNrZ3JvdW5kIGJhY2tpbmdfc2l6ZWRfYmFja2dyb3VuZFwiID5cblx0XHQ8ZGl2IGNsYXNzID0gXCJiYWNrZ3JvdW5kIHVuZGVyX3RvcF9iYWNrZ3JvdW5kXCIgPlxuXHRcdDxkaXYgY2xhc3MgPSBcImJhY2tncm91bmQgYWJvdmVfYm90dG9tX2JhY2tncm91bmRcIiA+XG5cdFx0XHQ8QmFja2dyb3VuZCAvPlxuXHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cblxuXHRsZXQgYXBwbGljYXRpb24gPSA8ZGl2IGNsYXNzID0geyAoKSA9PiBgXG5cdFx0YXBwbGljYXRpb25cblx0XHQkeyBhcHAucGFnZVN0YXJ0aW5nID8gYHBhZ2VTdGFydGluZ2AgOiBgcGFnZVJ1bm5pbmdgIH1cblx0XHQkeyBhcHAuaW5pdGlhbExvYWRpbmcgPyBgSlNPTmxvYWRpbmdgIDogYEpTT05sb2FkZWRgIH1cblx0XHQkeyBhcHAuaW5pdGlhbGl6ZWQgPyBgYWxyZWFkeVJ1bmAgOiBgZmlyc3RSdW5gIH1cblx0XHQkeyBhcHAuY29ubmVjdGVkVG9TZXJ2ZXIgPyBgYXBwQ29ubmVjdGVkYCA6IGBhcHBEaXNjb25uZWN0ZWRgIH1cblx0XHQkeyBgYCAvKiBhcHAuY3JlZGVudGlhbHMgPT0gbnVsbCA/IGBzaG93TG9naW5gIDogYGhpZGVMb2dpbmAgKi8gfVxuXHRcdCR7IGFwcC50ZW1wbGF0ZXMgPyBgdGVtcGxhdGVzTG9hZGVkYCA6IGB0ZW1wbGF0ZXNMb2FkaW5nYCB9XG5cdFx0JHsgYXBwLmRpYWxvZyAmJiBgZGlhbG9nJHsgYXBwLmRpYWxvZyB9YCB9XG5cdFx0JHsgYXBwLmRpYWxvZyA/IGBkaWFsb2dJc1ByZXNlbnRgIDogYGRpYWxvZ0lzQWJzZW50YCB9XG5cdFx0YXBwX2xhYmVsc18keyAhIWxvY2FsLmxhYmVscyB9XG5cdFx0YXBwX2VkaXRpbmdfJHsgISFhcHAuZWRpdGluZyB9XG5cdFx0bGF5b3V0XyR7IGx1LnZhbHVlT2YoIGFwcC53aW5kb3dTaXplICkgJiYgbHUudmFsdWVPZiggYXBwLndpbmRvd1NpemUgKS5sYXlvdXQgfVxuXHRcdHdpbmRvd18keyBsdS52YWx1ZU9mKCBhcHAud2luZG93U2l6ZSApICYmIGx1LnZhbHVlT2YoIGFwcC53aW5kb3dTaXplICkud2luZG93IH1cblx0XHR0aGVtZSR7IGFwcC50aGVtZU5hbWUgfVxuXHRgIH0gPlxuXHRcdHsvKlxuXG5cdFx00JzRjdGC0LAg0YDQsNC30YzQvNC10YLQutGWIC0g0L/QsNC30LHQsNCy0ZbRhtGG0LAg0LfRjNC90ZbQutC90LXQvdGM0L3Rjy/Qt9GM0Y/RntC70LXQvdGM0L3RjyDQv9GA0LDQt9GA0YvRgdGC0YvRhSDRjdC70LXQvNC10L3RgtCw0Z4g0L/QsNC00YfQsNGBIHJlZmxvdywg0YLQviDQsdC+0Lpcblx0XHTQv9GA0LDQt9GA0YvRgdGC0YvRjyDRjdC70LXQvNC10L3RgtGLINC/0LDQstGW0L3QvdGL0Y8g0LfRjNGP0Z7Qu9GP0YbRhtCwL9C30YzQvdGW0LrQsNGG0Ywg0YLQvtC70YzQutGWINGA0LDQt9Cw0Lwg0Lcg0L3QtdC/0YDQsNC30YDRi9GB0YLQsNC5INC/0LDQtNC70L7QttC60LDQuS5cblxuXHRcdCovfVxuXHRcdDxCYWNrZ3JvdW5kIC8+XG5cdFx0PGRpdiBjbGFzcyA9IFwiYXBwX2NvbnRlbnRcIiA+XG5cdFx0XHQ8ZGl2IGNsYXNzID0gXCJiYWNraW5nX3NpemVkXCIgPlxuXHRcdFx0XHQ8VG9wIC8+XG5cdFx0XHRcdDxCb3R0b20gLz5cblx0XHRcdFx0PE1haW5TY3JlZW4gLz5cblx0XHRcdFx0eyBkaWFsb2dDb250YWluZXIgfVxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdFx0PFN0YXJ0dXBTY3JlZW4gLz5cblx0XHQ8ZGl2IGNsYXNzID0gXCJsb2FkaW5nU2NyZWVuXCIgPjwvZGl2PlxuXHQ8L2Rpdj5cblxuXHRhcHAuaWNvbnMgPSBJY29uVGVtcGxhdGVzLnJlZHVjZSggKCBpY29ucywgdGVtcGxhdGUgKSA9PiB7XG5cdFx0aWNvbnNbIHRlbXBsYXRlLmRhdGFzZXQubmFtZSBdID0gdGVtcGxhdGVcblx0XHRyZXR1cm4gaWNvbnNcblx0fSwgT2JqZWN0LmNyZWF0ZSggbnVsbCApIClcblxuXHRsZXQgQ2xvc2VFcnJvciA9ICggYXR0ciwgdGV4dCApID0+IHtcblx0XHRyZXR1cm4gPHBcblx0XHRcdG9udG91Y2ggPSB7ICgpID0+IHtcblx0XHRcdFx0bGV0IGVycm9yID0gYXBwLmVycm9yXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0XHRhcHAuZXJyb3IgPSBudWxsXG5cdFx0XHRcdGF0dHIub25jbGljayAmJiBhdHRyLm9uY2xpY2soIGVycm9yIClcblx0XHRcdH0gfVxuXHRcdFx0XyA9IHsgT2JqZWN0LmFzc2lnbigge30sIGF0dHIsIHsgb25jbGljazogbnVsbCB9ICkgfVxuXHRcdD57IHRleHQgfTwvcD5cblx0fVxuXG5cdGxldCBDbG9zZURpYWxvZyA9ICggYXR0ciwgdGV4dCApID0+IHtcblx0XHRyZXR1cm4gPHBcblx0XHRcdG9udG91Y2ggPSB7ICgpID0+IHtcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRcdGF0dHIub25jbGljayAmJiBhdHRyLm9uY2xpY2soKVxuXHRcdFx0fSB9XG5cdFx0XHRfID0geyBPYmplY3QuYXNzaWduKCB7fSwgYXR0ciwgeyBvbmNsaWNrOiBudWxsIH0gKSB9XG5cdFx0PnsgdGV4dCB9PC9wPlxuXHR9XG5cblx0Ly8gZGlhbG9nc1xuXHRsZXQgZGlhbG9nVGVtcGxhdGVzID0ge1xuXG5cdFx0U2VydmljZURpYWxvZzogKCkgPT4gU3lzdGVtLmltcG9ydCggYHVpL1NlcnZpY2VEaWFsb2dgICk6OmFwcC5sb2FkKCksXG5cdFx0Q29udGV4dE1lbnU6ICgpID0+IFN5c3RlbS5pbXBvcnQoIGB1aS9Db250ZXh0TWVudWAgKTo6YXBwLmxvYWQoKSxcblx0XHRBZGRNZW51OiAoKSA9PiBTeXN0ZW0uaW1wb3J0KCBgdWkvQWRkTWVudWAgKTo6YXBwLmxvYWQoKSxcblx0XHRUaGVtZU1lbnU6ICgpID0+IFN5c3RlbS5pbXBvcnQoIGB1aS9UaGVtZU1lbnVgICk6OmFwcC5sb2FkKCksXG5cdFx0U2VhcmNoSXRlbXM6ICgpID0+IFN5c3RlbS5pbXBvcnQoIGB1aS9TZWFyY2hJdGVtc2AgKTo6YXBwLmxvYWQoKSxcblx0XHRTZWFyY2hQaWN0dXJlczogKCkgPT4gU3lzdGVtLmltcG9ydCggYHVpL1NlYXJjaFBpY3R1cmVzYCApOjphcHAubG9hZCgpLFxuXHRcdEFza05ld05hbWU6ICgpID0+IFN5c3RlbS5pbXBvcnQoIGB1aS9Bc2tOZXdOYW1lYCApOjphcHAubG9hZCgpLFxuXHRcdEFza1RvTGlua0RldmljZTogKCkgPT4gU3lzdGVtLmltcG9ydCggYHVpL0Fza1RvTGlua0RldmljZWAgKTo6YXBwLmxvYWQoKSxcblxuXHRcdEFza0lmRGV2aWNlSGFzQmVlbkxpbmtlZDogKCkgPT4gPGRpdj5cblx0XHRcdDxwPtCj0YHRgtGA0L7QudGB0YLQstC+INCx0YvQu9C+INGD0YHQv9C10YjQvdC+INC/0YDQuNCy0Y/Qt9Cw0L3Qvj88L3A+XG5cdFx0XHQ8QnV0dG9uIG9uY2xpY2sgPSBcIlN0b3BEZXZpY2VOb3RpZmljYXRpb25cIiA+0LTQsDwvQnV0dG9uPlxuXHRcdFx0PEJ1dHRvbiBvbmNsaWNrID0gXCJBc2tUb0xpbmtEZXZpY2VcIiA+0L3QtdGCPC9CdXR0b24+XG5cdFx0PC9kaXY+LFxuXG5cdFx0U3RvcERldmljZU5vdGlmaWNhdGlvbjogKCkgPT4gPGRpdj5cblx0XHRcdDxwPtCf0L7QttCw0LvRg9C50YHRgtCwLDxici8+0L/QtdGA0LXQstC10LTQuNGC0LUg0YPRgdGC0YDQvtC50YHRgtCy0L4g0LIg0YDQsNCx0L7Rh9C40Lkg0YDQtdC20LjQvC48L3A+XG5cdFx0XHQ8QnV0dG9uPtCX0LDQutGA0YvRgtGMPC9CdXR0b24+XG5cdFx0PC9kaXY+LFxuXG5cdFx0RXJyb3JOb0NhcnJpZXI6ICgpID0+IDxkaXYgY2xhc3MgPSBcImVycm9yRGlhbG9nXCIgPlxuXHRcdFx0PHA+0J7RiNC40LHQutCwPC9wPlxuXHRcdFx0PHA+0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsCDQv9GA0Lgg0L/QvtC/0YvRgtC60LUg0YHQstGP0LfQsNGC0YzRgdGPINGBINC80L7QtNC10LzQvtC8LjwvcD5cblx0XHRcdDxCdXR0b24+0JfQsNC60YDRi9GC0Yw8L0J1dHRvbj5cblx0XHQ8L2Rpdj4sXG5cblx0XHRFcnJvclVubGlua2luZ0RldmljZTogKCkgPT4gPGRpdiBjbGFzcyA9IFwiZXJyb3JEaWFsb2dcIiA+XG5cdFx0XHQ8cD7QntGI0LjQsdC60LA8L3A+XG5cdFx0XHQ8cD7QndC1INGD0LTQsNC70L7RgdGMINGB0LLRj9C30LDRgtGM0YHRjyDRgSDRg9GB0YLRgNC+0LnRgdGC0LLQvtC8INC4INC+0YLQstGP0LfQsNGC0Ywg0LXQs9C+LjwvcD5cblx0XHRcdDxwPtCn0YLQviDRgdC70LXQtNGD0LXRgiDRgdC00LXQu9Cw0YLRjD88L3A+XG5cdFx0XHQ8dWw+XG5cdFx0XHQ8Q2xvc2VFcnJvciBvbmNsaWNrID0geyBlcnJvciA9PiBhcHAucHVyZ2VJdGVtKCBlcnJvci5kYXRhLmRldmljZUlkICkgfVxuXHRcdFx0XHQ+PGxpPtCf0L7Qv9GL0YLQsNGC0YzRgdGPINC+0YLQstGP0LfQsNGC0Ywg0YPRgdGC0YDQvtC50YHRgtCy0L4g0LXRidGRINGA0LDQtzwvbGk+PC9DbG9zZUVycm9yPlxuXHRcdFx0PENsb3NlRXJyb3Jcblx0XHRcdFx0PjxsaT7QntGC0LzQtdC90LjRgtGMINGD0LTQsNC70LXQvdC40LU8L2xpPjwvQ2xvc2VFcnJvcj5cblx0XHRcdDxDbG9zZUVycm9yIG9uY2xpY2sgPSB7IGVycm9yID0+IGFwcC5wdXJnZUl0ZW0oIGVycm9yLmRhdGEuZGV2aWNlSWQsIHRydWUgKSB9XG5cdFx0XHRcdD48bGk+0JfQsNCx0YvRgtGMINC40L3RhNC+0YDQvNCw0YbQuNGOINC+0LEg0YPRgdGC0YDQvtC50YHRgtCy0LU8L2xpPjwvQ2xvc2VFcnJvcj5cblx0XHRcdDwvdWw+XG5cdFx0PC9kaXY+LFxuXG5cdFx0RGVsZXRlRGV2aWNlOiAoKSA9PiA8ZGl2PlxuXHRcdFx0PHA+eyAoIHtcblx0XHRcdFx0cGxhY2U6IDxzcGFuPtCf0L7QvNC10YnQtdC90LjQtSAo0LzQtdGB0YLQvikgXCJ7IGFwcC5jYXB0aW9uIH1cIiDQsdGD0LTQtdGCINGD0LTQsNC70LXQvdC+INC40Lcg0L/RgNC+0LPRgNCw0LzQvNGLLjwvc3Bhbj4sXG5cdFx0XHRcdHNpbmdsZTogPHNwYW4+0KPRgdGC0YDQvtC50YHRgtCy0L4gXCJ7IGFwcC5jYXB0aW9uIH1cIiDQsdGD0LTQtdGCINGD0LTQsNC70LXQvdC+INC40Lcg0L/RgNC+0LPRgNCw0LzQvNGLLjwvc3Bhbj4sXG5cdFx0XHRcdGdyb3VwOiA8c3Bhbj7Qk9GA0YPQv9C/0LAgXCJ7IGFwcC5jYXB0aW9uIH1cIiDQsdGD0LTQtdGCINGD0LTQsNC70LXQvdCwINC40Lcg0L/RgNC+0LPRgNCw0LzQvNGLLjwvc3Bhbj4sXG5cdFx0XHR9IClbIGFwcC5kZXZpY2VUeXBlIF0gfTwvcD5cblx0XHRcdDx1bD5cblx0XHRcdDxDbG9zZURpYWxvZyBjbGFzcyA9IFwiZGFuZ2Vyb3VzQWN0aW9uXCIgb25jbGljayA9IHsgKCkgPT4gYXBwLnB1cmdlSXRlbSggYXBwLmFjdGl2ZURldmljZUlkICkgfVxuXHRcdFx0XHQ+PGxpPtCj0LTQsNC70LjRgtGMPC9saT48L0Nsb3NlRGlhbG9nPlxuXHRcdFx0PENsb3NlRGlhbG9nXG5cdFx0XHRcdD48bGk+0J3QtSDRg9C00LDQu9GP0YLRjDwvbGk+PC9DbG9zZURpYWxvZz5cblx0XHRcdDwvdWw+XG5cdFx0PC9kaXY+LFxuXG5cdFx0U3RhdGVXYWl0OiAoKSA9PiA8ZGl2PlxuXHRcdFx0PHA+0J/QvtC00L7QttC00LjRgtC1Li4uPC9wPlxuXHRcdDwvZGl2PixcblxuXHRcdEFza1RvUmVzZXQ6ICgpID0+IDxkaXY+XG5cdFx0XHQ8cD7Qn9Cw0LzRj9GC0Ywg0LrQvtC90YLRgNC+0LvQu9C10YDQsCDQsdGD0LTQtdGCINC+0YfQuNGJ0LXQvdCwLDxici8+0L3QviDQv9Cw0LzRj9GC0Ywg0YPRgdGC0YDQvtC50YHRgtCyINC+0YfQuNGJ0LDRgtGM0YHRjyDQvdC1INCx0YPQtNC10YIuPC9wPlxuXHRcdFx0PEJ1dHRvbiBjbGFzcyA9IFwiZGFuZ2Vyb3VzQWN0aW9uXCIgb25jbGljayA9IHsgYXBwLnJlc2V0IH0gPtCe0YfQuNGB0YLQuNGC0Yw8YnIvPtC/0LDQvNGP0YLRjDwvQnV0dG9uPlxuXHRcdDwvZGl2PixcblxuXHRcdC8vIEFkZFBsYWNlLFxuXHRcdC8vIEFkZERldmljZSxcblx0fVxuXG5cdHJhKCBmdW5jdGlvbiogKCkge1xuXHRcdGxldCBkaWFsb2dOYW1lID0gYXBwLmRpYWxvZ1xuXHRcdGlmICggIWRpYWxvZ05hbWUgKVxuXHRcdFx0cmV0dXJuXG5cblx0XHRpZiAoICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRpYWxvZ1RlbXBsYXRlcywgZGlhbG9nTmFtZSApICkge1xuXHRcdFx0YWxlcnQoIGBFcnJvcjogQ291bGQgbm90IGZpbmQgZGlhbG9nIG5hbWVkXFxuXCIkeyBkaWFsb2dOYW1lIH1cImAgKVxuXHRcdFx0cmEuZGV0YWNoKCAoKSA9PiBhcHAuZGlhbG9nID0gYGAgKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGxldCBUZW1wbGF0ZSA9IGRpYWxvZ1RlbXBsYXRlc1sgZGlhbG9nTmFtZSBdXG5cdFx0aWYgKCAhVGVtcGxhdGUgKVxuXHRcdFx0cmV0dXJuXG5cdFx0ZGlhbG9nVGVtcGxhdGVzWyBkaWFsb2dOYW1lIF0gPSBudWxsXG5cblx0XHRsZXQgY29udHJvbCA9IFRlbXBsYXRlKClcblx0XHRpZiAoIHR5cGVvZiBjb250cm9sLnRoZW4gPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRjb250cm9sID0geWllbGQgY29udHJvbFxuXG5cdFx0bGV0IHN0YXRlID0gcmEoIHtcblx0XHRcdGdldCBpc0FjdGl2ZSgpIHsgcmV0dXJuIGRpYWxvZ05hbWUgPT0gYXBwLmRpYWxvZyB9LFxuXHRcdFx0X3RpbWVyOiBudWxsLFxuXHRcdFx0X2FjdGl2ZVN0YXRlOiBmYWxzZSxcblx0XHRcdGdldCBfYWN0aXZlQ2hhbmdlZCgpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLl90aW1lciApXG5cdFx0XHRcdHRoaXMuX3RpbWVyID0gbnVsbFxuXHRcdFx0XHRpZiAoIHRoaXMuaXNBY3RpdmUgKVxuXHRcdFx0XHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCggKCkgPT4gdGhpcy5fYWN0aXZlU3RhdGUgPSB0cnVlIClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZVN0YXRlID0gZmFsc2Vcblx0XHRcdH0sXG5cdFx0XHRnZXQgX2FjdGl2ZVN0YXRlQ2hhbmdlZCgpIHtcblx0XHRcdFx0aWYgKCB0aGlzLl9hY3RpdmVTdGF0ZSApIHtcblx0XHRcdFx0XHRsZXQgaW5wdXQgPSBjb250cm9sLnF1ZXJ5U2VsZWN0b3IoIGAqWyBhdXRvZm9jdXMgXWAgKVxuXHRcdFx0XHRcdGlmICggaW5wdXQgKVxuXHRcdFx0XHRcdFx0YXBwLmZvY3VzKCBpbnB1dCApXG5cdFx0XHRcdFx0Y29udHJvbC5kaXNwYXRjaEV2ZW50KCBuZXcgQ3VzdG9tRXZlbnQoIGBkaWFsb2dzaG93YCwgeyBkZXRhaWw6IG51bGwgfSApIClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRmb3IgKCBsZXQgZWxlbSBvZiBjb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoIGAqOmZvY3VzYCApIClcblx0XHRcdFx0XHRcdGVsZW0uYmx1cigpXG5cdFx0XHRcdFx0ZGlhbG9nLmJsdXIoKVxuXHRcdFx0XHRcdGNvbnRyb2wuZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KCBgZGlhbG9naGlkZWAsIHsgZGV0YWlsOiBudWxsIH0gKSApXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSApXG5cblx0XHRsZXQgZGlhbG9nID0gPGRpdiBjbGFzcyA9IHsgKCkgPT4gYFxuXHRcdFx0bW9kYWxEaWFsb2dcblx0XHRcdCR7IGRpYWxvZ05hbWUgfVxuXHRcdFx0JHsgc3RhdGUuaXNBY3RpdmUgPyBgZGlhbG9nU2hvd25gIDogYGRpYWxvZ0hpZGRlbmAgfVxuXHRcdGAgfSA+eyBjb250cm9sIH08L2Rpdj5cblx0XHRkaWFsb2dDb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpYWxvZyApXG5cdH0gKVxuXG5cdHNldFRpbWVvdXQoICgpID0+IGFwcC5wYWdlU3RhcnRpbmcgPSBmYWxzZSwgMSApXG5cblx0cmV0dXJuIGFwcGxpY2F0aW9uXG59XG4iLCJpbXBvcnQgKiBhcyBodG1sdXRpbHMgZnJvbSBcImh0bWx1dGlsc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGFwcCA9PiB7XG5cdGxldCAkID0ge31cblx0cmV0dXJuIDxkaXYgb25kaWFsb2dzaG93ID0geyAoKSA9PiB7XG5cdFx0JC5zdHJpbmcudmFsdWUgPSBhcHAuZ2V0TWVzc2FnZSggYXBwLmdldERldmljZSggYXBwLmFjdGl2ZURldmljZUlkICkgKVxuXHRcdCQuc3RyaW5nLnNldFNlbGVjdGlvblJhbmdlKCAwLCAkLnN0cmluZy52YWx1ZS5sZW5ndGggKVxuXHR9IH0gPlxuXHRcdDxwPtCd0LDQt9Cy0LDQvdC40LU6PC9wPlxuXHRcdDxmb3JtIG9uc3VibWl0ID0geyBldmVudCA9PiB7XG5cdFx0XHRldmVudCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRsZXQgbmFtZSA9ICQuc3RyaW5nLnZhbHVlLnRyaW0oKVxuXHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRpZiAoIG5hbWUgKVxuXHRcdFx0XHRhcHAucmVuYW1lSXRlbSggYXBwLmFjdGl2ZURldmljZUlkLCBuYW1lIClcblx0XHR9IH0gPlxuXHRcdFx0eyAkLnN0cmluZyA9IDx0ZXh0YXJlYSBuYW1lID0gXCJzdHJpbmdcIiBjb2xzID0gXCIzNVwiIHJvd3MgPSBcIjJcIiBhdXRvZm9jdXMgPSBcImF1dG9mb2N1c1wiIC8+IH1cblx0XHRcdDxwPjxhIGNsYXNzID0gXCJidXR0b25cIiBocmVmID0gXCJqYXZhc2NyaXB0OnZvaWQoMClcIiB0YXJnZXQgPSBcIl9zZWxmXCIgb250b3VjaCA9IHsgaHRtbHV0aWxzLlN1Ym1pdCB9ID7Ql9Cw0LrRgNGL0YLRjDwvYT48L3A+XG5cdFx0PC9mb3JtPlxuXHQ8L2Rpdj5cbn1cbiIsImltcG9ydCAqIGFzIGNvIGZyb20gXCJjb1wiXG5pbXBvcnQgRkJ1dHRvbiBmcm9tIFwidWkvQnV0dG9uXCJcblxuZXhwb3J0IGRlZmF1bHQgYXBwID0+IHtcblx0bGV0IEJ1dHRvbiA9IGFwcC5sb2FkKCBGQnV0dG9uIClcblx0cmV0dXJuIDxkaXY+XG5cdFx0PHA+0J/QvtC20LDQu9GD0LnRgdGC0LAsPGJyLz7Qv9C10YDQtdCy0LXQtNC40YLQtSDRg9GB0YLRgNC+0LnRgdGC0LLQviDQsiDRgNC10LbQuNC8PGJyLz7Qv9GA0L7Qs9GA0LDQvNC80LjRgNC+0LLQsNC90LjRjyDQuCDQvdCw0LbQvNC40YLQtTwvcD5cblx0XHQ8QnV0dG9uIG9uY2xpY2sgPSB7ICgpID0+IHtcblx0XHRcdGxldCBwbGFjZUlkID0gYXBwLmxpbmtpbmdQbGFjZUlkIHx8IGFwcC5hY3RpdmVEZXZpY2VJZFxuXHRcdFx0YXBwLmRpYWxvZyA9IGBTdGF0ZVdhaXRgXG5cdFx0XHRjby5nbyggZnVuY3Rpb24qICgpIHtcblx0XHRcdFx0eWllbGQgYXBwLmNvbW1hbmQoIHBsYWNlSWQsIGBMaW5rYCApXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgQXNrSWZEZXZpY2VIYXNCZWVuTGlua2VkYFxuXHRcdFx0XHRhcHAubGlua2luZ1BsYWNlSWQgPSBwbGFjZUlkXG5cdFx0XHR9ICkuY2F0Y2goIGVycm9yID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coIGVycm9yIClcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBFcnJvck5vQ2FycmllcmBcblx0XHRcdH0gKVxuXHRcdH0gfVxuXHRcdD7Qt9C00LXRgdGMPC9CdXR0b24+XG5cdDwvZGl2PlxufVxuIiwiaW1wb3J0ICogYXMgY3MgZnJvbSBcImNvbG9yLXN0cmluZ1wiXG5cbmV4cG9ydCBkZWZhdWx0IGFwcCA9PiAoKSA9PiA8ZGl2IHN0eWxlID0gXCJcblx0cG9zaXRpb246IGFic29sdXRlO1xuXHRsZWZ0OiAwO1xuXHR0b3A6IDA7XG5cdHJpZ2h0OiAwO1xuXHRib3R0b206IDA7XG5cdHRyYW5zZm9ybTogc2NhbGUoIDEsIC0xICk7XG5cIiA+XG5cdDxpbWcgc3JjID0geyAoKSA9PiBhcHAudGhlbWUuYmFja2dyb3VuZCB9IHN0eWxlID0gXCJcblx0XHR3aWR0aDogMTAwJTtcblx0XHR0cmFuc2Zvcm06IHNjYWxlKCAxLCAtMSApO1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XCIgLz5cblx0PGRpdiBzdHlsZSA9IHsgKCkgPT4gYFxuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRtaW4taGVpZ2h0OiAxMGNtO1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlKCAwLCAtM2NtICk7XG5cdFx0YmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KCB0byBib3R0b20sICR7IGNzLnJnYlN0cmluZyggY3MuZ2V0UmdiKCBhcHAudGhlbWUuZmlsbCApLCAwICkgfSwgJHsgY3MucmdiU3RyaW5nKCBjcy5nZXRSZ2IoIGFwcC50aGVtZS5maWxsICksIDEgKSB9IDNjbSApO1xuXHRgIH0gLz5cbjwvZGl2PlxuIiwiaW1wb3J0ICogYXMgaHRtbHV0aWxzIGZyb20gXCJodG1sdXRpbHNcIlxuXG5leHBvcnQgZGVmYXVsdCBhcHAgPT4gKCkgPT4gPGRpdiBjbGFzcyA9IFwiYm90dG9tXCIgPlxuXHQ8ZGl2IGNsYXNzID0gXCJoZWxwXCJcblx0XHQvLyBvbnByZXNzID0geyAoKSA9PiBhcHAuZGlhbG9nID0gYFNlcnZpY2VEaWFsb2dgIH1cblx0XHRvbnByZXNzID0geyAoKSA9PiB7XG5cdFx0XHRsZXQgdGV4dCA9IGBgXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdHRleHQgKz0gbG9jYWxTdG9yYWdlLmtleSggaSApXG5cdFx0XHRcdHRleHQgKz0gYFxcbmBcblx0XHRcdH1cblx0XHRcdGFsZXJ0KCB0ZXh0IClcblx0XHR9IH1cblx0XHQvLyBvbnRhcCA9IHsgZnVuY3Rpb24gKCkge1xuXHRcdC8vIFx0bGV0IGMgPSB0aGlzXG5cdFx0Ly8gXHRsZXQgcmV0ID0gW11cblx0XHQvLyBcdHdoaWxlICggYyApIHtcblx0XHQvLyBcdFx0bGV0IG4gPSBjLmNsYXNzTmFtZVxuXHRcdC8vIFx0XHRpZiAoIG4gKSB7XG5cdFx0Ly8gXHRcdFx0biA9IG4udHJpbSgpLnNwbGl0KCAvXFxzKy8gKVxuXHRcdC8vIFx0XHRcdGlmICggblsgMCBdIClcblx0XHQvLyBcdFx0XHRcdHJldC5wdXNoKCBuIClcblx0XHQvLyBcdFx0fVxuXHRcdC8vIFx0XHRjID0gYy5wYXJlbnROb2RlXG5cdFx0Ly8gXHR9XG5cdFx0Ly8gXHRhbGVydCggcmV0LnJldmVyc2UoKS5tYXAoICggbiwgaSApID0+IG4ubWFwKCBjID0+IGAkeyBpICsgMSB9IC4keyBjIH1gICkuam9pbiggYFxcbmAgKSApLmpvaW4oIGBcXG5gICkgKVxuXHRcdC8vIH0gfVxuXHQ+XG5cdFx0PGRpdiBjbGFzcyA9IFwiYmFja2luZ1wiID48ZGl2IGNsYXNzID0gXCJoZWxwX2ltZ1wiIC8+PC9kaXY+XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzID0gXCJsb2dvXCJcblx0XHRvbnByZXNzID0geyAoKSA9PiBhcHAuZGlhbG9nID0gYENvbnRleHRNZW51YCB9XG5cdFx0b250YXAgPSB7IGV2ZW50ID0+IHtcblx0XHRcdGlmICggZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuc3JjRXZlbnQgJiYgZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkgKVxuXHRcdFx0XHRyZXR1cm4gYXBwLmRpYWxvZyA9IGBDb250ZXh0TWVudWBcblx0XHRcdGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5zcmNFdmVudCAmJiBldmVudC5zcmNFdmVudC5jdHJsS2V5IClcblx0XHRcdFx0cmV0dXJuIGFwcC5kaWFsb2cgPSBgU2VhcmNoSXRlbXNgXG5cdFx0XHRhcHAuZWRpdGluZyA9IGZhbHNlXG5cdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdGFwcC5nbyggYXBwLm1haW4gKVxuXHRcdH0gfVxuXHQ+XG5cdFx0PGRpdiBjbGFzcyA9IFwiYmFja2luZ1wiID48ZGl2IGNsYXNzID0gXCJtZW51X2ltZ1wiIC8+PC9kaXY+XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzID0gXCJiYWNrXCJcblx0XHRvbnRvdWNoID0geyAoKSA9PiB7XG5cdFx0XHRpZiAoIGFwcC5lZGl0aW5nIClcblx0XHRcdFx0YXBwLmVkaXRpbmcgPSBmYWxzZVxuXHRcdFx0ZWxzZSBpZiAoIGFwcC5kaWFsb2cgKVxuXHRcdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdGVsc2Vcblx0XHRcdFx0YXBwLmJhY2soKVxuXHRcdH0gfVxuXHQ+XG5cdFx0PGRpdiBjbGFzcyA9IFwiYmFja2luZ1wiID48ZGl2IGNsYXNzID0gXCJiYWNrX2ltZ1wiIC8+PC9kaXY+XG5cdDwvZGl2PlxuPC9kaXY+XG4iLCJleHBvcnQgZGVmYXVsdCBhcHAgPT4gKCBhdHRyLCBjb250ZW50ICkgPT5cblx0PGEgY2xhc3MgPSBcImJ1dHRvblwiIGhyZWYgPSBcImphdmFzY3JpcHQ6dm9pZCgwKVwiIHRhcmdldCA9IFwiX3NlbGZcIiBvbnRvdWNoID0geyBldmVudCA9PiB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdGlmICggdHlwZW9mIGF0dHIub25jbGljayA9PSBgc3RyaW5nYCApXG5cdFx0XHRhcHAuZGlhbG9nID0gYXR0ci5vbmNsaWNrXG5cdFx0ZWxzZSB7XG5cdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdGF0dHIub25jbGljayAmJiBhdHRyLm9uY2xpY2soKVxuXHRcdH1cblx0fSB9XG5cdF8gPSB7IE9iamVjdC5hc3NpZ24oIHt9LCBhdHRyLCB7IG9uY2xpY2s6IG51bGwgfSApIH1cblx0Pntcblx0XHRjb250ZW50XG5cdH08L2E+XG4iLCJpbXBvcnQgKiBhcyBodG1sdXRpbHMgZnJvbSBcImh0bWx1dGlsc1wiXG5pbXBvcnQgcmEgZnJvbSBcInJhXCJcblxuZXhwb3J0IGRlZmF1bHQgYXBwID0+ICggeyBvbmNsaWNrLCB1cmwsIHZpc2libGUsIGVuYWJsZWQsIG1lc3NhZ2UgfSApID0+IHtcblx0bGV0IGNvbnRlbnQgPSBhcHAubWVzc2FnZSggbWVzc2FnZSApXG5cdGxldCBpc0VuYWJsZWQgPSAoKSA9PiAoIHVybCB8fCBvbmNsaWNrICkgJiYgKCAhZW5hYmxlZCB8fCBlbmFibGVkKCkgKVxuXHRpZiAoIHR5cGVvZiB2aXNpYmxlID09IGBzdHJpbmdgICkge1xuXHRcdGxldCBkZXZpY2VUeXBlID0gdmlzaWJsZVxuXHRcdHZpc2libGUgPSAoKSA9PiBhcHAuZGV2aWNlVHlwZSA9PSBkZXZpY2VUeXBlXG5cdH1cblx0bGV0IHJldFxuXHRpZiAoIHVybCAmJiAhb25jbGljayApXG5cdFx0cmV0ID0gPGEgaHJlZiA9IHsgdXJsIH0gcmVsID0gXCJleHRlcm5hbFwiIHRhcmdldCA9IFwiX2JsYW5rXCIgPnsgY29udGVudCB9PC9hPlxuXHRlbHNlXG5cdFx0cmV0ID0gPGEgaHJlZiA9IFwiamF2YXNjcmlwdDp2b2lkKDApXCIgdGFyZ2V0ID0gXCJfc2VsZlwiIG9udG91Y2ggPSB7IGV2ZW50ID0+IHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHRcdGlmICggb25jbGljayAmJiBpc0VuYWJsZWQoKSApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2Ygb25jbGljayA9PSBgc3RyaW5nYCApXG5cdFx0XHRcdFx0YXBwLmRpYWxvZyA9IG9uY2xpY2tcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRcdFx0b25jbGljaygpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IH0gPnsgY29udGVudCB9PC9hPlxuXHRsZXQgaXNWaXNpYmxlID0gcmEoICgpID0+IHZpc2libGUgPT0gbnVsbCB8fCB2aXNpYmxlKCkgKVxuXHRsZXQgcm9vdCA9IDxkaXYgY2xhc3MgPSB7ICgpID0+IGBcblx0XHRjb21tYW5kXG5cdFx0JHsgbWVzc2FnZSB9XG5cdFx0JHsgaXNFbmFibGVkKCkgPyBgZW5hYmxlZGAgOiBgZGlzYWJsZWRgIH1cblx0XHQkeyB2aXNpYmxlID09IG51bGwgfHwgdmlzaWJsZSgpID8gYGl0ZW1WaXNpYmxlYCA6IGBpdGVtSGlkZGVuYCB9XG5cdGAgfSA+PGRpdiBjbGFzcyA9IFwiYmFja2luZ1wiID48aHRtbHV0aWxzLkNlbnRlcmVkPnsgcmV0IH08L2h0bWx1dGlscy5DZW50ZXJlZD48L2Rpdj48L2Rpdj5cblx0cm9vdC5pc1Zpc2libGUgPSA6OmlzVmlzaWJsZS52YWx1ZU9mXG5cdHJldHVybiByb290XG59XG4iLCJpbXBvcnQgRk1lbnUgZnJvbSBcInVpL01lbnVcIlxuaW1wb3J0IEZDb21tYW5kIGZyb20gXCJ1aS9Db21tYW5kXCJcbmltcG9ydCBGQWRkRXhpc3RpbmdJdGVtIGZyb20gXCJ1aS9BZGRFeGlzdGluZ0l0ZW1cIlxuXG5leHBvcnQgZGVmYXVsdCAoIGFwcCwgbG9jYWwgKSA9PiB7XG5cdGxldCBNZW51ID0gYXBwLmxvYWQoIEZNZW51IClcblx0bGV0IENvbW1hbmQgPSBhcHAubG9hZCggRkNvbW1hbmQgKVxuXHRsZXQgQWRkRXhpc3RpbmdJdGVtID0gYXBwLmxvYWQoIEZBZGRFeGlzdGluZ0l0ZW0gKVxuXHRyZXR1cm4gPE1lbnU+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRTZWFyY2hEZXZpY2VzXCJcblx0XHRcdG9uY2xpY2sgPSBcIlNlYXJjaEl0ZW1zXCJcblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kVG9GYXZvdXJpdGVzXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuYWN0aXZlRGV2aWNlSWQgIT0gYXBwLm1haW4gfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4ge1xuXHRcdFx0XHRhcHAubGlua0FjdGl2ZVRvRmF2b3VyaXRlcygpXG5cdFx0XHRcdGFwcC5ub3RpZmljYXRpb24oIGDQlNC+0LHQsNCy0LvQtdC90L4g0LIg0LjQt9Cx0YDQsNC90L3QvtC1YCApXG5cdFx0XHR9IH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kTGlua0RldmljZVwiXG5cdFx0XHR2aXNpYmxlID0gXCJkZXZpY2VcIlxuXHRcdFx0b25jbGljayA9IFwiQXNrVG9MaW5rRGV2aWNlXCJcblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuZGV2aWNlVHlwZSA9PSBgcGxhY2VgIH1cblx0XHRcdG9uY2xpY2sgPSBcIkFkZE1lbnVcIlxuXHRcdC8+XG5cdFx0PEFkZEV4aXN0aW5nSXRlbVxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZEFkZFwiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgYXBwLmRldmljZVR5cGUgPT0gYGdyb3VwYCB9XG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZE1vdmVJY29uc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgYXBwLmRldmljZVR5cGUgIT0gYHNpbmdsZWAgfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4gYXBwLmVkaXRpbmcgPSB0cnVlIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kUmVuYW1lSXRlbVwiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgfVxuXHRcdFx0b25jbGljayA9IFwiQXNrTmV3TmFtZVwiXG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZENoYW5nZUljb25cIlxuXHRcdFx0dmlzaWJsZSA9IHsgKCkgPT4gIWFwcC5lZGl0aW5nICYmIGFwcC5hY3RpdmVEZXZpY2VJZCAhPSBhcHAubWFpbiB9XG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiB7XG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgU2VhcmNoUGljdHVyZXNgXG5cdFx0XHRcdGFwcC5zZWFyY2hBY3Rpb24gPSBuYW1lID0+IHtcblx0XHRcdFx0XHRpZiAoIG5hbWUgKVxuXHRcdFx0XHRcdFx0YXBwLmNoYW5nZVBpY3R1cmUoIGFwcC5hY3RpdmVEZXZpY2VJZCwgbmFtZSApXG5cdFx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRcdH1cblx0XHRcdFx0YXBwLnNlYXJjaEZpbHRlciA9IG51bGxcblx0XHRcdH0gfVxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRDaGFuZ2VTa2luXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+IGFwcC5hY3RpdmVEZXZpY2VJZCA9PSBhcHAubWFpbiB9XG5cdFx0XHRvbmNsaWNrID0gXCJUaGVtZU1lbnVcIlxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRQdXJnZUl0ZW1cIlxuXHRcdFx0dmlzaWJsZSA9IHsgKCkgPT4gIWFwcC5lZGl0aW5nICYmIGFwcC5hY3RpdmVEZXZpY2VJZCAhPSBhcHAubWFpbiB9XG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiB7XG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgRGVsZXRlRGV2aWNlYFxuXHRcdFx0XHQvLyBhcHAucHVyZ2VJdGVtKCBhcHAuYWN0aXZlRGV2aWNlSWQgKVxuXHRcdFx0fSB9XG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZFNob3dMYWJlbHNcIlxuXHRcdFx0dmlzaWJsZSA9IHsgKCkgPT4gIWxvY2FsLmxhYmVscyAmJiBhcHAuYWN0aXZlRGV2aWNlSWQgPT0gYXBwLm1haW4gfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4gbG9jYWwubGFiZWxzID0gdHJ1ZSB9XG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZEhpZGVMYWJlbHNcIlxuXHRcdFx0dmlzaWJsZSA9IHsgKCkgPT4gbG9jYWwubGFiZWxzICYmIGFwcC5hY3RpdmVEZXZpY2VJZCA9PSBhcHAubWFpbiB9XG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiBsb2NhbC5sYWJlbHMgPSBmYWxzZSB9XG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZFJlc2V0VG9GYWN0b3J5U2V0dGluZ3NcIlxuXHRcdFx0dmlzaWJsZSA9IHsgKCkgPT4gYXBwLmFjdGl2ZURldmljZUlkID09IGFwcC5tYWluIH1cblx0XHRcdGVuYWJsZWQgPSB7ICgpID0+IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSAhPSBgdGVzdC5zaC5uZXJvZWxlY3Ryb25pY3MuYnlgIH1cblx0XHRcdG9uY2xpY2sgPSBcIkFza1RvUmVzZXRcIlxuXHRcdC8+XG5cdDwvTWVudT5cbn1cbiIsImltcG9ydCByYSBmcm9tIFwicmFcIlxuaW1wb3J0ICogYXMgY28gZnJvbSBcImNvXCJcbmltcG9ydCAqIGFzIERpZmYgZnJvbSBcImRpZmZcIlxuaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gXCJsb2Rhc2hcIlxuaW1wb3J0ICogYXMgbHUgZnJvbSBcImxvY2FsVXRpbHNcIlxuaW1wb3J0ICogYXMgaHRtbHV0aWxzIGZyb20gXCJodG1sdXRpbHNcIlxuaW1wb3J0ICogYXMgY29tbWFuZHMgZnJvbSBcImNvbW1hbmRzXCJcblxuZXhwb3J0IGRlZmF1bHQgKCBhcHAsIGxvY2FsICkgPT4gKCB7IHBsYWNlSWQsIGljb25JZCwgaWNvbkRlc2NyLCBwb3NpdGlvbiB9ICkgPT4ge1xuXG5cdGxldCBpY29uLCBpbWFnZVxuXHRsZXQgaXNNb3VzZSA9IGZhbHNlXG5cblx0bGV0IHBsYWNlUmVjdCA9IGh0bWx1dGlscy50aWNrQ2FjaGUoICgpID0+IHtcblx0XHRsZXQgeCA9IGljb24ucGFyZW50Tm9kZVxuXHRcdGxldCByXG5cdFx0d2hpbGUgKCByID0geC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgIXIud2lkdGggfHwgIXIuaGVpZ2h0IClcblx0XHRcdHggPSB4LnBhcmVudE5vZGVcblx0XHRyZXR1cm4gclxuXHR9IClcblxuXHRsZXQgcmVsUG9pbnQgPSBwID0+IHtcblx0XHRsZXQgciA9IHBsYWNlUmVjdCgpXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6ICggcC54IC0gci5sZWZ0ICkgLyByLndpZHRoICogMTAwLFxuXHRcdFx0eTogKCBwLnkgLSByLnRvcCApIC8gci5oZWlnaHQgKiAxMDAsXG5cdFx0fVxuXHR9XG5cblx0bGV0IGdldFBvaW50ID0gZGF0YSA9PiB7XG5cdFx0cmV0dXJuIHJlbFBvaW50KCB7IHg6IGRhdGEucGFnZVgsIHk6IGRhdGEucGFnZVkgfSApXG5cdH1cblxuXHRsZXQgZ2V0TGVmdFRvcCA9IGRhdGEgPT4ge1xuXHRcdGxldCBwID0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXHRcdHJldHVybiByZWxQb2ludCggeyB4OiBwLmxlZnQsIHk6IHAudG9wIH0gKVxuXHR9XG5cblx0bGV0IGltYWdlSGVpZ2h0ID0gaHRtbHV0aWxzLnRpY2tDYWNoZSggKCkgPT4ge1xuXHRcdGlmICggIWlzTW91c2UgKVxuXHRcdFx0cmV0dXJuIGljb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG5cdFx0aWYgKCBvcHRzLmljb25EYXRhICkge1xuXHRcdFx0aWYgKCBvcHRzLmljb25EYXRhLmRldmljZUltYWdlR2V0SGVpZ2h0ICkge1xuXHRcdFx0XHRsZXQgciA9IG9wdHMuaWNvbkRhdGEuZGV2aWNlSW1hZ2VHZXRIZWlnaHQoKVxuXHRcdFx0XHRpZiAoIHIgKVxuXHRcdFx0XHRcdHJldHVybiByXG5cdFx0XHR9XG5cdFx0XHRsZXQgaCA9IG9wdHMuaWNvbkRhdGEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggYGRldmljZV9pbWFnZV9oZWlnaHRgIClbIDAgXVxuXHRcdFx0aWYgKCBoICE9IG51bGwgJiYgaC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgKSB7XG5cdFx0XHRcdGxldCByID0gaC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblx0XHRcdFx0aWYgKCByIClcblx0XHRcdFx0XHRyZXR1cm4gclxuXHRcdFx0fVxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb3B0cy5pY29uRGF0YS5jaGlsZE5vZGVzLmxlbmd0aDsgKytpICkge1xuXHRcdFx0XHRsZXQgciA9IG9wdHMuaWNvbkRhdGEuY2hpbGROb2Rlcy5pdGVtKCBpIClcblx0XHRcdFx0aWYgKCByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCApIHtcblx0XHRcdFx0XHRyID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblx0XHRcdFx0XHRpZiAoIHIgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaW1hZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG5cdH0gKVxuXG5cdGxldCBvcHRzID0gcmEoIHtcblxuXHRcdGdldCBpY29uTmFtZSgpIHsgcmV0dXJuIGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpICYmIGljb25EZXNjci52YWx1ZU9mKCkuaWNvbiB8fCBudWxsIH0sXG5cdFx0Z2V0IGljb25UZW1wbGF0ZSgpIHsgcmV0dXJuIHRoaXMuaWNvbk5hbWUgJiYgYXBwLmljb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggYXBwLmljb25zLCB0aGlzLmljb25OYW1lICkgJiYgYXBwLmljb25zWyB0aGlzLmljb25OYW1lIF0gfHwgbnVsbCB9LFxuXHRcdGljb25EYXRhOiBudWxsLFxuXHRcdGdldCB1cGRhdGVJY29uRGF0YVN0YXRlKCkge1xuXHRcdFx0bGV0IGRhdGEgPSB0aGlzLmljb25EYXRhXG5cdFx0XHRpZiAoIGRhdGEgJiYgZGF0YS5kZXZpY2VTZXRTdGF0ZSApXG5cdFx0XHRcdGRhdGEuZGV2aWNlU2V0U3RhdGUoIHRoaXMuc3RhdGUgKVxuXHRcdH0sXG5cblx0XHRnZXQgZGltbWVyaW5nKCkge1xuXHRcdFx0bGV0IGkgPSBpY29uRGVzY3IgPT0gbnVsbCA/IG51bGwgOiBpY29uRGVzY3IudmFsdWVPZigpXG5cdFx0XHRsZXQgaWQgPSBpID09IG51bGwgPyBudWxsIDogaS5kaW1tZXJpbmcgPT0gbnVsbCA/IG51bGwgOiAhIWkuZGltbWVyaW5nXG5cdFx0XHRpZiAoIGlkICE9IG51bGwgKVxuXHRcdFx0XHRyZXR1cm4gaWRcblx0XHRcdGlmICggaSAhPSBudWxsICYmIGkudHlwZSA9PT0gYHBsYWNlYCApXG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9LFxuXG5cdFx0aWNvbkNvbW1hbmQoIGNtZCwgZGF0YSApIHsgcmV0dXJuIGFwcC5pY29uQ29tbWFuZCggaWNvbkRlc2NyLCBpY29uSWQsIGNtZCwgZGF0YSApIH0sXG5cblx0XHRpc0RpbW1lcmluZzogZmFsc2UsXG5cdFx0bW92aW5nOiBmYWxzZSxcblx0XHRtb3ZlZDogZmFsc2UsXG5cdFx0eDogbnVsbCxcblx0XHR5OiBudWxsLFxuXG5cdFx0Z2V0IHByZXNlbnQoKSB7IHJldHVybiAhISggaWNvbkRlc2NyLmdldCggYGNvbnRlbnRgICkgfHwgaWNvbkRlc2NyLmdldCggYGdyb3VwYCApICkgfSxcblx0XHRzdGF0ZTogMCxcblx0XHRvbm5pbmc6IGZhbHNlLFxuXHRcdG9mZmluZzogZmFsc2UsXG5cdFx0ZmluYWw6IHRydWUsXG5cdFx0ZXJyb3JuZW91czogZmFsc2UsXG5cdFx0Z2V0IHVwZGF0ZVN0YXRlKCkge1xuXHRcdFx0bGV0IGQgPSBpY29uRGVzY3IgJiYgaWNvbkRlc2NyLnZhbHVlT2YoKVxuXHRcdFx0aWYgKCAhZCApXG5cdFx0XHRcdHJldHVybiAwXG5cdFx0XHRpZiAoIGQuY2xpZW50c3RhdGUgIT0gbnVsbCApIHtcblx0XHRcdFx0dGhpcy5vbm5pbmcgPSBmYWxzZVxuXHRcdFx0XHR0aGlzLm9mZmluZyA9IGZhbHNlXG5cdFx0XHRcdHRoaXMuZmluYWwgPSBmYWxzZVxuXHRcdFx0XHR0aGlzLnN0YXRlID0gZC5jbGllbnRzdGF0ZVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGQubmV3c3RhdGVfdGltZXN0YW1wICYmICggIWQuc3RhdGVfdGltZXN0YW1wIHx8IGQubmV3c3RhdGVfdGltZXN0YW1wID4gZC5zdGF0ZV90aW1lc3RhbXAgKSApIHtcblx0XHRcdFx0bGV0IGZvbm5pbmcgPSBkLm5ld3N0YXRlID49IGQuc3RhdGVcblx0XHRcdFx0dGhpcy5vbm5pbmcgPSBmb25uaW5nXG5cdFx0XHRcdHRoaXMub2ZmaW5nID0gIWZvbm5pbmdcblx0XHRcdFx0dGhpcy5maW5hbCA9IGZhbHNlXG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBkLm5ld3N0YXRlXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5vbm5pbmcgPSBmYWxzZVxuXHRcdFx0XHR0aGlzLm9mZmluZyA9IGZhbHNlXG5cdFx0XHRcdHRoaXMuZmluYWwgPSB0cnVlXG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBkLnN0YXRlXG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVycm9ybmVvdXMgPSAhIWQuZXJyb3JuZW91c1xuXHRcdH0sXG5cdH0gKVxuXG5cdGNvbnN0IE1PVkVfUEFHRV9ESVNUID0gMC4xXG5cdGNvbnN0IE1PVkVfU0lERV9ESVNUID0gMC4yNVxuXG5cdGZ1bmN0aW9uIGNvbXBhcmVJbmRleCggYSwgYiApIHtcblx0XHRyZXR1cm4gYS5pbmRleCAtIGIuaW5kZXhcblx0fVxuXG5cdGxldCBtb3ZlID0gZnVuY3Rpb24qICggc3RhcnQsIG5leHQgKSB7XG5cdFx0aWYgKCBvcHRzLm1vdmluZyApXG5cdFx0XHRvcHRzLm1vdmluZy5raWxsKCBgcmVzdGFydGluZyBieSBhbm90aGVyIGZpbmdlcmAgKVxuXG5cdFx0bGV0IGNoYW5nZXMgPSBhcHAuZGJjYWNoZS5vcGVuKClcblx0XHRsZXQgY3VycmVudFBvc2l0aW9uID0gcG9zaXRpb24udmFsdWVPZigpXG5cdFx0bGV0IGRvbmUgPSBmYWxzZVxuXG5cdFx0Ly8gVE9ETzogYWxsIHJhIHN0cnVjdHVyZXMgbXVzdCBiZSBsaW5rZWQgdG8gdGhlIGN1cnJlbnQgdGhyZWFkIGFuZCBtdXN0IGxpbmsgYWxsIHRoZXJlIHRpY2sgcHJvY3MgdG8gdGhlIGN1cnJlbnQgdGhyZWFkIGFuZCBzbyB1cGRhdGUgYWxsIHRoZXJlIHRpY2tzIG9uIHN1YnNlcXVlbnQgeWllbGQgYW5kIGFsc28gdXBkYXRlIHRoZW0gYWxsIHdoaWxlIGZpbmlzaGluZyB0aHJlYWQgZWl0aGVyIG5vcm1hbCBvciBhYm5vcm1hbCBhbmQgdGhlbiBzdWNoIHJhIHN0cnVjdHVyZXMgbXVzdCBiZSBkZXN0cm95ZWQgdG8gdW5saW5rIGZyb20gYW55IGV4dGVybmFsIGRlcGVuZGVuY3kuIFRoaXMgbXVzdCBiZSBkb25lIHZpYSBpbXBsZW1lbnRpbmcgY28ubmV4dFRpY2sgaW4gdGVybXMgbGlrZSBpb2pzLnByb2Nlc3MubmV4dFRpY2sgLSBuZXh0VGljayBjYWxsYmFja3MgbXVzdCBiZSBwcm9jZXNzZWQgYmVmb3JlIHlpZWxkaW5nIHN1YnNlcXVlbnQgcmVzdWx0LiBTbyBpdCBpcyBwb3NzaWJsZSB0byBsZXQgZXhjZXB0aW9ucyBiZSByYWlzZWQgaW4gcHJvcGVyIHdheS4gQW5kIGl0IG1lYW5zIHRoYXQgaWYgcG9zc2libGUgbmV4dFRpY2sgY2FsbGJhY2tzIHdpbGwgZmlyZSBqdXN0IGFmdGVyIHJlcXVlc3QgZm9yIG5leHQgeWllbGQuXG5cblx0XHRsZXQgaG92ZXIgPSByYSgge1xuXHRcdFx0c2F2ZWRJZDogbnVsbCxcblx0XHRcdGNhY2hlZElkOiBudWxsLFxuXHRcdFx0aWQ6IG51bGwsXG5cdFx0XHRwb3NpdGlvbjogbnVsbCxcblxuXHRcdFx0dXBkYXRlQXBwKCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNhdmVkSWQgKVxuXHRcdFx0XHRcdGFwcC5ob3ZlciA9IERpZmYuYXBwbHkoIGFwcC5ob3ZlciwgeyBbIHRoaXMuc2F2ZWRJZCBdOiB7IFsgcGxhY2VJZCBdOiB7IFsgaWNvbklkIF06IHZhbHVlIH0gfSB9IClcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRPRE86IGluc2VydCBkZWJvdW5jZSBtZWNoYW5pc20ganVzdCBpbnRvIHJhXG5cdFx0XHRnZXQgdXBkYXRlQ2FjaGUoKSB7IC8vIGRlYm91bmNlIGlkIGNoYW5naW5nXG5cdFx0XHRcdHRoaXMuY2FjaGVkSWQgPSB0aGlzLmlkXG5cdFx0XHR9LFxuXG5cdFx0XHRnZXQgc2F2ZUlkKCkge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZUFwcCggbnVsbCApXG5cdFx0XHRcdHRoaXMuc2F2ZWRJZCA9IHRoaXMuY2FjaGVkSWRcblx0XHRcdFx0dGhpcy51cGRhdGVBcHAoIHRydWUgKVxuXHRcdFx0fSxcblx0XHR9IClcblxuXHRcdGNvLmRlZmVyKCAoKSA9PiB7XG5cdFx0XHRob3Zlci5pZCA9IG51bGxcblx0XHRcdGRvbmUgPSB0cnVlXG5cdFx0XHRjaGFuZ2VzLmNsb3NlKClcblx0XHRcdGlmICggb3B0cy5tb3ZpbmcgPT0gY28uY3VycmVudCApIHtcblx0XHRcdFx0b3B0cy5tb3ZpbmcgPSBudWxsXG5cdFx0XHRcdG9wdHMubW92ZWQgPSBmYWxzZVxuXHRcdFx0fVxuXHRcdH0gKVxuXG5cdFx0cmEoIGNvLndyYXAoICgpID0+ICFkb25lICYmICFhcHAuZWRpdGluZyAmJiBjby5jdXJyZW50LmtpbGwoKSApIClcblxuXHRcdGxldCBwID0gZ2V0UG9pbnQoIHN0YXJ0IClcblx0XHRsZXQgciA9IGdldExlZnRUb3AoIGljb24gKVxuXHRcdG9wdHMubW92aW5nID0gY28uY3VycmVudFxuXHRcdG9wdHMubW92ZWQgPSBmYWxzZVxuXHRcdGxldCBmaW5nZXJTaGlmdCA9IHtcblx0XHRcdHg6IHIueCAtIHAueCxcblx0XHRcdHk6IHIueSAtIHAueSxcblx0XHR9XG5cdFx0b3B0cy54ID0gci54XG5cdFx0b3B0cy55ID0gci55XG5cblx0XHRmb3IgKCBsZXQgcHQ7IHB0ID0geWllbGQgbmV4dDsgKSB7XG5cdFx0XHRsZXQgZmluZ2VyID0gZ2V0UG9pbnQoIHB0IClcblx0XHRcdGxldCBjb3JuZXIgPSB7XG5cdFx0XHRcdHg6IGZpbmdlci54ICsgZmluZ2VyU2hpZnQueCxcblx0XHRcdFx0eTogZmluZ2VyLnkgKyBmaW5nZXJTaGlmdC55LFxuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRzLnggIT0gY29ybmVyLnggfHwgb3B0cy55ICE9IGNvcm5lci55IClcblx0XHRcdFx0b3B0cy5tb3ZlZCA9IHRydWVcblx0XHRcdG9wdHMueCA9IGNvcm5lci54XG5cdFx0XHRvcHRzLnkgPSBjb3JuZXIueVxuXG5cdFx0XHRsZXQgcGFnZVNpemUgPSB7XG5cdFx0XHRcdHg6IGFwcC5wYWdlV2lkdGgsXG5cdFx0XHRcdHk6IGFwcC5wYWdlSGVpZ2h0LFxuXHRcdFx0fVxuXHRcdFx0bGV0IGNlbGxTaXplID0ge1xuXHRcdFx0XHR4OiAxMDAgLyBwYWdlU2l6ZS54LFxuXHRcdFx0XHR5OiAxMDAgLyBwYWdlU2l6ZS55LFxuXHRcdFx0fVxuXHRcdFx0bGV0IGluZGV4ID0ge1xuXHRcdFx0XHR4OiBNYXRoLm1pbiggcGFnZVNpemUueCAtIDEsIE1hdGgubWF4KCAwLCBNYXRoLmZsb29yKCBmaW5nZXIueCAvIGNlbGxTaXplLnggKSApICksXG5cdFx0XHRcdHk6IE1hdGgubWluKCBwYWdlU2l6ZS55IC0gMSwgTWF0aC5tYXgoIDAsIE1hdGguZmxvb3IoIGZpbmdlci55IC8gY2VsbFNpemUueSApICkgKSxcblx0XHRcdH1cblx0XHRcdGxldCBpbkNlbGwgPSB7XG5cdFx0XHRcdHg6IGZpbmdlci54IC8gY2VsbFNpemUueCAtIGluZGV4LngsXG5cdFx0XHRcdHk6IGZpbmdlci55IC8gY2VsbFNpemUueSAtIGluZGV4LnksXG5cdFx0XHR9XG5cblx0XHRcdGxldCBwbGFjZVBvc2l0aW9uID0gaW5kZXgueCArIGluZGV4LnkgKiBwYWdlU2l6ZS54ICsgKCBsb2NhbC5wbGFjZXNQYWdlc1sgcGxhY2VJZCBdIHx8IDAgKSAqIHBhZ2VTaXplLnggKiBwYWdlU2l6ZS55XG5cblx0XHRcdGxldCBpc0luQ2VudGVyID0gaW5DZWxsLnggPiBNT1ZFX1NJREVfRElTVCAmJiBpbkNlbGwueCA8IDEgLSBNT1ZFX1NJREVfRElTVCAmJiBpbkNlbGwueSA+IE1PVkVfU0lERV9ESVNUICYmIGluQ2VsbC55IDwgMSAtIE1PVkVfU0lERV9ESVNUXG5cblx0XHRcdGlmICggIWlzSW5DZW50ZXIgfHwgaG92ZXIucG9zaXRpb24gIT0gcGxhY2VQb3NpdGlvbiApXG5cdFx0XHRcdGhvdmVyLmlkID0gbnVsbFxuXHRcdFx0aG92ZXIucG9zaXRpb24gPSBwbGFjZVBvc2l0aW9uXG5cblx0XHRcdGlmICggcHQudHlwZSAhPSBgc3RvcGAgKVxuXHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRob3Zlci5pZCA9IG51bGxcblxuXHRcdFx0aWYgKCBpbkNlbGwgPiAxIC0gTU9WRV9QQUdFX0RJU1QgJiYgY2VsbFNpemUueCA9PSBwYWdlU2l6ZS54IC0gMSApIHtcblx0XHRcdFx0Ly8gVE9ETzogc2Nyb2xsIHBhZ2UgcmlnaHRcblx0XHRcdFx0Y29udGludWVcblx0XHRcdH1cblx0XHRcdGlmICggaW5DZWxsIDwgTU9WRV9QQUdFX0RJU1QgJiYgY2VsbFNpemUueCA9PSBwYWdlU2l6ZS54IC0gMSApIHtcblx0XHRcdFx0Ly8gVE9ETzogc2Nyb2xsIHBhZ2UgbGVmdFxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcGxhY2UgPSBsdS5nZXQoIGNoYW5nZXMsIGByZXN1bHRgLCBgY29udGVudGAsIHBsYWNlSWQsIGBjb250ZW50YCApXG5cdFx0XHRpZiAoICFwbGFjZSB8fCAhcGxhY2VbIGljb25JZCBdIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRsZXQga2V5cyA9IGxvZGFzaC5rZXlzKCBwbGFjZSApXG5cdFx0XHRcdC5tYXAoIGtleSA9PiAoIHsga2V5LCBpbmRleDogcGxhY2VbIGtleSBdLmluZGV4IH0gKSApXG5cdFx0XHRcdC5zb3J0KCBjb21wYXJlSW5kZXggKVxuXG5cdFx0XHRsZXQgbmV3SW5kZXhcblxuXHRcdFx0aWYgKCBwbGFjZVBvc2l0aW9uIDwgMCApIHtcblx0XHRcdFx0aWYgKCBjdXJyZW50UG9zaXRpb24gPD0gMCApXG5cdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyAwIF0uaW5kZXggLSAxXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcGxhY2VQb3NpdGlvbiA+IGtleXMubGVuZ3RoIC0gMSApIHtcblx0XHRcdFx0aWYgKCBjdXJyZW50UG9zaXRpb24gPj0ga2V5cy5sZW5ndGggLSAxIClcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRuZXdJbmRleCA9IGtleXNbIGtleXMubGVuZ3RoIC0gMSBdLmluZGV4ICsgMVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICggY3VycmVudFBvc2l0aW9uID09IHBsYWNlUG9zaXRpb24gKVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdGlmICggaXNJbkNlbnRlciApIHtcblx0XHRcdFx0XHQvLyBUT0RPXG5cdFx0XHRcdFx0aG92ZXIuaWQgPSBrZXlzWyBwbGFjZVBvc2l0aW9uIF0ua2V5XG5cdFx0XHRcdFx0bGV0IHNyY0RldmljZSA9IGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpXG5cdFx0XHRcdFx0bGV0IHNyY1R5cGUgPSBzcmNEZXZpY2UgJiYgaWNvbkRlc2NyLnZhbHVlT2YoKS50eXBlXG5cdFx0XHRcdFx0bGV0IGRzdERldmljZSA9IGFwcC5nZXREZXZpY2UoIGhvdmVyLmlkIClcblx0XHRcdFx0XHRsZXQgZHN0VHlwZSA9IGRzdERldmljZSAmJiBkc3REZXZpY2UudHlwZVxuXHRcdFx0XHRcdC8vIFRPRE86IGFsbG93IGRzdFR5cGUgPT0gYHNpbmdsZWAgJiYgc3JjVHlwZSA9PSBgc2luZ2xlYFxuXHRcdFx0XHRcdGlmICggZmFsc2Vcblx0XHRcdFx0XHRcdHx8ICggc3JjVHlwZSA9PSBgZ3JvdXBgICkgJiYgKCBkc3RUeXBlID09IGBncm91cGAgKVxuXHRcdFx0XHRcdFx0fHwgKCBzcmNUeXBlID09IGBncm91cGAgKSAmJiAoIGRzdFR5cGUgPT0gYHBsYWNlYCApXG5cdFx0XHRcdFx0XHR8fCAoIHNyY1R5cGUgPT0gYHNpbmdsZWAgKSAmJiAoIGRzdFR5cGUgPT0gYGdyb3VwYCApXG5cdFx0XHRcdFx0XHR8fCAoIHNyY1R5cGUgPT0gYHNpbmdsZWAgKSAmJiAoIGRzdFR5cGUgPT0gYHBsYWNlYCApXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRob3Zlci5pZCA9IG51bGxcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGluQ2VsbC54ID4gMC41ICkge1xuXHRcdFx0XHRcdGlmICggY3VycmVudFBvc2l0aW9uID09IHBsYWNlUG9zaXRpb24gKyAxIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0aWYgKCBpbmRleC54ID09IHBhZ2VTaXplLnggLSAxICYmIGN1cnJlbnRQb3NpdGlvbiA+IHBsYWNlUG9zaXRpb24gKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRpZiAoIHBsYWNlUG9zaXRpb24gPj0ga2V5cy5sZW5ndGggLSAxIClcblx0XHRcdFx0XHRcdG5ld0luZGV4ID0ga2V5c1sgcGxhY2VQb3NpdGlvbiBdLmluZGV4ICsgMVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG5ld0luZGV4ID0gKCBrZXlzWyBwbGFjZVBvc2l0aW9uIF0uaW5kZXggKyBrZXlzWyBwbGFjZVBvc2l0aW9uICsgMSBdLmluZGV4ICkgLyAyXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50UG9zaXRpb24gPT0gcGxhY2VQb3NpdGlvbiAtIDEgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRpZiAoIGluZGV4LnggPT0gMCAmJiBjdXJyZW50UG9zaXRpb24gPCBwbGFjZVBvc2l0aW9uIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0aWYgKCBwbGFjZVBvc2l0aW9uIDw9IDAgKVxuXHRcdFx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyBwbGFjZVBvc2l0aW9uIF0uaW5kZXggLSAxXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0bmV3SW5kZXggPSAoIGtleXNbIHBsYWNlUG9zaXRpb24gXS5pbmRleCArIGtleXNbIHBsYWNlUG9zaXRpb24gLSAxIF0uaW5kZXggKSAvIDJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbmV3UG9zaXRpb24gPSBrZXlzLm1hcCggayA9PiBrLmtleSAhPSBpY29uSWQgPyBrIDogeyBrZXk6IGsua2V5LCBpbmRleDogbmV3SW5kZXggfSApLnNvcnQoIGNvbXBhcmVJbmRleCApLmZpbmRJbmRleCggayA9PiBrLmtleSA9PSBpY29uSWQgKVxuXG5cdFx0XHRpZiAoIGN1cnJlbnRQb3NpdGlvbiA9PSBuZXdQb3NpdGlvbiApXG5cdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdGN1cnJlbnRQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uXG5cdFx0XHRjaGFuZ2VzLnVwZGF0ZSggeyBjb250ZW50OiB7IFsgcGxhY2VJZCBdOiB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXToge1xuXHRcdFx0XHRfX3ByZXNlbnRfXzogdHJ1ZSxcblx0XHRcdFx0aW5kZXg6IG5ld0luZGV4LFxuXHRcdFx0fSB9IH0gfSB9IClcblx0XHR9XG5cdFx0ZG9uZSA9IHRydWVcblx0XHRpZiAoICFob3Zlci5pZCApIHtcblx0XHRcdHlpZWxkIGNvLnNsZWVwKClcblx0XHRcdHlpZWxkIGFwcC5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggY2hhbmdlcy50cmFuc2Zvcm0oKSApXG5cdFx0XHRjaGFuZ2VzLmNsb3NlKClcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjaGFuZ2VzLmNsb3NlKClcblx0XHRcdGxldCBzcmNUeXBlID0gaWNvbkRlc2NyICYmIGljb25EZXNjci52YWx1ZU9mKCkgJiYgaWNvbkRlc2NyLnZhbHVlT2YoKS50eXBlXG5cdFx0XHRsZXQgZHN0RGV2aWNlID0gYXBwLmdldERldmljZSggaG92ZXIuaWQgKVxuXHRcdFx0bGV0IGRzdFR5cGUgPSBkc3REZXZpY2UgJiYgZHN0RGV2aWNlLnR5cGVcblxuXHRcdFx0aWYgKCBkc3RUeXBlID09IGBwbGFjZWAgfHwgc3JjVHlwZSA9PSBgc2luZ2xlYCAmJiBkc3RUeXBlID09IGBncm91cGAgKVxuXHRcdFx0XHRhcHAubGlua0l0ZW0oIGhvdmVyLmlkLCBpY29uSWQgKVxuXHRcdFx0ZWxzZSBpZiAoIHNyY1R5cGUgPT0gYGdyb3VwYCAmJiBkc3RUeXBlID09IGBncm91cGAgKSB7XG5cdFx0XHRcdGZvciAoIGxldCBpIG9mIGxvZGFzaC5rZXlzKCBpY29uRGVzY3IudmFsdWVPZigpLmNvbnRlbnQgKSApXG5cdFx0XHRcdFx0YXBwLmxpbmtJdGVtKCBob3Zlci5pZCwgaSApXG5cdFx0XHR9XG5cblxuXHRcdFx0bGV0IGNvcHkgPSBpY29uLmNsb25lTm9kZSggdHJ1ZSApXG5cdFx0XHQvLyBjb3B5LnF1ZXJ5U2VsZWN0b3IoIGAuaW1hZ2VgICkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYHJlZGBcblx0XHRcdGNvcHkuY2xhc3NMaXN0LmFkZCggYHRyYW5zaXRpb25fb2ZmYCApXG5cdFx0XHRsZXQgcGFyZW50ID0gaWNvbi5wYXJlbnROb2RlXG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoIGNvcHkgKVxuXHRcdFx0Z2xvYmFsLmdldENvbXB1dGVkU3R5bGUoIGNvcHkgKSAvLyBmb3JjZSByZWZsb3dcblx0XHRcdGNvcHkuY2xhc3NMaXN0LnJlbW92ZSggYHRyYW5zaXRpb25fb2ZmYCApXG5cdFx0XHRjb3B5LmNsYXNzTGlzdC5hZGQoIGB0cmFuc2l0aW9uX29uYCApXG5cdFx0XHRnbG9iYWwuZ2V0Q29tcHV0ZWRTdHlsZSggY29weSApIC8vIGZvcmNlIHJlZmxvd1xuXHRcdFx0c2V0VGltZW91dCggKCkgPT4gY29weS5jbGFzc0xpc3QuYWRkKCBgbnVsbF9zaXplYCApLCAxMDAgKVxuXHRcdFx0c2V0VGltZW91dCggKCkgPT4gcGFyZW50LnJlbW92ZUNoaWxkKCBjb3B5ICksIDMwMDAgKVxuXG5cdFx0XHQvLyBpY29uLnF1ZXJ5U2VsZWN0b3IoIGAuaW1hZ2VgICkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYGdyZWVuYFxuXHRcdFx0aWNvbi5jbGFzc0xpc3QuYWRkKCBgdHJhbnNpdGlvbl9vZmZgIClcblx0XHRcdGdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKCBpY29uICkgLy8gZm9yY2UgcmVmbG93XG5cdFx0XHRpY29uLmNsYXNzTGlzdC5hZGQoIGBudWxsX3NpemVgIClcblx0XHRcdHNldFNjcmVlblBvc2l0aW9uKCBpY29uLnN0eWxlLCBnZXRDdXJyZW50U2NyZWVuUG9zaXRpb24oKSApXG5cdFx0XHRnbG9iYWwuZ2V0Q29tcHV0ZWRTdHlsZSggaWNvbiApIC8vIGZvcmNlIHJlZmxvd1xuXHRcdFx0aWNvbi5jbGFzc0xpc3QucmVtb3ZlKCBgdHJhbnNpdGlvbl9vZmZgIClcblx0XHRcdGdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKCBpY29uICkgLy8gZm9yY2UgcmVmbG93XG5cblx0XHRcdC8vIFRPRE9cblx0XHRcdC8vIGxldCBuZXdQbGFjZSA9IGFwcC5nZXREZXZpY2UoIGhvdmVyLmlkIClcblx0XHRcdC8vIGlmICggbmV3UGxhY2UgJiYgbmV3UGxhY2UudHlwZSA9PSBgc2luZ2xlYCApIHtcblx0XHRcdC8vIFx0YXBwLmxpbmtpbmdEZXZpY2VzID0gWyBob3Zlci5pZCwgaWNvbklkIF1cblx0XHRcdC8vIFx0YXBwLmRpYWxvZyA9IGBDcmVhdGVQbGFjZU9yR3JvdXBgXG5cdFx0XHQvLyB9XG5cdFx0XHQvLyBlbHNlXG5cdFx0XHQvLyBhcHAuaW5zZXJ0SW50byggaG92ZXIuaWQsIGljb25JZCwgcGxhY2VJZCApXG5cdFx0fVxuXHR9XG5cblx0bGV0IGRpbW0gPSBmdW5jdGlvbiogKCBuZXh0ICkge1xuXHRcdGxldCBjaGFuZ2VzID0gYXBwLmRiY2FjaGUub3BlbigpXG5cdFx0dHJ5IHtcblx0XHRcdGxldCBzdGF0ZVxuXHRcdFx0b3B0cy5pc0RpbW1lcmluZyA9IHRydWVcblx0XHRcdGxldCBpbml0aWFsRGltbWVyaW5nU3RhdGUgPSBpY29uRGVzY3IgJiYgaWNvbkRlc2NyLmdldCggYHN0YXRlYCApXG5cdFx0XHRmb3IgKCBsZXQgcHQ7IHB0ID0geWllbGQgbmV4dDsgKSB7XG5cdFx0XHRcdGlmICggcHQuZGV0YWlsLnR5cGUgPT0gYHN3aXBlYCApIHtcblx0XHRcdFx0XHRpZiAoIHB0LmRldGFpbC5kaXJlY3Rpb24gPT0gYHVwYCApXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IDFcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IDBcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRsZXQgZGVsdGEgPSAtcHQuZGVsdGFZIC8gKCBpbWFnZUhlaWdodCgpICogMS4wIC8qIG1vdmUgbXVsdGlwbHllciAqLyApXG5cdFx0XHRcdFx0c3RhdGUgPSBNYXRoLm1pbiggMSwgTWF0aC5tYXgoIDAsIGluaXRpYWxEaW1tZXJpbmdTdGF0ZSArIGRlbHRhICkgKVxuXHRcdFx0XHRcdGlmICggc3RhdGUgPT0gMCB8fCBzdGF0ZSA9PSAxIClcblx0XHRcdFx0XHRcdGluaXRpYWxEaW1tZXJpbmdTdGF0ZSA9IHN0YXRlIC0gZGVsdGFcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGFuZ2VzLnVwZGF0ZSggZGIgPT4gY29tbWFuZHMuU2V0U3RhdGUuZGIoIHsgbW9kZTogYGNsaWVudGAgfSwgZGIsIGljb25JZCwgc3RhdGUgKSApXG5cdFx0XHR9XG5cdFx0XHRpZiAoIHN0YXRlICE9IG51bGwgKVxuXHRcdFx0XHR5aWVsZCBvcHRzLmljb25Db21tYW5kKCBgU2V0YCwgc3RhdGUgKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdGNoYW5nZXMuY2xvc2UoKVxuXHRcdFx0b3B0cy5pc0RpbW1lcmluZyA9IGZhbHNlXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmVlblBvc2l0aW9uKCBzaGlmdCApIHtcblx0XHRsZXQgaSA9IGx1LnZhbHVlT2YoIHBvc2l0aW9uIClcblx0XHRsZXQgbXcgPSBhcHAubWVudVdpZHRoIHx8IDEwMFxuXHRcdGxldCBtaCA9IGFwcC5tZW51SGVpZ2h0IHx8IDEwMFxuXHRcdGxldCBwaCA9IGFwcC5wYWdlSGVpZ2h0IHx8IDFcblx0XHRsZXQgcHcgPSBhcHAucGFnZVdpZHRoIHx8IDFcblx0XHRsZXQgcHMgPSBwdyAqIHBoXG5cdFx0bGV0IHBpID0gaSAlIHBzXG5cdFx0bGV0IHAgPSAoIGkgLSBwaSApIC8gcHNcblx0XHRsZXQgdyA9IHBpICUgcHdcblx0XHRsZXQgaCA9ICggcGkgLSB3ICkgLyBwd1xuXHRcdGxldCBpbWdfc2l6ZSA9IE1hdGgubWluKCBtdyAvIHB3LCBtaCAvIHBoIClcblx0XHRsZXQgbWFyZ2luID0ge1xuXHRcdFx0eDogKCBtdyAtIGltZ19zaXplICogcHcgKSAvICggcHcgKyAxICksXG5cdFx0XHR5OiAoIG1oIC0gaW1nX3NpemUgKiBwaCApIC8gKCBwaCArIDEgKSxcblx0XHR9XG5cdFx0dyA9IHcgKiAoIGltZ19zaXplICsgbWFyZ2luLnggKSArIG1hcmdpbi54ICsgbXcgKiBwXG5cdFx0aCA9IGggKiAoIGltZ19zaXplICsgbWFyZ2luLnkgKSArIG1hcmdpbi55XG5cdFx0aWYgKCBzaGlmdCApIHtcblx0XHRcdHcgKz0gc2hpZnQueFxuXHRcdFx0aCArPSBzaGlmdC55XG5cdFx0fVxuXHRcdHJldHVybiB7IHg6IHcsIHk6IGgsIHc6IGltZ19zaXplLCBoOiBpbWdfc2l6ZSB9XG5cdH1cblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmVlblBvc2l0aW9uXyggc2hpZnQgKSB7XG5cdFx0bGV0IGkgPSBsdS52YWx1ZU9mKCBwb3NpdGlvbiApXG5cdFx0bGV0IHBoID0gYXBwLnBhZ2VIZWlnaHQgfHwgMVxuXHRcdGxldCBwdyA9IGFwcC5wYWdlV2lkdGggfHwgMVxuXHRcdGxldCBwcyA9IHB3ICogcGhcblx0XHRsZXQgcGkgPSBpICUgcHNcblx0XHRsZXQgcCA9ICggaSAtIHBpICkgLyBwc1xuXHRcdGxldCB3ID0gcGkgJSBwd1xuXHRcdGxldCBoID0gKCBwaSAtIHcgKSAvIHB3XG5cdFx0dyArPSBwdyAqIHBcblx0XHRpZiAoIHNoaWZ0ICkge1xuXHRcdFx0dyArPSBzaGlmdC54XG5cdFx0XHRoICs9IHNoaWZ0Lnlcblx0XHR9XG5cdFx0cmV0dXJuIHsgeDogdyAqIDEwMCAvIHB3LCB5OiBoICogMTAwIC8gcGggfVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2NyZWVuUG9zaXRpb24oIHN0eWxlLCBwdCApIHtcblx0XHRzdHlsZS5sZWZ0ID0gYCR7IHB0LnggfXB4YFxuXHRcdHN0eWxlLnRvcCA9IGAkeyBwdC55IH1weGBcblx0XHRpZiAoIHB0LncgKSB7XG5cdFx0XHRzdHlsZS53aWR0aCA9IGAkeyBwdC53IH1weGBcblx0XHRcdHN0eWxlLmhlaWdodCA9IGAkeyBwdC5oIH1weGBcblx0XHR9XG5cdFx0c3R5bGUucG9zaXRpb24gPSBgYWJzb2x1dGVgXG5cdFx0c3R5bGUuZm9udFNpemUgPSBgJHsgcHQuaCAqIDAuMDkgfXB4YFxuXHRcdHJldHVybiBzdHlsZVxuXHR9XG5cdGZ1bmN0aW9uIHNldFNjcmVlblBvc2l0aW9uXyggc3R5bGUsIHB0ICkge1xuXHRcdHN0eWxlLmxlZnQgPSBgJHsgcHQueCB9JWBcblx0XHRzdHlsZS50b3AgPSBgJHsgcHQueSB9JWBcblx0XHRyZXR1cm4gc3R5bGVcblx0fVxuXG5cdHJldHVybiA8ZGl2XG5cdFx0b25jcmVhdGUgPSB7IGUgPT4gaWNvbiA9IGUudGFyZ2V0IH1cblx0XHRvbm1vdXNlZG93biA9IHsgKCkgPT4gaXNNb3VzZSA9IHRydWUgfVxuXHRcdG9ud2hlZWwgPSB7IGUgPT4gY29uc29sZS5sb2coIGUuZGVsdGFZLCBlLmRlbHRhTW9kZSwgZSApIH1cblx0XHRjbGFzcyA9IHsgKCkgPT4gYFxuXHRcdFx0aWNvblxuXHRcdFx0JHsgb3B0cy5vbm5pbmcgJiYgYG9ubmluZ2AgfVxuXHRcdFx0JHsgb3B0cy5vZmZpbmcgJiYgYG9mZmluZ2AgfVxuXHRcdFx0JHsgb3B0cy5maW5hbCAmJiBgZmluYWxgIH1cblx0XHRcdCR7IG9wdHMuZXJyb3JuZW91cyAmJiBgZXJyb3JuZW91c2AgfVxuXHRcdFx0JHsgb3B0cy5kaW1tZXJpbmcudmFsdWVPZigpID8gYGRpbW1lcmluZ2AgOiBgc3dpdGNoaW5nYCB9XG5cdFx0XHQkeyBpY29uSWQgfVxuXHRcdFx0aWNvbl9tb3ZpbmdfJHsgISFvcHRzLm1vdmluZyB9XG5cdFx0XHRpY29uX21vdmVkXyR7ICEhb3B0cy5tb3ZpbmcgJiYgISFvcHRzLm1vdmVkIH1cblx0XHRcdGljb25fZGVzdGluYXRpb25fJHsgISEoIGFwcC5ob3ZlciAmJiBhcHAuaG92ZXJbIGljb25JZCBdICkgfVxuXHRcdGAgfVxuXHRcdHN0eWxlID0geyBmdW5jdGlvbiogKCkge1xuXHRcdFx0Ly8g0LrQsNC70ZYg0LDQtNGA0LDQt9GDINC/0YDRi9GB0LLQvtGW0YbRjCBsZWZ0INGWIHRvcCDRgtC+INGH0LDQvNGD0YHRjNGG0ZYg0L3QtSDQv9GA0LDRhtGD0LUgdHJhbnNpdGlvblxuXHRcdFx0aWYgKCBhcHAuZWRpdGluZyApIHtcblx0XHRcdFx0eWllbGQgY28uc2xlZXAoKVxuXHRcdFx0XHR5aWVsZCBjby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHRcdH1cblx0XHRcdHJldHVybiBzZXRTY3JlZW5Qb3NpdGlvbigge30sIG9wdHMubW92aW5nID8gb3B0cyA6IGdldEN1cnJlbnRTY3JlZW5Qb3NpdGlvbigpIClcblx0XHR9IH1cblx0PjxkaXYgY2xhc3MgPSBcImJhY2tpbmdcIiA+XG5cdFx0PGRpdiBjbGFzcyA9IHsgKCkgPT4gYFxuXHRcdFx0aWNvbkNvbnRyb2xcblx0XHRcdCR7IGBzdGF0ZWAgKyAoIG9wdHMucHJlc2VudCA/IGBQcmVzZW50YCA6IGBBYnNlbnRgICkgfVxuXHRcdFx0JHsgYHN0YXRlYCArICggTWF0aC5yb3VuZCggKCBvcHRzLnByZXNlbnQgPyBvcHRzLnN0YXRlIDogMCApICogMTAwICkgKyAxMDAwICkudG9TdHJpbmcoKS5zbGljZSggMSApIH1cblx0XHRcdCR7IGBzdGF0ZWAgKyAoIE1hdGgucm91bmQoICggb3B0cy5wcmVzZW50ID8gb3B0cy5zdGF0ZSA6IDAgKSAqIDEwMCApID8gYE9uYCA6IGBPZmZgICkgfVxuXHRcdFx0JHsgIW9wdHMuaXNEaW1tZXJpbmcgPyBgc21vb3RoaW5nYCA6IGBgIH1cblx0XHRcdCR7IG9wdHMuaWNvblRlbXBsYXRlICYmIG9wdHMuaWNvblRlbXBsYXRlLmNsYXNzTmFtZSB8fCBgYCB9XG5cdFx0YCB9XG5cdFx0XHRvbnRvdWNoID0geyBodG1sdXRpbHMucHJldmVudERlZmF1bHQgfVxuXHRcdFx0b250YXAgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBvcHRzLmljb25Db21tYW5kKCBgU2hvcnRgICkgfVxuXHRcdFx0b25wcmVzcyA9IHsgKCkgPT4gIWFwcC5lZGl0aW5nICYmIG9wdHMuaWNvbkNvbW1hbmQoIGBMb25nYCApIH1cblx0XHRcdG9ucGFuID0geyBmdW5jdGlvbiogKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoIGFwcC5lZGl0aW5nICkge1xuXHRcdFx0XHRcdC8vIG1vdmluZ1xuXHRcdFx0XHRcdGxldCBuZXh0ID0gZGF0YS5kZXRhaWwubG9jaygpXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGZvciAoIGxldCBwdDsgcHQgPSB5aWVsZCBuZXh0OyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBwdC5kZXRhaWwucHJlc3NlZCA9PT0gZmFsc2UgKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0XHRpZiAoIHB0LmRldGFpbC5wcmVzc2VkID09IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRcdHlpZWxkIG1vdmUoIHB0LCBuZXh0IClcblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdFx0XHRkYXRhLmRldGFpbC51bmxvY2soIG5leHQgKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGB1cGAgfHwgZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGBkb3duYCApIHtcblx0XHRcdFx0XHQvLyBkaW1tZXJpbmdcblx0XHRcdFx0XHRkYXRhLnN0b3BQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0eWllbGQgZGltbSggZGF0YS5kZXRhaWwubmV4dCApXG5cdFx0XHRcdH1cblx0XHRcdH0gfVxuXHRcdD5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJsYWJlbF9zdGF0ZVwiIC8+XG5cdFx0XHQ8ZGl2IGNsYXNzID0gXCJpbWFnZVwiIG9uY3JlYXRlID0geyBlID0+IGltYWdlID0gZS50YXJnZXQgfSA+XG5cdFx0XHRcdDxkaXYgY2xhc3MgPSBcInN2Z1wiID57XG5cdFx0XHRcdFx0KCkgPT4gb3B0cy5pY29uRGF0YSA9IG9wdHMuaWNvblRlbXBsYXRlICYmIGh0bWx1dGlscy5pbXBvcnRDb21wb25lbnQoIG9wdHMuaWNvblRlbXBsYXRlICkgfHwgbnVsbFxuXHRcdFx0XHR9PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJpY29uTGFiZWwgdGV4dF9saWdodG5pbmdcIiA+eyAoKSA9PlxuXHRcdFx0XHQoIGljb25EZXNjci5nZXQoIGxvY2FsLmxhbmd1YWdlICkgfHwgaWNvbkRlc2NyLmdldCggYHJ1YCApIHx8IGljb25EZXNjci5nZXQoIGBlbmAgKSApXG5cdFx0XHRcdC50b0xvd2VyQ2FzZSgpXG5cdFx0XHR9PC9zcGFuPlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3MgPSBcImRlbGV0ZVNpZ25cIiBvbnRvdWNoc3RhcnQgPSB7ICgpID0+IGFwcC5kZWxldGVJdGVtKCBwbGFjZUlkLCBpY29uSWQgKSB9IG9ubW91c2Vkb3duID0geyAoKSA9PiBhcHAuZGVsZXRlSXRlbSggcGxhY2VJZCwgaWNvbklkICkgfSAvPlxuXHQ8L2Rpdj48L2Rpdj5cbn1cbiIsImltcG9ydCBVSUQgZnJvbSBcInVpZFwiXG5pbXBvcnQgcmEgZnJvbSBcInJhXCJcbmltcG9ydCBGUGxhY2UgZnJvbSBcInVpL1BsYWNlXCJcblxuZXhwb3J0IGRlZmF1bHQgKCBhcHAsIGxvY2FsICkgPT4ge1xuXG5cdGxldCBQbGFjZSA9IGFwcC5sb2FkKCBGUGxhY2UgKVxuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0bGV0IGluc3RhbmNlSUQgPSBVSUQoKVxuXG5cdFx0ZnVuY3Rpb24qIHBhbiggbmV4dCApIHtcblx0XHRcdC8vIFRPRE86IG5vIHRyYW5zaXRpb24gd2hpbGUgcGFubmluZ1xuXHRcdFx0bGV0IGxhc3REZWx0YVgsIHBhZ2UsIHNpemVcblx0XHRcdGxldCBkZXZpY2VpZCA9IGFwcC5hY3RpdmVEZXZpY2VJZFxuXHRcdFx0YXBwLnBsYWNlc1NoaWZ0cy5kZWZpbmVQcm9wZXJ0eSggZGV2aWNlaWQgKVxuXHRcdFx0bG9jYWwucGxhY2VzUGFnZXMuZGVmaW5lUHJvcGVydHkoIGRldmljZWlkIClcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAoIGxldCBkYXRhOyBkYXRhID0geWllbGQgbmV4dDsgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmxhc3REZWx0YVggKVxuXHRcdFx0XHRcdFx0bGFzdERlbHRhWCA9IGRhdGEubGFzdERlbHRhWFxuXHRcdFx0XHRcdGxldCBkZWx0YVggPSBkYXRhLmRlbHRhWFxuXHRcdFx0XHRcdGxldCBkZXZpY2UgPSBhcHAuZ2V0RGV2aWNlKCBkZXZpY2VpZCApXG5cdFx0XHRcdFx0aWYgKCAhZGV2aWNlIHx8ICFkZXZpY2UuY29udGVudCApXG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRzaXplID0gTWF0aC5jZWlsKCBPYmplY3Qua2V5cyggZGV2aWNlLmNvbnRlbnQgKS5sZW5ndGggLyAoIGFwcC5wYWdlV2lkdGggKiBhcHAucGFnZUhlaWdodCApIClcblx0XHRcdFx0XHRpZiAoIHNpemUgPT0gMCApXG5cdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdHBhZ2UgPSBsb2NhbC5wbGFjZXNQYWdlc1sgZGV2aWNlaWQgXSB8fCAwXG5cdFx0XHRcdFx0bGV0IGluaXRpYWxTaGlmdCA9IC1wYWdlICogYXBwLm1lbnVXaWR0aFxuXHRcdFx0XHRcdGxldCBzaGlmdCA9IGRhdGEuZGVsdGFYXG5cdFx0XHRcdFx0aWYgKCBzaGlmdCA+IDAgJiYgcGFnZSA9PSAwIHx8IHNoaWZ0IDwgMCAmJiBwYWdlID09IHNpemUgLSAxIClcblx0XHRcdFx0XHRcdHNoaWZ0IC89IDNcblx0XHRcdFx0XHRhcHAucGxhY2VzU2hpZnRzWyBkZXZpY2VpZCBdID0gc2hpZnRcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGxhc3REZWx0YVggKSB7XG5cdFx0XHRcdFx0aWYgKCBsYXN0RGVsdGFYID4gMCAmJiBwYWdlID4gMCApXG5cdFx0XHRcdFx0XHRsb2NhbC5wbGFjZXNQYWdlc1sgZGV2aWNlaWQgXSA9IHBhZ2UgLSAxXG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGxhc3REZWx0YVggPCAwICYmIHBhZ2UgPCBzaXplIC0gMSApXG5cdFx0XHRcdFx0XHRsb2NhbC5wbGFjZXNQYWdlc1sgZGV2aWNlaWQgXSA9IHBhZ2UgKyAxXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZpbmFsbHkge1xuXHRcdFx0XHRhcHAucGxhY2VzU2hpZnRzWyBkZXZpY2VpZCBdID0gMFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiA8ZGl2PlxuXHRcdFx0PHN0eWxlIGNsYXNzID0gXCJzdHlsZVwiID57ICgpID0+IGBcblx0XHRcdFx0LiR7IGluc3RhbmNlSUQgfSAuaWNvbiB7XG5cdFx0XHRcdFx0d2lkdGg6ICR7IDEwMCAvIGFwcC5wYWdlV2lkdGggfSU7XG5cdFx0XHRcdFx0aGVpZ2h0OiAkeyAxMDAgLyBhcHAucGFnZUhlaWdodCB9JTtcblx0XHRcdFx0fVxuXHRcdFx0YCB9PC9zdHlsZT5cblx0XHRcdDxkaXYgY2xhc3MgPSB7ICgpID0+IGB1bmRlcl90b3AgYWJvdmVfYm90dG9tIG1lbnUgJHsgaW5zdGFuY2VJRCB9ICR7IGFwcC5hY3RpdmVEZXZpY2VJZCB9YCB9XG5cdFx0XHRcdG9ucGFuID0geyBmdW5jdGlvbiogKCBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGBsZWZ0YCB8fCBkYXRhLmRldGFpbC5kaXJlY3Rpb24gPT0gYHJpZ2h0YCApIHtcblx0XHRcdFx0XHRcdGRhdGEuc3RvcFByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdHlpZWxkKiBwYW4oIGV2ZW50LmRldGFpbC5uZXh0IClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gfVxuXHRcdFx0XHRvbmNyZWF0ZSA9IHsgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNldEludGVydmFsKCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblx0XHRcdFx0XHRcdGFwcC5tZW51V2lkdGggPSByZWN0LndpZHRoXG5cdFx0XHRcdFx0XHRhcHAubWVudUhlaWdodCA9IHJlY3QuaGVpZ2h0XG5cdFx0XHRcdFx0fSwgMTAwIClcblx0XHRcdFx0XHRsZXQgc2hvd24gPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdFx0XHRyYSggKCkgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IGlkID0gYXBwLmFjdGl2ZURldmljZUlkXG5cdFx0XHRcdFx0XHRpZiAoICFpZCB8fCBzaG93blsgaWQgXSApXG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0YXBwLnBsYWNlc1NoaWZ0cy5kZWZpbmVQcm9wZXJ0eSggaWQgKVxuXHRcdFx0XHRcdFx0bG9jYWwucGxhY2VzUGFnZXMuZGVmaW5lUHJvcGVydHkoIGlkIClcblx0XHRcdFx0XHRcdHNob3duWyBpZCBdID0gdHJ1ZVxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogcmVtb3ZlIDxQbGFjZS8+IHdoZW4gc3VjaCBhIHBsYWNlIGlzIGFjdHVhbGx5IHJlbW92ZWQgZnJvbSBkYXRhYmFzZVxuXHRcdFx0XHRcdFx0dGhpcy5hcHBlbmRDaGlsZCggPFBsYWNlIHBsYWNlSWQgPSB7IGlkIH0gcGxhY2VEZXNjciA9IHsgcmEoICgpID0+IGFwcC5nZXREZXZpY2UoIGlkICkgKSB9IC8+IClcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0fSB9XG5cdFx0XHQvPlxuXHRcdDwvZGl2PlxuXHR9XG59XG4iLCJleHBvcnQgZGVmYXVsdCAoKSA9PiAoIGF0dHIsIGNvbnRlbnQgKSA9PiB7XG5cdGNvbnNvbGUubG9nKCBjb250ZW50LCBjb250ZW50ICYmIGNvbnRlbnQuY29uc3RydWN0b3IgKVxuXHRsZXQgdmlzaWJpbGl0eSA9IFsgLi4uY29udGVudC5jaGlsZHJlbiBdLm1hcCggYyA9PiBjLmlzVmlzaWJsZSApLmZpbHRlciggQm9vbGVhbiApXG5cdHJldHVybiA8ZGl2XG5cdFx0Y2xhc3MgPSB7ICgpID0+IGBjb3VudCR7IHZpc2liaWxpdHkuZmlsdGVyKCB2ID0+IHYgKCkgKS5sZW5ndGggfWAgfVxuXHRcdF8gPSB7IGF0dHIgfVxuXHQ+eyBjb250ZW50IH08L2Rpdj5cbn1cbiIsImltcG9ydCBBcHBsaWNhdGlvbiBmcm9tIFwidWkvQXBwbGljYXRpb25cIlxuXG5leHBvcnQgZGVmYXVsdCAoIHsgSWNvblRlbXBsYXRlcyB9ICkgPT4gPHNwYW4+XG5cdDxzdHlsZT4geyBgLmFwcGxpY2F0aW9uIHsgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7IH0gfSBgIH0gPC9zdHlsZT5cblx0PEFwcGxpY2F0aW9uIEljb25UZW1wbGF0ZXMgPSB7IEljb25UZW1wbGF0ZXMgfSAvPlxuPC9zcGFuPlxuIiwiaW1wb3J0IHJhIGZyb20gXCJyYVwiXG5pbXBvcnQgKiBhcyBsb2Rhc2ggZnJvbSBcImxvZGFzaFwiXG5pbXBvcnQgKiBhcyBsdSBmcm9tIFwibG9jYWxVdGlsc1wiXG5pbXBvcnQgRkljb24gZnJvbSBcInVpL0ljb25cIlxuXG5leHBvcnQgZGVmYXVsdCAoIGFwcCwgbG9jYWwgKSA9PiB7XG5cblx0bGV0IEljb24gPSBhcHAubG9hZCggRkljb24gKVxuXG5cdHJldHVybiAoIHsgcGxhY2VJZCwgcGxhY2VEZXNjciB9ICkgPT4ge1xuXHRcdGxldCBpZHMgPSByYSggKCkgPT4ge1xuXHRcdFx0bGV0IGNvbnRlbnQgPSBwbGFjZURlc2NyLmdldCggYGNvbnRlbnRgIClcblx0XHRcdHJldHVybiByYS5BcnJheSggbG9kYXNoLmtleXMoIGNvbnRlbnQgKS5zb3J0KCAoIGEsIGIgKSA9PiBsdS5jb21wYXJlKCBjb250ZW50WyBhIF0uaW5kZXgsIGNvbnRlbnRbIGIgXS5pbmRleCApICkgKVxuXHRcdH0gKVxuXHRcdGxldCBjb250ZW50ID0gcmEubWFwKCBpZHMsICggaWNvbklkLCBwb3NpdGlvbiApID0+IDxJY29uXG5cdFx0XHRwbGFjZUlkID0geyBwbGFjZUlkIH1cblx0XHRcdGljb25JZCA9IHsgaWNvbklkIH1cblx0XHRcdHBvc2l0aW9uID0geyBwb3NpdGlvbiB9XG5cdFx0XHRpY29uRGVzY3IgPSB7IHJhKCAoKSA9PiBhcHAuZ2V0RGV2aWNlKCBpY29uSWQgKSApIH1cblx0XHQvPiApXG5cdFx0cmV0dXJuIDxkaXY+XG5cdFx0XHQ8c3R5bGU+eyBgXG5cdFx0XHRcdC4keyBwbGFjZUlkIH0gLnBsYWNlLiR7IHBsYWNlSWQgfSB7XG5cdFx0XHRcdFx0ZGlzcGxheTogaW5pdGlhbDtcblx0XHRcdFx0fVxuXHRcdFx0YCB9PC9zdHlsZT5cblx0XHRcdDxkaXYgY2xhc3MgPSB7IGBwbGFjZSAkeyBwbGFjZUlkIH1gIH0gc3R5bGUgPSB7e1xuXHRcdFx0XHR0cmFuc2Zvcm06ICgpID0+IGB0cmFuc2xhdGVYKCAke1xuXHRcdFx0XHRcdC0oIGxvY2FsLnBsYWNlc1BhZ2VzWyBwbGFjZUlkIF0gfHwgMCApICogYXBwLm1lbnVXaWR0aCArIGFwcC5wbGFjZXNTaGlmdHNbIHBsYWNlSWQgXSB8fCAwXG5cdFx0XHRcdH1weCApYCxcblx0XHRcdH19ID57XG5cdFx0XHRcdCgpID0+IGNvbnRlbnRcblx0XHRcdH08L2Rpdj5cblx0XHQ8L2Rpdj5cblx0fVxufVxuIiwiaW1wb3J0IERMIGZyb20gXCJEYW1lcmF1TGV2ZW5zaHRlaW5cIlxuaW1wb3J0IHJhIGZyb20gXCJyYVwiXG5pbXBvcnQgKiBhcyBsb2Rhc2ggZnJvbSBcImxvZGFzaFwiXG5pbXBvcnQgKiBhcyBsdSBmcm9tIFwibG9jYWxVdGlsc1wiXG5pbXBvcnQgSVNjcm9sbCBmcm9tIFwiaXNjcm9sbFwiXG5cbmxldCBub3RBQ2hhciA9IGNoYXIgPT4gY2hhciA8PSBgIGAgfHwgY2hhciA9PSBgLWBcblxubGV0IGZ1enp5ID0gKCBtYXNrLCB0ZXh0ICkgPT4gREwoIG1hc2sudG9VcHBlckNhc2UoKSwgdGV4dC50b1VwcGVyQ2FzZSgpLCB7XG5cdHJlcGxhY2U6IEluZmluaXR5LFxuXHRkZWxldGU6IGNoYXIgPT4gbm90QUNoYXIoIGNoYXIgKSA/IDFlLTIgOiBJbmZpbml0eSxcblx0aW5zZXJ0OiBjaGFyID0+IG5vdEFDaGFyKCBjaGFyICkgPyAxZS0yIDogMSxcblx0dHJhbnNwb3NlOiAxLFxufSApXG5cbmZ1bmN0aW9uIHdhdGNoKCBkYXRhLCBjYiApIHtcblx0bGV0IHZcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIHYgPT0gbnVsbCApIHJhLmRldGFjaCggKCkgPT4ge1xuXHRcdFx0diA9IHJhKCBkYXRhIClcblx0XHRcdHJhKCAoKSA9PiB7XG5cdFx0XHRcdHYudmFsdWVPZigpXG5cdFx0XHRcdGNiKClcblx0XHRcdH0gKVxuXHRcdH0gKVxuXHRcdHJldHVybiB2LnZhbHVlT2YoKVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFwcCA9PiB7XG5cdGxldCBvcHRzLCAkID0ge31cblxuXHRsZXQgU2VhcmNoSXRlbSA9ICggeyBwbGFjZUlkIH0gKSA9PlxuXHRcdDxkaXYgY2xhc3MgPSB7IGBzZWFyY2hJdGVtICR7IHBsYWNlSWQgfWAgfSBvbnNjcm9sbHRhcCA9IHsgKCkgPT4gb3B0cy5nb3RvKCBwbGFjZUlkICkgfSA+XG5cdFx0XHQ8c3BhbiBjbGFzcyA9IFwiY2FwdGlvblwiID57ICgpID0+IG9wdHMucGxhY2VJbmZvc1sgcGxhY2VJZCBdLmNhcHRpb24gfTwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJwbGFjZXNcIiA+eyAoKSA9PiBvcHRzLnBsYWNlSW5mb3NbIHBsYWNlSWQgXS5wdGV4dCB9PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImNtZERlbGV0ZUZyb21Qcm9ncmFtXCIgPjwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJjbWRBcHBlbmRcIiA+PC9zcGFuPlxuXHRcdDwvZGl2PlxuXG5cdG9wdHMgPSByYSgge1xuXHRcdGdvdG8oIGlkICkge1xuXHRcdFx0aWYgKCAhaWQgKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdGxldCBwbGFjZUluZm8gPSBvcHRzLnBsYWNlSW5mb3NbIGlkIF1cblx0XHRcdH4oIGFwcC5zZWFyY2hBY3Rpb24gfHwgYXBwLmdvICkoIGlkLCBwbGFjZUluZm8gJiYgcGxhY2VJbmZvLnBsYWNlcyApXG5cdFx0fSxcblx0XHRnZXQgZGV2aWNlSWRzKCkgeyByZXR1cm4gcmEuQXJyYXkoIGFwcC5kZXZpY2VJZHMuZmlsdGVyKCBpZCA9PiBpZCAhPSBhcHAubWFpbiApICkgfSxcblx0XHRnZXQgcGxhY2VJbmZvcygpIHtcblx0XHRcdGxldCBjYWNoZSA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0Zm9yICggbGV0IGlkIG9mIGFwcC5kZXZpY2VJZHMgKSB7XG5cdFx0XHRcdGxldCBpbmZvID0gYXBwLmdldERldmljZSggaWQgKVxuXHRcdFx0XHRjYWNoZVsgaWQgXSA9IHtcblx0XHRcdFx0XHRpbmZvLFxuXHRcdFx0XHRcdGNhcHRpb246IGlkID09IGFwcC5tYWluID8gYNCY0LfQsdGA0LDQvdC90L7QtWAgOiBhcHAuZ2V0TWVzc2FnZSggaW5mbyApLFxuXHRcdFx0XHRcdHBsYWNlczogW10sXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAoIGxldCBpZCBvZiBhcHAuZGV2aWNlSWRzIClcblx0XHRcdFx0Zm9yICggbGV0IGtleSBvZiBsb2Rhc2gua2V5cyggY2FjaGVbIGlkIF0uaW5mby5jb250ZW50ICkgKVxuXHRcdFx0XHRcdGlmICggY2FjaGVbIGtleSBdIClcblx0XHRcdFx0XHRcdGNhY2hlWyBrZXkgXS5wbGFjZXMucHVzaCggaWQgKVxuXHRcdFx0bGV0IHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0Zm9yICggbGV0IGlkIG9mIGFwcC5kZXZpY2VJZHMgKSB7XG5cdFx0XHRcdGxldCBjID0gY2FjaGVbIGlkIF1cblx0XHRcdFx0bGV0IHB0ZXh0ID0gYy5wbGFjZXMubWFwKCBpZCA9PiBjYWNoZVsgaWQgXS5jYXB0aW9uICkuam9pbiggYCwgYCApXG5cdFx0XHRcdGlmICggcHRleHQgKVxuXHRcdFx0XHRcdHB0ZXh0ID0gYCAoJHsgcHRleHQgfSlgXG5cdFx0XHRcdHJldFsgaWQgXSA9IHsgaWQsIGNhcHRpb246IGMuY2FwdGlvbiB8fCBgPCoqKj5gLCBwbGFjZXM6IGMucGxhY2VzLCBwdGV4dCB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmEuSlNPTiggcmV0IClcblx0XHR9LFxuXHRcdGdldCBsYWJlbHMoKSB7IHJldHVybiByYS5rZXltYXAoIG9wdHMubGl2ZS5kZXZpY2VJZHMsIHBsYWNlSWQgPT4gPFNlYXJjaEl0ZW0gcGxhY2VJZCA9IHsgcGxhY2VJZCB9IC8+ICkgfSxcblx0XHRnZXQgZmlsdGVyZWQoKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSAkLm1hc2sucmFWYWx1ZVxuXHRcdFx0bGV0IGFyciA9IFtdXG5cdFx0XHRmb3IgKCBsZXQgaWQgb2YgdGhpcy5kZXZpY2VJZHMuZmlsdGVyKCBhcHAuc2VhcmNoRmlsdGVyIHx8IEJvb2xlYW4gKSApIHtcblx0XHRcdFx0bGV0IGkgPSBvcHRzLnBsYWNlSW5mb3NbIGlkIF1cblx0XHRcdFx0bGV0IGtleSA9IFtdXG5cdFx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdFx0a2V5LnB1c2goXG5cdFx0XHRcdFx0XHRmdXp6eSggdmFsdWUsIGkuY2FwdGlvbiApLFxuXHRcdFx0XHRcdFx0Ly8gPz8/IE1hdGgubWF4KCAuLi5pLnBsYWNlcy5tYXAoIGlkID0+IGZ1enp5KCB2YWx1ZSwgb3B0cy5wbGFjZUluZm9zWyBpZCBdLmNhcHRpb24gKSApICksXG5cdFx0XHRcdFx0XHRmdXp6eSggdmFsdWUsIGkuY2FwdGlvbiArIGAgYCArIGkucHRleHQgKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRpZiAoIGtleS5ldmVyeSggayA9PiBNYXRoLmFicyggayApID09IEluZmluaXR5ICkgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkucHVzaCggaS5jYXB0aW9uLnRvVXBwZXJDYXNlKCkgKVxuXHRcdFx0XHRhcnIucHVzaCggeyBpZCwga2V5IH0gKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJhLkFycmF5KCBhcnJcblx0XHRcdFx0LnNvcnQoICggYSwgYiApID0+IGxvZGFzaFxuXHRcdFx0XHRcdC56aXAoIGEua2V5LCBiLmtleSApXG5cdFx0XHRcdFx0Lm1hcCggcGFpciA9PiBsdS5jb21wYXJlKCAuLi5wYWlyICkgKVxuXHRcdFx0XHRcdC5yZWR1Y2UoICggYSwgYiApID0+IGEgfHwgYiApXG5cdFx0XHRcdClcblx0XHRcdFx0Lm1hcCggYSA9PiBhLmlkIClcblx0XHRcdClcblx0XHR9LFxuXHRcdGdldCBpdGVtcygpIHtcblx0XHRcdHJldHVybiByYS5BcnJheSggdGhpcy5maWx0ZXJlZC5tYXAoIGlkID0+IHRoaXMubGFiZWxzLmdldCggaWQgKSApIClcblx0XHR9LFxuXHR9IClcblx0d2luZG93Ll9zZWFyY2ggPSBvcHRzXG5cdHJldHVybiA8ZGl2XG5cdFx0b25kaWFsb2dzaG93ID0geyAoKSA9PiB7XG5cdFx0XHQkLnNjcm9sbGVyICYmICQuc2Nyb2xsZXIucmVmcmVzaCgpXG5cdFx0XHQvLyBUT0RPOiDRgNCw0LfQsNCx0YDQsNGG0YbQsCwg0LAg0YbRliDRgtGA0Y3QsdCwINC30LDRhtGW0YDQsNGG0Ywg0L/QvtGI0YPQuj9cblx0XHRcdCQubWFzay5yYVZhbHVlID0gYGBcblx0XHR9IH1cblx0PlxuXHRcdDxmb3JtXG5cdFx0XHRvbnN1Ym1pdCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0XHRldmVudCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRcdG9wdHMuZ290byggb3B0cy5maWx0ZXJlZFsgMCBdIClcblx0XHRcdH0gfVxuXHRcdD5cblx0XHRcdDxpbnB1dCBuYW1lID0gXCJtYXNrXCIgdHlwZSA9IFwidGV4dFwiIGF1dG9mb2N1cyA9IFwiYXV0b2ZvY3VzXCIgb25jcmVhdGUgPSB7IGV2ZW50ID0+ICQubWFzayA9IGV2ZW50LnRhcmdldCB9IC8+XG5cdFx0XHQ8ZGl2IGNsYXNzID0gXCJzY3JvbGxcIiBvbmNyZWF0ZSA9IHsgZXZlbnQgPT4gJC5zY3JvbGwgPSBldmVudC50YXJnZXQgfSA+XG5cdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcyA9IFwiaXRlbXNcIiA+e1xuXHRcdFx0XHRcdFx0d2F0Y2goICgpID0+IG9wdHMuaXRlbXMsICgpID0+IHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhJC5zY3JvbGxlciApXG5cdFx0XHRcdFx0XHRcdFx0JC5zY3JvbGxlciA9IG5ldyBJU2Nyb2xsKCAkLnNjcm9sbCwge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW91c2VXaGVlbDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdHNjcm9sbGJhcnM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXA6IGBzY3JvbGx0YXBgLFxuXHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0JC5zY3JvbGxlci5yZWZyZXNoKClcblx0XHRcdFx0XHRcdH0sIDEwMCApIClcblx0XHRcdFx0XHR9PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcyA9IFwic2Nyb2xsQXJlYUJvdHRvbUZpbGxlclwiIC8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9mb3JtPlxuXHQ8L2Rpdj5cbn1cbiIsImltcG9ydCBETCBmcm9tIFwiRGFtZXJhdUxldmVuc2h0ZWluXCJcbmltcG9ydCByYSBmcm9tIFwicmFcIlxuaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gXCJsb2Rhc2hcIlxuaW1wb3J0ICogYXMgbHUgZnJvbSBcImxvY2FsVXRpbHNcIlxuaW1wb3J0ICogYXMgaHRtbHV0aWxzIGZyb20gXCJodG1sdXRpbHNcIlxuaW1wb3J0IElTY3JvbGwgZnJvbSBcImlzY3JvbGxcIlxuXG5sZXQgbm90QUNoYXIgPSBjaGFyID0+IGNoYXIgPD0gYCBgIHx8IGNoYXIgPT0gYC1gXG5cbmxldCBmdXp6eSA9ICggbWFzaywgdGV4dCApID0+IERMKCBtYXNrLnRvVXBwZXJDYXNlKCksIHRleHQudG9VcHBlckNhc2UoKSwge1xuXHRyZXBsYWNlOiBJbmZpbml0eSxcblx0ZGVsZXRlOiBjaGFyID0+IG5vdEFDaGFyKCBjaGFyICkgPyAxZS0yIDogSW5maW5pdHksXG5cdGluc2VydDogY2hhciA9PiBub3RBQ2hhciggY2hhciApID8gMWUtMiA6IDEsXG5cdHRyYW5zcG9zZTogMSxcbn0gKVxuXG5mdW5jdGlvbiB3YXRjaCggZGF0YSwgY2IgKSB7XG5cdGxldCB2XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCB2ID09IG51bGwgKSByYS5kZXRhY2goICgpID0+IHtcblx0XHRcdHYgPSByYSggZGF0YSApXG5cdFx0XHRyYSggKCkgPT4ge1xuXHRcdFx0XHR2LnZhbHVlT2YoKVxuXHRcdFx0XHRjYigpXG5cdFx0XHR9IClcblx0XHR9IClcblx0XHRyZXR1cm4gdi52YWx1ZU9mKClcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBhcHAgPT4ge1xuXHRsZXQgb3B0cywgJCA9IHt9XG5cblx0bGV0IFNlYXJjaEl0ZW0gPSB0ZW1wbGF0ZU5hbWUgPT5cblx0XHQvLyBUT0RPOiBjaGFuZ2UgJHsgdGVtcGxhdGVOYW1lIH0gdG8gc29tZSBpbnZhbGlkIGlkZW50aWZpZXIgbGlrZSAkeyBfSVNfTk9UX0RFQ0xBUkVEXyB9IGFuZCB2YXJpZHkgdGhhdCBicm93c2VyIGNvbnNvbGUgd2lsbCBzaG93IHNvbWUgZXJyb3Jcblx0XHQ8ZGl2IGNsYXNzID0geyBgc2VhcmNoSXRlbSBzZWFyY2hQaWMgJHsgdGVtcGxhdGVOYW1lIH1gIH0gb25zY3JvbGx0YXAgPSB7ICgpID0+IG9wdHMuZ290byggdGVtcGxhdGVOYW1lICkgfSA+XG5cdFx0XHR7W118fDxzcGFuIGNsYXNzID0gXCJpbWdcIiA+eyBodG1sdXRpbHMuaW1wb3J0Q29tcG9uZW50KCBhcHAuaWNvbnNbIHRlbXBsYXRlTmFtZSBdICkgfTwvc3Bhbj59XG5cdFx0XHQ8c3BhbiBjbGFzcyA9IFwiY2FwdGlvblwiID57IHRlbXBsYXRlTmFtZSB9PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImNtZERlbGV0ZUZyb21Qcm9ncmFtXCIgPjwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJjbWRBcHBlbmRcIiA+PC9zcGFuPlxuXHRcdDwvZGl2PlxuXG5cdG9wdHMgPSByYSgge1xuXHRcdGdvdG8oIHRlbXBsYXRlTmFtZSApIHtcblx0XHRcdGlmICggIXRlbXBsYXRlTmFtZSApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0YXBwLnNlYXJjaEFjdGlvbiggdGVtcGxhdGVOYW1lIClcblx0XHR9LFxuXHRcdGdldCB0ZW1wbGF0ZU5hbWVzKCkgeyByZXR1cm4gcmEuQXJyYXkoIE9iamVjdC5rZXlzKCBhcHAuaWNvbnMgKSApIH0sXG5cdFx0Ly8gZ2V0IHRlbXBsYXRlcygpIHsgcmV0dXJuIHJhLkFycmF5KCB0aGlzLnRlbXBsYXRlTmFtZXMubWFwKCB0ZW1wbGF0ZU5hbWUgPT4gYXBwLmljb25zWyB0ZW1wbGF0ZU5hbWUgXSApICkgfSxcblx0XHQvLyBUT0RPOiBjaGFuZ2Ugb3B0cy5saXZlLnRlbXBsYXRlTmFtZXMgdG8gc29tZSBjb25zdGFudCBsaWtlIHt9IGFuZCB2ZXJpZnkgdGhhdCBicm93c2VyIGNvbnNvbGUgd2lsbCBzaG93IHNvbWUgZXJyb3Jcblx0XHRnZXQgbGFiZWxzKCkgeyByZXR1cm4gcmEua2V5bWFwKCBvcHRzLmxpdmUudGVtcGxhdGVOYW1lcywgdGVtcGxhdGVOYW1lID0+IFNlYXJjaEl0ZW0oIHRlbXBsYXRlTmFtZSApICkgfSxcblx0XHRnZXQgZmlsdGVyZWQoKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSAkLm1hc2sucmFWYWx1ZVxuXHRcdFx0bGV0IGFyciA9IFtdXG5cdFx0XHRmb3IgKCBsZXQgaWQgb2YgdGhpcy50ZW1wbGF0ZU5hbWVzLmZpbHRlciggYXBwLnNlYXJjaEZpbHRlciB8fCBCb29sZWFuICkgKSB7XG5cdFx0XHRcdGxldCBrZXkgPSBbXVxuXHRcdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRcdGtleS5wdXNoKCBmdXp6eSggdmFsdWUsIGlkICkgKVxuXHRcdFx0XHRcdGlmICgga2V5LmV2ZXJ5KCBrID0+IE1hdGguYWJzKCBrICkgPT0gSW5maW5pdHkgKSApXG5cdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGtleS5wdXNoKCBpZC50b1VwcGVyQ2FzZSgpIClcblx0XHRcdFx0YXJyLnB1c2goIHsgaWQsIGtleSB9IClcblx0XHRcdH1cblx0XHRcdHJldHVybiByYS5BcnJheSggYXJyXG5cdFx0XHRcdC5zb3J0KCAoIGEsIGIgKSA9PiBsb2Rhc2hcblx0XHRcdFx0XHQuemlwKCBhLmtleSwgYi5rZXkgKVxuXHRcdFx0XHRcdC5tYXAoIHBhaXIgPT4gbHUuY29tcGFyZSggLi4ucGFpciApIClcblx0XHRcdFx0XHQucmVkdWNlKCAoIGEsIGIgKSA9PiBhIHx8IGIgKVxuXHRcdFx0XHQpXG5cdFx0XHRcdC5tYXAoIGEgPT4gYS5pZCApXG5cdFx0XHQpXG5cdFx0fSxcblx0XHRnZXQgaXRlbXMoKSB7XG5cdFx0XHRyZXR1cm4gcmEuQXJyYXkoIHRoaXMuZmlsdGVyZWQubWFwKCBpZCA9PiB0aGlzLmxhYmVscy5nZXQoIGlkICkgKSApXG5cdFx0fSxcblx0fSApXG5cdHdpbmRvdy5fc2VhcmNoID0gb3B0c1xuXHRyZXR1cm4gPGRpdlxuXHRcdG9uZGlhbG9nc2hvdyA9IHsgKCkgPT4ge1xuXHRcdFx0JC5zY3JvbGxlciAmJiAkLnNjcm9sbGVyLnJlZnJlc2goKVxuXHRcdFx0Ly8gVE9ETzog0YDQsNC30LDQsdGA0LDRhtGG0LAsINCwINGG0ZYg0YLRgNGN0LHQsCDQt9Cw0YbRltGA0LDRhtGMINC/0L7RiNGD0Lo/XG5cdFx0XHQkLm1hc2sucmFWYWx1ZSA9IGBgXG5cdFx0fSB9XG5cdD5cblx0XHQ8Zm9ybVxuXHRcdFx0b25zdWJtaXQgPSB7IGV2ZW50ID0+IHtcblx0XHRcdFx0ZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0XHRvcHRzLmdvdG8oIG9wdHMuZmlsdGVyZWRbIDAgXSApXG5cdFx0XHR9IH1cblx0XHQ+XG5cdFx0XHQ8aW5wdXQgbmFtZSA9IFwibWFza1wiIHR5cGUgPSBcInRleHRcIiBhdXRvZm9jdXMgPSBcImF1dG9mb2N1c1wiIG9uY3JlYXRlID0geyBldmVudCA9PiAkLm1hc2sgPSBldmVudC50YXJnZXQgfSAvPlxuXHRcdFx0PGRpdiBjbGFzcyA9IFwic2Nyb2xsXCIgb25jcmVhdGUgPSB7IGV2ZW50ID0+ICQuc2Nyb2xsID0gZXZlbnQudGFyZ2V0IH0gPlxuXHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3MgPSBcIml0ZW1zXCIgPntcblx0XHRcdFx0XHRcdHdhdGNoKCAoKSA9PiBvcHRzLml0ZW1zLCAoKSA9PiBzZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmICggISQuc2Nyb2xsZXIgKVxuXHRcdFx0XHRcdFx0XHRcdCQuc2Nyb2xsZXIgPSBuZXcgSVNjcm9sbCggJC5zY3JvbGwsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vdXNlV2hlZWw6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRzY3JvbGxiYXJzOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFwOiBgc2Nyb2xsdGFwYCxcblx0XHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdCQuc2Nyb2xsZXIucmVmcmVzaCgpXG5cdFx0XHRcdFx0XHR9LCAxMDAgKSApXG5cdFx0XHRcdFx0fTwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3MgPSBcInNjcm9sbEFyZWFCb3R0b21GaWxsZXJcIiAvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZm9ybT5cblx0PC9kaXY+XG59XG4iLCJpbXBvcnQgKiBhcyBodG1sdXRpbHMgZnJvbSBcImh0bWx1dGlsc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGFwcCA9PiB7XG5cdGxldCBqc29uXG5cdHJldHVybiA8ZGl2IG9uZGlhbG9nc2hvdyA9IHsgKCkgPT4ganNvbi52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KCBhcHAuZ2V0RGV2aWNlKCBhcHAuYWN0aXZlRGV2aWNlSWQgKSwgbnVsbCwgMyApIH0gPlxuXHRcdDxmb3JtXG5cdFx0XHRvbnN1Ym1pdCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0XHRldmVudCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRcdGxldCB0ZXh0ID0ganNvbi52YWx1ZS50cmltKCkgfHwgbnVsbFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRleHQgPSB0ZXh0ICYmIEpTT04ucGFyc2UoIHRleHQgKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFsZXJ0KCBlcnJvciApXG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVidWdnZXJcblx0XHRcdFx0aWYgKCB0ZXh0IClcblx0XHRcdFx0XHRhcHAuc2F2ZURldmljZSggYXBwLmFjdGl2ZURldmljZUlkLCB0ZXh0IClcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHR9IH1cblx0XHQ+XG5cdFx0XHQ8dGV4dGFyZWFcblx0XHRcdFx0bmFtZSA9IFwianNvblwiXG5cdFx0XHRcdGF1dG9mb2N1cyA9IFwiYXV0b2ZvY3VzXCJcblx0XHRcdFx0b25jcmVhdGUgPSB7IGV2ZW50ID0+IGpzb24gPSBldmVudC50YXJnZXQgfVxuXHRcdFx0XHRzdHlsZSA9IHt7XG5cdFx0XHRcdFx0cG9zaXRpb246IGBhYnNvbHV0ZWAsXG5cdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0XHR0b3A6IGAxMG1tYCxcblx0XHRcdFx0XHRib3R0b206IGAxNW1tYCxcblx0XHRcdFx0XHRmb250U2l6ZTogYDUwJWAsXG5cdFx0XHRcdH19XG5cdFx0XHQvPlxuXHRcdFx0PGFcblx0XHRcdFx0Y2xhc3MgPSBcInNhdmVcIlxuXHRcdFx0XHRocmVmID0gXCJqYXZhc2NyaXB0OnZvaWQoMClcIlxuXHRcdFx0XHR0YXJnZXQgPSBcIl9zZWxmXCJcblx0XHRcdFx0b250b3VjaCA9IHsgaHRtbHV0aWxzLlN1Ym1pdCB9XG5cdFx0XHRcdHN0eWxlID0ge3tcblx0XHRcdFx0XHRwb3NpdGlvbjogYGFic29sdXRlYCxcblx0XHRcdFx0XHRkaXNwbGF5OiBgYmxvY2tgLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdFx0aGVpZ2h0OiBgMTBtbWAsXG5cdFx0XHRcdFx0Ym90dG9tOiBgMGAsXG5cdFx0XHRcdH19XG5cdFx0XHQ+U2F2ZTwvYT5cblx0XHQ8L2Zvcm0+XG5cdDwvZGl2PlxufVxuIiwiaW1wb3J0IEZCYWNrZ3JvdW5kIGZyb20gXCJ1aS9CYWNrZ3JvdW5kXCJcblxuZXhwb3J0IGRlZmF1bHQgYXBwID0+IHtcblx0bGV0IEJhY2tncm91bmQgPSBhcHAubG9hZCggRkJhY2tncm91bmQgKVxuXHRyZXR1cm4gKCkgPT4gPGRpdiBjbGFzcyA9IFwic3RhcnR1cFNjcmVlblwiID5cblx0XHQ8QmFja2dyb3VuZCAvPlxuXHRcdDxkaXYgY2xhc3MgPSBcImFwcF9jb250ZW50XCIgPlxuXHRcdFx0PGRpdiBjbGFzcyA9IFwiYmFja2luZ19zaXplZFwiID5cblx0XHRcdFx0PHA+0JTQvtCx0YDQviDQv9C+0LbQsNC70L7QstCw0YLRjCDQsiDQktCw0Yg8YnIvPtCj0LzQvdGL0Lkg0JTQvtC8ITwvcD5cblx0XHRcdFx0PGRpdiBjbGFzcyA9IFwidGVtcGxhdGVzXCIgPlxuXHRcdFx0XHRcdDxwPtCf0L7QttCw0LvRg9C50YHRgtCwLCDQstGL0LHQtdGA0LjRgtC1INC80LXRgdGC0L4sINCz0LTQtSDQuNGB0L/QvtC70YzQt9GD0LXRgtGB0Y8g0Y3RgtC+0YIg0L/Rg9C70YzRgjo8L3A+XG5cdFx0XHRcdFx0PHVsIGNsYXNzID0gXCJob3VzZVRlbXBsYXRlc1wiID57ICgpID0+ICggYXBwLnRlbXBsYXRlcyB8fCBbXSApLmNvbmNhdCggWyB7XG5cdFx0XHRcdFx0XHRtZW51OiBg0L3QsNGH0LDRgtGMINGBINGH0LjRgdGC0L7Qs9C+INC70LjRgdGC0LBgLFxuXHRcdFx0XHRcdFx0cnU6IGDQnNC+0Lkg0LTQvtC8YCxcblx0XHRcdFx0XHRcdGVuOiBgSG9tZWAsXG5cdFx0XHRcdFx0XHR0eXBlOiBgcGxhY2VgLFxuXHRcdFx0XHRcdH0gXSApLm1hcCggaG91c2VUZW1wbGF0ZSA9PlxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzID0gXCJob3VzZVRlbXBsYXRlXCIgb250b3VjaCA9IHsgKCkgPT4gYXBwLnNldFRlbXBsYXRlKCBob3VzZVRlbXBsYXRlICkgfSA+e1xuXHRcdFx0XHRcdFx0XHRob3VzZVRlbXBsYXRlLm1lbnUgfHwgYXBwLmdldE1lc3NhZ2UoIGhvdXNlVGVtcGxhdGUgKVxuXHRcdFx0XHRcdFx0fTwvbGk+XG5cdFx0XHRcdFx0KSB9PC91bD5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxkaXYgY2xhc3MgPSBcImxvYWRpbmdcIiA+PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG59XG4iLCJpbXBvcnQgRk1lbnUgZnJvbSBcInVpL01lbnVcIlxuaW1wb3J0IEZDb21tYW5kIGZyb20gXCJ1aS9Db21tYW5kXCJcbmltcG9ydCAqIGFzIGxvZGFzaCBmcm9tIFwibG9kYXNoXCJcblxuZXhwb3J0IGRlZmF1bHQgYXBwID0+IHtcblx0bGV0IE1lbnUgPSBhcHAubG9hZCggRk1lbnUgKVxuXHRsZXQgQ29tbWFuZCA9IGFwcC5sb2FkKCBGQ29tbWFuZCApXG5cdC8vVE9ETzogY2hlY2sgdGhhdCBleGNlcHRpb24gaXMgc2VlbiB3aGVuIGNoYW5naW5nIGFwcC5nZXRNZXNzYWdlKCB0aGVtZSApIHRvIGdldE1lc3NhZ2UoIHRoZW1lIClcblx0Ly9UT0RPOiDQt9Cw0LPQsNC70L7QstCw0Log0LPRjdGC0LDQs9CwINC80LXQvdGOINC90LUg0L/QsNCy0ZbQvdC10L0g0LHRi9GG0Ywg0L3QsNC30LLQsNC5INC80LXRgdGG0LAsINCwINC90LDQt9Cy0LDQuSDQvNC10L3Rji5cblx0cmV0dXJuIDxNZW51PnsgbG9kYXNoLnBhaXJzKCBhcHAudGhlbWVzICkubWFwKCAoIFsgbmFtZSwgdGhlbWUgXSApID0+IDxDb21tYW5kXG5cdFx0bWVzc2FnZSA9IHsgYXBwLmdldE1lc3NhZ2UoIHRoZW1lLmNhcHRpb24gKSB9XG5cdFx0b25jbGljayA9IHsgKCkgPT4gYXBwLnRoZW1lTmFtZSA9IG5hbWUgfVxuXHQvPiApIH08L01lbnU+XG59XG4iLCJpbXBvcnQgKiBhcyBodG1sdXRpbHMgZnJvbSBcImh0bWx1dGlsc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGFwcCA9PiAoKSA9PiA8ZGl2IGNsYXNzID0gXCJ0b3BcIiA+XG5cdDxkaXYgY2xhc3MgPSBcImJhY2tpbmdcIiA+XG5cdFx0PGh0bWx1dGlscy5DZW50ZXJlZD57ICgpID0+XG5cdFx0XHRhcHAuY2FwdGlvblxuXHRcdFx0LnRyaW0oKS5yZXBsYWNlKCAvKFxccnxcXG58XFxzKSsvZywgYCBgICkudG9Mb3dlckNhc2UoKS5zbGljZSggMCwgMTggKVxuXHRcdH08L2h0bWx1dGlscy5DZW50ZXJlZD5cblx0PC9kaXY+XG48L2Rpdj5cbiIsIlwidXNlIHN0cmljdFwiXG5cbmxldCBjb3VudGVyID0gMFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVpZCggb2JqICkge1xuXHRsZXQgaSA9ICggKytjb3VudGVyICkudG9TdHJpbmcoIDM2IClcblx0bGV0IHIgPSBwYXJzZUludCggKCAxICsgTWF0aC5yYW5kb20oKSApLnRvU3RyaW5nKCkuc2xpY2UoIDIsIDE3ICkgKS50b1N0cmluZyggMzYgKVxuXHRsZXQgaWQgPSAoIHIubGVuZ3RoICsgOSApLnRvU3RyaW5nKCAzNiApICsgciArIGlcblx0aWYgKCBvYmogPT0gbnVsbCApXG5cdFx0cmV0dXJuIGlkXG5cdGVsc2Uge1xuXHRcdG9iai51aWQgPSBpZFxuXHRcdHJldHVybiBvYmpcblx0fVxufVxuIiwiLypcbnBvc3QgL2RldmljZXMge1wiUFwiOjF9XG4qL1xuaW1wb3J0IFwiYnJvd3Nlci1uZXh0dGlja1wiXG5pbXBvcnQgXCJwbGF0Zm9ybVwiXG5pbXBvcnQgXCJodG1scG9seWZpbGxcIlxuaW1wb3J0IFwidHJhY2tcIlxuaW1wb3J0IFwiZ2VzdHVyZVwiXG5pbXBvcnQgXCJjb2xvcnNcIlxuXG5pbXBvcnQgKiBhcyBsdSBmcm9tIFwibG9jYWxVdGlsc1wiXG5pbXBvcnQgcmEgZnJvbSBcInJhXCJcbmltcG9ydCAqIGFzIGNvIGZyb20gXCJjb1wiXG5pbXBvcnQgKiBhcyBsb2Rhc2ggZnJvbSBcImxvZGFzaFwiXG5cbk9iamVjdC5hc3NpZ24oIHdpbmRvdywgeyBsdSwgcmEsIGNvLCBsb2Rhc2ggfSApXG5cbndpbmRvdy5fID0ge1xuXHRCdWZmZXI6IE9iamVjdC5hc3NpZ24oIEJ1ZmZlciwgeyBwYXJzZTogc3RyID0+IHtcblx0XHRsZXQgcmV0ID0gW11cblx0XHRzdHIucmVwbGFjZSggL1xcYlxcd1xcdz9cXGIvZywgeCA9PiByZXQucHVzaCggTnVtYmVyLnBhcnNlSW50KCBgMHgkeyB4IH1gICkgKSApXG5cdFx0cmV0dXJuIG5ldyBCdWZmZXIoIHJldCApXG5cdH0gfSApLFxuXHRkZWJ1ZyggZiApIHtcblx0XHRkZWJ1Z2dlclxuXHRcdHJldHVybiBmKClcblx0fSxcbn1cblN5c3RlbS5pbXBvcnQoIGBuZXRyby9tb2RlbWAgKS50aGVuKCBtID0+IHdpbmRvdy5fLm1vZGVtID0gbSApXG5TeXN0ZW0uaW1wb3J0KCBgZGV2ZGJgICkudGhlbiggbSA9PiB3aW5kb3cuXy5kZXZkYiA9IG0gKVxuU3lzdGVtLmltcG9ydCggYHJhYCApLnRoZW4oIG0gPT4gd2luZG93Ll8ucmEgPSBtIClcblN5c3RlbS5pbXBvcnQoIGBjb2AgKS50aGVuKCBtID0+IHdpbmRvdy5fLmNvID0gbSApXG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCBldmVudCApIHtcblx0aWYgKCBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSggYHJlbGAgKSA9PSBgZXh0ZXJuYWxgIClcblx0XHRyZXR1cm5cblx0Zm9yICggbGV0IEMgb2YgWyB3aW5kb3cuSFRNTElucHV0RWxlbWVudCwgd2luZG93LkhUTUxUZXh0QXJlYUVsZW1lbnQsIHdpbmRvdy5IVE1MT3B0aW9uRWxlbWVudCwgd2luZG93LkhUTUxCdXR0b25FbGVtZW50IF0gKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgQyApXG5cdFx0XHRyZXR1cm5cblx0Ly8gYXR0ZW1wdCB0byB1c2UgbmF0aXZlIHNjcm9sbGluZyAtIHVuc3VjY2Vzc2Z1bGxcblx0Ly8gbGV0IEMgPSBldmVudC50YXJnZXRcblx0Ly8gd2hpbGUgKCBDICYmIEMuY2xhc3NMaXN0ICkge1xuXHQvLyBcdGlmICggQy5jbGFzc0xpc3QuY29udGFpbnMoIGBzY3JvbGxgICkgKVxuXHQvLyBcdFx0cmV0dXJuXG5cdC8vIFx0QyA9IEMucGFyZW50Tm9kZVxuXHQvLyB9XG5cdGV2ZW50LnByZXZlbnREZWZhdWx0KClcbn1cblxuZm9yICggbGV0IHR5cGUgb2YgWyBgdG91Y2hzdGFydGAsIGB0b3VjaG1vdmVgLCBgdG91Y2hlbmRgLCBgdG91Y2hjYW5jZWxgIF0gKVxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgcHJldmVudERlZmF1bHQgKVxuXG5sZXQgTE9HID0gZnVuY3Rpb24gKCBzdHIgKSB7XG5cdC8vIGlmICggU3RyaW5nKCBzdHIgKSA9PSBgdW5kZWZpbmVkYCApXG5cdC8vIFx0ZGVidWdnZXJcblx0Y29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApXG5cdHdpbmRvdy5fQUxFUlQgJiYgd2luZG93Ll9BTEVSVCggc3RyIClcblx0bGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cdHhoci5vcGVuKCBgUE9TVGAsIGAvbG9nPyR7IGVuY29kZVVSSUNvbXBvbmVudCggc3RyICkgfWAgKVxuXHR4aHIub25lcnJvciA9IGxvZGFzaC5ub29wXG5cdHhoci5zZW5kKClcblx0cmV0dXJuIHN0clxufVxud2luZG93LkxPRyA9IExPR1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggYGVycm9yYCwgZnVuY3Rpb24gb25FcnJvciggZSApIHtcblx0aWYgKCAhZS5tZXNzYWdlLm1hdGNoKCA0MDQgKSAmJiAhb25FcnJvci5wcm9jZXNzaW5nICkge1xuXHRcdG9uRXJyb3IucHJvY2Vzc2luZyA9IHRydWVcblx0XHR0cnkge1xuXHRcdFx0TE9HKCBgJHsgZS5tZXNzYWdlLnJlZCB9IGF0ICR7IGUubGluZW5vIH06JHsgZS5jb2xubyB9IGluICR7IGUuZmlsZW5hbWUgfWAgKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdG9uRXJyb3IucHJvY2Vzc2luZyA9IGZhbHNlXG5cdFx0fVxuXHR9XG59IClcblxubGV0IG9uZXJyb3IgPSB3aW5kb3cub25lcnJvclxud2luZG93Lm9uZXJyb3IgPSBmdW5jdGlvbiAoIG1lc3NhZ2UsIHVybCwgbGluZSwgY29sdW1uLCBlcnJvciApIHtcblx0bGV0IHJldFxuXHRpZiAoIGVycm9yICkge1xuXHRcdExPRyggYHN0YWNrOiBgICsgZXJyb3Iuc3RhY2sgKVxuXHR9XG5cdGlmICggb25lcnJvciApIHtcblx0XHR0cnkge1xuXHRcdFx0d2luZG93Lm9uZXJyb3IgPSBvbmVycm9yXG5cdFx0XHRyZXQgPSBvbmVycm9yLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdG9uZXJyb3IgPSB3aW5kb3cub25lcnJvclxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0XG59XG5cbi8vIGltcG9ydCBcInRvdWNoTG9nXCJcbi8vIGltcG9ydCBcInRvdWNoU2hvd1wiXG4vLyBpbXBvcnQgXCJ0b3VjaGVzXCJcblxuaW1wb3J0ICogYXMgY29tcG9uZW50cyBmcm9tIFwiY29tcG9uZW50c1wiXG53aW5kb3cuX18gPSBjb21wb25lbnRzLmNyZWF0ZUVsZW1lbnRcblxuZnVuY3Rpb24gc2NyaXB0KCB0ZXh0ICkge1xuXHRsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYHNjcmlwdGAgKVxuXHRzY3JpcHQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0ZXh0ICkgKVxuXHRyZXR1cm4gc2NyaXB0XG59XG5cbmNvLmdvKCBmdW5jdGlvbiogKCkge1xuXHRsZXQgaHRtbCA9IHdpbmRvdy5jYWNoZVVybFJlc291cmNlKCBgLi9tYWluLmh0bWxgIClcblx0aHRtbCA9IHlpZWxkIGh0bWxcblxuXHRsZXQgZGF0YSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXG5cdGxldCB0bXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgZGl2YCApXG5cdHRtcC5pbm5lckhUTUwgPSBodG1sXG5cdHRtcCA9IHRtcC5jaGlsZHJlblsgMCBdXG5cdGxldCBjaGlsZHJlbiA9IFtdXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IHRtcC5jaGlsZE5vZGVzLmxlbmd0aDsgKytpIClcblx0XHRjaGlsZHJlbi5wdXNoKCB0bXAuY2hpbGROb2Rlc1sgaSBdIClcblx0Y2hpbGRyZW4uZm9yRWFjaCggYyA9PiB0bXAucmVtb3ZlQ2hpbGQoIGMgKSApXG5cdGNoaWxkcmVuLmZvckVhY2goIGMgPT4ge1xuXHRcdGlmICggYyBpbnN0YW5jZW9mIEhUTUxTY3JpcHRFbGVtZW50IClcblx0XHRcdGMgPSBzY3JpcHQoIGMuaW5uZXJIVE1MIClcblx0XHRkYXRhLmFwcGVuZENoaWxkKCBjIClcblx0fSApXG5cblx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggZGF0YSApXG59IClcblxuLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIC8vIFRPRE86INCy0YvQtNCw0LvRltGG0Ywg0L/QsNGB0YzQu9GPINCy0YvRgdGC0LDQstGLLiDQndCw0LTRgtCwINGB0YLRgNCw0YjQvdCwINGP0L3QviDQtNC30ZHRgNCz0LDQtdGG0YbQsCDQv9GA0Ysg0L/QtdGA0LDQt9Cw0LPRgNGD0LfRhtGLXG4vLyBcdGBtZXNzYWdlYCxcbi8vIFx0ZXZlbnQgPT4ge1xuLy8gXHRcdGlmICggZXZlbnQgJiYgZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLndoYXQgPT0gYHVybFJlc291cmNlVXBkYXRlZGAgKVxuLy8gXHRcdFx0d2luZG93LnNldFRpbWVvdXQoXG4vLyBcdFx0XHRcdCgpID0+IHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKSxcbi8vIFx0XHRcdFx0MTAwMFxuLy8gXHRcdFx0KVxuLy8gXHR9LFxuLy8gXHRmYWxzZVxuLy8gKVxuIiwiLy8gQ2FuIG5vdCB1c2UgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2Vic29ja2V0LXN0cmVhbVxuLy8gYmVjYXVzZSBpdCB1c2VzIHdzLCB3aGljaCBpcyBub3QgcHVyZSBqYXZhc2NyaXB0XG5cbmltcG9ydCBzdHJlYW0gZnJvbSBcInN0cmVhbVwiXG5cbmV4cG9ydCBkZWZhdWx0IHdlYnNvY2tldCA9PiB7XG5cdGlmICggdHlwZW9mIHdlYnNvY2tldCA9PSBgc3RyaW5nYCApXG5cdFx0d2Vic29ja2V0PSBuZXcgV2ViU29ja2V0KCB3ZWJzb2NrZXQgKVxuXHQvLyB3ZWJzb2NrZXQuYmluYXJ5VHlwZSA9IGBhcnJheWJ1ZmZlcmBcblx0ZnVuY3Rpb24gY2xvc2VXZWJzb2NrZXQoKSB7XG5cdFx0d2Vic29ja2V0LmNsb3NlKClcblx0fVxuXHRmdW5jdGlvbiBzZXRFdmVudHMoKSB7XG5cdFx0d2Vic29ja2V0Lm9uZXJyb3IgPSBvbmVycm9yXG5cdFx0d2Vic29ja2V0Lm9uY2xvc2UgPSBvbmNsb3NlXG5cdFx0d2Vic29ja2V0Lm9ubWVzc2FnZSA9IG9ubWVzc2FnZVxuXHR9XG5cdGZ1bmN0aW9uIG9uZXJyb3IoIGV2ZW50ICkge1xuXHRcdHJldC5lbWl0KCBgZXJyb3JgLCBldmVudCApXG5cdFx0cHJvY2Vzcy5uZXh0VGljayggY2xvc2VXZWJzb2NrZXQgKVxuXHR9XG5cdGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG5cdFx0cmV0LnB1c2goIG51bGwgKVxuXHR9XG5cdGZ1bmN0aW9uIG9ubWVzc2FnZSggZXZlbnQgKSB7XG5cdFx0cmV0LnB1c2goIG5ldyBCdWZmZXIoIGV2ZW50LmRhdGEgKSApXG5cdH1cblx0ZnVuY3Rpb24gc2VuZCggY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayApIHtcblx0XHR0cnkge1xuXHRcdFx0eyBsZXQgc3RyXG5cdFx0XHRcdC8vIGNvbnZlcnQgdG8gc3RyaW5nIGlmIHBvc3NpYmxlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZVxuXHRcdFx0XHQvLyBUT0RPOiBkbyB0aGlzIHVuZGVyIGNvbmRpdGlvbiBvZiBkZWJ1ZyB2ZXJzaW9uIG9yIGRlYnVnZ2luZ1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBjaHVuayAhPSBgc3RyaW5nYCAmJiBCdWZmZXIuY29tcGFyZSggbmV3IEJ1ZmZlciggc3RyID0gU3RyaW5nKCBjaHVuayApICksIG5ldyBCdWZmZXIoIFsgLi4uY2h1bmsgXSApICkgPT0gMCApXG5cdFx0XHRcdFx0Y2h1bmsgPSBzdHJcblx0XHRcdH1cblx0XHRcdHdlYnNvY2tldC5zZW5kKCBjaHVuayApXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soIGVycm9yIClcblx0XHR9XG5cdFx0Y2FsbGJhY2soKVxuXHR9XG5cdGZ1bmN0aW9uIGNsb3NlZCggY2FsbGJhY2sgKSB7XG5cdFx0Y2FsbGJhY2soIG5ldyBFcnJvciggYHdlYnNvY2tldCBpcyBjbG9zZWRgICkgKVxuXHR9XG5cdGxldCByZXQgPSBuZXcgc3RyZWFtLkR1cGxleCgge1xuXHRcdHJlYWQoKSB7IC8qIG5vLW9wICovIH0sXG5cdFx0d3JpdGUoIGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2sgKSB7XG5cdFx0XHRpZiAoIHdlYnNvY2tldC5yZWFkeVN0YXRlID09IFdlYlNvY2tldC5DT05ORUNUSU5HICkge1xuXHRcdFx0XHR3ZWJzb2NrZXQub25jbG9zZSA9IGV2ZW50ID0+IHtcblx0XHRcdFx0XHRvbmNsb3NlKCBldmVudCApXG5cdFx0XHRcdFx0Y2xvc2VkKCBjYWxsYmFjayApXG5cdFx0XHRcdH1cblx0XHRcdFx0d2Vic29ja2V0Lm9uZXJyb3IgPSBldmVudCA9PiB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soIGV2ZW50IClcblx0XHRcdFx0fVxuXHRcdFx0XHR3ZWJzb2NrZXQub25vcGVuID0gKCkgPT4ge1xuXHRcdFx0XHRcdHNldEV2ZW50cygpXG5cdFx0XHRcdFx0c2VuZCggY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayApXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PSBXZWJTb2NrZXQuT1BFTiApXG5cdFx0XHRcdHNlbmQoIGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2sgKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjbG9zZWQoIGNhbGxiYWNrIClcblx0XHR9LFxuXHR9IClcblx0c2V0RXZlbnRzKClcblx0cmV0Lm9uKCBgZmluaXNoYCwgY2xvc2VXZWJzb2NrZXQgKVxuXHRyZXR1cm4gcmV0XG59XG4iLCJpbXBvcnQgcmEgZnJvbSBcInJhXCJcblxuY29uc3Qgd2luZG93U2l6ZSA9IHJhKCB7XG5cdHdpZHRoOiAxLFxuXHRoZWlnaHQ6IDEsXG5cdHBwbW06IDEsXG5cdHdpZHRobW06IDEsXG5cdGhlaWdodG1tOiAxLFxuXHRwaXhlbFJhdGlvOiAxLFxuXHRvcmllbnRhdGlvbjogMCxcblx0bGF5b3V0OiBgdmVydGljYWxgLFxuXHR3aW5kb3c6IGBicm93c2VyYCxcbn0gKS5zZXROYW1lKCBgd2luZG93U2l6ZWAgKVxuXG5leHBvcnQgZGVmYXVsdCB3aW5kb3dTaXplXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBgcmVzaXplYCwgdXBkYXRlU2l6ZSApXG5cbi8vIGxldCBvcmllbnRhdGlvbnMgPSB7fVxuXG5sZXQgY20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgZGl2YCApXG5jbS5zdHlsZS5sZWZ0ID0gYDBgXG5jbS5zdHlsZS50b3AgPSBgMGBcbmNtLnN0eWxlLndpZHRoID0gYDEwY21gXG5jbS5zdHlsZS5oZWlnaHQgPSBgMTBjbWBcbmNtLnN0eWxlLnBvc2l0aW9uID0gYGZpeGVkYFxuY20uc3R5bGUuekluZGV4ID0gYC05OTk5YFxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggY20gKVxubGV0IHBwbW0gPSBjbS5jbGllbnRXaWR0aCAvIDEwMFxuZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggY20gKVxuXG51cGRhdGVTaXplKClcblxuZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcblxuXHRsZXQgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuXHRsZXQgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG5cblx0bGV0IG9yaWVudGF0aW9uID0gKCB3aW5kb3cub3JpZW50YXRpb24gfHwgMCApICUgMzYwXG5cdGlmICggb3JpZW50YXRpb24gPCAwICkgb3JpZW50YXRpb24gKz0gMzYwXG5cblx0d2luZG93U2l6ZS53aWR0aCA9IHdpZHRoXG5cdHdpbmRvd1NpemUuaGVpZ2h0ID0gaGVpZ2h0XG5cdHdpbmRvd1NpemUucHBtbSA9IHBwbW1cblx0d2luZG93U2l6ZS53aWR0aG1tID0gd2lkdGggLyBwcG1tXG5cdHdpbmRvd1NpemUuaGVpZ2h0bW0gPSBoZWlnaHQgLyBwcG1tXG5cdHdpbmRvd1NpemUucGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDFcblx0d2luZG93U2l6ZS5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uXG5cdHdpbmRvd1NpemUubGF5b3V0ID0gd2lkdGggPD0gaGVpZ2h0ID8gYHZlcnRpY2FsYCA6IGBob3Jpem9udGFsYFxuXHR3aW5kb3dTaXplLndpbmRvdyA9IHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSA/IGBhcHBgIDogYGJyb3dzZXJgXG59XG4iLCJyZXF1aXJlKCBcIndlYnBhZ2VcIiApXG5yZXF1aXJlKCBcInVpL09uZUFwcFwiIClcbmdsb2JhbC5yZXF1aXJlID0gZnVuY3Rpb24gciggbmFtZSApIHtcblx0XHRcdFx0XHRnbG9iYWwucmVxdWlyZSA9IG51bGxcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcXVpcmUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0Z2xvYmFsLnJlcXVpcmUgPSByXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG4iXX0=
