(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

require("core-js/shim");

require("regenerator/runtime");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/lib/babel/polyfill.js","/node_modules/babel-core/lib/babel")

},{"_process":96,"buffer":91,"core-js/shim":87,"regenerator/runtime":88}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// false -> Array#indexOf
// true  -> Array#includes
var $ = require('./$');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = $.toObject($this)
      , length = $.toLength(O.length)
      , index  = $.toIndex(fromIndex, length)
      , value;
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index;
    } return !IS_INCLUDES && -1;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.array-includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var $   = require('./$')
  , ctx = require('./$.ctx');
module.exports = function(TYPE){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that){
    var O      = Object($.assertDefined($this))
      , self   = $.ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = $.toLength(self.length)
      , index  = 0
      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.array-methods.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.ctx":11,"_process":96,"buffer":91}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
assert.def = $.assertDefined;
assert.fn = function(it){
  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');
  return it;
};
assert.obj = function(it){
  if(!$.isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
assert.inst = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
module.exports = assert;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.assert.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , enumKeys = require('./$.enum-keys');
// 19.1.2.1 Object.assign(target, source, ...)
/* eslint-disable no-unused-vars */
module.exports = Object.assign || function assign(target, source){
/* eslint-enable no-unused-vars */
  var T = Object($.assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = $.ES5Object(arguments[i++])
      , keys   = enumKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.assign.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.enum-keys":14,"_process":96,"buffer":91}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , TAG      = require('./$.wks')('toStringTag')
  , toString = {}.toString;
function cof(it){
  return toString.call(it).slice(8, -1);
}
cof.classof = function(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
};
cof.set = function(it, tag, stat){
  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);
};
module.exports = cof;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.cof.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.wks":38,"_process":96,"buffer":91}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , safe     = require('./$.uid').safe
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , step     = require('./$.iter').step
  , has      = $.has
  , set      = $.set
  , isObject = $.isObject
  , hide     = $.hide
  , isExtensible = Object.isExtensible || isObject
  , ID       = safe('id')
  , O1       = safe('O1')
  , LAST     = safe('last')
  , FIRST    = safe('first')
  , ITER     = safe('iter')
  , SIZE     = $.DESC ? safe('size') : 'size'
  , id       = 0;

function fastKey(it, create){
  // return primitive with prefix
  if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
}

function getEntry(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index != 'F')return that[O1][index];
  // frozen object case
  for(entry = that[FIRST]; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
}

module.exports = {
  getConstructor: function(NAME, IS_MAP, ADDER){
    function C(){
      var that     = assert.inst(this, C, NAME)
        , iterable = arguments[0];
      set(that, O1, $.create(null));
      set(that, SIZE, 0);
      set(that, LAST, undefined);
      set(that, FIRST, undefined);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    }
    require('./$.mix')(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that[FIRST] = that[LAST] = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that[O1][entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that[FIRST] == entry)that[FIRST] = next;
          if(that[LAST] == entry)that[LAST] = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments[1], 3)
          , entry;
        while(entry = entry ? entry.n : this[FIRST]){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if($.DESC)$.setDesc(C.prototype, 'size', {
      get: function(){
        return assert.def(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  },
  getEntry: getEntry,
  // add .keys, .values, .entries, [@@iterator]
  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
  setIter: function(C, NAME, IS_MAP){
    require('./$.iter-define')(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-strong.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"./$.ctx":11,"./$.for-of":15,"./$.iter":21,"./$.iter-define":19,"./$.mix":24,"./$.uid":36,"_process":96,"buffer":91}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def')
  , forOf = require('./$.for-of');
module.exports = function(NAME){
  $def($def.P, NAME, {
    toJSON: function toJSON(){
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    }
  });
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.for-of":15,"_process":96,"buffer":91}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $         = require('./$')
  , safe      = require('./$.uid').safe
  , assert    = require('./$.assert')
  , forOf     = require('./$.for-of')
  , _has      = $.has
  , isObject  = $.isObject
  , hide      = $.hide
  , isExtensible = Object.isExtensible || isObject
  , id        = 0
  , ID        = safe('id')
  , WEAK      = safe('weak')
  , LEAK      = safe('leak')
  , method    = require('./$.array-methods')
  , find      = method(5)
  , findIndex = method(6);
function findFrozen(store, key){
  return find(store.array, function(it){
    return it[0] === key;
  });
}
// fallback for frozen keys
function leakStore(that){
  return that[LEAK] || hide(that, LEAK, {
    array: [],
    get: function(key){
      var entry = findFrozen(this, key);
      if(entry)return entry[1];
    },
    has: function(key){
      return !!findFrozen(this, key);
    },
    set: function(key, value){
      var entry = findFrozen(this, key);
      if(entry)entry[1] = value;
      else this.array.push([key, value]);
    },
    'delete': function(key){
      var index = findIndex(this.array, function(it){
        return it[0] === key;
      });
      if(~index)this.array.splice(index, 1);
      return !!~index;
    }
  })[LEAK];
}

module.exports = {
  getConstructor: function(NAME, IS_MAP, ADDER){
    function C(){
      $.set(assert.inst(this, C, NAME), ID, id++);
      var iterable = arguments[0];
      if(iterable != undefined)forOf(iterable, IS_MAP, this[ADDER], this);
    }
    require('./$.mix')(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this)['delete'](key);
        return _has(key, WEAK) && _has(key[WEAK], this[ID]) && delete key[WEAK][this[ID]];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this).has(key);
        return _has(key, WEAK) && _has(key[WEAK], this[ID]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    if(!isExtensible(assert.obj(key))){
      leakStore(that).set(key, value);
    } else {
      _has(key, WEAK) || hide(key, WEAK, {});
      key[WEAK][that[ID]] = value;
    } return that;
  },
  leakStore: leakStore,
  WEAK: WEAK,
  ID: ID
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-weak.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.array-methods":3,"./$.assert":4,"./$.for-of":15,"./$.mix":24,"./$.uid":36,"_process":96,"buffer":91}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $     = require('./$')
  , $def  = require('./$.def')
  , BUGGY = require('./$.iter').BUGGY
  , forOf = require('./$.for-of')
  , species = require('./$.species')
  , assertInstance = require('./$.assert').inst;

module.exports = function(NAME, methods, common, IS_MAP, IS_WEAK){
  var Base  = $.g[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  function fixMethod(KEY, CHAIN){
    if($.FW){
      var method = proto[KEY];
      require('./$.redef')(proto, KEY, function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return CHAIN ? this : result;
      });
    }
  }
  if(!$.isFunction(C) || !(IS_WEAK || !BUGGY && proto.forEach && proto.entries)){
    // create collection constructor
    C = common.getConstructor(NAME, IS_MAP, ADDER);
    require('./$.mix')(C.prototype, methods);
  } else {
    var inst  = new C
      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
      , buggyZero;
    // wrap for init collections from iterable
    if(!require('./$.iter-detect')(function(iter){ new C(iter); })){ // eslint-disable-line no-new
      C = function(){
        assertInstance(this, C, NAME);
        var that     = new Base
          , iterable = arguments[0];
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      };
      C.prototype = proto;
      if($.FW)proto.constructor = C;
    }
    IS_WEAK || inst.forEach(function(val, key){
      buggyZero = 1 / key === -Infinity;
    });
    // fix converting -0 key to +0
    if(buggyZero){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    // + fix .add & .set for chaining
    if(buggyZero || chain !== inst)fixMethod(ADDER, true);
  }

  require('./$.cof').set(C, NAME);

  O[NAME] = C;
  $def($def.G + $def.W + $def.F * (C != Base), O);
  species(C);
  species($.core[NAME]); // for wrapper

  if(!IS_WEAK)common.setIter(C, NAME, IS_MAP);

  return C;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.for-of":15,"./$.iter":21,"./$.iter-detect":20,"./$.mix":24,"./$.redef":27,"./$.species":30,"_process":96,"buffer":91}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Optional / simple context binding
var assertFunction = require('./$.assert').fn;
module.exports = function(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  } return function(/* ...args */){
      return fn.apply(that, arguments);
    };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.ctx.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assert":4,"_process":96,"buffer":91}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $          = require('./$')
  , global     = $.g
  , core       = $.core
  , isFunction = $.isFunction
  , $redef     = require('./$.redef');
function ctx(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
}
global.core = core;
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
function $def(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , isProto  = type & $def.P
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {}).prototype
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    if(type & $def.B && own)exp = ctx(out, global);
    else exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
    // extend global
    if(target && !own)$redef(target, key, out);
    // export
    if(exports[key] != out)$.hide(exports, key, exp);
    if(isProto)(exports.prototype || (exports.prototype = {}))[key] = out;
  }
}
module.exports = $def;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.def.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.redef":27,"_process":96,"buffer":91}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , document = $.g.document
  , isObject = $.isObject
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.dom-create.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getDesc    = $.getDesc
    , getSymbols = $.getSymbols;
  if(getSymbols)$.each.call(getSymbols(it), function(key){
    if(getDesc(it, key).enumerable)keys.push(key);
  });
  return keys;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.enum-keys.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var ctx  = require('./$.ctx')
  , get  = require('./$.iter').get
  , call = require('./$.iter-call');
module.exports = function(iterable, entries, fn, that){
  var iterator = get(iterable)
    , f        = ctx(fn, that, entries ? 2 : 1)
    , step;
  while(!(step = iterator.next()).done){
    if(call(iterator, f, step.value, entries) === false){
      return call.close(iterator);
    }
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.for-of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.ctx":11,"./$.iter":21,"./$.iter-call":18,"_process":96,"buffer":91}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function($){
  $.FW   = true;
  $.path = $.g;
  return $;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.fw.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":96,"buffer":91}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.invoke.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":96,"buffer":91}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assertObject = require('./$.assert').obj;
function close(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)assertObject(ret.call(iterator));
}
function call(iterator, fn, value, entries){
  try {
    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
  } catch(e){
    close(iterator);
    throw e;
  }
}
call.close = close;
module.exports = call;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-call.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assert":4,"_process":96,"buffer":91}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def            = require('./$.def')
  , $redef          = require('./$.redef')
  , $               = require('./$')
  , cof             = require('./$.cof')
  , $iter           = require('./$.iter')
  , SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , FF_ITERATOR     = '@@iterator'
  , KEYS            = 'keys'
  , VALUES          = 'values'
  , Iterators       = $iter.Iterators;
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
  $iter.create(Constructor, NAME, next);
  function createMethod(kind){
    function $$(that){
      return new Constructor(that, kind);
    }
    switch(kind){
      case KEYS: return function keys(){ return $$(this); };
      case VALUES: return function values(){ return $$(this); };
    } return function entries(){ return $$(this); };
  }
  var TAG      = NAME + ' Iterator'
    , proto    = Base.prototype
    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , _default = _native || createMethod(DEFAULT)
    , methods, key;
  // Fix native
  if(_native){
    var IteratorPrototype = $.getProto(_default.call(new Base));
    // Set @@toStringTag to native iterators
    cof.set(IteratorPrototype, TAG, true);
    // FF fix
    if($.FW && $.has(proto, FF_ITERATOR))$iter.set(IteratorPrototype, $.that);
  }
  // Define iterator
  if($.FW)$iter.set(proto, _default);
  // Plug for library
  Iterators[NAME] = _default;
  Iterators[TAG]  = $.that;
  if(DEFAULT){
    methods = {
      keys:    IS_SET            ? _default : createMethod(KEYS),
      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
      entries: DEFAULT != VALUES ? _default : createMethod('entries')
    };
    if(FORCE)for(key in methods){
      if(!(key in proto))$redef(proto, key, methods[key]);
    } else $def($def.P + $def.F * $iter.BUGGY, NAME, methods);
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-define.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.cof":6,"./$.def":12,"./$.iter":21,"./$.redef":27,"./$.wks":38,"_process":96,"buffer":91}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , SAFE_CLOSING    = false;
try {
  var riter = [7][SYMBOL_ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }
module.exports = function(exec){
  if(!SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[SYMBOL_ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[SYMBOL_ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-detect.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.wks":38,"_process":96,"buffer":91}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $                 = require('./$')
  , cof               = require('./$.cof')
  , assertObject      = require('./$.assert').obj
  , SYMBOL_ITERATOR   = require('./$.wks')('iterator')
  , FF_ITERATOR       = '@@iterator'
  , Iterators         = {}
  , IteratorPrototype = {};
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, $.that);
function setIterator(O, value){
  $.hide(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);
}

module.exports = {
  // Safari has buggy iterators w/o `next`
  BUGGY: 'keys' in [] && !('next' in [].keys()),
  Iterators: Iterators,
  step: function(done, value){
    return {value: value, done: !!done};
  },
  is: function(it){
    var O      = Object(it)
      , Symbol = $.g.Symbol
      , SYM    = Symbol && Symbol.iterator || FF_ITERATOR;
    return SYM in O || SYMBOL_ITERATOR in O || $.has(Iterators, cof.classof(O));
  },
  get: function(it){
    var Symbol  = $.g.Symbol
      , ext     = it[Symbol && Symbol.iterator || FF_ITERATOR]
      , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[cof.classof(it)];
    return assertObject(getIter.call(it));
  },
  set: setIterator,
  create: function(Constructor, NAME, next, proto){
    Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});
    cof.set(Constructor, NAME + ' Iterator');
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"./$.cof":6,"./$.wks":38,"_process":96,"buffer":91}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var global = typeof self != 'undefined' ? self : Function('return this')()
  , core   = {}
  , defineProperty = Object.defineProperty
  , hasOwnProperty = {}.hasOwnProperty
  , ceil  = Math.ceil
  , floor = Math.floor
  , max   = Math.max
  , min   = Math.min;
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
  try {
    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
  } catch(e){ /* empty */ }
}();
var hide = createDefiner(1);
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
}
function desc(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return $.setDesc(object, key, desc(bitmap, value));
  } : simpleSet;
}

function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
function assertDefined(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
}

var $ = module.exports = require('./$.fw')({
  g: global,
  core: core,
  html: global.document && document.documentElement,
  // http://jsperf.com/core-js-isobject
  isObject:   isObject,
  isFunction: isFunction,
  it: function(it){
    return it;
  },
  that: function(){
    return this;
  },
  // 7.1.4 ToInteger
  toInteger: toInteger,
  // 7.1.15 ToLength
  toLength: function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  },
  toIndex: function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  },
  has: function(it, key){
    return hasOwnProperty.call(it, key);
  },
  create:     Object.create,
  getProto:   Object.getPrototypeOf,
  DESC:       DESC,
  desc:       desc,
  getDesc:    Object.getOwnPropertyDescriptor,
  setDesc:    defineProperty,
  setDescs:   Object.defineProperties,
  getKeys:    Object.keys,
  getNames:   Object.getOwnPropertyNames,
  getSymbols: Object.getOwnPropertySymbols,
  assertDefined: assertDefined,
  // Dummy, fix for not array-like ES3 string in es5 module
  ES5Object: Object,
  toObject: function(it){
    return $.ES5Object(assertDefined(it));
  },
  hide: hide,
  def: createDefiner(0),
  set: global.Symbol ? simpleSet : hide,
  each: [].forEach
});
/* eslint-disable no-undef */
if(typeof __e != 'undefined')__e = core;
if(typeof __g != 'undefined')__g = global;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.fw":16,"_process":96,"buffer":91}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
module.exports = function(object, el){
  var O      = $.toObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.keyof.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $redef = require('./$.redef');
module.exports = function(target, src){
  for(var key in src)$redef(target, key, src[key]);
  return target;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.mix.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.redef":27,"_process":96,"buffer":91}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $            = require('./$')
  , assertObject = require('./$.assert').obj;
module.exports = function ownKeys(it){
  assertObject(it);
  var keys       = $.getNames(it)
    , getSymbols = $.getSymbols;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.own-keys.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"_process":96,"buffer":91}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $      = require('./$')
  , invoke = require('./$.invoke')
  , assertFunction = require('./$.assert').fn;
module.exports = function(/* ...pargs */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = $.path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !_length)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(_length > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.partial.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"./$.invoke":17,"_process":96,"buffer":91}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $   = require('./$')
  , tpl = String({}.hasOwnProperty)
  , SRC = require('./$.uid').safe('src')
  , _toString = Function.toString;

function $redef(O, key, val, safe){
  if($.isFunction(val)){
    var base = O[key];
    $.hide(val, SRC, base ? String(base) : tpl.replace(/hasOwnProperty/, String(key)));
  }
  if(O === $.g){
    O[key] = val;
  } else {
    if(!safe)delete O[key];
    $.hide(O, key, val);
  }
}

// add fake Function#toString for correct work wrapped methods / constructors
// with methods similar to LoDash isNative
$redef(Function.prototype, 'toString', function toString(){
  return $.has(this, SRC) ? this[SRC] : _toString.call(this);
});

$.core.inspectSource = function(it){
  return _toString.call(it);
};

module.exports = $redef;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.redef.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.uid":36,"_process":96,"buffer":91}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
module.exports = function(regExp, replace, isStatic){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.replacer.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":96,"buffer":91}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var $      = require('./$')
  , assert = require('./$.assert');
function check(O, proto){
  assert.obj(O);
  assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
}
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line
    ? function(buggy, set){
        try {
          set = require('./$.ctx')(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
          set({}, []);
        } catch(e){ buggy = true; }
        return function setPrototypeOf(O, proto){
          check(O, proto);
          if(buggy)O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }()
    : undefined),
  check: check
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.set-proto.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"./$.ctx":11,"_process":96,"buffer":91}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $       = require('./$')
  , SPECIES = require('./$.wks')('species');
module.exports = function(C){
  if($.DESC && !(SPECIES in C))$.setDesc(C, SPECIES, {
    configurable: true,
    get: $.that
  });
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.species.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.wks":38,"_process":96,"buffer":91}],31:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// true  -> String#at
// false -> String#codePointAt
var $ = require('./$');
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String($.assertDefined(that))
      , i = $.toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l
      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://wiki.ecmascript.org/doku.php?id=strawman:string_padding
var $      = require('./$')
  , repeat = require('./$.string-repeat');

module.exports = function(that, minLength, fillChar, left){
  // 1. Let O be CheckObjectCoercible(this value).
  // 2. Let S be ToString(O).
  var S = String($.assertDefined(that));
  // 4. If intMinLength is undefined, return S.
  if(minLength === undefined)return S;
  // 4. Let intMinLength be ToInteger(minLength).
  var intMinLength = $.toInteger(minLength);
  // 5. Let fillLen be the number of characters in S minus intMinLength.
  var fillLen = intMinLength - S.length;
  // 6. If fillLen < 0, then throw a RangeError exception.
  // 7. If fillLen is +âˆž, then throw a RangeError exception.
  if(fillLen < 0 || fillLen === Infinity){
    throw new RangeError('Cannot satisfy string length ' + minLength + ' for string: ' + S);
  }
  // 8. Let sFillStr be the string represented by fillStr.
  // 9. If sFillStr is undefined, let sFillStr be a space character.
  var sFillStr = fillChar === undefined ? ' ' : String(fillChar);
  // 10. Let sFillVal be a String made of sFillStr, repeated until fillLen is met.
  var sFillVal = repeat.call(sFillStr, Math.ceil(fillLen / sFillStr.length));
  // truncate if we overflowed
  if(sFillVal.length > fillLen)sFillVal = left
    ? sFillVal.slice(sFillVal.length - fillLen)
    : sFillVal.slice(0, fillLen);
  // 11. Return a string made from sFillVal, followed by S.
  // 11. Return a String made from S, followed by sFillVal.
  return left ? sFillVal.concat(S) : S.concat(sFillVal);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-pad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.string-repeat":33,"_process":96,"buffer":91}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $ = require('./$');

module.exports = function repeat(count){
  var str = String($.assertDefined(this))
    , res = ''
    , n   = $.toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-repeat.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $      = require('./$')
  , ctx    = require('./$.ctx')
  , cof    = require('./$.cof')
  , invoke = require('./$.invoke')
  , cel    = require('./$.dom-create')
  , global             = $.g
  , isFunction         = $.isFunction
  , html               = $.html
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , postMessage        = global.postMessage
  , addEventListener   = global.addEventListener
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
function run(){
  var id = +this;
  if($.has(queue, id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
}
function listner(event){
  run.call(event.data);
}
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!isFunction(setTask) || !isFunction(clearTask)){
  setTask = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(cof(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    };
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.task.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.cof":6,"./$.ctx":11,"./$.dom-create":13,"./$.invoke":17,"_process":96,"buffer":91}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(exec){
  try {
    exec();
    return false;
  } catch(e){
    return true;
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.throws.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":96,"buffer":91}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var sid = 0;
function uid(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++sid + Math.random()).toString(36));
}
uid.safe = require('./$').g.Symbol || uid;
module.exports = uid;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.uid.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 22.1.3.31 Array.prototype[@@unscopables]
var $           = require('./$')
  , UNSCOPABLES = require('./$.wks')('unscopables');
if($.FW && !(UNSCOPABLES in []))$.hide(Array.prototype, UNSCOPABLES, {});
module.exports = function(key){
  if($.FW)[][UNSCOPABLES][key] = true;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.unscope.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.wks":38,"_process":96,"buffer":91}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var global = require('./$').g
  , store  = {};
module.exports = function(name){
  return store[name] || (store[name] =
    global.Symbol && global.Symbol[name] || require('./$.uid').safe('Symbol.' + name));
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.wks.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.uid":36,"_process":96,"buffer":91}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $                = require('./$')
  , cel              = require('./$.dom-create')
  , cof              = require('./$.cof')
  , $def             = require('./$.def')
  , invoke           = require('./$.invoke')
  , arrayMethod      = require('./$.array-methods')
  , IE_PROTO         = require('./$.uid').safe('__proto__')
  , assert           = require('./$.assert')
  , assertObject     = assert.obj
  , ObjectProto      = Object.prototype
  , html             = $.html
  , A                = []
  , _slice           = A.slice
  , _join            = A.join
  , classof          = cof.classof
  , has              = $.has
  , defineProperty   = $.setDesc
  , getOwnDescriptor = $.getDesc
  , defineProperties = $.setDescs
  , isFunction       = $.isFunction
  , toObject         = $.toObject
  , toLength         = $.toLength
  , toIndex          = $.toIndex
  , IE8_DOM_DEFINE   = false
  , $indexOf         = require('./$.array-includes')(false)
  , $forEach         = arrayMethod(0)
  , $map             = arrayMethod(1)
  , $filter          = arrayMethod(2)
  , $some            = arrayMethod(3)
  , $every           = arrayMethod(4);

if(!$.DESC){
  try {
    IE8_DOM_DEFINE = defineProperty(cel('div'), 'x',
      {get: function(){ return 8; }}
    ).x == 8;
  } catch(e){ /* empty */ }
  $.setDesc = function(O, P, Attributes){
    if(IE8_DOM_DEFINE)try {
      return defineProperty(O, P, Attributes);
    } catch(e){ /* empty */ }
    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
    if('value' in Attributes)assertObject(O)[P] = Attributes.value;
    return O;
  };
  $.getDesc = function(O, P){
    if(IE8_DOM_DEFINE)try {
      return getOwnDescriptor(O, P);
    } catch(e){ /* empty */ }
    if(has(O, P))return $.desc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
  };
  $.setDescs = defineProperties = function(O, Properties){
    assertObject(O);
    var keys   = $.getKeys(Properties)
      , length = keys.length
      , i = 0
      , P;
    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
    return O;
  };
}
$def($def.S + $def.F * !$.DESC, 'Object', {
  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $.getDesc,
  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  defineProperty: $.setDesc,
  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
  defineProperties: defineProperties
});

  // IE 8- don't enum bug keys
var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
            'toLocaleString,toString,valueOf').split(',')
  // Additional keys for getOwnPropertyNames
  , keys2 = keys1.concat('length', 'prototype')
  , keysLen1 = keys1.length;

// Create object with `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = cel('iframe')
    , i      = keysLen1
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write('<script>document.F=Object</script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict.prototype[keys1[i]];
  return createDict();
};
function createGetKeys(names, length){
  return function(object){
    var O      = toObject(object)
      , i      = 0
      , result = []
      , key;
    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(length > i)if(has(O, key = names[i++])){
      ~$indexOf(result, key) || result.push(key);
    }
    return result;
  };
}
function isPrimitive(it){ return !$.isObject(it); }
function Empty(){}
$def($def.S, 'Object', {
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  getPrototypeOf: $.getProto = $.getProto || function(O){
    O = Object(assert.def(O));
    if(has(O, IE_PROTO))return O[IE_PROTO];
    if(isFunction(O.constructor) && O instanceof O.constructor){
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  },
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  create: $.create = $.create || function(O, /*?*/Properties){
    var result;
    if(O !== null){
      Empty.prototype = assertObject(O);
      result = new Empty();
      Empty.prototype = null;
      // add "__proto__" for Object.getPrototypeOf shim
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : defineProperties(result, Properties);
  },
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false),
  // 19.1.2.17 / 15.2.3.8 Object.seal(O)
  seal: $.it, // <- cap
  // 19.1.2.5 / 15.2.3.9 Object.freeze(O)
  freeze: $.it, // <- cap
  // 19.1.2.15 / 15.2.3.10 Object.preventExtensions(O)
  preventExtensions: $.it, // <- cap
  // 19.1.2.13 / 15.2.3.11 Object.isSealed(O)
  isSealed: isPrimitive, // <- cap
  // 19.1.2.12 / 15.2.3.12 Object.isFrozen(O)
  isFrozen: isPrimitive, // <- cap
  // 19.1.2.11 / 15.2.3.13 Object.isExtensible(O)
  isExtensible: $.isObject // <- cap
});

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
$def($def.P, 'Function', {
  bind: function(that /*, args... */){
    var fn       = assert.fn(this)
      , partArgs = _slice.call(arguments, 1);
    function bound(/* args... */){
      var args = partArgs.concat(_slice.call(arguments));
      return invoke(fn, args, this instanceof bound ? $.create(fn.prototype) : that);
    }
    if(fn.prototype)bound.prototype = fn.prototype;
    return bound;
  }
});

// Fix for not array-like ES3 string and DOM objects
if(!(0 in Object('z') && 'z'[0] == 'z')){
  $.ES5Object = function(it){
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
}

var buggySlice = true;
try {
  if(html)_slice.call(html);
  buggySlice = false;
} catch(e){ /* empty */ }

$def($def.P + $def.F * buggySlice, 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return _slice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

$def($def.P + $def.F * ($.ES5Object != Object), 'Array', {
  join: function join(){
    return _join.apply($.ES5Object(this), arguments);
  }
});

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
$def($def.S, 'Array', {
  isArray: function(arg){
    return cof(arg) == 'Array';
  }
});
function createArrayReduce(isRight){
  return function(callbackfn, memo){
    assert.fn(callbackfn);
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = isRight ? length - 1 : 0
      , i      = isRight ? -1 : 1;
    if(arguments.length < 2)for(;;){
      if(index in O){
        memo = O[index];
        index += i;
        break;
      }
      index += i;
      assert(isRight ? index >= 0 : length > index, 'Reduce of empty array with no initial value');
    }
    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
      memo = callbackfn(memo, O[index], index, this);
    }
    return memo;
  };
}
$def($def.P, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: $.each = $.each || function forEach(callbackfn/*, that = undefined */){
    return $forEach(this, callbackfn, arguments[1]);
  },
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn/*, that = undefined */){
    return $map(this, callbackfn, arguments[1]);
  },
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn/*, that = undefined */){
    return $filter(this, callbackfn, arguments[1]);
  },
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn/*, that = undefined */){
    return $some(this, callbackfn, arguments[1]);
  },
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn/*, that = undefined */){
    return $every(this, callbackfn, arguments[1]);
  },
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: createArrayReduce(false),
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: createArrayReduce(true),
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(el /*, fromIndex = 0 */){
    return $indexOf(this, el, arguments[1]);
  },
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, $.toInteger(fromIndex));
    if(index < 0)index = toLength(length + index);
    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
    return -1;
  }
});

// 21.1.3.25 / 15.5.4.20 String.prototype.trim()
$def($def.P, 'String', {trim: require('./$.replacer')(/^\s*([\s\S]*\S)?\s*$/, '$1')});

// 20.3.3.1 / 15.9.4.4 Date.now()
$def($def.S, 'Date', {now: function(){
  return +new Date;
}});

function lz(num){
  return num > 9 ? num : '0' + num;
}

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
// PhantomJS and old webkit had a broken Date implementation.
var date       = new Date(-5e13 - 1)
  , brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z'
      && require('./$.throws')(function(){ new Date(NaN).toISOString(); }));
$def($def.P + $def.F * brokenDate, 'Date', {toISOString: function(){
  if(!isFinite(this))throw RangeError('Invalid time value');
  var d = this
    , y = d.getUTCFullYear()
    , m = d.getUTCMilliseconds()
    , s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
}});

if(classof(function(){ return arguments; }()) == 'Object')cof.classof = function(it){
  var tag = classof(it);
  return tag == 'Object' && isFunction(it.callee) ? 'Arguments' : tag;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es5.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.array-includes":2,"./$.array-methods":3,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.dom-create":13,"./$.invoke":17,"./$.replacer":28,"./$.throws":35,"./$.uid":36,"_process":96,"buffer":91}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
  copyWithin: function copyWithin(target/* = 0 */, start /* = 0, end = @length */){
    var O     = Object($.assertDefined(this))
      , len   = $.toLength(O.length)
      , to    = toIndex(target, len)
      , from  = toIndex(start, len)
      , end   = arguments[2]
      , fin   = end === undefined ? len : toIndex(end, len)
      , count = Math.min(fin - from, len - to)
      , inc   = 1;
    if(from < to && to < from + count){
      inc  = -1;
      from = from + count - 1;
      to   = to   + count - 1;
    }
    while(count-- > 0){
      if(from in O)O[to] = O[from];
      else delete O[to];
      to   += inc;
      from += inc;
    } return O;
  }
});
require('./$.unscope')('copyWithin');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.copy-within.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"./$.unscope":37,"_process":96,"buffer":91}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
  fill: function fill(value /*, start = 0, end = @length */){
    var O      = Object($.assertDefined(this))
      , length = $.toLength(O.length)
      , index  = toIndex(arguments[1], length)
      , end    = arguments[2]
      , endPos = end === undefined ? length : toIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
  }
});
require('./$.unscope')('fill');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.fill.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"./$.unscope":37,"_process":96,"buffer":91}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var KEY    = 'findIndex'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(6);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.find-index.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-methods":3,"./$.def":12,"./$.unscope":37,"_process":96,"buffer":91}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var KEY    = 'find'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(5);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.find.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-methods":3,"./$.def":12,"./$.unscope":37,"_process":96,"buffer":91}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $     = require('./$')
  , ctx   = require('./$.ctx')
  , $def  = require('./$.def')
  , $iter = require('./$.iter')
  , call  = require('./$.iter-call');
$def($def.S + $def.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = Object($.assertDefined(arrayLike))
      , mapfn   = arguments[1]
      , mapping = mapfn !== undefined
      , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
      , index   = 0
      , length, result, step, iterator;
    if($iter.is(O)){
      iterator = $iter.get(O);
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result   = new (typeof this == 'function' ? this : Array);
      for(; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, f, [step.value, index], true) : step.value;
      }
    } else {
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result = new (typeof this == 'function' ? this : Array)(length = $.toLength(O.length));
      for(; length > index; index++){
        result[index] = mapping ? f(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.from.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.ctx":11,"./$.def":12,"./$.iter":21,"./$.iter-call":18,"./$.iter-detect":20,"_process":96,"buffer":91}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $          = require('./$')
  , setUnscope = require('./$.unscope')
  , ITER       = require('./$.uid').safe('iter')
  , $iter      = require('./$.iter')
  , step       = $iter.step
  , Iterators  = $iter.Iterators;

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , kind  = iter.k
    , index = iter.i++;
  if(!O || index >= O.length){
    iter.o = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

setUnscope('keys');
setUnscope('values');
setUnscope('entries');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.iterator.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.iter":21,"./$.iter-define":19,"./$.uid":36,"./$.unscope":37,"_process":96,"buffer":91}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def = require('./$.def');
$def($def.S, 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , length = arguments.length
      // strange IE quirks mode bug -> use typeof instead of isFunction
      , result = new (typeof this == 'function' ? this : Array)(length);
    while(length > index)result[index] = arguments[index++];
    result.length = length;
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"_process":96,"buffer":91}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./$.species')(Array);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.species.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.species":30,"_process":96,"buffer":91}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $             = require('./$')
  , HAS_INSTANCE  = require('./$.wks')('hasInstance')
  , FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(!$.isFunction(this) || !$.isObject(O))return false;
  if(!$.isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = $.getProto(O))if(this.prototype === O)return true;
  return false;
}});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.function.has-instance.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.wks":38,"_process":96,"buffer":91}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , NAME = 'name'
  , setDesc = $.setDesc
  , FunctionProto = Function.prototype;
// 19.2.4.2 name
NAME in FunctionProto || $.FW && $.DESC && setDesc(FunctionProto, NAME, {
  configurable: true,
  get: function(){
    var match = String(this).match(/^\s*function ([^ (]*)/)
      , name  = match ? match[1] : '';
    $.has(this, NAME) || setDesc(this, NAME, $.desc(5, name));
    return name;
  },
  set: function(value){
    $.has(this, NAME) || setDesc(this, NAME, $.desc(0, value));
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.function.name.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"_process":96,"buffer":91}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.map.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-strong":7,"_process":96,"buffer":91}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Infinity = 1 / 0
  , $def  = require('./$.def')
  , E     = Math.E
  , pow   = Math.pow
  , abs   = Math.abs
  , exp   = Math.exp
  , log   = Math.log
  , sqrt  = Math.sqrt
  , ceil  = Math.ceil
  , floor = Math.floor
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);
function roundTiesToEven(n){
  return n + 1 / EPSILON - 1 / EPSILON;
}

// 20.2.2.28 Math.sign(x)
function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
}
// 20.2.2.5 Math.asinh(x)
function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}
// 20.2.2.14 Math.expm1(x)
function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
}

$def($def.S, 'Math', {
  // 20.2.2.3 Math.acosh(x)
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
  },
  // 20.2.2.5 Math.asinh(x)
  asinh: asinh,
  // 20.2.2.7 Math.atanh(x)
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
  },
  // 20.2.2.9 Math.cbrt(x)
  cbrt: function cbrt(x){
    return sign(x = +x) * pow(abs(x), 1 / 3);
  },
  // 20.2.2.11 Math.clz32(x)
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * Math.LOG2E) : 32;
  },
  // 20.2.2.12 Math.cosh(x)
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  },
  // 20.2.2.14 Math.expm1(x)
  expm1: expm1,
  // 20.2.2.16 Math.fround(x)
  fround: function fround(x){
    var $abs  = abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  },
  // 20.2.2.17 Math.hypot([value1[, value2[, â€¦ ]]])
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , len  = arguments.length
      , args = Array(len)
      , larg = 0
      , arg;
    while(i < len){
      arg = args[i] = abs(arguments[i++]);
      if(arg == Infinity)return Infinity;
      if(arg > larg)larg = arg;
    }
    larg = larg || 1;
    while(len--)sum += pow(args[len] / larg, 2);
    return larg * sqrt(sum);
  },
  // 20.2.2.18 Math.imul(x, y)
  imul: function imul(x, y){
    var UInt16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UInt16 & xn
      , yl = UInt16 & yn;
    return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
  },
  // 20.2.2.20 Math.log1p(x)
  log1p: function log1p(x){
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
  },
  // 20.2.2.21 Math.log10(x)
  log10: function log10(x){
    return log(x) / Math.LN10;
  },
  // 20.2.2.22 Math.log2(x)
  log2: function log2(x){
    return log(x) / Math.LN2;
  },
  // 20.2.2.28 Math.sign(x)
  sign: sign,
  // 20.2.2.30 Math.sinh(x)
  sinh: function sinh(x){
    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
  },
  // 20.2.2.33 Math.tanh(x)
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  },
  // 20.2.2.34 Math.trunc(x)
  trunc: function trunc(it){
    return (it > 0 ? floor : ceil)(it);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.math.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"_process":96,"buffer":91}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $          = require('./$')
  , isObject   = $.isObject
  , isFunction = $.isFunction
  , NUMBER     = 'Number'
  , $Number    = $.g[NUMBER]
  , Base       = $Number
  , proto      = $Number.prototype;
function toPrimitive(it){
  var fn, val;
  if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
  if(isFunction(fn = it.toString) && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to number");
}
function toNumber(it){
  if(isObject(it))it = toPrimitive(it);
  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
    var binary = false;
    switch(it.charCodeAt(1)){
      case 66 : case 98  : binary = true;
      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
    }
  } return +it;
}
if($.FW && !($Number('0o1') && $Number('0b1'))){
  $Number = function Number(it){
    return this instanceof $Number ? new Base(toNumber(it)) : toNumber(it);
  };
  $.each.call($.DESC ? $.getNames(Base) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES6 (in case, if modules with ES6 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
    ).split(','), function(key){
      if($.has(Base, key) && !$.has($Number, key)){
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    }
  );
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./$.redef')($.g, NUMBER, $Number);
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.number.constructor.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.redef":27,"_process":96,"buffer":91}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $     = require('./$')
  , $def  = require('./$.def')
  , abs   = Math.abs
  , floor = Math.floor
  , _isFinite = $.g.isFinite
  , MAX_SAFE_INTEGER = 0x1fffffffffffff; // pow(2, 53) - 1 == 9007199254740991;
function isInteger(it){
  return !$.isObject(it) && _isFinite(it) && floor(it) === it;
}
$def($def.S, 'Number', {
  // 20.1.2.1 Number.EPSILON
  EPSILON: Math.pow(2, -52),
  // 20.1.2.2 Number.isFinite(number)
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  },
  // 20.1.2.3 Number.isInteger(number)
  isInteger: isInteger,
  // 20.1.2.4 Number.isNaN(number)
  isNaN: function isNaN(number){
    return number != number;
  },
  // 20.1.2.5 Number.isSafeInteger(number)
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
  },
  // 20.1.2.6 Number.MAX_SAFE_INTEGER
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
  // 20.1.2.10 Number.MIN_SAFE_INTEGER
  MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
  // 20.1.2.12 Number.parseFloat(string)
  parseFloat: parseFloat,
  // 20.1.2.13 Number.parseInt(string, radix)
  parseInt: parseInt
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.number.statics.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"_process":96,"buffer":91}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');
$def($def.S, 'Object', {assign: require('./$.assign')});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.assign.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assign":5,"./$.def":12,"_process":96,"buffer":91}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.10 Object.is(value1, value2)
var $def = require('./$.def');
$def($def.S, 'Object', {
  is: function is(x, y){
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.is.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"_process":96,"buffer":91}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $def = require('./$.def');
$def($def.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.set-prototype-of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.set-proto":29,"_process":96,"buffer":91}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , $def     = require('./$.def')
  , isObject = $.isObject
  , toObject = $.toObject;
$.each.call(('freeze,seal,preventExtensions,isFrozen,isSealed,isExtensible,' +
  'getOwnPropertyDescriptor,getPrototypeOf,keys,getOwnPropertyNames').split(',')
, function(KEY, ID){
  var fn     = ($.core.Object || {})[KEY] || Object[KEY]
    , forced = 0
    , method = {};
  method[KEY] = ID == 0 ? function freeze(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 1 ? function seal(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 2 ? function preventExtensions(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 3 ? function isFrozen(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 4 ? function isSealed(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 5 ? function isExtensible(it){
    return isObject(it) ? fn(it) : false;
  } : ID == 6 ? function getOwnPropertyDescriptor(it, key){
    return fn(toObject(it), key);
  } : ID == 7 ? function getPrototypeOf(it){
    return fn(Object($.assertDefined(it)));
  } : ID == 8 ? function keys(it){
    return fn(toObject(it));
  } : function getOwnPropertyNames(it){
    return fn(toObject(it));
  };
  try {
    fn('z');
  } catch(e){
    forced = 1;
  }
  $def($def.S + $def.F * forced, 'Object', method);
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.statics-accept-primitives.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"_process":96,"buffer":91}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , tmp = {};
tmp[require('./$.wks')('toStringTag')] = 'z';
if(require('./$').FW && cof(tmp) != 'z'){
  require('./$.redef')(Object.prototype, 'toString', function toString(){
    return '[object ' + cof.classof(this) + ']';
  }, true);
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.to-string.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.cof":6,"./$.redef":27,"./$.wks":38,"_process":96,"buffer":91}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , cof      = require('./$.cof')
  , $def     = require('./$.def')
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , setProto = require('./$.set-proto').set
  , species  = require('./$.species')
  , SPECIES  = require('./$.wks')('species')
  , RECORD   = require('./$.uid').safe('record')
  , PROMISE  = 'Promise'
  , global   = $.g
  , process  = global.process
  , asap     = process && process.nextTick || require('./$.task').set
  , P        = global[PROMISE]
  , isFunction     = $.isFunction
  , isObject       = $.isObject
  , assertFunction = assert.fn
  , assertObject   = assert.obj;

var useNative = function(){
  var test, works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = isFunction(P) && isFunction(P.resolve) && P.resolve(test = new P(function(){})) == test;
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
function getConstructor(C){
  var S = assertObject(C)[SPECIES];
  return S != undefined ? S : C;
}
function isThenable(it){
  var then;
  if(isObject(it))then = it.then;
  return isFunction(then) ? then : false;
}
function notify(record){
  var chain = record.c;
  if(chain.length)asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    function run(react){
      var cb = ok ? react.ok : react.fail
        , ret, then;
      try {
        if(cb){
          if(!ok)record.h = true;
          ret = cb === true ? value : cb(value);
          if(ret === react.P){
            react.rej(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(ret)){
            then.call(ret, react.res, react.rej);
          } else react.res(ret);
        } else react.rej(value);
      } catch(err){
        react.rej(err);
      }
    }
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
  });
}
function isUnhandled(promise){
  var record = promise[RECORD]
    , chain  = record.a || record.c
    , i      = 0
    , react;
  if(record.h)return false;
  while(chain.length > i){
    react = chain[i++];
    if(react.fail || !isUnhandled(react.P))return false;
  } return true;
}
function $reject(value){
  var record = this
    , promise;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  setTimeout(function(){
    asap(function(){
      if(isUnhandled(promise = record.p)){
        if(cof(process) == 'process'){
          process.emit('unhandledRejection', value, promise);
        } else if(global.console && isFunction(console.error)){
          console.error('Unhandled promise rejection', value);
        }
      }
      record.a = undefined;
    });
  }, 1);
  notify(record);
}
function $resolve(value){
  var record = this
    , then, wrapper;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(then = isThenable(value)){
      wrapper = {r: record, d: false}; // wrap
      then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
    } else {
      record.v = value;
      record.s = 1;
      notify(record);
    }
  } catch(err){
    $reject.call(wrapper || {r: record, d: false}, err); // wrap
  }
}

// constructor polyfill
if(!useNative){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    assertFunction(executor);
    var record = {
      p: assert.inst(this, P, PROMISE),       // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false                                // <- handled rejection
    };
    $.hide(this, RECORD, record);
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.mix')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var S = assertObject(assertObject(this).constructor)[SPECIES];
      var react = {
        ok:   isFunction(onFulfilled) ? onFulfilled : true,
        fail: isFunction(onRejected)  ? onRejected  : false
      };
      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
        react.res = assertFunction(res);
        react.rej = assertFunction(rej);
      });
      var record = this[RECORD];
      record.c.push(react);
      if(record.a)record.a.push(react);
      record.s && notify(record);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

// export
$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
cof.set(P, PROMISE);
species(P);
species($.core[PROMISE]); // for wrapper

// statics
$def($def.S + $def.F * !useNative, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    return new (getConstructor(this))(function(res, rej){
      rej(r);
    });
  },
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    return isObject(x) && RECORD in x && $.getProto(x) === this.prototype
      ? x : new (getConstructor(this))(function(res){
        res(x);
      });
  }
});
$def($def.S + $def.F * !(useNative && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C      = getConstructor(this)
      , values = [];
    return new C(function(res, rej){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        C.resolve(promise).then(function(value){
          results[index] = value;
          --remaining || res(results);
        }, rej);
      });
      else res(results);
    });
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C = getConstructor(this);
    return new C(function(res, rej){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(res, rej);
      });
    });
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.promise.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"./$.cof":6,"./$.ctx":11,"./$.def":12,"./$.for-of":15,"./$.iter-detect":20,"./$.mix":24,"./$.set-proto":29,"./$.species":30,"./$.task":34,"./$.uid":36,"./$.wks":38,"_process":96,"buffer":91}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $         = require('./$')
  , $def      = require('./$.def')
  , setProto  = require('./$.set-proto')
  , $iter     = require('./$.iter')
  , ITERATOR  = require('./$.wks')('iterator')
  , ITER      = require('./$.uid').safe('iter')
  , step      = $iter.step
  , assert    = require('./$.assert')
  , isObject  = $.isObject
  , getProto  = $.getProto
  , $Reflect  = $.g.Reflect
  , _apply    = Function.apply
  , assertObject = assert.obj
  , _isExtensible = Object.isExtensible || $.isObject
  , _preventExtensions = Object.preventExtensions || $.it
  // IE TP has broken Reflect.enumerate
  , buggyEnumerate = !($Reflect && $Reflect.enumerate && ITERATOR in $Reflect.enumerate({}));

function Enumerate(iterated){
  $.set(this, ITER, {o: iterated, k: undefined, i: 0});
}
$iter.create(Enumerate, 'Object', function(){
  var iter = this[ITER]
    , keys = iter.k
    , key;
  if(keys == undefined){
    iter.k = keys = [];
    for(key in iter.o)keys.push(key);
  }
  do {
    if(iter.i >= keys.length)return step(1);
  } while(!((key = keys[iter.i++]) in iter.o));
  return step(0, key);
});

var reflect = {
  // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
  apply: function apply(target, thisArgument, argumentsList){
    return _apply.call(target, thisArgument, argumentsList);
  },
  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
  construct: function construct(target, argumentsList /*, newTarget*/){
    var proto    = assert.fn(arguments.length < 3 ? target : arguments[2]).prototype
      , instance = $.create(isObject(proto) ? proto : Object.prototype)
      , result   = _apply.call(target, instance, argumentsList);
    return isObject(result) ? result : instance;
  },
  // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
  defineProperty: function defineProperty(target, propertyKey, attributes){
    assertObject(target);
    try {
      $.setDesc(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.4 Reflect.deleteProperty(target, propertyKey)
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = $.getDesc(assertObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  },
  // 26.1.6 Reflect.get(target, propertyKey [, receiver])
  get: function get(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = $.getDesc(assertObject(target), propertyKey), proto;
    if(desc)return $.has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getProto(target))
      ? get(proto, propertyKey, receiver)
      : undefined;
  },
  // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return $.getDesc(assertObject(target), propertyKey);
  },
  // 26.1.8 Reflect.getPrototypeOf(target)
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(assertObject(target));
  },
  // 26.1.9 Reflect.has(target, propertyKey)
  has: function has(target, propertyKey){
    return propertyKey in target;
  },
  // 26.1.10 Reflect.isExtensible(target)
  isExtensible: function isExtensible(target){
    return _isExtensible(assertObject(target));
  },
  // 26.1.11 Reflect.ownKeys(target)
  ownKeys: require('./$.own-keys'),
  // 26.1.12 Reflect.preventExtensions(target)
  preventExtensions: function preventExtensions(target){
    assertObject(target);
    try {
      _preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
  set: function set(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = $.getDesc(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getProto(target))){
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = $.desc(0);
    }
    if($.has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || $.desc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
};
// 26.1.14 Reflect.setPrototypeOf(target, proto)
if(setProto)reflect.setPrototypeOf = function setPrototypeOf(target, proto){
  setProto.check(target, proto);
  try {
    setProto.set(target, proto);
    return true;
  } catch(e){
    return false;
  }
};

$def($def.G, {Reflect: {}});

$def($def.S + $def.F * buggyEnumerate, 'Reflect', {
  // 26.1.5 Reflect.enumerate(target)
  enumerate: function enumerate(target){
    return new Enumerate(assertObject(target));
  }
});

$def($def.S, 'Reflect', reflect);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.reflect.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"./$.def":12,"./$.iter":21,"./$.own-keys":25,"./$.set-proto":29,"./$.uid":36,"./$.wks":38,"_process":96,"buffer":91}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $       = require('./$')
  , cof     = require('./$.cof')
  , $RegExp = $.g.RegExp
  , Base    = $RegExp
  , proto   = $RegExp.prototype
  , re      = /a/g
  // "new" creates a new object
  , CORRECT_NEW = new $RegExp(re) !== re
  // RegExp allows a regex with flags as the pattern
  , ALLOWS_RE_WITH_FLAGS = function(){
    try {
      return $RegExp(re, 'i') == '/a/i';
    } catch(e){ /* empty */ }
  }();
if($.FW && $.DESC){
  if(!CORRECT_NEW || !ALLOWS_RE_WITH_FLAGS){
    $RegExp = function RegExp(pattern, flags){
      var patternIsRegExp  = cof(pattern) == 'RegExp'
        , flagsIsUndefined = flags === undefined;
      if(!(this instanceof $RegExp) && patternIsRegExp && flagsIsUndefined)return pattern;
      return CORRECT_NEW
        ? new Base(patternIsRegExp && !flagsIsUndefined ? pattern.source : pattern, flags)
        : new Base(patternIsRegExp ? pattern.source : pattern
          , patternIsRegExp && flagsIsUndefined ? pattern.flags : flags);
    };
    $.each.call($.getNames(Base), function(key){
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function(){ return Base[key]; },
        set: function(it){ Base[key] = it; }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    require('./$.redef')($.g, 'RegExp', $RegExp);
  }
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')$.setDesc(proto, 'flags', {
    configurable: true,
    get: require('./$.replacer')(/^.*\/(\w*)$/, '$1')
  });
}
require('./$.species')($RegExp);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.regexp.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.cof":6,"./$.redef":27,"./$.replacer":28,"./$.species":30,"_process":96,"buffer":91}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.set.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-strong":7,"_process":96,"buffer":91}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(false);
$def($def.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.code-point-at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-at":31,"_process":96,"buffer":91}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def')
  , toLength = $.toLength;

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.endsWith(/./); }), 'String', {
  // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that = String($.assertDefined(this))
      , endPosition = arguments[1]
      , len = toLength(that.length)
      , end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    searchString += '';
    return that.slice(end - searchString.length, end) === searchString;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.ends-with.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.cof":6,"./$.def":12,"./$.throws":35,"_process":96,"buffer":91}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def    = require('./$.def')
  , toIndex = require('./$').toIndex
  , fromCharCode = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res = []
      , len = arguments.length
      , i   = 0
      , code;
    while(len > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.from-code-point.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"_process":96,"buffer":91}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.7 String.prototype.includes(searchString, position = 0)
  includes: function includes(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    return !!~String($.assertDefined(this)).indexOf(searchString, arguments[1]);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.cof":6,"./$.def":12,"_process":96,"buffer":91}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var set   = require('./$').set
  , $at   = require('./$.string-at')(true)
  , ITER  = require('./$.uid').safe('iter')
  , $iter = require('./$.iter')
  , step  = $iter.step;

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  set(this, ITER, {o: String(iterated), i: 0});
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , index = iter.i
    , point;
  if(index >= O.length)return step(1);
  point = $at(O, index);
  iter.i += point.length;
  return step(0, point);
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.iterator.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.iter":21,"./$.iter-define":19,"./$.string-at":31,"./$.uid":36,"_process":96,"buffer":91}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $    = require('./$')
  , $def = require('./$.def');

$def($def.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl = $.toObject(callSite.raw)
      , len = $.toLength(tpl.length)
      , sln = arguments.length
      , res = []
      , i   = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < sln)res.push(String(arguments[i]));
    } return res.join('');
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.raw.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"_process":96,"buffer":91}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./$.string-repeat')
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.repeat.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-repeat":33,"_process":96,"buffer":91}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.startsWith(/./); }), 'String', {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
  startsWith: function startsWith(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that  = String($.assertDefined(this))
      , index = $.toLength(Math.min(arguments[1], that.length));
    searchString += '';
    return that.slice(index, index + searchString.length) === searchString;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.starts-with.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.cof":6,"./$.def":12,"./$.throws":35,"_process":96,"buffer":91}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// ECMAScript 6 symbols shim
var $        = require('./$')
  , setTag   = require('./$.cof').set
  , uid      = require('./$.uid')
  , $def     = require('./$.def')
  , $redef   = require('./$.redef')
  , keyOf    = require('./$.keyof')
  , enumKeys = require('./$.enum-keys')
  , assertObject = require('./$.assert').obj
  , has      = $.has
  , $create  = $.create
  , getDesc  = $.getDesc
  , setDesc  = $.setDesc
  , desc     = $.desc
  , getNames = $.getNames
  , toObject = $.toObject
  , $Symbol  = $.g.Symbol
  , setter   = false
  , TAG      = uid('tag')
  , HIDDEN   = uid('hidden')
  , _propertyIsEnumerable = {}.propertyIsEnumerable
  , SymbolRegistry = {}
  , AllSymbols = {}
  , useNative = $.isFunction($Symbol);

function wrap(tag){
  var sym = AllSymbols[tag] = $.set($create($Symbol.prototype), TAG, tag);
  $.DESC && setter && setDesc(Object.prototype, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setDesc(this, tag, desc(1, value));
    }
  });
  return sym;
}

function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, desc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = $create(D, {enumerable: desc(0, false)});
    }
  } return setDesc(it, key, D);
}
function defineProperties(it, P){
  assertObject(it);
  var keys = enumKeys(P = toObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)defineProperty(it, key = keys[i++], P[key]);
  return it;
}
function create(it, P){
  return P === undefined ? $create(it) : defineProperties($create(it), P);
}
function propertyIsEnumerable(key){
  var E = _propertyIsEnumerable.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
}
function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
}
function getOwnPropertyNames(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
}
function getOwnPropertySymbols(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
}

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments[0]));
  };
  $redef($Symbol.prototype, 'toString', function(){
    return this[TAG];
  });

  $.create     = create;
  $.setDesc    = defineProperty;
  $.getDesc    = getOwnPropertyDescriptor;
  $.setDescs   = defineProperties;
  $.getNames   = getOwnPropertyNames;
  $.getSymbols = getOwnPropertySymbols;

  if($.DESC && $.FW)$redef(Object.prototype, 'propertyIsEnumerable', propertyIsEnumerable, true);
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
    'species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), function(it){
    var sym = require('./$.wks')(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  }
);

setter = true;

$def($def.G + $def.W, {Symbol: $Symbol});

$def($def.S, 'Symbol', symbolStatics);

$def($def.S + $def.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: getOwnPropertySymbols
});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setTag($.g.JSON, 'JSON', true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.symbol.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.enum-keys":14,"./$.keyof":23,"./$.redef":27,"./$.uid":36,"./$.wks":38,"_process":96,"buffer":91}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $         = require('./$')
  , weak      = require('./$.collection-weak')
  , leakStore = weak.leakStore
  , ID        = weak.ID
  , WEAK      = weak.WEAK
  , has       = $.has
  , isObject  = $.isObject
  , isExtensible = Object.isExtensible || isObject
  , tmp       = {};

// 23.3 WeakMap Objects
var WeakMap = require('./$.collection')('WeakMap', {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      if(!isExtensible(key))return leakStore(this).get(key);
      if(has(key, WEAK))return key[WEAK][this[ID]];
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
}, weak, true, true);

// IE11 WeakMap frozen keys fix
if($.FW && new WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  $.each.call(['delete', 'has', 'get', 'set'], function(key){
    var proto  = WeakMap.prototype
      , method = proto[key];
    require('./$.redef')(proto, key, function(a, b){
      // store frozen objects on leaky map
      if(isObject(a) && !isExtensible(a)){
        var result = leakStore(this)[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.weak-map.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.collection":10,"./$.collection-weak":9,"./$.redef":27,"_process":96,"buffer":91}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var weak = require('./$.collection-weak');

// 23.4 WeakSet Objects
require('./$.collection')('WeakSet', {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.weak-set.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-weak":9,"_process":96,"buffer":91}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/domenic/Array.prototype.includes
var $def      = require('./$.def')
  , $includes = require('./$.array-includes')(true);
$def($def.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments[1]);
  }
});
require('./$.unscope')('includes');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.array.includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-includes":2,"./$.def":12,"./$.unscope":37,"_process":96,"buffer":91}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Map');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.map.to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection-to-json":8,"_process":96,"buffer":91}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://gist.github.com/WebReflection/9353781
var $       = require('./$')
  , $def    = require('./$.def')
  , ownKeys = require('./$.own-keys');

$def($def.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O      = $.toObject(object)
      , result = {};
    $.each.call(ownKeys(O), function(key){
      $.setDesc(result, key, $.desc(0, $.getDesc(O, key)));
    });
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"./$.own-keys":25,"_process":96,"buffer":91}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://goo.gl/XkBrjD
var $    = require('./$')
  , $def = require('./$.def');
function createObjectToArray(isEntries){
  return function(object){
    var O      = $.toObject(object)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = Array(length)
      , key;
    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
    else while(length > i)result[i] = O[keys[i++]];
    return result;
  };
}
$def($def.S, 'Object', {
  values:  createObjectToArray(false),
  entries: createObjectToArray(true)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.object.to-array.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"_process":96,"buffer":91}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://gist.github.com/kangax/9698100
var $def = require('./$.def');
$def($def.S, 'RegExp', {
  escape: require('./$.replacer')(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.regexp.escape.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.replacer":28,"_process":96,"buffer":91}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Set');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.set.to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection-to-json":8,"_process":96,"buffer":91}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/mathiasbynens/String.prototype.at
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(true);
$def($def.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-at":31,"_process":96,"buffer":91}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  lpad: function lpad(n){
    return $pad(this, n, arguments[1], true);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.lpad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-pad":32,"_process":96,"buffer":91}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  rpad: function rpad(n){
    return $pad(this, n, arguments[1], false);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.rpad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-pad":32,"_process":96,"buffer":91}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// JavaScript 1.6 / Strawman array statics shim
var $       = require('./$')
  , $def    = require('./$.def')
  , $Array  = $.core.Array || Array
  , statics = {};
function setStatics(keys, length){
  $.each.call(keys.split(','), function(key){
    if(length == undefined && key in $Array)statics[key] = $Array[key];
    else if(key in [])statics[key] = require('./$.ctx')(Function.call, [][key], length);
  });
}
setStatics('pop,reverse,shift,keys,values,entries', 1);
setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
           'reduce,reduceRight,copyWithin,fill,turn');
$def($def.S, 'Array', statics);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/js.array.statics.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.ctx":11,"./$.def":12,"_process":96,"buffer":91}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./es6.array.iterator');
var $           = require('./$')
  , Iterators   = require('./$.iter').Iterators
  , ITERATOR    = require('./$.wks')('iterator')
  , ArrayValues = Iterators.Array
  , NodeList    = $.g.NodeList;
if($.FW && NodeList && !(ITERATOR in NodeList.prototype)){
  $.hide(NodeList.prototype, ITERATOR, ArrayValues);
}
Iterators.NodeList = ArrayValues;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.dom.iterable.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.iter":21,"./$.wks":38,"./es6.array.iterator":45,"_process":96,"buffer":91}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def  = require('./$.def')
  , $task = require('./$.task');
$def($def.G + $def.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.immediate.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.task":34,"_process":96,"buffer":91}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// ie9- setTimeout & setInterval additional parameters fix
var $         = require('./$')
  , $def      = require('./$.def')
  , invoke    = require('./$.invoke')
  , partial   = require('./$.partial')
  , navigator = $.g.navigator
  , MSIE      = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
function wrap(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      $.isFunction(fn) ? fn : Function(fn)
    ), time);
  } : set;
}
$def($def.G + $def.B + $def.F * MSIE, {
  setTimeout:  wrap($.g.setTimeout),
  setInterval: wrap($.g.setInterval)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.timers.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":22,"./$.def":12,"./$.invoke":17,"./$.partial":26,"_process":96,"buffer":91}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./modules/es5');
require('./modules/es6.symbol');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.object.statics-accept-primitives');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.number.constructor');
require('./modules/es6.number.statics');
require('./modules/es6.math');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.iterator');
require('./modules/es6.array.species');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.regexp');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.reflect');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.lpad');
require('./modules/es7.string.rpad');
require('./modules/es7.regexp.escape');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.to-array');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/js.array.statics');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/$').core;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/shim.js","/node_modules/babel-core/node_modules/core-js")

},{"./modules/$":22,"./modules/es5":39,"./modules/es6.array.copy-within":40,"./modules/es6.array.fill":41,"./modules/es6.array.find":43,"./modules/es6.array.find-index":42,"./modules/es6.array.from":44,"./modules/es6.array.iterator":45,"./modules/es6.array.of":46,"./modules/es6.array.species":47,"./modules/es6.function.has-instance":48,"./modules/es6.function.name":49,"./modules/es6.map":50,"./modules/es6.math":51,"./modules/es6.number.constructor":52,"./modules/es6.number.statics":53,"./modules/es6.object.assign":54,"./modules/es6.object.is":55,"./modules/es6.object.set-prototype-of":56,"./modules/es6.object.statics-accept-primitives":57,"./modules/es6.object.to-string":58,"./modules/es6.promise":59,"./modules/es6.reflect":60,"./modules/es6.regexp":61,"./modules/es6.set":62,"./modules/es6.string.code-point-at":63,"./modules/es6.string.ends-with":64,"./modules/es6.string.from-code-point":65,"./modules/es6.string.includes":66,"./modules/es6.string.iterator":67,"./modules/es6.string.raw":68,"./modules/es6.string.repeat":69,"./modules/es6.string.starts-with":70,"./modules/es6.symbol":71,"./modules/es6.weak-map":72,"./modules/es6.weak-set":73,"./modules/es7.array.includes":74,"./modules/es7.map.to-json":75,"./modules/es7.object.get-own-property-descriptors":76,"./modules/es7.object.to-array":77,"./modules/es7.regexp.escape":78,"./modules/es7.set.to-json":79,"./modules/es7.string.at":80,"./modules/es7.string.lpad":81,"./modules/es7.string.rpad":82,"./modules/js.array.statics":83,"./modules/web.dom.iterable":84,"./modules/web.immediate":85,"./modules/web.timers":86,"_process":96,"buffer":91}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(
      innerFn, self || null,
      new Context(tryLocsList || [])
    );

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    return new Promise(function(resolve, reject) {
      var generator = wrap(innerFn, outerFn, self, tryLocsList);
      var callNext = step.bind(generator, "next");
      var callThrow = step.bind(generator, "throw");

      function step(method, arg) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
          return;
        }

        var info = record.arg;
        if (info.done) {
          resolve(info.value);
        } else {
          Promise.resolve(info.value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  function defineGeneratorMethod(method) {
    Gp[method] = function(arg) {
      return this._invoke(method, arg);
    };
  }
  defineGeneratorMethod("next");
  defineGeneratorMethod("throw");
  defineGeneratorMethod("return");

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/regenerator/runtime.js","/node_modules/babel-core/node_modules/regenerator")

},{"_process":96,"buffer":91}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = require("./lib/babel/polyfill");

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/polyfill.js","/node_modules/babel-core")

},{"./lib/babel/polyfill":1,"_process":96,"buffer":91}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = require("babel-core/polyfill");

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babelify/polyfill.js","/node_modules/babelify")

},{"_process":96,"babel-core/polyfill":89,"buffer":91}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
    return fromTypedArray(that, object)
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = String(string)

  if (string.length === 0) return 0

  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      return string.length
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return string.length * 2
    case 'hex':
      return string.length >>> 1
    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(string).length
    case 'base64':
      return base64ToBytes(string).length
    default:
      return string.length
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/index.js","/node_modules/browserify/node_modules/buffer")

},{"_process":96,"base64-js":92,"buffer":91,"ieee754":93,"is-array":94}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib")

},{"_process":96,"buffer":91}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","/node_modules/browserify/node_modules/buffer/node_modules/ieee754")

},{"_process":96,"buffer":91}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js","/node_modules/browserify/node_modules/buffer/node_modules/is-array")

},{"_process":96,"buffer":91}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/events/events.js","/node_modules/browserify/node_modules/events")

},{"_process":96,"buffer":91}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/process/browser.js","/node_modules/browserify/node_modules/process")

},{"_process":96,"buffer":91}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/punycode/punycode.js","/node_modules/browserify/node_modules/punycode")

},{"_process":96,"buffer":91}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/decode.js","/node_modules/browserify/node_modules/querystring-es3")

},{"_process":96,"buffer":91}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/encode.js","/node_modules/browserify/node_modules/querystring-es3")

},{"_process":96,"buffer":91}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/index.js","/node_modules/browserify/node_modules/querystring-es3")

},{"./decode":98,"./encode":99,"_process":96,"buffer":91}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/url/url.js","/node_modules/browserify/node_modules/url")

},{"_process":96,"buffer":91,"punycode":97,"querystring":100}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

The MIT License (MIT)

Original Library 
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var ansiStyles = colors.styles = require('./styles');
var defineProps = Object.defineProperties;

colors.supportsColor = require('./system/supports-colors');

if (typeof colors.enabled === "undefined") {
  colors.enabled = colors.supportsColor;
}

colors.stripColors = colors.strip = function(str){
  return ("" + str).replace(/\x1B\[\d+m/g, '');
};


var stylize = colors.stylize = function stylize (str, style) {
  if (!colors.enabled) {
    return str+'';
  }

  return ansiStyles[style].open + str + ansiStyles[style].close;
}

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe,  '\\$&');
}

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function () {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function (key) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function () {
        return build(this._styles.concat(key));
      }
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = arguments;
  var argsLen = args.length;
  var str = argsLen !== 0 && String(arguments[0]);
  if (argsLen > 1) {
    for (var a = 1; a < argsLen; a++) {
      str += ' ' + args[a];
    }
  }

  if (!colors.enabled || !str) {
    return str;
  }

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
  }

  return str;
}

function applyTheme (theme) {
  for (var style in theme) {
    (function(style){
      colors[style] = function(str){
        if (typeof theme[style] === 'object'){
          var out = str;
          for (var i in theme[style]){
            out = colors[theme[style][i]](out);
          }
          return out;
        }
        return colors[theme[style]](str);
      };
    })(style)
  }
}

colors.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      colors.themes[theme] = require(theme);
      applyTheme(colors.themes[theme]);
      return colors.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function (name) {
    ret[name] = {
      get: function () {
        return build([name]);
      }
    };
  });
  return ret;
}

var sequencer = function sequencer (map, str) {
  var exploded = str.split(""), i = 0;
  exploded = exploded.map(map);
  return exploded.join("");
};

// custom formatter methods
colors.trap = require('./custom/trap');
colors.zalgo = require('./custom/zalgo');

// maps
colors.maps = {};
colors.maps.america = require('./maps/america');
colors.maps.zebra = require('./maps/zebra');
colors.maps.rainbow = require('./maps/rainbow');
colors.maps.random = require('./maps/random')

for (var map in colors.maps) {
  (function(map){
    colors[map] = function (str) {
      return sequencer(colors.maps[map], str);
    }
  })(map)
}

defineProps(colors, init());
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/colors.js","/node_modules/colors/lib")

},{"./custom/trap":103,"./custom/zalgo":104,"./maps/america":107,"./maps/rainbow":108,"./maps/random":109,"./maps/zebra":110,"./styles":111,"./system/supports-colors":112,"_process":96,"buffer":91}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module['exports'] = function runTheTrap (text, options) {
  var result = "";
  text = text || "Run the trap, drop the bass";
  text = text.split('');
  var trap = {
    a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
    b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
    c: ["\u00a9", "\u023b", "\u03fe"],
    d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
    e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
    f: ["\u04fa"],
    g: ["\u0262"],
    h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
    i: ["\u0f0f"],
    j: ["\u0134"],
    k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
    l: ["\u0139"],
    m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
    n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
    o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
    p: ["\u01f7", "\u048e"],
    q: ["\u09cd"],
    r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
    s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
    t: ["\u0141", "\u0166", "\u0373"],
    u: ["\u01b1", "\u054d"],
    v: ["\u05d8"],
    w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
    x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
    y: ["\u00a5", "\u04b0", "\u04cb"],
    z: ["\u01b5", "\u0240"]
  }
  text.forEach(function(c){
    c = c.toLowerCase();
    var chars = trap[c] || [" "];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== "undefined") {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;

}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/custom/trap.js","/node_modules/colors/lib/custom")

},{"_process":96,"buffer":91}],104:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// please no
module['exports'] = function zalgo(text, options) {
  text = text || "   he is here   ";
  var soul = {
    "up" : [
      'Ì', 'ÌŽ', 'Ì„', 'Ì…',
      'Ì¿', 'Ì‘', 'Ì†', 'Ì',
      'Í’', 'Í—', 'Í‘', 'Ì‡',
      'Ìˆ', 'ÌŠ', 'Í‚', 'Ì“',
      'Ìˆ', 'ÍŠ', 'Í‹', 'ÍŒ',
      'Ìƒ', 'Ì‚', 'ÌŒ', 'Í',
      'Ì€', 'Ì', 'Ì‹', 'Ì',
      'Ì’', 'Ì“', 'Ì”', 'Ì½',
      'Ì‰', 'Í£', 'Í¤', 'Í¥',
      'Í¦', 'Í§', 'Í¨', 'Í©',
      'Íª', 'Í«', 'Í¬', 'Í­',
      'Í®', 'Í¯', 'Ì¾', 'Í›',
      'Í†', 'Ìš'
    ],
    "down" : [
      'Ì–', 'Ì—', 'Ì˜', 'Ì™',
      'Ìœ', 'Ì', 'Ìž', 'ÌŸ',
      'Ì ', 'Ì¤', 'Ì¥', 'Ì¦',
      'Ì©', 'Ìª', 'Ì«', 'Ì¬',
      'Ì­', 'Ì®', 'Ì¯', 'Ì°',
      'Ì±', 'Ì²', 'Ì³', 'Ì¹',
      'Ìº', 'Ì»', 'Ì¼', 'Í…',
      'Í‡', 'Íˆ', 'Í‰', 'Í',
      'ÍŽ', 'Í“', 'Í”', 'Í•',
      'Í–', 'Í™', 'Íš', 'Ì£'
    ],
    "mid" : [
      'Ì•', 'Ì›', 'Ì€', 'Ì',
      'Í˜', 'Ì¡', 'Ì¢', 'Ì§',
      'Ì¨', 'Ì´', 'Ìµ', 'Ì¶',
      'Íœ', 'Í', 'Íž',
      'ÍŸ', 'Í ', 'Í¢', 'Ì¸',
      'Ì·', 'Í¡', ' Ò‰'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }
  

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] =   typeof options["up"]   !== 'undefined' ? options["up"]   : true;
    options["mid"] =  typeof options["mid"]  !== 'undefined' ? options["mid"]  : true;
    options["down"] = typeof options["down"] !== 'undefined' ? options["down"] : true;
    options["size"] = typeof options["size"] !== 'undefined' ? options["size"] : "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.mid = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.mid = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text, options);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/custom/zalgo.js","/node_modules/colors/lib/custom")

},{"_process":96,"buffer":91}],105:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('./colors');

module['exports'] = function () {

  //
  // Extends prototype of native string object to allow for "foo".red syntax
  //
  var addProperty = function (color, func) {
    String.prototype.__defineGetter__(color, func);
  };

  var sequencer = function sequencer (map, str) {
      return function () {
        var exploded = this.split(""), i = 0;
        exploded = exploded.map(map);
        return exploded.join("");
      }
  };

  addProperty('strip', function () {
    return colors.strip(this);
  });

  addProperty('stripColors', function () {
    return colors.strip(this);
  });

  addProperty("trap", function(){
    return colors.trap(this);
  });

  addProperty("zalgo", function(){
    return colors.zalgo(this);
  });

  addProperty("zebra", function(){
    return colors.zebra(this);
  });

  addProperty("rainbow", function(){
    return colors.rainbow(this);
  });

  addProperty("random", function(){
    return colors.random(this);
  });

  addProperty("america", function(){
    return colors.america(this);
  });

  //
  // Iterate through all default styles and colors
  //
  var x = Object.keys(colors.styles);
  x.forEach(function (style) {
    addProperty(style, function () {
      return colors.stylize(this, style);
    });
  });

  function applyTheme(theme) {
    //
    // Remark: This is a list of methods that exist
    // on String that you should not overwrite.
    //
    var stringPrototypeBlacklist = [
      '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
      'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
      'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
      'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
    ];

    Object.keys(theme).forEach(function (prop) {
      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
        console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
      }
      else {
        if (typeof(theme[prop]) === 'string') {
          colors[prop] = colors[theme[prop]];
          addProperty(prop, function () {
            return colors[theme[prop]](this);
          });
        }
        else {
          addProperty(prop, function () {
            var ret = this;
            for (var t = 0; t < theme[prop].length; t++) {
              ret = exports[theme[prop][t]](ret);
            }
            return ret;
          });
        }
      }
    });
  }

  colors.setTheme = function (theme) {
    if (typeof theme === 'string') {
      try {
        colors.themes[theme] = require(theme);
        applyTheme(colors.themes[theme]);
        return colors.themes[theme];
      } catch (err) {
        console.log(err);
        return err;
      }
    } else {
      applyTheme(theme);
    }
  };

};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/extendStringPrototype.js","/node_modules/colors/lib")

},{"./colors":102,"_process":96,"buffer":91}],106:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('./colors');
module['exports'] = colors;

// Remark: By default, colors will add style properties to String.prototype
//
// If you don't wish to extend String.prototype you can do this instead and native String will not be touched
//
//   var colors = require('colors/safe);
//   colors.red("foo")
//
//
require('./extendStringPrototype')();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/index.js","/node_modules/colors/lib")

},{"./colors":102,"./extendStringPrototype":105,"_process":96,"buffer":91}],107:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function() {
  return function (letter, i, exploded) {
    if(letter === " ") return letter;
    switch(i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter)
      case 2: return colors.blue(letter)
    }
  }
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/america.js","/node_modules/colors/lib/maps")

},{"../colors":102,"_process":96,"buffer":91}],108:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
})();


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/rainbow.js","/node_modules/colors/lib/maps")

},{"../colors":102,"_process":96,"buffer":91}],109:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function () {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
  return function(letter, i, exploded) {
    return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
  };
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/random.js","/node_modules/colors/lib/maps")

},{"../colors":102,"_process":96,"buffer":91}],110:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = function (letter, i, exploded) {
  return i % 2 === 0 ? letter : colors.inverse(letter);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/zebra.js","/node_modules/colors/lib/maps")

},{"../colors":102,"_process":96,"buffer":91}],111:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49]

};

Object.keys(codes).forEach(function (key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/styles.js","/node_modules/colors/lib")

},{"_process":96,"buffer":91}],112:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var argv = process.argv;

module.exports = (function () {
  if (argv.indexOf('--no-color') !== -1 ||
    argv.indexOf('--color=false') !== -1) {
    return false;
  }

  if (argv.indexOf('--color') !== -1 ||
    argv.indexOf('--color=true') !== -1 ||
    argv.indexOf('--color=always') !== -1) {
    return true;
  }

  if (process.stdout && !process.stdout.isTTY) {
    return false;
  }

  if (process.platform === 'win32') {
    return true;
  }

  if ('COLORTERM' in process.env) {
    return true;
  }

  if (process.env.TERM === 'dumb') {
    return false;
  }

  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    return true;
  }

  return false;
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/system/supports-colors.js","/node_modules/colors/lib/system")

},{"_process":96,"buffer":91}],113:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Generated by CoffeeScript 1.7.1
module.exports = {
  100: 'Continue',
  101: 'Switching Protocols',
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  307: 'Temporary Redirect',
  400: 'Bad Request',
  401: 'Unauthorized',
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Time-out',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Request Entity Too Large',
  414: 'Request-URI Too Large',
  415: 'Unsupported Media Type',
  416: 'Requested Range not Satisfiable',
  417: 'Expectation Failed',
  422: 'Unprocessable Entity',
  429: 'Too Many Requests',
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Time-out',
  505: 'HTTP Version not Supported',
  CONTINUE: 100,
  SWITCHING_PROTOCOLS: 101,
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NON_AUTHORITATIVE_INFORMATION: 203,
  NO_CONTENT: 204,
  RESET_CONTENT: 205,
  PARTIAL_CONTENT: 206,
  MULTIPLE_CHOICES: 300,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  USE_PROXY: 305,
  TEMPORARY_REDIRECT: 307,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  REQUEST_ENTITY_TOO_LARGE: 413,
  REQUEST_URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  REQUESTED_RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,
  UNPROCESSABLE_ENTITY: 422,
  TOO_MANY_REQUESTS: 429,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/http-status/lib/index.js","/node_modules/http-status/lib")

},{"_process":96,"buffer":91}],114:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * @license
 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
      descriptor.value = null;
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * https://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.2';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/lodash/dist/lodash.js","/node_modules/lodash/dist")

},{"_process":96,"buffer":91}],115:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
	costs: {
		delete: number | function ( char )
		insert: number | function ( char )
		replace: number | function ( what, by )
		transpose: number | function ( left, right )
	}
*/

"use strict";

function getCost(costs, op, a, b) {
	var cost = typeof costs == "object" ? costs[op] : costs;
	return typeof cost == "function" ? cost.call(costs, a, b) : cost;
}

module.exports = function (s1, s2) {
	var costs = arguments[2] === undefined ? 1 : arguments[2];

	var d = [];
	for (var i = 0; i <= s1.length; ++i) {
		d[i] = i < 3 ? [] : d[i - 3]; // some optimization
		for (var j = 0; j <= s2.length; ++j) {
			d[i][j] = i == 0 && j == 0 ? 0 : i == 0 ? d[i][j - 1] + getCost(costs, "insert", s2[j - 1]) : j == 0 ? d[i - 1][j] + getCost(costs, "delete", s1[i - 1]) : Math.min(d[i - 1][j] + getCost(costs, "delete", s1[i - 1]), d[i][j - 1] + getCost(costs, "insert", s2[j - 1]), d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : getCost(costs, "replace", s1[i - 1], s2[j - 1])), i > 1 && j > 1 && s1[i - 1] == s2[j - 2] && s1[i - 2] == s2[j - 1] ? d[i - 2][j - 2] + getCost(costs, "transpose", s1[i - 2], s1[i - 1]) : Infinity);
		}
	}
	return d[s1.length][s2.length];
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/DamerauLevenshtein.js","/src")

},{"_process":96,"buffer":91}],116:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ra = require("ra");

module.exports = function (key) {
	var defaults = arguments[1] === undefined ? null : arguments[1];

	var ret = ra.clean(defaults).setConst("reset", function () {
		localStorage.removeItem(key);
		ret.assign(defaults);
	}).setName("localStorage." + key);
	var stored = localStorage.getItem(key);
	if (stored != null) ret.assign(JSON.parse(stored));
	ra.clean(function () {
		if (ret.valueOf() != defaults) localStorage.setItem(key, JSON.stringify(ret));
	});
	return ret;
};
// ret.loaded = true

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/JSONlocal.js","/src")

},{"_process":96,"buffer":91,"ra":136}],117:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

require("colors");

var LOG = function LOG(msg) {
  for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    data[_key - 1] = arguments[_key];
  }

  return console.log.apply(console, ["" + new Date().toISOString().replace("T", "=").replace("Z", "") + " " + msg].concat(data));
};
LOG.LOG = LOG;
LOG.INFO = LOG;
LOG.TRACE = LOG;
LOG.ERROR = LOG;
LOG.WARNING = LOG;

module.exports = LOG;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/LOG.js","/src")

},{"_process":96,"buffer":91,"colors":106}],118:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var lodash = require("lodash");

var PongJSON = (function (_require) {
	function PongJSON(q) {
		var _this = this;

		_classCallCheck(this, PongJSON);

		_get(Object.getPrototypeOf(PongJSON.prototype), "constructor", this).call(this);
		this._q = q;
		this.pipeFrom(q);
		q.onmessage = function (message) {
			return _this._message(message);
		};
	}

	_inherits(PongJSON, _require);

	_createClass(PongJSON, [{
		key: "unwise",
		value: function unwise() {
			var q = this._q;
			this._q = null;
			q.onopen = null;
			q.onclose = null;
			q.onerror = null;
			q.onmessage = null;
			return q.unwise ? q.unwise() : q;
		}
	}, {
		key: "_message",
		value: function _message(message) {
			if (message.what == "ping") this._q.send({ what: "pong", pong: message.ping });else this.domessage(message);
		}
	}, {
		key: "_send",
		value: function _send(message) {
			this._q.send(message);
		}
	}, {
		key: "_close",
		value: function _close() {
			this._q.onclose = null;
			this._q.close();
		}
	}]);

	return PongJSON;
})(require("WebQueue"));

var PingPongJSON = (function (_PongJSON) {
	function PingPongJSON(q) {
		var _this2 = this;

		var _ref = arguments[1] === undefined ? {} : arguments[1];

		var _ref$interval = _ref.interval;
		var interval = _ref$interval === undefined ? 60000 : _ref$interval;
		var _ref$timeout = _ref.timeout;
		var timeout = _ref$timeout === undefined ? 15000 : _ref$timeout;
		var _ref$maxpings = _ref.maxpings;
		var maxpings = _ref$maxpings === undefined ? 1000 : _ref$maxpings;

		_classCallCheck(this, PingPongJSON);

		_get(Object.getPrototypeOf(PingPongJSON.prototype), "constructor", this).call(this, q);
		this._pings = {};
		this._count = 0;
		this._pinterval = interval == Infinity ? null : setInterval(function () {
			return _this2.ping();
		}, interval);
		this._timeout = timeout;
		this._maxpings = maxpings;
	}

	_inherits(PingPongJSON, _PongJSON);

	_createClass(PingPongJSON, [{
		key: "_message",
		value: function _message(message) {
			if (message.what == "pong") {
				if (Object.prototype.hasOwnProperty.call(this._pings, message.pong)) {
					clearTimeout(this._pings[message.pong]);
					delete this._pings[message.pong];
					--this._count;
				}
			} else _get(Object.getPrototypeOf(PingPongJSON.prototype), "_message", this).call(this, message);
		}
	}, {
		key: "_send",
		value: function _send(message) {
			_get(Object.getPrototypeOf(PingPongJSON.prototype), "_send", this).call(this, message);
			this.ping();
		}
	}, {
		key: "_close",
		value: function _close() {
			clearInterval(this._pinterval);
			this._pinterval = null;
			lodash.forEach(this._pings, function (t) {
				return clearTimeout(t);
			});
			this._pings = null;
			_get(Object.getPrototypeOf(PingPongJSON.prototype), "_close", this).call(this);
		}
	}, {
		key: "ping",
		value: function ping() {
			var _this3 = this;

			if (!this._q) return;
			if (this._count > this._maxpings) return this._ontimeout();
			var id = "" + Math.random();
			this._q.send({ what: "ping", ping: id });
			this._pings[id] = setTimeout(function () {
				console.log(id.red);
				_this3._ontimeout();
			}, this._timeout);
			++this._count;
		}
	}, {
		key: "_ontimeout",
		value: function _ontimeout() {
			try {
				this.doerror(new Error("timeout"));
			} finally {
				this.close();
			}
		}
	}]);

	return PingPongJSON;
})(PongJSON);

module.exports = function (q, options) {
	return new PingPongJSON(q, options);
};
module.exports.silent = function (q) {
	return new PongJSON(q);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/PingPongJSON.js","/src")

},{"WebQueue":119,"_process":96,"buffer":91,"lodash":114}],119:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WebQueue = (function () {
	function WebQueue() {
		_classCallCheck(this, WebQueue);

		this.onopen = null;
		this.onclose = null;
		this.onmessage = null;
		this.onerror = null;
		this._closed = false;
		this._opened = false;
	}

	_createClass(WebQueue, [{
		key: "doopen",
		value: function doopen() {
			if (!this._closed && this.onopen && !this._opened) {
				this._opened = true;
				this.onopen();
			}
		}
	}, {
		key: "doclose",
		value: function doclose() {
			if (this.onclose) this.onclose();
		}
	}, {
		key: "domessage",
		value: function domessage(message) {
			if (!this._closed && this.onmessage) {
				if (!this._opened) this.doopen();
				this.onmessage(message);
			}
		}
	}, {
		key: "doerror",
		value: function doerror(error) {
			if (this.onerror) this.onerror(error);else process.nextTick(function () {
				throw error;
			});
		}
	}, {
		key: "_send",
		value: function _send() {}
	}, {
		key: "send",
		value: function send(message) {
			if (!this._closed) this._send(message);
		}
	}, {
		key: "_close",
		value: function _close() {}
	}, {
		key: "close",
		value: function close() {
			if (this._closed) return;
			try {
				this._close();
			} finally {
				this._closed = true;
				this.doclose();
			}
		}
	}, {
		key: "pipeFrom",
		value: function pipeFrom(q) {
			var _this = this;

			q.onopen = function () {
				return _this.doopen();
			};
			q.onclose = function () {
				return _this.close();
			};
			q.onerror = function (error) {
				return _this.doerror(error);
			};
			q.onmessage = function (message) {
				return _this.domessage(message);
			};
		}
	}]);

	return WebQueue;
})();

module.exports = WebQueue;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/WebQueue.js","/src")

},{"_process":96,"buffer":91}],120:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var WebSocketToJSON = (function (_require) {
	function WebSocketToJSON(ws) {
		var _this = this;

		_classCallCheck(this, WebSocketToJSON);

		_get(Object.getPrototypeOf(WebSocketToJSON.prototype), "constructor", this).call(this);
		this._ws = ws;
		this.pipeFrom(ws);
		ws.onmessage = function (event) {
			var message = undefined;
			try {
				message = JSON.parse(String(event.data));
			} catch (error) {
				return _this.doerror(error);
			}
			_this.domessage(message);
		};
	}

	_inherits(WebSocketToJSON, _require);

	_createClass(WebSocketToJSON, [{
		key: "unwise",
		value: function unwise() {
			var ws = this._ws;
			this._ws = null;
			ws.onopen = null;
			ws.onclose = null;
			ws.onerror = null;
			ws.onmessage = null;
			return ws;
		}
	}, {
		key: "_send",
		value: function _send(message) {
			this._ws.send(JSON.stringify(message));
		}
	}, {
		key: "_close",
		value: function _close() {
			this._ws.onclose = null;
			this._ws.close();
		}
	}]);

	return WebSocketToJSON;
})(require("WebQueue"));

module.exports = function (ws) {
	return new WebSocketToJSON(ws);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/WebSocketToJSON.js","/src")

},{"WebQueue":119,"_process":96,"buffer":91}],121:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

TODO 2015.03.25 Ð£ Ð¢Ð— Ð½Ðµ Ð±Ñ‹Ð»Ð¾: Ð ÑÐ´Ð°Ð³Ð°Ð²Ð°Ð½ÑŒÐ½Ðµ Ð¼ÐµÑÑ†Ð°Ñž Ð¼Ð°Ð³Ñ‡Ñ‹Ð¼Ð° Ð¿Ð°Ñ‚Ñ€ÑÐ±Ð½Ð°Ðµ Ñ‚Ð¾Ð»ÑŒÐºÑ– Ð»Ð°ÐºÐ°Ð»ÑŒÐ½Ð° Ð· Ð°ÑÐ¾Ð±Ð½Ñ‹Ð¼Ñ– ÐºÐ°Ð¼Ð°Ð½Ð´Ð°Ð¼Ñ– Ð¼ÐµÐ½ÑŽ "Ð·Ð°Ñ…Ð°Ð²Ð°Ñ†ÑŒ Ð´Ð»Ñ Ð·Ð¼Ð¾ÑžÑ‡Ð°Ð½Ð°Ð³Ð°" Ñ– "Ð·Ð°Ð³Ñ€ÑƒÐ·Ñ–Ñ†ÑŒ Ð½Ð° ÑžÑÐµ Ð¿Ñ€Ñ‹Ð»Ð°Ð´Ñ‹".

*/
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var JSONlocal = require("JSONlocal");
var lu = require("localUtils");
var ra = require("ra");
var lodash = require("lodash");
var UID = require("uid");
var httpClient = require("httpClient");
var EventEmitter = require("events").EventEmitter || require("events");
var deviceActions = require("netro/deviceActions");
var HTTPStatus = require("http-status");
var WebSocketToJSON = require("WebSocketToJSON");
var PingPongJSON = require("PingPongJSON");
var devdb = require("devdb");

var WebSocketRetry = 1000;
var savePlacesTimeout = 3000;

var PersistentWebSocket = (function (_EventEmitter) {
	function PersistentWebSocket(url) {
		_classCallCheck(this, PersistentWebSocket);

		_get(Object.getPrototypeOf(PersistentWebSocket.prototype), "constructor", this).call(this);
		this.connected = false;
		this.closed = false;
		this._ws = null;
		this._sheduledCreating = null;
		this._first = true;
		this._lastClose = -Infinity;
		this.url = url;
		this.user = undefined;
		this.key = undefined
		// window.addEventListener( `_application_resumed` )
		;
	}

	_inherits(PersistentWebSocket, _EventEmitter);

	_createClass(PersistentWebSocket, [{
		key: "url",
		get: function () {
			return this._url;
		},
		set: function (url) {
			this._url = url;
			this._createHandle();
		}
	}, {
		key: "_setConnected",
		value: function _setConnected(value) {
			value = !!value;
			if (this.connected != value) {
				this.connected = value;
				this.emit("changed", value);
			}
		}
	}, {
		key: "_clearHandle",
		value: function _clearHandle() {
			if (this._ws) {
				this._ws.onclose = null;
				this._ws.close();
				this._ws = null;
				this._setConnected(false);
			}
			if (this._sheduledCreating) {
				clearTimeout(this._sheduledCreating);
				this._sheduledCreating = null;
			}
		}
	}, {
		key: "_ensureHandle",
		value: function _ensureHandle() {
			if (!this._ws) this._createHandle();
		}
	}, {
		key: "_createHandle",
		value: function _createHandle() {
			var _this = this;

			this._clearHandle();
			if (!this._url) return;
			this._ws = PingPongJSON(WebSocketToJSON(new WebSocket(this._url)));
			this._ws.onclose = function () {
				_this._ws = null;
				_this._setConnected(false);
				_this.emit("pause");
				if (!_this.closed) {
					var t = _this._lastClose;
					_this._lastClose = Date.now();
					_this._sheduledCreating = setTimeout(function () {
						_this._createHandle();
					}, Math.max(0, WebSocketRetry - (_this._lastClose - t)));
				}
			};
			this._ws.onerror = function (error) {
				_this.emit("error", error);
			};
			this._ws.onopen = function () {
				_this._setConnected(true);
				if (_this._first) {
					_this._first = false;
					_this.emit("open");
				}
				_this.emit("resume");
			};
			this._ws.onmessage = function (message) {
				_this.emit("message", message);
			};
		}
	}, {
		key: "reinit",
		value: function reinit() {
			this._ws && this._ws.close();
		}
	}, {
		key: "send",
		value: function send(data) {
			this._ensureHandle();
			if (!(this._ws && this.connected && !this.closed)) throw new Error("socket is not open");
			this._ws.send(data);
		}
	}, {
		key: "delete",
		value: function _delete() {
			this.close();
		}
	}, {
		key: "close",
		value: function close() {
			this.closed = true;
			this._clearHandle();
			this.emit("close");
		}
	}, {
		key: "ask",
		value: function ask(question) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var id, message;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							id = UID();

							this.send({ id: id, question: question });
							context$3$0.next = 4;
							return this.get(id);

						case 4:
							message = context$3$0.sent;

							if (!message.error) {
								context$3$0.next = 7;
								break;
							}

							throw new Error(message.error);

						case 7:
							return context$3$0.abrupt("return", message.answer);

						case 8:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		}
	}, {
		key: "get",
		value: function get(predicate, timeout) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var _ref, event, data;

				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (typeof predicate == "string" || typeof predicate == "number") {
								(function () {
									var id = predicate;
									predicate = function (msg) {
										return msg.id == id;
									};
								})();
							} else if (!(typeof predicate == "function")) {
								(function () {
									var p = predicate;
									predicate = function (msg) {
										return lodash.every(p, function (value, key) {
											return msg[key] == value;
										});
									};
								})();
							}
							context$3$0.next = 3;
							return co.receive(this, { close: true, message: predicate, timeout: timeout });

						case 3:
							_ref = context$3$0.sent;
							event = _ref.event;
							data = _ref.data;

							if (!(event == "message")) {
								context$3$0.next = 8;
								break;
							}

							return context$3$0.abrupt("return", data);

						case 8:
							throw new Error("timeout");

						case 9:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		}
	}]);

	return PersistentWebSocket;
})(EventEmitter);

function wsClient(app, url) {
	var ws = new PersistentWebSocket();
	ra(function () {
		return ws.url = app.localModem && app.localModem + url;
	});
	ws.active = ra.on(ws, ["pause", "resume"], function () {
		return ws.connected;
	});
	return ws;
}

function wsJSONclient(app, url) {

	var json = JSONlocal(url, { uid: null });
	var ws = wsClient(app, url);
	var init = function init() {
		return ws.send({ what: "init", id: json.uid });
	};
	var resolvers = {};

	var doError = function doError(message, data) {
		throw new Error("wsJSONclient: " + message + ": " + JSON.stringify(data));
	};

	lu.on(ws, {
		resume: init,
		message: function message(_message) {
			switch (_message.what) {
				case "error":
					doError("error from server", _message);
				case "saved":
					{
						var resolve = resolvers[_message.messageId];
						delete resolvers[_message.messageId];
						resolve && resolve();
						return;
					}
				case "data":
					{
						if (_message.partial && _message.previous != json.uid) init();else if (Object.prototype.hasOwnProperty.call(_message, "data")) json.assign(lu.applyDiff(json.valueOf(), _message.data, _message.partial));
						return;
					}
				default:
					doError("unknown message from server", _message);
			}
		},
		error: function error() {
			app.onCredentials();
		} });

	function doReject(messageId, reject) {
		delete resolvers[messageId];
		reject();
	}

	var save = function save(partial, data) {
		return new Promise(function (resolve, reject) {
			var messageId = UID();
			resolvers[messageId] = resolve;
			ws.send({ what: "save", data: partial ? data : Object.assign({ __partial__: false }, data || {}), messageId: messageId });
			setTimeout(doReject, savePlacesTimeout, messageId, reject);
		});
	};

	return {
		data: json.getReadOnly(),
		active: ws.active,
		send: function send(data) {
			return save(false, data);
		},
		update: function update(data) {
			return save(true, data);
		},
		"delete": function _delete() {
			ws.close();
		} };
}

module.exports = function (appid) {

	var localDefaults = {
		activeDeviceId: "",
		language: "ru",
		iconSize: 40, // millimeters
		labels: true,
		placesPages: {} };

	var local = JSONlocal(appid, localDefaults);

	var app = ra.clean(Object.defineProperties({

		getMessage: function getMessage(data) {
			var language = local.language || "ru";
			return [language, "ru", "en", "by"].filter(function (l) {
				return Object.prototype.hasOwnProperty.call(data, l);
			}).map(function (l) {
				return data[l];
			})[0];
		},

		pageWidth: 2,
		pageHeight: 3,
		pageStarting: false,
		dialog: "",
		editing: false,
		moving: 0,
		history: [],
		menuElement: null, // div

		loggedin: false,
		// credentials: 1,
		onCredentials: function onCredentials() {
			this.loggedin = false;
		},

		go: function go(to, path) {
			var _this2 = this;

			if (!to) return;
			var h = this.history;
			var a = local.activeDeviceId;
			var l = undefined;
			while (h.length && (l = h[h.length - 1], l == to || l == a || path && path.indexOf(l) >= 0)) h.pop();
			if (a != to) h.push(a);
			path && h.push.apply(h, _toConsumableArray(path.filter(function (id) {
				return id != _this2.main;
			}).reverse()));
			local.activeDeviceId = to;
			this.dialog = "";
		},

		back: function back() {
			while (this.history.length) {
				var device = this.history.pop();
				if (this.getDevice(device)) return local.activeDeviceId = device;
			}
			local.activeDeviceId = this.main;
		},

		windowSize: require("windowSize").getReadOnly(),

		placesShifts: {},

		login: function login(name, pwd) {},

		getDevice: function getDevice(deviceId) {
			return this.devices.content && this.devices.content[lu.valueOf(deviceId)];
		},

		linkingPlaceId: null,

		setDatabase: function setDatabase(devices) {
			this.serverDevices.send(devices);
		},

		reset: function reset() {
			local.reset();
			this.setDatabase({ uid: UID() });
			this.dialog = "";
			this.editing = false;
			this.history.length = 0;
		},

		setTemplate: function setTemplate(template) {
			console.log(template);
			var devices = {
				uid: UID(),
				content: {} };
			function copy(template, device) {
				Object.keys(template).forEach(function (key) {
					return key != "image" && // TODO: !!!!!!!!
					key != "content" && key != "type" && (device[key] = template[key]);
				});
				return device;
			}
			function walk(template, id) {
				if (template.content || template.type == "place") {
					(function () {
						var content = {};
						devices.content[id] = copy(template, { type: "place", content: content });
						var index = 0;
						template.content && template.content.forEach(function (p) {
							return content[walk(p, UID())] = { index: index++ };
						});
					})();
				} else {
					devices.content[id] = copy(template, { type: "single" });
				}
				return id;
			}
			devices.main = walk(template, UID());
			this.setDatabase(devices);
		},

		message: function message(id) {
			var ret = this.messages && this.messages[id];
			if (ret == null) ret = id;
			return ret;
		},

		notification: function notification(message) {},

		saveDevice: function saveDevice(deviceId, device) {
			var diff = lu.makeDiff(this.getDevice(deviceId), device);
			return diff == null ? Promise.resolve() : this.serverDevices.update({ content: _defineProperty({}, deviceId, diff) });
		},

		newIndex: function newIndex(iconId) {
			return Object.keys(this.getDevice(iconId).content || {}).length + 1;
		},

		linkItem: function linkItem(iconId, itemId, extra) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var place, device, rec, packet, result;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!(iconId == itemId)) {
								context$3$0.next = 2;
								break;
							}

							throw new Error("cannot link place to itself");

						case 2:
							place = this.getDevice(iconId);
							device = this.getDevice(itemId);

							if (!(place.type == "group")) {
								context$3$0.next = 9;
								break;
							}

							if (place.group) {
								context$3$0.next = 7;
								break;
							}

							throw new Error("internal error: no GROUP number found");

						case 7:
							if (device.group) {
								context$3$0.next = 9;
								break;
							}

							throw new Error("cannot add unlinked device to a group");

						case 9:
							rec = this.localDevices.createRecord();
							context$3$0.prev = 10;
							packet = { content: _defineProperty({}, iconId, { content: _defineProperty({}, itemId, { index: this.newIndex(iconId) }) }) };
							result = !extra ? packet : lu.mergeDiffs(extra, packet);

							debugger;
							rec.assign(result);

							if (!(place.type == "group")) {
								context$3$0.next = 18;
								break;
							}

							context$3$0.next = 18;
							return this.command(itemId, "AppendTo", place.group);

						case 18:
							context$3$0.next = 20;
							return rec.save();

						case 20:
							context$3$0.prev = 20;

							rec.close();
							return context$3$0.finish(20);

						case 23:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[10,, 20, 23]]);
			}), this);
		},

		linkToFavourites: function linkToFavourites(itemId) {
			return this.linkItem(this.main, itemId);
		},

		linkActiveToFavourites: function linkActiveToFavourites(itemId) {
			return this.linkToFavourites(this.activeDeviceId);
		},

		addItem: function addItem(iconId, item) {
			var _content5;

			var id = arguments[2] === undefined ? UID() : arguments[2];
			var index = arguments[3] === undefined ? null : arguments[3];

			return this.serverDevices.update({ content: (_content5 = {}, _defineProperty(_content5, iconId, { content: _defineProperty({}, id, { index: index != null ? index : this.newIndex(iconId) }) }), _defineProperty(_content5, id, item), _content5) });
		},

		addPlace: function addPlace(iconId) {
			return this.addItem(iconId, {
				type: "place",
				ru: "ÐŸÐ¾Ð¼ÐµÑ‰ÐµÐ½Ð¸Ðµ",
				en: "Room" });
		},

		addDevice: function addDevice(iconId) {
			return this.addItem(iconId, {
				type: "single",
				ru: "Ð£ÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾",
				en: "Device" });
		},

		addGroup: function addGroup(iconId, id) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!id) id = UID();
							context$3$0.next = 3;
							return this.addItem(iconId, {
								type: "group",
								ru: "Ð“Ñ€ÑƒÐ¿Ð¿Ð°",
								en: "Group" }, id);

						case 3:
							context$3$0.next = 5;
							return this.command(id, "Reserve");

						case 5:
							return context$3$0.abrupt("return", id);

						case 6:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		},

		deleteItem: function deleteItem(iconId, itemId) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var place, rec;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							place = this.getDevice(iconId);
							rec = this.localDevices.createRecord();
							context$3$0.prev = 2;

							rec.assign({ content: _defineProperty({}, iconId, { content: _defineProperty({}, itemId, null) }) });

							if (!(place.type == "group" && place.group)) {
								context$3$0.next = 7;
								break;
							}

							context$3$0.next = 7;
							return this.command(itemId, "RemoveFrom", place.group);

						case 7:
							context$3$0.next = 9;
							return rec.save();

						case 9:
							context$3$0.prev = 9;

							rec.close();
							return context$3$0.finish(9);

						case 12:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[2,, 9, 12]]);
			}), this);
		},

		insertInto: function insertInto(iconId, itemId, fromId) {
			return this.linkItem(iconId, itemId, { content: _defineProperty({}, fromId, { content: _defineProperty({}, itemId, null) }) });
		},

		errors: null,
		"throw": function _throw(dialog, data, retry) {
			if (!dialog) throw new Error("an error has to have its own dialog");
			this.errors = (this.errors || []).concat([{
				dialog: dialog,
				data: data,
				retry: retry }]);
		},
		clearError: function clearError() {
			var _this3 = this;

			ra.detach(function () {
				if (_this3.error) {
					_this3.dialog = "";
					_this3.errors = _this3.errors && _this3.errors.slice(1);
				}
			});
		},
		error: null,

		purgeItem: function purgeItem(deviceId, force) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var device, rec, cmd;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							device = this.getDevice(deviceId);
							rec = this.localDevices.createRecord();
							context$3$0.prev = 2;

							rec.assign(devdb.Clear(this.devices, deviceId));
							cmd = undefined;

							if (device && device.group != null) if (device.type == "group") cmd = "Clear";else if (device.type == "single") cmd = "Unlink";

							if (!cmd) {
								context$3$0.next = 11;
								break;
							}

							context$3$0.next = 9;
							return this.command(deviceId, cmd);

						case 9:
							context$3$0.next = 13;
							break;

						case 11:
							context$3$0.next = 13;
							return rec.save();

						case 13:
							context$3$0.prev = 13;

							if (!force) {
								context$3$0.next = 17;
								break;
							}

							context$3$0.next = 17;
							return rec.save();

						case 17:
							rec.close();
							// server MUST send us actual state BEFORE returning result of command execution
							if ((lu.valueOf(this.serverDevices.data) || 1)[deviceId]) this["throw"]("ErrorUnlinkingDevice", { deviceId: deviceId });
							return context$3$0.finish(13);

						case 20:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[2,, 13, 20]]);
			}), this);
		},

		renameItem: function renameItem(iconId, name) {
			var ret = lodash.reduce(this.getDevice(iconId), function (ret, _, key) {
				if (key.length == 2) ret[key] = null;
				return ret;
			}, {});
			ret[localDefaults.language || "ru"] = name;
			return this.serverDevices.update({ content: _defineProperty({}, iconId, ret) });
		},

		command: function command(deviceId, cmd, data) {

			// debugger

			// TODO:
			var newstate = deviceActions.getNewState(this.getDevice(deviceId), cmd);
			if (newstate != null) {}

			return this.commands.ask({ device: deviceId, command: cmd, data: data });
		},

		iconCommand: function iconCommand(icon, iconId, cmd, data) {
			// console.log( icon, iconId, cmd )
			icon = lu.valueOf(icon);
			if (icon.type == "place" ? cmd == "Short" : cmd == "Long") return this.go(iconId);
			if (icon.type != "place" && !icon.group) {
				this.dialog = "AskToLinkDevice";
				this.linkingPlaceId = iconId;
				// return Promise.reject( new Error( `device not configured` ) )
				return Promise.resolve();
			}
			if (cmd == "Short" || cmd == "Long") {
				if (icon && icon.state) {
					cmd = "Set";
					data = 0;
				} else {
					cmd = "Set";
					data = 1;
				}
				// cmd = `Comfort_1`
			}
			return this.command(iconId, cmd, data);
		},

		focus: function focus(node) {
			// magic actions to force allow to show keyboard by input.focus() on iOS ( so far checked iOS 8 )
			setTimeout(function () {
				return node.focus();
			}, 400);
		},

		searchAction: null,
		searchFilter: null,

		icons: null,

		modules: new WeakMap(),
		load: function load(module) {
			var ret = this.modules.get(module);
			if (ret == null) {
				ret = module(app, local);
				this.modules.set(module, ret);
			}
			return ret;
		},

		hover: null,

		"debugger": function _debugger() {
			debugger;
		} }, {
		modemLocations: {

			// TODO Ð°Ð±Ð½Ð°ÑžÐ»ÑÑ†ÑŒ!! Ñ–Ð½Ñ‚ÑÑ€Ñ„ÐµÐ¹ÑÑ‹ ÑÐº Ñ‚Ð¾Ð»ÑŒÐºÑ– ÑÐ½Ñ‹ Ñž Ð¼Ð°Ð´ÑÐ¼Ð° Ð°Ð±Ð½Ð°ÑžÐ»ÑÑŽÑ†Ñ†Ð°!!

			get: function () {
				return httpClient.get("/modem_locations");
			},
			configurable: true,
			enumerable: true
		},
		localModem: {
			get: function () {
				return this.modemLocations ? this.modemLocations[0].url.replace(/^http(?=s?\:\/\/)/, "ws") : "";
			},
			configurable: true,
			enumerable: true
		},
		doLogin: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					var script;
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						var _this4 = this;

						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!(!this.loggedin && this.modemLocations)) {
									context$3$0.next = 23;
									break;
								}

								script = document.createElement("script");

								script.src = "" + this.modemLocations[0].url + "/login?" + UID();
								document.body.appendChild(script);
								context$3$0.prev = 4;
								context$3$0.next = 7;
								return script
								// yield Promise.race( [ co.promise( script ), co.timeout( 15000 ) ] )
								;

							case 7:
								context$3$0.next = 16;
								break;

							case 9:
								context$3$0.prev = 9;
								context$3$0.t0 = context$3$0["catch"](4);

								LOG("error while trying to login: " + (context$3$0.t0 && context$3$0.t0.message && context$3$0.t0));
								console.error(context$3$0.t0);
								context$3$0.next = 15;
								return co.sleep(300);

							case 15:
								return context$3$0.abrupt("continue", 0);

							case 16:
								context$3$0.prev = 16;

								document.body.removeChild(script);
								return context$3$0.finish(16);

							case 19:
								LOG("logged in");
								ra.detach(function () {
									return _this4.loggedin = true;
								});
								context$3$0.next = 0;
								break;

							case 23:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this, [[4, 9, 16, 19]]);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		serverDevices: {
			get: function () {
				return wsJSONclient(this, "/database");
			},
			configurable: true,
			enumerable: true
		},
		localDevices: {
			get: function () {
				var _this5 = this;

				return ra.db(this.serverDevices.data, function (data) {
					return _this5.serverDevices.update(data);
				});
			},
			configurable: true,
			enumerable: true
		},
		devices: {
			get: function () {
				return this.localDevices.valueOf() || {};
			},
			configurable: true,
			enumerable: true
		},
		commands: {
			get: function () {
				return wsClient(this, "/commands");
			},
			configurable: true,
			enumerable: true
		},
		connectedToServer: {
			get: function () {
				return true && this.serverDevices.active.valueOf() && this.commands.active.valueOf();
			},
			configurable: true,
			enumerable: true
		},
		main: {
			get: function () {
				return this.devices.main;
			},
			configurable: true,
			enumerable: true
		},
		activeDeviceId: {
			get: function () {
				return local.activeDeviceId || this.main;
			},
			configurable: true,
			enumerable: true
		},
		activeDevice: {
			get: function () {
				return this.getDevice(this.activeDeviceId);
			},
			configurable: true,
			enumerable: true
		},
		activeContentIds: {
			get: function () {
				var device = this.activeDevice;
				return ra.Array(lodash.keys(device && device.content).sort(function (a, b) {
					return device.content[a].index - device.content[b].index;
				}));
			},
			configurable: true,
			enumerable: true
		},
		activeContent: {
			get: function () {
				return ra.Array(this.activeContentIds.map(this.getDevice));
			},
			configurable: true,
			enumerable: true
		},
		clearLinkingPlaceId: {
			get: function () {
				if (this.dialog != "AskToLinkDevice" && this.dialog != "AskIfDeviceHasBeenLinked") this.linkingPlaceId = null;
			},
			configurable: true,
			enumerable: true
		},
		checkIfTimeToGoBack: {
			get: function () {
				// lu.valueOf( this.places )
				if (!this.getDevice(this.activeDeviceId)) this.back();
			},
			configurable: true,
			enumerable: true
		},
		caption: {
			get: function () {
				return this.getMessage(this.getDevice(this.activeDeviceId)) || this.message("favorites");
			},
			configurable: true,
			enumerable: true
		},
		deviceType: {
			get: function () {
				var ret = this.getDevice(this.activeDeviceId);
				if (!ret) ret = this.getDevice(this.main);
				return ret && ret.type || "place";
			},
			configurable: true,
			enumerable: true
		},
		deviceIds: {
			get: function () {
				return ra.Array(lodash.keys(this.devices.content).sort());
			},
			configurable: true,
			enumerable: true
		},
		initialLoading: {
			get: function () {
				return !this.devices.uid;
			},
			configurable: true,
			enumerable: true
		},
		initialized: {
			get: function () {
				return !this.initialLoading && !!this.devices.main;
			},
			configurable: true,
			enumerable: true
		},
		templates: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								context$3$0.prev = 0;
								context$3$0.next = 3;
								return httpClient.get("/templates");

							case 3:
								return context$3$0.abrupt("return", context$3$0.sent);

							case 6:
								context$3$0.prev = 6;
								context$3$0.t0 = context$3$0["catch"](0);
								return context$3$0.abrupt("return", context$3$0.t0);

							case 9:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this, [[0, 6]]);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		allMessages: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								context$3$0.next = 2;
								return httpClient.get("/messages");

							case 2:
								return context$3$0.abrupt("return", context$3$0.sent);

							case 3:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		messages: {
			get: function () {
				var allMessages = this.allMessages;
				if (allMessages == null) return;
				var ret = {};
				var language = local.language || "ru";
				lodash.forOwn(allMessages, function (value, key) {
					return ret[key] = Object.prototype.hasOwnProperty.call(value, language) ? value[language] : key;
				});
				return ret;
			},
			configurable: true,
			enumerable: true
		},
		checkError: {
			get: function () {
				var _this6 = this;

				if (!this.dialog) if (this.errors && this.errors.length) ra.detach(function () {
					var error = _this6.errors[0];
					_this6.errors = _this6.errors && _this6.errors.slice(1);
					_this6.dialog = error.dialog;
					_this6.error = error;
				});else this.error = null;
			},
			configurable: true,
			enumerable: true
		},
		checkSearchDialog: {
			get: function () {
				if (this.dialog != "SearchItems") {
					this.searchAction = null;
					this.searchFilter = null;
				}
			},
			configurable: true,
			enumerable: true
		}
	})).setName("app");

	return { app: app, local: local };
};
// TODO: this code with an XMLHttpRequest does not work on iPhone :(((
// let xhr = new XMLHttpRequest
// xhr.open( `POST`, this.modemLocations[ 0 ].url + `/login`, true, `nero`, `123` )
// xhr.withCredentials = true
// try {
// 	xhr.send()
// 	yield xhr
// 	// alert( xhr.status )
// 	LOG( ( `` + xhr.status ).blue )
// 	if ( xhr.status >= 200 && xhr.status <= 299 )
// 		return ra.detach( () => this.loggedin = true )
// }
// catch ( error ) {
// 	// alert( `ERR` )
// 	console.log( `error while trying to login`, error )
// }
// yield co.sleep( 300 )

// alert( message )

// debugger

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/app.js","/src")

},{"JSONlocal":116,"PingPongJSON":118,"WebSocketToJSON":120,"_process":96,"buffer":91,"devdb":125,"events":95,"http-status":113,"httpClient":129,"localUtils":132,"lodash":114,"netro/deviceActions":133,"ra":136,"uid":155,"windowSize":157}],122:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var MAX_TICKS = 1000;

var setTimeout = window.setTimeout;
var setInterval = window.setInterval;

process.nextTick = nextTick;

var queue = [];
var timer = null;
var processing = false;
var secret = "process-tick-" + Math.random();

var installTimer = function installTimer() {
	timer = setTimeout(onTimer, 1);
};

if (window.postMessage && window.addEventListener) {
	(function () {
		window.addEventListener("message", function (ev) {
			var source = ev.source;
			if ((source == window || source == null) && ev.data == secret) {
				ev.stopPropagation();
				onTimer();
			}
		});
		var postMessage = window.postMessage;
		installTimer = function () {
			postMessage(secret, "*");
			timer = true;
		};
	})();
}

!["setTimeout", "setInterval", "requestAnimationFrame"].forEach(function (name) {
	var proc = hookMethod(window, name, function (handler, time) {
		if (typeof arguments[0] == "function") arguments[0] = getProxy(arguments[0]);
		return proc.apply(this, arguments);
	});
});

![window, document].forEach(hookEventListener);

function onTimer() {
	timer = null;
	processQueue();
}

function ensureTimer() {
	if (!timer && !processing) installTimer();
}

function nextTick(fun) {
	queue.push(fun);
	ensureTimer();
}

function processQueue() {
	if (processing || !queue.length) return;
	var index = 0;
	processing = true;
	try {
		while (index < MAX_TICKS && index < queue.length) queue[index++]();
	} finally {
		// console.log( "ticks: " + index )
		processing = false;
		queue.splice(0, index);
		if (queue.length) ensureTimer();
	}
}

function getProxy(handler) {
	function proxy() {
		var ret = handler.handleEvent ? handler.handleEvent.apply(handler, arguments) : handler.apply(this, arguments);
		processQueue();
		return ret;
	}
	var ret = undefined;
	if ((ret = handler[secret]) != null) return ret;else {
		assignProperty(proxy, secret, proxy);
		return assignProperty(handler, secret, proxy);
	}
}

function hookEventListener(obj) {
	if (obj.addEventListener) {
		(function () {
			var addEventListener = hookMethod(obj, "addEventListener", function (event, handler) {
				arguments[1] = getProxy(arguments[1]);
				return addEventListener.apply(this, arguments);
			});
			var removeEventListener = hookMethod(obj, "removeEventListener", function (event, handler) {
				if (arguments[1][secret]) arguments[1] = arguments[1][secret];
				return removeEventListener.apply(this, arguments);
			});
		})();
	}
}

function hookMethod(obj, name, proxy) {
	var ret = obj[name];
	if (ret) {
		assignProperty(proxy, "toString", function () {
			return ret.toString();
		});
		obj[name] = proxy;
	}
	return ret;
}

function assignProperty(obj, name, value) {
	if (Object.defineProperty) Object.defineProperty(obj, name, { value: value });else obj[name] = value;
	return value;
}

/*
Does not work. window[ secret ] is executed before, not after, current script will finish.
*/

//
// window[ secret ] = () => {
// 	delete window[ secret ]
// 	let script = document.getElementById( secret )
// 	script.parentNode.removeChild( script )
// 	console.log( 98765, queue.length )
// 	processQueue()
// 	console.log( 98765, queue.length )
// }

// let code = `window[ "${ secret }" ]()`

// if ( document.body ) {
// 	let script = document.createElement( "script" )
// 	script.id = secret
// 	script.innerHTML = code
// 	document.body.appendChild( script )
// }
// else
// 	document.write( `<script id = "${ secret }1" >${ code }</script>` )

// console.log( 54321, queue.length )

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/browser-nexttick.js","/src")

},{"_process":96,"buffer":91}],123:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var marked0$0 = [_IteratorProxy].map(regeneratorRuntime.mark);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var later = require("later");
var EventEmitter = require("events").EventEmitter;

var co = module.exports = exports = new EventEmitter();

var threadCatcher = null;

exports.cb = null;
exports.global = null;

var id = function id(value) {
	return value;
};

exports.go = function (fun) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	if (typeof fun == "function") fun = fun.apply(null, args);
	if (!fun.next) {
		(function () {
			var value = fun;
			fun = {
				next: function next() {
					var ret = { value: value, done: !value };
					value = null;
					return ret;
				} };
		})();
	}
	return new Thread(fun);
};

exports.gocall = function (fun, context) {
	for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
		args[_key2 - 2] = arguments[_key2];
	}

	return new Thread(fun.apply(context, args));
};

exports.func = function (fun) {
	if (arguments.length >= 2) fun = Array.prototype.reduceRight.call(arguments, function (g, f) {
		return f(g);
	});
	return function proc() {
		return new Thread(fun.apply(this, arguments));
	};
};

exports.eventHandler = function (fun) {
	return function proc() {
		var ret = new Thread(fun.apply(this, arguments));
		ret.waitForInput();
		return ret;
	};
};

// the first argument is an error, the second one is a result
exports.cbfunc = function (funWithCB) {
	return function () {
		var _this = this;

		for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
			args[_key3] = arguments[_key3];
		}

		return new Promise(function (resolve, reject) {
			return funWithCB.call.apply(funWithCB, [_this].concat(args, [function (error, value) {
				if (error != null) reject(error);else resolve(value);
			}]));
		});
	};
};

exports.catchThreads = function (cb, onThread) {
	var oldCatcher = threadCatcher;
	threadCatcher = onThread;
	try {
		return cb();
	} finally {
		threadCatcher = oldCatcher;
	}
};

exports.receive = function (emitter, events) {
	return new Promise(function (resolve, reject) {
		var handlers = Object.create(null);
		var timer = undefined;
		var rejecter = co.defer(function () {
			clear();
			reject();
		});

		var _loop = function (_event) {
			if (Object.prototype.hasOwnProperty.call(events, _event)) {
				var _ret3 = (function () {
					var predicate = events[_event];
					if (predicate == null)
						//
						// allow simpler events defining like
						//
						// yield co.receive( obj, { data: true, timeout: getTimeout( ... ) } )
						//
						// instead of
						//
						// let events = { data: true }
						// if ( getTimeout( ... ) != null ) events.timeout = getTimeout( ... )
						// yield co.receive( obj, events )
						//
						return {
							v: "continue"
						};
					if (_event == "timeout") timer = setTimeout(function () {
						return done("timeout", null);
					}, predicate);else emitter.addListener(_event, handlers[_event] = function (data) {
						if (typeof predicate != "function" || predicate(data)) done(_event, data);
					});
				})();

				if (typeof _ret3 === "object") return _ret3.v;
			}
		};

		for (var _event in events) {
			var _ret2 = _loop(_event);

			if (_ret2 === "continue") continue;
		}function clear() {
			if (!handlers) return;
			clearTimeout(timer);
			for (var _event2 in handlers) {
				emitter.removeListener(_event2, handlers[_event2]);
			}rejecter.close();
			handlers = null;
		}
		function done(event, data) {
			clear();
			resolve({ event: event, data: data });
		}
	});
};

var noopthen = { then: function then() {} };
exports.wait = function () {
	return noopthen;
};

exports.sleep = function (milliseconds) {
	return { then: function then(resolve) {
			var timer = setTimeout(resolve, milliseconds);
			return { kill: function kill() {
					clearTimout(timer);
				} };
		} };
};

exports.tick = exports.sleep(1);

exports.timeout = function (milliseconds) {
	return { then: function then(_, reject) {
			var timer = setTimeout(reject, milliseconds);
			return { kill: function kill() {
					clearTimout(timer);
				} };
		} };
};

exports.promise = function (value) {
	return Promise.all([co.go(regeneratorRuntime.mark(function callee$1$0() {
		return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
			while (1) switch (context$2$0.prev = context$2$0.next) {
				case 0:
					context$2$0.next = 2;
					return value;

				case 2:
				case "end":
					return context$2$0.stop();
			}
		}, callee$1$0, this);
	}))]);
};

exports.requestAnimationFrame = { then: function then(resolve) {
		if (typeof cancelAnimationFrame == "function") {
			var frame = requestAnimationFrame(resolve);
			return { kill: function kill() {
					cancelAnimationFrame(timer);
				} };
		} else return exports.sleep(1).then(resolve);
	} };

var rethrow = function rethrow(e) {
	return setTimeout(function () {
		throw e;
	}, 1);
};

function iteratorFailed(error) {
	return { done: true, iteratorFailed: true, value: error };
}

function iteratorNext(iterator, result) {
	try {
		return iterator.next(result);
	} catch (error) {
		return iteratorFailed(error);
	}
}

function iteratorThrow(iterator, result) {
	if (!iterator["throw"]) return iteratorFailed(result);
	try {
		return iterator["throw"](result);
	} catch (error) {
		return iteratorFailed(error);
	}
}

var DONE = { done: true };

var EKill = (function (_Error) {
	function EKill() {
		var message = arguments[0] === undefined ? "kill" : arguments[0];

		_classCallCheck(this, EKill);

		_get(Object.getPrototypeOf(EKill.prototype), "constructor", this).call(this, message);
	}

	_inherits(EKill, _Error);

	return EKill;
})(Error);

exports.EKill = EKill;

function iteratorReturn(iterator) {
	if (iterator["return"]) {
		try {
			iterator["return"]();
		} catch (error) {
			return iteratorFailed(error);
		}
	} else if (iterator["throw"]) {
		var e = new EKill();
		var v = iteratorThrow(iterator, e);
		if (!v.done || !v.iteratorFailed) rethrow(new Error("thread has eaten EKill"));else if (v.value != e) return v;
	}
	return DONE;
}

function iteratorCheck(ret) {
	if (ret && ret.done && ret.iteratorFailed) throw ret.value;else return ret;
}

function killIterator(iterator) {
	if (iterator) {
		var res = iteratorReturn(iterator);
		if (res.done && res.iteratorFailed) rethrow(res.value);
	}
}

// Thread

var _private = { writable: true };
var notEnumerable = { enumerable: false };

var catchDefer = function catchDefer(func) {
	// optimization -- using try/catch in a separate function.
	try {
		return func();
	} catch (error) {
		return { next: function next() {
				return iteratorFailed(error);
			} };
	}
};

var IteratorProxy = (function () {
	function IteratorProxy(iterator) {
		_classCallCheck(this, IteratorProxy);

		if (iterator instanceof IteratorProxy) return iterator;
		this._iterator = iterator;
		this._deferred = null;
		this._result = null;
	}

	_createClass(IteratorProxy, [{
		key: "defer",
		value: function defer(proc) {
			var _this2 = this;

			if (typeof proc != "function") throw new Error("type error: only functions can be deferred");
			if (!this._deferred) this._deferred = [];
			this._deferred.push(proc);
			return { close: function close() {
					if (_this2._deferred) for (var i = _this2._deferred.length - 1; i >= 0; --i) {
						if (_this2._deferred[i] == proc) {
							_this2._deferred.splice(i, 1);
							return;
						}
					}
				} };
		}
	}, {
		key: "save",
		value: function save(result) {
			if (!this._result) this._result = result;else if (result.iteratorFailed) {
				if (this._result.iteratorFailed) rethrow(this._result.value);
				this._result = result;
			}
		}
	}, {
		key: "call",
		value: function call(proc, value) {
			var old = IteratorProxy._iterator;
			IteratorProxy._iterator = this;
			try {
				start: for (;;) {
					var ret = proc(this._iterator, value);
					if (!ret.done) return ret;
					this._iterator = null;
					if (!this._deferred) return ret;
					this.save(ret);
					while (this._deferred.length) {
						var def = catchDefer(this._deferred.pop());
						if (def == null || typeof def.next != "function") continue;
						this._iterator = def;
						value = undefined;
						proc = iteratorNext;
						continue start;
					}
					ret = this._result;
					this._result = null;
					return ret;
				}
			} finally {
				IteratorProxy._iterator = old;
			}
		}
	}, {
		key: "next",
		value: function next(value) {
			return iteratorCheck(this.call(iteratorNext, value));
		}
	}, {
		key: "throw",
		value: function _throw(value) {
			return iteratorCheck(this.call(iteratorThrow, value));
		}
	}, {
		key: "return",
		value: function _return(value) {
			if (!this._iterator) return;
			this.save({ done: true, value: value });
			var old = IteratorProxy._iterator;
			IteratorProxy._iterator = this;
			try {
				var ret = iteratorReturn(this._iterator);
				this._iterator = null;
				if (!this.deferred) {
					iteratorCheck(ret);
					return;
				}
				this.save(ret);
				while (this._deferred.length) {
					var def = catchDefer(this._deferred.pop());
					if (def != null && typeof def.next == "function") {
						var _ret4 = iteratorNext(def);
						if (!_ret4.done) _ret4 = iteratorReturn(def);
						this.save(_ret4);
					}
				}
				ret = this._result;
				this._result = null;
				iteratorCheck(ret);
			} finally {
				IteratorProxy._iterator = old;
			}
		}
	}]);

	return IteratorProxy;
})();

IteratorProxy._iterator = null;

function _IteratorProxy(iterator) {
	var deffered, ret, save, step, it, yieldResult;
	return regeneratorRuntime.wrap(function _IteratorProxy$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				save = function save(it) {
					if (ret == null || it.iteratorFailed) {
						if (ret && ret.iteratorFailed) rethrow(ret.value);
						ret = it;
					}
				};

				deffered = [];
				ret = null;
				step = iteratorNext;
				it = null;
				context$1$0.prev = 5;

			case 6:
				if (!true) {
					context$1$0.next = 40;
					break;
				}

				yieldResult = undefined;

				step = iteratorNext;

				if (!(it != null)) {
					context$1$0.next = 22;
					break;
				}

				context$1$0.prev = 10;
				context$1$0.next = 13;
				return it.value;

			case 13:
				yieldResult = context$1$0.sent;
				context$1$0.next = 20;
				break;

			case 16:
				context$1$0.prev = 16;
				context$1$0.t0 = context$1$0["catch"](10);

				yieldResult = context$1$0.t0;
				step = iteratorThrow;

			case 20:
				context$1$0.next = 23;
				break;

			case 22:
				yieldResult = undefined;

			case 23:
				_IteratorProxy.deferred = deferred;
				it = step(iterator, yieldResult);
				_IteratorProxy.deferred = null;

				if (it.done) {
					context$1$0.next = 28;
					break;
				}

				return context$1$0.abrupt("continue", 6);

			case 28:
				save(it);
				it = undefined;

			case 30:
				if (!deffered.length) {
					context$1$0.next = 36;
					break;
				}

				iterator = catchDefer(deffered.shift());

				if (!(iterator != null && typeof iterator.next == "function")) {
					context$1$0.next = 34;
					break;
				}

				return context$1$0.abrupt("continue", 6);

			case 34:
				context$1$0.next = 30;
				break;

			case 36:
				iterator = null;
				return context$1$0.abrupt("break", 40);

			case 40:
				context$1$0.prev = 40;

				if (iterator) save(iteratorReturn(iterator));
				while (deffered.length) {
					iterator = catchDefer(deffered.shift());
					if (iterator != null && typeof iterator.next == "function") {
						it = iteratorNext(iterator, undefined);
						if (!it.done) it = iteratorReturn(iterator);
						save(it);
					}
				}

				if (!ret) {
					context$1$0.next = 49;
					break;
				}

				if (!ret.iteratorFailed) {
					context$1$0.next = 48;
					break;
				}

				throw ret.value;

			case 48:
				return context$1$0.abrupt("return", ret.value);

			case 49:
				return context$1$0.finish(40);

			case 50:
			case "end":
				return context$1$0.stop();
		}
	}, marked0$0[0], this, [[5,, 40, 50], [10, 16]]);
}

exports.defer = function (proc) {
	if (!IteratorProxy._iterator) throw new Error("defer: not in a co-thread");
	return IteratorProxy._iterator.defer(proc);
};

exports._defer = function (proc) {
	if (typeof proc != "function") throw new Error("type error: only functions can be deferred");
	var deferred = _IteratorProxy.deferred;
	if (deferred) throw new Error("defer: not in a co-thread");
	deferred.push(proc);
	return { close: function close() {
			if (deferred) for (var i = deferred.length - 1; i >= 0; --i) {
				if (deferred[i] == proc) {
					deferred.splice(i, 1);
					return;
				}
			}
		} };
};

var Thread = (function () {
	function Thread(iterator) {
		var _this3 = this;

		_classCallCheck(this, Thread);

		this._attachedToStack = true;
		this._iterator = new IteratorProxy(iterator);
		this._stopCount = 0;
		this._stack = [];
		this.global = Object.create(null);
		this._currentPromise = null;
		this._running = false;
		this._killing = null;
		this._cb = function (error, data) {
			if (_this3._step) if (error) _this3._step.fail(error);else _this3._step.next(data);
		};
		this.$name = { toString: function toString() {
				return "<Thread>";
			} };

		this._newStep();
		this._start = function () {
			if (_this3._start && _this3._step && _this3._step.next) {
				if (_this3._stopCount > 0) _this3._step.resume = _this3._start;else {
					_this3._start = null;
					_this3._step.next();
				}
			}
		};

		this._promise = new Promise(function (resolve, reject) {
			_this3._resolve = resolve;
			_this3._reject = reject;
		});
		if (!this._resolve) throw new Error("assertion failure: wrong implementation of Promise");

		later.then(this._start);
		if (threadCatcher) threadCatcher(this);

		exports.emit("start", this);
	}

	_createClass(Thread, [{
		key: "linkName",
		value: function linkName(value) {
			var suffix = arguments[1] === undefined ? ":thread" : arguments[1];

			if (value.$name) value = value.$name;
			this.$name.toString = function () {
				return "" + value + suffix;
			};
			return this;
		}
	}, {
		key: "waitForInput",
		value: function waitForInput() {
			this._checkFinished();
			if (this._stopCount > 0) throw new Error("thread is paused");
			if (this._start) this._start();
			return this;
		}
	}, {
		key: "_attachPromise",
		value: function _attachPromise(promise) {
			promise.kill = this.kill.bind(this);
			return promise;
		}
	}, {
		key: "then",
		value: function then(onFulfilled, onRejected) {
			this._attachedToStack = false;
			return this._attachPromise(this._promise.then(onFulfilled, onRejected));
		}
	}, {
		key: "catch",
		value: function _catch(onRejected) {
			this._attachedToStack = false;
			return this._attachPromise(this._promise["catch"](onRejected));
		}
	}, {
		key: "isFinished",
		value: function isFinished() {
			return !this._step || this._killing;
		}
	}, {
		key: "isPaused",
		value: function isPaused() {
			return this._stopCount > 0;
		}
	}, {
		key: "throw",
		value: function _throw(exception) {
			if (this.global == exports.global) throw exception;
			this._checkFinished();
			this._newStep();
			if (this._stopCount > 0) this._step.resume = this._step.fail.bind(this._step, exception);else this._step.fail(exception);
		}
	}, {
		key: "attachToStack",
		value: function attachToStack() {
			this._attachedToStack = true;
		}
	}, {
		key: "kill",
		value: function kill(reason) {
			if (this.isFinished()) return;
			this._reject(reason);
			if (this._running) {
				this._killing = { reason: reason };
				throw new EKill();
			}
			var previousThread = exports.current;
			var previosCB = exports.cb;
			var previosGlobal = exports.global;
			exports.cb = this._cb;
			exports.global = this.global;
			exports.current = this;
			killIterator(this._iterator);
			for (var a = this._stack, i = a.length - 1; i >= 0; --i) {
				killIterator(a[i]);
			}exports.cb = previosCB;
			exports.global = previosGlobal;
			exports.current = previousThread;
			if (this._currentPromise) {
				try {
					this._currentPromise.kill(reason);
				} catch (e) {
					rethrow(e);
				}
			}
			this._done();
		}
	}, {
		key: "pause",
		value: function pause() {
			this._checkFinished();
			++this._stopCount;
		}
	}, {
		key: "resume",
		value: function resume() {
			if (this._stopCount == 0) throw new Error("thread not paused");
			if (0 == --this._stopCount && this._step && this._step.resume) {
				later.then(this._step.resume);
				this._step.resume = null;
			}
		}
	}, {
		key: "_tick",
		value: function _tick(step, imethod, result) {
			if (this["debugger"] || step["debugger"]) debugger;
			if (this._running) throw new Error("FATAL: reentering thread tick");
			if (step !== this._step) return;
			if (this._stopCount > 0) {
				step.resume = this._tick.bind(this, step, imethod, result);
				return;
			}
			for (;;) {
				this._currentPromise = null;
				this._running = true;
				var previousThread = exports.current;
				var previosCB = exports.cb;
				var previosGlobal = exports.global;
				exports.cb = this._cb;
				exports.global = this.global;
				exports.current = this;
				var v = this._iterator.call(imethod, result);
				exports.cb = previosCB;
				exports.global = previosGlobal;
				exports.current = previousThread;
				this._running = false;
				if (this["debugger"] || step["debugger"]) debugger;
				if (this._killing) {
					var reason = this._killing.reason;
					this._killing = null;
					this.kill(reason);
					return;
				}
				if (v.done) {
					if (this.isFinished()) return;
					if (this._iterator = this._stack.pop()) {
						imethod = v.iteratorFailed ? iteratorThrow : iteratorNext;
						result = v.value;
						continue;
					}
					var r = v.iteratorFailed ? this._reject : this._resolve;
					this._done();
					if (v.iteratorFailed && this._attachedToStack) rethrow(v.value);
					r(v.value);
				} else if (!v.value) // any falsy value
					exports.tick.then(step.next);else if (v.value.then) {
					var p = v.value.then(step.next, step.fail);
					if (p && p.kill) this._currentPromise = p;
				} else if (v.value.next) {
					this._stack.push(this._iterator);
					this._iterator = new IteratorProxy(v.value);
					imethod = iteratorNext;
					result = undefined;
					continue;
				} else if ("onload" in v.value && !v.value.onload && "onerror" in v.value && !v.value.onerror) {
					v.value.onload = step.next;
					v.value.onerror = step.fail;
				} else if ("onsuccess" in v.value && !v.value.onload && "onerror" in v.value && !v.value.onerror) {
					if (!step.success_error) step.success_error = {
						onsuccess: function onsuccess(event) {
							step.next(event.target.result);
						},
						onerror: function onerror(event) {
							step.fail(event.target.error || event);
						} };
					v.value.onsuccess = step.success_error.onsuccess;
					v.value.onerror = step.success_error.onerror;
				} else throw new Error("thread type error");
				break;
			}
		}
	}, {
		key: "_done",
		value: function _done() {
			this._step = null;
			this._iterator = null;
			this._stack = null;
			this._resolve = null;
			this._reject = null;
			this._currentPromise = null;
			this._killing = null;
		}
	}, {
		key: "_newStep",
		value: function _newStep() {
			var step = this._step = { resume: null };
			step.next = this._tick.bind(this, step, iteratorNext);
			step.fail = this._tick.bind(this, step, iteratorThrow);
			var $name = this.$name;
			step.next.$name = { toString: function toString() {
					return $name + ":next";
				} };
			step.fail.$name = { toString: function toString() {
					return $name + ":fail";
				} };
		}
	}, {
		key: "_onPromise",
		value: function _onPromise(resolve, reject) {
			this._resolve = resolve;
			this._reject = reject;
			this.resume();
		}
	}, {
		key: "_checkFinished",
		value: function _checkFinished() {
			if (this.isFinished()) throw new Error("thread is already finished");
		}
	}]);

	return Thread;
})();

exports.Thread = Thread;

Object.keys(Thread.prototype).forEach(function (k) {
	return k.match(/^_/) && Object.defineProperty(Thread.prototype, k, notEnumerable);
});

var mainThread = new Thread({ next: function next() {
		return { value: { then: function then() {} } };
	} }).waitForInput();
exports.current = null;
exports.global = mainThread.global;
exports.cb = null;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/co.js","/src")

},{"_process":96,"buffer":91,"events":95,"later":131}],124:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var co = require("co");
var ra = require("ra");
var lodash = require("lodash");

function toNode(child, node) {
	restart: for (;;) {
		child = child && typeof child.valueOf == "function" ? child.valueOf() : child;
		if (Array.isArray(child)) {
			if (child.length == 0) return null;
			if (child.length == 1) {
				child = child[0];
				continue restart;
			}
			if (!node) node = document.createDocumentFragment();
			child.forEach(function (child) {
				return toNode(child, node);
			});
			child = node;
		} else {
			if (typeof child == "string") child = document.createTextNode(child);
			if (node) {
				node.appendChild(child);
				child = node;
			}
		}
		return child;
	}
}

function fcalc(f, cb) {
	if (typeof f != "function") cb(f);else {
		(function () {
			var first = true;
			ra(false, regeneratorRuntime.mark(function callee$2$0() {
				var ret;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!first) {
								context$3$0.next = 4;
								break;
							}

							first = false;
							context$3$0.next = 6;
							break;

						case 4:
							context$3$0.next = 6;
							return co.requestAnimationFrame;

						case 6:
							ret = f();

							if (!(ret && ret.next && ret["throw"])) {
								context$3$0.next = 11;
								break;
							}

							context$3$0.next = 10;
							return ret;

						case 10:
							ret = context$3$0.sent;

						case 11:
							cb(ret);

						case 12:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}));
		})();
	}
}

function checkDOMControl(control) {
	var q = [control.ownerDocument && control.ownerDocument.documentElement, document.documentElement, control.ownerDocument && control.ownerDocument.body, document.body].filter(Boolean);
	var p = control;
	while (p) {
		if (q.indexOf(p) >= 0) {
			ra.forceCalculations();
			return;
		}
		p = p.parentNode;
	}
}

function setContent(control, content) {
	var cb = arguments[2] === undefined ? null : arguments[2];
	fcalc(content, function (content) {
		checkDOMControl(control);
		var c = toNode(content);
		if (c) {
			checkDOMControl(control);
			control.innerHTML = "";
			control.appendChild(c);
		} else control.innerHTML = "";
		cb && cb();
	});
}

function toAttrString(value) {
	if (Array.isArray(value)) return value.map(toAttrString).join(" ");else if (value) return "" + value;else return "";
}

function appendContent(content, f) {
	if (!f) f = document.createDocumentFragment();
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = content[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var c = _step.value;

			if (typeof c == "function") {
				var p = document.createElement("span");
				setContent(p, c);
				f.appendChild(p);
			} else if (c instanceof Node) f.appendChild(c);else if (c != null && typeof c != "string" && c[Symbol.iterator]) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = c[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var cc = _step2.value;

						appendContent(cc, f);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			} else f.appendChild(document.createTextNode(c));
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator["return"]) {
				_iterator["return"]();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return f;
}

var Events = {};

var GeneratorFunctionPrototype = Object.getPrototypeOf(regeneratorRuntime.mark(function callee$0$0() {
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
}));

module.exports = {
	createElement: function createElement(name, attributes) {
		for (var _len = arguments.length, content = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			content[_key - 2] = arguments[_key];
		}

		if (typeof name == "function") return name(attributes && attributes._ ? Object.assign({}, attributes, attributes._, { _: null }) : attributes || 0, appendContent(content));
		var onCreate = undefined;
		var ret = document.createElement(name);
		var classes = [];
		function applyAttributes(attributes) {
			if (attributes == null) return;
			lodash.forEach(attributes, function (value, name) {
				if (name == "_") null;else if (name == "class") classes.push(value);else if (name == "style")
					// TODO: smth like to "class" attribute - parse parent style and update it
					fcalc(value, function (value) {
						if (typeof value == "string") ret.setAttribute("style", value);else lodash.forEach(value, function (value, name) {
							return fcalc(value, function (value) {
								return ret.style[name] = value;
							});
						});
					});else if (name == "oncreate") onCreate = value;else if (name.match(/^on/)) {
					if (value != null) {
						if (typeof value == "function") value = [value];
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;

						try {
							for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var handler = _step3.value;

								if (Object.getPrototypeOf(handler) == GeneratorFunctionPrototype) handler = co.eventHandler(handler);
								ret.addEventListener(name.slice("on".length), handler);
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
									_iterator3["return"]();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
					}
				} else fcalc(value, function (value) {
					value = toAttrString(value);
					if (ret.getAttribute(name) != value) ret.setAttribute(name, value);
				});
			});
			if (Object.prototype.hasOwnProperty.call(attributes, "_")) applyAttributes(attributes._);
		}
		applyAttributes(attributes);
		if (classes.length) {
			(function () {
				var copy = classes.map(function () {
					return null;
				});
				classes.forEach(function (c, i) {
					return fcalc(c, function (c) {
						copy[i] = c;
						var className = toAttrString(copy).replace(/(^|\s|\r|\n)(null|undefined|false|0|\-0|NaN)(?=$|\s|\r|\n)/g, "");
						if (ret.className != className) ret.className = className;
					});
				});
			})();
		}
		switch (content.length) {
			case 0:
				break;
			case 1:
				setContent(ret, content[0]);
				break;
			default:
				ret.appendChild(appendContent(content));
				break;
		}
		if (typeof onCreate == "function") {
			onCreate.call(ret, {
				type: "create",
				target: ret,
				srcElement: ret,
				currentTarget: ret });
		}
		return ret;
	} };

var updateInputValue = function updateInputValue() {
	var _this = this;

	setTimeout(function () {
		return _this._raValue.assign(_this.value);
	});
};
var raValue = {
	get: function get() {
		var _this2 = this;

		if (!this._raValue) ra.detach(function () {
			_this2._raValue = ra();
			_this2._raValue.assign(_this2.value);
			_this2.addEventListener("change", updateInputValue);
			_this2.addEventListener("keypress", updateInputValue);
			_this2.addEventListener("keydown", updateInputValue);
			_this2.addEventListener("keyup", updateInputValue);
		});
		return this._raValue.valueOf();
	},
	set: function set(value) {
		if (this.value != value) {
			this.value = value;
			if (this._raValue) this._raValue.assign(this.value);
		}
	} };

var _arr = [HTMLInputElement, HTMLTextAreaElement];
for (var _i = 0; _i < _arr.length; _i++) {
	var C = _arr[_i];
	Object.defineProperty(C.prototype, "raValue", raValue);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/components.js","/src")

},{"_process":96,"buffer":91,"co":123,"lodash":114,"ra":136}],125:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var UID = require("uid");
var lu = require("localUtils");

exports.Clear = exports.Unlink = function (devices, deviceId) {
	return lodash.reduce(devices.content, function (ret, q, index) {
		if (q) if (index == deviceId) ret.content[index] = null;else if (q.content && q.content[deviceId]) ret.content[index] = { content: _defineProperty({}, deviceId, null) };
		return ret;
	}, { content: {} });
};

exports.Set = function (devices, deviceId, data) {
	var device = devices.content[deviceId];
	if (!device || !device.group) return;
	var ret = { content: _defineProperty({}, deviceId, data) };
	if (device.type == "group") ret = lodash.reduce(device.content, function (ret, q, index) {
		if (q) ret.content[index] = data;
		return ret;
	}, ret);
	return ret;
};

exports.findFreeGroup = function (devices) {
	var groups = [];
	for (var i = 1; i <= 1022; ++i) {
		groups[i] = i;
	}lodash.forEach(devices.content, function (device) {
		return device && Number.isFinite(device.group) && (groups[device.group] = false);
	});
	groups = groups.filter(Boolean);
	return !groups.length ? null : groups[Math.floor(Math.random() * groups.length) % groups.length];
};

exports.cleanDatabase = function (devices) {
	var ret = devices || {};
	function _save(diff) {
		ret = lu.applyDiff(ret, diff);
	}
	function _change(path, value) {
		_save(path.reduceRight(function (ret, key) {
			return _defineProperty({}, key, ret);
		}, value));
	}
	function assign() {
		for (var _len = arguments.length, path = Array(_len), _key = 0; _key < _len; _key++) {
			path[_key] = arguments[_key];
		}

		_change(path, path.pop());
	}
	function remove() {
		for (var _len2 = arguments.length, path = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			path[_key2] = arguments[_key2];
		}

		_change(path, null);
	}

	// move root items to content
	if (!ret.content) lodash.forEach(ret, function (place, placeId) {
		if (place != null && typeof place != "object") return;
		remove(placeId);
		assign("content", placeId, place);
	});else // TODO delete later
		lodash.forEach(ret, function (place, placeId) {
			if (place != null && typeof place != "object") return;
			if (placeId == "content") return;
			remove(placeId);
		});

	// remove items with wrong type & remove group from places
	lodash.forEach(ret.content, function (place, placeId) {
		if (place == null || typeof place != "object") return remove("content", placeId);
		if (place.type == "device") // TODO: remove later
			assign("content", placeId, "type", "single");
		if (place.device == placeId) remove("content", placeId, "device");else if (!(place.type || "").match(/^(place|group|single)$/)) return remove("content", placeId);
		if (place.group != null && (!Number.isFinite(place.group) || place.type == "place")) remove("content", placeId, "group");
	});

	// create main
	if (ret && typeof ret.main != "string") {
		(function () {
			var main = UID();
			var i = 0;
			lodash.forEach(ret.content, function (place, key) {
				return assign("content", main, "content", key, ++i);
			});
			if (ret.content && ret.content[main]) assign("main", main);
		})();
	}

	// remove items with duplicate group
	var reachable = undefined;
	function groupIndex(key) {
		if (!reachable) {
			(function () {
				var push = function (key) {
					if (!(key in reachable) && ret.content.hasOwnProperty(key)) {
						reachable[key] = true;
						reachableKeys.push(key);
					}
					return key;
				};

				reachable = Object.create(null);
				var reachableKeys = [];

				push(ret.main);
				for (var _i = 0; _i < reachableKeys.length; ++_i) {
					var place = ret.content[reachableKeys[_i]];
					if (place && place.content) Object.keys(place.content).forEach(push);
				}
			})();
		}
		var i = 0;
		if (ret.content[key].type == "group") i += 2;
		if (key in reachable) i += 1;
	}

	var groups = Object.create(null);
	lodash.forEach(ret.content, function (place, key) {
		if (!place || place.group == null) return;
		if (!groups[place.group]) groups[place.group] = key;else {
			if (groupIndex(groups[place.group]) < groupIndex(key)) {
				remove("content", groups[place.group]);
				groups[place.group] = key;
			} else remove("content", key);
		}
	});

	// check content
	lodash.forEach(ret.content, function (place, key) {
		if (!place || place.content == null) return;
		if (typeof place.content != "object") return remove("content", key, "content");
		lodash.forEach(place.content, function (_, ckey) {
			if (!ret.content[ckey] || typeof ret.content[ckey] != "object") remove("content", key, "content", ckey);
		});
		place = ret.content[key]; // reassign place cause it could change in previous forEach
		lodash.keys(place.content).sort(function (a, b) {
			return (place.content[a].index || 0) - (place.content[b].index || 0);
		}).forEach(function (ckey, index) {
			if (place.content[ckey].index != index) assign("content", key, "content", ckey, "index", index);
		});
	});

	return lu.makeDiff(devices, ret);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/devdb.js","/src")

},{"_process":96,"buffer":91,"localUtils":132,"lodash":114,"uid":155}],126:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

2014.09.22

it should be better to use hammer.js, but i cannot use it without problems -
hammer.js often drops events, while direct addEventListener does not.

*/

"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var co = require("co");
var sparsequeue = require("sparsequeue");

var TRACE = undefined;
// let TC = 0
// TRACE = ( ...info ) => LOG( `${ ++TC } g ${ JSON.stringify( info ).slice( 0, 100 ) }`.green )

var SWIPE_TIMEOUT = 400; // ms
var PRESS_TIMEOUT = 500; // ms
var PRESS_MOVE_OUT = 2 /* ~mm */ * (96 / 25.4);

function squareDistance(p1, p2) {
	return (p1.pageX - p2.pageX) * (p1.pageX - p2.pageX) + (p1.pageY - p2.pageY) * (p1.pageY - p2.pageY);
}

function getX(p) {
	return p.pageX;
}
function getY(p) {
	return p.pageY;
}
function increasing(v, i, p) {
	return i == 0 || v >= p[i - 1];
}
function decreasing(v, i, p) {
	return i == 0 || v <= p[i - 1];
}

document.addEventListener("touch", co.eventHandler(regeneratorRuntime.mark(function callee$0$0(event) {
	var all, trace, last, pressed, swiped, pan, panlock, sent, send, ensurepan, sendpan, pressTimeout, stoppedTimeout, startStoppedTimeout, stopPoint, pt, longmove, dx, dy, sizex, sizey, prev, direction, traceX, traceY, bounds;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				startStoppedTimeout = function startStoppedTimeout() {
					clearTimeout(stoppedTimeout);
					stoppedTimeout = setTimeout(function () {
						ensurepan();
						sendpan("stop");
						startStoppedTimeout();
					}, PRESS_TIMEOUT);
				};

				sendpan = function sendpan(type, direction, pt, detail) {
					var data = send(type, direction, pt, detail);
					if (pan) {
						if (panlock && panlock.length) {
							panlock[0].queue.push(data);
							panlock.forEach(function (p, i) {
								return i > 0 && (p.dirty = true);
							});
							pan.dirty = true;
						} else pan.queue.push(data);
					}
				};

				ensurepan = function ensurepan(direction) {
					if (pan) return;
					pan = { queue: new sparsequeue() };
					send("pan", direction, last, {
						next: pan.queue,
						lock: function lock() {
							if (!panlock) panlock = [];
							var ret = { queue: new sparsequeue() };
							panlock.push(ret);
							return ret.queue;
						},
						unlock: function unlock(lock) {
							var lastlock = panlock[0];
							panlock = panlock.filter(function (l) {
								return l != lock;
							});
							var p = panlock[0] || pan;
							if (p.dirty) {
								p.dirty = false;
								sendpan("pan", "unlocked");
							}
						} }, "");
				};

				send = function send(type, direction, pt, detail, typeDirection) {
					TRACE && TRACE(type, all);
					if (typeDirection == null) typeDirection = direction;
					if (!detail) detail = {};
					detail.direction = direction;
					detail.pressed = pressed;
					detail.type = type;
					detail.start = event;
					detail.original = pt || event;
					var ret = new CustomEvent(type + (typeDirection || ""), { bubbles: true, cancelable: true, detail: detail });
					ret.pageX = last.pageX;
					ret.pageY = last.pageY;
					ret.clientX = last.clientX;
					ret.clientY = last.clientY;
					ret.screenX = last.screenX;
					ret.screenY = last.screenY;
					ret.deltaX = last.pageX - event.pageX;
					ret.deltaY = last.pageY - event.pageY;
					ret.lastDeltaX = last.pageX - sent.pageX;
					ret.lastDeltaY = last.pageY - sent.pageY;
					sent = last;
					ret.preventDefault = function () {
						return event.preventDefault();
					};
					event.target.dispatchEvent(ret);
					return ret;
				};

				all = undefined;
				trace = [event];
				last = event;
				pressed = null;
				swiped = false;
				pan = null;
				panlock = null;
				sent = event;

				co.defer(function () {
					panlock && panlock.forEach(function (lock) {
						return lock.queue.close();
					});
					pan && pan.queue.close();
				});

				pressTimeout = undefined;
				stoppedTimeout = undefined;

				co.defer(function () {
					clearTimeout(pressTimeout);
					clearTimeout(stoppedTimeout);
				});

				pressTimeout = setTimeout(function () {
					pressed = true;
					send("press");
				}, PRESS_TIMEOUT);

				startStoppedTimeout();

				TRACE && TRACE("enter", { x: event.pageX, y: event.pageY, t: event.timeStamp });

				stopPoint = event;
				pt = undefined;

			case 21:
				context$1$0.next = 23;
				return event.detail.next;

			case 23:
				if (!(pt = context$1$0.sent)) {
					context$1$0.next = 31;
					break;
				}

				if (TRACE) {
					(all || (all = [])).push({ x: pt.pageX, y: pt.pageY, t: pt.timeStamp - event.timeStamp });
					TRACE("next", all);
				}
				if (last.timeStamp - event.timeStamp > SWIPE_TIMEOUT) trace = null;

				longmove = squareDistance(pt, stopPoint) > PRESS_MOVE_OUT * PRESS_MOVE_OUT;

				if (longmove) {
					stopPoint = pt;
					startStoppedTimeout();
				}

				if (longmove || !trace || trace.length > 1) {
					if (pressed == null) {
						pressed = false;
						clearTimeout(pressTimeout);
					}
					dx = pt.pageX - last.pageX;
					dy = pt.pageY - last.pageY;

					if (dx || dy) {
						sizex = Math.abs(dx);
						sizey = Math.abs(dy);
						prev = last;

						if (trace) trace.push(last);
						last = pt;
						direction = "";

						if (sizex >= sizey && dx > 0) direction = "right";else if (sizex >= sizey && dx < 0) direction = "left";else if (sizex < sizey && dy > 0) direction = "down";else if (sizex < sizey && dy < 0) direction = "up";
						ensurepan(direction);
						sendpan("pan", direction, last);
					}
				}

			case 29:
				context$1$0.next = 21;
				break;

			case 31:
				clearTimeout(pressTimeout);
				if (last.timeStamp - event.timeStamp < SWIPE_TIMEOUT && trace && trace.length > 2) {
					// remove first point to eliminate touch bouncing effect
					trace.shift();
					traceX = trace.map(getX);
					traceY = trace.map(getY);
					bounds = {
						x: Math.max.apply(Math, _toConsumableArray(traceX)) - Math.min.apply(Math, _toConsumableArray(traceX)),
						y: Math.max.apply(Math, _toConsumableArray(traceY)) - Math.min.apply(Math, _toConsumableArray(traceY)) };
					direction = "";

					if (bounds.x > bounds.y && traceX.every(increasing)) direction = "right";else if (bounds.x > bounds.y && traceX.every(decreasing)) direction = "left";else if (bounds.x < bounds.y && traceY.every(increasing)) direction = "down";else if (bounds.x < bounds.y && traceY.every(decreasing)) direction = "up";
					if (direction) {
						swiped = true;
						sendpan("swipe", direction, last);
					}
				}
				if (!pressed && !swiped && !pan) sendpan("tap");
				TRACE && TRACE("done", all);

			case 35:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/gesture.js","/src")

},{"_process":96,"buffer":91,"co":123,"sparsequeue":138}],127:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var style = document.createElement("div").style;
if (!("transform" in style) && "webkitTransform" in style) {
	Object.defineProperty(CSSStyleDeclaration.prototype, "transform", {
		get: function get() {
			return this.webkitTransform;
		},
		set: function set(value) {
			this.webkitTransform = value;
		} });
}

// let slice = [].slice

if (!NodeList.prototype[Symbol.iterator]) NodeList.prototype[Symbol.iterator] = regeneratorRuntime.mark(function callee$0$0() {
	var i, l;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				i = 0, l = this.length;

			case 1:
				if (!(i < l)) {
					context$1$0.next = 7;
					break;
				}

				context$1$0.next = 4;
				return this.item(i);

			case 4:
				++i;
				context$1$0.next = 1;
				break;

			case 7:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
});

// return slice.call( this )[ Symbol.iterator ]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/htmlpolyfill.js","/src")

},{"_process":96,"buffer":91}],128:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

exports.preventDefault = function (event) {
	return event && event.preventDefault && event.preventDefault();
};

exports.Submit = function (event) {
	event && event.preventDefault();
	var c = this;
	while (c && !(c instanceof HTMLFormElement)) c = c.parentNode;
	if (c) c.dispatchEvent(new CustomEvent("submit", null));
	return false;
};

var centered = "\n\twidth: 100%;\n\theight: 100%;\n\tvertical-align: middle;\n\ttext-align: center;\n";

exports.Centered = function (_, content) {
	return React.createElement(
		"table",
		{ style: centered },
		React.createElement(
			"tr",
			{ style: centered },
			React.createElement(
				"td",
				{ style: centered },
				content
			)
		)
	);
};

exports.isEmptyNode = function (node) {
	return node instanceof Comment || node instanceof ProcessingInstruction || node instanceof Text && !node.nodeValue.trim();
};

exports.importTemplate = function (template) {
	return document.importNode(template.content, true);
};

exports.importElement = function (template) {
	var ret = exports.importTemplate(template);
	if (!ret) return null;
	while (ret.lastChild && exports.isEmptyNode(ret.lastChild)) ret.removeChild(ret.lastChild);
	while (ret.firstChild && exports.isEmptyNode(ret.firstChild)) ret.removeChild(ret.firstChild);
	if (!ret.firstChild) return null;
	if (ret.childNodes.length == 1) return ret.childNodes.item(0);
	var root = document.createElement("span");
	root.appendChild(ret);
	return root;
};

exports.importComponent = function (template) {
	var data = exports.importElement(template);
	if (data) {
		var init = data.getElementsByClassName("init")[0];
		if (init && init.type == "init") {
			var methods = ["setDeviceState"];
			var finit = new Function("component", [].slice.call(init.childNodes).map(function (x) {
				return x.data || "";
			}).join(""));
			finit(data);
		}
	}
	return data;
};

exports.tickCache = function (fun) {
	var cachedResult = undefined;
	var cached = false;

	var clearCache = function clearCache() {
		cachedResult = null;
		cached = false;
	};

	return function () {
		if (!cached) {
			cachedResult = fun.apply(this, arguments);
			cached = true;
			setImmediate(clearCache);
		}
		return cachedResult;
	};
};

exports.createEvent = function (type, detail, on) {
	var event = new CustomEvent(type, { detail: detail, bubbles: true, cancelable: true });
	if (on) {
		event.pageX = on.pageX;
		event.pageY = on.pageY;
		event.clientX = on.clientX;
		event.clientY = on.clientY;
		event.screenX = on.screenX;
		event.screenY = on.screenY;
	}
	return event;
};

exports.sendEvent = function (type, detail, on) {
	return on.target.dispatchEvent(exports.createEvent(type, detail, on));
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/htmlutils.js","/src")

},{"_process":96,"buffer":91}],129:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var lodash = require("lodash");
var lu = require("localUtils");

var httpClient = {
	get: function get(url, encoding) {
		return httpClient.xhr({ method: "GET", url: url, encoding: encoding });
	},

	post: function post(url, data, encoding) {
		return httpClient.xhr({ method: "POST", url: url, data: data, encoding: encoding });
	},

	xhr: function xhr(options) {
		var method = options.method;
		var url = options.url;
		var encoding = options.encoding;
		var data = options.data;

		var xhr = new XMLHttpRequest();
		if (encoding == "binary") xhr.responseType = "arraybuffer";else xhr.responseType = "text";
		var promise = new Promise(function (resolve, reject) {
			var onerror = function onerror(error) {
				if (typeof error == "string") {
					error = new Error(error);
					error.method = method;
					error.url = url;
				}
				global._ALERT && global._ALERT("try " + error + url);
				reject(error);
			};
			xhr.ontimeout = function () {
				return onerror(new Error("TIMEOUT " + url));
			};
			xhr.onerror = function (e) {
				return onerror(e || "ERROR");
			};
			xhr.onreadystatechange = function () {
				if (xhr.readyState == xhr.DONE && xhr.status == 0) xhr.ontimeout();
			};
			xhr.onload = function () {
				// alert( xhr.status )
				if (xhr.status >= 200 && xhr.status <= 299) return resolve(xhr.response == null ? null : xhr.response);
				if (xhr.status == 401) {
					// append some thing to the page to force standalone browser to show login dialog
					var surl = require("url").parse(url);
					if (surl.host) {
						(function () {
							surl = "" + surl.protocol + "//" + surl.host + "/dummy." + Math.random() + ".js";
							var script = document.createElement("script");
							script.src = surl;
							// alert( surl )
							document.body.appendChild(script);
							setTimeout(function () {
								return document.body.removeChild(script);
							}, 1000);
						})();
					}
				}
				onerror("" + xhr.status + " " + xhr.statusText);
			};
		});
		switch (encoding) {
			case "immutable":
				promise = promise.then(function (data) {
					return Immutable.fromJS(JSON.parse(data));
				});
				break;
			case "binary":
				promise = promise.then(function (data) {
					return new Uint8Array(data);
				});
				break;
			case "text":
				break;
			default:
				promise = promise.then(function (data) {
					var actualEncoding = encoding;
					if (!actualEncoding) {
						var ct = xhr.getResponseHeader("content-type") || "";
						if (ct.match(/^application\/json/)) actualEncoding = "json";
					}
					switch (actualEncoding) {
						case "json":
							return JSON.parse(data);
					}
					return data;
				});
		}
		xhr.open(method || "GET", url);
		xhr.withCredentials = true;
		xhr.send(data);
		xhr.then = promise.then.bind(promise);
		xhr["catch"] = promise["catch"].bind(promise);
		return xhr;
	},

	url: function url(_url, params) {
		params && Object.keys(params).forEach(function (k, i) {
			return _url = _url + (i > 0 ? "&" : "?") + encodeURIComponent(k) + "=" + encodeURIComponent(params[k]);
		});
		return _url;
	} };

module.exports = httpClient;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/httpClient.js","/src")

},{"_process":96,"buffer":91,"localUtils":132,"lodash":114,"url":101}],130:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

vadzim zienka

2015.05.11
added this.stoppedTransition to not to fire tap when scrolling is stopped by that tap.

 */

/*! iScroll v5.1.3 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */
'use strict';

(function (window, document, Math) {
	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
		window.setTimeout(callback, 1000 / 60);
	};

	var utils = (function () {
		var me = {};

		var _elementStyle = document.createElement('div').style;
		var _vendor = (function () {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			    transform,
			    i = 0,
			    l = vendors.length;

			for (; i < l; i++) {
				transform = vendors[i] + 'ransform';
				if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
			}

			return false;
		})();

		function _prefixStyle(style) {
			if (_vendor === false) return false;
			if (_vendor === '') return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		}

		me.getTime = Date.now || function getTime() {
			return new Date().getTime();
		};

		me.extend = function (target, obj) {
			for (var i in obj) {
				target[i] = obj[i];
			}
		};

		me.addEvent = function (el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};

		me.removeEvent = function (el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};

		me.prefixPointerEvent = function (pointerEvent) {
			return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) : pointerEvent;
		};

		me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
			    speed = Math.abs(distance) / time,
			    destination,
			    duration;

			deceleration = deceleration === undefined ? 0.0006 : deceleration;

			destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
			duration = speed / deceleration;

			if (destination < lowerMargin) {
				destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if (destination > 0) {
				destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}

			return {
				destination: Math.round(destination),
				duration: duration
			};
		};

		var _transform = _prefixStyle('transform');

		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: window.PointerEvent || window.MSPointerEvent, // IE10 is prefixed
			hasTransition: _prefixStyle('transition') in _elementStyle
		});

		// This should find all Android browsers lower than build 535.19 (both stock browser and webview)
		me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !/Chrome\/\d/.test(window.navigator.appVersion);

		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});

		me.hasClass = function (e, c) {
			var re = new RegExp('(^|\\s)' + c + '(\\s|$)');
			return re.test(e.className);
		};

		me.addClass = function (e, c) {
			if (me.hasClass(e, c)) {
				return;
			}

			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};

		me.removeClass = function (e, c) {
			if (!me.hasClass(e, c)) {
				return;
			}

			var re = new RegExp('(^|\\s)' + c + '(\\s|$)', 'g');
			e.className = e.className.replace(re, ' ');
		};

		me.offset = function (el) {
			var left = -el.offsetLeft,
			    top = -el.offsetTop;

			// jshint -W084
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			// jshint +W084

			return {
				left: left,
				top: top
			};
		};

		me.preventDefaultException = function (el, exceptions) {
			for (var i in exceptions) {
				if (exceptions[i].test(el[i])) {
					return true;
				}
			}

			return false;
		};

		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,

			mousedown: 2,
			mousemove: 2,
			mouseup: 2,

			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,

			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});

		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function fn(k) {
					return k * (2 - k);
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
				fn: function fn(k) {
					return Math.sqrt(1 - --k * k);
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function fn(k) {
					var b = 4;
					return (k = k - 1) * k * ((b + 1) * k + b) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function fn(k) {
					if ((k /= 1) < 1 / 2.75) {
						return 7.5625 * k * k;
					} else if (k < 2 / 2.75) {
						return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
					} else if (k < 2.5 / 2.75) {
						return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
					} else {
						return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function fn(k) {
					var f = 0.22,
					    e = 0.4;

					if (k === 0) {
						return 0;
					}
					if (k == 1) {
						return 1;
					}

					return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
				}
			}
		});

		me.tap = function (e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};

		me.click = function (e) {
			var target = e.target,
			    ev;

			if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);

				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};

		return me;
	})();

	function IScroll(el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style; // cache style for better performance

		this.options = {

			resizeScrollbars: true,

			mouseWheelSpeed: 20,

			snapThreshold: 0.334,

			// INSERT POINT: OPTIONS

			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,

			bounce: true,
			bounceTime: 600,
			bounceEasing: '',

			preventDefault: true,
			preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

			HWCompositing: true,
			useTransition: true,
			useTransform: true
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		// Normalize options
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;

		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

		// If you want eventPassthrough I have to lock one of the axes
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

		// With eventPassthrough we also need lockDirection mechanism
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

		if (this.options.tap === true) {
			this.options.tap = 'tap';
		}

		if (this.options.shrinkScrollbars == 'scale') {
			this.options.useTransition = false;
		}

		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

		if (this.options.probeType == 3) {
			this.options.useTransition = false;
		}

		// INSERT POINT: NORMALIZATION

		// Some defaults	
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};

		// INSERT POINT: DEFAULTS

		this._init();
		this.refresh();

		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	}

	IScroll.prototype = {
		version: '5.1.3',

		_init: function _init() {
			this._initEvents();

			if (this.options.scrollbars || this.options.indicators) {
				this._initIndicators();
			}

			if (this.options.mouseWheel) {
				this._initWheel();
			}

			if (this.options.snap) {
				this._initSnap();
			}

			if (this.options.keyBindings) {
				this._initKeys();
			}

			// INSERT POINT: _init
		},

		destroy: function destroy() {
			this._initEvents(true);

			this._execEvent('destroy');
		},

		_transitionEnd: function _transitionEnd(e) {
			if (e.target != this.scroller || !this.isInTransition) {
				return;
			}

			this._transitionTime();
			if (!this.resetPosition(this.options.bounceTime)) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},

		_start: function _start(e) {
			// React to left mouse button only
			if (utils.eventType[e.type] != 1) {
				if (e.button !== 0) {
					return;
				}
			}

			if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    pos;

			this.initiated = utils.eventType[e.type];
			this.moved = false;
			this.distX = 0;
			this.distY = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;

			this._transitionTime();

			this.startTime = utils.getTime();

			this.stoppedTransition = false;
			if (this.options.useTransition && this.isInTransition) {
				this.stoppedTransition = true;
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if (!this.options.useTransition && this.isAnimating) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}

			this.startX = this.x;
			this.startY = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault) {
				// increases performance on Android? TODO: check!
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    deltaX = point.pageX - this.pointX,
			    deltaY = point.pageY - this.pointY,
			    timestamp = utils.getTime(),
			    newX,
			    newY,
			    absDistX,
			    absDistY;

			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this.distX += deltaX;
			this.distY += deltaY;
			absDistX = Math.abs(this.distX);
			absDistY = Math.abs(this.distY);

			// We need to move at least 10 pixels for the scrolling to initiate
			if (timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10)) {
				return;
			}

			// If you are scrolling in one direction lock the other
			if (!this.directionLocked && !this.options.freeScroll) {
				if (absDistX > absDistY + this.options.directionLockThreshold) {
					this.directionLocked = 'h'; // lock horizontally
				} else if (absDistY >= absDistX + this.options.directionLockThreshold) {
					this.directionLocked = 'v'; // lock vertically
				} else {
					this.directionLocked = 'n'; // no lock
				}
			}

			if (this.directionLocked == 'h') {
				if (this.options.eventPassthrough == 'vertical') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'horizontal') {
					this.initiated = false;
					return;
				}

				deltaY = 0;
			} else if (this.directionLocked == 'v') {
				if (this.options.eventPassthrough == 'horizontal') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'vertical') {
					this.initiated = false;
					return;
				}

				deltaX = 0;
			}

			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			// Slow down if outside of the boundaries
			if (newX > 0 || newX < this.maxScrollX) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if (newY > 0 || newY < this.maxScrollY) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}

			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

			if (!this.moved) {
				this._execEvent('scrollStart');
			}

			this.moved = true;

			this._translate(newX, newY);

			/* REPLACE START: _move */
			if (timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;

				if (this.options.probeType == 1) {
					this._execEvent('scroll');
				}
			}

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}
			/* REPLACE END: _move */
		},

		_end: function _end(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.changedTouches ? e.changedTouches[0] : e,
			    momentumX,
			    momentumY,
			    duration = utils.getTime() - this.startTime,
			    newX = Math.round(this.x),
			    newY = Math.round(this.y),
			    distanceX = Math.abs(newX - this.startX),
			    distanceY = Math.abs(newY - this.startY),
			    time = 0,
			    easing = '';

			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();

			// reset if we are outside of the boundaries
			if (this.resetPosition(this.options.bounceTime)) {
				return;
			}

			this.scrollTo(newX, newY); // ensures that the last position is rounded

			// we scrolled less than 10 pixels
			if (!this.moved) {
				if (!this.stoppedTransition) {
					if (this.options.tap) {
						utils.tap(e, this.options.tap);
					}

					if (this.options.click) {
						utils.click(e);
					}
				}

				this._execEvent('scrollCancel');
				return;
			}

			if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
				this._execEvent('flick');
				return;
			}

			// start momentum animation if needed
			if (this.options.momentum && duration < 300) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}

			if (this.options.snap) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
				newX = snap.x;
				newY = snap.y;

				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}

			// INSERT POINT: _end

			if (newX != this.x || newY != this.y) {
				// change easing function when scroller goes out of the boundaries
				if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
					easing = utils.ease.quadratic;
				}

				this.scrollTo(newX, newY, time, easing);
				return;
			}

			this._execEvent('scrollEnd');
		},

		_resize: function _resize() {
			var that = this;

			clearTimeout(this.resizeTimeout);

			this.resizeTimeout = setTimeout(function () {
				that.refresh();
			}, this.options.resizePolling);
		},

		resetPosition: function resetPosition(time) {
			var x = this.x,
			    y = this.y;

			time = time || 0;

			if (!this.hasHorizontalScroll || this.x > 0) {
				x = 0;
			} else if (this.x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (!this.hasVerticalScroll || this.y > 0) {
				y = 0;
			} else if (this.y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			if (x == this.x && y == this.y) {
				return false;
			}

			this.scrollTo(x, y, time, this.options.bounceEasing);

			return true;
		},

		disable: function disable() {
			this.enabled = false;
		},

		enable: function enable() {
			this.enabled = true;
		},

		refresh: function refresh() {
			var rf = this.wrapper.offsetHeight; // Force reflow

			this.wrapperWidth = this.wrapper.clientWidth;
			this.wrapperHeight = this.wrapper.clientHeight;

			/* REPLACE START: refresh */

			this.scrollerWidth = this.scroller.offsetWidth;
			this.scrollerHeight = this.scroller.offsetHeight;

			this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY = this.wrapperHeight - this.scrollerHeight;

			/* REPLACE END: refresh */

			this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

			if (!this.hasHorizontalScroll) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}

			if (!this.hasVerticalScroll) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}

			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;

			this.wrapperOffset = utils.offset(this.wrapper);

			this._execEvent('refresh');

			this.resetPosition();

			// INSERT POINT: _refresh
		},

		on: function on(type, fn) {
			if (!this._events[type]) {
				this._events[type] = [];
			}

			this._events[type].push(fn);
		},

		off: function off(type, fn) {
			if (!this._events[type]) {
				return;
			}

			var index = this._events[type].indexOf(fn);

			if (index > -1) {
				this._events[type].splice(index, 1);
			}
		},

		_execEvent: function _execEvent(type) {
			if (!this._events[type]) {
				return;
			}

			var i = 0,
			    l = this._events[type].length;

			if (!l) {
				return;
			}

			for (; i < l; i++) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},

		scrollBy: function scrollBy(x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;

			this.scrollTo(x, y, time, easing);
		},

		scrollTo: function scrollTo(x, y, time, easing) {
			easing = easing || utils.ease.circular;

			this.isInTransition = this.options.useTransition && time > 0;

			if (!time || this.options.useTransition && easing.style) {
				this._transitionTimingFunction(easing.style);
				this._transitionTime(time);
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},

		scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);

			if (!el) {
				return;
			}

			var pos = utils.offset(el);

			pos.left -= this.wrapperOffset.left;
			pos.top -= this.wrapperOffset.top;

			// if offsetX/Y are true we center the element to the screen
			if (offsetX === true) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if (offsetY === true) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}

			pos.left -= offsetX || 0;
			pos.top -= offsetY || 0;

			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

			this.scrollTo(pos.left, pos.top, time, easing);
		},

		_transitionTime: function _transitionTime(time) {
			time = time || 0;

			this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
			}

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTime(time);
				}
			}

			// INSERT POINT: _transitionTime
		},

		_transitionTimingFunction: function _transitionTimingFunction(easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}

			// INSERT POINT: _transitionTimingFunction
		},

		_translate: function _translate(x, y) {
			if (this.options.useTransform) {

				/* REPLACE START: _translate */

				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

				/* REPLACE END: _translate */
			} else {
				x = Math.round(x);
				y = Math.round(y);
				this.scrollerStyle.left = x + 'px';
				this.scrollerStyle.top = y + 'px';
			}

			this.x = x;
			this.y = y;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].updatePosition();
				}
			}

			// INSERT POINT: _translate
		},

		_initEvents: function _initEvents(remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
			    target = this.options.bindToWrapper ? this.wrapper : window;

			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);

			if (this.options.click) {
				eventType(this.wrapper, 'click', this, true);
			}

			if (!this.options.disableMouse) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}

			if (utils.hasPointer && !this.options.disablePointer) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}

			if (utils.hasTouch && !this.options.disableTouch) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}

			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},

		getComputedPosition: function getComputedPosition() {
			var matrix = window.getComputedStyle(this.scroller, null),
			    x,
			    y;

			if (this.options.useTransform) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}

			return { x: x, y: y };
		},

		_initIndicators: function _initIndicators() {
			var interactive = this.options.interactiveScrollbars,
			    customStyle = typeof this.options.scrollbars != 'string',
			    indicators = [],
			    indicator;

			var that = this;

			this.indicators = [];

			if (this.options.scrollbars) {
				// Vertical scrollbar
				if (this.options.scrollY) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}

				// Horizontal scrollbar
				if (this.options.scrollX) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}

			if (this.options.indicators) {
				// TODO: check concat compatibility
				indicators = indicators.concat(this.options.indicators);
			}

			for (var i = indicators.length; i--;) {
				this.indicators.push(new Indicator(this, indicators[i]));
			}

			// TODO: check if we can use array.map (wide compatibility and performance issues)
			function _indicatorsMap(fn) {
				for (var i = that.indicators.length; i--;) {
					fn.call(that.indicators[i]);
				}
			}

			if (this.options.fadeScrollbars) {
				this.on('scrollEnd', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollCancel', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1);
					});
				});

				this.on('beforeScrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1, true);
					});
				});
			}

			this.on('refresh', function () {
				_indicatorsMap(function () {
					this.refresh();
				});
			});

			this.on('destroy', function () {
				_indicatorsMap(function () {
					this.destroy();
				});

				delete this.indicators;
			});
		},

		_initWheel: function _initWheel() {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

			this.on('destroy', function () {
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},

		_wheel: function _wheel(e) {
			if (!this.enabled) {
				return;
			}

			e.preventDefault();
			e.stopPropagation();

			var wheelDeltaX,
			    wheelDeltaY,
			    newX,
			    newY,
			    that = this;

			if (this.wheelTimeout === undefined) {
				that._execEvent('scrollStart');
			}

			// Execute the scrollEnd event after 400ms the wheel stopped scrolling
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function () {
				that._execEvent('scrollEnd');
				that.wheelTimeout = undefined;
			}, 400);

			if ('deltaX' in e) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ('wheelDeltaX' in e) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ('wheelDelta' in e) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ('detail' in e) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}

			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;

			if (!this.hasVerticalScroll) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}

			if (this.options.snap) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;

				if (wheelDeltaX > 0) {
					newX--;
				} else if (wheelDeltaX < 0) {
					newX++;
				}

				if (wheelDeltaY > 0) {
					newY--;
				} else if (wheelDeltaY < 0) {
					newY++;
				}

				this.goToPage(newX, newY);

				return;
			}

			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

			if (newX > 0) {
				newX = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
			}

			if (newY > 0) {
				newY = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
			}

			this.scrollTo(newX, newY, 0);

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}

			// INSERT POINT: _wheel
		},

		_initSnap: function _initSnap() {
			this.currentPage = {};

			if (typeof this.options.snap == 'string') {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}

			this.on('refresh', function () {
				var i = 0,
				    l,
				    m = 0,
				    n,
				    cx,
				    cy,
				    x = 0,
				    y,
				    stepX = this.options.snapStepX || this.wrapperWidth,
				    stepY = this.options.snapStepY || this.wrapperHeight,
				    el;

				this.pages = [];

				if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
					return;
				}

				if (this.options.snap === true) {
					cx = Math.round(stepX / 2);
					cy = Math.round(stepY / 2);

					while (x > -this.scrollerWidth) {
						this.pages[i] = [];
						l = 0;
						y = 0;

						while (y > -this.scrollerHeight) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};

							y -= stepY;
							l++;
						}

						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;

					for (; i < l; i++) {
						if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
							m = 0;
							n++;
						}

						if (!this.pages[m]) {
							this.pages[m] = [];
						}

						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);

						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};

						if (x > this.maxScrollX) {
							m++;
						}
					}
				}

				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

				// Update snap threshold if needed
				if (this.options.snapThreshold % 1 === 0) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});

			this.on('flick', function () {
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);

				this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
			});
		},

		_nearestSnap: function _nearestSnap(x, y) {
			if (!this.pages.length) {
				return { x: 0, y: 0, pageX: 0, pageY: 0 };
			}

			var i = 0,
			    l = this.pages.length,
			    m = 0;

			// Check if we exceeded the snap threshold
			if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
				return this.currentPage;
			}

			if (x > 0) {
				x = 0;
			} else if (x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (y > 0) {
				y = 0;
			} else if (y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			for (; i < l; i++) {
				if (x >= this.pages[i][0].cx) {
					x = this.pages[i][0].x;
					break;
				}
			}

			l = this.pages[i].length;

			for (; m < l; m++) {
				if (y >= this.pages[0][m].cy) {
					y = this.pages[0][m].y;
					break;
				}
			}

			if (i == this.currentPage.pageX) {
				i += this.directionX;

				if (i < 0) {
					i = 0;
				} else if (i >= this.pages.length) {
					i = this.pages.length - 1;
				}

				x = this.pages[i][0].x;
			}

			if (m == this.currentPage.pageY) {
				m += this.directionY;

				if (m < 0) {
					m = 0;
				} else if (m >= this.pages[0].length) {
					m = this.pages[0].length - 1;
				}

				y = this.pages[0][m].y;
			}

			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},

		goToPage: function goToPage(x, y, time, easing) {
			easing = easing || this.options.bounceEasing;

			if (x >= this.pages.length) {
				x = this.pages.length - 1;
			} else if (x < 0) {
				x = 0;
			}

			if (y >= this.pages[x].length) {
				y = this.pages[x].length - 1;
			} else if (y < 0) {
				y = 0;
			}

			var posX = this.pages[x][y].x,
			    posY = this.pages[x][y].y;

			time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;

			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};

			this.scrollTo(posX, posY, time, easing);
		},

		next: function next(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x++;

			if (x >= this.pages.length && this.hasVerticalScroll) {
				x = 0;
				y++;
			}

			this.goToPage(x, y, time, easing);
		},

		prev: function prev(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x--;

			if (x < 0 && this.hasVerticalScroll) {
				x = 0;
				y--;
			}

			this.goToPage(x, y, time, easing);
		},

		_initKeys: function _initKeys(e) {
			// default key bindings
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;

			// if you give me characters I give you keycode
			if (typeof this.options.keyBindings == 'object') {
				for (i in this.options.keyBindings) {
					if (typeof this.options.keyBindings[i] == 'string') {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}

			for (i in keys) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}

			utils.addEvent(window, 'keydown', this);

			this.on('destroy', function () {
				utils.removeEvent(window, 'keydown', this);
			});
		},

		_key: function _key(e) {
			if (!this.enabled) {
				return;
			}

			var snap = this.options.snap,
			    // we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			    newY = snap ? this.currentPage.pageY : this.y,
			    now = utils.getTime(),
			    prevTime = this.keyTime || 0,
			    acceleration = 0.25,
			    pos;

			if (this.options.useTransition && this.isInTransition) {
				pos = this.getComputedPosition();

				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}

			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

			switch (e.keyCode) {
				case this.options.keyBindings.pageUp:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX += snap ? 1 : this.wrapperWidth;
					} else {
						newY += snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.pageDown:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX -= snap ? 1 : this.wrapperWidth;
					} else {
						newY -= snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.end:
					newX = snap ? this.pages.length - 1 : this.maxScrollX;
					newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
					break;
				case this.options.keyBindings.home:
					newX = 0;
					newY = 0;
					break;
				case this.options.keyBindings.left:
					newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.up:
					newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.right:
					newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.down:
					newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				default:
					return;
			}

			if (snap) {
				this.goToPage(newX, newY);
				return;
			}

			if (newX > 0) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}

			if (newY > 0) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}

			this.scrollTo(newX, newY, 0);

			this.keyTime = now;
		},

		_animate: function _animate(destX, destY, duration, easingFn) {
			var that = this,
			    startX = this.x,
			    startY = this.y,
			    startTime = utils.getTime(),
			    destTime = startTime + duration;

			function step() {
				var now = utils.getTime(),
				    newX,
				    newY,
				    easing;

				if (now >= destTime) {
					that.isAnimating = false;
					that._translate(destX, destY);

					if (!that.resetPosition(that.options.bounceTime)) {
						that._execEvent('scrollEnd');
					}

					return;
				}

				now = (now - startTime) / duration;
				easing = easingFn(now);
				newX = (destX - startX) * easing + startX;
				newY = (destY - startY) * easing + startY;
				that._translate(newX, newY);

				if (that.isAnimating) {
					rAF(step);
				}

				if (that.options.probeType == 3) {
					that._execEvent('scroll');
				}
			}

			this.isAnimating = true;
			step();
		},

		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
				case 'orientationchange':
				case 'resize':
					this._resize();
					break;
				case 'transitionend':
				case 'webkitTransitionEnd':
				case 'oTransitionEnd':
				case 'MSTransitionEnd':
					this._transitionEnd(e);
					break;
				case 'wheel':
				case 'DOMMouseScroll':
				case 'mousewheel':
					this._wheel(e);
					break;
				case 'keydown':
					this._key(e);
					break;
				case 'click':
					if (!e._constructed) {
						e.preventDefault();
						e.stopPropagation();
					}
					break;
			}
		}
	};
	function createDefaultScrollbar(direction, interactive, type) {
		var scrollbar = document.createElement('div'),
		    indicator = document.createElement('div');

		if (type === true) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}

		indicator.className = 'iScrollIndicator';

		if (direction == 'h') {
			if (type === true) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if (type === true) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}

		scrollbar.style.cssText += ';overflow:hidden';

		if (!interactive) {
			scrollbar.style.pointerEvents = 'none';
		}

		scrollbar.appendChild(indicator);

		return scrollbar;
	}

	function Indicator(scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;

		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;

		if (this.options.interactive) {
			if (!this.options.disableTouch) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}

		if (this.options.fade) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
			this.wrapperStyle.opacity = '0';
		}
	}

	Indicator.prototype = {
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
			}
		},

		destroy: function destroy() {
			if (this.options.interactive) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);

				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);

				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}

			if (this.options.defaultScrollbars) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},

		_start: function _start(e) {
			var point = e.touches ? e.touches[0] : e;

			e.preventDefault();
			e.stopPropagation();

			this.transitionTime();

			this.initiated = true;
			this.moved = false;
			this.lastPointX = point.pageX;
			this.lastPointY = point.pageY;

			this.startTime = utils.getTime();

			if (!this.options.disableTouch) {
				utils.addEvent(window, 'touchmove', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(window, 'mousemove', this);
			}

			this.scroller._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			var point = e.touches ? e.touches[0] : e,
			    deltaX,
			    deltaY,
			    newX,
			    newY,
			    timestamp = utils.getTime();

			if (!this.moved) {
				this.scroller._execEvent('scrollStart');
			}

			this.moved = true;

			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;

			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			this._pos(newX, newY);

			if (this.scroller.options.probeType == 1 && timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.scroller._execEvent('scroll');
			} else if (this.scroller.options.probeType > 1) {
				this.scroller._execEvent('scroll');
			}

			// INSERT POINT: indicator._move

			e.preventDefault();
			e.stopPropagation();
		},

		_end: function _end(e) {
			if (!this.initiated) {
				return;
			}

			this.initiated = false;

			e.preventDefault();
			e.stopPropagation();

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			if (this.scroller.options.snap) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

				if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}

			if (this.moved) {
				this.scroller._execEvent('scrollEnd');
			}
		},

		transitionTime: function transitionTime(time) {
			time = time || 0;
			this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
			}
		},

		transitionTimingFunction: function transitionTimingFunction(easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},

		refresh: function refresh() {
			this.transitionTime();

			if (this.options.listenX && !this.options.listenY) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if (this.options.listenY && !this.options.listenX) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}

			if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}

			var r = this.wrapper.offsetHeight; // force refresh

			if (this.options.listenX) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if (this.options.resize) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}

				this.maxPosX = this.wrapperWidth - this.indicatorWidth;

				if (this.options.shrink == 'clip') {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}

				this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
			}

			if (this.options.listenY) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if (this.options.resize) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;

				if (this.options.shrink == 'clip') {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
			}

			this.updatePosition();
		},

		updatePosition: function updatePosition() {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			    y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

			if (!this.options.ignoreBoundaries) {
				if (x < this.minBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if (x > this.maxBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}

				if (y < this.minBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if (y > this.maxBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}

			this.x = x;
			this.y = y;

			if (this.scroller.options.useTransform) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},

		_pos: function _pos(x, y) {
			if (x < 0) {
				x = 0;
			} else if (x > this.maxPosX) {
				x = this.maxPosX;
			}

			if (y < 0) {
				y = 0;
			} else if (y > this.maxPosY) {
				y = this.maxPosY;
			}

			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

			this.scroller.scrollTo(x, y);
		},

		fade: function fade(val, hold) {
			if (hold && !this.visible) {
				return;
			}

			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;

			var time = val ? 250 : 500,
			    delay = val ? 0 : 300;

			val = val ? '1' : '0';

			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

			this.fadeTimeout = setTimeout((function (val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}).bind(this, val), delay);
		}
	};

	IScroll.utils = utils;

	if (typeof module != 'undefined' && module.exports) {
		module.exports = IScroll;
	} else {
		window.IScroll = IScroll;
	}
})(window, document, Math);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/iscroll.js","/src")

},{"_process":96,"buffer":91}],131:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = new (require("scheduler"))();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/later.js","/src")

},{"_process":96,"buffer":91,"scheduler":137}],132:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var co = require("co");
var EventEmitter = require("events").EventEmitter || require("events");

var NON_PARTIAL = Object.create(null);
NON_PARTIAL.__partial__ = false;

var PARTIAL = Object.create(null);

function assert(value, message) {
	if (!value) throw new Error("" + message);
}

var LiteralPrototype = Object.getPrototypeOf({});

var lu = module.exports = {

	dumpPromise: function dumpPromise(p) {
		return p.then(function (result) {
			return lu.log("result:", result);
		}, function (error) {
			return lu.error("error:", error);
		});
	},

	dump: function dump(msg, value) {
		console.log(msg, value);
		return value;
	},

	log: console.log.bind(console),
	info: (console.info || console.log).bind(console),
	warn: (console.warn || console.log).bind(console),
	error: (console.error || console.log).bind(console),
	trace: (console.trace || console.log).bind(console),

	mapObj: function mapObj(obj, props) {
		var ret = Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
		lodash.forEach(props, function (fun, key) {
			return ret[key] = typeof fun == "function" ? fun(obj[key]) : fun;
		});
		return ret;
	},

	rests: function rests(num) {
		for (var _len = arguments.length, _rests = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			_rests[_key - 1] = arguments[_key];
		}

		var ret = [];
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = _rests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var r = _step.value;

				var n = num % r;
				num = (num - n) / r;
				ret.push(n);
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator["return"]) {
					_iterator["return"]();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return ret;
	},

	pad: function pad(s, n, p) {
		s = String(s);
		var x = "";
		n -= s.length;
		while (n > 0) {
			x += p;
			--n;
		}
		return x + s;
	},

	time: function time() {
		var d = new Date();
		return "" + d.getHours() + ":" + lu.pad(d.getMinutes(), 2, 0) + ":" + lu.pad(d.getSeconds(), 2, 0) + "." + lu.pad(d.getMilliseconds(), 3, 0);
	},

	stack: function stack() {
		return new Error().stack;
	},

	options: function options(_options, def) {
		var ret = {};
		for (var i in def) {
			if (Object.prototype.hasOwnProperty.call(def, i)) if (_options == null) ret[i] = def[i];else {
				var op = _options[i];
				if (op == null) op = def[i];
				ret[i] = op;
			}
		}return ret;
	},

	str: function str(obj, depth) {
		if (depth == null) depth = 1;
		if (!obj || !depth || depth < 1) return "" + obj;
		if (Array.isArray(obj)) return "[ " + obj.map(function (x) {
			return lu.str(x, depth - 1);
		}).join(" ") + " ]";
		if (!obj.constructor || obj.constructor == Object) return "{ " + Object.keys(obj).map(function (x) {
			return x + "=" + lu.str(obj[x], depth - 1);
		}).join(" ") + " }";
		return String(obj);
	},

	toOneLine: function toOneLine(obj) {
		var ret = JSON.stringify(obj);
		ret += "\n";
		return ret;
	},

	byLines: function byLines(callback) {
		var buffer = "";
		return function (chunk) {
			buffer += String(chunk);
			var ret = buffer.split("\n");
			buffer = ret.pop();
			ret.forEach(callback);
		};
	},

	byJSON: function byJSON(callback) {
		return byLines(function (line) {
			return callback(JSON.parse(line.trim()));
		});
	},

	valueOf: function valueOf(val) {
		return val == null ? null : val.valueOf == null ? val : val.valueOf();
	},

	returnThis: function returnThis() {
		return this;
	},
	returnNull: function returnNull() {
		return null;
	},
	returnTrue: function returnTrue() {
		return true;
	},
	returnFalse: function returnFalse() {
		return false;
	},
	returnZero: function returnZero() {
		return 0;
	},
	returnOne: function returnOne() {
		return 1;
	},

	promiseSucceeded: Promise.resolve(),
	promiseNull: Promise.resolve(null),
	promiseTrue: Promise.resolve(true),
	promiseFalse: Promise.resolve(false),
	promiseZero: Promise.resolve(0),
	promiseOne: Promise.resolve(1),

	returnNullPromise: function returnNullPromise() {
		return lu.promiseNull;
	},
	returnTruePromise: function returnTruePromise() {
		return lu.promiseTrue;
	},
	returnFalsePromise: function returnFalsePromise() {
		return lu.promiseFalse;
	},
	returnZeroPromise: function returnZeroPromise() {
		return lu.promiseZero;
	},
	returnOnePromise: function returnOnePromise() {
		return lu.promiseOne;
	},

	when: function when(promise, cb) {
		if (promise != null) promise.then(cb, cb);else process.nextTick(cb);
		return promise;
	},

	waitFor: function waitFor(timeout, interval, callback) {
		if (typeof timeout == "function") {
			interval = timeout;
			timeout = 5000;
		}
		if (typeof interval == "function") {
			callback = interval;
			interval = 200;
		}
		return new Promise(function (resolve, reject) {
			var start = Date.now();
			setTimeout(function check() {
				var ret = undefined;
				if (ret = callback()) resolve(ret);else if (Date.now() - start > timeout) reject(new Error("timeout"));else setTimeout(check, interval);
			}, interval);
		});
	},

	empty: Object.freeze(Object.create(null)),

	JSONEqual: function JSONEqual(a, b) {
		return JSON.stringify(a) == JSON.stringify(b);
	},

	"new": function _new() {
		for (var _len2 = arguments.length, descedents = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			descedents[_key2] = arguments[_key2];
		}

		return Object.assign.apply(Object, [{}].concat(descedents));
	},

	call: function call(fun) {
		for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
			args[_key3 - 1] = arguments[_key3];
		}

		return fun.apply(undefined, args);
	},

	rethrow: function rethrow(e) {
		setTimeout(function () {
			throw e;
		}, 1);
	},

	// optimization -- using try/catch in a separate function.
	"catch": function _catch(cb, ret) {
		try {
			return cb();
		} catch (e) {
			return ret(e);
		}
	},

	catchMap: function catchMap(cb, mapResult, mapError) {
		var result = undefined;
		try {
			result = cb();
		} catch (error) {
			return mapError(error);
		}
		return mapResult(result);
	},

	catchCall: function catchCall(cb) {
		try {
			return { ok: true, result: cb() };
		} catch (error) {
			return { ok: false, error: error };
		}
	},

	"try": regeneratorRuntime.mark(function _try(fun) {
		var startTimeToWait = arguments[1] === undefined ? 100 : arguments[1];
		var maxTimeToWait = arguments[2] === undefined ? 3000 : arguments[2];
		var multiply = arguments[3] === undefined ? 1.5 : arguments[3];
		var timeToWait;
		return regeneratorRuntime.wrap(function _try$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					timeToWait = startTimeToWait;

				case 1:
					context$1$0.prev = 1;
					context$1$0.next = 4;
					return fun();

				case 4:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 7:
					context$1$0.prev = 7;
					context$1$0.t0 = context$1$0["catch"](1);

					lu.rethrow(context$1$0.t0);
					context$1$0.next = 12;
					return co.sleep(timeToWait);

				case 12:
					timeToWait = Math.min(timeToWait * multiply, maxTimeToWait);

				case 13:
					context$1$0.next = 1;
					break;

				case 15:
				case "end":
					return context$1$0.stop();
			}
		}, _try, this, [[1, 7]]);
	}),

	unique: function unique(value, index, array) {
		return index == 0 || value != array[index - 1];
	},

	joinData: function joinData(array) {
		return array.length == 0 ? "" : typeof array[0] == "string" ? array.join("") : Buffer.isBuffer(array[0]) ? Buffer.concat(array) : array.join("");
	},

	on: function on(emitter, events) {
		lodash.forEach(events, function (handler, event) {
			return emitter.on(event, handler);
		});
	},

	off: function off(emitter, events) {
		lodash.forEach(events, function (handler, event) {
			return emitter.removeListener(event, handler);
		});
	},

	readStream: regeneratorRuntime.mark(function readStream(stream) {
		return regeneratorRuntime.wrap(function readStream$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return { then: function then(resolve, reject) {
							var content = [];
							stream.on("data", function (chunk) {
								return content.push(chunk);
							});
							stream.on("end", function () {
								return resolve(lu.joinData(content));
							});
							stream.on("error", reject);
						} };

				case 2:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 3:
				case "end":
					return context$1$0.stop();
			}
		}, readStream, this);
	}),

	readJSON: regeneratorRuntime.mark(function readJSON(stream) {
		return regeneratorRuntime.wrap(function readJSON$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return lu.readStream(stream);

				case 2:
					context$1$0.t0 = context$1$0.sent;
					return context$1$0.abrupt("return", JSON.parse(context$1$0.t0));

				case 4:
				case "end":
					return context$1$0.stop();
			}
		}, readJSON, this);
	}),

	readChunk: regeneratorRuntime.mark(function readChunk(stream) {
		return regeneratorRuntime.wrap(function readChunk$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return { then: function then(resolve, reject) {
							stream.on("data", onData);
							stream.on("end", onEnd);
							stream.on("error", onError);
							function done() {
								stream.removeListener("data", onData);
								stream.removeListener("end", onEnd);
								stream.removeListener("error", onError);
							}
							function onData(chunk) {
								done();
								resolve(chunk);
							}
							function onEnd() {
								done();
								resolve(null);
							}
							function onError(error) {
								done();
								reject(error);
							}
						} };

				case 2:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 3:
				case "end":
					return context$1$0.stop();
			}
		}, readChunk, this);
	}),

	"static": function _static(fun) {
		return co.func(regeneratorRuntime.mark(function callee$1$0(request, response) {
			var headWritten, responseEnded, body;
			return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						headWritten = false, responseEnded = false;
						context$2$0.prev = 1;
						context$2$0.next = 4;
						return fun();

					case 4:
						body = context$2$0.sent;

						response.writeHead(200, _defineProperty({}, "Content-Type", "text/html; charset=UTF-8"));
						headWritten = true;
						if (typeof body != "string") body = React.renderComponentToString(body);
						response.end(body);
						responseEnded = true;

					case 10:
						context$2$0.prev = 10;

						if (!headWritten) response.writeHead(500, _defineProperty({}, "Content-Type", "text/plain"));
						if (!responseEnded) response.end("<<< ERROR >>>");
						return context$2$0.finish(10);

					case 14:
					case "end":
						return context$2$0.stop();
				}
			}, callee$1$0, this, [[1,, 10, 14]]);
		}));
	},

	property: function property(obj, name, defaultValue) {
		var privateName = "_" + name;
		if (arguments.length > 2) obj[privateName] = defaultValue;
		obj[name] = function (value) {
			if (arguments.length == 0) return obj[privateName];else {
				obj[privateName] = value;
				return obj;
			}
		};
		return obj;
	},

	polling: function polling(stream) {
		var ret = {
			stop: function stop() {
				if (!ret) return;
				if (ret._polling != null) {
					clearTimeout(ret._polling);
					ret._polling = null;
				}
				ret = null;
			},
			_polling: null,
			_tryToSendChunk: function _tryToSendChunk() {
				if (!ret) return;
				ret._polling = null;
				if (!stream.write(ret._chunk)) stream.once("drain", ret._tryToSendChunk);else {
					if (typeof stream.flush == "function") stream.flush();
					ret._polling = setTimeout(ret._tryToSendChunk, ret._interval);
				}
			} };

		lu.property(ret, "chunk", "\n");
		lu.property(ret, "interval", 60000);

		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("end", ret.stop);
		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("close", ret.stop);
		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("error", ret.stop);

		process.nextTick(ret._tryToSendChunk);

		return ret;
	},

	testDiff: function testDiff() {
		var p = { a: 1, x: { u: 9 } };
		var q = { x: { c: 2 } };
		assert(JSON.stringify(q) == JSON.stringify(lu.applyDiff(p, lu.makeDiff(p, q))));
	},

	isSet: function isSet(obj) {
		if (obj == null) return false;
		var proto = Object.getPrototypeOf(obj);
		return proto === LiteralPrototype || proto === null;
	},

	applyDiff: function applyDiff(dest, diff, partial) {
		var ret = dest;
		var cnt = 0;

		function copyDest() {
			ret = Object.create(null);
			for (var key in dest) {
				if (Object.prototype.hasOwnProperty.call(dest, key)) {
					var value = dest[key];
					if (value === undefined) continue;
					ret[key] = dest[key];
					++cnt;
				}
			}
		}

		if (diff && diff.__partial__ === false) partial = false;

		for (var key in diff) {
			if (key != "__partial__" && Object.prototype.hasOwnProperty.call(diff, key)) {
				var value = diff[key];
				if (value === undefined) continue;
				if (value != null && typeof value == "object") value = lu.applyDiff(ret && ret[key], value, partial);
				if (value == null) {
					if (ret != null && Object.prototype.hasOwnProperty.call(ret, key)) {
						if (ret === dest) copyDest();
						delete ret[key];
						--cnt;
					}
				} else {
					if (ret == null || ret[key] !== value) {
						if (ret === dest) copyDest();
						ret[key] = value;
					}
					cnt = Infinity;
				}
			}
		}if (partial === false) for (var key in ret) {
			if (Object.prototype.hasOwnProperty.call(ret, key)) {
				if (!Object.prototype.hasOwnProperty.call(diff, key) || diff[key] === undefined) {
					if (ret === dest) copyDest();
					delete ret[key];
					--cnt;
				} else cnt = Infinity;
			}
		}if (ret !== dest && cnt == 0) ret = null;

		return ret;
	},

	mergeDiffs: function mergeDiffs(a, b) {

		if (a == null) a = NON_PARTIAL;
		if (b == null) b = NON_PARTIAL;

		if (b.__partial__ === false) return b;

		var ret = a;

		function copyDest() {
			ret = Object.create(null);
			for (var key in a) {
				if (Object.prototype.hasOwnProperty.call(a, key)) {
					var value = a[key];
					if (value === undefined) continue;
					ret[key] = a[key];
				}
			}
		}

		for (var key in b) {
			if (Object.prototype.hasOwnProperty.call(b, key)) {
				var value = b[key];
				if (value === undefined) continue;
				if (value == null) value = NON_PARTIAL;
				if (typeof value == "object") {
					var r = ret ? ret[key] : undefined;
					if (r === undefined) r = PARTIAL;
					value = lu.mergeDiffs(r, value);
				}
				if (ret == null || ret[key] !== value) {
					if (ret === a) copyDest();
					ret[key] = value;
				}
			}
		}if (ret !== a && typeof a != "object") ret.__partial__ = false;

		return ret;
	},

	makeDiff: function makeDiff(previous, next) {
		if (previous === next) return undefined;
		var ret = undefined;
		function toArray(obj) {
			var ret = [];
			lodash.forEach(obj, function (value, key) {
				return ret.push({ value: value, key: key });
			});
			return ret.sort(function (v1, v2) {
				return v1.key < v2.key ? -1 : v1.key > v2.key ? 1 : 0;
			});
		}
		var pa = toArray(previous);
		var na = toArray(next);
		var p = pa.pop();
		var n = na.pop();
		while (p || n) {
			if (!n || p && p.key > n.key) {
				if (!ret) ret = Object.create(null);
				ret[p.key] = null; // deleting
				p = pa.pop();
			} else if (!p || p.key < n.key) {
				if (!ret) ret = Object.create(null);
				ret[n.key] = n.value;
				n = na.pop();
			} else {
				if (p.value !== n.value) {
					if (lu.isSet(p.value) && lu.isSet(n.value)) {
						var diff = lu.makeDiff(p.value, n.value);
						if (diff) {
							if (!ret) ret = Object.create(null);
							ret[n.key] = diff;
						}
					} else {
						if (!ret) ret = Object.create(null);
						ret[n.key] = n.value;
					}
				}
				p = pa.pop();
				n = na.pop();
			}
		}
		return ret ? ret : undefined;
	},

	concatString: function concatString(array) {
		var ret = "";
		!(function walk(array) {
			if (typeof array != "object") ret += array;else if (array.length != null) array.forEach(walk);else {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var s = _step2.value;

						walk(s);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		})(array);
		return ret;
	},

	sortedDiff: function sortedDiff(first, second) {
		var fi = first[Symbol.iterator]();
		var si = second[Symbol.iterator]();
		var ret = {
			common: [],
			first: [],
			second: [] };
		var fv = fi.next(),
		    sv = si.next();
		while (!fv.done || !sv.done) {
			if (sv.done || fv.value < sv.value) {
				ret.first.push(fv.value);
				fv = fi.next();
			} else if (fv.done || fv.value > sv.value) {
				ret.second.push(sv.value);
				sv = si.next();
			} else {
				ret.common.push(fv.value);
				fv = fi.next();
				sv = si.next();
			}
		}
		return ret;
	},

	measure: function measure(fun) {
		var now = global.performance || global.Date;
		var t = now.now();
		try {
			return fun();
		} finally {
			t = (now.now() - t) / 1000;
			if (t > 0) {
				var i = 1;
				while (t < 1000) {
					i *= 10;
					t *= 10;
				}
				t = Math.round(t) / i;
			}
			console.log(t);
		}
	},

	skip: regeneratorRuntime.mark(function skip(c, buf) {
		var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, b;

		return regeneratorRuntime.wrap(function skip$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion3 = true;
					_didIteratorError3 = false;
					_iteratorError3 = undefined;
					context$1$0.prev = 3;
					_iterator3 = buf[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
						context$1$0.next = 16;
						break;
					}

					b = _step3.value;

					if (!(c > 0)) {
						context$1$0.next = 11;
						break;
					}

					--c;
					context$1$0.next = 13;
					break;

				case 11:
					context$1$0.next = 13;
					return b;

				case 13:
					_iteratorNormalCompletion3 = true;
					context$1$0.next = 5;
					break;

				case 16:
					context$1$0.next = 22;
					break;

				case 18:
					context$1$0.prev = 18;
					context$1$0.t0 = context$1$0["catch"](3);
					_didIteratorError3 = true;
					_iteratorError3 = context$1$0.t0;

				case 22:
					context$1$0.prev = 22;
					context$1$0.prev = 23;

					if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
						_iterator3["return"]();
					}

				case 25:
					context$1$0.prev = 25;

					if (!_didIteratorError3) {
						context$1$0.next = 28;
						break;
					}

					throw _iteratorError3;

				case 28:
					return context$1$0.finish(25);

				case 29:
					return context$1$0.finish(22);

				case 30:
				case "end":
					return context$1$0.stop();
			}
		}, skip, this, [[3, 18, 22, 30], [23,, 25, 29]]);
	}),

	take: regeneratorRuntime.mark(function take(c, buf) {
		var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, b;

		return regeneratorRuntime.wrap(function take$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion4 = true;
					_didIteratorError4 = false;
					_iteratorError4 = undefined;
					context$1$0.prev = 3;
					_iterator4 = buf[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
						context$1$0.next = 17;
						break;
					}

					b = _step4.value;

					if (!(c > 0)) {
						context$1$0.next = 13;
						break;
					}

					--c;
					context$1$0.next = 11;
					return b;

				case 11:
					context$1$0.next = 14;
					break;

				case 13:
					return context$1$0.abrupt("break", 17);

				case 14:
					_iteratorNormalCompletion4 = true;
					context$1$0.next = 5;
					break;

				case 17:
					context$1$0.next = 23;
					break;

				case 19:
					context$1$0.prev = 19;
					context$1$0.t0 = context$1$0["catch"](3);
					_didIteratorError4 = true;
					_iteratorError4 = context$1$0.t0;

				case 23:
					context$1$0.prev = 23;
					context$1$0.prev = 24;

					if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
						_iterator4["return"]();
					}

				case 26:
					context$1$0.prev = 26;

					if (!_didIteratorError4) {
						context$1$0.next = 29;
						break;
					}

					throw _iteratorError4;

				case 29:
					return context$1$0.finish(26);

				case 30:
					return context$1$0.finish(23);

				case 31:
				case "end":
					return context$1$0.stop();
			}
		}, take, this, [[3, 19, 23, 31], [24,, 26, 30]]);
	}),

	copy: function copy(buf) {
		var ret = lu.array(buf);
		if (ret == buf) ret = buf.slice();
		return ret;
	},

	array1: function array1(value) {
		if (Array.isArray(value)) return value;else return [value];
	},

	array: function array(buf) {
		if (Array.isArray(buf)) return buf;
		var ret = [];
		if (!buf[Symbol.iterator]) for (var i = 0; i < buf.length; ++i) {
			ret.push(buf[i]);
		} else {
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = buf[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var b = _step5.value;

					ret.push(b);
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
						_iterator5["return"]();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}return ret;
	},

	buffer: function buffer(buf) {
		if (buf instanceof Buffer) return buf;else return new Buffer(lu.array(buf));
	},

	vector: function vector(buf) {
		return buf instanceof Buffer ? buf : lu.array(buf);
	},

	concat: regeneratorRuntime.mark(function concat(list) {
		var _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, l, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, x;

		return regeneratorRuntime.wrap(function concat$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion6 = true;
					_didIteratorError6 = false;
					_iteratorError6 = undefined;
					context$1$0.prev = 3;
					_iterator6 = list[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
						context$1$0.next = 36;
						break;
					}

					l = _step6.value;
					_iteratorNormalCompletion7 = true;
					_didIteratorError7 = false;
					_iteratorError7 = undefined;
					context$1$0.prev = 10;
					_iterator7 = l[Symbol.iterator]();

				case 12:
					if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
						context$1$0.next = 19;
						break;
					}

					x = _step7.value;
					context$1$0.next = 16;
					return x;

				case 16:
					_iteratorNormalCompletion7 = true;
					context$1$0.next = 12;
					break;

				case 19:
					context$1$0.next = 25;
					break;

				case 21:
					context$1$0.prev = 21;
					context$1$0.t0 = context$1$0["catch"](10);
					_didIteratorError7 = true;
					_iteratorError7 = context$1$0.t0;

				case 25:
					context$1$0.prev = 25;
					context$1$0.prev = 26;

					if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
						_iterator7["return"]();
					}

				case 28:
					context$1$0.prev = 28;

					if (!_didIteratorError7) {
						context$1$0.next = 31;
						break;
					}

					throw _iteratorError7;

				case 31:
					return context$1$0.finish(28);

				case 32:
					return context$1$0.finish(25);

				case 33:
					_iteratorNormalCompletion6 = true;
					context$1$0.next = 5;
					break;

				case 36:
					context$1$0.next = 42;
					break;

				case 38:
					context$1$0.prev = 38;
					context$1$0.t1 = context$1$0["catch"](3);
					_didIteratorError6 = true;
					_iteratorError6 = context$1$0.t1;

				case 42:
					context$1$0.prev = 42;
					context$1$0.prev = 43;

					if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
						_iterator6["return"]();
					}

				case 45:
					context$1$0.prev = 45;

					if (!_didIteratorError6) {
						context$1$0.next = 48;
						break;
					}

					throw _iteratorError6;

				case 48:
					return context$1$0.finish(45);

				case 49:
					return context$1$0.finish(42);

				case 50:
				case "end":
					return context$1$0.stop();
			}
		}, concat, this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
	}),

	word: function word(w) {
		return [w & 255, w >> 8 & 255];
	},

	dword: function dword(w) {
		return [w & 255, w >> 8 & 255, w >> 16 & 255, w >> 24 & 255];
	},

	makeWord: function makeWord(lo, hi) {
		return (lo & 255) + (hi & 255) << 8;
	},

	arrayEqual: function arrayEqual(a, b) {
		return a && b && a.length == b.length && a.every(function (ai, i) {
			return ai == b[i];
		});
	},

	compare: function compare(a, b) {
		if (a == b) return 0;
		if (a < b) return -1;
		return 1;
	},

	formatms: function formatms(value) {
		var ret = "";
		value = Math.round(value);
		var ms = value % 1000;
		value -= ms;
		value /= 1000;
		var s = value % 60;
		value -= s;
		value /= 60;
		var m = value % 60;
		value -= m;
		value /= 60;
		var h = value;
		ret += h ? h : "";
		ret += ret ? ":" + z(m, 2) : m ? m : "";
		ret += ret ? ":" + z(s, 2) : s;
		ret += "." + z(ms, 3);
		return ret;
		function z(value, len) {
			var str = String(value);
			var ret = "";
			for (var i = str.length; i < len; ++i) {
				ret += "0";
			}ret += str;
			return ret;
		}
	},

	get: function get(obj) {
		for (var _len4 = arguments.length, path = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
			path[_key4 - 1] = arguments[_key4];
		}

		var _iteratorNormalCompletion8 = true;
		var _didIteratorError8 = false;
		var _iteratorError8 = undefined;

		try {
			for (var _iterator8 = path[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
				var p = _step8.value;

				if (obj == null) break;else obj = obj[p];
			}
		} catch (err) {
			_didIteratorError8 = true;
			_iteratorError8 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion8 && _iterator8["return"]) {
					_iterator8["return"]();
				}
			} finally {
				if (_didIteratorError8) {
					throw _iteratorError8;
				}
			}
		}

		return obj;
	},

	limitCalls: function limitCalls(limit, period, message) {
		var calls = 0;
		return function () {
			if (calls >= limit) if (message) throw new Error.create(message);else return false;
			++calls;
			setTimeout(function () {
				return --calls;
			}, period);
			return true;
		};
	} };

function _copy(obj) {
	var ret = Object.create(null);
	for (var key in obj) {
		if (Object.prototype.hasOwnProperty.call(obj, key)) {
			var value = obj[key];
			if (value === undefined) continue;
			ret[key] = obj[key];
		}
	}return ret;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/localUtils.js","/src")

},{"_process":96,"buffer":91,"co":123,"events":95,"lodash":114}],133:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var deviceTypes = require("netro/deviceTypes");

var actions = {
	Up: function Up(device) {
		return 1;
	},
	Down: function Down(device) {
		return 0;
	},
	Comfort_1: function Comfort_1(device) {
		return device.comfort_1;
	},
	Comfort_2: function Comfort_2(device) {
		return device.comfort_2;
	},
	Stop: function Stop(device) {
		return null;
	},
	Loop: function Loop(device) {
		return device.state ? 0 : 1;
	},
	Script: function Script(device) {
		return null;
	},
	Link: function Link(device) {
		return null;
	},
	Set: function Set(_, data) {
		return data;
	} };

function getNewState(device, action, data) {
	// let type = deviceTypes[ device.model ]
	return device && Object.prototype.hasOwnProperty.call(actions, action) ? actions[action](device, data) : null;
}

exports.getNewState = getNewState;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/netro/deviceActions.js","/src/netro")

},{"_process":96,"buffer":91,"netro/deviceTypes":134}],134:[function(require,module,exports){
module.exports={
	"Nero II 8713-50": {
		"buttons": "RollShutter"
	},
	"Intro II 8513-50": {
		"buttons": "RollShutter"
	},
	"Nero II 8421": {
		"buttons": "Dimeer"
	}
}
},{}],135:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

Object.defineProperty(Object.prototype, "_LOG_", { value: function value() {
		console.log(this);
		return this;
	}, configurable: true });

if (typeof Symbol == "function" && Symbol.iterator) {
	var x = null;
	try {
		x = eval.call(null, "(function*(){}().constructor.prototype)");
	} catch (_) {}
	if (x && !x[Symbol.iterator]) x[Symbol.iterator] = function () {
		return this;
	};
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/platform.js","/src")

},{"_process":96,"buffer":91}],136:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

TODO:

* Warning if a live property has not been read during the life time of observable value or during some period of time (e.g. 1-30 minutes) since creating that observable value.

* check for changes during execution of (function*) and restart calculus.


TODO BUG:
let app = ra.clean( {
	moving1: {
		a: 1,
		b: 2,
		c: {
			d: 3,
		},
	},
}
_app.moving1.a
1
_app.moving1.c.d
3
_app.moving1={a:4}
Object {a: 4}
_app.moving1.c.d
3                       <----------- !!!  MUST BE NULL !!!!
_app.moving1.c
Cell {_id: "j87yqkoqppuv", _value: null, _error: null, _isValueEqual: function, _initialized: trueâ€¦}
_app.moving1.c.valueOf()
null


*/

"use strict";

var _get = function get(_x5, _x6, _x7) { var _again = true; _function: while (_again) { var object = _x5, property = _x6, receiver = _x7; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x5 = parent; _x6 = property; _x7 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var later = require("later").push;
var co = require("co");
var UID = require("uid");
var lodash = require("lodash");

var _require = require("LOG");

var LOG = _require.LOG;

var actionKey = "_RA_ACTION_" + UID();
var raValue = "_RA_VALUE_" + UID();

// let debugLog = false

var updates = {};
updates.scheduled = false;
updates.procs = [];
updates.index = 0;
updates.maxIndex = 32768;
updates.processing = false;
updates.totalTime = 0;
updates.maxTime = 0;
updates.maxTime1 = 0;
updates.minTime = Infinity;
updates.runCount = 0;
updates.runAllCount = 0;

global.updates = updates; // debugger

var performance = global.performance || global.Date;
updates.start = performance.now();

updates.log = function () {
	return console.log(":: " + updates.totalTime / 1000 + " / " + (performance.now() - updates.start) / 1000 + " (" + updates.maxTime / 1000 + ", " + updates.maxTime1 / 1000 + ", " + updates.minTime / 1000 + ", " + Action.maxCount + ", " + updates.runCount + ", " + updates.runAllCount + ")");
};

// co.go( function* () { // debugger
// 	let sleep5000 = co.sleep( 5000 )
// 	for (;;) {
// 		let totalTime = updates.totalTime
// 		yield sleep5000
// 		if ( totalTime != updates.totalTime )
// 			updates.log()
// 	}
// } )

updates.checkSchedule = function () {
	if (!updates.scheduled && updates.procs.length > 0) {
		updates.scheduled = true;
		later(updates.tick);
	}
};

updates.tick = function () {
	updates.scheduled = false;
	for (var _try = 0; _try < 1000; ++_try) {
		try {
			updates.runAll();
			break;
		} catch (error) {
			setTimeout(function () {
				throw error;
			}, 1);
		}
	}
	updates.checkSchedule();
};

updates.runAll = function () {
	// if ( updates.processing )
	// 	return

	var start = performance.now();
	var st1 = start;
	var runCount = updates.runCount;

	var processing = updates.processing;
	updates.processing = true;
	var action = co.global[actionKey];
	if (action != null) co.global[actionKey] = null;
	try {
		while (updates.index < updates.procs.length) {
			if (global.APP_TIMEOUT && global.APP_TIMEOUT < Date.now) {
				alert("Application is running too long");
			}
			var proc = updates.procs[updates.index];
			++updates.index;
			++updates.runCount;
			if (updates.index >= updates.maxIndex && updates.index * 3 > updates.procs.length) {
				updates.procs.splice(0, updates.index);
				updates.index = 0;
			}
			proc();
			var t1 = performance.now();
			if (updates.maxTime1 < t1 - st1) updates.maxTime1 = t1 - st1;
			// if ( t1 - st1 > 10 )
			// 	console.log( t1 - st1, `` + proc.$name ) // debugger
			st1 = t1;
		}
		updates.index = updates.procs.length = 0;
	} finally {
		if (action != null) co.global[actionKey] = action;
		updates.processing = processing;
		if (!processing) {
			var time = performance.now() - start;
			updates.totalTime += time;
			if (updates.maxTime < time) updates.maxTime = time;
			runCount = updates.runCount - runCount;
			if (runCount) {
				++updates.runAllCount;
				if (updates.minTime > time) updates.minTime = time;
			}
			if (time > 300) LOG("updates have been run for " + time.toString().red + " ms");
		}
	}
};

updates.later = function (proc) {
	updates.procs.push(proc);
	updates.checkSchedule();
};

updates.later.then = updates.later;

var emptyMap = typeof Immutable == "undefined" ? null : Immutable.Map();
var checkNull = function checkNull(value) {
	return value == null || value == emptyMap ? null : value;
};
var checkMap = function checkMap(value) {
	return value == null ? emptyMap : value;
};
var returnThis = function returnThis() {
	return this;
};

var isLiteral = function isLiteral(value) {
	return value && typeof value == "object" && value.constructor == Object;
};
var getValue = function getValue(value) {
	return value == null || value.valueOf == null ? value : value.valueOf();
};
var close = function close(value) {
	return value != null && value.close != null && value.close();
};

// let _m = obj => checkMap( obj.valueOf() )

function AbstractGuard() {}

var invalidKeyCall = function invalidKeyCall(key) {
	throw new Error("access to an undeclared property \"" + this.$name + "." + key + "\"");
};

var usedProps = Object.create(null);
var usedPropsProto = Object.create(null);
var guardProp = function guardProp(key) {
	if (!usedProps[key]) {
		usedProps[key] = true;
		Object.defineProperty(usedPropsProto, key, {
			get: function get() {
				invalidKeyCall.call(this, key);
			},
			set: function set() {
				invalidKeyCall.call(this, key);
			} });
	}
};
AbstractGuard.prototype = usedPropsProto;

// ÐÐµ Ð·Ñ€Ð°Ð·ÑƒÐ¼ÐµÐ»Ð° Ñ‚Ð¾Ð»ÐºÐ°Ð¼, ÑÐº Ð³ÑÑ‚Ñ‹ Proxy Ð¿Ñ€Ð°Ñ†ÑƒÐµ Ñž ÑÐºÐ°ÑÑŒÑ†Ñ– Ð¿Ñ€Ð°Ñ‚Ð°Ñ‚Ñ‹Ð¿Ñƒ.
// ÐŸÐ°ÐºÑƒÐ»ÑŒ ÑˆÑ‚Ð¾, Ð·Ð´Ð°ÐµÑ†Ñ†Ð°, Ð¿Ð°Ð²Ð¾Ð´Ð·Ñ–Ð½Ñ‹ Ð½Ðµ Ð°Ð´Ð¿Ð°Ð²ÑÐ´Ð°ÑŽÑ†ÑŒ ÑÑŒÐ¿ÐµÑ†Ñ‹Ñ„Ñ–ÐºÐ°Ñ†Ñ‹Ñ– (2014.11.25)

// if ( typeof Proxy == "function" ) {
// 	AbstractGuard.prototype = new Proxy( AbstractGuard.prototype, {
// 		get: function ( _, key ) { invalidKeyCall.call( this, key ) },
// 		set: function ( _, key ) { invalidKeyCall.call( this, key ) },
// 	} )
// }

if (global.APP_DEBUG) {
	//
	// Ð°Ð±'ÑÑžÐ»ÐµÐ½ÑŒÐ½Ðµ Ð°Ð±'ÐµÐºÑ‚Ð° Ð· ~700-800 ÑƒÐ»Ð°ÑÑŒÑ†Ñ–Ð²Ð°ÑÑŒÑ†ÑÑž Ð· Ñ„ÑƒÐ½ÐºÑ†Ñ‹ÑÐ¼Ñ– Ñ‡Ñ‹Ñ‚Ð°Ð½ÑŒÐ½Ñ/Ð·Ð°Ð¿Ñ–ÑÑƒ
	// Ð·Ð°Ð¹Ð¼Ð°Ðµ Ñž Google Chrome'Ðµ ÐºÐ°Ð»Ñ Ñ‚Ñ€Ð°Ñ†Ñ–Ð½Ñ‹ ÑÐµÐºÑƒÐ½Ð´Ñ‹.
	// ÐŸÑ€Ð°Ð²ÐµÑ€Ð°Ð½Ñ‹Ñ ÑÐ¿Ð¾ÑÐ°Ð±Ñ‹:
	// - Ð´Ð°Ð±Ð°ÑžÐ»ÐµÐ½ÑŒÐ½Ðµ Ð¿Ð° Ð°Ð´Ð½Ñ‹Ð¼ Ð¿Ñ€Ð°Ð· Object.defineProperty
	// - Ð´Ð°Ð±Ð°ÑžÐ»ÐµÐ½ÑŒÐ½Ðµ Ð³ÑƒÑ€Ñ‚Ð°Ð¼ Ð¿Ñ€Ð°Ð· Object.defineProperties
	// - ÐºÐ°Ð¼Ð¿Ñ–Ð»ÑÑ†Ñ‹Ñ Ð·Ñ‹Ñ…Ð¾Ð´Ð½Ñ–ÐºÐ° Ð¿Ñ€Ð°Ð· Ð»Ð°ÐºÐ°Ð»ÑŒÐ½Ñ‹ eval
	// - ÐºÐ°Ð¼Ð¿Ñ–Ð»ÑÑ†Ñ‹Ñ Ð·Ñ‹Ñ…Ð¾Ð´Ð½Ñ–ÐºÐ° Ð¿Ñ€Ð°Ð· Ð³Ð»Ð°Ð±Ð°Ð»ÑŒÐ½Ñ‹ eval
	// - ÐºÐ°Ð¼Ð¿Ñ–Ð»ÑÑ†Ñ‹Ñ Ð·Ñ‹Ñ…Ð¾Ð´Ð½Ñ–ÐºÐ° Ð¿Ñ€Ð°Ð· Ð´Ð°Ð±Ð°ÑžÐ»ÐµÐ½ÑŒÐ½Ðµ Ñ‚ÑÐ³Ñƒ script Ð· Ð·Ñ‹Ñ…Ð¾Ð´Ð½Ñ–ÐºÐ°Ð¼
	// ÐÐµ Ð¿Ñ€Ð°Ð²ÐµÑ€Ð°Ð½Ñ‹Ñ ÑÐ¿Ð¾ÑÐ°Ð±Ñ‹:
	// - Ð´Ð°Ð±Ð°ÑžÐ»ÐµÐ½ÑŒÐ½Ðµ Ñ‚ÑÐ³Ñƒ script Ð· Ð¿Ð°Ð·Ð½Ð°ÐºÐ°Ð¹ src
	// ÐŸÐ°Ð»ÑÐ¿ÑˆÐ°Ðµ ÑÑ–Ñ‚ÑƒÐ°Ñ†Ñ‹ÑŽ (Ð½Ð°Ð¿Ð°Ð»Ð¾Ð²Ñƒ):
	// - ÑÑ‚Ð²Ð°Ñ€ÑÐ½ÑŒÐ½Ðµ Ð´Ð»Ñ ÐºÐ¾Ð¶Ð½Ð°Ð¹ ÑƒÐ»Ð°ÑÑŒÑ†Ñ–Ð²Ð°ÑÑŒÑ†Ñ– Ð½Ð¾Ð²Ð°Ð³Ð° Ð°Ð±'ÐµÐºÑ‚Ð° ÑÐ° ÑÑ‚Ð°Ñ€Ñ‹Ð¼ Ð°Ð±'ÐµÐºÑ‚Ð°Ð¼
	// Ñƒ ÑÐºÐ°ÑÑŒÑ†Ñ– Ð¿Ñ€Ð°Ñ‚Ð°Ñ‚Ñ‹Ð¿Ñƒ. ÐŸÑ€Ñ‹ Ð³ÑÑ‚Ñ‹Ð¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ð´Ð° Ð½ÐµÐ°Ð±'ÑÑžÐ»ÐµÐ½Ñ‹Ñ… ÑƒÐ»Ð°ÑÑŒÑ†Ñ–Ð²Ð°ÑÑŒÑ†ÑÑž Ð¼Ð¾Ð¶Ð°
	// ÑÑ‚Ð°Ñ†ÑŒ Ð°Ð´Ð½Ð¾ÑÐ½Ð° Ð´Ð¾ÑžÐ³Ñ–Ð¼ Ð¿Ð° Ñ‡Ð°ÑÐµ, Ð°Ð»Ðµ Ð¶ Ð³ÑÑ‚Ð° Ð½Ñ Ñ‚Ð°Ðº Ð²Ð°Ð¶Ð½Ð°, Ð±Ð¾ Ñž Ð²Ñ‹Ð½Ñ–ÐºÑƒ ÑžÑÑ‘ Ð°Ð´Ð½Ð¾
	// ÐºÑ–Ð´Ð°ÐµÑ†Ñ†Ð° Ð¿Ð°Ð¼Ñ‹Ð»ÐºÐ°.
	//
	// Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ñ‹Ñ Ñ‚ÑÐºÑÑ‚Ñƒ Ð·Ñ‹Ñ…Ð¾Ð´Ð½Ñ–ÐºÐ° Ð°Ð´Ð±Ñ‹Ð²Ð°ÐµÑ†Ñ†Ð° Ñ–Ð¼Ð³Ð½ÐµÐ½Ð½Ð°.
	//
	// Ð—Ñ‹Ñ…Ð¾Ð´Ð·ÑÑ‡Ñ‹ Ð· Ð³ÑÑ‚Ð°Ð³Ð° ÑƒÐ»ÑƒÑ‡Ð°Ñ†ÑŒ ÑÑ‚Ñ€Ð°Ð¶Ð½Ñ–ÐºÐ°Ñž Ð´Ð¾ÑÑ‚ÑƒÐ¿Ñƒ Ð´Ð° Ð½ÐµÐ°Ð±'ÑÑžÐ»ÐµÐ½Ñ‹Ñ… ÑƒÐ»Ð°ÑÑŒÑ†Ñ–Ð²Ð°ÑÑŒÑ†ÑÑž
	// Ñ‚Ñ€ÑÐ±Ð° Ñ‚Ð¾Ð»ÑŒÐºÑ– Ð¿Ñ€Ñ‹ Ð°Ð´Ð»Ð°Ð´Ñ†Ñ‹.
	//
	AbstractGuard.prototype = (global.__UsedScriptIdentifiers__ + "").split(/[\s,]+/).reduce(function (proto, key) {
		return Object.create(proto, _defineProperty({}, key, {
			get: function get() {
				invalidKeyCall.call(this, key);
			},
			set: function set(_) {
				invalidKeyCall.call(this, key);
			} }));
	}, AbstractGuard.prototype);
}

AbstractGuard.prototype = Object.create(AbstractGuard.prototype, {
	toString: { value: ({}).toString },
	valueOf: { value: ({}).valueOf },
	toLocaleString: { value: ({}).toLocaleString },
	hasOwnProperty: { value: ({}).hasOwnProperty },
	isPrototypeOf: { value: ({}).isPrototypeOf },
	propertyIsEnumerable: { value: ({}).propertyIsEnumerable },
	$name: { value: "<...>", writable: 1 } });

var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);

var ImmutableInterface = (function (_AbstractGuard) {
	function ImmutableInterface() {
		_classCallCheck(this, ImmutableInterface);

		if (_AbstractGuard != null) {
			_AbstractGuard.apply(this, arguments);
		}
	}

	_inherits(ImmutableInterface, _AbstractGuard);

	_createClass(ImmutableInterface, [{
		key: "props",

		// debugger
		get: function () {
			throw new Error("access to deprecated 'props' property detected");
		}
	}, {
		key: "declaredProperties",
		get: function () {
			return this.live;
		}
	}, {
		key: "length",
		get: function () {
			var m = this.valueOf();return m == null ? 0 : Object.keys(m).length;
		}
	}, {
		key: "get",
		value: function get(key) {
			if (key != null) {
				var m = this.valueOf();
				if (m != null && Object.prototype.hasOwnProperty.call(m, key)) return m[key];
			}
			return null;
		}
	}, {
		key: "map",
		value: function map(fun) {
			var m = this.valueOf();
			return m && (Array.isArray(m) ? lodash.map(m, fun) : lodash.mapValues(m, fun));
		}
	}, {
		key: "keys",
		value: function keys() {
			var m = this.valueOf();
			return m == null ? EMPTY_ARRAY : Object.keys(m);
		}

		// clear() { let m = _m( this ); return m.clear.apply( m, arguments ) }
		// entries() { let m = _m( this ); return m.entries.apply( m, arguments ) }
		// get() { let m = _m( this ); return m.get.apply( m, arguments ) }
		// keys() { let m = _m( this ); return m.keys.apply( m, arguments ) }
		// last() { let m = _m( this ); return m.last.apply( m, arguments ) }
		// map() { let m = _m( this ); return m.map.apply( m, arguments ) }
		// merge() { let m = _m( this ); return m.merge.apply( m, arguments ) }
		// mergeDeep() { let m = _m( this ); return m.mergeDeep.apply( m, arguments ) }
		// mergeDeepWith() { let m = _m( this ); return m.mergeDeepWith.apply( m, arguments ) }
		// mergeWith() { let m = _m( this ); return m.mergeWith.apply( m, arguments ) }
		// remove() { let m = _m( this ); return m.remove.apply( m, arguments ) }
		// set() { let m = _m( this ); return m.set.apply( m, arguments ) }
		// update() { let m = _m( this ); return m.update.apply( m, arguments ) }
		// updateIn() { let m = _m( this ); return m.updateIn.apply( m, arguments ) }
		// values() { let m = _m( this ); return m.values.apply( m, arguments ) }
		// withMutations() { let m = _m( this ); return m.withMutations.apply( m, arguments ) }
		// toJS() { let m = _m( this ); return m.toJS() }

	}]);

	return ImmutableInterface;
})(AbstractGuard);

var ReadOnlyCell = (function (_ImmutableInterface) {
	function ReadOnlyCell(parent) {
		_classCallCheck(this, ReadOnlyCell);

		_get(Object.getPrototypeOf(ReadOnlyCell.prototype), "constructor", this).call(this);
		this._parent = parent;
	}

	_inherits(ReadOnlyCell, _ImmutableInterface);

	_createClass(ReadOnlyCell, [{
		key: "getReadOnly",
		value: function getReadOnly() {
			return this;
		}
	}, {
		key: "live",
		get: function () {
			return this._parent.live;
		}
	}, {
		key: "$name",
		get: function () {
			return this._parent.$name;
		}
	}, {
		key: "valueOf",
		value: function valueOf() {
			return this._parent.valueOf.apply(this._parent, arguments);
		}
	}, {
		key: "noTouch",
		value: function noTouch() {
			return this._parent.noTouch.apply(this._parent, arguments);
		}
	}, {
		key: "toString",
		value: function toString() {
			return this._parent.toString.apply(this._parent, arguments);
		}
	}, {
		key: "toJSON",
		value: function toJSON() {
			return this._parent.toJSON.apply(this._parent, arguments);
		}
	}, {
		key: "getName",
		value: function getName() {
			return this._parent.getName.apply(this._parent, arguments);
		}
	}]);

	return ReadOnlyCell;
})(ImmutableInterface);

var Getter = function Getter(fun, isValueEqual) {
	var last = undefined;
	var ret = !isValueEqual ? function () {
		return fun.apply(this, arguments);
	} : function () {
		var ret = fun.apply(this, arguments);
		if (!is(last, ret, isValueEqual)) last = ret;
		return last;
	};
	ret.isGetter = true;
	return ret;
};

var Type = function Type(f) {
	g.typeDescriptor = true;
	return g;
	function g() {
		return f.apply(this, arguments);
	}
};

var runGetter = function runGetter(cell, getter, sticky) {
	return new Action(getter, cell, sticky).linkName(cell, ":getter");
};

var runSetter = function runSetter(cell, setter, sticky) {
	return new Action(function () {
		return setter(cell.valueOf());
	}, null, sticky).linkName(cell, ":setter");
};

function is(a, b, isEqual) {
	return Object.is(a, b) || b && typeof b.isEqualTo == "function" && b.isEqualTo(a) || a && typeof a.isEqualTo == "function" && a.isEqualTo(b) || typeof isEqual == "function" && isEqual(a, b);
}

var This = (function () {
	function This() {
		_classCallCheck(this, This);
	}

	_createClass(This, [{
		key: "_defineThatProperty",
		value: function _defineThatProperty(key, that) {
			Object.defineProperty(this, key, {
				configurable: true,
				enumerable: true,
				get: function get() {
					return that[key];
				},
				set: function set(value) {
					that[key] = value;
				} });
		}
	}], [{
		key: "create",
		value: function create(parent, that) {
			var ret = null;
			if (!parent) ret = new This();else ret = Object.create(parent);
			ret.valueOf = function () {
				return that.valueOf();
			};
			ret.toString = function () {
				return that.toString();
			};
			ret.toJSON = function () {
				return that.toJSON();
			};
			ret.assign = function (value) {
				return that.assign(value);
			};
			ret["throw"] = function (value) {
				return that["throw"](value);
			};
			Object.defineProperty(ret, "live", { get: function get() {
					return that.live;
				} });
			return ret;
		}
	}]);

	return This;
})();

var Cell = (function (_ImmutableInterface2) {
	function Cell(sticky) {
		var _this = this;

		_classCallCheck(this, Cell);

		_get(Object.getPrototypeOf(Cell.prototype), "constructor", this).call(this);
		this._id = UID();
		this._that = null;
		this._value = null;
		this._error = null;
		this._isValueEqual = is;
		this._initialized = false;
		this._frozen = false;
		this._closed = false;
		this._dirty = false;
		this._live = null;
		this._liveArray = null;
		this._actionsArr = [];
		this._parent = null;
		this._onchange = [];
		this.$name = { toString: function toString() {
				return _this.getName();
			} };
		this._notifyWritten();
		this._sticky = !!sticky;
	}

	_inherits(Cell, _ImmutableInterface2);

	_createClass(Cell, [{
		key: "valueOf",
		value: function valueOf() {
			return this._read();
		}
	}, {
		key: "assign",
		value: function assign(value) {
			return this._write(value, false, null);
		}
	}, {
		key: "update",
		value: function update(diff) {
			return this.assign(lu.applyDiff(this.noTouch(), diff));
		}
	}, {
		key: "throw",
		value: function _throw(value) {
			return this._write(null, false, value);
		}
	}, {
		key: "touch",
		value: function touch() {
			this._fire();
		}
	}, {
		key: "noTouch",
		value: function noTouch() {
			if (this._dirty) this._updateSelf();
			if (this._error) throw this._error;
			return this._value;
		}
	}, {
		key: "then",
		value: function then(proc) {
			this._onchange.push(proc);
		}
	}, {
		key: "close",
		value: function close() {
			if (this._closed) return;
			this._closed = true;
			this._fire();
			if (this._parent) this._parent.close();
			if (this._liveArray) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this._liveArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var p = _step.value;

						p.close();
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator["return"]) {
							_iterator["return"]();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				this._liveArray = null;
			}
			this._value = null;
			this._error = null;
			this._actionsArr = null;
			this._parent = null;
		}
	}, {
		key: "freeze",
		value: function freeze() {
			if (this._closed || this._frozen) return;
			this._frozen = true;
			this._fire(); // TODO Ð´Ð»Ñ Ð²Ñ‹Ð´Ð°Ð»ÐµÐ½ÑŒÐ½Ñ ÑÐ¿Ð°ÑÑ‹Ð»Ð°Ðº Ð°Ð±Ñ‹ÑÑŒÑ†Ñ–ÑÑ Ð±ÐµÐ· _fire Ñ– Ð°Ð´Ð¿Ð°Ð²ÐµÐ´Ð½Ð° Ð±ÐµÐ· Ð»Ñ–ÑˆÐ½ÑÐ³Ð° Ð¿Ñ€Ð°Ð³Ð¾Ð½Ñƒ
			if (this._parent) this._parent.freeze();
			if (this._liveArray) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = this._liveArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var p = _step2.value;

						p.freeze();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		}
	}, {
		key: "live",
		get: function () {
			return this._live;
		}
	}, {
		key: "getReadOnly",
		value: function getReadOnly() {
			return this._readOnly || (this._readOnly = new ReadOnlyCell(this));
		}
	}, {
		key: "toString",
		value: function toString() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			var v = this._read();
			return v == null || !v.toString ? "" + v : v.toString.apply(v, args);
		}
	}, {
		key: "toJSON",
		value: function toJSON() {
			for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}

			var v = this._read();
			return v == null || !v.toJSON ? v : v.toJSON.apply(v, args);
		}
	}, {
		key: "with",
		value: function _with(cb) {
			return cb.call(this._getThat());
		}
	}, {
		key: "setName",
		value: function setName(name) {
			this._name = name;
			return this;
		}
	}, {
		key: "getName",
		value: function getName() {
			var ret = this._name || this._key;
			var p = this._parent;
			while (p) {
				ret = (p._name || p._key) + "." + ret;
				p = p._parent;
			}
			return ret;
		}
	}, {
		key: "_getThat",
		value: function _getThat() {
			if (!this._that) {
				this._that = This.create(this._parent && this._parent._getThat(), this);
				if (this._live) for (var i in this._live) {
					this._that._defineThatProperty(i, this);
				}
			}
			return this._that;
		}
	}, {
		key: "defineProperty",
		value: function defineProperty(key) {
			var inheritParent = arguments[1] === undefined ? false : arguments[1];

			// pass key == `` to make Cell object, not value
			if (!this._live) {
				this._live = Object.create(null);
				this._liveArray = [];
			}
			if (!key) return;
			guardProp(key);
			var c = this._live[key];
			if (c) return c;
			c = new Cell(this._sticky);
			this._live[key] = c;
			this._liveArray.push(c);
			c._key = key;
			c._parent = this;
			c._level = (this._level || 0) + 1;
			Object.defineProperty(this, key, {
				enumerable: true,
				configurable: true,
				get: function get() {
					if (c._live) return c;else return c._read();
				},
				set: function set(value) {
					if (c._live) value = getValue(value);
					c._write(value, false);
				} });
			if (this._that) this._that._defineThatProperty(key, this);
			if (this._value != null) c._write(this._value[key], true);
			return c;
		}
	}, {
		key: "init",
		value: function init(value) {
			this._init(value, false, false);
		}
	}, {
		key: "setConst",
		value: function setConst(prop, value) {
			Object.defineProperty(this, prop, { enumerable: true, get: function get() {
					return value;
				} });
			return this;
		}
	}, {
		key: "setVar",
		value: function setVar(prop, value) {
			Object.defineProperty(this, prop, { enumerable: true, writable: true, value: value });
			return this;
		}
	}, {
		key: raValue,
		get: function () {
			return true;
		}
	}, {
		key: "_init",
		value: function _init(value, recursive, isGetter, isValueEqual) {
			var cell = this;
			if (!recursive && cell._initialized) throw new Error("already initialized");
			if (this._parent) this._parent._dirty = true;
			cell._initialized = true;
			if (isValueEqual) this._isValueEqual = isValueEqual;
			value = checkNull(value);
			if (typeof value == "function" && value.typeDescriptor) value = value(cell._key);
			if (value == null) // we are already null at the point of birth
				return;
			if (value[raValue]) // force just a value
				return cell._value = value;
			if (typeof value == "function") {
				if (isGetter || value.isGetter) // getter
					runGetter(cell, function () {
						return value.call(cell._parent && cell._parent._getThat());
					}, this._sticky);else // method
					cell._value = function () {
						return value.apply(cell._parent && cell._parent._getThat(), arguments);
					};
				return;
			}
			if (!isLiteral(value)) // just a value
				return cell._value = value;
			// subrecord description
			if (recursive) throw new Error("wrong parameters");
			cell.defineProperty();
			for (var key in value) {
				var descr = Object.getOwnPropertyDescriptor(value, key);
				if (!descr) continue;
				var get = descr.get;
				var subValue = descr.value;
				if (descr.set) throw new Error("wrong parameters");else if (get) subValue = get;
				if (key == "$") cell._init(subValue, true, !!get);else cell.defineProperty(key, true)._init(subValue, false, !!get);
			}
		}
	}, {
		key: "_read",
		value: function _read() {
			if (this._dirty) this._updateSelf();
			var action = co.global[actionKey];
			if (action) {
				if (this._closed) action.close();else if (!this._frozen) action.onread(this);
			}
			if (this._error) throw this._error;
			return this._value;
		}
	}, {
		key: "_write",
		value: function _write(newValue, down, newError) {
			if (newError == null) newError = null;
			if (this._frozen) throw new Error("Try to change a frozen value");
			this._initialized = true;
			this._dirty = false;
			newValue = checkNull(newValue);
			if (this._closed) {
				var action = co.global[actionKey];
				if (action) action.close();
			} else if (!this._isValueEqual(this._value, newValue) || this._error != newError) {
				// console.log(`>`+this.$name)//debugger
				this._value = newValue;
				this._error = newError;
				if (this._live) {
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = this._liveArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var p = _step3.value;

							p._write(newValue && newValue[p._key], true);
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
								_iterator3["return"]();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}this._fire();
				if (!down) {
					var p = this._parent;
					while (p && !p._dirty) {
						p._dirty = true;
						p._fire();
						p = p._parent;
					}
				}
			}
			if (!down) this._notifyWritten();
			return newValue;
		}
	}, {
		key: "_updateSelf",
		value: function _updateSelf() {
			var cnt = 0;
			var ret = {};
			for (var key in this._value) {
				if (Object.prototype.hasOwnProperty.call(this._value, key)) {
					ret[key] = this._value[key];
					++cnt;
				}
			}var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = this._liveArray[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var p = _step4.value;

					if (p._dirty) p._updateSelf();
					if (p._error) {
						this._error = p._error;
						this._value = null;
						this._dirty = false;
						return;
					}
					var value = p._value;
					if (value == null) {
						if (Object.prototype.hasOwnProperty.call(ret, p._key)) {
							delete ret[p._key];
							--cnt;
						}
					} else {
						ret[p._key] = value;
						cnt = Infinity;
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
						_iterator4["return"]();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			if (cnt == 0) ret = null;

			this._value = ret;
			this._dirty = false;
		}
	}, {
		key: "debug",
		value: function debug(cb) {
			this._actionsArr.push({ action: { _fire: cb } });
		}
	}, {
		key: "debugger",
		value: function _debugger() {
			this.debug(function () {
				debugger;
			});
		}
	}, {
		key: "_fire",
		value: function _fire() {
			var a = undefined;
			a = this._actionsArr;
			if (a.length) {
				for (var i = 0; i < a.length; i++) {
					var c = a[i];
					if (c.action) c.action._fire();
					c.pushedC = false;
				}
				a.length = 0;
			}
			a = this._onchange;
			if (a.length) {
				for (var i = 0; i < a.length; i++) {
					updates.later(a[i]);
				}a.length = 0;
			}
		}
	}, {
		key: "_notifyWritten",
		value: function _notifyWritten() {
			var action = co.global[actionKey];
			if (action) action.onwritten(this);
		}
	}]);

	return Cell;
})(ImmutableInterface);

var rethrow = function rethrow(error) {
	return setTimeout(function () {
		throw error;
	}, 1);
};

var Action = (function () {
	function Action(fun, dest, sticky) {
		var _this2 = this;

		_classCallCheck(this, Action);

		this._id = UID();
		this._fun = fun;
		this._dest = dest;
		this._cellSet = {};
		this._cellSetSize = 0;
		this._cellArr = [];
		this.$name = { toString: function toString() {
				return "<Action>";
			} };
		this._thread = co.gocall(this._loop, this).linkName(this).waitForInput();
		this._runCount = 0;
		var owner = undefined;
		if ((owner = co.global[actionKey]) && owner._children) owner._children.push(this);
		this._children = null;
		this._threads = null;
		this._onthread = null;
		this._generatorProxy = null;
		this._generator = null;
		if (sticky) {
			this._children = [];
			this._threads = [];
			this._onthread = function (thread) {
				return _this2._threads.push(thread);
			};
		}
	}

	_createClass(Action, [{
		key: "linkName",
		value: function linkName(value) {
			var suffix = arguments[1] === undefined ? ":action" : arguments[1];

			if (value.$name) value = value.$name;
			this.$name.toString = function () {
				return "" + value + suffix;
			};
			return this;
		}
	}, {
		key: "_initGeneratorProxy",
		value: function _initGeneratorProxy() {
			var _generatorProxy,
			    _this3 = this;

			var _value = undefined;
			var _next = function _next() {
				return _this3._generator.next(_value);
			};
			var _throw2 = function _throw2() {
				return _this3._generator["throw"](_value);
			};
			var _return2 = function _return2() {
				return _this3._generator["return"](_value);
			};
			this._generatorProxy = (_generatorProxy = {}, _defineProperty(_generatorProxy, Symbol.iterator, returnThis), _defineProperty(_generatorProxy, "next", function next(v) {
				_value = v;
				try {
					return co.catchThreads(_next, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _defineProperty(_generatorProxy, "throw", function _throw(v) {
				_value = v;
				try {
					return co.catchThreads(_throw2, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _defineProperty(_generatorProxy, "return", function _return(v) {
				_value = v;
				try {
					return co.catchThreads(_return2, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _generatorProxy);
		}
	}, {
		key: "_loop",
		value: regeneratorRuntime.mark(function _loop() {
			var next, errorCatched, ret;
			return regeneratorRuntime.wrap(function _loop$(context$2$0) {
				var _this4 = this;

				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						context$2$0.next = 2;
						return updates.later;

					case 2:
						next = { then: function then(next) {
								_this4._onchange = next;
							} };

						co.global[actionKey] = this;
						errorCatched = false;

					case 5:
						context$2$0.prev = 5;

					case 6:
						if (errorCatched) {
							context$2$0.next = 50;
							break;
						}

						if (!this.isClosed()) {
							context$2$0.next = 9;
							break;
						}

						return context$2$0.abrupt("break", 68);

					case 9:
						this._begin();
						errorCatched = true;
						ret = undefined;

						if (!this._children) {
							context$2$0.next = 35;
							break;
						}

						ret = co.catchThreads(this._fun, this._onthread);

						if (!(!ret || ret[raValue])) {
							context$2$0.next = 18;
							break;
						}

						null;
						context$2$0.next = 33;
						break;

					case 18:
						if (!(ret.next && ret["throw"])) {
							context$2$0.next = 29;
							break;
						}

						if (!this._generatorProxy) this._initGeneratorProxy();
						this._generator = ret;
						context$2$0.prev = 21;
						return context$2$0.delegateYield(this._generatorProxy, "t0", 23);

					case 23:
						ret = context$2$0.t0;

					case 24:
						context$2$0.prev = 24;
						this._generator = null;return context$2$0.finish(24);

					case 27:
						context$2$0.next = 33;
						break;

					case 29:
						if (!ret.then) {
							context$2$0.next = 33;
							break;
						}

						context$2$0.next = 32;
						return ret;

					case 32:
						ret = context$2$0.sent;

					case 33:
						context$2$0.next = 49;
						break;

					case 35:
						ret = (0, this._fun)();

						if (!(!ret || ret[raValue])) {
							context$2$0.next = 40;
							break;
						}

						null;
						context$2$0.next = 49;
						break;

					case 40:
						if (!(ret.next && ret["throw"])) {
							context$2$0.next = 45;
							break;
						}

						return context$2$0.delegateYield(ret, "t1", 42);

					case 42:
						ret = context$2$0.t1;
						context$2$0.next = 49;
						break;

					case 45:
						if (!ret.then) {
							context$2$0.next = 49;
							break;
						}

						context$2$0.next = 48;
						return ret;

					case 48:
						ret = context$2$0.sent;

					case 49:
						if (this._dest) this._dest.assign(ret);

					case 50:
						errorCatched = false;

						if (!this.isClosed()) {
							context$2$0.next = 53;
							break;
						}

						return context$2$0.abrupt("break", 68);

					case 53:
						context$2$0.t2 = this._end();
						context$2$0.next = context$2$0.t2 === false ? 56 : context$2$0.t2 === true ? 57 : 59;
						break;

					case 56:
						return context$2$0.abrupt("break", 68);

					case 57:
						context$2$0.next = 59;
						return next
						// case null:
						/* immediate recalculation */
						;

					case 59:
						context$2$0.next = 6;
						break;

					case 61:
						context$2$0.next = 66;
						break;

					case 63:
						context$2$0.prev = 63;
						context$2$0.t3 = context$2$0["catch"](5);

						if (errorCatched) this._dest["throw"](context$2$0.t3);else rethrow(context$2$0.t3);

					case 66:
						context$2$0.next = 5;
						break;

					case 68:
						co.global[actionKey] = null;
						this._finalize();

					case 70:
					case "end":
						return context$2$0.stop();
				}
			}, _loop, this, [[5, 63], [21,, 24, 27]]);
		})
	}, {
		key: "isClosed",
		value: function isClosed() {
			return !this._cellSet;
		}
	}, {
		key: "close",
		value: function close() {
			var thread = this._thread;
			this._fire();
			this._finalize();
			thread && thread.kill();
		}
	}, {
		key: "_closeChildren",
		value: function _closeChildren() {
			var c = undefined;
			if (c = this._children) {
				for (var i = 0, l = c.length; i < l; ++i) {
					c[i].close();
				}c.length = 0;
			}
			if (c = this._threads) {
				for (var i = 0, l = c.length; i < l; ++i) {
					c[i].kill();
				}c.length = 0;
			}
		}
	}, {
		key: "_finalize",
		value: function _finalize() {
			this._unsubscribe();
			this._cellSet = null;
			this._cellArr = null;
			this._fun = null;
			this._dest = null;
			this._thread = null;
		}
	}, {
		key: "_begin",
		value: function _begin() {
			this._unsubscribe();
			++this._runCount;
			if (Action.maxCount < this._runCount) {
				Action.maxCount = this._runCount;
			}
		}
	}, {
		key: "_unsubscribe",
		value: function _unsubscribe() {
			this._onchange = null;
			var a = this._cellArr;
			if (a) {
				for (var i = 0; i < a.length; ++i) {
					var c = a[i];
					c.cell = null;
					c.value = null;
					c.action = null;
					c.read = false;
					c.written = false;
					c.pushedA = false
					// do not change c.pushedC here!!
					;
				}
				if (this._cellSetSize > 32 && a.length < this._cellSetSize / 4) {
					this._cellSet = {};
					this._cellSetSize = 0;
				}
				a.length = 0;
			}
			this._closeChildren();
		}
	}, {
		key: "_end",
		value: function _end() {
			var ret = false;
			var a = this._cellArr;
			for (var i = 0; i < a.length; ++i) {
				var c = a[i];
				if (c.written) c.action = null;else {
					if (!c.pushedC) {
						c.cell._actionsArr.push(c);
						c.pushedC = true;
					}
					if (!is(c.value, c.cell._value) || c.error != c.cell._error) return null;
					c.action = this;
					ret = true;
				}
				c.value = null;
				c.cell = null;
			}
			return ret;
		}
	}, {
		key: "_linkCell",
		value: function _linkCell(cell) {
			var c = this._cellSet[cell._id];
			if (c == null) {
				c = this._cellSet[cell._id] = {
					cell: null,
					value: null,
					error: null,
					action: null,
					read: false,
					written: false,
					pushedA: false,
					pushedC: false };
				++this._cellSetSize;
			}
			if (!c.pushedA) {
				this._cellArr.push(c);
				c.cell = cell;
				c.pushedA = true;
			}
			return c;
		}
	}, {
		key: "onread",
		value: function onread(cell) {
			var c = this._linkCell(cell);
			c.read = true;
			c.value = cell._value;
			c.error = cell._error;
		}
	}, {
		key: "onwritten",
		value: function onwritten(cell) {
			this._linkCell(cell).written = true;
		}
	}, {
		key: "_fire",
		value: function _fire() {
			if (this._onchange) updates.later(this._onchange);
			this._unsubscribe();
		}
	}]);

	return Action;
})();

Action.maxCount = 0;

var newReactive = function newReactive(getter, handlers, sticky, isValueEqual) {
	var _iteratorNormalCompletion5 = true;
	var _didIteratorError5 = false;
	var _iteratorError5 = undefined;

	try {
		for (var _iterator5 = handlers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
			var h = _step5.value;

			if (h != null && typeof h != "function") throw new Error("wrong parameters");
		}
	} catch (err) {
		_didIteratorError5 = true;
		_iteratorError5 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
				_iterator5["return"]();
			}
		} finally {
			if (_didIteratorError5) {
				throw _iteratorError5;
			}
		}
	}

	var cell = new Cell(sticky);
	if (getter !== undefined) cell._init(getter, false, true, isValueEqual);
	var _iteratorNormalCompletion6 = true;
	var _didIteratorError6 = false;
	var _iteratorError6 = undefined;

	try {
		for (var _iterator6 = handlers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
			var h = _step6.value;

			h && (h.length ? runSetter : runGetter)(cell, h, sticky);
		}
	} catch (err) {
		_didIteratorError6 = true;
		_iteratorError6 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
				_iterator6["return"]();
			}
		} finally {
			if (_didIteratorError6) {
				throw _iteratorError6;
			}
		}
	}

	return cell;
};

var ra = function ra() {
	var name = undefined,
	    fun = undefined,
	    sticky = undefined,
	    isValueEqual = undefined,
	    index = 0,
	    length = arguments.length - 1;
	if (typeof arguments[index] == "string") name = arguments[index++];
	if (typeof arguments[index] == "boolean") sticky = arguments[index++];
	fun = arguments[index++];
	if (typeof arguments[index] == "function") isValueEqual = arguments[index++];
	return newReactive(fun, [], sticky, isValueEqual);
};

function ArrayIsEqualTo(a) {
	return this == a || Array.isArray(a) && this.length == a.length && this.every(function (e, i) {
		return is(e, a[i]);
	});
}

function JsonIsEqualTo(a) {
	return this == a || JSON.stringify(this) == JSON.stringify(a);
}

exports = module.exports = ra;

exports.ra = ra;

exports.is = is;

exports.Array = function (array) {
	array.isEqualTo = ArrayIsEqualTo;
	return array;
};

exports.JSON = function (obj) {
	obj.isEqualTo = JsonIsEqualTo;
	return obj;
};

exports.Value = function (obj) {
	obj && obj.defineProperty(raValue, { value: true, configurable: true, enumerable: false, writable: false });
	return obj;
};

exports.clean = function (getter) {
	for (var _len3 = arguments.length, handers = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		handers[_key3 - 1] = arguments[_key3];
	}

	return newReactive(getter, handers, false);
};

exports.detach = function (fun) {
	var old = undefined;
	if (old = co.global[actionKey]) {
		co.global[actionKey] = null;
		try {
			return fun();
		} finally {
			co.global[actionKey] = old;
		}
	} else return fun();
};

exports.detached = function (fun) {
	return function () {
		var old = undefined;
		if (old = co.global[actionKey]) {
			co.global[actionKey] = null;
			try {
				return fun.apply(this, arguments);
			} finally {
				co.global[actionKey] = old;
			}
		} else return fun.apply(this, arguments);
	};
};

exports.on = function (emitter, event, getter) {
	var ret = ra();
	var handler = function handler(data) {
		return ret.assign(getter(data));
	};
	if (event == "string") emitter.on(event, handler);else {
		var _iteratorNormalCompletion7 = true;
		var _didIteratorError7 = false;
		var _iteratorError7 = undefined;

		try {
			for (var _iterator7 = event[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
				var e = _step7.value;

				emitter.on(e, handler);
			}
		} catch (err) {
			_didIteratorError7 = true;
			_iteratorError7 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
					_iterator7["return"]();
				}
			} finally {
				if (_didIteratorError7) {
					throw _iteratorError7;
				}
			}
		}
	}handler();
	return ret;
};

exports.Cell = Cell;
exports.ImmutableInterface = ImmutableInterface;
exports.AbstractGuard = AbstractGuard;
exports.Getter = Getter;
exports.Type = Type;
exports.importFrom = function (observable) {
	return Type(function (name) {
		return Getter(function () {
			return observable.live[name].valueOf();
		});
	});
};
exports.forceCalculations = function () {
	return updates.runAll();
};

function createActual() {
	var ret = ra();
	ret.assign(ret);
	ra(function () {
		var value = ret.valueOf();
		ra.detach(function () {
			return ret.assign(value);
		});
	});
	return ret;
}

var _DBChunk_Getter = UID();

var DBChunk = (function () {
	function DBChunk(getter, save, initial, previous) {
		_classCallCheck(this, DBChunk);

		this._previous = previous;
		this._getter = getter;
		this._save = save;
		var chunk = this._chunk = ra();
		chunk.assign(initial);
		var actual = this._actual = createActual();
		actual[_DBChunk_Getter] = ra(function () {
			return lu.applyDiff(getter.valueOf(), chunk.valueOf());
		});
		this._summary = ra(function () {
			return actual.valueOf()[_DBChunk_Getter].valueOf();
		});
	}

	_createClass(DBChunk, [{
		key: "createNext",
		value: function createNext() {
			var initial = arguments[0] === undefined ? null : arguments[0];
			return new DBChunk(this._summary, this._save, initial, this._actual);
		}
	}, {
		key: "before",
		get: function () {
			return this._getter.valueOf();
		}
	}, {
		key: "summary",
		get: function () {
			return this._summary.valueOf();
		}
	}, {
		key: "chunk",
		get: function () {
			return this._chunk.valueOf();
		},
		set: function (value) {
			this._chunk.assign(value);
		}
	}, {
		key: "valueOf",
		value: function valueOf() {
			return this.chunk;
		}
	}, {
		key: "assign",
		value: function assign(value) {
			this.chunk = value;
		}
	}, {
		key: "save",
		value: function save() {
			return this._save(this.chunk);
		}
	}, {
		key: "update",
		value: function update(diff) {
			return this._chunk.update(diff);
		}
	}, {
		key: "set",
		value: function set(name, value) {
			return this._chunk.set(name, value);
		}
	}, {
		key: "get",
		value: function get(name) {
			return this._chunk.get(name);
		}
	}, {
		key: "close",
		value: function close() {
			this._chunk.assign(null);
			if (this._previous) {
				this._actual.assign(this._previous);
				this._previous = null;
			}
		}
	}]);

	return DBChunk;
})();

var DB = (function () {
	function DB(getter, save) {
		var _this5 = this;

		_classCallCheck(this, DB);

		this._head = ra();
		this._head.assign(new DBChunk(getter, save));
		this._value = ra(function () {
			return _this5._head.valueOf().summary;
		});
	}

	_createClass(DB, [{
		key: "data",
		get: function () {
			return this.valueOf();
		}
	}, {
		key: "valueOf",
		value: function valueOf() {
			return this._value.valueOf();
		}
	}, {
		key: "createRecord",
		value: function createRecord() {
			var initial = arguments[0] === undefined ? null : arguments[0];
			// not detached
			var ret = this._head.valueOf().createNext();
			this._head.assign(ret);
			return ret;
		}
	}]);

	return DB;
})();

exports.db = function (getter, save) {
	return new DB(getter, save);
};

function toKey(obj) {
	if (!toKey.Keys) toKey.Keys = typeof WeakMap != "undefined" ? new WeakMap() : (function () {
		var id = "_to_key_" + UID();
		return {
			set: function set(obj, value) {
				Object.defineProperty(obj, id, {
					enumerable: false,
					configurable: true,
					writable: false,
					value: value });
			},
			get: function get(obj) {
				return obj[id];
			},
			has: function has(obj) {
				return Object.prototype.hasOwnProperty.call(obj, id);
			} };
	})();
	if (obj && (typeof obj == "object" || typeof obj == "function")) {
		if (!toKey.Keys.has(obj)) toKey.Keys.set(obj, UID());
		return toKey.Keys.get(obj);
	}
	return typeof obj + obj;
}

exports.makeKey = function (obj, key) {
	return ra(function () {
		return obj.get(key);
	});
};

exports.map = function (array, mapper) {
	if (!(array instanceof Cell)) throw new Error("ra.map: first argument must be a cell");
	var cache = Object.create(null);
	var ret = ra();
	ra.detach(function () {
		return ra(function () {
			// TODO Ð¿Ñ€Ð°Ð²ÐµÑ€Ñ‹Ñ†ÑŒ, ÑˆÑ‚Ð¾ Ð¿Ñ€Ñ‹ array.close() Ð³ÑÑ‚Ð° Ñ„ÑƒÐ½ÐºÑ†Ñ‹Ñ Ð°Ð´Ð¿Ñ€Ð°Ñ†Ð¾ÑžÐ²Ð°Ðµ Ñ– Ð¿Ñ€Ñ‹Ð±Ñ–Ð²Ð°Ðµ ÑžÑÐµ cache[].index Ñ– cache[].proc
			var a = array.valueOf();
			ra.detach(function () {
				var retarr = [];
				var index = 0;
				lodash.forEach(cache, function (c) {
					return c.abandoned = true;
				});
				a && a.forEach(function (value) {
					var key = toKey(value);
					var c = undefined;
					if (!(c = cache[key])) c = cache[key] = {
						value: value,
						index: ra() };
					c.abandoned = false;
					c.index.assign(index++);
					if (!c.proc) c.proc = ra(function () {
						return mapper(value, c.index);
					});
					retarr.push(c.proc);
				});
				lodash.keys(cache).forEach(function (key) {
					var c = cache[key];
					if (c.abandoned) {
						delete cache[key];
						c.index.close();
						c.proc.close();
					}
				});
				ret.assign(ra.Array(retarr));
			});
		});
	});
	return ret;
};

exports.keymap = function (array, mapper) {
	var mapped = ra.map(array, mapper);
	return ra(function () {
		return lodash.zipObject(array.valueOf(), mapped.valueOf());
	});
};

exports.slice = function (dest, source, keysVar) {
	throw new Error("message");
	// TODO: optimization
	if (!(dest instanceof Cell)) dest = ra.clean(dest);
	var cacheHolder = ra.clean();
	ra.clean(function () {
		var keys = getValue(keysVar);
		if (keys) keys.sort();
		updates.later(function () {
			var c = ra.clean();
			var s = c.defineProperty("source");
			var d = c.defineProperty("dest");
			keys && keys.forEach(function (k) {
				var sk = s.defineProperty(k);
				var dk = d.defineProperty(k);
				ra.clean(function () {
					return dk.assign(sk.valueOf());
				});
			});
			var t = cacheHolder.valueOf();
			cacheHolder.assign(c);
			t && t.close();
		});
	});
	ra.clean(function () {
		var c = cacheHolder.valueOf();
		c && c.source && c.source.assign(source.valueOf());
	});
	ra.clean(function () {
		var c = cacheHolder.valueOf();
		dest.assign(c && c.dest && c.dest.valueOf());
	});
	return dest;
};

// delete( obj ) { delete obj[ id ] },

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ra.js","/src")

},{"LOG":117,"_process":96,"buffer":91,"co":123,"later":131,"lodash":114,"uid":155}],137:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var maxIndex = 32768;

var Scheduler = (function () {
	function Scheduler(options) {
		_classCallCheck(this, Scheduler);

		this.setImmediate = options && options.setImmediate || process.nextTick;
		this.maxTicks = options && options.maxTicks || Infinity;
		this._procs = [];
		this._index = 0;
		this._scheduled = false;
		this._processing = false;
		this._handler = this._handler.bind(this);
		this.push = this.then.bind(this);
	}

	_createClass(Scheduler, [{
		key: "then",
		value: function then(proc) {
			this._procs.push(proc);
			if (!this._processing) this._schedule();
		}
	}, {
		key: "_schedule",
		value: function _schedule() {
			if (!this._scheduled) {
				this.setImmediate(this._handler);
				this._scheduled = true;
			}
		}
	}, {
		key: "_handler",
		value: function _handler() {
			this._scheduled = false;
			while (this._procs.length) {
				try {
					this._handler1();
				} catch (error) {
					setTimeout(function () {
						throw error;
					}, 0);
				}
			}
		}
	}, {
		key: "_handler1",
		value: function _handler1() {
			this._processing = true;
			try {
				var t = 0;
				while (this._index < this._procs.length && ++t <= this.maxTicks) {
					var proc = this._procs[this._index];
					this._procs[this._index] = null;
					++this._index;
					if (this._index >= maxIndex && this._index * 3 > this._procs.length) {
						this._procs.splice(0, this._index);
						this._index = 0;
					}
					proc();
				}
			} finally {
				this._processing = false;
				if (this._procs.length && this._index >= this._procs.length) this._procs.length = this._index = 0;
				if (this._index) this._schedule();
			}
		}
	}]);

	return Scheduler;
})();

module.exports = Scheduler;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/scheduler.js","/src")

},{"_process":96,"buffer":91}],138:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function rethrow(error) {
	setTimeout(function () {
		throw error;
	});
}

function safeEach(array, cb) {
	for (var i = 0, l = array.length; i < l; ++i) {
		try {
			cb(array.shift());
		} catch (error) {
			rethrow(error);
		}
	}
}

module.exports = (function () {
	function SparseQueue() {
		_classCallCheck(this, SparseQueue);

		this._cbs = [];
	}

	_createClass(SparseQueue, [{
		key: "then",
		value: function then(cb) {
			if (this._closed) process.nextTick(function () {
				return cb(undefined);
			});else this._cbs.push(cb);
		}
	}, {
		key: "isClosed",
		value: function isClosed() {
			return this._closed;
		}
	}, {
		key: "close",
		value: function close() {
			this._closed = true;
			safeEach(this._cbs, function (handler) {
				return handler(undefined);
			});
		}
	}, {
		key: "push",
		value: function push(data) {
			if (this._closed) throw new Error("queue is aready closed");
			safeEach(this._cbs, function (handler) {
				return handler(data);
			});
		}
	}, {
		key: "pushcb",
		value: function pushcb(data) {
			if (this._closed) throw new Error("queue is aready closed");
			safeEach(this._cbs, function (handler) {
				return handler(data());
			});
		}
	}]);

	return SparseQueue;
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/sparsequeue.js","/src")

},{"_process":96,"buffer":91}],139:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
by design:
ÐÐµ ÑÑ‚Ð²Ð°Ñ€Ð°ÐµÐ¼ Ð½Ñ–ÑÐºÑ–Ñ… Ð±ÑƒÑ„ÐµÑ€Ð°Ñž Ð´Ð»Ñ Ð¿Ð°Ð´Ð·ÐµÐ¹ (Ð½Ð°ÐºÑˆÑ‚Ð°Ð»Ñ‚ touchmove Ñ†Ñ– mousemove) - Ð¿Ð°Ð´Ð·ÐµÑ– ÑžÑÑ‘ Ð°Ð´Ð½Ð¾ Ð°Ð»ÑŒÐ±Ð¾ Ð°Ð¿Ñ€Ð°Ñ†Ð¾ÑžÐ²Ð°ÑŽÑ†Ñ†Ð° Ñ…ÑƒÑ‚ÐºÐ°, Ð°Ð»ÑŒÐ±Ð¾ Ñ‚Ð¾Ð»ÑŒÐºÑ– Ð·Ð°Ð¹Ð¼Ð°ÑŽÑ†ÑŒ Ð¼ÐµÑÑ†Ð° Ñž Ð±ÑƒÑ„ÐµÑ€Ð°Ñ… Ñ– Ð·Ð°Ñ‚Ð°Ñ€Ð¼Ð¾Ð¶Ð²Ð°ÑŽÑ†ÑŒ Ð°Ð¿Ñ€Ð°Ñ†Ð¾ÑžÐºÑƒ, ÐºÐ°Ð»Ñ– Ð°Ð¿Ñ€Ð°Ñ†Ð¾ÑžÑˆÑ‡Ñ‹ÐºÑ– ÑžÑÑ‘ Ð¶ Ð¿Ñ€Ð°Ñ‡Ð½ÑƒÑ†Ñ†Ð°.
*/

"use strict";

var htmlutils = require("htmlutils");
var sparsequeue = require("sparsequeue");

var tracks = Object.create(null);

setInterval(function () {
	for (var identifier in tracks) {
		var track = tracks[identifier];
		if (track.abandoned) {} else track.abandoned = true;
	}
}, 7000);

function pushEvent(track, event) {
	track.points.push(event);
	if (track.preventDefault && event.preventDefault) event.preventDefault();
}

function stopEvents(track) {
	track.points.close();
}

function startTrack(identifier, event) {
	var points = new sparsequeue();
	var detail = {
		cancelEvent: null,
		next: points };
	var track = {
		abandoned: false,
		closed: false,
		detail: detail,
		points: points,
		preventDefault: false };
	tracks[identifier] = track;
	var ret = new CustomEvent("touch", { detail: detail, bubbles: true, cancelable: true });
	ret.pageX = event.pageX;
	ret.pageY = event.pageY;
	ret.clientX = event.clientX;
	ret.clientY = event.clientY;
	ret.screenX = event.screenX;
	ret.screenY = event.screenY;
	ret.preventDefault = function () {
		event.preventDefault();
		track.preventDefault = true;
	};
	event.target.dispatchEvent(ret);
	pushEvent(track, event);
}

function onExistingTrack(fun) {
	return function (identifier, arg) {
		var track = tracks[identifier];
		if (!track) return;
		track.abandoned = false;
		fun(track, arg);
	};
}

var continueTrack = onExistingTrack(pushEvent);

var stopTrack = onExistingTrack(function (track, event) {
	pushEvent(track, event);
	stopEvents(track);
});

var removeTrack = onExistingTrack(stopEvents);

var cancelTrack = onExistingTrack(function (track, event) {
	track.detail.cancelEvent = event;
	stopEvents(track);
});

function forTouches(event, cb) {
	for (var i = 0; i < event.changedTouches.length; ++i) {
		var touch = event.changedTouches.item(i);
		cb(touch.identifier, {
			type: "touchmove",
			identifier: touch.identifier,
			target: touch.target,
			screenX: touch.screenX,
			screenY: touch.screenY,
			clientX: touch.clientX,
			clientY: touch.clientY,
			pageX: touch.pageX,
			pageY: touch.pageY,
			radiusX: touch.radiusX,
			radiusY: touch.radiusY,
			rotationAngle: touch.rotationAngle,
			force: touch.force,
			timeStamp: event.timeStamp,
			preventDefault: event.preventDefault.bind(event) });
	}
	var current = Object.create(null);
	for (var i = 0; i < event.touches.length; ++i) {
		current[event.touches.item(i).identifier] = true;
	}for (var identifier in tracks) {
		if (!(identifier in current)) removeTrack(identifier);else tracks[identifier].abandoned = false;
	}
}

var container = document;

container.addEventListener("mousedown", function (event) {
	if (event.button == 0) startTrack("mouse", event);else if (!(event.buttons & 1)) removeTrack("mouse");
});

container.addEventListener("mousemove", function (event) {
	if (event.buttons & 1) continueTrack("mouse", event);else removeTrack("mouse");
});

container.addEventListener("mouseup", function (event) {
	if (event.button == 0) stopTrack("mouse", event);else if (!(event.buttons & 1)) removeTrack("mouse");
});

container.addEventListener("touchstart", function (event) {
	forTouches(event, startTrack);
});

container.addEventListener("touchmove", function (event) {
	forTouches(event, continueTrack);
});

container.addEventListener("touchend", function (event) {
	forTouches(event, stopTrack);
});

container.addEventListener("touchcancel", function (event) {
	forTouches(event, cancelTrack);
});

// if ( track.handler.return )
// 	track.handler.return()
// delete tracks[ identifier ]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/track.js","/src")

},{"_process":96,"buffer":91,"htmlutils":128,"sparsequeue":138}],140:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Command = app.load(require("ui/Command"));
	return function (attr) {
		return React.createElement(Command, {
			message: "commandAddExistingItem",
			onclick: function () {
				app.dialog = "SearchItems";
				app.searchAction = function (itemId) {
					app.linkItem(app.activeDeviceId, itemId);
					app.dialog = "";
				};
				app.searchFilter = null;
				if (app.deviceType == "group") app.searchFilter = function (itemId) {
					var device = app.getDevice(itemId);
					return device && device.type == "single";
				};
			},
			_: attr
		});
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AddExistingItem.js","/src/ui")

},{"_process":96,"buffer":91,"ui/Command":146}],141:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Command = app.load(require("ui/Command"));
	var AddExistingItem = app.load(require("ui/AddExistingItem"));
	return React.createElement(
		"div",
		null,
		React.createElement(AddExistingItem, null),
		React.createElement(Command, {
			message: "commandCreateNewGroup",
			onclick: function () {
				app.addGroup(app.activeDeviceId);
			}
		}),
		React.createElement(Command, {
			message: "commandAddNewDevice",
			onclick: function () {
				return app.addDevice(app.activeDeviceId);
			}
		}),
		React.createElement(Command, {
			message: "commandAddPlace",
			onclick: function () {
				app.addPlace(app.activeDeviceId);
			}
		})
	);
};

// app.dialog = `AddPlace`

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AddMenu.js","/src/ui")

},{"_process":96,"buffer":91,"ui/AddExistingItem":140,"ui/Command":146}],142:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var lu = require("localUtils");

module.exports = function (_ref) {
	var appid = _ref.appid;
	var IconTemplates = _ref.IconTemplates;

	var _require = require("app")(appid);

	var app = _require.app;
	var local = _require.local;

	app.pageStarting = true;

	window._app = app;
	window._local = local;
	window._devdb = require("devdb");

	var httpClient = require("httpClient");
	// let cookies = require( `cookies` )
	if (navigator.standalone) void 0 // cookies.setItem( `standalone`, 1, Infinity ) -- ÑƒÑÑ‘ Ð°Ð´Ð½Ð¾ Ð½Ðµ Ð¿Ð°ÑÑŒÐ¿ÑÐ²Ð°ÐµÐ¼ Ð¿Ð°ÑÑ‚Ð°Ð²Ñ–Ñ†ÑŒ ÐºÑƒÐºÑƒ Ð¿ÐµÑ€Ð°Ð´ Ð¿ÐµÑ€ÑˆÑ‹Ð¼ Ð·Ð²Ð°Ñ€Ð¾Ñ‚Ð°Ð¼ Ð´Ð° ÑÐµÑ€Ð²ÐµÑ€Ð°
	;else {
		ra(function () {
			if (local.activeDeviceId && local.activeDeviceId.valueOf()) {
				var title = "TITLE_" + local.activeDeviceId;
				var icon = "ICON_" + local.activeDeviceId;
				screenTitle.setAttribute("content", title);
				if (local.activeDeviceId && local.activeDeviceId != "main") history.replaceState(null, title, "?appicon=" + icon);else history.replaceState(null, title, "?");
			}
		});
	}

	var MainScreen = app.load(require("ui/MainScreen"));
	var StartupScreen = app.load(require("ui/StartupScreen"));
	var LoadingScreen = function LoadingScreen() {
		return React.createElement("div", { "class": "loadingScreen" });
	};

	var application = React.createElement(
		"div",
		{ "class": function () {
				return "\n\t\tapplication\n\t\t" + (app.pageStarting ? "pageStarting" : "pageRunning") + "\n\t\t" + (app.initialLoading ? "JSONloading" : "JSONloaded") + "\n\t\t" + (app.initialized ? "alreadyRun" : "firstRun") + "\n\t\t" + (app.connectedToServer ? "appConnected" : "appDisconnected") + "\n\t\t" + "" + "\n\t\t" + (app.templates ? "templatesLoaded" : "templatesLoading") + "\n\t\t" + (app.dialog && "dialog" + app.dialog) + "\n\t\t" + (app.dialog ? "dialogIsPresent" : "dialogIsAbsent") + "\n\t\tapp_labels_" + !!local.labels + "\n\t\tapp_editing_" + !!app.editing + "\n\t";
			} },
		React.createElement(MainScreen, null),
		React.createElement(StartupScreen, null),
		React.createElement(LoadingScreen, null)
	);

	app.icons = IconTemplates.reduce(function (icons, template) {
		icons[template.dataset.name] = template;
		return icons;
	}, Object.create(null));

	var Button = app.load(require("ui/Button"));

	var CloseError = function CloseError(attr, text) {
		return React.createElement(
			"p",
			{
				ontouch: function () {
					var error = app.error;
					app.dialog = "";
					app.error = null;
					attr.onclick && attr.onclick(error);
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			text
		);
	};

	var CloseDialog = function CloseDialog(attr, text) {
		return React.createElement(
			"p",
			{
				ontouch: function () {
					app.dialog = "";
					attr.onclick && attr.onclick();
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			text
		);
	};

	// dialogs
	var dialogTemplates = {

		ServiceDialog: function ServiceDialog() {
			return app.load(require("ui/ServiceDialog"));
		},
		ContextMenu: function ContextMenu() {
			return app.load(require("ui/ContextMenu"));
		},
		AddMenu: function AddMenu() {
			return app.load(require("ui/AddMenu"));
		},
		SearchItems: function SearchItems() {
			return app.load(require("ui/SearchItems"));
		},
		AskNewName: function AskNewName() {
			return app.load(require("ui/AskNewName"));
		},
		AskToLinkDevice: function AskToLinkDevice() {
			return app.load(require("ui/AskToLinkDevice"));
		},

		AskIfDeviceHasBeenLinked: function AskIfDeviceHasBeenLinked() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Ð£ÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ Ð±Ñ‹Ð»Ð¾ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¿Ñ€Ð¸Ð²ÑÐ·Ð°Ð½Ð¾?"
				),
				React.createElement(
					Button,
					{ onclick: "StopDeviceNotification" },
					"Ð´Ð°"
				),
				React.createElement(
					Button,
					{ onclick: "AskToLinkDevice" },
					"Ð½ÐµÑ‚"
				)
			);
		},

		StopDeviceNotification: function StopDeviceNotification() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°,",
					React.createElement("br", null),
					"Ð¿ÐµÑ€ÐµÐ²ÐµÐ´Ð¸Ñ‚Ðµ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ Ð² Ñ€Ð°Ð±Ð¾Ñ‡Ð¸Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼."
				),
				React.createElement(
					Button,
					null,
					"Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ"
				)
			);
		},

		ErrorNoCarrier: function ErrorNoCarrier() {
			return React.createElement(
				"div",
				{ "class": "errorDialog" },
				React.createElement(
					"p",
					null,
					"ÐžÑˆÐ¸Ð±ÐºÐ°"
				),
				React.createElement(
					"p",
					null,
					"ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÐµ ÑÐ²ÑÐ·Ð°Ñ‚ÑŒÑÑ Ñ Ð¼Ð¾Ð´ÐµÐ¼Ð¾Ð¼."
				),
				React.createElement(
					Button,
					null,
					"Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ"
				)
			);
		},

		ErrorUnlinkingDevice: function ErrorUnlinkingDevice() {
			return React.createElement(
				"div",
				{ "class": "errorDialog" },
				React.createElement(
					"p",
					null,
					"ÐžÑˆÐ¸Ð±ÐºÐ°"
				),
				React.createElement(
					"p",
					null,
					"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ²ÑÐ·Ð°Ñ‚ÑŒÑÑ Ñ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾Ð¼ Ð¸ Ð¾Ñ‚Ð²ÑÐ·Ð°Ñ‚ÑŒ ÐµÐ³Ð¾."
				),
				React.createElement(
					"p",
					null,
					"Ð§Ñ‚Ð¾ ÑÐ»ÐµÐ´ÑƒÐµÑ‚ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ?"
				),
				React.createElement(
					"ul",
					null,
					React.createElement(
						CloseError,
						{ onclick: function (error) {
								return app.purgeItem(error.data.deviceId);
							}
						},
						React.createElement(
							"li",
							null,
							"ÐŸÐ¾Ð¿Ñ‹Ñ‚Ð°Ñ‚ÑŒÑÑ Ð¾Ñ‚Ð²ÑÐ·Ð°Ñ‚ÑŒ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·"
						)
					),
					React.createElement(
						CloseError,
						null,
						React.createElement(
							"li",
							null,
							"ÐžÑ‚Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ"
						)
					),
					React.createElement(
						CloseError,
						{ onclick: function (error) {
								return app.purgeItem(error.data.deviceId, true);
							}
						},
						React.createElement(
							"li",
							null,
							"Ð—Ð°Ð±Ñ‹Ñ‚ÑŒ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾Ð± ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ðµ"
						)
					)
				)
			);
		},

		DeleteDevice: function DeleteDevice() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					({
						place: React.createElement(
							"span",
							null,
							"ÐŸÐ¾Ð¼ÐµÑ‰ÐµÐ½Ð¸Ðµ (Ð¼ÐµÑÑ‚Ð¾) \"",
							app.caption,
							"\" Ð±ÑƒÐ´ÐµÑ‚ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¾ Ð¸Ð· Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñ‹."
						),
						single: React.createElement(
							"span",
							null,
							"Ð£ÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ \"",
							app.caption,
							"\" Ð±ÑƒÐ´ÐµÑ‚ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¾ Ð¸Ð· Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñ‹."
						),
						group: React.createElement(
							"span",
							null,
							"Ð“Ñ€ÑƒÐ¿Ð¿Ð° \"",
							app.caption,
							"\" Ð±ÑƒÐ´ÐµÑ‚ ÑƒÐ´Ð°Ð»ÐµÐ½Ð° Ð¸Ð· Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñ‹."
						) })[app.deviceType]
				),
				React.createElement(
					"ul",
					null,
					React.createElement(
						CloseDialog,
						{ "class": "dangerousAction", onclick: function () {
								return app.purgeItem(app.activeDeviceId);
							}
						},
						React.createElement(
							"li",
							null,
							"Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ"
						)
					),
					React.createElement(
						CloseDialog,
						null,
						React.createElement(
							"li",
							null,
							"ÐÐµ ÑƒÐ´Ð°Ð»ÑÑ‚ÑŒ"
						)
					)
				)
			);
		},

		StateWait: function StateWait() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"ÐŸÐ¾Ð´Ð¾Ð¶Ð´Ð¸Ñ‚Ðµ..."
				)
			);
		},

		AskToReset: function AskToReset() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"ÐŸÐ°Ð¼ÑÑ‚ÑŒ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»ÐµÑ€Ð° Ð±ÑƒÐ´ÐµÑ‚ Ð¾Ñ‡Ð¸Ñ‰ÐµÐ½Ð°,",
					React.createElement("br", null),
					"Ð½Ð¾ Ð¿Ð°Ð¼ÑÑ‚ÑŒ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² Ð¾Ñ‡Ð¸Ñ‰Ð°Ñ‚ÑŒÑÑ Ð½Ðµ Ð±ÑƒÐ´ÐµÑ‚."
				),
				React.createElement(
					Button,
					{ "class": "dangerousAction", onclick: app.reset },
					"ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ",
					React.createElement("br", null),
					"Ð¿Ð°Ð¼ÑÑ‚ÑŒ"
				)
			);
		} };

	ra(function () {
		var dialogName = app.dialog;
		if (!dialogName) return;

		if (!Object.prototype.hasOwnProperty.call(dialogTemplates, dialogName)) {
			alert("Error: Could not find dialog named\n\"" + dialogName + "\"");
			ra.detach(function () {
				return app.dialog = "";
			});
			return;
		}
		var Template = dialogTemplates[dialogName];
		if (!Template) return;
		dialogTemplates[dialogName] = null;

		var dialog = Template();
		dialog.classList.add(dialogName);
		dialog.classList.add("modalDialog");
		ra(Object.defineProperties({}, {
			isActive: {
				get: function () {
					return dialogName == app.dialog;
				},
				configurable: true,
				enumerable: true
			},
			updateClass: {
				get: function () {
					var event = undefined;
					if (this.isActive) {
						event = "dialogshow";
						dialog.classList.add("dialogShown");
						dialog.classList.remove("dialogHidden");
						var input = dialog.querySelector("*[ autofocus ]");
						if (input) app.focus(input);
					} else {
						event = "dialoghide";
						dialog.classList.remove("dialogShown");
						dialog.classList.add("dialogHidden");
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
							for (var _iterator = dialog.querySelectorAll("*:focus")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var elem = _step.value;

								elem.blur();
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator["return"]) {
									_iterator["return"]();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}

						dialog.blur();
					}
					dialog.dispatchEvent(new CustomEvent(event, { detail: null }));
				},
				configurable: true,
				enumerable: true
			}
		}));
		application.appendChild(dialog);
	});

	setTimeout(function () {
		return app.pageStarting = false;
	}, 1);

	return application;
};
// httpClient.post( `/cookie?appicon=${ icon }`, `` )
// cookies.setItem( `appicon`, icon, Infinity )
// LOG( local.activeDeviceId.blue )
/* app.credentials == null ? `showLogin` : `hideLogin` */

// AddPlace,
// AddDevice,

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Application.js","/src/ui")

},{"_process":96,"app":121,"buffer":91,"devdb":125,"httpClient":129,"localUtils":132,"ui/AddMenu":141,"ui/AskNewName":143,"ui/AskToLinkDevice":144,"ui/Button":145,"ui/ContextMenu":147,"ui/MainScreen":149,"ui/SearchItems":152,"ui/ServiceDialog":153,"ui/StartupScreen":154}],143:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");

module.exports = function (app) {
	var $ = {};
	return React.createElement(
		"div",
		{ ondialogshow: function () {
				$.string.value = app.getMessage(app.getDevice(app.activeDeviceId));
				$.string.setSelectionRange(0, $.string.value.length);
			} },
		React.createElement(
			"p",
			null,
			"ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ:"
		),
		React.createElement(
			"form",
			{ onsubmit: function (event) {
					event && event.preventDefault();
					var name = $.string.value.trim();
					app.dialog = "";
					if (name) app.renameItem(app.activeDeviceId, name);
				} },
			$.string = React.createElement("textarea", { name: "string", cols: "35", rows: "2", autofocus: "autofocus" }),
			React.createElement(
				"p",
				null,
				React.createElement(
					"a",
					{ "class": "button", href: "javascript:void(0)", target: "_self", ontouch: htmlutils.Submit },
					"Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ"
				)
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AskNewName.js","/src/ui")

},{"_process":96,"buffer":91,"htmlutils":128}],144:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Button = app.load(require("ui/Button"));
	return React.createElement(
		"div",
		null,
		React.createElement(
			"p",
			null,
			"ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°,",
			React.createElement("br", null),
			"Ð¿ÐµÑ€ÐµÐ²ÐµÐ´Ð¸Ñ‚Ðµ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ Ð² Ñ€ÐµÐ¶Ð¸Ð¼",
			React.createElement("br", null),
			"Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¸ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ"
		),
		React.createElement(
			Button,
			{ onclick: function () {
					var placeId = app.linkingPlaceId || app.activeDeviceId;
					app.dialog = "StateWait";
					co.go(regeneratorRuntime.mark(function callee$2$0() {
						return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
							while (1) switch (context$3$0.prev = context$3$0.next) {
								case 0:
									context$3$0.next = 2;
									return app.command(placeId, "Link");

								case 2:
									app.dialog = "AskIfDeviceHasBeenLinked";
									app.linkingPlaceId = placeId;

								case 4:
								case "end":
									return context$3$0.stop();
							}
						}, callee$2$0, this);
					}))["catch"](function (error) {
						console.log(error);
						app.dialog = "ErrorNoCarrier";
					});
				}
			},
			"Ð·Ð´ÐµÑÑŒ"
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AskToLinkDevice.js","/src/ui")

},{"_process":96,"buffer":91,"ui/Button":145}],145:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function (attr, content) {
		return React.createElement(
			"a",
			{ "class": "button", href: "javascript:void(0)", target: "_self", ontouch: function (event) {
					event.preventDefault();
					if (typeof attr.onclick == "string") app.dialog = attr.onclick;else {
						app.dialog = "";
						attr.onclick && attr.onclick();
					}
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			content
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Button.js","/src/ui")

},{"_process":96,"buffer":91}],146:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function (_ref) {
		var onclick = _ref.onclick;
		var url = _ref.url;
		var visible = _ref.visible;
		var enabled = _ref.enabled;
		var message = _ref.message;

		var content = app.message(message);
		var isEnabled = function isEnabled() {
			return (url || onclick) && (!enabled || enabled());
		};
		if (typeof visible == "string") {
			(function () {
				var deviceType = visible;
				visible = function () {
					return app.deviceType == deviceType;
				};
			})();
		}
		var className = function className() {
			return "command " + message + " " + (isEnabled() ? "enabled" : "disabled") + " " + (visible == null || visible() ? "itemVisible" : "itemHidden");
		};
		if (url && !onclick) return React.createElement(
			"a",
			{ "class": className, href: url, rel: "external", target: "_blank" },
			content
		);else return React.createElement(
			"a",
			{ "class": className, href: "javascript:void(0)", target: "_self", ontouch: function (event) {
					event.preventDefault();
					if (onclick && isEnabled()) {
						if (typeof onclick == "string") app.dialog = onclick;else {
							app.dialog = "";
							onclick();
						}
					}
				} },
			content
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Command.js","/src/ui")

},{"_process":96,"buffer":91}],147:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app, local) {
	var Command = app.load(require("ui/Command"));
	var AddExistingItem = app.load(require("ui/AddExistingItem"));
	return React.createElement(
		"div",
		null,
		React.createElement(Command, {
			message: "commandSearchDevices",
			onclick: "SearchItems"
		}),
		React.createElement(Command, {
			message: "commandToFavourites",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.linkActiveToFavourites();
				app.notification("Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾ Ð² Ð¸Ð·Ð±Ñ€Ð°Ð½Ð½Ð¾Ðµ");
			}
		}),
		React.createElement(Command, {
			message: "commandLinkDevice",
			visible: "device",
			onclick: "AskToLinkDevice"
		}),
		React.createElement(Command, {
			message: "commandAdd",
			visible: function () {
				return !app.editing && app.deviceType == "place";
			},
			onclick: "AddMenu"
		}),
		React.createElement(AddExistingItem, {
			message: "commandAdd",
			visible: function () {
				return !app.editing && app.deviceType == "group";
			}
		}),
		React.createElement(Command, {
			message: "commandMoveIcons",
			visible: function () {
				return !app.editing && app.deviceType != "single";
			},
			onclick: function () {
				return app.editing = true;
			}
		}),
		React.createElement(Command, {
			message: "commandRenameItem",
			visible: function () {
				return !app.editing;
			},
			onclick: "AskNewName"
		}),
		React.createElement(Command, {
			message: "commandPurgeItem",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.dialog = "DeleteDevice";
			}
		}),
		React.createElement(Command, {
			message: "commandShowLabels",
			visible: function () {
				return !local.labels && app.activeDeviceId == app.main;
			},
			onclick: function () {
				return local.labels = true;
			}
		}),
		React.createElement(Command, {
			message: "commandHideLabels",
			visible: function () {
				return local.labels && app.activeDeviceId == app.main;
			},
			onclick: function () {
				return local.labels = false;
			}
		}),
		React.createElement(Command, {
			message: "commandResetToFactorySettings",
			visible: function () {
				return app.activeDeviceId == app.main;
			},
			enabled: function () {
				return window.location.hostname != "test.sh.neroelectronics.by";
			},
			onclick: "AskToReset"
		})
	);
};
// app.purgeItem( app.activeDeviceId )

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/ContextMenu.js","/src/ui")

},{"_process":96,"buffer":91,"ui/AddExistingItem":140,"ui/Command":146}],148:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var htmlutils = require("htmlutils");

module.exports = function (app, local) {
	return function (_ref) {
		var placeId = _ref.placeId;
		var iconId = _ref.iconId;
		var iconDescr = _ref.iconDescr;
		var position = _ref.position;

		// TODO: refactoring: move to more JSX (?)
		// TODO: onTap, onPress, onClick handlers must remove themself when thread is being killed
		var icon = undefined,
		    off = undefined,
		    on = undefined,
		    absent = undefined,
		    image = undefined;
		var isMouse = false;

		var placeRect = htmlutils.tickCache(function () {
			var x = icon.parentNode;
			var r = undefined;
			while ((r = x.getBoundingClientRect(), !r.width || !r.height)) x = x.parentNode;
			return r;
		});

		var relPoint = function relPoint(p) {
			var r = placeRect();
			return {
				x: (p.x - r.left) / r.width * 100,
				y: (p.y - r.top) / r.height * 100 };
		};

		var getPoint = function getPoint(data) {
			return relPoint({ x: data.pageX, y: data.pageY });
		};

		var getLeftTop = function getLeftTop(data) {
			var p = data.getBoundingClientRect();
			return relPoint({ x: p.left, y: p.top });
		};

		var iconsCount = function iconsCount() {
			var place = app.getDevice(placeId);
			return lodash.keys(place && place.content).length;
		};

		var imageHeight = htmlutils.tickCache(function () {
			if (!isMouse) return icon.getBoundingClientRect().height;
			if (opts.iconData) {
				if (opts.iconData.deviceImageGetHeight) {
					var r = opts.iconData.deviceImageGetHeight();
					if (r) return r;
				}
				var h = opts.iconData.getElementsByClassName("device_image_height")[0];
				if (h != null && h.getBoundingClientRect) {
					var r = h.getBoundingClientRect().height;
					if (r) return r;
				}
				for (var i = 0; i < opts.iconData.childNodes.length; ++i) {
					var r = opts.iconData.childNodes.item(i);
					if (r.getBoundingClientRect) {
						r = r.getBoundingClientRect().height;
						if (r) return r;
					}
				}
			}
			return image.getBoundingClientRect().height;
		});

		var opts = ra(Object.defineProperties({
			iconData: null,

			iconCommand: function iconCommand(cmd, data) {
				return app.iconCommand(iconDescr, iconId, cmd, data);
			},

			isDimmering: false,
			moving: false,
			moved: false,
			x: null,
			y: null,
			state: 0,
			onning: false,
			offing: false,
			final: true,
			errorneous: false,

			setOpacity: function setOpacity(node, opacity) {
				if (opacity == null) {
					delete node.style.opacity;
				} else {
					node.style.opacity = opacity;
				}
			} }, {
			iconName: {
				get: function () {
					return iconDescr && iconDescr.valueOf() && iconDescr.valueOf().icon || null;
				},
				configurable: true,
				enumerable: true
			},
			iconTemplate: {
				get: function () {
					return this.iconName && app.icons && Object.prototype.hasOwnProperty.call(app.icons, this.iconName) && app.icons[this.iconName] || null;
				},
				configurable: true,
				enumerable: true
			},
			updateIconDataState: {
				get: function () {
					var data = this.iconData;
					if (data && data.deviceSetState) data.deviceSetState(this.state);
				},
				configurable: true,
				enumerable: true
			},
			dimmering: {
				get: function () {
					var i = iconDescr == null ? null : iconDescr.valueOf();
					var id = i == null ? null : i.dimmering == null ? null : !!i.dimmering;
					if (id != null) return id;
					if (i != null && i.type === "place") return false;
					return true;
				},
				configurable: true,
				enumerable: true
			},
			image_on: {
				get: function () {
					var i = iconDescr && iconDescr.valueOf();
					var file = "" || i && i.image_on || i && i.image;
					return file && "/images/" + file;
				},
				configurable: true,
				enumerable: true
			},
			update_image_on: {
				get: function () {
					if (opts.image_on) on.src = opts.image_on;
				},
				configurable: true,
				enumerable: true
			},
			image_off: {
				get: function () {
					var i = iconDescr && iconDescr.valueOf();
					var file = "" || i && i.image_off || i && i.image;
					return file && "/images/" + file;
				},
				configurable: true,
				enumerable: true
			},
			update_image_off: {
				get: function () {
					if (opts.image_off) off.src = opts.image_off;
				},
				configurable: true,
				enumerable: true
			},
			present: {
				get: function () {
					return !!(iconDescr.get("content") || iconDescr.get("group"));
				},
				configurable: true,
				enumerable: true
			},
			updateState: {
				get: function () {
					var d = iconDescr && iconDescr.valueOf();
					if (!d) return 0;
					if (d.newstate_timestamp && (!d.state_timestamp || d.newstate_timestamp > d.state_timestamp)) {
						var fonning = d.newstate >= d.state;
						this.onning = fonning;
						this.offing = !fonning;
						this.final = false;
						this.state = d.newstate;
					} else {
						this.onning = false;
						this.offing = false;
						this.final = true;
						this.state = d.state;
					}
					this.errorneous = !!d.errorneous;
				},
				configurable: true,
				enumerable: true
			},
			updateOpacity: {
				get: function () {
					if (this.iconTemplate) {
						on.style.visibility = "hidden";
						off.style.visibility = "hidden";
						absent.style.visibility = "hidden";
					} else if (!this.present) {
						this.setOpacity(on, 0);
						this.setOpacity(off, 0);
						this.setOpacity(absent, 0.7);
					} else {
						this.setOpacity(absent, 0);
						if (this.dimmering) {
							this.setOpacity(on, this.state);
							this.setOpacity(off, (1 - this.state) * 0.333);
						} else {
							this.setOpacity(on, +!!this.state);
							this.setOpacity(off, +!this.state);
						}
					}
				},
				configurable: true,
				enumerable: true
			}
		}));

		var MOVE_PAGE_DIST = 0.1;
		var MOVE_SIDE_DIST = 0.25;

		function compareIndex(a, b) {
			return a.index - b.index;
		}

		var move = regeneratorRuntime.mark(function move(start, next) {
			var changes, currentPosition, done, hoverId, setHover, _ret;

			return regeneratorRuntime.wrap(function move$(context$3$0) {
				var _this = this;

				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						setHover = function setHover(value) {
							if (hoverId == value) return;
							if (hoverId) app.hover = lu.applyDiff(app.hover, _defineProperty({}, hoverId, _defineProperty({}, placeId, _defineProperty({}, iconId, null))));
							hoverId = value;
							if (hoverId) app.hover = lu.applyDiff(app.hover, _defineProperty({}, hoverId, _defineProperty({}, placeId, _defineProperty({}, iconId, true))));
						};

						if (opts.moving) opts.moving.kill("restarting by another finger");

						changes = app.localDevices.createRecord();
						currentPosition = position.valueOf();
						done = false;
						hoverId = null;
						context$3$0.prev = 6;
						return context$3$0.delegateYield(regeneratorRuntime.mark(function callee$3$0() {
							var self, p, r, fingerShift, pt, finger, corner, newHoverId, _ret2;

							return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
								while (1) switch (context$4$0.prev = context$4$0.next) {
									case 0:
										self = co.current;

										ra(function () {
											return !done && !app.editing && self.kill();
										});

										p = getPoint(start);
										r = getLeftTop(icon);

										opts.moving = co.current;
										opts.moved = false;
										fingerShift = {
											x: r.x - p.x,
											y: r.y - p.y };

										opts.x = r.x;
										opts.y = r.y;

										pt = undefined;

									case 10:
										context$4$0.next = 12;
										return next;

									case 12:
										if (!(pt = context$4$0.sent)) {
											context$4$0.next = 34;
											break;
										}

										finger = getPoint(pt);
										corner = {
											x: finger.x + fingerShift.x,
											y: finger.y + fingerShift.y };

										if (opts.x != corner.x || opts.y != corner.y) opts.moved = true;
										opts.x = corner.x;
										opts.y = corner.y;

										if (!(pt.type != "stop")) {
											context$4$0.next = 20;
											break;
										}

										return context$4$0.abrupt("continue", 32);

									case 20:
										newHoverId = null;
										context$4$0.prev = 21;

										_ret2 = (function () {
											var pageSize = {
												x: app.pageWidth,
												y: app.pageHeight };
											var cellSize = {
												x: 100 / pageSize.x,
												y: 100 / pageSize.y };
											var index = {
												x: Math.min(pageSize.x - 1, Math.max(0, Math.floor(finger.x / cellSize.x))),
												y: Math.min(pageSize.y - 1, Math.max(0, Math.floor(finger.y / cellSize.y))) };
											var inCell = {
												x: finger.x / cellSize.x - index.x,
												y: finger.y / cellSize.y - index.y };

											if (inCell > 1 - MOVE_PAGE_DIST && cellSize.x == pageSize.x - 1) {
												// TODO: scroll page right
												return "continue";
											}
											if (inCell < MOVE_PAGE_DIST && cellSize.x == pageSize.x - 1) {
												// TODO: scroll page left
												return "continue";
											}

											var placePosition = index.x + index.y * pageSize.x + (local.placesPages[placeId] || 0) * pageSize.x * pageSize.y;

											var place = lu.get(changes, "summary", "content", placeId, "content");
											if (!place || !place[iconId]) return {
													v: {
														v: undefined
													}
												};
											var keys = lodash.keys(place).map(function (key) {
												return { key: key, index: place[key].index };
											}).sort(compareIndex);

											var newIndex = undefined;

											if (placePosition < 0) {
												if (currentPosition <= 0) return "continue";
												newIndex = keys[0].index - 1;
											} else if (placePosition > keys.length - 1) {
												if (currentPosition >= keys.length - 1) return "continue";
												newIndex = keys[keys.length - 1].index + 1;
											} else {
												if (currentPosition == placePosition) return "continue";
												if (inCell.x > MOVE_SIDE_DIST && inCell.x < 1 - MOVE_SIDE_DIST && inCell.y > MOVE_SIDE_DIST && inCell.y < 1 - MOVE_SIDE_DIST) {
													// TODO
													newHoverId = keys[placePosition].key;
													var srcType = iconDescr && iconDescr.valueOf() && iconDescr.valueOf().type;
													var dstDevice = app.getDevice(newHoverId);
													var dstType = dstDevice && dstDevice.type;
													if (dstType == "place") return "continue";
													if (dstType == "group" && srcType == "single") return "continue";
													// TODO: allow dstType == `single` && srcType == `single`
													newHoverId = null;
												}
												if (inCell.x > 0.5) {
													if (currentPosition == placePosition + 1) return "continue";
													if (index.x == pageSize.x - 1 && currentPosition > placePosition) return "continue";
													if (placePosition >= keys.length - 1) newIndex = keys[placePosition].index + 1;else newIndex = (keys[placePosition].index + keys[placePosition + 1].index) / 2;
												} else {
													if (currentPosition == placePosition - 1) return "continue";
													if (index.x == 0 && currentPosition < placePosition) return "continue";
													if (placePosition <= 0) newIndex = keys[placePosition].index - 1;else newIndex = (keys[placePosition].index + keys[placePosition - 1].index) / 2;
												}
											}

											var newPosition = keys.map(function (k) {
												return k.key != iconId ? k : { key: k.key, index: newIndex };
											}).sort(compareIndex).findIndex(function (k) {
												return k.key == iconId;
											});

											if (currentPosition == newPosition) return "continue";

											currentPosition = newPosition;
											changes.assign({ content: _defineProperty({}, placeId, { content: _defineProperty({}, iconId, { index: newIndex }) }) });
										})();

										context$4$0.t0 = _ret2;
										context$4$0.next = context$4$0.t0 === "continue" ? 26 : 27;
										break;

									case 26:
										return context$4$0.abrupt("continue", 32);

									case 27:
										if (!(typeof _ret2 === "object")) {
											context$4$0.next = 29;
											break;
										}

										return context$4$0.abrupt("return", _ret2.v);

									case 29:
										context$4$0.prev = 29;

										setHover(newHoverId);
										return context$4$0.finish(29);

									case 32:
										context$4$0.next = 10;
										break;

									case 34:
										done = true;

										if (!hoverId) {
											context$4$0.next = 40;
											break;
										}

										changes.close();
										// TODO
										// let newPlace = app.getDevice( hoverId )
										// if ( newPlace && newPlace.type == `single` ) {
										// 	app.linkingDevices = [ hoverId, iconId ]
										// 	app.dialog = `CreatePlaceOrGroup`
										// }
										// else
										app.insertInto(hoverId, iconId, placeId);
										context$4$0.next = 43;
										break;

									case 40:
										context$4$0.next = 42;
										return co.sleep();

									case 42:
										lu.when(changes.save(), function () {
											return changes.close();
										});

									case 43:
									case "end":
										return context$4$0.stop();
								}
							}, callee$3$0, _this, [[21,, 29, 32]]);
						})(), "t0", 8);

					case 8:
						_ret = context$3$0.t0;

						if (!(typeof _ret === "object")) {
							context$3$0.next = 11;
							break;
						}

						return context$3$0.abrupt("return", _ret.v);

					case 11:
						context$3$0.prev = 11;

						setHover(null);
						if (!done) {
							done = true;
							changes.close();
						}
						if (opts.moving == co.current) {
							opts.moving = null;
							opts.moved = false;
						}
						return context$3$0.finish(11);

					case 16:
					case "end":
						return context$3$0.stop();
				}
			}, move, this, [[6,, 11, 16]]);
		});

		var dimm = regeneratorRuntime.mark(function dimm(next) {
			var changes, state, initialDimmeringState, pt, delta;
			return regeneratorRuntime.wrap(function dimm$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						changes = app.localDevices.createRecord();
						context$3$0.prev = 1;
						state = undefined;

						opts.isDimmering = true;
						initialDimmeringState = iconDescr && iconDescr.get("state");
						pt = undefined;

					case 6:
						context$3$0.next = 8;
						return next;

					case 8:
						if (!(pt = context$3$0.sent)) {
							context$3$0.next = 13;
							break;
						}

						if (pt.detail.type == "swipe") {
							if (data.detail.direction == "up") state = 1;else state = 0;
						} else {
							delta = -pt.deltaY / (imageHeight() * 1 /* move multiplyer */);

							state = Math.min(1, Math.max(0, initialDimmeringState + delta));
							if (state == 0 || state == 1) initialDimmeringState = state - delta;
						}
						changes.update({ content: _defineProperty({}, iconId, { state: state }) });

					case 11:
						context$3$0.next = 6;
						break;

					case 13:
						if (state != null) opts.iconCommand("Set", state);

					case 14:
						context$3$0.prev = 14;

						changes.close();
						opts.isDimmering = false;
						return context$3$0.finish(14);

					case 18:
					case "end":
						return context$3$0.stop();
				}
			}, dimm, this, [[1,, 14, 18]]);
		});

		var Picture = function Picture(attributes) {
			return React.createElement("img", {
				"class": "error",
				onerror: function () {
					this.classList.add("error");
				},
				onload: function () {
					this.classList.remove("error");
				},
				_: attributes
			});
		};

		return React.createElement(
			"div",
			{
				oncreate: function (e) {
					return icon = e.target;
				},
				onmousedown: function () {
					return isMouse = true;
				},
				onwheel: function (e) {
					return console.log(e.deltaY, e.deltaMode, e);
				},
				"class": function () {
					return "\n\t\t\ticon\n\t\t\t" + (opts.onning && "onning") + "\n\t\t\t" + (opts.offing && "offing") + "\n\t\t\t" + (opts.final && "final") + "\n\t\t\t" + (opts.errorneous && "errorneous") + "\n\t\t\t" + (opts.dimmering.valueOf() ? "dimmering" : "switching") + "\n\t\t\t" + iconId + "\n\t\t\ticon_moving_" + !!opts.moving + "\n\t\t\ticon_moved_" + (!!opts.moving && !!opts.moved) + "\n\t\t\ticon_destination_" + !!(app.hover && app.hover[iconId]) + "\n\t\t";
				},
				style: regeneratorRuntime.mark(function block() {
					var pt, i, ph, pw, ps, pi, p, w, h;
					return regeneratorRuntime.wrap(function block$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!app.editing) {
									context$3$0.next = 3;
									break;
								}

								context$3$0.next = 3;
								return co.sleep();

							case 3:
								if (block.run) {
									context$3$0.next = 7;
									break;
								}

								block.run = true;
								context$3$0.next = 9;
								break;

							case 7:
								context$3$0.next = 9;
								return co.requestAnimationFrame;

							case 9:
								pt = undefined;

								if (opts.moving) pt = { x: opts.x, y: opts.y };else {
									i = lu.valueOf(position);
									ph = app.pageHeight || 1;
									pw = app.pageWidth || 1;
									ps = pw * ph;
									pi = i % ps;
									p = (i - pi) / ps;
									w = pi % pw;
									h = (pi - w) / pw;

									w += pw * p;
									pt = { x: w * 100 / pw, y: h * 100 / ph };
								}
								return context$3$0.abrupt("return", {
									left: "" + pt.x + "%",
									top: "" + pt.y + "%" });

							case 12:
							case "end":
								return context$3$0.stop();
						}
					}, block, this);
				})
			},
			React.createElement(
				"div",
				{ "class": "iconControl",
					ontouch: htmlutils.preventDefault,
					ontap: function () {
						return !app.editing && opts.iconCommand("Short");
					},
					onpress: function () {
						return !app.editing && opts.iconCommand("Long");
					},
					onpan: regeneratorRuntime.mark(function callee$2$0(data) {
						var next, pt;
						return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
							while (1) switch (context$3$0.prev = context$3$0.next) {
								case 0:
									if (!app.editing) {
										context$3$0.next = 20;
										break;
									}

									next = data.detail.lock();
									context$3$0.prev = 2;
									pt = undefined;

								case 4:
									context$3$0.next = 6;
									return next;

								case 6:
									if (!(pt = context$3$0.sent)) {
										context$3$0.next = 15;
										break;
									}

									if (!(pt.detail.pressed == false)) {
										context$3$0.next = 9;
										break;
									}

									return context$3$0.abrupt("return");

								case 9:
									if (!(pt.detail.pressed == null)) {
										context$3$0.next = 11;
										break;
									}

									return context$3$0.abrupt("continue", 13);

								case 11:
									return context$3$0.delegateYield(move(pt, next), "t0", 12);

								case 12:
									return context$3$0.abrupt("break", 15);

								case 13:
									context$3$0.next = 4;
									break;

								case 15:
									context$3$0.prev = 15;

									data.detail.unlock(next);
									return context$3$0.finish(15);

								case 18:
									context$3$0.next = 23;
									break;

								case 20:
									if (!(data.detail.direction == "up" || data.detail.direction == "down")) {
										context$3$0.next = 23;
										break;
									}

									data.stopPropagation();
									return context$3$0.delegateYield(dimm(data.detail.next), "t1", 23);

								case 23:
								case "end":
									return context$3$0.stop();
							}
						}, callee$2$0, this, [[2,, 15, 18]]);
					})
				},
				React.createElement(
					"div",
					{ "class": "image", oncreate: function (e) {
							return image = e.target;
						} },
					React.createElement(Picture, { "class": "wait", src: "/images/wait.svg", style: {
							visibility: function visibility() {
								return undefined.final ? "hidden" : null;
							} } }),
					React.createElement(Picture, { "class": "off", src: "/images/room.svg", oncreate: function (e) {
							return off = e.target;
						} }),
					React.createElement(Picture, { "class": "on", src: "/images/room_on.svg", oncreate: function (e) {
							return on = e.target;
						} }),
					React.createElement(Picture, { "class": "absent", src: "/images/room_absent.svg", oncreate: function (e) {
							return absent = e.target;
						} }),
					React.createElement(
						"div",
						{ "class": function () {
								return "\n\t\t\t\t\tsvg\n\t\t\t\t\t" + ("state" + (!opts.present ? "Absent" : (Math.round(opts.state * 100) + 1000).toString().slice(1))) + "\n\t\t\t\t\t" + (!opts.isDimmering ? "smoothing" : "") + "\n\t\t\t\t";
							} },
						function () {
							return opts.iconData = opts.iconTemplate && htmlutils.importComponent(opts.iconTemplate) || null;
						}
					)
				),
				React.createElement(
					"span",
					{ "class": "iconLabel" },
					function () {
						return iconDescr.get(local.language) || iconDescr.get("ru") || iconDescr.get("en");
					}
				),
				React.createElement(
					"span",
					{ "class": "iconPercentage" },
					function () {
						return opts.present && opts.dimmering && "" + Math.round(opts.state * 100) + "%";
					}
				)
			),
			React.createElement("div", { "class": "deleteSign", ontouchstart: function () {
					return app.deleteItem(placeId, iconId);
				}, onmousedown: function () {
					return app.deleteItem(placeId, iconId);
				} })
		);
	};
};

// ÐºÐ°Ð»Ñ– Ð°Ð´Ñ€Ð°Ð·Ñƒ Ð¿Ñ€Ñ‹ÑÐ²Ð¾Ñ–Ñ†ÑŒ left Ñ– top Ñ‚Ð¾ Ñ‡Ð°Ð¼ÑƒÑÑŒÑ†Ñ– Ð½Ðµ Ð¿Ñ€Ð°Ñ†ÑƒÐµ transition
// TODO: Ñ€Ð°Ð·Ð°Ð±Ñ€Ð°Ñ†Ñ†Ð°, Ñ†Ñ– Ñ‘ÑÑŒÑ†ÑŒ ÑÐºÑ– Ð· Ð³ÑÑ‚Ñ‹Ñ… Ð´Ð²ÑƒÑ… Ñ€Ð°Ð´ÐºÐ¾Ñž Ð»Ñ–ÑˆÐ½Ñ–?

//

// moving

// dimmering

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Icon.js","/src/ui")

},{"_process":96,"buffer":91,"htmlutils":128,"lodash":114}],149:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");
var UID = require("uid");

module.exports = function (app, local) {

	var Place = app.load(require("ui/Place"));

	return function () {
		var marked2$0 = [pan].map(regeneratorRuntime.mark);

		var id = UID();

		function pan(next) {
			var lastDeltaX, page, size, deviceid, data, deltaX, rect, device, initialShift, shift;
			return regeneratorRuntime.wrap(function pan$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						lastDeltaX = undefined, page = undefined, size = undefined;
						deviceid = app.activeDeviceId;

						app.placesShifts.defineProperty(deviceid);
						local.placesPages.defineProperty(deviceid);
						context$3$0.prev = 4;
						data = undefined;

					case 6:
						context$3$0.next = 8;
						return next;

					case 8:
						if (!(data = context$3$0.sent)) {
							context$3$0.next = 25;
							break;
						}

						if (data.lastDeltaX) lastDeltaX = data.lastDeltaX;
						deltaX = data.deltaX;
						rect = app.menuElement.getBoundingClientRect();
						device = app.getDevice(deviceid);

						if (!(!device || !device.content)) {
							context$3$0.next = 15;
							break;
						}

						return context$3$0.abrupt("return");

					case 15:
						size = Math.ceil(Object.keys(device.content).length / (app.pageWidth * app.pageHeight));

						if (!(size == 0)) {
							context$3$0.next = 18;
							break;
						}

						return context$3$0.abrupt("continue", 23);

					case 18:
						page = local.placesPages[deviceid] || 0;
						initialShift = -page * rect.width;
						shift = data.deltaX;

						if (shift > 0 && page == 0 || shift < 0 && page == size - 1) shift /= 3;
						app.placesShifts[deviceid] = shift;

					case 23:
						context$3$0.next = 6;
						break;

					case 25:
						if (lastDeltaX) {
							if (lastDeltaX > 0 && page > 0) local.placesPages[deviceid] = page - 1;else if (lastDeltaX < 0 && page < size - 1) local.placesPages[deviceid] = page + 1;
						}

					case 26:
						context$3$0.prev = 26;

						app.placesShifts[deviceid] = 0;
						return context$3$0.finish(26);

					case 29:
					case "end":
						return context$3$0.stop();
				}
			}, marked2$0[0], this, [[4,, 26, 29]]);
		}

		return React.createElement(
			"div",
			null,
			React.createElement(
				"style",
				{ "class": "style" },
				function () {
					return "\n\t\t\t\t." + id + " .icon {\n\t\t\t\t\twidth: " + 100 / app.pageWidth + "%;\n\t\t\t\t\theight: " + 100 / app.pageHeight + "%;\n\t\t\t\t}\n\t\t\t";
				}
			),
			React.createElement(
				"div",
				{ "class": "top" },
				React.createElement(
					"span",
					{ "class": "top_self" },
					React.createElement(
						htmlutils.Centered,
						null,
						function () {
							return app.caption;
						}
					)
				)
			),
			React.createElement("div", { "class": function () {
					return "menu " + id + " " + app.activeDeviceId;
				},
				onpan: regeneratorRuntime.mark(function callee$2$0(data) {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!(data.detail.direction == "left" || data.detail.direction == "right")) {
									context$3$0.next = 3;
									break;
								}

								data.stopPropagation();
								return context$3$0.delegateYield(pan(event.detail.next), "t0", 3);

							case 3:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this);
				}),
				oncreate: function () {
					var _this = this;

					app.menuElement = this;
					var shown = Object.create(null);
					ra(function () {
						var id = app.activeDeviceId;
						if (!id || shown[id]) return;
						app.placesShifts.defineProperty(id);
						local.placesPages.defineProperty(id);
						shown[id] = true;

						_this.appendChild(React.createElement(Place, { placeId: id, placeDescr: ra(function () {
								return app.getDevice(id);
							}) }));
					});
				}
			}),
			React.createElement(
				"div",
				{ "class": "bottom" },
				React.createElement("div", { "class": "help",
					onpress: function () {
						return app.dialog = "ServiceDialog";
					}
				}),
				React.createElement("div", { "class": "logo",
					onpress: function () {
						return app.dialog = "ContextMenu";
					},
					ontap: function (event) {
						if (event.shiftKey || event.srcEvent && event.srcEvent.shiftKey) return app.dialog = "ContextMenu";
						if (event.ctrlKey || event.srcEvent && event.srcEvent.ctrlKey) return app.dialog = "SearchItems";
						app.editing = false;
						app.dialog = "";
						app.go(app.main);
					}
				}),
				React.createElement("div", { "class": "back",
					ontouch: function () {
						if (app.editing) app.editing = false;else if (app.dialog) app.dialog = "";else app.back();
					}
				})
			)
		);
	};
};

// TODO: no transition while panning
// TODO: remove <Place/> when such a place is actually removed from database

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/MainScreen.js","/src/ui")

},{"_process":96,"buffer":91,"htmlutils":128,"ui/Place":151,"uid":155}],150:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var Application = require("ui/Application");

module.exports = function (_ref) {
	var IconTemplates = _ref.IconTemplates;
	return React.createElement(
		"span",
		null,
		React.createElement(
			"style",
			null,
			" ",
			".application { position: fixed !important; } } ",
			" "
		),
		React.createElement(Application, { IconTemplates: IconTemplates })
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/OneApp.js","/src/ui")

},{"_process":96,"buffer":91,"ui/Application":142}],151:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app, local) {

	var Icon = app.load(require("ui/Icon"));

	return function (_ref) {
		var placeId = _ref.placeId;
		var placeDescr = _ref.placeDescr;

		var ids = ra(function () {
			var content = placeDescr.get("content");
			return ra.Array(lodash.keys(content).sort(function (a, b) {
				return lu.compare(content[a].index, content[b].index);
			}));
		});
		var content = ra.map(ids, function (iconId, position) {
			return React.createElement(Icon, {
				placeId: placeId,
				iconId: iconId,
				position: position,
				iconDescr: ra(function () {
					return app.getDevice(iconId);
				})
			});
		});
		return React.createElement(
			"div",
			null,
			React.createElement(
				"style",
				null,
				"\n\t\t\t\t." + placeId + " .place." + placeId + " {\n\t\t\t\t\tdisplay: initial;\n\t\t\t\t}\n\t\t\t"
			),
			React.createElement(
				"div",
				{ "class": "place " + placeId, style: {
						transform: function transform() {
							return "translateX( " + (-(local.placesPages[placeId] || 0) * app.menuElement.getBoundingClientRect().width + app.placesShifts[placeId] || 0) + "px )";
						} } },
				function () {
					return content;
				}
			)
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Place.js","/src/ui")

},{"_process":96,"buffer":91,"ui/Icon":148}],152:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var DL = require("DamerauLevenshtein");

var notAChar = function notAChar(char) {
	return char <= " " || char == "-";
};

var fuzzy = function fuzzy(mask, text) {
	return DL(mask.toUpperCase(), text.toUpperCase(), {
		replace: Infinity,
		"delete": function _delete(char) {
			return notAChar(char) ? 0.01 : Infinity;
		},
		insert: function insert(char) {
			return notAChar(char) ? 0.01 : 1;
		},
		transpose: 1 });
};

function watch(data, cb) {
	var v = undefined;
	return function () {
		if (v == null) ra.detach(function () {
			v = ra(data);
			ra(function () {
				v.valueOf();
				cb();
			});
		});
		return v.valueOf();
	};
}

module.exports = function (app) {
	var opts = undefined,
	    $ = {};

	var SearchItem = function SearchItem(_ref) {
		var placeId = _ref.placeId;
		return React.createElement(
			"div",
			{ "class": "searchItem " + placeId, onscrolltap: function () {
					return opts.goto(placeId);
				} },
			React.createElement(
				"span",
				{ "class": "caption" },
				function () {
					return opts.placeInfos[placeId].caption;
				}
			),
			React.createElement(
				"span",
				{ "class": "places" },
				function () {
					return opts.placeInfos[placeId].ptext;
				}
			),
			React.createElement("span", { "class": "cmdDeleteFromProgram" }),
			React.createElement("span", { "class": "cmdAppend" })
		);
	};

	opts = ra(Object.defineProperties({
		goto: function goto(id) {
			if (!id) return;
			var placeInfo = opts.placeInfos[id];
			~(app.searchAction || app.go)(id, placeInfo && placeInfo.places);
		} }, {
		deviceIds: {
			get: function () {
				return ra.Array(app.deviceIds.filter(function (id) {
					return id != app.main;
				}));
			},
			configurable: true,
			enumerable: true
		},
		placeInfos: {
			get: function () {
				var cache = Object.create(null);
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this.deviceIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var id = _step.value;

						var info = app.getDevice(id);
						cache[id] = {
							info: info,
							caption: app.getMessage(info),
							places: [] };
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator["return"]) {
							_iterator["return"]();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					var _loop = function () {
						var id = _step2.value;

						lodash.forEach(cache[id].info.content, function (_, key) {
							return cache[key] && cache[key].places.push(id);
						});
					};

					for (var _iterator2 = this.deviceIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						_loop();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}

				var ret = Object.create(null);
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = this.deviceIds[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var id = _step3.value;

						var c = cache[id];
						var ptext = c.places.map(function (id) {
							return cache[id].caption;
						}).join(", ");
						if (ptext) ptext = "(" + ptext + ")";
						ret[id] = { id: id, caption: c.caption || "<***>", places: c.places, ptext: ptext };
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
							_iterator3["return"]();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				return ra.JSON(ret);
			},
			configurable: true,
			enumerable: true
		},
		labels: {
			get: function () {
				return ra.keymap(opts.live.deviceIds, function (placeId) {
					return React.createElement(SearchItem, { placeId: placeId });
				});
			},
			configurable: true,
			enumerable: true
		},
		filtered: {
			get: function () {
				var value = $.mask.raValue;
				var arr = [];
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = this.deviceIds.filter(app.searchFilter || Boolean)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var id = _step4.value;

						var i = opts.placeInfos[id];
						var key = [];
						if (value) {
							key.push(fuzzy(value, i.caption),
							// ??? Math.max( ...i.places.map( id => fuzzy( value, opts.placeInfos[ id ].caption ) ) ),
							fuzzy(value, i.caption + " " + i.ptext));
							if (key.every(function (k) {
								return Math.abs(k) == Infinity;
							})) continue;
						}
						key.push(i.caption.toUpperCase());
						arr.push({ id: id, key: key });
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
							_iterator4["return"]();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				return ra.Array(arr.sort(function (a, b) {
					return lodash.zip(a.key, b.key).map(function (pair) {
						var _lu;

						return (_lu = lu).compare.apply(_lu, _toConsumableArray(pair));
					}).reduce(function (a, b) {
						return a || b;
					});
				}).map(function (a) {
					return a.id;
				}));
			},
			configurable: true,
			enumerable: true
		},
		items: {
			get: function () {
				var _this = this;

				return ra.Array(this.filtered.map(function (id) {
					return _this.labels.get(id);
				}));
			},
			configurable: true,
			enumerable: true
		}
	}));
	window._search = opts;
	return React.createElement(
		"div",
		{
			ondialogshow: function () {
				$.scroller && $.scroller.refresh();
				// TODO: Ñ€Ð°Ð·Ð°Ð±Ñ€Ð°Ñ†Ñ†Ð°, Ð° Ñ†Ñ– Ñ‚Ñ€ÑÐ±Ð° Ð·Ð°Ñ†Ñ–Ñ€Ð°Ñ†ÑŒ Ð¿Ð¾ÑˆÑƒÐº?
				$.mask.raValue = "";
			}
		},
		React.createElement(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					opts.goto(opts.filtered[0]);
				}
			},
			React.createElement("input", { name: "mask", type: "text", autofocus: "autofocus", oncreate: function (event) {
					return $.mask = event.target;
				} }),
			React.createElement(
				"div",
				{ "class": "scroll", oncreate: function (event) {
						return $.scroll = event.target;
					} },
				React.createElement(
					"div",
					null,
					React.createElement(
						"div",
						{ "class": "items" },
						watch(function () {
							return opts.items;
						}, function () {
							return setTimeout(function () {
								if (!$.scroller) $.scroller = new (require("iscroll"))($.scroll, {
									mouseWheel: true,
									scrollbars: true,
									tap: "scrolltap" });else $.scroller.refresh();
							}, 100);
						})
					),
					React.createElement("div", { "class": "scrollAreaBottomFiller" })
				)
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/SearchItems.js","/src/ui")

},{"DamerauLevenshtein":115,"_process":96,"buffer":91,"iscroll":130}],153:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");

module.exports = function (app) {
	var json = undefined;
	return React.createElement(
		"div",
		{ ondialogshow: function () {
				return json.value = JSON.stringify(app.getDevice(app.activeDeviceId), null, 3);
			} },
		React.createElement(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					var text = json.value.trim() || null;
					try {
						text = text && JSON.parse(text);
					} catch (error) {
						return alert(error);
					}
					debugger;
					if (text) app.saveDevice(app.activeDeviceId, text);
					app.dialog = "";
				}
			},
			React.createElement("textarea", {
				name: "json",
				autofocus: "autofocus",
				oncreate: function (event) {
					return json = event.target;
				},
				style: {
					position: "absolute",
					left: 0,
					right: 0,
					top: "10mm",
					bottom: "15mm",
					fontSize: "50%" }
			}),
			React.createElement(
				"a",
				{
					"class": "save",
					href: "javascript:void(0)",
					target: "_self",
					ontouch: htmlutils.Submit,
					style: {
						position: "absolute",
						display: "block",
						left: 0,
						right: 0,
						height: "10mm",
						bottom: "0" }
				},
				"Save"
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/ServiceDialog.js","/src/ui")

},{"_process":96,"buffer":91,"htmlutils":128}],154:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function () {
		return React.createElement(
			"div",
			{ "class": "startupScreen" },
			React.createElement(
				"p",
				null,
				"Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ Ð² Ð’Ð°Ñˆ",
				React.createElement("br", null),
				"Ð£Ð¼Ð½Ñ‹Ð¹ Ð”Ð¾Ð¼!"
			),
			React.createElement(
				"div",
				{ "class": "templates" },
				React.createElement(
					"p",
					null,
					"ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¼ÐµÑÑ‚Ð¾, Ð³Ð´Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ ÑÑ‚Ð¾Ñ‚ Ð¿ÑƒÐ»ÑŒÑ‚:"
				),
				React.createElement(
					"ul",
					{ "class": "houseTemplates" },
					function () {
						return (app.templates || []).concat([{
							menu: "Ð½Ð°Ñ‡Ð°Ñ‚ÑŒ Ñ Ñ‡Ð¸ÑÑ‚Ð¾Ð³Ð¾ Ð»Ð¸ÑÑ‚Ð°",
							ru: "ÐœÐ¾Ð¹ Ð´Ð¾Ð¼",
							en: "Home",
							type: "place" }]).map(function (houseTemplate) {
							return React.createElement(
								"li",
								{ "class": "houseTemplate", ontouch: function () {
										return app.setTemplate(houseTemplate);
									} },
								houseTemplate.menu || app.getMessage(houseTemplate)
							);
						});
					}
				)
			),
			React.createElement("div", { "class": "loading" })
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/StartupScreen.js","/src/ui")

},{"_process":96,"buffer":91}],155:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var counter = 0;

module.exports = function uid(obj) {
	var i = (++counter).toString(36);
	var r = parseInt(Math.random().toString().slice(2, 17)).toString(36);
	var id = (r.length + 9).toString(36) + r + i;
	if (obj == null) return id;else {
		obj.uid = id;
		return obj;
	}
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/uid.js","/src")

},{"_process":96,"buffer":91}],156:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
post /devices {"P":1}
*/

"use strict";

function checkBrowserFunctions() {
	var ret = true && typeof HTMLTemplateElement != "undefined" && HTMLTemplateElement;
	return !!ret;
}

if (!checkBrowserFunctions()) {
	window.__UNSUPPORTED__();
	throw new Error("unsupported");
}

var performance = global.performance || global.Date;
var startUpTime = performance.now();

require("browser-nexttick");
require("platform");
require("htmlpolyfill");
require("track");
require("gesture");

global.lu = require("localUtils");
global.ra = require("ra");
global.co = require("co");
global.lodash = require("lodash");
require("colors");

var UID = require("uid");
var httpClient = require("httpClient");

function preventDefault(event) {
	if (event.target && event.target.getAttribute("rel") == "external") return;
	var _arr = [HTMLInputElement, HTMLTextAreaElement, HTMLOptionElement, HTMLButtonElement];
	for (var _i = 0; _i < _arr.length; _i++) {
		var C = _arr[_i];
		if (event.target instanceof C) return;
	} // attempt to use native scrolling - unsuccessfull
	// let C = event.target
	// while ( C && C.classList ) {
	// 	if ( C.classList.contains( `scroll` ) )
	// 		return
	// 	C = C.parentNode
	// }
	event.preventDefault();
}

var _arr2 = ["touchstart", "touchmove", "touchend", "touchcancel"];
for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	var type = _arr2[_i2];
	window.addEventListener(type, preventDefault);
}global.LOG = function (str) {
	// if ( String( str ) == `undefined` )
	// 	debugger
	console.log.apply(console, arguments);
	global._ALERT && global._ALERT(str);
	var xhr = new XMLHttpRequest();
	xhr.open("POST", "/log?" + encodeURIComponent(str));
	xhr.onerror = lodash.noop;
	xhr.send();
	return str;
};

window.addEventListener("error", function onError(e) {
	if (!e.message.match(404) && !onError.processing) {
		onError.processing = true;
		try {
			LOG("" + e.message.red + " at " + e.lineno + ":" + e.colno + " in " + e.filename);
		} finally {
			onError.processing = false;
		}
	}
});

var onerror = window.onerror;
window.onerror = function (message, url, line, column, error) {
	var ret = undefined;
	if (error) {
		LOG("stack: " + error.stack);
	}
	if (onerror) {
		try {
			window.onerror = onerror;
			ret = onerror.apply(this, arguments);
		} finally {
			onerror = window.onerror;
		}
	}
	return ret;
};

// require( `touchLog` )
// require( `touchShow` )
// require( `touches` )

global.React = require("components");

function script(text) {
	var script = document.createElement("script");
	script.appendChild(document.createTextNode(text));
	return script;
}

co.go(regeneratorRuntime.mark(function callee$0$0() {
	var html, data, tmp, children, i;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				html = cacheUrlResource("./main.html");
				context$1$0.next = 3;
				return html;

			case 3:
				html = context$1$0.sent;
				data = document.createDocumentFragment();
				tmp = document.createElement("div");

				tmp.innerHTML = html;
				tmp = tmp.children[0];
				children = [];

				for (i = 0; i < tmp.childNodes.length; ++i) {
					children.push(tmp.childNodes[i]);
				}children.forEach(function (c) {
					return tmp.removeChild(c);
				});
				children.forEach(function (c) {
					if (c instanceof HTMLScriptElement) c = script(c.innerHTML);
					data.appendChild(c);
				});

				document.body.appendChild(data);

			case 13:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
}));

// window.addEventListener( // TODO: Ð²Ñ‹Ð´Ð°Ð»Ñ–Ñ†ÑŒ Ð¿Ð°ÑÑŒÐ»Ñ Ð²Ñ‹ÑÑ‚Ð°Ð²Ñ‹. ÐÐ°Ð´Ñ‚Ð° ÑÑ‚Ñ€Ð°ÑˆÐ½Ð° ÑÐ½Ð¾ Ð´Ð·Ñ‘Ñ€Ð³Ð°ÐµÑ†Ñ†Ð° Ð¿Ñ€Ñ‹ Ð¿ÐµÑ€Ð°Ð·Ð°Ð³Ñ€ÑƒÐ·Ñ†Ñ‹
// 	`message`,
// 	event => {
// 		if ( event && event.data && event.data.what == `urlResourceUpdated` )
// 			window.setTimeout(
// 				() => window.location.reload(),
// 				1000
// 			)
// 	},
// 	false
// )

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/webpage.js","/src")

},{"_process":96,"browser-nexttick":122,"buffer":91,"co":123,"colors":106,"components":124,"gesture":126,"htmlpolyfill":127,"httpClient":129,"localUtils":132,"lodash":114,"platform":135,"ra":136,"track":139,"uid":155}],157:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ra = require("ra");

var windowSize = ra.clean({
	width: 1,
	height: 1,
	ppmm: 1,
	widthmm: 1,
	heightmm: 1,
	pixelRatio: 1,
	orientation: 0,
	layout: "vertical",
	window: "browser" }).setName("windowSize");

window.addEventListener("resize", updateSize);

var orientations = {};

var cm = document.createElement("div");
cm.style.left = "0";
cm.style.top = "0";
cm.style.width = "10cm";
cm.style.height = "10cm";
cm.style.position = "fixed";
cm.style.zIndex = "-9999";
document.body.appendChild(cm);
var ppmm = cm.clientWidth / 100;
document.body.removeChild(cm);

updateSize();

function updateSize() {

	var width = window.innerWidth;
	var height = window.innerHeight;

	var orientation = (window.orientation || 0) % 360;
	if (orientation < 0) orientation += 360;

	windowSize.width = width;
	windowSize.height = height;
	windowSize.ppmm = ppmm;
	windowSize.widthmm = width / ppmm;
	windowSize.heightmm = height / ppmm;
	windowSize.pixelRatio = window.devicePixelRatio || 1;
	windowSize.orientation = orientation;
	windowSize.layout = width <= height ? "vertical" : "horizontal";
	windowSize.window = window.navigator.standalone ? "app" : "browser";
}

module.exports = windowSize;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/windowSize.js","/src")

},{"_process":96,"buffer":91,"ra":136}],158:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require( "webpage" )
require( "ui/OneApp" )
global.require = function r( name ) {
					global.require = null
					try {
						return require.apply( this, arguments )
					}
					finally {
						global.require = r
					}
				}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/tmp/index.js","/tmp")

},{"_process":96,"buffer":91,"ui/OneApp":150,"webpage":156}]},{},[90,158])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9saWIvYmFiZWwvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY3R4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmVudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZncuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLml0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmtleW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLm1peC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5wYXJ0aWFsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnJlZGVmLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnJlcGxhY2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnNldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnN0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdHJpbmctcGFkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnN0cmluZy1yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudGFzay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC50aHJvd3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudWlkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnVuc2NvcGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQud2tzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnN0YXRpY3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc3RhdGljcy1hY2NlcHQtcHJpbWl0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWdleHAuZXNjYXBlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubHBhZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5ycGFkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9qcy5hcnJheS5zdGF0aWNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWxpZnkvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvY3VzdG9tL3RyYXAuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9jdXN0b20vemFsZ28uanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9leHRlbmRTdHJpbmdQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL21hcHMvYW1lcmljYS5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL21hcHMvcmFpbmJvdy5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL21hcHMvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvbWFwcy96ZWJyYS5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL3N0eWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL3N5c3RlbS9zdXBwb3J0cy1jb2xvcnMuanMiLCJub2RlX21vZHVsZXMvaHR0cC1zdGF0dXMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9kaXN0L2xvZGFzaC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9EYW1lcmF1TGV2ZW5zaHRlaW4uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvSlNPTmxvY2FsLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL0xPRy5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9QaW5nUG9uZ0pTT04uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvV2ViUXVldWUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvV2ViU29ja2V0VG9KU09OLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2FwcC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9icm93c2VyLW5leHR0aWNrLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvbXBvbmVudHMuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvZGV2ZGIuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvZ2VzdHVyZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9odG1scG9seWZpbGwuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvaHRtbHV0aWxzLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2h0dHBDbGllbnQuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvaXNjcm9sbC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9sYXRlci5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9sb2NhbFV0aWxzLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL25ldHJvL2RldmljZUFjdGlvbnMuanMiLCJzcmMvbmV0cm8vZGV2aWNlVHlwZXMuanNvbiIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9wbGF0Zm9ybS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9yYS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9zY2hlZHVsZXIuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvc3BhcnNlcXVldWUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdHJhY2suanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQWRkRXhpc3RpbmdJdGVtLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL0FkZE1lbnUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQXBwbGljYXRpb24uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQXNrTmV3TmFtZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9Bc2tUb0xpbmtEZXZpY2UuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQnV0dG9uLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL0NvbW1hbmQuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQ29udGV4dE1lbnUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvSWNvbi5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9NYWluU2NyZWVuLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL09uZUFwcC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9QbGFjZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9TZWFyY2hJdGVtcy5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9TZXJ2aWNlRGlhbG9nLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1N0YXJ0dXBTY3JlZW4uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWlkLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3dlYnBhZ2UuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvd2luZG93U2l6ZS5qcyIsInRtcC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNaQTs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbENBO0FBQ0E7QUFDQTs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNOQTtBQUNBO0FBQ0E7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUkE7QUFDQTs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNKQTtBQUNBOzs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BqQkE7QUFDQTs7Ozs7QUNEQTtBQUNBOzs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdDRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDem5OQSxTQUFTLE9BQU8sQ0FBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUc7QUFDbkMsS0FBSSxJQUFJLEdBQUcsT0FBTyxLQUFLLFlBQVksR0FBRyxLQUFLLENBQUUsRUFBRSxDQUFFLEdBQUcsS0FBSyxDQUFBO0FBQ3pELFFBQU8sT0FBTyxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFFLEdBQUcsSUFBSSxDQUFBO0NBQ2xFOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFpQjtLQUFmLEtBQUssZ0NBQUcsQ0FBQzs7QUFDbkMsS0FBSSxDQUFDLEdBQUcsRUFBRSxDQUFBO0FBQ1YsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUc7QUFDdEMsR0FBQyxDQUFFLENBQUMsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLENBQUE7QUFDaEMsT0FBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO0FBQ25DLElBQUMsQ0FBRSxDQUFDLENBQUUsQ0FBRSxDQUFDLENBQUUsR0FDVixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQ2YsQ0FBQyxHQUNBLENBQUMsSUFBSSxDQUFDLEdBQ1AsQ0FBQyxDQUFFLENBQUMsQ0FBRSxDQUFFLENBQUMsR0FBRyxDQUFDLENBQUUsR0FBRyxPQUFPLENBQUUsS0FBSyxZQUFZLEVBQUUsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLENBQUUsR0FDeEQsQ0FBQyxJQUFJLENBQUMsR0FDUCxDQUFDLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxDQUFFLENBQUMsQ0FBRSxHQUFHLE9BQU8sQ0FBRSxLQUFLLFlBQVksRUFBRSxDQUFFLENBQUMsR0FBRyxDQUFDLENBQUUsQ0FBRSxHQUN4RCxJQUFJLENBQUMsR0FBRyxDQUNULENBQUMsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLENBQUUsQ0FBQyxDQUFFLEdBQUcsT0FBTyxDQUFFLEtBQUssWUFBWSxFQUFFLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxDQUFFLEVBQ3pELENBQUMsQ0FBRSxDQUFDLENBQUUsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLEdBQUcsT0FBTyxDQUFFLEtBQUssWUFBWSxFQUFFLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxDQUFFLEVBQ3pELENBQUMsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxJQUFLLEVBQUUsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLElBQUksRUFBRSxDQUFFLENBQUMsR0FBRyxDQUFDLENBQUUsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFFLEtBQUssYUFBYSxFQUFFLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxFQUFFLEVBQUUsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLENBQUUsQ0FBQSxBQUFFLEVBQ2hILEFBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLElBQUksRUFBRSxDQUFFLENBQUMsR0FBRyxDQUFDLENBQUUsSUFBSSxFQUFFLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxJQUFJLEVBQUUsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLEdBQ3pFLENBQUMsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFFLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxHQUFHLE9BQU8sQ0FBRSxLQUFLLGVBQWUsRUFBRSxDQUFFLENBQUMsR0FBRyxDQUFDLENBQUUsRUFBRSxF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QUMsSUFBSSxHQUFHLEdBQUcsQ0FBQTtBQUNmLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFBO0FBQ2pCLE1BQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFBO0FBQ2xCLE1BQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFBO0FBQ3JCLE1BQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFBO0FBQ2xCLE1BQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxRQUFRLEVBQUU7O0lBQWdCLEVBQUUsQ0FBQTtBQUMzQyxNQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUUsQ0FBQyxRQUFRLENBQUUsSUFBSSxDQUFFLENBQUMsWUFBWSxFQUFFLENBQUE7QUFDNUUsTUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUE7QUFDbEIsTUFBSSxLQUFLLFlBQUEsQ0FBQTtBQUNULE1BQUssQ0FBRSxLQUFLLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBRSxTQUFTLENBQUUsQ0FBQSxJQUFNLEtBQUssQ0FBQyxTQUFTLEVBQ3pELEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFFLElBQUksQ0FBRSxDQUFBO0FBQzdCLE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFBO0FBQ3JCLE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFBO0FBQ3BCLE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFBO0FBQ3JCLE1BQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFBO0FBQzNCLE1BQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFBO0FBQ3RCLE1BQUssTUFBTSxFQUFHO0FBQ2IsT0FBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUE7QUFDbkIsT0FBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUE7QUFDbEIsT0FBSSxDQUFDLFNBQVMsR0FBRyxVQUFBLE1BQU07V0FBSSxPQUFLLFFBQVEsQ0FBQyxJQUFJLENBQUUsTUFBTSxDQUFFO0lBQUEsQ0FBQTtHQUN2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ZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3IvcnVudGltZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC9wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTsiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyICQgPSByZXF1aXJlKCcuLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSAkLnRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSAkLnRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAkLnRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59OyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciAkICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGN0eCA9IHJlcXVpcmUoJy4vJC5jdHgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IE9iamVjdCgkLmFzc2VydERlZmluZWQoJHRoaXMpKVxuICAgICAgLCBzZWxmICAgPSAkLkVTNU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gJC50b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBBcnJheShsZW5ndGgpIDogSVNfRklMVEVSID8gW10gOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnMSwgbXNnMil7XG4gIGlmKCFjb25kaXRpb24pdGhyb3cgVHlwZUVycm9yKG1zZzIgPyBtc2cxICsgbXNnMiA6IG1zZzEpO1xufVxuYXNzZXJ0LmRlZiA9ICQuYXNzZXJ0RGVmaW5lZDtcbmFzc2VydC5mbiA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoISQuaXNGdW5jdGlvbihpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbmFzc2VydC5vYmogPSBmdW5jdGlvbihpdCl7XG4gIGlmKCEkLmlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5hc3NlcnQuaW5zdCA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgVHlwZUVycm9yKG5hbWUgKyBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XG4gIHJldHVybiBpdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydDsiLCJ2YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGVudW1LZXlzID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2Upe1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICB2YXIgVCA9IE9iamVjdCgkLmFzc2VydERlZmluZWQodGFyZ2V0KSlcbiAgICAsIGwgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpID0gMTtcbiAgd2hpbGUobCA+IGkpe1xuICAgIHZhciBTICAgICAgPSAkLkVTNU9iamVjdChhcmd1bWVudHNbaSsrXSlcbiAgICAgICwga2V5cyAgID0gZW51bUtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailUW2tleSA9IGtleXNbaisrXV0gPSBTW2tleV07XG4gIH1cbiAgcmV0dXJuIFQ7XG59OyIsInZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgVEFHICAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLCB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuZnVuY3Rpb24gY29mKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn1cbmNvZi5jbGFzc29mID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVDtcbiAgcmV0dXJuIGl0ID09IHVuZGVmaW5lZCA/IGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6ICdOdWxsJ1xuICAgIDogdHlwZW9mIChUID0gKE8gPSBPYmplY3QoaXQpKVtUQUddKSA9PSAnc3RyaW5nJyA/IFQgOiBjb2YoTyk7XG59O1xuY29mLnNldCA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhJC5oYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpJC5oaWRlKGl0LCBUQUcsIHRhZyk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjb2Y7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjdHggICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIHNhZmUgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmVcbiAgLCBhc3NlcnQgICA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKVxuICAsIGZvck9mICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc3RlcCAgICAgPSByZXF1aXJlKCcuLyQuaXRlcicpLnN0ZXBcbiAgLCBoYXMgICAgICA9ICQuaGFzXG4gICwgc2V0ICAgICAgPSAkLnNldFxuICAsIGlzT2JqZWN0ID0gJC5pc09iamVjdFxuICAsIGhpZGUgICAgID0gJC5oaWRlXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBpc09iamVjdFxuICAsIElEICAgICAgID0gc2FmZSgnaWQnKVxuICAsIE8xICAgICAgID0gc2FmZSgnTzEnKVxuICAsIExBU1QgICAgID0gc2FmZSgnbGFzdCcpXG4gICwgRklSU1QgICAgPSBzYWZlKCdmaXJzdCcpXG4gICwgSVRFUiAgICAgPSBzYWZlKCdpdGVyJylcbiAgLCBTSVpFICAgICA9ICQuREVTQyA/IHNhZmUoJ3NpemUnKSA6ICdzaXplJ1xuICAsIGlkICAgICAgID0gMDtcblxuZnVuY3Rpb24gZmFzdEtleShpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBJRCkpe1xuICAgIC8vIGNhbid0IHNldCBpZCB0byBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBpZFxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBvYmplY3QgaWRcbiAgICBoaWRlKGl0LCBJRCwgKytpZCk7XG4gIC8vIHJldHVybiBvYmplY3QgaWQgd2l0aCBwcmVmaXhcbiAgfSByZXR1cm4gJ08nICsgaXRbSURdO1xufVxuXG5mdW5jdGlvbiBnZXRFbnRyeSh0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT0gJ0YnKXJldHVybiB0aGF0W08xXVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0W0ZJUlNUXTsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24oTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgZnVuY3Rpb24gQygpe1xuICAgICAgdmFyIHRoYXQgICAgID0gYXNzZXJ0Lmluc3QodGhpcywgQywgTkFNRSlcbiAgICAgICAgLCBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHNldCh0aGF0LCBPMSwgJC5jcmVhdGUobnVsbCkpO1xuICAgICAgc2V0KHRoYXQsIFNJWkUsIDApO1xuICAgICAgc2V0KHRoYXQsIExBU1QsIHVuZGVmaW5lZCk7XG4gICAgICBzZXQodGhhdCwgRklSU1QsIHVuZGVmaW5lZCk7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH1cbiAgICByZXF1aXJlKCcuLyQubWl4JykoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXRbTzFdLCBlbnRyeSA9IHRoYXRbRklSU1RdOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdFtGSVJTVF0gPSB0aGF0W0xBU1RdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXRbTzFdW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdFtGSVJTVF0gPT0gZW50cnkpdGhhdFtGSVJTVF0gPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXRbTEFTVF0gPT0gZW50cnkpdGhhdFtMQVNUXSA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0sIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzW0ZJUlNUXSl7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZigkLkRFU0MpJC5zZXREZXNjKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5kZWYodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0W0xBU1RdID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdFtMQVNUXSwgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdFtGSVJTVF0pdGhhdFtGSVJTVF0gPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9ICdGJyl0aGF0W08xXVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gIHNldEl0ZXI6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgcmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgazoga2luZH0pO1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXG4gICAgICAgICwga2luZCAgPSBpdGVyLmtcbiAgICAgICAgLCBlbnRyeSA9IGl0ZXIubDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIWl0ZXIubyB8fCAhKGl0ZXIubCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogaXRlci5vW0ZJUlNUXSkpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICBpdGVyLm8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgZm9yT2YgPSByZXF1aXJlKCcuLyQuZm9yLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICAkZGVmKCRkZWYuUCwgTkFNRSwge1xuICAgIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3JPZih0aGlzLCBmYWxzZSwgYXJyLnB1c2gsIGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHNhZmUgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlXG4gICwgYXNzZXJ0ICAgID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpXG4gICwgZm9yT2YgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgX2hhcyAgICAgID0gJC5oYXNcbiAgLCBpc09iamVjdCAgPSAkLmlzT2JqZWN0XG4gICwgaGlkZSAgICAgID0gJC5oaWRlXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBpc09iamVjdFxuICAsIGlkICAgICAgICA9IDBcbiAgLCBJRCAgICAgICAgPSBzYWZlKCdpZCcpXG4gICwgV0VBSyAgICAgID0gc2FmZSgnd2VhaycpXG4gICwgTEVBSyAgICAgID0gc2FmZSgnbGVhaycpXG4gICwgbWV0aG9kICAgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKVxuICAsIGZpbmQgICAgICA9IG1ldGhvZCg1KVxuICAsIGZpbmRJbmRleCA9IG1ldGhvZCg2KTtcbmZ1bmN0aW9uIGZpbmRGcm96ZW4oc3RvcmUsIGtleSl7XG4gIHJldHVybiBmaW5kKHN0b3JlLmFycmF5LCBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufVxuLy8gZmFsbGJhY2sgZm9yIGZyb3plbiBrZXlzXG5mdW5jdGlvbiBsZWFrU3RvcmUodGhhdCl7XG4gIHJldHVybiB0aGF0W0xFQUtdIHx8IGhpZGUodGhhdCwgTEVBSywge1xuICAgIGFycmF5OiBbXSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSl7XG4gICAgICB2YXIgZW50cnkgPSBmaW5kRnJvemVuKHRoaXMsIGtleSk7XG4gICAgICBpZihlbnRyeSlyZXR1cm4gZW50cnlbMV07XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSl7XG4gICAgICByZXR1cm4gISFmaW5kRnJvemVuKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgdmFyIGVudHJ5ID0gZmluZEZyb3plbih0aGlzLCBrZXkpO1xuICAgICAgaWYoZW50cnkpZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgIGVsc2UgdGhpcy5hcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSxcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleCh0aGlzLmFycmF5LCBmdW5jdGlvbihpdCl7XG4gICAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgICAgfSk7XG4gICAgICBpZih+aW5kZXgpdGhpcy5hcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuICEhfmluZGV4O1xuICAgIH1cbiAgfSlbTEVBS107XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24oTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgZnVuY3Rpb24gQygpe1xuICAgICAgJC5zZXQoYXNzZXJ0Lmluc3QodGhpcywgQywgTkFNRSksIElELCBpZCsrKTtcbiAgICAgIHZhciBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGlzW0FEREVSXSwgdGhpcyk7XG4gICAgfVxuICAgIHJlcXVpcmUoJy4vJC5taXgnKShDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKCFpc0V4dGVuc2libGUoa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gX2hhcyhrZXksIFdFQUspICYmIF9oYXMoa2V5W1dFQUtdLCB0aGlzW0lEXSkgJiYgZGVsZXRlIGtleVtXRUFLXVt0aGlzW0lEXV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIWlzRXh0ZW5zaWJsZShrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBfaGFzKGtleSwgV0VBSykgJiYgX2hhcyhrZXlbV0VBS10sIHRoaXNbSURdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICBpZighaXNFeHRlbnNpYmxlKGFzc2VydC5vYmooa2V5KSkpe1xuICAgICAgbGVha1N0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2hhcyhrZXksIFdFQUspIHx8IGhpZGUoa2V5LCBXRUFLLCB7fSk7XG4gICAgICBrZXlbV0VBS11bdGhhdFtJRF1dID0gdmFsdWU7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgbGVha1N0b3JlOiBsZWFrU3RvcmUsXG4gIFdFQUs6IFdFQUssXG4gIElEOiBJRFxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgQlVHR1kgPSByZXF1aXJlKCcuLyQuaXRlcicpLkJVR0dZXG4gICwgZm9yT2YgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBzcGVjaWVzID0gcmVxdWlyZSgnLi8kLnNwZWNpZXMnKVxuICAsIGFzc2VydEluc3RhbmNlID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLmluc3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSAkLmdbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIGZ1bmN0aW9uIGZpeE1ldGhvZChLRVksIENIQUlOKXtcbiAgICBpZigkLkZXKXtcbiAgICAgIHZhciBtZXRob2QgPSBwcm90b1tLRVldO1xuICAgICAgcmVxdWlyZSgnLi8kLnJlZGVmJykocHJvdG8sIEtFWSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIHZhciByZXN1bHQgPSBtZXRob2QuY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gQ0hBSU4gPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmKCEkLmlzRnVuY3Rpb24oQykgfHwgIShJU19XRUFLIHx8ICFCVUdHWSAmJiBwcm90by5mb3JFYWNoICYmIHByb3RvLmVudHJpZXMpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3IoTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVxdWlyZSgnLi8kLm1peCcpKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdCAgPSBuZXcgQ1xuICAgICAgLCBjaGFpbiA9IGluc3RbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKVxuICAgICAgLCBidWdneVplcm87XG4gICAgLy8gd3JhcCBmb3IgaW5pdCBjb2xsZWN0aW9ucyBmcm9tIGl0ZXJhYmxlXG4gICAgaWYoIXJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgQyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCAgICAgPSBuZXcgQmFzZVxuICAgICAgICAgICwgaXRlcmFibGUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBpZigkLkZXKXByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgSVNfV0VBSyB8fCBpbnN0LmZvckVhY2goZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgYnVnZ3laZXJvID0gMSAvIGtleSA9PT0gLUluZmluaXR5O1xuICAgIH0pO1xuICAgIC8vIGZpeCBjb252ZXJ0aW5nIC0wIGtleSB0byArMFxuICAgIGlmKGJ1Z2d5WmVybyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICAvLyArIGZpeCAuYWRkICYgLnNldCBmb3IgY2hhaW5pbmdcbiAgICBpZihidWdneVplcm8gfHwgY2hhaW4gIT09IGluc3QpZml4TWV0aG9kKEFEREVSLCB0cnVlKTtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vJC5jb2YnKS5zZXQoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRkZWYoJGRlZi5HICsgJGRlZi5XICsgJGRlZi5GICogKEMgIT0gQmFzZSksIE8pO1xuICBzcGVjaWVzKEMpO1xuICBzcGVjaWVzKCQuY29yZVtOQU1FXSk7IC8vIGZvciB3cmFwcGVyXG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldEl0ZXIoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwiLy8gT3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYXNzZXJ0RnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYXNzZXJ0JykuZm47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhc3NlcnRGdW5jdGlvbihmbik7XG4gIGlmKH5sZW5ndGggJiYgdGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH0gcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn07IiwidmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgPSAkLmdcbiAgLCBjb3JlICAgICAgID0gJC5jb3JlXG4gICwgaXNGdW5jdGlvbiA9ICQuaXNGdW5jdGlvblxuICAsICRyZWRlZiAgICAgPSByZXF1aXJlKCcuLyQucmVkZWYnKTtcbmZ1bmN0aW9uIGN0eChmbiwgdGhhdCl7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRkZWYuRiA9IDE7ICAvLyBmb3JjZWRcbiRkZWYuRyA9IDI7ICAvLyBnbG9iYWxcbiRkZWYuUyA9IDQ7ICAvLyBzdGF0aWNcbiRkZWYuUCA9IDg7ICAvLyBwcm90b1xuJGRlZi5CID0gMTY7IC8vIGJpbmRcbiRkZWYuVyA9IDMyOyAvLyB3cmFwXG5mdW5jdGlvbiAkZGVmKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHBcbiAgICAsIGlzR2xvYmFsID0gdHlwZSAmICRkZWYuR1xuICAgICwgaXNQcm90byAgPSB0eXBlICYgJGRlZi5QXG4gICAgLCB0YXJnZXQgICA9IGlzR2xvYmFsID8gZ2xvYmFsIDogdHlwZSAmICRkZWYuU1xuICAgICAgICA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pLnByb3RvdHlwZVxuICAgICwgZXhwb3J0cyAgPSBpc0dsb2JhbCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICBpZihpc0dsb2JhbClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gISh0eXBlICYgJGRlZi5GKSAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBpZih0eXBlICYgJGRlZi5CICYmIG93billeHAgPSBjdHgob3V0LCBnbG9iYWwpO1xuICAgIGVsc2UgZXhwID0gaXNQcm90byAmJiBpc0Z1bmN0aW9uKG91dCkgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0ICYmICFvd24pJHJlZGVmKHRhcmdldCwga2V5LCBvdXQpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpJC5oaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihpc1Byb3RvKShleHBvcnRzLnByb3RvdHlwZSB8fCAoZXhwb3J0cy5wcm90b3R5cGUgPSB7fSkpW2tleV0gPSBvdXQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gJGRlZjsiLCJ2YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGRvY3VtZW50ID0gJC5nLmRvY3VtZW50XG4gICwgaXNPYmplY3QgPSAkLmlzT2JqZWN0XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSAkLmdldEtleXMoaXQpXG4gICAgLCBnZXREZXNjICAgID0gJC5nZXREZXNjXG4gICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzO1xuICBpZihnZXRTeW1ib2xzKSQuZWFjaC5jYWxsKGdldFN5bWJvbHMoaXQpLCBmdW5jdGlvbihrZXkpe1xuICAgIGlmKGdldERlc2MoaXQsIGtleSkuZW51bWVyYWJsZSlrZXlzLnB1c2goa2V5KTtcbiAgfSk7XG4gIHJldHVybiBrZXlzO1xufTsiLCJ2YXIgY3R4ICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIGdldCAgPSByZXF1aXJlKCcuLyQuaXRlcicpLmdldFxuICAsIGNhbGwgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XG4gIHZhciBpdGVyYXRvciA9IGdldChpdGVyYWJsZSlcbiAgICAsIGYgICAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBzdGVwO1xuICB3aGlsZSghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpe1xuICAgIGlmKGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpID09PSBmYWxzZSl7XG4gICAgICByZXR1cm4gY2FsbC5jbG9zZShpdGVyYXRvcik7XG4gICAgfVxuICB9XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCl7XG4gICQuRlcgICA9IHRydWU7XG4gICQucGF0aCA9ICQuZztcbiAgcmV0dXJuICQ7XG59OyIsIi8vIEZhc3QgYXBwbHlcbi8vIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICBjYXNlIDU6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsInZhciBhc3NlcnRPYmplY3QgPSByZXF1aXJlKCcuLyQuYXNzZXJ0Jykub2JqO1xuZnVuY3Rpb24gY2xvc2UoaXRlcmF0b3Ipe1xuICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICBpZihyZXQgIT09IHVuZGVmaW5lZClhc3NlcnRPYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbn1cbmZ1bmN0aW9uIGNhbGwoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhc3NlcnRPYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIH0gY2F0Y2goZSl7XG4gICAgY2xvc2UoaXRlcmF0b3IpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cbmNhbGwuY2xvc2UgPSBjbG9zZTtcbm1vZHVsZS5leHBvcnRzID0gY2FsbDsiLCJ2YXIgJGRlZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHJlZGVmICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmJylcbiAgLCAkICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNvZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRpdGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyJylcbiAgLCBTWU1CT0xfSVRFUkFUT1IgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBGRl9JVEVSQVRPUiAgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICAgPSAndmFsdWVzJ1xuICAsIEl0ZXJhdG9ycyAgICAgICA9ICRpdGVyLkl0ZXJhdG9ycztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0Upe1xuICAkaXRlci5jcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICBmdW5jdGlvbiBjcmVhdGVNZXRob2Qoa2luZCl7XG4gICAgZnVuY3Rpb24gJCQodGhhdCl7XG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoYXQsIGtpbmQpO1xuICAgIH1cbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiAkJCh0aGlzKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkJCh0aGlzKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiAkJCh0aGlzKTsgfTtcbiAgfVxuICB2YXIgVEFHICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIHByb3RvICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsIF9uYXRpdmUgID0gcHJvdG9bU1lNQk9MX0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgX2RlZmF1bHQgPSBfbmF0aXZlIHx8IGNyZWF0ZU1ldGhvZChERUZBVUxUKVxuICAgICwgbWV0aG9kcywga2V5O1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKF9uYXRpdmUpe1xuICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9ICQuZ2V0UHJvdG8oX2RlZmF1bHQuY2FsbChuZXcgQmFzZSkpO1xuICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICBjb2Yuc2V0KEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgIC8vIEZGIGZpeFxuICAgIGlmKCQuRlcgJiYgJC5oYXMocHJvdG8sIEZGX0lURVJBVE9SKSkkaXRlci5zZXQoSXRlcmF0b3JQcm90b3R5cGUsICQudGhhdCk7XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCQuRlcpJGl0ZXIuc2V0KHByb3RvLCBfZGVmYXVsdCk7XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gX2RlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9ICQudGhhdDtcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgICAgICAgID8gX2RlZmF1bHQgOiBjcmVhdGVNZXRob2QoS0VZUyksXG4gICAgICB2YWx1ZXM6ICBERUZBVUxUID09IFZBTFVFUyA/IF9kZWZhdWx0IDogY3JlYXRlTWV0aG9kKFZBTFVFUyksXG4gICAgICBlbnRyaWVzOiBERUZBVUxUICE9IFZBTFVFUyA/IF9kZWZhdWx0IDogY3JlYXRlTWV0aG9kKCdlbnRyaWVzJylcbiAgICB9O1xuICAgIGlmKEZPUkNFKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpJHJlZGVmKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRkZWYoJGRlZi5QICsgJGRlZi5GICogJGl0ZXIuQlVHR1ksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG59OyIsInZhciBTWU1CT0xfSVRFUkFUT1IgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgICAgPSBmYWxzZTtcbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtTWU1CT0xfSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgaWYoIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltTWU1CT0xfSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgc2FmZSA9IHRydWU7IH07XG4gICAgYXJyW1NZTUJPTF9JVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY29mICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCBhc3NlcnRPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKS5vYmpcbiAgLCBTWU1CT0xfSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEZGX0lURVJBVE9SICAgICAgID0gJ0BAaXRlcmF0b3InXG4gICwgSXRlcmF0b3JzICAgICAgICAgPSB7fVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuc2V0SXRlcmF0b3IoSXRlcmF0b3JQcm90b3R5cGUsICQudGhhdCk7XG5mdW5jdGlvbiBzZXRJdGVyYXRvcihPLCB2YWx1ZSl7XG4gICQuaGlkZShPLCBTWU1CT0xfSVRFUkFUT1IsIHZhbHVlKTtcbiAgLy8gQWRkIGl0ZXJhdG9yIGZvciBGRiBpdGVyYXRvciBwcm90b2NvbFxuICBpZihGRl9JVEVSQVRPUiBpbiBbXSkkLmhpZGUoTywgRkZfSVRFUkFUT1IsIHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgQlVHR1k6ICdrZXlzJyBpbiBbXSAmJiAhKCduZXh0JyBpbiBbXS5rZXlzKCkpLFxuICBJdGVyYXRvcnM6IEl0ZXJhdG9ycyxcbiAgc3RlcDogZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICAgIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xuICB9LFxuICBpczogZnVuY3Rpb24oaXQpe1xuICAgIHZhciBPICAgICAgPSBPYmplY3QoaXQpXG4gICAgICAsIFN5bWJvbCA9ICQuZy5TeW1ib2xcbiAgICAgICwgU1lNICAgID0gU3ltYm9sICYmIFN5bWJvbC5pdGVyYXRvciB8fCBGRl9JVEVSQVRPUjtcbiAgICByZXR1cm4gU1lNIGluIE8gfHwgU1lNQk9MX0lURVJBVE9SIGluIE8gfHwgJC5oYXMoSXRlcmF0b3JzLCBjb2YuY2xhc3NvZihPKSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oaXQpe1xuICAgIHZhciBTeW1ib2wgID0gJC5nLlN5bWJvbFxuICAgICAgLCBleHQgICAgID0gaXRbU3ltYm9sICYmIFN5bWJvbC5pdGVyYXRvciB8fCBGRl9JVEVSQVRPUl1cbiAgICAgICwgZ2V0SXRlciA9IGV4dCB8fCBpdFtTWU1CT0xfSVRFUkFUT1JdIHx8IEl0ZXJhdG9yc1tjb2YuY2xhc3NvZihpdCldO1xuICAgIHJldHVybiBhc3NlcnRPYmplY3QoZ2V0SXRlci5jYWxsKGl0KSk7XG4gIH0sXG4gIHNldDogc2V0SXRlcmF0b3IsXG4gIGNyZWF0ZTogZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIHByb3RvKXtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLmNyZWF0ZShwcm90byB8fCBJdGVyYXRvclByb3RvdHlwZSwge25leHQ6ICQuZGVzYygxLCBuZXh0KX0pO1xuICAgIGNvZi5zZXQoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClcbiAgLCBjb3JlICAgPSB7fVxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eVxuICAsIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yXG4gICwgbWF4ICAgPSBNYXRoLm1heFxuICAsIG1pbiAgID0gTWF0aC5taW47XG4vLyBUaGUgZW5naW5lIHdvcmtzIGZpbmUgd2l0aCBkZXNjcmlwdG9ycz8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eS5cbnZhciBERVNDID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gMjsgfX0pLmEgPT0gMjtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xudmFyIGhpZGUgPSBjcmVhdGVEZWZpbmVyKDEpO1xuLy8gNy4xLjQgVG9JbnRlZ2VyXG5mdW5jdGlvbiB0b0ludGVnZXIoaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn1cbmZ1bmN0aW9uIGRlc2MoYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gc2ltcGxlU2V0KG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZpbmVyKGJpdG1hcCl7XG4gIHJldHVybiBERVNDID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBkZXNjKGJpdG1hcCwgdmFsdWUpKTtcbiAgfSA6IHNpbXBsZVNldDtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoaXQpe1xuICByZXR1cm4gaXQgIT09IG51bGwgJiYgKHR5cGVvZiBpdCA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaXQgPT0gJ2Z1bmN0aW9uJyk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZChpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn1cblxudmFyICQgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5mdycpKHtcbiAgZzogZ2xvYmFsLFxuICBjb3JlOiBjb3JlLFxuICBodG1sOiBnbG9iYWwuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9jb3JlLWpzLWlzb2JqZWN0XG4gIGlzT2JqZWN0OiAgIGlzT2JqZWN0LFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpdDogZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdDtcbiAgfSxcbiAgdGhhdDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gNy4xLjQgVG9JbnRlZ2VyXG4gIHRvSW50ZWdlcjogdG9JbnRlZ2VyLFxuICAvLyA3LjEuMTUgVG9MZW5ndGhcbiAgdG9MZW5ndGg6IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuICB9LFxuICB0b0luZGV4OiBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24oaXQsIGtleSl7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG4gIH0sXG4gIGNyZWF0ZTogICAgIE9iamVjdC5jcmVhdGUsXG4gIGdldFByb3RvOiAgIE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgREVTQzogICAgICAgREVTQyxcbiAgZGVzYzogICAgICAgZGVzYyxcbiAgZ2V0RGVzYzogICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgc2V0RGVzYzogICAgZGVmaW5lUHJvcGVydHksXG4gIHNldERlc2NzOiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuICBnZXRLZXlzOiAgICBPYmplY3Qua2V5cyxcbiAgZ2V0TmFtZXM6ICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gIGdldFN5bWJvbHM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gIGFzc2VydERlZmluZWQ6IGFzc2VydERlZmluZWQsXG4gIC8vIER1bW15LCBmaXggZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmcgaW4gZXM1IG1vZHVsZVxuICBFUzVPYmplY3Q6IE9iamVjdCxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gJC5FUzVPYmplY3QoYXNzZXJ0RGVmaW5lZChpdCkpO1xuICB9LFxuICBoaWRlOiBoaWRlLFxuICBkZWY6IGNyZWF0ZURlZmluZXIoMCksXG4gIHNldDogZ2xvYmFsLlN5bWJvbCA/IHNpbXBsZVNldCA6IGhpZGUsXG4gIGVhY2g6IFtdLmZvckVhY2hcbn0pO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbmlmKHR5cGVvZiBfX2UgIT0gJ3VuZGVmaW5lZCcpX19lID0gY29yZTtcbmlmKHR5cGVvZiBfX2cgIT0gJ3VuZGVmaW5lZCcpX19nID0gZ2xvYmFsOyIsInZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gJC50b09iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59OyIsInZhciAkcmVkZWYgPSByZXF1aXJlKCcuLyQucmVkZWYnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYyl7XHJcbiAgZm9yKHZhciBrZXkgaW4gc3JjKSRyZWRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn07IiwidmFyICQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgYXNzZXJ0T2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLm9iajtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb3duS2V5cyhpdCl7XG4gIGFzc2VydE9iamVjdChpdCk7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXROYW1lcyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSAkLmdldFN5bWJvbHM7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaW52b2tlID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgYXNzZXJ0RnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYXNzZXJ0JykuZm47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFzc2VydEZ1bmN0aW9uKHRoaXMpXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBwYXJncyAgPSBBcnJheShsZW5ndGgpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBfICAgICAgPSAkLnBhdGguX1xuICAgICwgaG9sZGVyID0gZmFsc2U7XG4gIHdoaWxlKGxlbmd0aCA+IGkpaWYoKHBhcmdzW2ldID0gYXJndW1lbnRzW2krK10pID09PSBfKWhvbGRlciA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgdGhhdCAgICA9IHRoaXNcbiAgICAgICwgX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaiA9IDAsIGsgPSAwLCBhcmdzO1xuICAgIGlmKCFob2xkZXIgJiYgIV9sZW5ndGgpcmV0dXJuIGludm9rZShmbiwgcGFyZ3MsIHRoYXQpO1xuICAgIGFyZ3MgPSBwYXJncy5zbGljZSgpO1xuICAgIGlmKGhvbGRlcilmb3IoO2xlbmd0aCA+IGo7IGorKylpZihhcmdzW2pdID09PSBfKWFyZ3Nbal0gPSBhcmd1bWVudHNbaysrXTtcbiAgICB3aGlsZShfbGVuZ3RoID4gaylhcmdzLnB1c2goYXJndW1lbnRzW2srK10pO1xuICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xufTsiLCJ2YXIgJCAgID0gcmVxdWlyZSgnLi8kJylcclxuICAsIHRwbCA9IFN0cmluZyh7fS5oYXNPd25Qcm9wZXJ0eSlcclxuICAsIFNSQyA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdzcmMnKVxyXG4gICwgX3RvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XHJcblxyXG5mdW5jdGlvbiAkcmVkZWYoTywga2V5LCB2YWwsIHNhZmUpe1xyXG4gIGlmKCQuaXNGdW5jdGlvbih2YWwpKXtcclxuICAgIHZhciBiYXNlID0gT1trZXldO1xyXG4gICAgJC5oaWRlKHZhbCwgU1JDLCBiYXNlID8gU3RyaW5nKGJhc2UpIDogdHBsLnJlcGxhY2UoL2hhc093blByb3BlcnR5LywgU3RyaW5nKGtleSkpKTtcclxuICB9XHJcbiAgaWYoTyA9PT0gJC5nKXtcclxuICAgIE9ba2V5XSA9IHZhbDtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYoIXNhZmUpZGVsZXRlIE9ba2V5XTtcclxuICAgICQuaGlkZShPLCBrZXksIHZhbCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9yc1xyXG4vLyB3aXRoIG1ldGhvZHMgc2ltaWxhciB0byBMb0Rhc2ggaXNOYXRpdmVcclxuJHJlZGVmKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcclxuICByZXR1cm4gJC5oYXModGhpcywgU1JDKSA/IHRoaXNbU1JDXSA6IF90b1N0cmluZy5jYWxsKHRoaXMpO1xyXG59KTtcclxuXHJcbiQuY29yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xyXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChpdCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICRyZWRlZjsiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlZ0V4cCwgcmVwbGFjZSwgaXNTdGF0aWMpe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpc1N0YXRpYyA/IGl0IDogdGhpcykucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07IiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyICQgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgYXNzZXJ0ID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpO1xuZnVuY3Rpb24gY2hlY2soTywgcHJvdG8pe1xuICBhc3NlcnQub2JqKE8pO1xuICBhc3NlcnQocHJvdG8gPT09IG51bGwgfHwgJC5pc09iamVjdChwcm90byksIHByb3RvLCBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICA/IGZ1bmN0aW9uKGJ1Z2d5LCBzZXQpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldCA9IHJlcXVpcmUoJy4vJC5jdHgnKShGdW5jdGlvbi5jYWxsLCAkLmdldERlc2MoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgICAgc2V0KHt9LCBbXSk7XG4gICAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgICByZXR1cm4gTztcbiAgICAgICAgfTtcbiAgICAgIH0oKVxuICAgIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59OyIsInZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBTUEVDSUVTID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEMpe1xuICBpZigkLkRFU0MgJiYgIShTUEVDSUVTIGluIEMpKSQuc2V0RGVzYyhDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogJC50aGF0XG4gIH0pO1xufTsiLCIvLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxudmFyICQgPSByZXF1aXJlKCcuLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoJC5hc3NlcnREZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gJC50b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbFxuICAgICAgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTsiLCIvLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1zdHJhd21hbjpzdHJpbmdfcGFkZGluZ1xudmFyICQgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgcmVwZWF0ID0gcmVxdWlyZSgnLi8kLnN0cmluZy1yZXBlYXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBtaW5MZW5ndGgsIGZpbGxDaGFyLCBsZWZ0KXtcbiAgLy8gMS4gTGV0IE8gYmUgQ2hlY2tPYmplY3RDb2VyY2libGUodGhpcyB2YWx1ZSkuXG4gIC8vIDIuIExldCBTIGJlIFRvU3RyaW5nKE8pLlxuICB2YXIgUyA9IFN0cmluZygkLmFzc2VydERlZmluZWQodGhhdCkpO1xuICAvLyA0LiBJZiBpbnRNaW5MZW5ndGggaXMgdW5kZWZpbmVkLCByZXR1cm4gUy5cbiAgaWYobWluTGVuZ3RoID09PSB1bmRlZmluZWQpcmV0dXJuIFM7XG4gIC8vIDQuIExldCBpbnRNaW5MZW5ndGggYmUgVG9JbnRlZ2VyKG1pbkxlbmd0aCkuXG4gIHZhciBpbnRNaW5MZW5ndGggPSAkLnRvSW50ZWdlcihtaW5MZW5ndGgpO1xuICAvLyA1LiBMZXQgZmlsbExlbiBiZSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gUyBtaW51cyBpbnRNaW5MZW5ndGguXG4gIHZhciBmaWxsTGVuID0gaW50TWluTGVuZ3RoIC0gUy5sZW5ndGg7XG4gIC8vIDYuIElmIGZpbGxMZW4gPCAwLCB0aGVuIHRocm93IGEgUmFuZ2VFcnJvciBleGNlcHRpb24uXG4gIC8vIDcuIElmIGZpbGxMZW4gaXMgK+KIniwgdGhlbiB0aHJvdyBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uLlxuICBpZihmaWxsTGVuIDwgMCB8fCBmaWxsTGVuID09PSBJbmZpbml0eSl7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Nhbm5vdCBzYXRpc2Z5IHN0cmluZyBsZW5ndGggJyArIG1pbkxlbmd0aCArICcgZm9yIHN0cmluZzogJyArIFMpO1xuICB9XG4gIC8vIDguIExldCBzRmlsbFN0ciBiZSB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IGZpbGxTdHIuXG4gIC8vIDkuIElmIHNGaWxsU3RyIGlzIHVuZGVmaW5lZCwgbGV0IHNGaWxsU3RyIGJlIGEgc3BhY2UgY2hhcmFjdGVyLlxuICB2YXIgc0ZpbGxTdHIgPSBmaWxsQ2hhciA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxDaGFyKTtcbiAgLy8gMTAuIExldCBzRmlsbFZhbCBiZSBhIFN0cmluZyBtYWRlIG9mIHNGaWxsU3RyLCByZXBlYXRlZCB1bnRpbCBmaWxsTGVuIGlzIG1ldC5cbiAgdmFyIHNGaWxsVmFsID0gcmVwZWF0LmNhbGwoc0ZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gc0ZpbGxTdHIubGVuZ3RoKSk7XG4gIC8vIHRydW5jYXRlIGlmIHdlIG92ZXJmbG93ZWRcbiAgaWYoc0ZpbGxWYWwubGVuZ3RoID4gZmlsbExlbilzRmlsbFZhbCA9IGxlZnRcbiAgICA/IHNGaWxsVmFsLnNsaWNlKHNGaWxsVmFsLmxlbmd0aCAtIGZpbGxMZW4pXG4gICAgOiBzRmlsbFZhbC5zbGljZSgwLCBmaWxsTGVuKTtcbiAgLy8gMTEuIFJldHVybiBhIHN0cmluZyBtYWRlIGZyb20gc0ZpbGxWYWwsIGZvbGxvd2VkIGJ5IFMuXG4gIC8vIDExLiBSZXR1cm4gYSBTdHJpbmcgbWFkZSBmcm9tIFMsIGZvbGxvd2VkIGJ5IHNGaWxsVmFsLlxuICByZXR1cm4gbGVmdCA/IHNGaWxsVmFsLmNvbmNhdChTKSA6IFMuY29uY2F0KHNGaWxsVmFsKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLyQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpe1xuICB2YXIgc3RyID0gU3RyaW5nKCQuYXNzZXJ0RGVmaW5lZCh0aGlzKSlcbiAgICAsIHJlcyA9ICcnXG4gICAgLCBuICAgPSAkLnRvSW50ZWdlcihjb3VudCk7XG4gIGlmKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjdHggICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjb2YgICAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCBpbnZva2UgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBjZWwgICAgPSByZXF1aXJlKCcuLyQuZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gJC5nXG4gICwgaXNGdW5jdGlvbiAgICAgICAgID0gJC5pc0Z1bmN0aW9uXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gJC5odG1sXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgcG9zdE1lc3NhZ2UgICAgICAgID0gZ2xvYmFsLnBvc3RNZXNzYWdlXG4gICwgYWRkRXZlbnRMaXN0ZW5lciAgID0gZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXJcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuZnVuY3Rpb24gcnVuKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZigkLmhhcyhxdWV1ZSwgaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59XG5mdW5jdGlvbiBsaXN0bmVyKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighaXNGdW5jdGlvbihzZXRUYXNrKSB8fCAhaXNGdW5jdGlvbihjbGVhclRhc2spKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKGlzRnVuY3Rpb24oZm4pID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYoY29mKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gTW9kZXJuIGJyb3dzZXJzLCBza2lwIGltcGxlbWVudGF0aW9uIGZvciBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzIG9iamVjdFxuICB9IGVsc2UgaWYoYWRkRXZlbnRMaXN0ZW5lciAmJiBpc0Z1bmN0aW9uKHBvc3RNZXNzYWdlKSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcG9zdE1lc3NhZ2UoaWQsICcqJyk7XG4gICAgfTtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdG5lciwgZmFsc2UpO1xuICAvLyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihpc0Z1bmN0aW9uKE1lc3NhZ2VDaGFubmVsKSl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICBleGVjKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsInZhciBzaWQgPSAwO1xuZnVuY3Rpb24gdWlkKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK3NpZCArIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDM2KSk7XG59XG51aWQuc2FmZSA9IHJlcXVpcmUoJy4vJCcpLmcuU3ltYm9sIHx8IHVpZDtcbm1vZHVsZS5leHBvcnRzID0gdWlkOyIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciAkICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuLyQud2tzJykoJ3Vuc2NvcGFibGVzJyk7XG5pZigkLkZXICYmICEoVU5TQ09QQUJMRVMgaW4gW10pKSQuaGlkZShBcnJheS5wcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIGlmKCQuRlcpW11bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi8kJykuZ1xuICAsIHN0b3JlICA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgZ2xvYmFsLlN5bWJvbCAmJiBnbG9iYWwuU3ltYm9sW25hbWVdIHx8IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07IiwidmFyICQgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNlbCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZG9tLWNyZWF0ZScpXG4gICwgY29mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRkZWYgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpbnZva2UgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgYXJyYXlNZXRob2QgICAgICA9IHJlcXVpcmUoJy4vJC5hcnJheS1tZXRob2RzJylcbiAgLCBJRV9QUk9UTyAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ19fcHJvdG9fXycpXG4gICwgYXNzZXJ0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKVxuICAsIGFzc2VydE9iamVjdCAgICAgPSBhc3NlcnQub2JqXG4gICwgT2JqZWN0UHJvdG8gICAgICA9IE9iamVjdC5wcm90b3R5cGVcbiAgLCBodG1sICAgICAgICAgICAgID0gJC5odG1sXG4gICwgQSAgICAgICAgICAgICAgICA9IFtdXG4gICwgX3NsaWNlICAgICAgICAgICA9IEEuc2xpY2VcbiAgLCBfam9pbiAgICAgICAgICAgID0gQS5qb2luXG4gICwgY2xhc3NvZiAgICAgICAgICA9IGNvZi5jbGFzc29mXG4gICwgaGFzICAgICAgICAgICAgICA9ICQuaGFzXG4gICwgZGVmaW5lUHJvcGVydHkgICA9ICQuc2V0RGVzY1xuICAsIGdldE93bkRlc2NyaXB0b3IgPSAkLmdldERlc2NcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gJC5zZXREZXNjc1xuICAsIGlzRnVuY3Rpb24gICAgICAgPSAkLmlzRnVuY3Rpb25cbiAgLCB0b09iamVjdCAgICAgICAgID0gJC50b09iamVjdFxuICAsIHRvTGVuZ3RoICAgICAgICAgPSAkLnRvTGVuZ3RoXG4gICwgdG9JbmRleCAgICAgICAgICA9ICQudG9JbmRleFxuICAsIElFOF9ET01fREVGSU5FICAgPSBmYWxzZVxuICAsICRpbmRleE9mICAgICAgICAgPSByZXF1aXJlKCcuLyQuYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCAkZm9yRWFjaCAgICAgICAgID0gYXJyYXlNZXRob2QoMClcbiAgLCAkbWFwICAgICAgICAgICAgID0gYXJyYXlNZXRob2QoMSlcbiAgLCAkZmlsdGVyICAgICAgICAgID0gYXJyYXlNZXRob2QoMilcbiAgLCAkc29tZSAgICAgICAgICAgID0gYXJyYXlNZXRob2QoMylcbiAgLCAkZXZlcnkgICAgICAgICAgID0gYXJyYXlNZXRob2QoNCk7XG5cbmlmKCEkLkRFU0Mpe1xuICB0cnkge1xuICAgIElFOF9ET01fREVGSU5FID0gZGVmaW5lUHJvcGVydHkoY2VsKCdkaXYnKSwgJ3gnLFxuICAgICAge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDg7IH19XG4gICAgKS54ID09IDg7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgJC5zZXREZXNjID0gZnVuY3Rpb24oTywgUCwgQXR0cmlidXRlcyl7XG4gICAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gICAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKWFzc2VydE9iamVjdChPKVtQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgcmV0dXJuIE87XG4gIH07XG4gICQuZ2V0RGVzYyA9IGZ1bmN0aW9uKE8sIFApe1xuICAgIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgICByZXR1cm4gZ2V0T3duRGVzY3JpcHRvcihPLCBQKTtcbiAgICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYoaGFzKE8sIFApKXJldHVybiAkLmRlc2MoIU9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoTywgUCksIE9bUF0pO1xuICB9O1xuICAkLnNldERlc2NzID0gZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uKE8sIFByb3BlcnRpZXMpe1xuICAgIGFzc2VydE9iamVjdChPKTtcbiAgICB2YXIga2V5cyAgID0gJC5nZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGkgPSAwXG4gICAgICAsIFA7XG4gICAgd2hpbGUobGVuZ3RoID4gaSkkLnNldERlc2MoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gICAgcmV0dXJuIE87XG4gIH07XG59XG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICEkLkRFU0MsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi42IC8gMTUuMi4zLjMgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICQuZ2V0RGVzYyxcbiAgLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICQuc2V0RGVzYyxcbiAgLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiBkZWZpbmVQcm9wZXJ0aWVzXG59KTtcblxuICAvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIga2V5czEgPSAoJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsJyArXG4gICAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZicpLnNwbGl0KCcsJylcbiAgLy8gQWRkaXRpb25hbCBrZXlzIGZvciBnZXRPd25Qcm9wZXJ0eU5hbWVzXG4gICwga2V5czIgPSBrZXlzMS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKVxuICAsIGtleXNMZW4xID0ga2V5czEubGVuZ3RoO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gY2VsKCdpZnJhbWUnKVxuICAgICwgaSAgICAgID0ga2V5c0xlbjFcbiAgICAsIGd0ICAgICA9ICc+J1xuICAgICwgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKCc8c2NyaXB0PmRvY3VtZW50LkY9T2JqZWN0PC9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0LnByb3RvdHlwZVtrZXlzMVtpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuZnVuY3Rpb24gY3JlYXRlR2V0S2V5cyhuYW1lcywgbGVuZ3RoKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAgIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgICB3aGlsZShsZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgICB+JGluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShpdCl7IHJldHVybiAhJC5pc09iamVjdChpdCk7IH1cbmZ1bmN0aW9uIEVtcHR5KCl7fVxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG4gIGdldFByb3RvdHlwZU9mOiAkLmdldFByb3RvID0gJC5nZXRQcm90byB8fCBmdW5jdGlvbihPKXtcbiAgICBPID0gT2JqZWN0KGFzc2VydC5kZWYoTykpO1xuICAgIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICAgIGlmKGlzRnVuY3Rpb24oTy5jb25zdHJ1Y3RvcikgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG4gIH0sXG4gIC8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJC5nZXROYW1lcyA9ICQuZ2V0TmFtZXMgfHwgY3JlYXRlR2V0S2V5cyhrZXlzMiwga2V5czIubGVuZ3RoLCB0cnVlKSxcbiAgLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJC5jcmVhdGUgPSAkLmNyZWF0ZSB8fCBmdW5jdGlvbihPLCAvKj8qL1Byb3BlcnRpZXMpe1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYoTyAhPT0gbnVsbCl7XG4gICAgICBFbXB0eS5wcm90b3R5cGUgPSBhc3NlcnRPYmplY3QoTyk7XG4gICAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHNoaW1cbiAgICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICAgIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gICAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbiAgfSxcbiAgLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG4gIGtleXM6ICQuZ2V0S2V5cyA9ICQuZ2V0S2V5cyB8fCBjcmVhdGVHZXRLZXlzKGtleXMxLCBrZXlzTGVuMSwgZmFsc2UpLFxuICAvLyAxOS4xLjIuMTcgLyAxNS4yLjMuOCBPYmplY3Quc2VhbChPKVxuICBzZWFsOiAkLml0LCAvLyA8LSBjYXBcbiAgLy8gMTkuMS4yLjUgLyAxNS4yLjMuOSBPYmplY3QuZnJlZXplKE8pXG4gIGZyZWV6ZTogJC5pdCwgLy8gPC0gY2FwXG4gIC8vIDE5LjEuMi4xNSAvIDE1LjIuMy4xMCBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbiAgcHJldmVudEV4dGVuc2lvbnM6ICQuaXQsIC8vIDwtIGNhcFxuICAvLyAxOS4xLjIuMTMgLyAxNS4yLjMuMTEgT2JqZWN0LmlzU2VhbGVkKE8pXG4gIGlzU2VhbGVkOiBpc1ByaW1pdGl2ZSwgLy8gPC0gY2FwXG4gIC8vIDE5LjEuMi4xMiAvIDE1LjIuMy4xMiBPYmplY3QuaXNGcm96ZW4oTylcbiAgaXNGcm96ZW46IGlzUHJpbWl0aXZlLCAvLyA8LSBjYXBcbiAgLy8gMTkuMS4yLjExIC8gMTUuMi4zLjEzIE9iamVjdC5pc0V4dGVuc2libGUoTylcbiAgaXNFeHRlbnNpYmxlOiAkLmlzT2JqZWN0IC8vIDwtIGNhcFxufSk7XG5cbi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbiRkZWYoJGRlZi5QLCAnRnVuY3Rpb24nLCB7XG4gIGJpbmQ6IGZ1bmN0aW9uKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBmbiAgICAgICA9IGFzc2VydC5mbih0aGlzKVxuICAgICAgLCBwYXJ0QXJncyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZnVuY3Rpb24gYm91bmQoLyogYXJncy4uLiAqLyl7XG4gICAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChfc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MsIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/ICQuY3JlYXRlKGZuLnByb3RvdHlwZSkgOiB0aGF0KTtcbiAgICB9XG4gICAgaWYoZm4ucHJvdG90eXBlKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH1cbn0pO1xuXG4vLyBGaXggZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmcgYW5kIERPTSBvYmplY3RzXG5pZighKDAgaW4gT2JqZWN0KCd6JykgJiYgJ3onWzBdID09ICd6Jykpe1xuICAkLkVTNU9iamVjdCA9IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG4gIH07XG59XG5cbnZhciBidWdneVNsaWNlID0gdHJ1ZTtcbnRyeSB7XG4gIGlmKGh0bWwpX3NsaWNlLmNhbGwoaHRtbCk7XG4gIGJ1Z2d5U2xpY2UgPSBmYWxzZTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBidWdneVNsaWNlLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKXtcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcbiAgICAgICwga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gX3NsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ICA9IHRvSW5kZXgoYmVnaW4sIGxlbilcbiAgICAgICwgdXBUbyAgID0gdG9JbmRleChlbmQsIGxlbilcbiAgICAgICwgc2l6ZSAgID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KVxuICAgICAgLCBjbG9uZWQgPSBBcnJheShzaXplKVxuICAgICAgLCBpICAgICAgPSAwO1xuICAgIGZvcig7IGkgPCBzaXplOyBpKyspY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZydcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxuICAgICAgOiB0aGlzW3N0YXJ0ICsgaV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7XG5cbiRkZWYoJGRlZi5QICsgJGRlZi5GICogKCQuRVM1T2JqZWN0ICE9IE9iamVjdCksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbigpe1xuICAgIHJldHVybiBfam9pbi5hcHBseSgkLkVTNU9iamVjdCh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfVxufSk7XG5cbi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG4kZGVmKCRkZWYuUywgJ0FycmF5Jywge1xuICBpc0FycmF5OiBmdW5jdGlvbihhcmcpe1xuICAgIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xuICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5UmVkdWNlKGlzUmlnaHQpe1xuICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2tmbiwgbWVtbyl7XG4gICAgYXNzZXJ0LmZuKGNhbGxiYWNrZm4pO1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDIpZm9yKDs7KXtcbiAgICAgIGlmKGluZGV4IGluIE8pe1xuICAgICAgICBtZW1vID0gT1tpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGFzc2VydChpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4LCAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgICBmb3IoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpaWYoaW5kZXggaW4gTyl7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBPW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn1cbiRkZWYoJGRlZi5QLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiAkLmVhY2ggPSAkLmVhY2ggfHwgZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9LFxuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9LFxuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9LFxuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9LFxuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogY3JlYXRlQXJyYXlSZWR1Y2UoZmFsc2UpLFxuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGNyZWF0ZUFycmF5UmVkdWNlKHRydWUpLFxuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKGVsIC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gJGluZGV4T2YodGhpcywgZWwsIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24oZWwsIGZyb21JbmRleCAvKiA9IEBbKi0xXSAqLyl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBsZW5ndGggLSAxO1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKWluZGV4ID0gTWF0aC5taW4oaW5kZXgsICQudG9JbnRlZ2VyKGZyb21JbmRleCkpO1xuICAgIGlmKGluZGV4IDwgMClpbmRleCA9IHRvTGVuZ3RoKGxlbmd0aCArIGluZGV4KTtcbiAgICBmb3IoO2luZGV4ID49IDA7IGluZGV4LS0paWYoaW5kZXggaW4gTylpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIGluZGV4O1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG5cbi8vIDIxLjEuMy4yNSAvIDE1LjUuNC4yMCBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7dHJpbTogcmVxdWlyZSgnLi8kLnJlcGxhY2VyJykoL15cXHMqKFtcXHNcXFNdKlxcUyk/XFxzKiQvLCAnJDEnKX0pO1xuXG4vLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbiRkZWYoJGRlZi5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7XG4gIHJldHVybiArbmV3IERhdGU7XG59fSk7XG5cbmZ1bmN0aW9uIGx6KG51bSl7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufVxuXG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxuLy8gUGhhbnRvbUpTIGFuZCBvbGQgd2Via2l0IGhhZCBhIGJyb2tlbiBEYXRlIGltcGxlbWVudGF0aW9uLlxudmFyIGRhdGUgICAgICAgPSBuZXcgRGF0ZSgtNWUxMyAtIDEpXG4gICwgYnJva2VuRGF0ZSA9ICEoZGF0ZS50b0lTT1N0cmluZyAmJiBkYXRlLnRvSVNPU3RyaW5nKCkgPT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5WidcbiAgICAgICYmIHJlcXVpcmUoJy4vJC50aHJvd3MnKShmdW5jdGlvbigpeyBuZXcgRGF0ZShOYU4pLnRvSVNPU3RyaW5nKCk7IH0pKTtcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogYnJva2VuRGF0ZSwgJ0RhdGUnLCB7dG9JU09TdHJpbmc6IGZ1bmN0aW9uKCl7XG4gIGlmKCFpc0Zpbml0ZSh0aGlzKSl0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgdmFyIGQgPSB0aGlzXG4gICAgLCB5ID0gZC5nZXRVVENGdWxsWWVhcigpXG4gICAgLCBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICwgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbn19KTtcblxuaWYoY2xhc3NvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdPYmplY3QnKWNvZi5jbGFzc29mID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGFnID0gY2xhc3NvZihpdCk7XG4gIHJldHVybiB0YWcgPT0gJ09iamVjdCcgJiYgaXNGdW5jdGlvbihpdC5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiB0YWc7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgdG9JbmRleCA9ICQudG9JbmRleDtcbiRkZWYoJGRlZi5QLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgTyAgICAgPSBPYmplY3QoJC5hc3NlcnREZWZpbmVkKHRoaXMpKVxuICAgICAgLCBsZW4gICA9ICQudG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIHRvICAgID0gdG9JbmRleCh0YXJnZXQsIGxlbilcbiAgICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgICAsIGVuZCAgID0gYXJndW1lbnRzWzJdXG4gICAgICAsIGZpbiAgID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBjb3VudCA9IE1hdGgubWluKGZpbiAtIGZyb20sIGxlbiAtIHRvKVxuICAgICAgLCBpbmMgICA9IDE7XG4gICAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcbiAgICAgIGluYyAgPSAtMTtcbiAgICAgIGZyb20gPSBmcm9tICsgY291bnQgLSAxO1xuICAgICAgdG8gICA9IHRvICAgKyBjb3VudCAtIDE7XG4gICAgfVxuICAgIHdoaWxlKGNvdW50LS0gPiAwKXtcbiAgICAgIGlmKGZyb20gaW4gTylPW3RvXSA9IE9bZnJvbV07XG4gICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIHRvICAgKz0gaW5jO1xuICAgICAgZnJvbSArPSBpbmM7XG4gICAgfSByZXR1cm4gTztcbiAgfVxufSk7XG5yZXF1aXJlKCcuLyQudW5zY29wZScpKCdjb3B5V2l0aGluJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCB0b0luZGV4ID0gJC50b0luZGV4O1xuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4gIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gICAgdmFyIE8gICAgICA9IE9iamVjdCgkLmFzc2VydERlZmluZWQodGhpcykpXG4gICAgICAsIGxlbmd0aCA9ICQudG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoYXJndW1lbnRzWzFdLCBsZW5ndGgpXG4gICAgICAsIGVuZCAgICA9IGFyZ3VtZW50c1syXVxuICAgICAgLCBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpO1xuICAgIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcbiAgICByZXR1cm4gTztcbiAgfVxufSk7XG5yZXF1aXJlKCcuLyQudW5zY29wZScpKCdmaWxsJyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgS0VZICAgID0gJ2ZpbmRJbmRleCdcbiAgLCAkZGVmICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBmb3JjZWQgPSB0cnVlXG4gICwgJGZpbmQgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKSg2KTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgS0VZICAgID0gJ2ZpbmQnXG4gICwgJGRlZiAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgZm9yY2VkID0gdHJ1ZVxuICAsICRmaW5kICA9IHJlcXVpcmUoJy4vJC5hcnJheS1tZXRob2RzJykoNSk7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoS0VZKTsiLCJ2YXIgJCAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGN0eCAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkaXRlciA9IHJlcXVpcmUoJy4vJC5pdGVyJylcbiAgLCBjYWxsICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKTtcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogIXJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZChhcnJheUxpa2UpKVxuICAgICAgLCBtYXBmbiAgID0gYXJndW1lbnRzWzFdXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGYgICAgICAgPSBtYXBwaW5nID8gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpIDogdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZigkaXRlci5pcyhPKSl7XG4gICAgICBpdGVyYXRvciA9ICRpdGVyLmdldChPKTtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgcXVpcmtzIG1vZGUgYnVnIC0+IHVzZSB0eXBlb2YgaW5zdGVhZCBvZiBpc0Z1bmN0aW9uXG4gICAgICByZXN1bHQgICA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSk7XG4gICAgICBmb3IoOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIGYsIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RyYW5nZSBJRSBxdWlya3MgbW9kZSBidWcgLT4gdXNlIHR5cGVvZiBpbnN0ZWFkIG9mIGlzRnVuY3Rpb25cbiAgICAgIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkobGVuZ3RoID0gJC50b0xlbmd0aChPLmxlbmd0aCkpO1xuICAgICAgZm9yKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGYoT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwidmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHNldFVuc2NvcGUgPSByZXF1aXJlKCcuLyQudW5zY29wZScpXG4gICwgSVRFUiAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdpdGVyJylcbiAgLCAkaXRlciAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIHN0ZXAgICAgICAgPSAkaXRlci5zdGVwXG4gICwgSXRlcmF0b3JzICA9ICRpdGVyLkl0ZXJhdG9ycztcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgJC5zZXQodGhpcywgSVRFUiwge286ICQudG9PYmplY3QoaXRlcmF0ZWQpLCBpOiAwLCBrOiBraW5kfSk7XG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cbiAgICAsIE8gICAgID0gaXRlci5vXG4gICAgLCBraW5kICA9IGl0ZXIua1xuICAgICwgaW5kZXggPSBpdGVyLmkrKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIGl0ZXIubyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuc2V0VW5zY29wZSgna2V5cycpO1xuc2V0VW5zY29wZSgndmFsdWVzJyk7XG5zZXRVbnNjb3BlKCdlbnRyaWVzJyk7IiwidmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAvLyBzdHJhbmdlIElFIHF1aXJrcyBtb2RlIGJ1ZyAtPiB1c2UgdHlwZW9mIGluc3RlYWQgb2YgaXNGdW5jdGlvblxuICAgICAgLCByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsInJlcXVpcmUoJy4vJC5zcGVjaWVzJykoQXJyYXkpOyIsInZhciAkICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBIQVNfSU5TVEFOQ0UgID0gcmVxdWlyZSgnLi8kLndrcycpKCdoYXNJbnN0YW5jZScpXG4gICwgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpJC5zZXREZXNjKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwge3ZhbHVlOiBmdW5jdGlvbihPKXtcbiAgaWYoISQuaXNGdW5jdGlvbih0aGlzKSB8fCAhJC5pc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCEkLmlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSlyZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlKE8gPSAkLmdldFByb3RvKE8pKWlmKHRoaXMucHJvdG90eXBlID09PSBPKXJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59fSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIE5BTUUgPSAnbmFtZSdcbiAgLCBzZXREZXNjID0gJC5zZXREZXNjXG4gICwgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRnVuY3Rpb25Qcm90byB8fCAkLkZXICYmICQuREVTQyAmJiBzZXREZXNjKEZ1bmN0aW9uUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG1hdGNoID0gU3RyaW5nKHRoaXMpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLylcbiAgICAgICwgbmFtZSAgPSBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XG4gICAgJC5oYXModGhpcywgTkFNRSkgfHwgc2V0RGVzYyh0aGlzLCBOQU1FLCAkLmRlc2MoNSwgbmFtZSkpO1xuICAgIHJldHVybiBuYW1lO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAkLmhhcyh0aGlzLCBOQU1FKSB8fCBzZXREZXNjKHRoaXMsIE5BTUUsICQuZGVzYygwLCB2YWx1ZSkpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ01hcCcsIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7IiwidmFyIEluZmluaXR5ID0gMSAvIDBcbiAgLCAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIEUgICAgID0gTWF0aC5FXG4gICwgcG93ICAgPSBNYXRoLnBvd1xuICAsIGFicyAgID0gTWF0aC5hYnNcbiAgLCBleHAgICA9IE1hdGguZXhwXG4gICwgbG9nICAgPSBNYXRoLmxvZ1xuICAsIHNxcnQgID0gTWF0aC5zcXJ0XG4gICwgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3JcbiAgLCBFUFNJTE9OICAgPSBwb3coMiwgLTUyKVxuICAsIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpXG4gICwgTUFYMzIgICAgID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMilcbiAgLCBNSU4zMiAgICAgPSBwb3coMiwgLTEyNik7XG5mdW5jdGlvbiByb3VuZFRpZXNUb0V2ZW4obil7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn1cblxuLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxuZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufVxuLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxuZnVuY3Rpb24gYXNpbmgoeCl7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogbG9nKHggKyBzcXJ0KHggKiB4ICsgMSkpO1xufVxuLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbmZ1bmN0aW9uIGV4cG0xKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogZXhwKHgpIC0gMTtcbn1cblxuJGRlZigkZGVmLlMsICdNYXRoJywge1xuICAvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogaXNGaW5pdGUoeCkgPyBsb2coeCAvIEUgKyBzcXJ0KHggKyAxKSAqIHNxcnQoeCAtIDEpIC8gRSkgKyAxIDogeDtcbiAgfSxcbiAgLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxuICBhc2luaDogYXNpbmgsXG4gIC8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IGxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9LFxuICAvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KXtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogcG93KGFicyh4KSwgMSAvIDMpO1xuICB9LFxuICAvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCl7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIGZsb29yKGxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH0sXG4gIC8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KXtcbiAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xuICB9LFxuICAvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxuICBleHBtMTogZXhwbTEsXG4gIC8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxuICBmcm91bmQ6IGZ1bmN0aW9uIGZyb3VuZCh4KXtcbiAgICB2YXIgJGFicyAgPSBhYnMoeClcbiAgICAgICwgJHNpZ24gPSBzaWduKHgpXG4gICAgICAsIGEsIHJlc3VsdDtcbiAgICBpZigkYWJzIDwgTUlOMzIpcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gICAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gICAgaWYocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdClyZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG4gIH0sXG4gIC8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSAgPSAwXG4gICAgICAsIGkgICAgPSAwXG4gICAgICAsIGxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGFyZ3MgPSBBcnJheShsZW4pXG4gICAgICAsIGxhcmcgPSAwXG4gICAgICAsIGFyZztcbiAgICB3aGlsZShpIDwgbGVuKXtcbiAgICAgIGFyZyA9IGFyZ3NbaV0gPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYoYXJnID09IEluZmluaXR5KXJldHVybiBJbmZpbml0eTtcbiAgICAgIGlmKGFyZyA+IGxhcmcpbGFyZyA9IGFyZztcbiAgICB9XG4gICAgbGFyZyA9IGxhcmcgfHwgMTtcbiAgICB3aGlsZShsZW4tLSlzdW0gKz0gcG93KGFyZ3NbbGVuXSAvIGxhcmcsIDIpO1xuICAgIHJldHVybiBsYXJnICogc3FydChzdW0pO1xuICB9LFxuICAvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSl7XG4gICAgdmFyIFVJbnQxNiA9IDB4ZmZmZlxuICAgICAgLCB4biA9ICt4XG4gICAgICAsIHluID0gK3lcbiAgICAgICwgeGwgPSBVSW50MTYgJiB4blxuICAgICAgLCB5bCA9IFVJbnQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUludDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUludDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH0sXG4gIC8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG4gIGxvZzFwOiBmdW5jdGlvbiBsb2cxcCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBsb2coMSArIHgpO1xuICB9LFxuICAvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCl7XG4gICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4xMDtcbiAgfSxcbiAgLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpe1xuICAgIHJldHVybiBsb2coeCkgLyBNYXRoLkxOMjtcbiAgfSxcbiAgLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxuICBzaWduOiBzaWduLFxuICAvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIGFicyh4ID0gK3gpIDwgMSA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoRSAvIDIpO1xuICB9LFxuICAvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCl7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpXG4gICAgICAsIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfSxcbiAgLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KXtcbiAgICByZXR1cm4gKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaXNPYmplY3QgICA9ICQuaXNPYmplY3RcbiAgLCBpc0Z1bmN0aW9uID0gJC5pc0Z1bmN0aW9uXG4gICwgTlVNQkVSICAgICA9ICdOdW1iZXInXG4gICwgJE51bWJlciAgICA9ICQuZ1tOVU1CRVJdXG4gICwgQmFzZSAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgID0gJE51bWJlci5wcm90b3R5cGU7XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZShpdCl7XG4gIHZhciBmbiwgdmFsO1xuICBpZihpc0Z1bmN0aW9uKGZuID0gaXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZihpc0Z1bmN0aW9uKGZuID0gaXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gbnVtYmVyXCIpO1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoaXQpe1xuICBpZihpc09iamVjdChpdCkpaXQgPSB0b1ByaW1pdGl2ZShpdCk7XG4gIGlmKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyICYmIGl0LmNoYXJDb2RlQXQoMCkgPT0gNDgpe1xuICAgIHZhciBiaW5hcnkgPSBmYWxzZTtcbiAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XG4gICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiBiaW5hcnkgPSB0cnVlO1xuICAgICAgY2FzZSA3OSA6IGNhc2UgMTExIDogcmV0dXJuIHBhcnNlSW50KGl0LnNsaWNlKDIpLCBiaW5hcnkgPyAyIDogOCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59XG5pZigkLkZXICYmICEoJE51bWJlcignMG8xJykgJiYgJE51bWJlcignMGIxJykpKXtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcihpdCl7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiAkTnVtYmVyID8gbmV3IEJhc2UodG9OdW1iZXIoaXQpKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgJC5lYWNoLmNhbGwoJC5ERVNDID8gJC5nZXROYW1lcyhCYXNlKSA6IChcbiAgICAgIC8vIEVTMzpcbiAgICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICAgICkuc3BsaXQoJywnKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgIGlmKCQuaGFzKEJhc2UsIGtleSkgJiYgISQuaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgICAkLnNldERlc2MoJE51bWJlciwga2V5LCAkLmdldERlc2MoQmFzZSwga2V5KSk7XG4gICAgICB9XG4gICAgfVxuICApO1xuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vJC5yZWRlZicpKCQuZywgTlVNQkVSLCAkTnVtYmVyKTtcbn0iLCJ2YXIgJCAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgYWJzICAgPSBNYXRoLmFic1xuICAsIGZsb29yID0gTWF0aC5mbG9vclxuICAsIF9pc0Zpbml0ZSA9ICQuZy5pc0Zpbml0ZVxuICAsIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxO1xuZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KXtcbiAgcmV0dXJuICEkLmlzT2JqZWN0KGl0KSAmJiBfaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59XG4kZGVmKCRkZWYuUywgJ051bWJlcicsIHtcbiAgLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbiAgRVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKSxcbiAgLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KXtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH0sXG4gIC8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxuICBpc0ludGVnZXI6IGlzSW50ZWdlcixcbiAgLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH0sXG4gIC8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpe1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICB9LFxuICAvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICBNQVhfU0FGRV9JTlRFR0VSOiBNQVhfU0FGRV9JTlRFR0VSLFxuICAvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbiAgTUlOX1NBRkVfSU5URUdFUjogLU1BWF9TQUZFX0lOVEVHRVIsXG4gIC8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4gIHBhcnNlRmxvYXQ6IHBhcnNlRmxvYXQsXG4gIC8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiAgcGFyc2VJbnQ6IHBhcnNlSW50XG59KTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vJC5hc3NpZ24nKX0pOyIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbiRkZWYoJGRlZi5TLCAnT2JqZWN0Jywge1xuICBpczogZnVuY3Rpb24gaXMoeCwgeSl7XG4gICAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG4gIH1cbn0pOyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbiRkZWYoJGRlZi5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuLyQuc2V0LXByb3RvJykuc2V0fSk7IiwidmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGlzT2JqZWN0ID0gJC5pc09iamVjdFxuICAsIHRvT2JqZWN0ID0gJC50b09iamVjdDtcbiQuZWFjaC5jYWxsKCgnZnJlZXplLHNlYWwscHJldmVudEV4dGVuc2lvbnMsaXNGcm96ZW4saXNTZWFsZWQsaXNFeHRlbnNpYmxlLCcgK1xuICAnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLGdldFByb3RvdHlwZU9mLGtleXMsZ2V0T3duUHJvcGVydHlOYW1lcycpLnNwbGl0KCcsJylcbiwgZnVuY3Rpb24oS0VZLCBJRCl7XG4gIHZhciBmbiAgICAgPSAoJC5jb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZm9yY2VkID0gMFxuICAgICwgbWV0aG9kID0ge307XG4gIG1ldGhvZFtLRVldID0gSUQgPT0gMCA/IGZ1bmN0aW9uIGZyZWV6ZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGl0O1xuICB9IDogSUQgPT0gMSA/IGZ1bmN0aW9uIHNlYWwoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBpdDtcbiAgfSA6IElEID09IDIgPyBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGl0O1xuICB9IDogSUQgPT0gMyA/IGZ1bmN0aW9uIGlzRnJvemVuKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogdHJ1ZTtcbiAgfSA6IElEID09IDQgPyBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IHRydWU7XG4gIH0gOiBJRCA9PSA1ID8gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogZmFsc2U7XG4gIH0gOiBJRCA9PSA2ID8gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICAgIHJldHVybiBmbih0b09iamVjdChpdCksIGtleSk7XG4gIH0gOiBJRCA9PSA3ID8gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiBmbihPYmplY3QoJC5hc3NlcnREZWZpbmVkKGl0KSkpO1xuICB9IDogSUQgPT0gOCA/IGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiBmbih0b09iamVjdChpdCkpO1xuICB9IDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSk7XG4gIH07XG4gIHRyeSB7XG4gICAgZm4oJ3onKTtcbiAgfSBjYXRjaChlKXtcbiAgICBmb3JjZWQgPSAxO1xuICB9XG4gICRkZWYoJGRlZi5TICsgJGRlZi5GICogZm9yY2VkLCAnT2JqZWN0JywgbWV0aG9kKTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIHRtcCA9IHt9O1xudG1wW3JlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZihyZXF1aXJlKCcuLyQnKS5GVyAmJiBjb2YodG1wKSAhPSAneicpe1xuICByZXF1aXJlKCcuLyQucmVkZWYnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY29mLmNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3R4ICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgYXNzZXJ0ICAgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JylcbiAgLCBmb3JPZiAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHNldFByb3RvID0gcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldFxuICAsIHNwZWNpZXMgID0gcmVxdWlyZSgnLi8kLnNwZWNpZXMnKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJylcbiAgLCBSRUNPUkQgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdyZWNvcmQnKVxuICAsIFBST01JU0UgID0gJ1Byb21pc2UnXG4gICwgZ2xvYmFsICAgPSAkLmdcbiAgLCBwcm9jZXNzICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgYXNhcCAgICAgPSBwcm9jZXNzICYmIHByb2Nlc3MubmV4dFRpY2sgfHwgcmVxdWlyZSgnLi8kLnRhc2snKS5zZXRcbiAgLCBQICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIGlzRnVuY3Rpb24gICAgID0gJC5pc0Z1bmN0aW9uXG4gICwgaXNPYmplY3QgICAgICAgPSAkLmlzT2JqZWN0XG4gICwgYXNzZXJ0RnVuY3Rpb24gPSBhc3NlcnQuZm5cbiAgLCBhc3NlcnRPYmplY3QgICA9IGFzc2VydC5vYmo7XG5cbnZhciB1c2VOYXRpdmUgPSBmdW5jdGlvbigpe1xuICB2YXIgdGVzdCwgd29ya3MgPSBmYWxzZTtcbiAgZnVuY3Rpb24gUDIoeCl7XG4gICAgdmFyIHNlbGYgPSBuZXcgUCh4KTtcbiAgICBzZXRQcm90byhzZWxmLCBQMi5wcm90b3R5cGUpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRyeSB7XG4gICAgd29ya3MgPSBpc0Z1bmN0aW9uKFApICYmIGlzRnVuY3Rpb24oUC5yZXNvbHZlKSAmJiBQLnJlc29sdmUodGVzdCA9IG5ldyBQKGZ1bmN0aW9uKCl7fSkpID09IHRlc3Q7XG4gICAgc2V0UHJvdG8oUDIsIFApO1xuICAgIFAyLnByb3RvdHlwZSA9ICQuY3JlYXRlKFAucHJvdG90eXBlLCB7Y29uc3RydWN0b3I6IHt2YWx1ZTogUDJ9fSk7XG4gICAgLy8gYWN0dWFsIEZpcmVmb3ggaGFzIGJyb2tlbiBzdWJjbGFzcyBzdXBwb3J0LCB0ZXN0IHRoYXRcbiAgICBpZighKFAyLnJlc29sdmUoNSkudGhlbihmdW5jdGlvbigpe30pIGluc3RhbmNlb2YgUDIpKXtcbiAgICAgIHdvcmtzID0gZmFsc2U7XG4gICAgfVxuICB9IGNhdGNoKGUpeyB3b3JrcyA9IGZhbHNlOyB9XG4gIHJldHVybiB3b3Jrcztcbn0oKTtcblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IoQyl7XG4gIHZhciBTID0gYXNzZXJ0T2JqZWN0KEMpW1NQRUNJRVNdO1xuICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcbn1cbmZ1bmN0aW9uIGlzVGhlbmFibGUoaXQpe1xuICB2YXIgdGhlbjtcbiAgaWYoaXNPYmplY3QoaXQpKXRoZW4gPSBpdC50aGVuO1xuICByZXR1cm4gaXNGdW5jdGlvbih0aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5vdGlmeShyZWNvcmQpe1xuICB2YXIgY2hhaW4gPSByZWNvcmQuYztcbiAgaWYoY2hhaW4ubGVuZ3RoKWFzYXAoZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSByZWNvcmQudlxuICAgICAgLCBvayAgICA9IHJlY29yZC5zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIGZ1bmN0aW9uIHJ1bihyZWFjdCl7XG4gICAgICB2YXIgY2IgPSBvayA/IHJlYWN0Lm9rIDogcmVhY3QuZmFpbFxuICAgICAgICAsIHJldCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGNiKXtcbiAgICAgICAgICBpZighb2spcmVjb3JkLmggPSB0cnVlO1xuICAgICAgICAgIHJldCA9IGNiID09PSB0cnVlID8gdmFsdWUgOiBjYih2YWx1ZSk7XG4gICAgICAgICAgaWYocmV0ID09PSByZWFjdC5QKXtcbiAgICAgICAgICAgIHJlYWN0LnJlaihUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJldCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJldCwgcmVhY3QucmVzLCByZWFjdC5yZWopO1xuICAgICAgICAgIH0gZWxzZSByZWFjdC5yZXMocmV0KTtcbiAgICAgICAgfSBlbHNlIHJlYWN0LnJlaih2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgIHJlYWN0LnJlaihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBjaGFpbi5sZW5ndGggPSAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzVW5oYW5kbGVkKHByb21pc2Upe1xuICB2YXIgcmVjb3JkID0gcHJvbWlzZVtSRUNPUkRdXG4gICAgLCBjaGFpbiAgPSByZWNvcmQuYSB8fCByZWNvcmQuY1xuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVhY3Q7XG4gIGlmKHJlY29yZC5oKXJldHVybiBmYWxzZTtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3QgPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0LmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0LlApKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICRyZWplY3QodmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpc1xuICAgICwgcHJvbWlzZTtcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHJlY29yZC52ID0gdmFsdWU7XG4gIHJlY29yZC5zID0gMjtcbiAgcmVjb3JkLmEgPSByZWNvcmQuYy5zbGljZSgpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgYXNhcChmdW5jdGlvbigpe1xuICAgICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSA9IHJlY29yZC5wKSl7XG4gICAgICAgIGlmKGNvZihwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoZ2xvYmFsLmNvbnNvbGUgJiYgaXNGdW5jdGlvbihjb25zb2xlLmVycm9yKSl7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWNvcmQuYSA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfSwgMSk7XG4gIG5vdGlmeShyZWNvcmQpO1xufVxuZnVuY3Rpb24gJHJlc29sdmUodmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpc1xuICAgICwgdGhlbiwgd3JhcHBlcjtcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIHdyYXBwZXIgPSB7cjogcmVjb3JkLCBkOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgICAgIHJlY29yZC5zID0gMTtcbiAgICAgIG5vdGlmeShyZWNvcmQpO1xuICAgIH1cbiAgfSBjYXRjaChlcnIpe1xuICAgICRyZWplY3QuY2FsbCh3cmFwcGVyIHx8IHtyOiByZWNvcmQsIGQ6IGZhbHNlfSwgZXJyKTsgLy8gd3JhcFxuICB9XG59XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighdXNlTmF0aXZlKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFzc2VydEZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgcDogYXNzZXJ0Lmluc3QodGhpcywgUCwgUFJPTUlTRSksICAgICAgIC8vIDwtIHByb21pc2VcbiAgICAgIGM6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICAgIGE6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgICAgczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgICBkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gZG9uZVxuICAgICAgdjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICBoOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gaGFuZGxlZCByZWplY3Rpb25cbiAgICB9O1xuICAgICQuaGlkZSh0aGlzLCBSRUNPUkQsIHJlY29yZCk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgcmVjb3JkLCAxKSwgY3R4KCRyZWplY3QsIHJlY29yZCwgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbChyZWNvcmQsIGVycik7XG4gICAgfVxuICB9O1xuICByZXF1aXJlKCcuLyQubWl4JykoUC5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIFMgPSBhc3NlcnRPYmplY3QoYXNzZXJ0T2JqZWN0KHRoaXMpLmNvbnN0cnVjdG9yKVtTUEVDSUVTXTtcbiAgICAgIHZhciByZWFjdCA9IHtcbiAgICAgICAgb2s6ICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWUsXG4gICAgICAgIGZhaWw6IGlzRnVuY3Rpb24ob25SZWplY3RlZCkgID8gb25SZWplY3RlZCAgOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBwcm9taXNlID0gcmVhY3QuUCA9IG5ldyAoUyAhPSB1bmRlZmluZWQgPyBTIDogUCkoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgICByZWFjdC5yZXMgPSBhc3NlcnRGdW5jdGlvbihyZXMpO1xuICAgICAgICByZWFjdC5yZWogPSBhc3NlcnRGdW5jdGlvbihyZWopO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVjb3JkID0gdGhpc1tSRUNPUkRdO1xuICAgICAgcmVjb3JkLmMucHVzaChyZWFjdCk7XG4gICAgICBpZihyZWNvcmQuYSlyZWNvcmQuYS5wdXNoKHJlYWN0KTtcbiAgICAgIHJlY29yZC5zICYmIG5vdGlmeShyZWNvcmQpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGV4cG9ydFxuJGRlZigkZGVmLkcgKyAkZGVmLlcgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCB7UHJvbWlzZTogUH0pO1xuY29mLnNldChQLCBQUk9NSVNFKTtcbnNwZWNpZXMoUCk7XG5zcGVjaWVzKCQuY29yZVtQUk9NSVNFXSk7IC8vIGZvciB3cmFwcGVyXG5cbi8vIHN0YXRpY3NcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogIXVzZU5hdGl2ZSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICByZXR1cm4gbmV3IChnZXRDb25zdHJ1Y3Rvcih0aGlzKSkoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgcmVqKHIpO1xuICAgIH0pO1xuICB9LFxuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgUkVDT1JEIGluIHggJiYgJC5nZXRQcm90byh4KSA9PT0gdGhpcy5wcm90b3R5cGVcbiAgICAgID8geCA6IG5ldyAoZ2V0Q29uc3RydWN0b3IodGhpcykpKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIHJlcyh4KTtcbiAgICAgIH0pO1xuICB9XG59KTtcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogISh1c2VOYXRpdmUgJiYgcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gIFAuYWxsKGl0ZXIpWydjYXRjaCddKGZ1bmN0aW9uKCl7fSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgID0gZ2V0Q29uc3RydWN0b3IodGhpcylcbiAgICAgICwgdmFsdWVzID0gW107XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgdmFsdWVzLnB1c2gsIHZhbHVlcyk7XG4gICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aFxuICAgICAgICAsIHJlc3VsdHMgICA9IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICBpZihyZW1haW5pbmcpJC5lYWNoLmNhbGwodmFsdWVzLCBmdW5jdGlvbihwcm9taXNlLCBpbmRleCl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlcyhyZXN1bHRzKTtcbiAgICAgICAgfSwgcmVqKTtcbiAgICAgIH0pO1xuICAgICAgZWxzZSByZXMocmVzdWx0cyk7XG4gICAgfSk7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4ocmVzLCByZWopO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pOyIsInZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHNldFByb3RvICA9IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKVxuICAsICRpdGVyICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJVEVSICAgICAgPSByZXF1aXJlKCcuLyQudWlkJykuc2FmZSgnaXRlcicpXG4gICwgc3RlcCAgICAgID0gJGl0ZXIuc3RlcFxuICAsIGFzc2VydCAgICA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKVxuICAsIGlzT2JqZWN0ICA9ICQuaXNPYmplY3RcbiAgLCBnZXRQcm90byAgPSAkLmdldFByb3RvXG4gICwgJFJlZmxlY3QgID0gJC5nLlJlZmxlY3RcbiAgLCBfYXBwbHkgICAgPSBGdW5jdGlvbi5hcHBseVxuICAsIGFzc2VydE9iamVjdCA9IGFzc2VydC5vYmpcbiAgLCBfaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCAkLmlzT2JqZWN0XG4gICwgX3ByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIHx8ICQuaXRcbiAgLy8gSUUgVFAgaGFzIGJyb2tlbiBSZWZsZWN0LmVudW1lcmF0ZVxuICAsIGJ1Z2d5RW51bWVyYXRlID0gISgkUmVmbGVjdCAmJiAkUmVmbGVjdC5lbnVtZXJhdGUgJiYgSVRFUkFUT1IgaW4gJFJlZmxlY3QuZW51bWVyYXRlKHt9KSk7XG5cbmZ1bmN0aW9uIEVudW1lcmF0ZShpdGVyYXRlZCl7XG4gICQuc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgazogdW5kZWZpbmVkLCBpOiAwfSk7XG59XG4kaXRlci5jcmVhdGUoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIGl0ZXIgPSB0aGlzW0lURVJdXG4gICAgLCBrZXlzID0gaXRlci5rXG4gICAgLCBrZXk7XG4gIGlmKGtleXMgPT0gdW5kZWZpbmVkKXtcbiAgICBpdGVyLmsgPSBrZXlzID0gW107XG4gICAgZm9yKGtleSBpbiBpdGVyLm8pa2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgZG8ge1xuICAgIGlmKGl0ZXIuaSA+PSBrZXlzLmxlbmd0aClyZXR1cm4gc3RlcCgxKTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW2l0ZXIuaSsrXSkgaW4gaXRlci5vKSk7XG4gIHJldHVybiBzdGVwKDAsIGtleSk7XG59KTtcblxudmFyIHJlZmxlY3QgPSB7XG4gIC8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3Qpe1xuICAgIHJldHVybiBfYXBwbHkuY2FsbCh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCk7XG4gIH0sXG4gIC8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgdmFyIHByb3RvICAgID0gYXNzZXJ0LmZuKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdKS5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSAkLmNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAsIHJlc3VsdCAgID0gX2FwcGx5LmNhbGwodGFyZ2V0LCBpbnN0YW5jZSwgYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfSxcbiAgLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpe1xuICAgIGFzc2VydE9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICAkLnNldERlc2ModGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gJC5nZXREZXNjKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfSxcbiAgLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xuICAgIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgICAsIGRlc2MgPSAkLmdldERlc2MoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KSwgcHJvdG87XG4gICAgaWYoZGVzYylyZXR1cm4gJC5oYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgOiBkZXNjLmdldCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KSlcbiAgICAgID8gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiAkLmdldERlc2MoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfSxcbiAgLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KXtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xuICB9LFxuICAvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfSxcbiAgLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCl7XG4gICAgcmV0dXJuIF9pc0V4dGVuc2libGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xuICB9LFxuICAvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG4gIG93bktleXM6IHJlcXVpcmUoJy4vJC5vd24ta2V5cycpLFxuICAvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KXtcbiAgICBhc3NlcnRPYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgX3ByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgVi8qLCByZWNlaXZlciovKXtcbiAgICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxuICAgICAgLCBvd25EZXNjICA9ICQuZ2V0RGVzYyhhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXG4gICAgICAsIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gICAgaWYoIW93bkRlc2Mpe1xuICAgICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90byh0YXJnZXQpKSl7XG4gICAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgICB9XG4gICAgICBvd25EZXNjID0gJC5kZXNjKDApO1xuICAgIH1cbiAgICBpZigkLmhhcyhvd25EZXNjLCAndmFsdWUnKSl7XG4gICAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9ICQuZ2V0RGVzYyhyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8ICQuZGVzYygwKTtcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgICAkLnNldERlc2MocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xuICB9XG59O1xuLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG5pZihzZXRQcm90bylyZWZsZWN0LnNldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byl7XG4gIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICB0cnkge1xuICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbiRkZWYoJGRlZi5HLCB7UmVmbGVjdDoge319KTtcblxuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiBidWdneUVudW1lcmF0ZSwgJ1JlZmxlY3QnLCB7XG4gIC8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCl7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcblxuJGRlZigkZGVmLlMsICdSZWZsZWN0JywgcmVmbGVjdCk7IiwidmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNvZiAgICAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCAkUmVnRXhwID0gJC5nLlJlZ0V4cFxuICAsIEJhc2UgICAgPSAkUmVnRXhwXG4gICwgcHJvdG8gICA9ICRSZWdFeHAucHJvdG90eXBlXG4gICwgcmUgICAgICA9IC9hL2dcbiAgLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdFxuICAsIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUpICE9PSByZVxuICAvLyBSZWdFeHAgYWxsb3dzIGEgcmVnZXggd2l0aCBmbGFncyBhcyB0aGUgcGF0dGVyblxuICAsIEFMTE9XU19SRV9XSVRIX0ZMQUdTID0gZnVuY3Rpb24oKXtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICRSZWdFeHAocmUsICdpJykgPT0gJy9hL2knO1xuICAgIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgfSgpO1xuaWYoJC5GVyAmJiAkLkRFU0Mpe1xuICBpZighQ09SUkVDVF9ORVcgfHwgIUFMTE9XU19SRV9XSVRIX0ZMQUdTKXtcbiAgICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHBhdHRlcm4sIGZsYWdzKXtcbiAgICAgIHZhciBwYXR0ZXJuSXNSZWdFeHAgID0gY29mKHBhdHRlcm4pID09ICdSZWdFeHAnXG4gICAgICAgICwgZmxhZ3NJc1VuZGVmaW5lZCA9IGZsYWdzID09PSB1bmRlZmluZWQ7XG4gICAgICBpZighKHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwKSAmJiBwYXR0ZXJuSXNSZWdFeHAgJiYgZmxhZ3NJc1VuZGVmaW5lZClyZXR1cm4gcGF0dGVybjtcbiAgICAgIHJldHVybiBDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBhdHRlcm5Jc1JlZ0V4cCAmJiAhZmxhZ3NJc1VuZGVmaW5lZCA/IHBhdHRlcm4uc291cmNlIDogcGF0dGVybiwgZmxhZ3MpXG4gICAgICAgIDogbmV3IEJhc2UocGF0dGVybklzUmVnRXhwID8gcGF0dGVybi5zb3VyY2UgOiBwYXR0ZXJuXG4gICAgICAgICAgLCBwYXR0ZXJuSXNSZWdFeHAgJiYgZmxhZ3NJc1VuZGVmaW5lZCA/IHBhdHRlcm4uZmxhZ3MgOiBmbGFncyk7XG4gICAgfTtcbiAgICAkLmVhY2guY2FsbCgkLmdldE5hbWVzKEJhc2UpLCBmdW5jdGlvbihrZXkpe1xuICAgICAga2V5IGluICRSZWdFeHAgfHwgJC5zZXREZXNjKCRSZWdFeHAsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgICByZXF1aXJlKCcuLyQucmVkZWYnKSgkLmcsICdSZWdFeHAnLCAkUmVnRXhwKTtcbiAgfVxuICAvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXG4gIGlmKC8uL2cuZmxhZ3MgIT0gJ2cnKSQuc2V0RGVzYyhwcm90bywgJ2ZsYWdzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IHJlcXVpcmUoJy4vJC5yZXBsYWNlcicpKC9eLipcXC8oXFx3KikkLywgJyQxJylcbiAgfSk7XG59XG5yZXF1aXJlKCcuLyQuc3BlY2llcycpKCRSZWdFeHApOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnU2V0Jywge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykoZmFsc2UpO1xuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvTGVuZ3RoID0gJC50b0xlbmd0aDtcblxuLy8gc2hvdWxkIHRocm93IGVycm9yIG9uIHJlZ2V4XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqICFyZXF1aXJlKCcuLyQudGhyb3dzJykoZnVuY3Rpb24oKXsgJ3EnLmVuZHNXaXRoKC8uLyk7IH0pLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgdmFyIHRoYXQgPSBTdHJpbmcoJC5hc3NlcnREZWZpbmVkKHRoaXMpKVxuICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50c1sxXVxuICAgICAgLCBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcbiAgICAgICwgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XG4gICAgcmV0dXJuIHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoU3RyaW5nLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoU3RyaW5nO1xuICB9XG59KTsiLCJ2YXIgJGRlZiAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvSW5kZXggPSByZXF1aXJlKCcuLyQnKS50b0luZGV4XG4gICwgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRkZWYoJGRlZi5TICsgJGRlZi5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdXG4gICAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaSAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGxlbiA+IGkpe1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgcmV0dXJuICEhflN0cmluZygkLmFzc2VydERlZmluZWQodGhpcykpLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCJ2YXIgc2V0ICAgPSByZXF1aXJlKCcuLyQnKS5zZXRcbiAgLCAkYXQgICA9IHJlcXVpcmUoJy4vJC5zdHJpbmctYXQnKSh0cnVlKVxuICAsIElURVIgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ2l0ZXInKVxuICAsICRpdGVyID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIHN0ZXAgID0gJGl0ZXIuc3RlcDtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICBzZXQodGhpcywgSVRFUiwge286IFN0cmluZyhpdGVyYXRlZCksIGk6IDB9KTtcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cbiAgICAsIE8gICAgID0gaXRlci5vXG4gICAgLCBpbmRleCA9IGl0ZXIuaVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiBzdGVwKDEpO1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIGl0ZXIuaSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiBzdGVwKDAsIHBvaW50KTtcbn0pOyIsInZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpe1xuICAgIHZhciB0cGwgPSAkLnRvT2JqZWN0KGNhbGxTaXRlLnJhdylcbiAgICAgICwgbGVuID0gJC50b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBzbG4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlcyA9IFtdXG4gICAgICAsIGkgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBzbG4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwidmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi8kLnN0cmluZy1yZXBlYXQnKVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNvZiAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4vLyBzaG91bGQgdGhyb3cgZXJyb3Igb24gcmVnZXhcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogIXJlcXVpcmUoJy4vJC50aHJvd3MnKShmdW5jdGlvbigpeyAncScuc3RhcnRzV2l0aCgvLi8pOyB9KSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgdmFyIHRoYXQgID0gU3RyaW5nKCQuYXNzZXJ0RGVmaW5lZCh0aGlzKSlcbiAgICAgICwgaW5kZXggPSAkLnRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50c1sxXSwgdGhhdC5sZW5ndGgpKTtcbiAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XG4gICAgcmV0dXJuIHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBzZXRUYWcgICA9IHJlcXVpcmUoJy4vJC5jb2YnKS5zZXRcbiAgLCB1aWQgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHJlZGVmICAgPSByZXF1aXJlKCcuLyQucmVkZWYnKVxuICAsIGtleU9mICAgID0gcmVxdWlyZSgnLi8kLmtleW9mJylcbiAgLCBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vJC5lbnVtLWtleXMnKVxuICAsIGFzc2VydE9iamVjdCA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKS5vYmpcbiAgLCBoYXMgICAgICA9ICQuaGFzXG4gICwgJGNyZWF0ZSAgPSAkLmNyZWF0ZVxuICAsIGdldERlc2MgID0gJC5nZXREZXNjXG4gICwgc2V0RGVzYyAgPSAkLnNldERlc2NcbiAgLCBkZXNjICAgICA9ICQuZGVzY1xuICAsIGdldE5hbWVzID0gJC5nZXROYW1lc1xuICAsIHRvT2JqZWN0ID0gJC50b09iamVjdFxuICAsICRTeW1ib2wgID0gJC5nLlN5bWJvbFxuICAsIHNldHRlciAgID0gZmFsc2VcbiAgLCBUQUcgICAgICA9IHVpZCgndGFnJylcbiAgLCBISURERU4gICA9IHVpZCgnaGlkZGVuJylcbiAgLCBfcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0ge31cbiAgLCBBbGxTeW1ib2xzID0ge31cbiAgLCB1c2VOYXRpdmUgPSAkLmlzRnVuY3Rpb24oJFN5bWJvbCk7XG5cbmZ1bmN0aW9uIHdyYXAodGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9ICQuc2V0KCRjcmVhdGUoJFN5bWJvbC5wcm90b3R5cGUpLCBUQUcsIHRhZyk7XG4gICQuREVTQyAmJiBzZXR0ZXIgJiYgc2V0RGVzYyhPYmplY3QucHJvdG90eXBlLCB0YWcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXREZXNjKHRoaXMsIHRhZywgZGVzYygxLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzeW07XG59XG5cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpc2V0RGVzYyhpdCwgSElEREVOLCBkZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9ICRjcmVhdGUoRCwge2VudW1lcmFibGU6IGRlc2MoMCwgZmFsc2UpfSk7XG4gICAgfVxuICB9IHJldHVybiBzZXREZXNjKGl0LCBrZXksIEQpO1xufVxuZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFzc2VydE9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSlkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59XG5mdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gJGNyZWF0ZShpdCkgOiBkZWZpbmVQcm9wZXJ0aWVzKCRjcmVhdGUoaXQpLCBQKTtcbn1cbmZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gX3Byb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGhpcywga2V5KTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XVxuICAgID8gRSA6IHRydWU7XG59XG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHZhciBEID0gZ2V0RGVzYyhpdCA9IHRvT2JqZWN0KGl0KSwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufVxuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b09iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTilyZXN1bHQucHVzaChrZXkpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIXVzZU5hdGl2ZSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHJldHVybiB3cmFwKHVpZChhcmd1bWVudHNbMF0pKTtcbiAgfTtcbiAgJHJlZGVmKCRTeW1ib2wucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzW1RBR107XG4gIH0pO1xuXG4gICQuY3JlYXRlICAgICA9IGNyZWF0ZTtcbiAgJC5zZXREZXNjICAgID0gZGVmaW5lUHJvcGVydHk7XG4gICQuZ2V0RGVzYyAgICA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJC5zZXREZXNjcyAgID0gZGVmaW5lUHJvcGVydGllcztcbiAgJC5nZXROYW1lcyAgID0gZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgJC5nZXRTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKCQuREVTQyAmJiAkLkZXKSRyZWRlZihPYmplY3QucHJvdG90eXBlLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCBwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG59XG5cbnZhciBzeW1ib2xTdGF0aWNzID0ge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59O1xuLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXG4vLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXG4vLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3Jcbi8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxuLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2Vcbi8vIDE5LjQuMi45IFN5bWJvbC5zZWFyY2hcbi8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xuLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxuLy8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxuLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xuLy8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xuJC5lYWNoLmNhbGwoKFxuICAgICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsJyArXG4gICAgJ3NwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4gICkuc3BsaXQoJywnKSwgZnVuY3Rpb24oaXQpe1xuICAgIHZhciBzeW0gPSByZXF1aXJlKCcuLyQud2tzJykoaXQpO1xuICAgIHN5bWJvbFN0YXRpY3NbaXRdID0gdXNlTmF0aXZlID8gc3ltIDogd3JhcChzeW0pO1xuICB9XG4pO1xuXG5zZXR0ZXIgPSB0cnVlO1xuXG4kZGVmKCRkZWYuRyArICRkZWYuVywge1N5bWJvbDogJFN5bWJvbH0pO1xuXG4kZGVmKCRkZWYuUywgJ1N5bWJvbCcsIHN5bWJvbFN0YXRpY3MpO1xuXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICF1c2VOYXRpdmUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6IGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKCQuZy5KU09OLCAnSlNPTicsIHRydWUpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHdlYWsgICAgICA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGxlYWtTdG9yZSA9IHdlYWsubGVha1N0b3JlXG4gICwgSUQgICAgICAgID0gd2Vhay5JRFxuICAsIFdFQUsgICAgICA9IHdlYWsuV0VBS1xuICAsIGhhcyAgICAgICA9ICQuaGFzXG4gICwgaXNPYmplY3QgID0gJC5pc09iamVjdFxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCB0bXAgICAgICAgPSB7fTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciBXZWFrTWFwID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnV2Vha01hcCcsIHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICBpZihpc09iamVjdChrZXkpKXtcbiAgICAgIGlmKCFpc0V4dGVuc2libGUoa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpLmdldChrZXkpO1xuICAgICAgaWYoaGFzKGtleSwgV0VBSykpcmV0dXJuIGtleVtXRUFLXVt0aGlzW0lEXV07XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIGtleSwgdmFsdWUpO1xuICB9XG59LCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYoJC5GVyAmJiBuZXcgV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICAkLmVhY2guY2FsbChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSBXZWFrTWFwLnByb3RvdHlwZVxuICAgICAgLCBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlcXVpcmUoJy4vJC5yZWRlZicpKHByb3RvLCBrZXksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gbGVha3kgbWFwXG4gICAgICBpZihpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKXtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxlYWtTdG9yZSh0aGlzKVtrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24td2VhaycpO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnV2Vha1NldCcsIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21lbmljL0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRkZWYgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vJC5hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoJ2luY2x1ZGVzJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uLzkzNTM3ODFcbnZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgb3duS2V5cyA9IHJlcXVpcmUoJy4vJC5vd24ta2V5cycpO1xuXG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgPSAkLnRvT2JqZWN0KG9iamVjdClcbiAgICAgICwgcmVzdWx0ID0ge307XG4gICAgJC5lYWNoLmNhbGwob3duS2V5cyhPKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICQuc2V0RGVzYyhyZXN1bHQsIGtleSwgJC5kZXNjKDAsICQuZ2V0RGVzYyhPLCBrZXkpKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiLy8gaHR0cDovL2dvby5nbC9Ya0JyakRcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuZnVuY3Rpb24gY3JlYXRlT2JqZWN0VG9BcnJheShpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICB2YXIgTyAgICAgID0gJC50b09iamVjdChvYmplY3QpXG4gICAgICAsIGtleXMgICA9ICQuZ2V0S2V5cyhPKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpICAgICAgPSAwXG4gICAgICAsIHJlc3VsdCA9IEFycmF5KGxlbmd0aClcbiAgICAgICwga2V5O1xuICAgIGlmKGlzRW50cmllcyl3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IFtrZXkgPSBrZXlzW2krK10sIE9ba2V5XV07XG4gICAgZWxzZSB3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IE9ba2V5c1tpKytdXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogIGNyZWF0ZU9iamVjdFRvQXJyYXkoZmFsc2UpLFxuICBlbnRyaWVzOiBjcmVhdGVPYmplY3RUb0FycmF5KHRydWUpXG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9rYW5nYXgvOTY5ODEwMFxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ1JlZ0V4cCcsIHtcbiAgZXNjYXBlOiByZXF1aXJlKCcuLyQucmVwbGFjZXInKSgvKFtcXFxcXFwtW1xcXXt9KCkqKz8uLF4kfF0pL2csICdcXFxcJDEnLCB0cnVlKVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4ndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykodHJ1ZSk7XG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRwYWQgPSByZXF1aXJlKCcuLyQuc3RyaW5nLXBhZCcpO1xuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIGxwYWQ6IGZ1bmN0aW9uIGxwYWQobil7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbiwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcGFkID0gcmVxdWlyZSgnLi8kLnN0cmluZy1wYWQnKTtcbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICBycGFkOiBmdW5jdGlvbiBycGFkKG4pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG4sIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTsiLCIvLyBKYXZhU2NyaXB0IDEuNiAvIFN0cmF3bWFuIGFycmF5IHN0YXRpY3Mgc2hpbVxudmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkQXJyYXkgID0gJC5jb3JlLkFycmF5IHx8IEFycmF5XG4gICwgc3RhdGljcyA9IHt9O1xuZnVuY3Rpb24gc2V0U3RhdGljcyhrZXlzLCBsZW5ndGgpe1xuICAkLmVhY2guY2FsbChrZXlzLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGtleSl7XG4gICAgaWYobGVuZ3RoID09IHVuZGVmaW5lZCAmJiBrZXkgaW4gJEFycmF5KXN0YXRpY3Nba2V5XSA9ICRBcnJheVtrZXldO1xuICAgIGVsc2UgaWYoa2V5IGluIFtdKXN0YXRpY3Nba2V5XSA9IHJlcXVpcmUoJy4vJC5jdHgnKShGdW5jdGlvbi5jYWxsLCBbXVtrZXldLCBsZW5ndGgpO1xuICB9KTtcbn1cbnNldFN0YXRpY3MoJ3BvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMnLCAxKTtcbnNldFN0YXRpY3MoJ2luZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMnLCAzKTtcbnNldFN0YXRpY3MoJ2pvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZiwnICtcbiAgICAgICAgICAgJ3JlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGwsdHVybicpO1xuJGRlZigkZGVmLlMsICdBcnJheScsIHN0YXRpY3MpOyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgJCAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIEl0ZXJhdG9ycyAgID0gcmVxdWlyZSgnLi8kLml0ZXInKS5JdGVyYXRvcnNcbiAgLCBJVEVSQVRPUiAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5XG4gICwgTm9kZUxpc3QgICAgPSAkLmcuTm9kZUxpc3Q7XG5pZigkLkZXICYmIE5vZGVMaXN0ICYmICEoSVRFUkFUT1IgaW4gTm9kZUxpc3QucHJvdG90eXBlKSl7XG4gICQuaGlkZShOb2RlTGlzdC5wcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG59XG5JdGVyYXRvcnMuTm9kZUxpc3QgPSBBcnJheVZhbHVlczsiLCJ2YXIgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkdGFzayA9IHJlcXVpcmUoJy4vJC50YXNrJyk7XG4kZGVmKCRkZWYuRyArICRkZWYuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGludm9rZSAgICA9IHJlcXVpcmUoJy4vJC5pbnZva2UnKVxuICAsIHBhcnRpYWwgICA9IHJlcXVpcmUoJy4vJC5wYXJ0aWFsJylcbiAgLCBuYXZpZ2F0b3IgPSAkLmcubmF2aWdhdG9yXG4gICwgTVNJRSAgICAgID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xuZnVuY3Rpb24gd3JhcChzZXQpe1xuICByZXR1cm4gTVNJRSA/IGZ1bmN0aW9uKGZuLCB0aW1lIC8qLCAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gc2V0KGludm9rZShcbiAgICAgIHBhcnRpYWwsXG4gICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAkLmlzRnVuY3Rpb24oZm4pID8gZm4gOiBGdW5jdGlvbihmbilcbiAgICApLCB0aW1lKTtcbiAgfSA6IHNldDtcbn1cbiRkZWYoJGRlZi5HICsgJGRlZi5CICsgJGRlZi5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiAgd3JhcCgkLmcuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKCQuZy5zZXRJbnRlcnZhbClcbn0pOyIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnN0YXRpY3MtYWNjZXB0LXByaW1pdGl2ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5zdGF0aWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubHBhZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucnBhZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWdleHAuZXNjYXBlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC50by1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2pzLmFycmF5LnN0YXRpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzLyQnKS5jb3JlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoXG4gICAgICBpbm5lckZuLCBzZWxmIHx8IG51bGwsXG4gICAgICBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSlcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbmVyYXRvciA9IHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpO1xuICAgICAgdmFyIGNhbGxOZXh0ID0gc3RlcC5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgICAgdmFyIGNhbGxUaHJvdyA9IHN0ZXAuYmluZChnZW5lcmF0b3IsIFwidGhyb3dcIik7XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUoaW5mby52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGluZm8udmFsdWUpLnRoZW4oY2FsbE5leHQsIGNhbGxUaHJvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbE5leHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fFxuICAgICAgICAgICAgICAobWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBhcmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0LnNlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVHZW5lcmF0b3JNZXRob2QobWV0aG9kKSB7XG4gICAgR3BbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgfTtcbiAgfVxuICBkZWZpbmVHZW5lcmF0b3JNZXRob2QoXCJuZXh0XCIpO1xuICBkZWZpbmVHZW5lcmF0b3JNZXRob2QoXCJ0aHJvd1wiKTtcbiAgZGVmaW5lR2VuZXJhdG9yTWV0aG9kKFwicmV0dXJuXCIpO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgLy8gUHJlLWluaXRpYWxpemUgYXQgbGVhc3QgMjAgdGVtcG9yYXJ5IHZhcmlhYmxlcyB0byBlbmFibGUgaGlkZGVuXG4gICAgICAvLyBjbGFzcyBvcHRpbWl6YXRpb25zIGZvciBzaW1wbGUgZ2VuZXJhdG9ycy5cbiAgICAgIGZvciAodmFyIHRlbXBJbmRleCA9IDAsIHRlbXBOYW1lO1xuICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCB0ZW1wTmFtZSA9IFwidFwiICsgdGVtcEluZGV4KSB8fCB0ZW1wSW5kZXggPCAyMDtcbiAgICAgICAgICAgKyt0ZW1wSW5kZXgpIHtcbiAgICAgICAgdGhpc1t0ZW1wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvYmFiZWwvcG9seWZpbGxcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1jb3JlL3BvbHlmaWxsXCIpO1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gU3RyaW5nKHN0cmluZylcblxuICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aCAqIDJcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGggPj4+IDFcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbi8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG5CdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCB8IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpcXC1dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuICB2YXIgaSA9IDBcblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgyMDAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCIvKlxuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuT3JpZ2luYWwgTGlicmFyeSBcbiAgLSBDb3B5cmlnaHQgKGMpIE1hcmFrIFNxdWlyZXNcblxuQWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5XG4gLSBDb3B5cmlnaHQgKGMpIFNpbmRyZSBTb3JodXMgPHNpbmRyZXNvcmh1c0BnbWFpbC5jb20+IChzaW5kcmVzb3JodXMuY29tKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbiovXG5cbnZhciBjb2xvcnMgPSB7fTtcbm1vZHVsZVsnZXhwb3J0cyddID0gY29sb3JzO1xuXG5jb2xvcnMudGhlbWVzID0ge307XG5cbnZhciBhbnNpU3R5bGVzID0gY29sb3JzLnN0eWxlcyA9IHJlcXVpcmUoJy4vc3R5bGVzJyk7XG52YXIgZGVmaW5lUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblxuY29sb3JzLnN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCcuL3N5c3RlbS9zdXBwb3J0cy1jb2xvcnMnKTtcblxuaWYgKHR5cGVvZiBjb2xvcnMuZW5hYmxlZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBjb2xvcnMuZW5hYmxlZCA9IGNvbG9ycy5zdXBwb3J0c0NvbG9yO1xufVxuXG5jb2xvcnMuc3RyaXBDb2xvcnMgPSBjb2xvcnMuc3RyaXAgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gKFwiXCIgKyBzdHIpLnJlcGxhY2UoL1xceDFCXFxbXFxkK20vZywgJycpO1xufTtcblxuXG52YXIgc3R5bGl6ZSA9IGNvbG9ycy5zdHlsaXplID0gZnVuY3Rpb24gc3R5bGl6ZSAoc3RyLCBzdHlsZSkge1xuICBpZiAoIWNvbG9ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIHN0cisnJztcbiAgfVxuXG4gIHJldHVybiBhbnNpU3R5bGVzW3N0eWxlXS5vcGVuICsgc3RyICsgYW5zaVN0eWxlc1tzdHlsZV0uY2xvc2U7XG59XG5cbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xudmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UobWF0Y2hPcGVyYXRvcnNSZSwgICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gYnVpbGQoX3N0eWxlcykge1xuICB2YXIgYnVpbGRlciA9IGZ1bmN0aW9uIGJ1aWxkZXIoKSB7XG4gICAgcmV0dXJuIGFwcGx5U3R5bGUuYXBwbHkoYnVpbGRlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgYnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcbiAgLy8gX19wcm90b19fIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcbiAgLy8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlLlxuICBidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvO1xuICByZXR1cm4gYnVpbGRlcjtcbn1cblxudmFyIHN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgYW5zaVN0eWxlcy5ncmV5ID0gYW5zaVN0eWxlcy5ncmF5O1xuICBPYmplY3Qua2V5cyhhbnNpU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBhbnNpU3R5bGVzW2tleV0uY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwKGFuc2lTdHlsZXNba2V5XS5jbG9zZSksICdnJyk7XG4gICAgcmV0W2tleV0gPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkKHRoaXMuX3N0eWxlcy5jb25jYXQoa2V5KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59KSgpO1xuXG52YXIgcHJvdG8gPSBkZWZpbmVQcm9wcyhmdW5jdGlvbiBjb2xvcnMoKSB7fSwgc3R5bGVzKTtcblxuZnVuY3Rpb24gYXBwbHlTdHlsZSgpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBhcmdzTGVuICE9PSAwICYmIFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICBpZiAoYXJnc0xlbiA+IDEpIHtcbiAgICBmb3IgKHZhciBhID0gMTsgYSA8IGFyZ3NMZW47IGErKykge1xuICAgICAgc3RyICs9ICcgJyArIGFyZ3NbYV07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb2xvcnMuZW5hYmxlZCB8fCAhc3RyKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBuZXN0ZWRTdHlsZXMgPSB0aGlzLl9zdHlsZXM7XG5cbiAgdmFyIGkgPSBuZXN0ZWRTdHlsZXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGNvZGUgPSBhbnNpU3R5bGVzW25lc3RlZFN0eWxlc1tpXV07XG4gICAgc3RyID0gY29kZS5vcGVuICsgc3RyLnJlcGxhY2UoY29kZS5jbG9zZVJlLCBjb2RlLm9wZW4pICsgY29kZS5jbG9zZTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGhlbWUgKHRoZW1lKSB7XG4gIGZvciAodmFyIHN0eWxlIGluIHRoZW1lKSB7XG4gICAgKGZ1bmN0aW9uKHN0eWxlKXtcbiAgICAgIGNvbG9yc1tzdHlsZV0gPSBmdW5jdGlvbihzdHIpe1xuICAgICAgICBpZiAodHlwZW9mIHRoZW1lW3N0eWxlXSA9PT0gJ29iamVjdCcpe1xuICAgICAgICAgIHZhciBvdXQgPSBzdHI7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGVtZVtzdHlsZV0pe1xuICAgICAgICAgICAgb3V0ID0gY29sb3JzW3RoZW1lW3N0eWxlXVtpXV0ob3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3JzW3RoZW1lW3N0eWxlXV0oc3RyKTtcbiAgICAgIH07XG4gICAgfSkoc3R5bGUpXG4gIH1cbn1cblxuY29sb3JzLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbG9ycy50aGVtZXNbdGhlbWVdID0gcmVxdWlyZSh0aGVtZSk7XG4gICAgICBhcHBseVRoZW1lKGNvbG9ycy50aGVtZXNbdGhlbWVdKTtcbiAgICAgIHJldHVybiBjb2xvcnMudGhlbWVzW3RoZW1lXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhcHBseVRoZW1lKHRoZW1lKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIHJldCA9IHt9O1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXRbbmFtZV0gPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkKFtuYW1lXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBzZXF1ZW5jZXIgPSBmdW5jdGlvbiBzZXF1ZW5jZXIgKG1hcCwgc3RyKSB7XG4gIHZhciBleHBsb2RlZCA9IHN0ci5zcGxpdChcIlwiKSwgaSA9IDA7XG4gIGV4cGxvZGVkID0gZXhwbG9kZWQubWFwKG1hcCk7XG4gIHJldHVybiBleHBsb2RlZC5qb2luKFwiXCIpO1xufTtcblxuLy8gY3VzdG9tIGZvcm1hdHRlciBtZXRob2RzXG5jb2xvcnMudHJhcCA9IHJlcXVpcmUoJy4vY3VzdG9tL3RyYXAnKTtcbmNvbG9ycy56YWxnbyA9IHJlcXVpcmUoJy4vY3VzdG9tL3phbGdvJyk7XG5cbi8vIG1hcHNcbmNvbG9ycy5tYXBzID0ge307XG5jb2xvcnMubWFwcy5hbWVyaWNhID0gcmVxdWlyZSgnLi9tYXBzL2FtZXJpY2EnKTtcbmNvbG9ycy5tYXBzLnplYnJhID0gcmVxdWlyZSgnLi9tYXBzL3plYnJhJyk7XG5jb2xvcnMubWFwcy5yYWluYm93ID0gcmVxdWlyZSgnLi9tYXBzL3JhaW5ib3cnKTtcbmNvbG9ycy5tYXBzLnJhbmRvbSA9IHJlcXVpcmUoJy4vbWFwcy9yYW5kb20nKVxuXG5mb3IgKHZhciBtYXAgaW4gY29sb3JzLm1hcHMpIHtcbiAgKGZ1bmN0aW9uKG1hcCl7XG4gICAgY29sb3JzW21hcF0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2VyKGNvbG9ycy5tYXBzW21hcF0sIHN0cik7XG4gICAgfVxuICB9KShtYXApXG59XG5cbmRlZmluZVByb3BzKGNvbG9ycywgaW5pdCgpKTsiLCJtb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uIHJ1blRoZVRyYXAgKHRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIHRleHQgPSB0ZXh0IHx8IFwiUnVuIHRoZSB0cmFwLCBkcm9wIHRoZSBiYXNzXCI7XG4gIHRleHQgPSB0ZXh0LnNwbGl0KCcnKTtcbiAgdmFyIHRyYXAgPSB7XG4gICAgYTogW1wiXFx1MDA0MFwiLCBcIlxcdTAxMDRcIiwgXCJcXHUwMjNhXCIsIFwiXFx1MDI0NVwiLCBcIlxcdTAzOTRcIiwgXCJcXHUwMzliXCIsIFwiXFx1MDQxNFwiXSxcbiAgICBiOiBbXCJcXHUwMGRmXCIsIFwiXFx1MDE4MVwiLCBcIlxcdTAyNDNcIiwgXCJcXHUwMjZlXCIsIFwiXFx1MDNiMlwiLCBcIlxcdTBlM2ZcIl0sXG4gICAgYzogW1wiXFx1MDBhOVwiLCBcIlxcdTAyM2JcIiwgXCJcXHUwM2ZlXCJdLFxuICAgIGQ6IFtcIlxcdTAwZDBcIiwgXCJcXHUwMThhXCIsIFwiXFx1MDUwMFwiICwgXCJcXHUwNTAxXCIgLFwiXFx1MDUwMlwiLCBcIlxcdTA1MDNcIl0sXG4gICAgZTogW1wiXFx1MDBjYlwiLCBcIlxcdTAxMTVcIiwgXCJcXHUwMThlXCIsIFwiXFx1MDI1OFwiLCBcIlxcdTAzYTNcIiwgXCJcXHUwM2JlXCIsIFwiXFx1MDRiY1wiLCBcIlxcdTBhNmNcIl0sXG4gICAgZjogW1wiXFx1MDRmYVwiXSxcbiAgICBnOiBbXCJcXHUwMjYyXCJdLFxuICAgIGg6IFtcIlxcdTAxMjZcIiwgXCJcXHUwMTk1XCIsIFwiXFx1MDRhMlwiLCBcIlxcdTA0YmFcIiwgXCJcXHUwNGM3XCIsIFwiXFx1MDUwYVwiXSxcbiAgICBpOiBbXCJcXHUwZjBmXCJdLFxuICAgIGo6IFtcIlxcdTAxMzRcIl0sXG4gICAgazogW1wiXFx1MDEzOFwiLCBcIlxcdTA0YTBcIiwgXCJcXHUwNGMzXCIsIFwiXFx1MDUxZVwiXSxcbiAgICBsOiBbXCJcXHUwMTM5XCJdLFxuICAgIG06IFtcIlxcdTAyOGRcIiwgXCJcXHUwNGNkXCIsIFwiXFx1MDRjZVwiLCBcIlxcdTA1MjBcIiwgXCJcXHUwNTIxXCIsIFwiXFx1MGQ2OVwiXSxcbiAgICBuOiBbXCJcXHUwMGQxXCIsIFwiXFx1MDE0YlwiLCBcIlxcdTAxOWRcIiwgXCJcXHUwMzc2XCIsIFwiXFx1MDNhMFwiLCBcIlxcdTA0OGFcIl0sXG4gICAgbzogW1wiXFx1MDBkOFwiLCBcIlxcdTAwZjVcIiwgXCJcXHUwMGY4XCIsIFwiXFx1MDFmZVwiLCBcIlxcdTAyOThcIiwgXCJcXHUwNDdhXCIsIFwiXFx1MDVkZFwiLCBcIlxcdTA2ZGRcIiwgXCJcXHUwZTRmXCJdLFxuICAgIHA6IFtcIlxcdTAxZjdcIiwgXCJcXHUwNDhlXCJdLFxuICAgIHE6IFtcIlxcdTA5Y2RcIl0sXG4gICAgcjogW1wiXFx1MDBhZVwiLCBcIlxcdTAxYTZcIiwgXCJcXHUwMjEwXCIsIFwiXFx1MDI0Y1wiLCBcIlxcdTAyODBcIiwgXCJcXHUwNDJmXCJdLFxuICAgIHM6IFtcIlxcdTAwYTdcIiwgXCJcXHUwM2RlXCIsIFwiXFx1MDNkZlwiLCBcIlxcdTAzZThcIl0sXG4gICAgdDogW1wiXFx1MDE0MVwiLCBcIlxcdTAxNjZcIiwgXCJcXHUwMzczXCJdLFxuICAgIHU6IFtcIlxcdTAxYjFcIiwgXCJcXHUwNTRkXCJdLFxuICAgIHY6IFtcIlxcdTA1ZDhcIl0sXG4gICAgdzogW1wiXFx1MDQyOFwiLCBcIlxcdTA0NjBcIiwgXCJcXHUwNDdjXCIsIFwiXFx1MGQ3MFwiXSxcbiAgICB4OiBbXCJcXHUwNGIyXCIsIFwiXFx1MDRmZVwiLCBcIlxcdTA0ZmNcIiwgXCJcXHUwNGZkXCJdLFxuICAgIHk6IFtcIlxcdTAwYTVcIiwgXCJcXHUwNGIwXCIsIFwiXFx1MDRjYlwiXSxcbiAgICB6OiBbXCJcXHUwMWI1XCIsIFwiXFx1MDI0MFwiXVxuICB9XG4gIHRleHQuZm9yRWFjaChmdW5jdGlvbihjKXtcbiAgICBjID0gYy50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjaGFycyA9IHRyYXBbY10gfHwgW1wiIFwiXTtcbiAgICB2YXIgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiB0cmFwW2NdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXN1bHQgKz0gdHJhcFtjXVtyYW5kXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGM7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcblxufVxuIiwiLy8gcGxlYXNlIG5vXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uIHphbGdvKHRleHQsIG9wdGlvbnMpIHtcbiAgdGV4dCA9IHRleHQgfHwgXCIgICBoZSBpcyBoZXJlICAgXCI7XG4gIHZhciBzb3VsID0ge1xuICAgIFwidXBcIiA6IFtcbiAgICAgICfMjScsICfMjicsICfMhCcsICfMhScsXG4gICAgICAnzL8nLCAnzJEnLCAnzIYnLCAnzJAnLFxuICAgICAgJ82SJywgJ82XJywgJ82RJywgJ8yHJyxcbiAgICAgICfMiCcsICfMiicsICfNgicsICfMkycsXG4gICAgICAnzIgnLCAnzYonLCAnzYsnLCAnzYwnLFxuICAgICAgJ8yDJywgJ8yCJywgJ8yMJywgJ82QJyxcbiAgICAgICfMgCcsICfMgScsICfMiycsICfMjycsXG4gICAgICAnzJInLCAnzJMnLCAnzJQnLCAnzL0nLFxuICAgICAgJ8yJJywgJ82jJywgJ82kJywgJ82lJyxcbiAgICAgICfNpicsICfNpycsICfNqCcsICfNqScsXG4gICAgICAnzaonLCAnzasnLCAnzawnLCAnza0nLFxuICAgICAgJ82uJywgJ82vJywgJ8y+JywgJ82bJyxcbiAgICAgICfNhicsICfMmidcbiAgICBdLFxuICAgIFwiZG93blwiIDogW1xuICAgICAgJ8yWJywgJ8yXJywgJ8yYJywgJ8yZJyxcbiAgICAgICfMnCcsICfMnScsICfMnicsICfMnycsXG4gICAgICAnzKAnLCAnzKQnLCAnzKUnLCAnzKYnLFxuICAgICAgJ8ypJywgJ8yqJywgJ8yrJywgJ8ysJyxcbiAgICAgICfMrScsICfMricsICfMrycsICfMsCcsXG4gICAgICAnzLEnLCAnzLInLCAnzLMnLCAnzLknLFxuICAgICAgJ8y6JywgJ8y7JywgJ8y8JywgJ82FJyxcbiAgICAgICfNhycsICfNiCcsICfNiScsICfNjScsXG4gICAgICAnzY4nLCAnzZMnLCAnzZQnLCAnzZUnLFxuICAgICAgJ82WJywgJ82ZJywgJ82aJywgJ8yjJ1xuICAgIF0sXG4gICAgXCJtaWRcIiA6IFtcbiAgICAgICfMlScsICfMmycsICfMgCcsICfMgScsXG4gICAgICAnzZgnLCAnzKEnLCAnzKInLCAnzKcnLFxuICAgICAgJ8yoJywgJ8y0JywgJ8y1JywgJ8y2JyxcbiAgICAgICfNnCcsICfNnScsICfNnicsXG4gICAgICAnzZ8nLCAnzaAnLCAnzaInLCAnzLgnLFxuICAgICAgJ8y3JywgJ82hJywgJyDSiSdcbiAgICBdXG4gIH0sXG4gIGFsbCA9IFtdLmNvbmNhdChzb3VsLnVwLCBzb3VsLmRvd24sIHNvdWwubWlkKSxcbiAgemFsZ28gPSB7fTtcblxuICBmdW5jdGlvbiByYW5kb21OdW1iZXIocmFuZ2UpIHtcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzX2NoYXIoY2hhcmFjdGVyKSB7XG4gICAgdmFyIGJvb2wgPSBmYWxzZTtcbiAgICBhbGwuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICBib29sID0gKGkgPT09IGNoYXJhY3Rlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvb2w7XG4gIH1cbiAgXG5cbiAgZnVuY3Rpb24gaGVDb21lcyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnLCBjb3VudHMsIGw7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9uc1tcInVwXCJdID0gICB0eXBlb2Ygb3B0aW9uc1tcInVwXCJdICAgIT09ICd1bmRlZmluZWQnID8gb3B0aW9uc1tcInVwXCJdICAgOiB0cnVlO1xuICAgIG9wdGlvbnNbXCJtaWRcIl0gPSAgdHlwZW9mIG9wdGlvbnNbXCJtaWRcIl0gICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnNbXCJtaWRcIl0gIDogdHJ1ZTtcbiAgICBvcHRpb25zW1wiZG93blwiXSA9IHR5cGVvZiBvcHRpb25zW1wiZG93blwiXSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zW1wiZG93blwiXSA6IHRydWU7XG4gICAgb3B0aW9uc1tcInNpemVcIl0gPSB0eXBlb2Ygb3B0aW9uc1tcInNpemVcIl0gIT09ICd1bmRlZmluZWQnID8gb3B0aW9uc1tcInNpemVcIl0gOiBcIm1heGlcIjtcbiAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnJyk7XG4gICAgZm9yIChsIGluIHRleHQpIHtcbiAgICAgIGlmIChpc19jaGFyKGwpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdGV4dFtsXTtcbiAgICAgIGNvdW50cyA9IHtcInVwXCIgOiAwLCBcImRvd25cIiA6IDAsIFwibWlkXCIgOiAwfTtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5zaXplKSB7XG4gICAgICBjYXNlICdtaW5pJzpcbiAgICAgICAgY291bnRzLnVwID0gcmFuZG9tTnVtYmVyKDgpO1xuICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDIpO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXhpJzpcbiAgICAgICAgY291bnRzLnVwID0gcmFuZG9tTnVtYmVyKDE2KSArIDM7XG4gICAgICAgIGNvdW50cy5taWQgPSByYW5kb21OdW1iZXIoNCkgKyAxO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig2NCkgKyAzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcig4KSArIDE7XG4gICAgICAgIGNvdW50cy5taWQgPSByYW5kb21OdW1iZXIoNikgLyAyO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig4KSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyID0gW1widXBcIiwgXCJtaWRcIiwgXCJkb3duXCJdO1xuICAgICAgZm9yICh2YXIgZCBpbiBhcnIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJyW2RdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPD0gY291bnRzW2luZGV4XTsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnNbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBzb3VsW2luZGV4XVtyYW5kb21OdW1iZXIoc291bFtpbmRleF0ubGVuZ3RoKV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gZG9uJ3Qgc3VtbW9uIGhpbVxuICByZXR1cm4gaGVDb21lcyh0ZXh0LCBvcHRpb25zKTtcbn1cbiIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uICgpIHtcblxuICAvL1xuICAvLyBFeHRlbmRzIHByb3RvdHlwZSBvZiBuYXRpdmUgc3RyaW5nIG9iamVjdCB0byBhbGxvdyBmb3IgXCJmb29cIi5yZWQgc3ludGF4XG4gIC8vXG4gIHZhciBhZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChjb2xvciwgZnVuYykge1xuICAgIFN0cmluZy5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhjb2xvciwgZnVuYyk7XG4gIH07XG5cbiAgdmFyIHNlcXVlbmNlciA9IGZ1bmN0aW9uIHNlcXVlbmNlciAobWFwLCBzdHIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleHBsb2RlZCA9IHRoaXMuc3BsaXQoXCJcIiksIGkgPSAwO1xuICAgICAgICBleHBsb2RlZCA9IGV4cGxvZGVkLm1hcChtYXApO1xuICAgICAgICByZXR1cm4gZXhwbG9kZWQuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgfTtcblxuICBhZGRQcm9wZXJ0eSgnc3RyaXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbG9ycy5zdHJpcCh0aGlzKTtcbiAgfSk7XG5cbiAgYWRkUHJvcGVydHkoJ3N0cmlwQ29sb3JzJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2xvcnMuc3RyaXAodGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwidHJhcFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBjb2xvcnMudHJhcCh0aGlzKTtcbiAgfSk7XG5cbiAgYWRkUHJvcGVydHkoXCJ6YWxnb1wiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBjb2xvcnMuemFsZ28odGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwiemVicmFcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLnplYnJhKHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcInJhaW5ib3dcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLnJhaW5ib3codGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwicmFuZG9tXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGNvbG9ycy5yYW5kb20odGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwiYW1lcmljYVwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBjb2xvcnMuYW1lcmljYSh0aGlzKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBkZWZhdWx0IHN0eWxlcyBhbmQgY29sb3JzXG4gIC8vXG4gIHZhciB4ID0gT2JqZWN0LmtleXMoY29sb3JzLnN0eWxlcyk7XG4gIHguZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBhZGRQcm9wZXJ0eShzdHlsZSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvbG9ycy5zdHlsaXplKHRoaXMsIHN0eWxlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYXBwbHlUaGVtZSh0aGVtZSkge1xuICAgIC8vXG4gICAgLy8gUmVtYXJrOiBUaGlzIGlzIGEgbGlzdCBvZiBtZXRob2RzIHRoYXQgZXhpc3RcbiAgICAvLyBvbiBTdHJpbmcgdGhhdCB5b3Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUuXG4gICAgLy9cbiAgICB2YXIgc3RyaW5nUHJvdG90eXBlQmxhY2tsaXN0ID0gW1xuICAgICAgJ19fZGVmaW5lR2V0dGVyX18nLCAnX19kZWZpbmVTZXR0ZXJfXycsICdfX2xvb2t1cEdldHRlcl9fJywgJ19fbG9va3VwU2V0dGVyX18nLCAnY2hhckF0JywgJ2NvbnN0cnVjdG9yJyxcbiAgICAgICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnLCAnY2hhckNvZGVBdCcsXG4gICAgICAnaW5kZXhPZicsICdsYXN0SW5kZXhvZicsICdsZW5ndGgnLCAnbG9jYWxlQ29tcGFyZScsICdtYXRjaCcsICdyZXBsYWNlJywgJ3NlYXJjaCcsICdzbGljZScsICdzcGxpdCcsICdzdWJzdHJpbmcnLFxuICAgICAgJ3RvTG9jYWxlTG93ZXJDYXNlJywgJ3RvTG9jYWxlVXBwZXJDYXNlJywgJ3RvTG93ZXJDYXNlJywgJ3RvVXBwZXJDYXNlJywgJ3RyaW0nLCAndHJpbUxlZnQnLCAndHJpbVJpZ2h0J1xuICAgIF07XG5cbiAgICBPYmplY3Qua2V5cyh0aGVtZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgaWYgKHN0cmluZ1Byb3RvdHlwZUJsYWNrbGlzdC5pbmRleE9mKHByb3ApICE9PSAtMSkge1xuICAgICAgICBjb25zb2xlLmxvZygnd2FybjogJy5yZWQgKyAoJ1N0cmluZy5wcm90b3R5cGUnICsgcHJvcCkubWFnZW50YSArICcgaXMgcHJvYmFibHkgc29tZXRoaW5nIHlvdSBkb25cXCd0IHdhbnQgdG8gb3ZlcnJpZGUuIElnbm9yaW5nIHN0eWxlIG5hbWUnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mKHRoZW1lW3Byb3BdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb2xvcnNbcHJvcF0gPSBjb2xvcnNbdGhlbWVbcHJvcF1dO1xuICAgICAgICAgIGFkZFByb3BlcnR5KHByb3AsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcnNbdGhlbWVbcHJvcF1dKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFkZFByb3BlcnR5KHByb3AsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGVtZVtwcm9wXS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgICByZXQgPSBleHBvcnRzW3RoZW1lW3Byb3BdW3RdXShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29sb3JzLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbG9ycy50aGVtZXNbdGhlbWVdID0gcmVxdWlyZSh0aGVtZSk7XG4gICAgICAgIGFwcGx5VGhlbWUoY29sb3JzLnRoZW1lc1t0aGVtZV0pO1xuICAgICAgICByZXR1cm4gY29sb3JzLnRoZW1lc1t0aGVtZV07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlUaGVtZSh0aGVtZSk7XG4gICAgfVxuICB9O1xuXG59OyIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuL2NvbG9ycycpO1xubW9kdWxlWydleHBvcnRzJ10gPSBjb2xvcnM7XG5cbi8vIFJlbWFyazogQnkgZGVmYXVsdCwgY29sb3JzIHdpbGwgYWRkIHN0eWxlIHByb3BlcnRpZXMgdG8gU3RyaW5nLnByb3RvdHlwZVxuLy9cbi8vIElmIHlvdSBkb24ndCB3aXNoIHRvIGV4dGVuZCBTdHJpbmcucHJvdG90eXBlIHlvdSBjYW4gZG8gdGhpcyBpbnN0ZWFkIGFuZCBuYXRpdmUgU3RyaW5nIHdpbGwgbm90IGJlIHRvdWNoZWRcbi8vXG4vLyAgIHZhciBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZSk7XG4vLyAgIGNvbG9ycy5yZWQoXCJmb29cIilcbi8vXG4vL1xucmVxdWlyZSgnLi9leHRlbmRTdHJpbmdQcm90b3R5cGUnKSgpOyIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuLi9jb2xvcnMnKTtcblxubW9kdWxlWydleHBvcnRzJ10gPSAoZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICAgIGlmKGxldHRlciA9PT0gXCIgXCIpIHJldHVybiBsZXR0ZXI7XG4gICAgc3dpdGNoKGklMykge1xuICAgICAgY2FzZSAwOiByZXR1cm4gY29sb3JzLnJlZChsZXR0ZXIpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gY29sb3JzLndoaXRlKGxldHRlcilcbiAgICAgIGNhc2UgMjogcmV0dXJuIGNvbG9ycy5ibHVlKGxldHRlcilcbiAgICB9XG4gIH1cbn0pKCk7IiwidmFyIGNvbG9ycyA9IHJlcXVpcmUoJy4uL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByYWluYm93Q29sb3JzID0gWydyZWQnLCAneWVsbG93JywgJ2dyZWVuJywgJ2JsdWUnLCAnbWFnZW50YSddOyAvL1JvWSBHIEJpVlxuICByZXR1cm4gZnVuY3Rpb24gKGxldHRlciwgaSwgZXhwbG9kZWQpIHtcbiAgICBpZiAobGV0dGVyID09PSBcIiBcIikge1xuICAgICAgcmV0dXJuIGxldHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbG9yc1tyYWluYm93Q29sb3JzW2krKyAlIHJhaW5ib3dDb2xvcnMubGVuZ3RoXV0obGV0dGVyKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG4iLCJ2YXIgY29sb3JzID0gcmVxdWlyZSgnLi4vY29sb3JzJyk7XG5cbm1vZHVsZVsnZXhwb3J0cyddID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF2YWlsYWJsZSA9IFsndW5kZXJsaW5lJywgJ2ludmVyc2UnLCAnZ3JleScsICd5ZWxsb3cnLCAncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAnd2hpdGUnLCAnY3lhbicsICdtYWdlbnRhJ107XG4gIHJldHVybiBmdW5jdGlvbihsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gICAgcmV0dXJuIGxldHRlciA9PT0gXCIgXCIgPyBsZXR0ZXIgOiBjb2xvcnNbYXZhaWxhYmxlW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChhdmFpbGFibGUubGVuZ3RoIC0gMSkpXV0obGV0dGVyKTtcbiAgfTtcbn0pKCk7IiwidmFyIGNvbG9ycyA9IHJlcXVpcmUoJy4uL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uIChsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gIHJldHVybiBpICUgMiA9PT0gMCA/IGxldHRlciA6IGNvbG9ycy5pbnZlcnNlKGxldHRlcik7XG59OyIsIi8qXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgc3R5bGVzID0ge307XG5tb2R1bGVbJ2V4cG9ydHMnXSA9IHN0eWxlcztcblxudmFyIGNvZGVzID0ge1xuICByZXNldDogWzAsIDBdLFxuXG4gIGJvbGQ6IFsxLCAyMl0sXG4gIGRpbTogWzIsIDIyXSxcbiAgaXRhbGljOiBbMywgMjNdLFxuICB1bmRlcmxpbmU6IFs0LCAyNF0sXG4gIGludmVyc2U6IFs3LCAyN10sXG4gIGhpZGRlbjogWzgsIDI4XSxcbiAgc3RyaWtldGhyb3VnaDogWzksIDI5XSxcblxuICBibGFjazogWzMwLCAzOV0sXG4gIHJlZDogWzMxLCAzOV0sXG4gIGdyZWVuOiBbMzIsIDM5XSxcbiAgeWVsbG93OiBbMzMsIDM5XSxcbiAgYmx1ZTogWzM0LCAzOV0sXG4gIG1hZ2VudGE6IFszNSwgMzldLFxuICBjeWFuOiBbMzYsIDM5XSxcbiAgd2hpdGU6IFszNywgMzldLFxuICBncmF5OiBbOTAsIDM5XSxcbiAgZ3JleTogWzkwLCAzOV0sXG5cbiAgYmdCbGFjazogWzQwLCA0OV0sXG4gIGJnUmVkOiBbNDEsIDQ5XSxcbiAgYmdHcmVlbjogWzQyLCA0OV0sXG4gIGJnWWVsbG93OiBbNDMsIDQ5XSxcbiAgYmdCbHVlOiBbNDQsIDQ5XSxcbiAgYmdNYWdlbnRhOiBbNDUsIDQ5XSxcbiAgYmdDeWFuOiBbNDYsIDQ5XSxcbiAgYmdXaGl0ZTogWzQ3LCA0OV0sXG5cbiAgLy8gbGVnYWN5IHN0eWxlcyBmb3IgY29sb3JzIHByZSB2MS4wLjBcbiAgYmxhY2tCRzogWzQwLCA0OV0sXG4gIHJlZEJHOiBbNDEsIDQ5XSxcbiAgZ3JlZW5CRzogWzQyLCA0OV0sXG4gIHllbGxvd0JHOiBbNDMsIDQ5XSxcbiAgYmx1ZUJHOiBbNDQsIDQ5XSxcbiAgbWFnZW50YUJHOiBbNDUsIDQ5XSxcbiAgY3lhbkJHOiBbNDYsIDQ5XSxcbiAgd2hpdGVCRzogWzQ3LCA0OV1cblxufTtcblxuT2JqZWN0LmtleXMoY29kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdmFsID0gY29kZXNba2V5XTtcbiAgdmFyIHN0eWxlID0gc3R5bGVzW2tleV0gPSBbXTtcbiAgc3R5bGUub3BlbiA9ICdcXHUwMDFiWycgKyB2YWxbMF0gKyAnbSc7XG4gIHN0eWxlLmNsb3NlID0gJ1xcdTAwMWJbJyArIHZhbFsxXSArICdtJztcbn0pOyIsIi8qXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgYXJndiA9IHByb2Nlc3MuYXJndjtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndi5pbmRleE9mKCctLW5vLWNvbG9yJykgIT09IC0xIHx8XG4gICAgYXJndi5pbmRleE9mKCctLWNvbG9yPWZhbHNlJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyZ3YuaW5kZXhPZignLS1jb2xvcicpICE9PSAtMSB8fFxuICAgIGFyZ3YuaW5kZXhPZignLS1jb2xvcj10cnVlJykgIT09IC0xIHx8XG4gICAgYXJndi5pbmRleE9mKCctLWNvbG9yPWFsd2F5cycpICE9PSAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoJ0NPTE9SVEVSTScgaW4gcHJvY2Vzcy5lbnYpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5URVJNID09PSAnZHVtYicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0pKCk7IiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDEwMDogJ0NvbnRpbnVlJyxcbiAgMTAxOiAnU3dpdGNoaW5nIFByb3RvY29scycsXG4gIDIwMDogJ09LJyxcbiAgMjAxOiAnQ3JlYXRlZCcsXG4gIDIwMjogJ0FjY2VwdGVkJyxcbiAgMjAzOiAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nLFxuICAyMDQ6ICdObyBDb250ZW50JyxcbiAgMjA1OiAnUmVzZXQgQ29udGVudCcsXG4gIDIwNjogJ1BhcnRpYWwgQ29udGVudCcsXG4gIDMwMDogJ011bHRpcGxlIENob2ljZXMnLFxuICAzMDE6ICdNb3ZlZCBQZXJtYW5lbnRseScsXG4gIDMwMjogJ0ZvdW5kJyxcbiAgMzAzOiAnU2VlIE90aGVyJyxcbiAgMzA0OiAnTm90IE1vZGlmaWVkJyxcbiAgMzA1OiAnVXNlIFByb3h5JyxcbiAgMzA3OiAnVGVtcG9yYXJ5IFJlZGlyZWN0JyxcbiAgNDAwOiAnQmFkIFJlcXVlc3QnLFxuICA0MDE6ICdVbmF1dGhvcml6ZWQnLFxuICA0MDI6ICdQYXltZW50IFJlcXVpcmVkJyxcbiAgNDAzOiAnRm9yYmlkZGVuJyxcbiAgNDA0OiAnTm90IEZvdW5kJyxcbiAgNDA1OiAnTWV0aG9kIE5vdCBBbGxvd2VkJyxcbiAgNDA2OiAnTm90IEFjY2VwdGFibGUnLFxuICA0MDc6ICdQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcsXG4gIDQwODogJ1JlcXVlc3QgVGltZS1vdXQnLFxuICA0MDk6ICdDb25mbGljdCcsXG4gIDQxMDogJ0dvbmUnLFxuICA0MTE6ICdMZW5ndGggUmVxdWlyZWQnLFxuICA0MTI6ICdQcmVjb25kaXRpb24gRmFpbGVkJyxcbiAgNDEzOiAnUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlJyxcbiAgNDE0OiAnUmVxdWVzdC1VUkkgVG9vIExhcmdlJyxcbiAgNDE1OiAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZScsXG4gIDQxNjogJ1JlcXVlc3RlZCBSYW5nZSBub3QgU2F0aXNmaWFibGUnLFxuICA0MTc6ICdFeHBlY3RhdGlvbiBGYWlsZWQnLFxuICA0MjI6ICdVbnByb2Nlc3NhYmxlIEVudGl0eScsXG4gIDQyOTogJ1RvbyBNYW55IFJlcXVlc3RzJyxcbiAgNTAwOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyxcbiAgNTAxOiAnTm90IEltcGxlbWVudGVkJyxcbiAgNTAyOiAnQmFkIEdhdGV3YXknLFxuICA1MDM6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcbiAgNTA0OiAnR2F0ZXdheSBUaW1lLW91dCcsXG4gIDUwNTogJ0hUVFAgVmVyc2lvbiBub3QgU3VwcG9ydGVkJyxcbiAgQ09OVElOVUU6IDEwMCxcbiAgU1dJVENISU5HX1BST1RPQ09MUzogMTAxLFxuICBPSzogMjAwLFxuICBDUkVBVEVEOiAyMDEsXG4gIEFDQ0VQVEVEOiAyMDIsXG4gIE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OOiAyMDMsXG4gIE5PX0NPTlRFTlQ6IDIwNCxcbiAgUkVTRVRfQ09OVEVOVDogMjA1LFxuICBQQVJUSUFMX0NPTlRFTlQ6IDIwNixcbiAgTVVMVElQTEVfQ0hPSUNFUzogMzAwLFxuICBNT1ZFRF9QRVJNQU5FTlRMWTogMzAxLFxuICBGT1VORDogMzAyLFxuICBTRUVfT1RIRVI6IDMwMyxcbiAgTk9UX01PRElGSUVEOiAzMDQsXG4gIFVTRV9QUk9YWTogMzA1LFxuICBURU1QT1JBUllfUkVESVJFQ1Q6IDMwNyxcbiAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gIFBBWU1FTlRfUkVRVUlSRUQ6IDQwMixcbiAgRk9SQklEREVOOiA0MDMsXG4gIE5PVF9GT1VORDogNDA0LFxuICBNRVRIT0RfTk9UX0FMTE9XRUQ6IDQwNSxcbiAgTk9UX0FDQ0VQVEFCTEU6IDQwNixcbiAgUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDQwNyxcbiAgUkVRVUVTVF9USU1FT1VUOiA0MDgsXG4gIENPTkZMSUNUOiA0MDksXG4gIEdPTkU6IDQxMCxcbiAgTEVOR1RIX1JFUVVJUkVEOiA0MTEsXG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQxMixcbiAgUkVRVUVTVF9FTlRJVFlfVE9PX0xBUkdFOiA0MTMsXG4gIFJFUVVFU1RfVVJJX1RPT19MT05HOiA0MTQsXG4gIFVOU1VQUE9SVEVEX01FRElBX1RZUEU6IDQxNSxcbiAgUkVRVUVTVEVEX1JBTkdFX05PVF9TQVRJU0ZJQUJMRTogNDE2LFxuICBFWFBFQ1RBVElPTl9GQUlMRUQ6IDQxNyxcbiAgVU5QUk9DRVNTQUJMRV9FTlRJVFk6IDQyMixcbiAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG4gIE5PVF9JTVBMRU1FTlRFRDogNTAxLFxuICBCQURfR0FURVdBWTogNTAyLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG4gIEdBVEVXQVlfVElNRU9VVDogNTA0LFxuICBIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRDogNTA1XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjQuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiAtbyAuL2Rpc3QvbG9kYXNoLmpzYFxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS41LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZSBFUzUgZW52aXJvbm1lbnRzICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgdG8gcG9vbCBhcnJheXMgYW5kIG9iamVjdHMgdXNlZCBpbnRlcm5hbGx5ICovXG4gIHZhciBhcnJheVBvb2wgPSBbXSxcbiAgICAgIG9iamVjdFBvb2wgPSBbXTtcblxuICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIHRvIHByZWZpeCBrZXlzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGBfX3Byb3RvX19gIGFuZCBwcm9wZXJ0aWVzIG9uIGBPYmplY3QucHJvdG90eXBlYCAqL1xuICB2YXIga2V5UHJlZml4ID0gK25ldyBEYXRlICsgJyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gNzU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heCBzaXplIG9mIHRoZSBgYXJyYXlQb29sYCBhbmQgYG9iamVjdFBvb2xgICovXG4gIHZhciBtYXhQb29sU2l6ZSA9IDQwO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCB3aGl0ZXNwYWNlICovXG4gIHZhciB3aGl0ZXNwYWNlID0gKFxuICAgIC8vIHdoaXRlc3BhY2VcbiAgICAnIFxcdFxceDBCXFxmXFx4QTBcXHVmZWZmJyArXG5cbiAgICAvLyBsaW5lIHRlcm1pbmF0b3JzXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyB1bmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzXG4gICAgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDAnXG4gICk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIEVTNiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAqIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Z1bmN0aW9uJywgJ01hdGgnLCAnTnVtYmVyJywgJ09iamVjdCcsXG4gICAgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnXycsICdhdHRhY2hFdmVudCcsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLFxuICAgICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkgKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IDA7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCBzaG9ydGN1dHMgKi9cbiAgdmFyIGFyZ3NDbGFzcyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlDbGFzcyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBmdW5jQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FyZ3NDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdCc6ICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSB8fCB0aGlzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AgKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAgKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYCAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgICovXG4gIHZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXNcbiAgICogb3IgYGZyb21JbmRleGAgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb250YWluc2AgZm9yIGNhY2hlIG9iamVjdHMgdGhhdCBtaW1pY3MgdGhlIHJldHVyblxuICAgKiBzaWduYXR1cmUgb2YgYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGNhY2hlID0gY2FjaGUuY2FjaGU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3ZhbHVlXSA/IDAgOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgIH1cbiAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWU7XG4gICAgY2FjaGUgPSAoY2FjaGUgPSBjYWNoZVt0eXBlXSkgJiYgY2FjaGVba2V5XTtcblxuICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnXG4gICAgICA/IChjYWNoZSAmJiBiYXNlSW5kZXhPZihjYWNoZSwgdmFsdWUpID4gLTEgPyAwIDogLTEpXG4gICAgICA6IChjYWNoZSA/IDAgOiAtMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGdpdmVuIHZhbHVlIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgY2FjaGVbdmFsdWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWUsXG4gICAgICAgICAgdHlwZUNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAodHlwZUNhY2hlW2tleV0gfHwgKHR5cGVDYWNoZVtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5tYXhgIGFuZCBgXy5taW5gIGFzIHRoZSBkZWZhdWx0IGNhbGxiYWNrIHdoZW4gYSBnaXZlblxuICAgKiBjb2xsZWN0aW9uIGlzIGEgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGNoYXJhY3RlciB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgZ2l2ZW4gY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIGVsZW1lbnRzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWMgPSBhLmNyaXRlcmlhLFxuICAgICAgICBiYyA9IGIuY3JpdGVyaWEsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFjLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY1tpbmRleF0sXG4gICAgICAgICAgb3RoZXIgPSBiY1tpbmRleF07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgdHlwZW9mIG90aGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYGFgIGFuZCBgYmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgb3IgYG51bGxgIGlmIGNhY2hpbmcgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IGFycmF5WzBdLFxuICAgICAgICBtaWQgPSBhcnJheVsobGVuZ3RoIC8gMikgfCAwXSxcbiAgICAgICAgbGFzdCA9IGFycmF5W2xlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBtaWQgJiYgdHlwZW9mIG1pZCA9PSAnb2JqZWN0JyAmJiBsYXN0ICYmIHR5cGVvZiBsYXN0ID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkXG4gICAqIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IGZyb20gdGhlIGFycmF5IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gYXJyYXlQb29sLnBvcCgpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGZyb20gdGhlIG9iamVjdCBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPYmplY3QoKSB7XG4gICAgcmV0dXJuIG9iamVjdFBvb2wucG9wKCkgfHwge1xuICAgICAgJ2FycmF5JzogbnVsbCxcbiAgICAgICdjYWNoZSc6IG51bGwsXG4gICAgICAnY3JpdGVyaWEnOiBudWxsLFxuICAgICAgJ2ZhbHNlJzogZmFsc2UsXG4gICAgICAnaW5kZXgnOiAwLFxuICAgICAgJ251bGwnOiBmYWxzZSxcbiAgICAgICdudW1iZXInOiBudWxsLFxuICAgICAgJ29iamVjdCc6IG51bGwsXG4gICAgICAncHVzaCc6IG51bGwsXG4gICAgICAnc3RyaW5nJzogbnVsbCxcbiAgICAgICd0cnVlJzogZmFsc2UsXG4gICAgICAndW5kZWZpbmVkJzogZmFsc2UsXG4gICAgICAndmFsdWUnOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYmFjayB0byB0aGUgYXJyYXkgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VBcnJheShhcnJheSkge1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgaWYgKGFycmF5UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgYXJyYXlQb29sLnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGJhY2sgdG8gdGhlIG9iamVjdCBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZU9iamVjdChvYmplY3QpIHtcbiAgICB2YXIgY2FjaGUgPSBvYmplY3QuY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICB9XG4gICAgb2JqZWN0LmFycmF5ID0gb2JqZWN0LmNhY2hlID0gb2JqZWN0LmNyaXRlcmlhID0gb2JqZWN0Lm9iamVjdCA9IG9iamVjdC5udW1iZXIgPSBvYmplY3Quc3RyaW5nID0gb2JqZWN0LnZhbHVlID0gbnVsbDtcbiAgICBpZiAob2JqZWN0UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgb2JqZWN0UG9vbC5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWNlcyB0aGUgYGNvbGxlY3Rpb25gIGZyb20gdGhlIGBzdGFydGAgaW5kZXggdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLFxuICAgKiB0aGUgYGVuZGAgaW5kZXguXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlIGxpc3RzXG4gICAqIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0IHx8IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0IG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcbiAgICAvLyBhZnRlciBidWlsdC1pbiBjb25zdHJ1Y3RvcnMgbGlrZSBgT2JqZWN0YCwgZm9yIHRoZSBjcmVhdGlvbiBvZiBsaXRlcmFscy5cbiAgICAvLyBFUzUgY2xlYXJzIHRoaXMgdXAgYnkgc3RhdGluZyB0aGF0IGxpdGVyYWxzIG11c3QgdXNlIGJ1aWx0LWluIGNvbnN0cnVjdG9ycy5cbiAgICAvLyBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKSA6IHJvb3Q7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBCb29sZWFuID0gY29udGV4dC5Cb29sZWFuLFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBub0NvbmZsaWN0YCAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgW1tDbGFzc11dIG9mIHZhbHVlcyAqL1xuICAgIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICAgIHZhciByZU5hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVJlZi5zcGxpY2UsXG4gICAgICAgIHVuc2hpZnQgPSBhcnJheVJlZi51bnNoaWZ0O1xuXG4gICAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJRSA4IG9ubHkgYWNjZXB0cyBET00gZWxlbWVudHNcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge30sXG4gICAgICAgICAgICBmdW5jID0gaXNOYXRpdmUoZnVuYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xuICAgIHZhciBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVJc05hTiA9IGNvbnRleHQuaXNOYU4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXMsXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCBhIGJ1aWx0LWluIGNvbnN0cnVjdG9yIGJ5IFtbQ2xhc3NdXSAqL1xuICAgIHZhciBjdG9yQnlDbGFzcyA9IHt9O1xuICAgIGN0b3JCeUNsYXNzW2FycmF5Q2xhc3NdID0gQXJyYXk7XG4gICAgY3RvckJ5Q2xhc3NbYm9vbENsYXNzXSA9IEJvb2xlYW47XG4gICAgY3RvckJ5Q2xhc3NbZGF0ZUNsYXNzXSA9IERhdGU7XG4gICAgY3RvckJ5Q2xhc3NbZnVuY0NsYXNzXSA9IEZ1bmN0aW9uO1xuICAgIGN0b3JCeUNsYXNzW29iamVjdENsYXNzXSA9IE9iamVjdDtcbiAgICBjdG9yQnlDbGFzc1tudW1iZXJDbGFzc10gPSBOdW1iZXI7XG4gICAgY3RvckJ5Q2xhc3NbcmVnZXhwQ2xhc3NdID0gUmVnRXhwO1xuICAgIGN0b3JCeUNsYXNzW3N0cmluZ0NsYXNzXSA9IFN0cmluZztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5hYmxlIGludHVpdGl2ZVxuICAgICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIExvLURhc2ggbWV0aG9kcywgd3JhcHBlcnMgYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgYEFycmF5YCBtZXRob2RzOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICAgKiBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXNzaWduYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNoYWluYCwgYGNvbXBhY3RgLFxuICAgICAqIGBjb21wb3NlYCwgYGNvbmNhdGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjcmVhdGVDYWxsYmFja2AsIGBjdXJyeWAsXG4gICAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgICAqIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsXG4gICAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAgICogYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGlja2AsIGBwbHVja2AsIGBwdWxsYCwgYHB1c2hgLFxuICAgICAqIGByYW5nZWAsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCxcbiAgICAgKiBhbmQgYHppcGBcbiAgICAgKlxuICAgICAqIFRoZSBub24tY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgICAqIGBpbmRleE9mYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLFxuICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgICAqIGBsYXN0SW5kZXhPZmAsIGBtaXhpbmAsIGBub0NvbmZsaWN0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVzdWx0YCwgYHNoaWZ0YCwgYHNpemVgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBydW5JbkNvbnRleHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBmdW5jdGlvbnMgYGZpcnN0YCBhbmQgYGxhc3RgIHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGBuYCBpc1xuICAgICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluaW5nIGNhbiBiZSBlbmFibGVkIGJ5IHVzaW5nIHRoZSBgXy5jaGFpbmAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAvLyBkb24ndCB3cmFwIGlmIGFscmVhZHkgd3JhcHBlZCwgZXZlbiBpZiB3cmFwcGVkIGJ5IGEgZGlmZmVyZW50IGBsb2Rhc2hgIGNvbnN0cnVjdG9yXG4gICAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpXG4gICAgICAgPyB2YWx1ZVxuICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFzdCBwYXRoIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluQWxsIEEgZmxhZyB0byBlbmFibGUgY2hhaW5pbmcgZm9yIGFsbCBtZXRob2RzXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBgbmV3IGxvZGFzaFdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBsb2Rhc2hgXG4gICAgbG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBsb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gZmxhZyBlbnZpcm9ubWVudHMgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAhaXNOYXRpdmUoY29udGV4dC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChydW5JbkNvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAgICogZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgLy8gYXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IGRlb3B0aW1pemF0aW9ucyBieSB1c2luZyBgc2xpY2VgIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0FyciA/IHNsaWNlKHZhbHVlKSA6IGFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgICBhcmdzIHx8IChhcmdzID0gc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZVdyYXBwZXIoW2Z1bmMsIChpc0N1cnJ5Qm91bmQgPyBiaXRtYXNrIDogYml0bWFzayAmIH4zKSwgYXJncywgbnVsbCwgdGhpc0FyZywgYXJpdHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncyB8fCAoYXJncyA9IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBpc0xhcmdlID0gbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3QodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGlzU3RyaWN0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAgICogdGhhdCBhbGxvd3MgcGFydGlhbCBcIl8ud2hlcmVcIiBzdHlsZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXNXaGVyZT1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhLFxuICAgICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGEgJiZcbiAgICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgcmV0dXJuICthID09ICtiO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIChhICE9ICthKVxuICAgICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40KVxuICAgICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChhV3JhcHBlZCB8fCBiV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEsIGBhcmd1bWVudHNgIG9iamVjdHMgaGF2ZSBgQXJyYXlgIGNvbnN0cnVjdG9yc1xuICAgICAgICB2YXIgY3RvckEgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY3RvckIgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgICAhKGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiYgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQikgJiZcbiAgICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuICAgICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbaW5kZXhdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2suIFRoZSBnaXZlbiBgc2V0dGVyYCBmdW5jdGlvbiBzZXRzIHRoZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICAgKiBvZiB0aGUgY29tcG9zZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIHNldHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgXG4gICAgICogd2l0aCBhbiBvcHRpb25hbCBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgMSAtIGBfLmJpbmRgXG4gICAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICA0IC0gYF8uY3VycnlgXG4gICAgICogIDggLSBgXy5jdXJyeWAgKGJvdW5kKVxuICAgICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAgICogIDMyIC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsQXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbFJpZ2h0QXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBiaXRtYXNrICYgMzI7XG5cbiAgICAgIGlmICghaXNCaW5kS2V5ICYmICFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsICYmICFwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICAgIGlzUGFydGlhbCA9IHBhcnRpYWxBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjMyO1xuICAgICAgICBpc1BhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMgJiYgZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAoYmluZERhdGEgJiYgYmluZERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgICBiaW5kRGF0YSA9IHNsaWNlKGJpbmREYXRhKTtcbiAgICAgICAgaWYgKGJpbmREYXRhWzJdKSB7XG4gICAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmREYXRhWzNdKSB7XG4gICAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGB0aGlzQmluZGluZ2AgaXMgbm90IHByZXZpb3VzbHkgYm91bmRcbiAgICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgICBpZiAoaXNDdXJyeSAmJiAhKGJpbmREYXRhWzFdICYgNCkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIGxlZnQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgICB1bnNoaWZ0LmFwcGx5KGJpbmREYXRhWzNdIHx8IChiaW5kRGF0YVszXSA9IFtdKSwgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgICAgYmluZERhdGFbMV0gfD0gYml0bWFzaztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgICAgfVxuICAgICAgLy8gZmFzdCBwYXRoIGZvciBgXy5iaW5kYFxuICAgICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiByZU5hdGl2ZS50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgICAqL1xuICAgIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYGlzUGxhaW5PYmplY3RgIHdoaWNoIGNoZWNrcyBpZiBhIGdpdmVuIHZhbHVlXG4gICAgICogaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLCBhc3N1bWluZyBvYmplY3RzIGNyZWF0ZWRcbiAgICAgKiBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IgaGF2ZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFuZCB0aGF0XG4gICAgICogdGhlcmUgYXJlIG5vIGBPYmplY3QucHJvdG90eXBlYCBleHRlbnNpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgY3RvcixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIC8vIGF2b2lkIG5vbiBPYmplY3Qgb2JqZWN0cywgYGFyZ3VtZW50c2Agb2JqZWN0cywgYW5kIERPTSBlbGVtZW50c1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpIHx8XG4gICAgICAgICAgKGN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgaXNGdW5jdGlvbihjdG9yKSAmJiAhKGN0b3IgaW5zdGFuY2VvZiBjdG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAgICAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuICAgICAgLy8gb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICBmb3JJbih2YWx1ZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgdW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sQ2hhcihtYXRjaCkge1xuICAgICAgcmV0dXJuIGh0bWxVbmVzY2FwZXNbbWF0Y2hdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcmd1bWVudHMoYXJndW1lbnRzKTsgfSkoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcnJheShhcmd1bWVudHMpOyB9KSgpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcyB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIHByb2R1Y2VzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIGdpdmVuIG9iamVjdCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICB2YXIgc2hpbUtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghKG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3RdKSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgZm9yIChpbmRleCBpbiBpdGVyYWJsZSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhYmxlLCBpbmRleCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2V5cyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbJ29uZScsICd0d28nLCAndGhyZWUnXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzOlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBgPmAgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2UgYD5gIGFuZCBgL2BcbiAgICAgKiBkb24ndCByZXF1aXJlIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nIHVubGVzcyB0aGV5J3JlIHBhcnRcbiAgICAgKiBvZiBhIHRhZyBvciBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMgKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpXG4gICAgICovXG4gICAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmIzM5OydcbiAgICB9O1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMgKi9cbiAgICB2YXIgaHRtbFVuZXNjYXBlcyA9IGludmVydChodG1sRXNjYXBlcyk7XG5cbiAgICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMgKi9cbiAgICB2YXIgcmVFc2NhcGVkSHRtbCA9IFJlZ0V4cCgnKCcgKyBrZXlzKGh0bWxVbmVzY2FwZXMpLmpvaW4oJ3wnKSArICcpJywgJ2cnKSxcbiAgICAgICAgcmVVbmVzY2FwZWRIdG1sID0gUmVnRXhwKCdbJyArIGtleXMoaHRtbEVzY2FwZXMpLmpvaW4oJycpICsgJ10nLCAnZycpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91c1xuICAgICAqIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZVxuICAgICAqIGFzc2lnbmVkIHZhbHVlcy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnbmFtZSc6ICdmcmVkJyB9LCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiBhID09ICd1bmRlZmluZWQnID8gYiA6IGE7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAgICogZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBndWFyZCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gdHlwZW9mIGd1YXJkID09ICdudW1iZXInID8gMiA6IGFyZ3MubGVuZ3RoO1xuICAgICAgaWYgKGFyZ3NMZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tYXJnc0xlbmd0aCAtIDFdLCBhcmdzW2FyZ3NMZW5ndGgtLV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChhcmdzTGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NbLS1hcmdzTGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgaXRlcmFibGUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSB7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrID8gY2FsbGJhY2socmVzdWx0W2luZGV4XSwgaXRlcmFibGVbaW5kZXhdKSA6IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgd2lsbCBhbHNvXG4gICAgICogYmUgY2xvbmVkLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwPWZhbHNlXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUoY2hhcmFjdGVycyk7XG4gICAgICogc2hhbGxvd1swXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUoY2hhcmFjdGVycywgdHJ1ZSk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5taXhpbih7XG4gICAgICogICAnY2xvbmUnOiBfLnBhcnRpYWxSaWdodChfLmNsb25lLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgKiAgIH0pXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lKGRvY3VtZW50LmJvZHkpO1xuICAgICAqIGNsb25lLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcyB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGBcbiAgICAgIC8vIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzIGZvciBgaXNEZWVwYCBhbmQgYGNhbGxiYWNrYFxuICAgICAgaWYgKHR5cGVvZiBpc0RlZXAgIT0gJ2Jvb2xlYW4nICYmIGlzRGVlcCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSBpc0RlZXA7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmVcbiAgICAgKiBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90KiogY2xvbmVkLiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kXG4gICAgICogb2JqZWN0cyBjcmVhdGVkIGJ5IGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy5cbiAgICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChjaGFyYWN0ZXJzKTtcbiAgICAgKiBkZWVwWzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdub2RlJzogZWxlbWVudFxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lRGVlcCh2aWV3LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZSh0cnVlKSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNsb25lLm5vZGUgPT0gdmlldy5ub2RlO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIHByb3ZpZGVkIGl0cyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZFxuICAgICAqIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7ICdjb25zdHJ1Y3Rvcic6IENpcmNsZSB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID8gYXNzaWduKHJlc3VsdCwgcHJvcGVydGllcykgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIE9uY2UgYVxuICAgICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCBkZWZhdWx0cyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCB3aXRob3V0IHVzaW5nIGl0c1xuICAgICAqICBga2V5YCBhbmQgYG9iamVjdGAgYXJndW1lbnRzIGFzIHNvdXJjZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAgICogXy5kZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgaXRlcmFibGUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSB7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbaW5kZXhdID09ICd1bmRlZmluZWQnKSByZXN1bHRbaW5kZXhdID0gaXRlcmFibGVbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50IHRoYXQgcGFzc2VzIHRoZSBjYWxsYmFjayBjaGVjaywgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgJ2ZyZWQnOiB7ICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogeyAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgLCBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zIGBiYXJuZXlgXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDQwIH0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JPd25SaWdodChvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsXG4gICAgICogZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFNoYXBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgdGhpcy54ICs9IHg7XG4gICAgICogICB0aGlzLnkgKz0geTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgU2hhcGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAneCcsICd5JywgYW5kICdtb3ZlJyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIgZm9ySW4gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IGNvbGxlY3Rpb24sIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgU2hhcGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbW92ZScsICd5JywgYW5kICd4JyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuXG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcGFpcnMucHVzaChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMubGVuZ3RoO1xuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhwYWlyc1tsZW5ndGgtLV0sIHBhaXJzW2xlbmd0aF0sIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCwgZXhlY3V0aW5nIHRoZSBjYWxsYmFja1xuICAgICAqIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodCh7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdsZW5ndGgnLCAnMScsIGFuZCAnMCcgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF07XG4gICAgICAgIGlmIChjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzb3J0ZWQgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgb2YgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyxcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCwgb2YgYG9iamVjdGAgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMoXyk7XG4gICAgICogLy8gPT4gWydhbGwnLCAnYW55JywgJ2JpbmQnLCAnYmluZEFsbCcsICdjbG9uZScsICdjb21wYWN0JywgJ2NvbXBvc2UnLCAuLi5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgbmFtZSBleGlzdHMgYXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAsXG4gICAgICogaW5zdGVhZCBvZiBhbiBpbmhlcml0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBrZXkgaXMgYSBkaXJlY3QgcHJvcGVydHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oYXMoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sICdiJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludmVydCh7ICdmaXJzdCc6ICdmcmVkJywgJ3NlY29uZCc6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAnZmlyc3QnLCAnYmFybmV5JzogJ3NlY29uZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVydChvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W29iamVjdFtrZXldXSA9IGtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBkYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBkYXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZW1wdHkuIEFycmF5cywgc3RyaW5ncywgb3IgYGFyZ3VtZW50c2Agb2JqZWN0cyB3aXRoIGFcbiAgICAgKiBsZW5ndGggb2YgYDBgIGFuZCBvYmplY3RzIHdpdGggbm8gb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29uc2lkZXJlZFxuICAgICAqIFwiZW1wdHlcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KCcnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICBpZiAoKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzIHx8IGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gYXJnc0NsYXNzICkgfHxcbiAgICAgICAgICAoY2xhc3NOYW1lID09IG9iamVjdENsYXNzICYmIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvck93bih2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50IHRvIGVhY2ggb3RoZXIuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBjb21wYXJpc29ucyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChhLCBiKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBjb3B5ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogb2JqZWN0ID09IGNvcHk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIGNvcHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB3b3JkcyA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlcldvcmRzID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwod29yZHMsIG90aGVyV29yZHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHZhciByZUdyZWV0ID0gL14oPzpoZWxsb3xoaSkkL2ksXG4gICAgICogICAgICAgYUdyZWV0ID0gXy5pc1N0cmluZyhhKSAmJiByZUdyZWV0LnRlc3QoYSksXG4gICAgICogICAgICAgYkdyZWV0ID0gXy5pc1N0cmluZyhiKSAmJiByZUdyZWV0LnRlc3QoYik7XG4gICAgICpcbiAgICAgKiAgIHJldHVybiAoYUdyZWV0IHx8IGJHcmVldCkgPyAoYUdyZWV0ID09IGJHcmVldCkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhLCBiLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcywgb3IgY2FuIGJlIGNvZXJjZWQgdG8sIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNGaW5pdGVgIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgZm9yXG4gICAgICogYm9vbGVhbnMgYW5kIGVtcHR5IHN0cmluZ3MuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZmluaXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoLTEwMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKHRydWUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUlzRmluaXRlKHZhbHVlKSAmJiAhbmF0aXZlSXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCgxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgdmFsdWUgaXMgdGhlIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3RcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OFxuICAgICAgLy8gYW5kIGF2b2lkIGEgVjggYnVnXG4gICAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxXG4gICAgICByZXR1cm4gISEodmFsdWUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzTmFOYCB3aGljaCB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1lcmljIHZhbHVlcy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIGBOYU5gIGFzIGEgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZlxuICAgICAgLy8gKHBlcmZvcm0gdGhlIFtbQ2xhc3NdXSBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lIGhvc3Qgb2JqZWN0cyBpbiBJRSlcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBgTmFOYCBpcyBjb25zaWRlcmVkIGEgbnVtYmVyLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3g4LjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDguNCAqIDUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gbnVtYmVyQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgU2hhcGUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc1BsYWluT2JqZWN0ID0gIWdldFByb3RvdHlwZU9mID8gc2hpbUlzUGxhaW5PYmplY3QgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZixcbiAgICAgICAgICBvYmpQcm90byA9IGlzTmF0aXZlKHZhbHVlT2YpICYmIChvYmpQcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlT2YpKSAmJiBnZXRQcm90b3R5cGVPZihvYmpQcm90byk7XG5cbiAgICAgIHJldHVybiBvYmpQcm90b1xuICAgICAgICA/ICh2YWx1ZSA9PSBvYmpQcm90byB8fCBnZXRQcm90b3R5cGVPZih2YWx1ZSkgPT0gb2JqUHJvdG8pXG4gICAgICAgIDogc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2ZyZWQvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gcmVnZXhwQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkIGJ5XG4gICAgICogcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocm91Z2ggdGhlIGNhbGxiYWNrLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB2YWx1ZXMgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXMoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzfSAsIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyhjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAgICAgKiBkb24ndCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzXG4gICAgICogd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBhbmQgc291cmNlIHByb3BlcnRpZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIG1lcmdpbmcgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBuYW1lcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICduYW1lJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ2FnZSc6IDM2IH0sXG4gICAgICogICAgIHsgJ2FnZSc6IDQwIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShuYW1lcywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnY2hhcmFjdGVycyc6IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogdmFyIGZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydhcHBsZSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXJGb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYmFuYW5hJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnY2Fycm90J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShmb29kLCBvdGhlckZvb2QsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzQXJyYXkoYSkgPyBhLmNvbmNhdChiKSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcnVpdHMnOiBbJ2FwcGxlJywgJ2JhbmFuYSddLCAndmVnZXRhYmxlcyc6IFsnYmVldCcsICdjYXJyb3RdIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZShvYmplY3QpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IDI7XG5cbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdICE9ICdudW1iZXInKSB7XG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbbGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWxlbmd0aCAtIDFdLCBhcmdzW2xlbmd0aC0tXSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbbGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NbLS1sZW5ndGhdO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZXMgPSBzbGljZShhcmd1bWVudHMsIDEsIGxlbmd0aCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBzdGFja0EgPSBnZXRBcnJheSgpLFxuICAgICAgICAgIHN0YWNrQiA9IGdldEFycmF5KCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZXNbaW5kZXhdLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgZXhjbHVkaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2hcbiAgICAgKiBwcm9wZXJ0eSBvZiBgb2JqZWN0YCBvbWl0dGluZyB0aGUgcHJvcGVydGllcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleVxuICAgICAqIGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLnN0cmluZ3xzdHJpbmdbXX0gW2NhbGxiYWNrXSBUaGUgcHJvcGVydGllcyB0byBvbWl0IG9yIHRoZVxuICAgICAqICBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRob3V0IHRoZSBvbWl0dGVkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ub21pdCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgcHJvcHMucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMgPSBiYXNlRGlmZmVyZW5jZShwcm9wcywgYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSkpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgYW4gb2JqZWN0J3Mga2V5LXZhbHVlIHBhaXJzLFxuICAgICAqIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIG5ldyBhcnJheSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFpcnMoeyAnYmFybmV5JzogMzYsICdmcmVkJzogNDAgfSk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhaXJzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGNvbXBvc2VkIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2hcbiAgICAgKiBwcm9wZXJ0eSBvZiBgb2JqZWN0YCBwaWNraW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eVxuICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBpY2soeyAnbmFtZSc6ICdmcmVkJywgJ191c2VyaWQnOiAnZnJlZDEnIH0sICduYW1lJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLnBpY2soeyAnbmFtZSc6ICdmcmVkJywgJ191c2VyaWQnOiAnZnJlZDEnIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkuY2hhckF0KDApICE9ICdfJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHByb3BzID0gYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSksXG4gICAgICAgICAgICBsZW5ndGggPSBpc09iamVjdChvYmplY3QpID8gcHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYCB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyB0aHJvdWdoIGEgY2FsbGJhY2ssIHdpdGggZWFjaCBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOyAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNxdWFyZXMgPSBfLnRyYW5zZm9ybShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdLCBmdW5jdGlvbihyZXN1bHQsIG51bSkge1xuICAgICAqICAgbnVtICo9IG51bTtcbiAgICAgKiAgIGlmIChudW0gJSAyKSB7XG4gICAgICogICAgIHJldHVybiByZXN1bHQucHVzaChudW0pIDwgMztcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgOSwgMjVdXG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgIHByb3RvID0gY3RvciAmJiBjdG9yLnByb3RvdHlwZTtcblxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gYmFzZUNyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICAgIChpc0FyciA/IGZvckVhY2ggOiBmb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleGVzLCBvciBrZXlzLCBvZiB0aGVcbiAgICAgKiBgY29sbGVjdGlvbmAuIEluZGV4ZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW118c3RyaW5nfHN0cmluZ1tdKX0gW2luZGV4XSBUaGUgaW5kZXhlcyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiAgIHRvIHJldHJpZXZlLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqICBwcm92aWRlZCBpbmRleGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sIFswLCAyLCA0XSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnLCAnZSddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXQoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3MsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICBsZW5ndGggPSAoYXJnc1syXSAmJiBhcmdzWzJdW2FyZ3NbMV1dID09PSBjb2xsZWN0aW9uKSA/IDEgOiBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIGEgY29sbGVjdGlvbiB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaW5jbHVkZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucygncGViYmxlcycsICdlYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4KSB8fCAwO1xuICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSAoaXNTdHJpbmcoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LCBmcm9tSW5kZXgpIDogaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkpID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoKytpbmRleCA+PSBmcm9tSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IHZhbHVlID09PSB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSsrIDogcmVzdWx0W2tleV0gPSAxKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJucyB0cnVleSB2YWx1ZSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbGxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSAhIWNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9ICEhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBzZWxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGV2ZW5zID0gXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50IHRoYXRcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZGV0ZWN0LCBmaW5kV2hlcmVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2hcbiAgICAgKiBlbGVtZW50LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBgbGVuZ3RoYCBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2goZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zICcxLDIsMydcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyB0aGUgb2JqZWN0IChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaFJpZ2h0KGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgJzMsMiwxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25bbGVuZ3RoXSwgbGVuZ3RoLCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGtleSA9IHByb3BzID8gcHJvcHNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNvbGxlY3Rpb25ba2V5XSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldIDogcmVzdWx0W2tleV0gPSBbXSkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgZ2l2ZW4gY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleXMgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleXMsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleXMsIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShjaGFyYWN0ZXJzLCBmdW5jdGlvbihrZXkpIHsgdGhpcy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9LCBTdHJpbmcpO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIgaW5kZXhCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIG5hbWVkIGJ5IGBtZXRob2ROYW1lYCBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYFxuICAgICAqIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYG1ldGhvZE5hbWVgIGlzIGEgZnVuY3Rpb24gaXRcbiAgICAgKiB3aWxsIGJlIGludm9rZWQgZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlKGNvbGxlY3Rpb24sIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBtZXRob2ROYW1lID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gKGlzRnVuYyA/IG1ldGhvZE5hbWUgOiB2YWx1ZVttZXRob2ROYW1lXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICogdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29sbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmVzdWx0WysraW5kZXhdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPiBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYEluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWluKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWluKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPCBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGFsbCBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHBsdWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayhjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIHZhciBwbHVjayA9IG1hcDtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYSBjb2xsZWN0aW9uIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBjYWxsYmFjayBleGVjdXRpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZXhlY3V0aW9uLiBJZlxuICAgICAqIGBhY2N1bXVsYXRvcmAgaXMgbm90IHByb3ZpZGVkIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBpbml0aWFsIGBhY2N1bXVsYXRvcmAgdmFsdWUuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOyAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRsLCBpbmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzdW0gPSBfLnJlZHVjZShbMSwgMiwgM10sIGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbnVtO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoIWNvbGxlY3Rpb24pIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAobm9hY2N1bSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY29sbGVjdGlvblsrK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbGlzdCA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKiB2YXIgZmxhdCA9IF8ucmVkdWNlUmlnaHQobGlzdCwgZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uIHRoYXQgdGhlIGNhbGxiYWNrIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1ZXkgZm9yLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgZmFpbGVkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9kZHMgPSBfLnJlamVjdChbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSByYW5kb20gZWxlbWVudCBvciBgbmAgcmFuZG9tIGVsZW1lbnRzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGBcbiAgICAgKiAgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50cyBhcyBgbmAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoICE9ICdudW1iZXInKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uID8gY29sbGVjdGlvbltiYXNlUmFuZG9tKDAsIGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNodWZmbGUoY29sbGVjdGlvbik7XG4gICAgICByZXN1bHQubGVuZ3RoID0gbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlIEZpc2hlci1ZYXRlc1xuICAgICAqIHNodWZmbGUuIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IHNodWZmbGVkIGNvbGxlY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNCwgNSwgNl0pO1xuICAgICAqIC8vID0+IFs0LCAxLCA2LCAzLCA1LCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKDAsICsraW5kZXgpO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0W3JhbmRdO1xuICAgICAgICByZXN1bHRbcmFuZF0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGBjb2xsZWN0aW9uLmxlbmd0aGAgZm9yIGFycmF5c1xuICAgICAqIGFuZCBhcnJheS1saWtlIG9iamVjdHMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgY29sbGVjdGlvbi5sZW5ndGhgIG9yIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDJdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydWV5IHZhbHVlIGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYVxuICAgICAqIGNvbGxlY3Rpb24uIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFzIHNvb24gYXMgaXQgZmluZHMgYSBwYXNzaW5nIHZhbHVlIGFuZFxuICAgICAqIGRvZXMgbm90IGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGNvbGxlY3Rpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYW55XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoKHJlc3VsdCA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gIShyZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCB3aWxsIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyXG4gICAgICogb2YgZXF1YWwgZWxlbWVudHMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB3aWxsIGJlIHNvcnRlZCBieSBlYWNoIHByb3BlcnR5IHZhbHVlLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNvcnRlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguc2luKG51bSk7IH0pO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuc2luKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDI2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogMzAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCAnYWdlJyksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAyNl0sIFsnZnJlZCcsIDMwXSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKlxuICAgICAqIC8vIHNvcnRpbmcgYnkgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsIFsnbmFtZScsICdhZ2UnXSksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9ID4gW1snYmFybmV5JywgMjZdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoY2FsbGJhY2spLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0WysraW5kZXhdID0gZ2V0T2JqZWN0KCk7XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIG9iamVjdC5jcml0ZXJpYSA9IG1hcChjYWxsYmFjaywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAob2JqZWN0LmNyaXRlcmlhID0gZ2V0QXJyYXkoKSlbMF0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QuaW5kZXggPSBpbmRleDtcbiAgICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgIHJlc3VsdC5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBvYmplY3QudmFsdWU7XG4gICAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgICByZWxlYXNlQXJyYXkob2JqZWN0LmNyaXRlcmlhKTtcbiAgICAgICAgfVxuICAgICAgICByZWxlYXNlT2JqZWN0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBgY29sbGVjdGlvbmAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpOyB9KSgxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc2xpY2UoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIG9mIGVhY2ggZWxlbWVudCBpbiBhIGBjb2xsZWN0aW9uYCB0byB0aGUgZ2l2ZW5cbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0LCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ud2hlcmUoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9XVxuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdwZXRzJzogWydkaW5vJ10gfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfV1cbiAgICAgKi9cbiAgICB2YXIgd2hlcmUgPSBmaWx0ZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgYWxsIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHZhbHVlcyBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nIHN0cmljdFxuICAgICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXlzIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMSwgMiwgMywgNCwgNV0sIFs1LCAyLCAxMF0pO1xuICAgICAqIC8vID0+IFsxLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpZmZlcmVuY2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IHRoYXQgcGFzc2VzIHRoZSBjYWxsYmFjayBjaGVjaywgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgMjA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlID4gMzA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvciBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgcmV0dXJuZWQgYXMgbG9uZ1xuICAgICAqIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGhlYWQsIHRha2VcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudChzKSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpcnN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlyc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcnN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAobiA9PSBudWxsIHx8IHRoaXNBcmcpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCAwLCBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIG4pLCBsZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheSAodGhlIG5lc3RpbmcgY2FuIGJlIHRvIGFueSBkZXB0aCkuIElmIGBpc1NoYWxsb3dgXG4gICAgICogaXMgdHJ1ZXksIHRoZSBhcnJheSB3aWxsIG9ubHkgYmUgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlXG4gICAgICogZmxhdHRlbmluZy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NoYWxsb3c9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbWzRdXV07XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDMwLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5mbGF0dGVuKGNoYXJhY3RlcnMsICdwZXRzJyk7XG4gICAgICogLy8gPT4gWydob3BweScsICdiYWJ5IHB1c3MnLCAnZGlubyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Jvb2xlYW4nICYmIGlzU2hhbGxvdyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSAodHlwZW9mIGlzU2hhbGxvdyAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NoYWxsb3ddID09PSBhcnJheSkgPyBudWxsIDogaXNTaGFsbG93O1xuICAgICAgICBpc1NoYWxsb3cgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5ID0gbWFwKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBhbHJlYWR5IHNvcnRlZFxuICAgICAqIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgIHdpbGwgcnVuIGEgZmFzdGVyIGJpbmFyeSBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tIG9yIGB0cnVlYFxuICAgICAqICB0byBwZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDEsIDIsIDIsIDMsIDNdLCAyLCB0cnVlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCB8fCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpbmRleF0gPT09IHZhbHVlID8gaW5kZXggOiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb3IgbGFzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGFcbiAgICAgKiBjYWxsYmFjayBpcyBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbVxuICAgICAqIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kXG4gICAgICogdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrPTFdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5pbml0aWFsKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5pbml0aWFsKGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSAoY2FsbGJhY2sgPT0gbnVsbCB8fCB0aGlzQXJnKSA/IDEgOiBjYWxsYmFjayB8fCBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCAwLCBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pLCBsZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBnZXRBcnJheSgpLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgdHJ1c3RJbmRleE9mID0gaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgc2VlbiA9IGdldEFycmF5KCk7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgICAgICBhcmdzLnB1c2godmFsdWUpO1xuICAgICAgICAgIGNhY2hlcy5wdXNoKHRydXN0SW5kZXhPZiAmJiB2YWx1ZS5sZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiZcbiAgICAgICAgICAgIGNyZWF0ZUNhY2hlKGFyZ3NJbmRleCA/IGFyZ3NbYXJnc0luZGV4XSA6IHNlZW4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGFycmF5ID0gYXJnc1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbMF07XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2Yoc2VlbiwgdmFsdWUpKSA8IDApIHtcbiAgICAgICAgICBhcmdzSW5kZXggPSBhcmdzTGVuZ3RoO1xuICAgICAgICAgIChjYWNoZSB8fCBzZWVuKS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB3aGlsZSAoLS1hcmdzSW5kZXgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVzW2FyZ3NJbmRleF07XG4gICAgICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKGFyZ3NbYXJnc0luZGV4XSwgdmFsdWUpKSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzTGVuZ3RoXTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgcmVsZWFzZU9iamVjdChjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbGVhc2VBcnJheShjYWNoZXMpO1xuICAgICAgcmVsZWFzZUFycmF5KHNlZW4pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb3IgbGFzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhcmUgcmV0dXJuZWQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudChzKSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ubGFzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubGFzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAobiA9PSBudWxsIHx8IHRoaXNBcmcpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCBuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkXG4gICAgICogYXMgdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBpbmRleCArIGZyb21JbmRleCkgOiBuYXRpdmVNaW4oZnJvbUluZGV4LCBpbmRleCAtIDEpKSArIDE7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHByb3ZpZGVkIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBhcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV0gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcbiAgICAgKiBfLnB1bGwoYXJyYXksIDIsIDMpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsKGFycmF5KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGBlbmRgLiBJZiBgc3RhcnRgIGlzIGxlc3MgdGhhbiBgc3RvcGAgYVxuICAgICAqIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IHJhbmdlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBzdGVwID0gdHlwZW9mIHN0ZXAgPT0gJ251bWJlcicgPyBzdGVwIDogKCtzdGVwIHx8IDEpO1xuXG4gICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHVzZSBgQXJyYXkobGVuZ3RoKWAgc28gZW5naW5lcyBsaWtlIENoYWtyYSBhbmQgVjggYXZvaWQgc2xvd2VyIG1vZGVzXG4gICAgICAvLyBodHRwOi8veW91dHUuYmUvWEFxSXBHVThaWmsjdD0xN20yNXNcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heCgwLCBjZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSkpLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSB0aGF0IHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNCwgNSwgNl07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uaW5pdGlhbGAgdGhpcyBtZXRob2QgZ2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9yXG4gICAgICogZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGVsZW1lbnRzXG4gICAgICogYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZHJvcCwgdGFpbFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrPTFdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IGZhbHNlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSAoY2FsbGJhY2sgPT0gbnVsbCB8fCB0aGlzQXJnKSA/IDEgOiBuYXRpdmVNYXgoMCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoIGEgdmFsdWVcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBhIGdpdmVuIHNvcnRlZCBhcnJheSBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgc29ydFxuICAgICAqIG9yZGVyIG9mIHRoZSBhcnJheS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvclxuICAgICAqIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGVcbiAgICAgKiBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMjAsIDMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvcnRlZEluZGV4KFt7ICd4JzogMjAgfSwgeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGRpY3QgPSB7XG4gICAgICogICAnd29yZFRvTnVtYmVyJzogeyAndHdlbnR5JzogMjAsICd0aGlydHknOiAzMCwgJ2ZvdXJ0eSc6IDQwLCAnZmlmdHknOiA1MCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gZGljdC53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9LCBkaWN0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICAvLyBleHBsaWNpdGx5IHJlZmVyZW5jZSBgaWRlbnRpdHlgIGZvciBiZXR0ZXIgaW5saW5pbmcgaW4gRmlyZWZveFxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkgOiBpZGVudGl0eTtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUpO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgICAoY2FsbGJhY2soYXJyYXlbbWlkXSkgPCB2YWx1ZSlcbiAgICAgICAgICA/IGxvdyA9IG1pZCArIDFcbiAgICAgICAgICA6IGhpZ2ggPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG93O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDUsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pb24oKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgc29ydGVkLCBwcm92aWRpbmdcbiAgICAgKiBgdHJ1ZWAgZm9yIGBpc1NvcnRlZGAgd2lsbCB1c2UgYSBmYXN0ZXIgYWxnb3JpdGhtLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZSB1bmlxdWVuZXNzXG4gICAgICogaXMgY29tcHV0ZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW5pcXVlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCBgYXJyYXlgIGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDIsIDEsIDMsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMSwgMiwgMiwgM10sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy51bmlxKFsnQScsICdiJywgJ0MnLCAnYScsICdCJywgJ2MnXSwgZnVuY3Rpb24obGV0dGVyKSB7IHJldHVybiBsZXR0ZXIudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgICogLy8gPT4gWydBJywgJ2InLCAnQyddXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDIuNSwgMywgMS41LCAyLCAzLjVdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzEsIDIuNSwgM11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8udW5pcShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkICE9ICdib29sZWFuJyAmJiBpc1NvcnRlZCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSAodHlwZW9mIGlzU29ydGVkICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU29ydGVkXSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU29ydGVkO1xuICAgICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBwcm92aWRlZCB2YWx1ZXMgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzEsIDIsIDEsIDAsIDMsIDEsIDRdLCAwLCAxKTtcbiAgICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3aXRob3V0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgc3ltbWV0cmljIGRpZmZlcmVuY2Ugb2YgdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAgICAgKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSk7XG4gICAgICogLy8gPT4gWzMsIDUsIDRdXG4gICAgICpcbiAgICAgKiBfLnhvcihbMSwgMiwgNV0sIFsyLCAzLCA1XSwgWzMsIDQsIDVdKTtcbiAgICAgKiAvLyA9PiBbMSwgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4b3IoKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheSkgfHwgaXNBcmd1bWVudHMoYXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgICAgPyBiYXNlVW5pcShiYXNlRGlmZmVyZW5jZShyZXN1bHQsIGFycmF5KS5jb25jYXQoYmFzZURpZmZlcmVuY2UoYXJyYXksIHJlc3VsdCkpKVxuICAgICAgICAgICAgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW56aXBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBBcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcCgpIHtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzIDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBtYXgocGx1Y2soYXJyYXksICdsZW5ndGgnKSkgOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzIG9mIGBrZXlzYCBhbmQgYHZhbHVlc2AuIFByb3ZpZGVcbiAgICAgKiBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LCBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWBcbiAgICAgKiBvciB0d28gYXJyYXlzLCBvbmUgb2YgYGtleXNgIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBvYmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgb2Yga2V5cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBnaXZlbiBrZXlzIGFuZFxuICAgICAqICBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChrZXlzLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMgPyBrZXlzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGlmICghdmFsdWVzICYmIGxlbmd0aCAmJiAhaXNBcnJheShrZXlzWzBdKSkge1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGBmdW5jYCwgd2l0aCAgdGhlIGB0aGlzYCBiaW5kaW5nIGFuZFxuICAgICAqIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgb25seSBhZnRlciBiZWluZyBjYWxsZWQgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGJlZm9yZVxuICAgICAqICBgZnVuY2AgaXMgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdEb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ0RvbmUgc2F2aW5nIScsIGFmdGVyIGFsbCBzYXZlcyBoYXZlIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZnVuYyA9IF8uYmluZChmdW5jLCB7ICduYW1lJzogJ2ZyZWQnIH0sICdoaScpO1xuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMlxuICAgICAgICA/IGNyZWF0ZVdyYXBwZXIoZnVuYywgMTcsIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIHRoaXNBcmcpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihmdW5jLCAxLCBudWxsLCBudWxsLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLiBNZXRob2QgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBtZXRob2QgbmFtZXMuIElmIG5vIG1ldGhvZCBuYW1lcyBhcmUgcHJvdmlkZWQgYWxsIHRoZSBmdW5jdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAgd2lsbCBiZSBib3VuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBbbWV0aG9kTmFtZV0gVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG9cbiAgICAgKiAgYmluZCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgbWV0aG9kIG5hbWVzIG9yIGFycmF5cyBvZiBtZXRob2QgbmFtZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnb25DbGljayc6IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7IH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcpO1xuICAgICAqIGpRdWVyeSgnI2RvY3MnKS5vbignY2xpY2snLCB2aWV3Lm9uQ2xpY2spO1xuICAgICAqIC8vID0+IGxvZ3MgJ2NsaWNrZWQgZG9jcycsIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEFsbChvYmplY3QpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSkgOiBmdW5jdGlvbnMob2JqZWN0KSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBjcmVhdGVXcmFwcGVyKG9iamVjdFtrZXldLCAxLCBudWxsLCBudWxsLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gXG4gICAgICogYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kS2V5YCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGJvdW5kXG4gICAgICogZnVuY3Rpb24uIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG9cbiAgICAgKiByZWZlcmVuY2UgbWV0aG9kcyB0aGF0IHdpbGwgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICAgKiBTZWUgaHR0cDovL21pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICduYW1lJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMubmFtZSArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRLZXkob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMlxuICAgICAgICA/IGNyZWF0ZVdyYXBwZXIoa2V5LCAxOSwgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgb2JqZWN0KVxuICAgICAgICA6IGNyZWF0ZVdyYXBwZXIoa2V5LCAzLCBudWxsLCBudWxsLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zLFxuICAgICAqIHdoZXJlIGVhY2ggZnVuY3Rpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICAgICAqIEZvciBleGFtcGxlLCBjb21wb3NpbmcgdGhlIGZ1bmN0aW9ucyBgZigpYCwgYGcoKWAsIGFuZCBgaCgpYCBwcm9kdWNlcyBgZihnKGgoKSkpYC5cbiAgICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBbZnVuY10gRnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFsTmFtZU1hcCA9IHtcbiAgICAgKiAgICdwZWJibGVzJzogJ3BlbmVsb3BlJ1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZm9ybWF0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAqICAgbmFtZSA9IHJlYWxOYW1lTWFwW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgbmFtZTtcbiAgICAgKiAgIHJldHVybiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihmb3JtYXR0ZWQpIHtcbiAgICAgKiAgIHJldHVybiAnSGl5YSAnICsgZm9ybWF0dGVkICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgd2VsY29tZSA9IF8uY29tcG9zZShncmVldCwgZm9ybWF0KTtcbiAgICAgKiB3ZWxjb21lKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0hpeWEgUGVuZWxvcGUhJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmNzW2xlbmd0aF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzID0gW2Z1bmNzW2xlbmd0aF0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBvbmUgb3IgbW9yZSBhcmd1bWVudHMgb2YgYGZ1bmNgIHRoYXQgd2hlblxuICAgICAqIGludm9rZWQgZWl0aGVyIGV4ZWN1dGVzIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYWxsIGBmdW5jYCBhcmd1bWVudHNcbiAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG4gICAgICogcmVtYWluaW5nIGBmdW5jYCBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBjYW4gYmUgc3BlY2lmaWVkXG4gICAgICogaWYgYGZ1bmMubGVuZ3RoYCBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhhICsgYiArIGMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5KSB7XG4gICAgICBhcml0eSA9IHR5cGVvZiBhcml0eSA9PSAnbnVtYmVyJyA/IGFyaXR5IDogKCthcml0eSB8fCBmdW5jLmxlbmd0aCk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCA0LCBudWxsLCBudWxsLCBudWxsLCBhcml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIG9mIGBmdW5jYCB1bnRpbCBhZnRlclxuICAgICAqIGB3YWl0YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGludm9rZWQuXG4gICAgICogUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvblxuICAgICAqIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxsc1xuICAgICAqIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBjYWxsZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAgICAgKiB2YXIgbGF6eUxheW91dCA9IF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBsYXp5TGF5b3V0KTtcbiAgICAgKlxuICAgICAqIC8vIGV4ZWN1dGUgYHNlbmRNYWlsYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICogalF1ZXJ5KCcjcG9zdGJveCcpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGVuc3VyZSBgYmF0Y2hMb2dgIGlzIGV4ZWN1dGVkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzXG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7XG4gICAgICogICAnbWF4V2FpdCc6IDEwMDBcbiAgICAgKiB9LCBmYWxzZSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgbWF4VGltZW91dElkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB3YWl0ID0gbmF0aXZlTWF4KDAsIHdhaXQpIHx8IDA7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAobmF0aXZlTWF4KHdhaXQsIG9wdGlvbnMubWF4V2FpdCkgfHwgMCk7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGRlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNDYWxsZWQgPSB0cmFpbGluZ0NhbGw7XG4gICAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBtYXhEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN0YW1wID0gbm93KCk7XG4gICAgICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgICAgICBpZiAobWF4V2FpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtYXhUaW1lb3V0SWQgJiYgIWxlYWRpbmcpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IG1heFdhaXQgLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKSxcbiAgICAgICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMDtcblxuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmIHRpbWVvdXRJZCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgZXhlY3V0aW5nIHRoZSBgZnVuY2AgZnVuY3Rpb24gdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC5cbiAgICAgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHsgY29uc29sZS5sb2codGV4dCk7IH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZlcihmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZnVuY2AgZnVuY3Rpb24gYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgZXhlY3V0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7IGNvbnNvbGUubG9nKHRleHQpOyB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBsb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbGF5KGZ1bmMsIHdhaXQpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdFxuICAgICAqIGJhc2VkIG9uIHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGVcbiAgICAgKiBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgY2FjaGUga2V5LlxuICAgICAqIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIFRoZSByZXN1bHQgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gQSBmdW5jdGlvbiB1c2VkIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmaWJvbmFjY2kgPSBfLm1lbW9pemUoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAyID8gbiA6IGZpYm9uYWNjaShuIC0gMSkgKyBmaWJvbmFjY2kobiAtIDIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmlib25hY2NpKDkpXG4gICAgICogLy8gPT4gMzRcbiAgICAgKlxuICAgICAqIHZhciBkYXRhID0ge1xuICAgICAqICAgJ2ZyZWQnOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyBtb2RpZnlpbmcgdGhlIHJlc3VsdCBjYWNoZVxuICAgICAqIHZhciBnZXQgPSBfLm1lbW9pemUoZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gZGF0YVtuYW1lXTsgfSwgXy5pZGVudGl0eSk7XG4gICAgICogZ2V0KCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqXG4gICAgICogZ2V0LmNhY2hlLnBlYmJsZXMubmFtZSA9ICdwZW5lbG9wZSc7XG4gICAgICogZ2V0KCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdwZW5lbG9wZScsICdhZ2UnOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBtZW1vaXplZC5jYWNoZSxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleVByZWZpeCArIGFyZ3VtZW50c1swXTtcblxuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwga2V5KVxuICAgICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICAgIDogKGNhY2hlW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSB7fTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGV4ZWN1dGUgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxscyB0b1xuICAgICAqIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNhbGwuIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyBgaW5pdGlhbGl6ZWAgZXhlY3V0ZXMgYGNyZWF0ZUFwcGxpY2F0aW9uYCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICB2YXIgcmFuLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyYW4pIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgYGZ1bmNgIHZhcmlhYmxlIHNvIHRoZSBmdW5jdGlvbiBtYXkgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCBhbnkgYWRkaXRpb25hbFxuICAgICAqIGBwYXJ0aWFsYCBhcmd1bWVudHMgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uIFRoaXNcbiAgICAgKiBtZXRob2QgaXMgc2ltaWxhciB0byBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkgeyByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lOyB9O1xuICAgICAqIHZhciBoaSA9IF8ucGFydGlhbChncmVldCwgJ2hpJyk7XG4gICAgICogaGkoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDE2LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IGBwYXJ0aWFsYCBhcmd1bWVudHMgYXJlXG4gICAgICogYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHNEZWVwID0gXy5wYXJ0aWFsUmlnaHQoXy5tZXJnZSwgXy5kZWZhdWx0cyk7XG4gICAgICpcbiAgICAgKiB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICd2YXJpYWJsZSc6ICdkYXRhJyxcbiAgICAgKiAgICdpbXBvcnRzJzogeyAnanEnOiAkIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZGVmYXVsdHNEZWVwKG9wdGlvbnMsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG4gICAgICpcbiAgICAgKiBvcHRpb25zLnZhcmlhYmxlXG4gICAgICogLy8gPT4gJ2RhdGEnXG4gICAgICpcbiAgICAgKiBvcHRpb25zLmltcG9ydHNcbiAgICAgKiAvLyA9PiB7ICdfJzogXywgJ2pxJzogJCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbFJpZ2h0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDMyLCBudWxsLCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBleGVjdXRlZCwgd2lsbCBvbmx5IGNhbGwgdGhlIGBmdW5jYCBmdW5jdGlvblxuICAgICAqIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0b1xuICAgICAqIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlXG4gICAgICogb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbFxuICAgICAqIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGV4ZWN1dGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmdcbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIGV4ZWN1dGUgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlc1xuICAgICAqIGpRdWVyeSgnLmludGVyYWN0aXZlJykub24oJ2NsaWNrJywgXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHtcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZU9wdGlvbnMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICBkZWJvdW5jZU9wdGlvbnMubWF4V2FpdCA9IHdhaXQ7XG4gICAgICBkZWJvdW5jZU9wdGlvbnMudHJhaWxpbmcgPSB0cmFpbGluZztcblxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGRlYm91bmNlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLiBUaGUgd3JhcHBlciBpcyBleGVjdXRlZCB3aXRoXG4gICAgICogdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPkZyZWQsIFdpbG1hLCAmYW1wOyBQZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcih3cmFwcGVyLCAxNiwgW3ZhbHVlXSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICAgICAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBjYWxsYmFjayBib3VuZCB0byBhbiBvcHRpb25hbCBgdGhpc0FyZ2AuIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5XG4gICAgICogbmFtZSB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBJZiBgZnVuY2AgaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHNcbiAgICAgKiB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnQgb2JqZWN0IHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBjYWxsYmFjayBhY2NlcHRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogXy5jcmVhdGVDYWxsYmFjayA9IF8ud3JhcChfLmNyZWF0ZUNhbGxiYWNrLCBmdW5jdGlvbihmdW5jLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGNhbGxiYWNrKTtcbiAgICAgKiAgIHJldHVybiAhbWF0Y2ggPyBmdW5jKGNhbGxiYWNrLCB0aGlzQXJnKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0JyA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXSA6IG9iamVjdFttYXRjaFsxXV0gPCBtYXRjaFszXTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYWdlX19ndDM4Jyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICAgICAgaWYgKGZ1bmMgPT0gbnVsbCB8fCB0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgXCJfLnBsdWNrXCIgc3R5bGUgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAgaWYgKHR5cGUgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5KGZ1bmMpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0ga2V5cyhmdW5jKSxcbiAgICAgICAgICBrZXkgPSBwcm9wc1swXSxcbiAgICAgICAgICBhID0gZnVuY1trZXldO1xuXG4gICAgICAvLyBoYW5kbGUgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PSAxICYmIGEgPT09IGEgJiYgIWlzT2JqZWN0KGEpKSB7XG4gICAgICAgIC8vIGZhc3QgcGF0aCB0aGUgY29tbW9uIGNhc2Ugb2YgcHJvdmlkaW5nIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlXG4gICAgICAgIC8vIHByb3BlcnR5IGNvbnRhaW5pbmcgYSBwcmltaXRpdmUgdmFsdWVcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHZhciBiID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgcmV0dXJuIGEgPT09IGIgJiYgKGEgIT09IDAgfHwgKDEgLyBhID09IDEgLyBiKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBiYXNlSXNFcXVhbChvYmplY3RbcHJvcHNbbGVuZ3RoXV0sIGZ1bmNbcHJvcHNbbGVuZ3RoXV0sIG51bGwsIHRydWUpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIGAmYCwgYDxgLCBgPmAsIGBcImAsIGFuZCBgJ2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24gbWV0aG9kcyB3aWxsIGJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWQgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0pO1xuICAgICAqIF8uY2FwaXRhbGl6ZSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGFpbiA9IHRydWUsXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBzb3VyY2UgJiYgZnVuY3Rpb25zKHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlIHx8ICghb3B0aW9ucyAmJiAhbWV0aG9kTmFtZXMubGVuZ3RoKSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBjdG9yID0gbG9kYXNoV3JhcHBlcjtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSBsb2Rhc2g7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gZnVuY3Rpb25zKHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY2hhaW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNoYWluID0gb3B0aW9ucy5jaGFpbjtcbiAgICAgIH1cbiAgICAgIHZhciBjdG9yID0gb2JqZWN0LFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24oY3Rvcik7XG5cbiAgICAgIGZvckVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBvYmplY3RbbWV0aG9kTmFtZV0gPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdmFsdWVdO1xuXG4gICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcmVzdWx0ICYmIGlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgY3RvcihyZXN1bHQpO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlICdfJyB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBjb250ZXh0Ll8gPSBvbGREYXNoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogXy5ub29wKG9iamVjdCkgPT09IHVuZGVmaW5lZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIG5vIG9wZXJhdGlvbiBwZXJmb3JtZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzdGFtcCA9IF8ubm93KCk7XG4gICAgICogXy5kZWZlcihmdW5jdGlvbigpIHsgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTsgfSk7XG4gICAgICogLy8gPT4gbG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGlzTmF0aXZlKG5vdyA9IERhdGUubm93KSAmJiBub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICAgKiBJZiBgcmFkaXhgIGlzIGB1bmRlZmluZWRgIG9yIGAwYCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyB0aGVcbiAgICAgKiBgdmFsdWVgIGlzIGEgaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGF2b2lkcyBkaWZmZXJlbmNlcyBpbiBuYXRpdmUgRVMzIGFuZCBFUzUgYHBhcnNlSW50YFxuICAgICAqIGltcGxlbWVudGF0aW9ucy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyNFLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBuZXcgaW50ZWdlciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICovXG4gICAgdmFyIHBhcnNlSW50ID0gbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZSArICcwOCcpID09IDggPyBuYXRpdmVQYXJzZUludCA6IGZ1bmN0aW9uKHZhbHVlLCByYWRpeCkge1xuICAgICAgLy8gRmlyZWZveCA8IDIxIGFuZCBPcGVyYSA8IDE1IGZvbGxvdyB0aGUgRVMzIHNwZWNpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBgcGFyc2VJbnRgXG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZShyZUxlYWRpbmdTcGFjZXNBbmRaZXJvcywgJycpIDogdmFsdWUsIHJhZGl4IHx8IDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgXCJfLnBsdWNrXCIgc3R5bGUgZnVuY3Rpb24sIHdoaWNoIHJldHVybnMgdGhlIGBrZXlgIHZhbHVlIG9mIGFcbiAgICAgKiBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGdldE5hbWUgPSBfLnByb3BlcnR5KCduYW1lJyk7XG4gICAgICpcbiAgICAgKiBfLm1hcChjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KGtleSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCAoaW5jbHVzaXZlKS4gSWYgb25seSBvbmVcbiAgICAgKiBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlciB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgdHJ1ZXkgb3IgZWl0aGVyIGBtaW5gIG9yIGBtYXhgIGFyZSBmbG9hdHMgYVxuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlciB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZz1mYWxzZV0gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCBmbG9hdGluZykge1xuICAgICAgdmFyIG5vTWluID0gbWluID09IG51bGwsXG4gICAgICAgICAgbm9NYXggPSBtYXggPT0gbnVsbDtcblxuICAgICAgaWYgKGZsb2F0aW5nID09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gPT0gJ2Jvb2xlYW4nICYmIG5vTWF4KSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtaW47XG4gICAgICAgICAgbWluID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbm9NYXggJiYgdHlwZW9mIG1heCA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1heDtcbiAgICAgICAgICBub01heCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub01pbiAmJiBub01heCkge1xuICAgICAgICBtYXggPSAxO1xuICAgICAgfVxuICAgICAgbWluID0gK21pbiB8fCAwO1xuICAgICAgaWYgKG5vTWF4KSB7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9ICttYXggfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBtaW4gJSAxIHx8IG1heCAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihtaW4gKyAocmFuZCAqIChtYXggLSBtaW4gKyBwYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsnJykubGVuZ3RoIC0gMSkpKSksIG1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHZhbHVlIG9mIHByb3BlcnR5IGBrZXlgIG9uIGBvYmplY3RgLiBJZiBga2V5YCBpcyBhIGZ1bmN0aW9uXG4gICAgICogaXQgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBvYmplY3RgIGFuZCBpdHMgcmVzdWx0IHJldHVybmVkLFxuICAgICAqIGVsc2UgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJldHVybmVkLiBJZiBgb2JqZWN0YCBpcyBmYWxzZXkgdGhlbiBgdW5kZWZpbmVkYFxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2NoZWVzZSc6ICdjcnVtcGV0cycsXG4gICAgICogICAnc3R1ZmYnOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuICdub25zZW5zZSc7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2NoZWVzZScpO1xuICAgICAqIC8vID0+ICdjcnVtcGV0cydcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ3N0dWZmJyk7XG4gICAgICogLy8gPT4gJ25vbnNlbnNlJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gb2JqZWN0W2tleV0oKSA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbWljcm8tdGVtcGxhdGluZyBtZXRob2QgdGhhdCBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXNcbiAgICAgKiB3aGl0ZXNwYWNlLCBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCwgYF8udGVtcGxhdGVgIHV0aWxpemVzIHNvdXJjZVVSTHMgZm9yIGVhc2llclxuICAgICAqIGRlYnVnZ2luZy4gU2VlIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlOlxuICAgICAqIGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWU6XG4gICAgICogaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3N0YWJsZS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsLmh0bWxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBsb2NhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufHN0cmluZ30gUmV0dXJucyBhIGNvbXBpbGVkIGZ1bmN0aW9uIHdoZW4gbm8gYGRhdGFgIG9iamVjdFxuICAgICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIEhUTUwgaW4gZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyAkeyBuYW1lIH0nLCB7ICduYW1lJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgbmFtZSk7ICU+IScsIHsgJ25hbWUnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgICogICAnaW50ZXJwb2xhdGUnOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvIHt7IG5hbWUgfX0hJywgeyAnbmFtZSc6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBqUXVlcnlcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBqcS5lYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+JywgbnVsbCwgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IGZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3JcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLm5hbWUgJT4hJywgbnVsbCwgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgIHZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZTtcbiAgICAgKiAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLm5hbWUgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAgIHJldHVybiBfX3A7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgLy8gYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy9cbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0IHx8ICcnKTtcblxuICAgICAgLy8gYXZvaWQgbWlzc2luZyBkZXBlbmRlbmNpZXMgd2hlbiBgaXRlcmF0b3JUZW1wbGF0ZWAgaXMgbm90IGRlZmluZWRcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0dGluZ3MpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gdmFsdWVzKGltcG9ydHMpO1xuXG4gICAgICB2YXIgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gY29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICB0ZXh0LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyByZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0c1xuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gaWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkLCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpblxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZSxcbiAgICAgICAgICBoYXNWYXJpYWJsZSA9IHZhcmlhYmxlO1xuXG4gICAgICBpZiAoIWhhc1ZhcmlhYmxlKSB7XG4gICAgICAgIHZhcmlhYmxlID0gJ29iaic7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoICgnICsgdmFyaWFibGUgKyAnKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5nc1xuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBmcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArIHZhcmlhYmxlICsgJykge1xcbicgK1xuICAgICAgICAoaGFzVmFyaWFibGUgPyAnJyA6IHZhcmlhYmxlICsgJyB8fCAoJyArIHZhcmlhYmxlICsgJyA9IHt9KTtcXG4nKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlXCIgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICdcXG4vKlxcbi8vIyBzb3VyY2VVUkw9JyArIChvcHRpb25zLnNvdXJjZVVSTCB8fCAnL2xvZGFzaC90ZW1wbGF0ZS9zb3VyY2VbJyArICh0ZW1wbGF0ZUNvdW50ZXIrKykgKyAnXScpICsgJ1xcbiovJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uKGltcG9ydHNLZXlzLCAncmV0dXJuICcgKyBzb3VyY2UgKyBzb3VyY2VVUkwpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGRhdGEpO1xuICAgICAgfVxuICAgICAgLy8gcHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kLCBpblxuICAgICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyBtYWdlLmNhc3RTcGVsbChuKTsgfSk7XG4gICAgICogLy8gPT4gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcywgcGFzc2luZyBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgdGhpcy5jYXN0KG4pOyB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgbiA9IChuID0gK24pID4gLTEgPyBuIDogMDtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYCB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ0ZyZWQsIEJhcm5leSAmYW1wOyBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIEJhcm5leSAmIFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgd2lsbCBiZSBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBTdHJpbmcocHJlZml4ID09IG51bGwgPyAnJyA6IHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCBleHBsaWNpdFxuICAgICAqIG1ldGhvZCBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKGNoYXJhY3RlcnMpXG4gICAgICogICAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIubmFtZSArICcgaXMgJyArIGNoci5hZ2U7IH0pXG4gICAgICogICAgIC5maXJzdCgpXG4gICAgICogICAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBpbnRlcmNlcHRvcmAgd2l0aCB0aGUgYHZhbHVlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIGB2YWx1ZWAuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZFxuICAgICAqIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW5cbiAgICAgKiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzLCA0XSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkgeyBhcnJheS5wb3AoKTsgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygnYWdlJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nIHJlc3VsdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZU9mXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5kcm9wID0gcmVzdDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gemlwO1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgICBtaXhpbihsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIG1peGluKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9XG4gICAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCksIGZhbHNlKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLnRha2UgPSBmaXJzdDtcbiAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuXG4gICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNhbGxiYWNrYWJsZSA9IG1ldGhvZE5hbWUgIT09ICdzYW1wbGUnO1xuICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV09IGZ1bmN0aW9uKG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmModGhpcy5fX3dyYXBwZWRfXywgbiwgZ3VhcmQpO1xuXG4gICAgICAgICAgcmV0dXJuICFjaGFpbkFsbCAmJiAobiA9PSBudWxsIHx8IChndWFyZCAmJiAhKGNhbGxiYWNrYWJsZSAmJiB0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSkpXG4gICAgICAgICAgICA/IHJlc3VsdFxuICAgICAgICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSAnMi40LjInO1xuXG4gICAgLy8gYWRkIFwiQ2hhaW5pbmdcIiBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZU9mO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IHdyYXBwZXJWYWx1ZU9mO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnam9pbicsICdwb3AnLCAnc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYWluQWxsXG4gICAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgZXhpc3Rpbmcgd3JhcHBlZCB2YWx1ZVxuICAgIGZvckVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyksIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIExvLURhc2hcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCBpcyBsb2FkZWQgd2l0aCBhIFJlcXVpcmVKUyBzaGltIGNvbmZpZy5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbCNjb25maWctc2hpbVxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIGluIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmVcbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLypcblx0Y29zdHM6IHtcblx0XHRkZWxldGU6IG51bWJlciB8IGZ1bmN0aW9uICggY2hhciApXG5cdFx0aW5zZXJ0OiBudW1iZXIgfCBmdW5jdGlvbiAoIGNoYXIgKVxuXHRcdHJlcGxhY2U6IG51bWJlciB8IGZ1bmN0aW9uICggd2hhdCwgYnkgKVxuXHRcdHRyYW5zcG9zZTogbnVtYmVyIHwgZnVuY3Rpb24gKCBsZWZ0LCByaWdodCApXG5cdH1cbiovXG5cbmZ1bmN0aW9uIGdldENvc3QoIGNvc3RzLCBvcCwgYSwgYiApIHtcblx0bGV0IGNvc3QgPSB0eXBlb2YgY29zdHMgPT0gYG9iamVjdGAgPyBjb3N0c1sgb3AgXSA6IGNvc3RzXG5cdHJldHVybiB0eXBlb2YgY29zdCA9PSBgZnVuY3Rpb25gID8gY29zdC5jYWxsKCBjb3N0cywgYSwgYiApIDogY29zdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggczEsIHMyLCBjb3N0cyA9IDEgKSA9PiB7XG5cdGxldCBkID0gW11cblx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHMxLmxlbmd0aDsgKytpICkge1xuXHRcdGRbIGkgXSA9IGkgPCAzID8gW10gOiBkWyBpIC0gMyBdIC8vIHNvbWUgb3B0aW1pemF0aW9uXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHMyLmxlbmd0aDsgKytqIClcblx0XHRcdGRbIGkgXVsgaiBdID1cblx0XHRcdFx0aSA9PSAwICYmIGogPT0gMCA/XG5cdFx0XHRcdFx0MFxuXHRcdFx0XHQ6IGkgPT0gMCA/XG5cdFx0XHRcdFx0ZFsgaSBdWyBqIC0gMSBdICsgZ2V0Q29zdCggY29zdHMsIGBpbnNlcnRgLCBzMlsgaiAtIDEgXSApXG5cdFx0XHRcdDogaiA9PSAwID9cblx0XHRcdFx0XHRkWyBpIC0gMSBdWyBqIF0gKyBnZXRDb3N0KCBjb3N0cywgYGRlbGV0ZWAsIHMxWyBpIC0gMSBdIClcblx0XHRcdFx0OiBNYXRoLm1pbihcblx0XHRcdFx0XHRkWyBpIC0gMSBdWyBqIF0gKyBnZXRDb3N0KCBjb3N0cywgYGRlbGV0ZWAsIHMxWyBpIC0gMSBdICksXG5cdFx0XHRcdFx0ZFsgaSBdWyBqIC0gMSBdICsgZ2V0Q29zdCggY29zdHMsIGBpbnNlcnRgLCBzMlsgaiAtIDEgXSApLFxuXHRcdFx0XHRcdGRbIGkgLSAxIF1bIGogLSAxIF0gKyAoIHMxWyBpIC0gMSBdID09IHMyWyBqIC0gMSBdID8gMCA6IGdldENvc3QoIGNvc3RzLCBgcmVwbGFjZWAsIHMxWyBpIC0gMSBdLCBzMlsgaiAtIDEgXSApICksXG5cdFx0XHRcdFx0KCBpID4gMSAmJiBqID4gMSAmJiBzMVsgaSAtIDEgXSA9PSBzMlsgaiAtIDIgXSAmJiBzMVsgaSAtIDIgXSA9PSBzMlsgaiAtIDEgXSApXG5cdFx0XHRcdFx0XHQ/IGRbIGkgLSAyIF1bIGogLSAyIF0gKyBnZXRDb3N0KCBjb3N0cywgYHRyYW5zcG9zZWAsIHMxWyBpIC0gMiBdLCBzMVsgaSAtIDEgXSApIDogSW5maW5pdHlcblx0XHRcdFx0KVxuXHR9XG5cdHJldHVybiBkWyBzMS5sZW5ndGggXVsgczIubGVuZ3RoIF1cbn1cbiIsImxldCByYSA9IHJlcXVpcmUoIGByYWAgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgga2V5LCBkZWZhdWx0cyA9IG51bGwgKSB7XG5cdGxldCByZXQgPSByYS5jbGVhbiggZGVmYXVsdHMgKVxuXHQuc2V0Q29uc3QoIFwicmVzZXRcIiwgKCkgPT4ge1xuXHRcdFx0bG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oIGtleSApXG5cdFx0XHRyZXQuYXNzaWduKCBkZWZhdWx0cyApXG5cdFx0XHQvLyByZXQubG9hZGVkID0gdHJ1ZVxuXHRcdH1cblx0KVxuXHQuc2V0TmFtZSggXCJsb2NhbFN0b3JhZ2UuXCIgKyBrZXkgKVxuXHRsZXQgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oIGtleSApXG5cdGlmICggc3RvcmVkICE9IG51bGwgKVxuXHRcdHJldC5hc3NpZ24oIEpTT04ucGFyc2UoIHN0b3JlZCApIClcblx0cmEuY2xlYW4oICgpID0+IHtcblx0XHRpZiAoIHJldC52YWx1ZU9mKCkgIT0gZGVmYXVsdHMgKVxuXHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oIGtleSwgSlNPTi5zdHJpbmdpZnkoIHJldCApIClcblx0fSApXG5cdHJldHVybiByZXRcbn1cbiIsInJlcXVpcmUoIGBjb2xvcnNgIClcblxubGV0IExPRyA9ICggbXNnLCAuLi5kYXRhICkgPT4gY29uc29sZS5sb2coIGAkeyAoIG5ldyBEYXRlICkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCBgVGAsIGA9YCApLnJlcGxhY2UoIGBaYCwgYGAgKSB9ICR7IG1zZyB9YCwgLi4uZGF0YSApXG5MT0cuTE9HID0gTE9HXG5MT0cuSU5GTyA9IExPR1xuTE9HLlRSQUNFID0gTE9HXG5MT0cuRVJST1IgPSBMT0dcbkxPRy5XQVJOSU5HID0gTE9HXG5cbm1vZHVsZS5leHBvcnRzID0gTE9HXG4iLCJsZXQgbG9kYXNoID0gcmVxdWlyZSggYGxvZGFzaGAgKVxuXG5jbGFzcyBQb25nSlNPTiBleHRlbmRzIHJlcXVpcmUoIGBXZWJRdWV1ZWAgKSB7XG5cdGNvbnN0cnVjdG9yKCBxICkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLl9xID0gcVxuXHRcdHRoaXMucGlwZUZyb20oIHEgKVxuXHRcdHEub25tZXNzYWdlID0gbWVzc2FnZSA9PiB0aGlzLl9tZXNzYWdlKCBtZXNzYWdlIClcblx0fVxuXHR1bndpc2UoKSB7XG5cdFx0bGV0IHEgPSB0aGlzLl9xXG5cdFx0dGhpcy5fcSA9IG51bGxcblx0XHRxLm9ub3BlbiA9IG51bGxcblx0XHRxLm9uY2xvc2UgPSBudWxsXG5cdFx0cS5vbmVycm9yID0gbnVsbFxuXHRcdHEub25tZXNzYWdlID0gbnVsbFxuXHRcdHJldHVybiBxLnVud2lzZSA/IHEudW53aXNlKCkgOiBxXG5cdH1cblx0X21lc3NhZ2UoIG1lc3NhZ2UgKSB7XG5cdFx0aWYgKCBtZXNzYWdlLndoYXQgPT0gYHBpbmdgIClcblx0XHRcdHRoaXMuX3Euc2VuZCggeyB3aGF0OiBgcG9uZ2AsIHBvbmc6IG1lc3NhZ2UucGluZyB9IClcblx0XHRlbHNlXG5cdFx0XHR0aGlzLmRvbWVzc2FnZSggbWVzc2FnZSApXG5cdH1cblx0X3NlbmQoIG1lc3NhZ2UgKSB7XG5cdFx0dGhpcy5fcS5zZW5kKCBtZXNzYWdlIClcblx0fVxuXHRfY2xvc2UoKSB7XG5cdFx0dGhpcy5fcS5vbmNsb3NlID0gbnVsbFxuXHRcdHRoaXMuX3EuY2xvc2UoKVxuXHR9XG59XG5cbmNsYXNzIFBpbmdQb25nSlNPTiBleHRlbmRzIFBvbmdKU09OIHtcblx0Y29uc3RydWN0b3IoIHEsIHsgaW50ZXJ2YWwgPSA2MDAwMCwgdGltZW91dCA9IDE1MDAwLCBtYXhwaW5ncyA9IDEwMDAgfSA9IHt9ICkge1xuXHRcdHN1cGVyKCBxIClcblx0XHR0aGlzLl9waW5ncyA9IHt9XG5cdFx0dGhpcy5fY291bnQgPSAwXG5cdFx0dGhpcy5fcGludGVydmFsID0gaW50ZXJ2YWwgPT0gSW5maW5pdHkgPyBudWxsIDogc2V0SW50ZXJ2YWwoICgpID0+IHRoaXMucGluZygpLCBpbnRlcnZhbCApXG5cdFx0dGhpcy5fdGltZW91dCA9IHRpbWVvdXRcblx0XHR0aGlzLl9tYXhwaW5ncyA9IG1heHBpbmdzXG5cdH1cblx0X21lc3NhZ2UoIG1lc3NhZ2UgKSB7XG5cdFx0aWYgKCBtZXNzYWdlLndoYXQgPT0gYHBvbmdgICkge1xuXHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHRoaXMuX3BpbmdzLCBtZXNzYWdlLnBvbmcgKSApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLl9waW5nc1sgbWVzc2FnZS5wb25nIF0gKVxuXHRcdFx0XHRkZWxldGUgdGhpcy5fcGluZ3NbIG1lc3NhZ2UucG9uZyBdXG5cdFx0XHRcdC0tdGhpcy5fY291bnRcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0c3VwZXIuX21lc3NhZ2UoIG1lc3NhZ2UgKVxuXHR9XG5cdF9zZW5kKCBtZXNzYWdlICkge1xuXHRcdHN1cGVyLl9zZW5kKCBtZXNzYWdlIClcblx0XHR0aGlzLnBpbmcoKVxuXHR9XG5cdF9jbG9zZSgpIHtcblx0XHRjbGVhckludGVydmFsKCB0aGlzLl9waW50ZXJ2YWwgKVxuXHRcdHRoaXMuX3BpbnRlcnZhbCA9IG51bGxcblx0XHRsb2Rhc2guZm9yRWFjaCggdGhpcy5fcGluZ3MsIHQgPT4gY2xlYXJUaW1lb3V0KCB0ICkgKVxuXHRcdHRoaXMuX3BpbmdzID0gbnVsbFxuXHRcdHN1cGVyLl9jbG9zZSgpXG5cdH1cblx0cGluZygpIHtcblx0XHRpZiAoICF0aGlzLl9xIClcblx0XHRcdHJldHVyblxuXHRcdGlmICggdGhpcy5fY291bnQgPiB0aGlzLl9tYXhwaW5ncyApXG5cdFx0XHRyZXR1cm4gdGhpcy5fb250aW1lb3V0KClcblx0XHRsZXQgaWQgPSBgJHsgTWF0aC5yYW5kb20oKSB9YFxuXHRcdHRoaXMuX3Euc2VuZCggeyB3aGF0OiBgcGluZ2AsIHBpbmc6IGlkIH0gKVxuXHRcdHRoaXMuX3BpbmdzWyBpZCBdID0gc2V0VGltZW91dCggKCkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coIGlkLnJlZCApXG5cdFx0XHR0aGlzLl9vbnRpbWVvdXQoKVxuXHRcdH0sIHRoaXMuX3RpbWVvdXQgKVxuXHRcdCsrdGhpcy5fY291bnRcblx0fVxuXHRfb250aW1lb3V0KCkge1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLmRvZXJyb3IoIG5ldyBFcnJvciggYHRpbWVvdXRgICkgKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuY2xvc2UoKVxuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggcSwgb3B0aW9ucyApID0+IG5ldyBQaW5nUG9uZ0pTT04oIHEsIG9wdGlvbnMgKVxubW9kdWxlLmV4cG9ydHMuc2lsZW50ID0gcSA9PiBuZXcgUG9uZ0pTT04oIHEgKVxuIiwiY2xhc3MgV2ViUXVldWUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLm9ub3BlbiA9IG51bGxcblx0XHR0aGlzLm9uY2xvc2UgPSBudWxsXG5cdFx0dGhpcy5vbm1lc3NhZ2UgPSBudWxsXG5cdFx0dGhpcy5vbmVycm9yID0gbnVsbFxuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlXG5cdFx0dGhpcy5fb3BlbmVkID0gZmFsc2Vcblx0fVxuXHRkb29wZW4oKSB7XG5cdFx0aWYgKCAhdGhpcy5fY2xvc2VkICYmIHRoaXMub25vcGVuICYmICF0aGlzLl9vcGVuZWQgKSB7XG5cdFx0XHR0aGlzLl9vcGVuZWQgPSB0cnVlXG5cdFx0XHR0aGlzLm9ub3BlbigpXG5cdFx0fVxuXHR9XG5cdGRvY2xvc2UoKSB7XG5cdFx0aWYoIHRoaXMub25jbG9zZSApXG5cdFx0XHR0aGlzLm9uY2xvc2UoKVxuXHR9XG5cdGRvbWVzc2FnZSggbWVzc2FnZSApIHtcblx0XHRpZiAoICF0aGlzLl9jbG9zZWQgJiYgdGhpcy5vbm1lc3NhZ2UgKSB7XG5cdFx0XHRpZiAoICF0aGlzLl9vcGVuZWQgKVxuXHRcdFx0XHR0aGlzLmRvb3BlbigpXG5cdFx0XHR0aGlzLm9ubWVzc2FnZSggbWVzc2FnZSApXG5cdFx0fVxuXHR9XG5cdGRvZXJyb3IoIGVycm9yICkge1xuXHRcdGlmICggdGhpcy5vbmVycm9yIClcblx0XHRcdHRoaXMub25lcnJvciggZXJyb3IgKVxuXHRcdGVsc2Vcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soICgpID0+IHsgdGhyb3cgZXJyb3IgfSApXG5cdH1cblx0X3NlbmQoKSB7fVxuXHRzZW5kKCBtZXNzYWdlICkge1xuXHRcdGlmICggIXRoaXMuX2Nsb3NlZCApXG5cdFx0XHR0aGlzLl9zZW5kKCBtZXNzYWdlIClcblx0fVxuXHRfY2xvc2UoKSB7fVxuXHRjbG9zZSgpIHtcblx0XHRpZiAoIHRoaXMuX2Nsb3NlZCApXG5cdFx0XHRyZXR1cm5cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5fY2xvc2UoKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuX2Nsb3NlZCA9IHRydWVcblx0XHRcdHRoaXMuZG9jbG9zZSgpXG5cdFx0fVxuXHR9XG5cdHBpcGVGcm9tKCBxICkge1xuXHRcdHEub25vcGVuID0gKCkgPT4gdGhpcy5kb29wZW4oKVxuXHRcdHEub25jbG9zZSA9ICgpID0+IHRoaXMuY2xvc2UoKVxuXHRcdHEub25lcnJvciA9IGVycm9yID0+IHRoaXMuZG9lcnJvciggZXJyb3IgKVxuXHRcdHEub25tZXNzYWdlID0gbWVzc2FnZSA9PiB0aGlzLmRvbWVzc2FnZSggbWVzc2FnZSApXG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJRdWV1ZVxuIiwiY2xhc3MgV2ViU29ja2V0VG9KU09OIGV4dGVuZHMgcmVxdWlyZSggYFdlYlF1ZXVlYCApIHtcblx0Y29uc3RydWN0b3IoIHdzICkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLl93cyA9IHdzXG5cdFx0dGhpcy5waXBlRnJvbSggd3MgKVxuXHRcdHdzLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcblx0XHRcdGxldCBtZXNzYWdlXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRtZXNzYWdlID0gSlNPTi5wYXJzZSggU3RyaW5nKCBldmVudC5kYXRhICkgKVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9lcnJvciggZXJyb3IgKVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5kb21lc3NhZ2UoIG1lc3NhZ2UgKVxuXHRcdH1cblx0fVxuXHR1bndpc2UoKSB7XG5cdFx0bGV0IHdzID0gdGhpcy5fd3Ncblx0XHR0aGlzLl93cyA9IG51bGxcblx0XHR3cy5vbm9wZW4gPSBudWxsXG5cdFx0d3Mub25jbG9zZSA9IG51bGxcblx0XHR3cy5vbmVycm9yID0gbnVsbFxuXHRcdHdzLm9ubWVzc2FnZSA9IG51bGxcblx0XHRyZXR1cm4gd3Ncblx0fVxuXHRfc2VuZCggbWVzc2FnZSApIHsgdGhpcy5fd3Muc2VuZCggSlNPTi5zdHJpbmdpZnkoIG1lc3NhZ2UgKSApIH1cblx0X2Nsb3NlKCkge1xuXHRcdHRoaXMuX3dzLm9uY2xvc2UgPSBudWxsXG5cdFx0dGhpcy5fd3MuY2xvc2UoKVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3MgPT4gbmV3IFdlYlNvY2tldFRvSlNPTiggd3MgKVxuIiwiLypcblxuVE9ETyAyMDE1LjAzLjI1INCjINCi0Jcg0L3QtSDQsdGL0LvQvjog0KDRjdC00LDQs9Cw0LLQsNC90YzQvdC1INC80LXRgdGG0LDRniDQvNCw0LPRh9GL0LzQsCDQv9Cw0YLRgNGN0LHQvdCw0LUg0YLQvtC70YzQutGWINC70LDQutCw0LvRjNC90LAg0Lcg0LDRgdC+0LHQvdGL0LzRliDQutCw0LzQsNC90LTQsNC80ZYg0LzQtdC90Y4gXCLQt9Cw0YXQsNCy0LDRhtGMINC00LvRjyDQt9C80L7RntGH0LDQvdCw0LPQsFwiINGWIFwi0LfQsNCz0YDRg9C30ZbRhtGMINC90LAg0Z7RgdC1INC/0YDRi9C70LDQtNGLXCIuXG5cbiovXG5sZXQgSlNPTmxvY2FsID0gcmVxdWlyZSggYEpTT05sb2NhbGAgKVxubGV0IGx1ID0gcmVxdWlyZSggYGxvY2FsVXRpbHNgIClcbmxldCByYSA9IHJlcXVpcmUoIGByYWAgKVxubGV0IGxvZGFzaCA9IHJlcXVpcmUoIGBsb2Rhc2hgIClcbmxldCBVSUQgPSByZXF1aXJlKCBgdWlkYCApXG5sZXQgaHR0cENsaWVudCA9IHJlcXVpcmUoIGBodHRwQ2xpZW50YCApXG5sZXQgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSggYGV2ZW50c2AgKS5FdmVudEVtaXR0ZXIgfHwgcmVxdWlyZSggYGV2ZW50c2AgKVxubGV0IGRldmljZUFjdGlvbnMgPSByZXF1aXJlKCBgbmV0cm8vZGV2aWNlQWN0aW9uc2AgKVxubGV0IEhUVFBTdGF0dXMgPSByZXF1aXJlKCBgaHR0cC1zdGF0dXNgIClcbmxldCBXZWJTb2NrZXRUb0pTT04gPSByZXF1aXJlKCBgV2ViU29ja2V0VG9KU09OYCApXG5sZXQgUGluZ1BvbmdKU09OID0gcmVxdWlyZSggYFBpbmdQb25nSlNPTmAgKVxubGV0IGRldmRiID0gcmVxdWlyZSggYGRldmRiYCApXG5cbmxldCBXZWJTb2NrZXRSZXRyeSA9IDEwMDBcbmxldCBzYXZlUGxhY2VzVGltZW91dCA9IDMwMDBcblxuY2xhc3MgUGVyc2lzdGVudFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cblx0Y29uc3RydWN0b3IgKCB1cmwgKSB7XG5cdFx0c3VwZXIoKVxuXHRcdHRoaXMuY29ubmVjdGVkID0gZmFsc2Vcblx0XHR0aGlzLmNsb3NlZCA9IGZhbHNlXG5cdFx0dGhpcy5fd3MgPSBudWxsXG5cdFx0dGhpcy5fc2hlZHVsZWRDcmVhdGluZyA9IG51bGxcblx0XHR0aGlzLl9maXJzdCA9IHRydWVcblx0XHR0aGlzLl9sYXN0Q2xvc2UgPSAtSW5maW5pdHlcblx0XHR0aGlzLnVybCA9IHVybFxuXHRcdHRoaXMudXNlciA9IHVuZGVmaW5lZFxuXHRcdHRoaXMua2V5ID0gdW5kZWZpbmVkXG5cdFx0Ly8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIGBfYXBwbGljYXRpb25fcmVzdW1lZGAgKVxuXHR9XG5cblx0Z2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuX3VybCB9XG5cdHNldCB1cmwoIHVybCApIHtcblx0XHR0aGlzLl91cmwgPSB1cmxcblx0XHR0aGlzLl9jcmVhdGVIYW5kbGUoKVxuXHR9XG5cblx0X3NldENvbm5lY3RlZCggdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSAhIXZhbHVlXG5cdFx0aWYgKCB0aGlzLmNvbm5lY3RlZCAhPSB2YWx1ZSApIHtcblx0XHRcdHRoaXMuY29ubmVjdGVkID0gdmFsdWVcblx0XHRcdHRoaXMuZW1pdCggYGNoYW5nZWRgLCB2YWx1ZSApXG5cdFx0fVxuXHR9XG5cblx0X2NsZWFySGFuZGxlKCkge1xuXHRcdGlmICggdGhpcy5fd3MgKSB7XG5cdFx0XHR0aGlzLl93cy5vbmNsb3NlID0gbnVsbFxuXHRcdFx0dGhpcy5fd3MuY2xvc2UoKVxuXHRcdFx0dGhpcy5fd3MgPSBudWxsXG5cdFx0XHR0aGlzLl9zZXRDb25uZWN0ZWQoIGZhbHNlIClcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9zaGVkdWxlZENyZWF0aW5nICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLl9zaGVkdWxlZENyZWF0aW5nIClcblx0XHRcdHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgPSBudWxsXG5cdFx0fVxuXHR9XG5cblx0X2Vuc3VyZUhhbmRsZSgpIHtcblx0XHRpZiAoICF0aGlzLl93cyApXG5cdFx0XHR0aGlzLl9jcmVhdGVIYW5kbGUoKVxuXHR9XG5cblx0X2NyZWF0ZUhhbmRsZSgpIHtcblx0XHR0aGlzLl9jbGVhckhhbmRsZSgpXG5cdFx0aWYgKCAhdGhpcy5fdXJsIClcblx0XHRcdHJldHVyblxuXHRcdHRoaXMuX3dzID0gUGluZ1BvbmdKU09OKCBXZWJTb2NrZXRUb0pTT04oIG5ldyBXZWJTb2NrZXQoIHRoaXMuX3VybCApICkgKVxuXHRcdHRoaXMuX3dzLm9uY2xvc2UgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl93cyA9IG51bGxcblx0XHRcdHRoaXMuX3NldENvbm5lY3RlZCggZmFsc2UgKVxuXHRcdFx0dGhpcy5lbWl0KCBgcGF1c2VgIClcblx0XHRcdGlmICggIXRoaXMuY2xvc2VkICkge1xuXHRcdFx0XHRsZXQgdCA9IHRoaXMuX2xhc3RDbG9zZVxuXHRcdFx0XHR0aGlzLl9sYXN0Q2xvc2UgPSBEYXRlLm5vdygpXG5cdFx0XHRcdHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgPSBzZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5fY3JlYXRlSGFuZGxlKClcblx0XHRcdFx0fSwgTWF0aC5tYXgoIDAsIFdlYlNvY2tldFJldHJ5IC0gKCB0aGlzLl9sYXN0Q2xvc2UgLSB0ICkgKSApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3dzLm9uZXJyb3IgPSBlcnJvciA9PiB7XG5cdFx0XHR0aGlzLmVtaXQoIGBlcnJvcmAsIGVycm9yIClcblx0XHR9XG5cdFx0dGhpcy5fd3Mub25vcGVuID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5fc2V0Q29ubmVjdGVkKCB0cnVlIClcblx0XHRcdGlmICggdGhpcy5fZmlyc3QgKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0ID0gZmFsc2Vcblx0XHRcdFx0dGhpcy5lbWl0KCBgb3BlbmAgKVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbWl0KCBgcmVzdW1lYCApXG5cdFx0fVxuXHRcdHRoaXMuX3dzLm9ubWVzc2FnZSA9IG1lc3NhZ2UgPT4ge1xuXHRcdFx0dGhpcy5lbWl0KCBgbWVzc2FnZWAsIG1lc3NhZ2UgKVxuXHRcdH1cblx0fVxuXG5cdHJlaW5pdCgpIHtcblx0XHR0aGlzLl93cyAmJiB0aGlzLl93cy5jbG9zZSgpXG5cdH1cblxuXHRzZW5kKCBkYXRhICkge1xuXHRcdHRoaXMuX2Vuc3VyZUhhbmRsZSgpXG5cdFx0aWYgKCAhKCB0aGlzLl93cyAmJiB0aGlzLmNvbm5lY3RlZCAmJiAhdGhpcy5jbG9zZWQgKSApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBzb2NrZXQgaXMgbm90IG9wZW5gIClcblx0XHR0aGlzLl93cy5zZW5kKCBkYXRhIClcblx0fVxuXG5cdGRlbGV0ZSgpIHtcblx0XHR0aGlzLmNsb3NlKClcblx0fVxuXG5cdGNsb3NlKCkge1xuXHRcdHRoaXMuY2xvc2VkID0gdHJ1ZVxuXHRcdHRoaXMuX2NsZWFySGFuZGxlKClcblx0XHR0aGlzLmVtaXQoIGBjbG9zZWAgKVxuXHR9XG5cblx0YXNrKCBxdWVzdGlvbiApIHsgcmV0dXJuIGNvLmdvY2FsbCggZnVuY3Rpb24qICgpIHtcblx0XHRsZXQgaWQgPSBVSUQoKVxuXHRcdHRoaXMuc2VuZCggeyBpZCwgcXVlc3Rpb24gfSApXG5cdFx0bGV0IG1lc3NhZ2UgPSB5aWVsZCB0aGlzLmdldCggaWQgKVxuXHRcdGlmICggbWVzc2FnZS5lcnJvciApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1lc3NhZ2UuZXJyb3IgKVxuXHRcdHJldHVybiBtZXNzYWdlLmFuc3dlclxuXHR9LCB0aGlzICkgfVxuXG5cdGdldCggcHJlZGljYXRlLCB0aW1lb3V0ICkgeyByZXR1cm4gY28uZ29jYWxsKCBmdW5jdGlvbiogKCkge1xuXHRcdGlmICggdHlwZW9mIHByZWRpY2F0ZSA9PSBgc3RyaW5nYCB8fCB0eXBlb2YgcHJlZGljYXRlID09IGBudW1iZXJgICkge1xuXHRcdFx0bGV0IGlkID0gcHJlZGljYXRlXG5cdFx0XHRwcmVkaWNhdGUgPSBtc2cgPT4gbXNnLmlkID09IGlkXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhKCB0eXBlb2YgcHJlZGljYXRlID09IGBmdW5jdGlvbmAgKSApIHtcblx0XHRcdGxldCBwID0gcHJlZGljYXRlXG5cdFx0XHRwcmVkaWNhdGUgPSBtc2cgPT4gbG9kYXNoLmV2ZXJ5KCBwLCAoIHZhbHVlLCBrZXkgKSA9PiBtc2dbIGtleSBdID09IHZhbHVlIClcblx0XHR9XG5cdFx0bGV0IHsgZXZlbnQsIGRhdGEgfSA9IHlpZWxkIGNvLnJlY2VpdmUoIHRoaXMsIHsgY2xvc2U6IHRydWUsIG1lc3NhZ2U6IHByZWRpY2F0ZSwgdGltZW91dDogdGltZW91dCB9IClcblx0XHRpZiAoIGV2ZW50ID09IGBtZXNzYWdlYCApXG5cdFx0XHRyZXR1cm4gZGF0YVxuXHRcdHRocm93IG5ldyBFcnJvciggXCJ0aW1lb3V0XCIgKVxuXHR9LCB0aGlzICkgfVxufVxuXG5mdW5jdGlvbiB3c0NsaWVudCggYXBwLCB1cmwgKSB7XG5cdGxldCB3cyA9IG5ldyBQZXJzaXN0ZW50V2ViU29ja2V0KClcblx0cmEoICgpID0+IHdzLnVybCA9IGFwcC5sb2NhbE1vZGVtICYmICggYXBwLmxvY2FsTW9kZW0gKyB1cmwgKSApXG5cdHdzLmFjdGl2ZSA9IHJhLm9uKCB3cywgWyBgcGF1c2VgLCBgcmVzdW1lYCBdLCAoKSA9PiB3cy5jb25uZWN0ZWQgKVxuXHRyZXR1cm4gd3Ncbn1cblxuZnVuY3Rpb24gd3NKU09OY2xpZW50KCBhcHAsIHVybCApIHtcblxuXHRsZXQganNvbiA9IEpTT05sb2NhbCggdXJsLCB7IHVpZDogbnVsbCB9IClcblx0bGV0IHdzID0gd3NDbGllbnQoIGFwcCwgdXJsIClcblx0bGV0IGluaXQgPSAoKSA9PiB3cy5zZW5kKCB7IHdoYXQ6IGBpbml0YCwgaWQ6IGpzb24udWlkIH0gKVxuXHRsZXQgcmVzb2x2ZXJzID0ge31cblxuXHRsZXQgZG9FcnJvciA9ICggbWVzc2FnZSwgZGF0YSApID0+IHsgdGhyb3cgbmV3IEVycm9yKCBgd3NKU09OY2xpZW50OiAkeyBtZXNzYWdlIH06ICR7IEpTT04uc3RyaW5naWZ5KCBkYXRhICkgfWAgKSB9XG5cblx0bHUub24oIHdzLCB7XG5cdFx0cmVzdW1lOiBpbml0LFxuXHRcdG1lc3NhZ2UoIG1lc3NhZ2UgKSB7IHN3aXRjaCAoIG1lc3NhZ2Uud2hhdCApIHtcblx0XHRcdGNhc2UgYGVycm9yYDpcblx0XHRcdFx0ZG9FcnJvciggYGVycm9yIGZyb20gc2VydmVyYCwgbWVzc2FnZSApXG5cdFx0XHRjYXNlIGBzYXZlZGA6IHtcblx0XHRcdFx0bGV0IHJlc29sdmUgPSByZXNvbHZlcnNbIG1lc3NhZ2UubWVzc2FnZUlkIF1cblx0XHRcdFx0ZGVsZXRlIHJlc29sdmVyc1sgbWVzc2FnZS5tZXNzYWdlSWQgXVxuXHRcdFx0XHRyZXNvbHZlICYmIHJlc29sdmUoKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGNhc2UgYGRhdGFgOiB7XG5cdFx0XHRcdGlmICggbWVzc2FnZS5wYXJ0aWFsICYmIG1lc3NhZ2UucHJldmlvdXMgIT0ganNvbi51aWQgKVxuXHRcdFx0XHRcdGluaXQoKVxuXHRcdFx0XHRlbHNlIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBtZXNzYWdlLCBgZGF0YWAgKSApXG5cdFx0XHRcdFx0anNvbi5hc3NpZ24oIGx1LmFwcGx5RGlmZigganNvbi52YWx1ZU9mKCksIG1lc3NhZ2UuZGF0YSwgbWVzc2FnZS5wYXJ0aWFsICkgKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGRvRXJyb3IoIGB1bmtub3duIG1lc3NhZ2UgZnJvbSBzZXJ2ZXJgLCBtZXNzYWdlIClcblx0XHR9IH0sXG5cdFx0ZXJyb3IoKSB7XG5cdFx0XHRhcHAub25DcmVkZW50aWFscygpXG5cdFx0fSxcblx0fSApXG5cblx0ZnVuY3Rpb24gZG9SZWplY3QoIG1lc3NhZ2VJZCwgcmVqZWN0ICkge1xuXHRcdGRlbGV0ZSByZXNvbHZlcnNbIG1lc3NhZ2VJZCBdXG5cdFx0cmVqZWN0KClcblx0fVxuXG5cdGxldCBzYXZlID0gKCBwYXJ0aWFsLCBkYXRhICkgPT4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdGxldCBtZXNzYWdlSWQgPSBVSUQoKVxuXHRcdHJlc29sdmVyc1sgbWVzc2FnZUlkIF0gPSByZXNvbHZlXG5cdFx0d3Muc2VuZCggeyB3aGF0OiBgc2F2ZWAsIGRhdGE6IHBhcnRpYWwgPyBkYXRhIDogT2JqZWN0LmFzc2lnbiggeyBfX3BhcnRpYWxfXzogZmFsc2UgfSwgZGF0YSB8fCB7fSApLCBtZXNzYWdlSWQgfSApXG5cdFx0c2V0VGltZW91dCggZG9SZWplY3QsIHNhdmVQbGFjZXNUaW1lb3V0LCBtZXNzYWdlSWQsIHJlamVjdCApXG5cdH0gKVxuXG5cdHJldHVybiB7XG5cdFx0ZGF0YToganNvbi5nZXRSZWFkT25seSgpLFxuXHRcdGFjdGl2ZTogd3MuYWN0aXZlLFxuXHRcdHNlbmQoIGRhdGEgKSB7IHJldHVybiBzYXZlKCBmYWxzZSwgZGF0YSApIH0sXG5cdFx0dXBkYXRlKCBkYXRhICkgeyByZXR1cm4gc2F2ZSggdHJ1ZSwgZGF0YSApIH0sXG5cdFx0ZGVsZXRlKCkgeyB3cy5jbG9zZSgpIH0sXG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBpZCA9PiB7XG5cbmxldCBsb2NhbERlZmF1bHRzID0ge1xuXHRhY3RpdmVEZXZpY2VJZDogYGAsXG5cdGxhbmd1YWdlOiBgcnVgLFxuXHRpY29uU2l6ZTogNDAsIC8vIG1pbGxpbWV0ZXJzXG5cdGxhYmVsczogdHJ1ZSxcblx0cGxhY2VzUGFnZXM6IHtcblx0fSxcbn1cblxubGV0IGxvY2FsID0gSlNPTmxvY2FsKCBhcHBpZCwgbG9jYWxEZWZhdWx0cyApXG5cbmxldCBhcHAgPSByYS5jbGVhbigge1xuXG5cdGdldE1lc3NhZ2UoIGRhdGEgKSB7XG5cdFx0bGV0IGxhbmd1YWdlID0gbG9jYWwubGFuZ3VhZ2UgfHwgYHJ1YFxuXHRcdHJldHVybiBbIGxhbmd1YWdlLCBgcnVgLCBgZW5gLCBgYnlgIF1cblx0XHRcdC5maWx0ZXIoIGwgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkYXRhLCBsICkgKVxuXHRcdFx0Lm1hcCggbCA9PiBkYXRhWyBsIF0gKVxuXHRcdFx0WyAwIF1cblx0fSxcblxuXHRwYWdlV2lkdGg6IDIsXG5cdHBhZ2VIZWlnaHQ6IDMsXG5cdHBhZ2VTdGFydGluZzogZmFsc2UsXG5cdGRpYWxvZzogYGAsXG5cdGVkaXRpbmc6IGZhbHNlLFxuXHRtb3Zpbmc6IDAsXG5cdGhpc3Rvcnk6IFtdLFxuXHRtZW51RWxlbWVudDogbnVsbCwgLy8gZGl2XG5cblx0bG9nZ2VkaW46IGZhbHNlLFxuXHQvLyBjcmVkZW50aWFsczogMSxcblx0b25DcmVkZW50aWFscygpIHtcblx0XHR0aGlzLmxvZ2dlZGluID0gZmFsc2Vcblx0fSxcblxuXHRnbyggdG8sIHBhdGggKSB7XG5cdFx0aWYgKCAhdG8gKVxuXHRcdFx0cmV0dXJuXG5cdFx0bGV0IGggPSB0aGlzLmhpc3Rvcnlcblx0XHRsZXQgYSA9IGxvY2FsLmFjdGl2ZURldmljZUlkXG5cdFx0bGV0IGxcblx0XHR3aGlsZSAoIGgubGVuZ3RoICYmICggbCA9IGhbIGgubGVuZ3RoIC0gMSBdLCBsID09IHRvIHx8IGwgPT0gYSB8fCBwYXRoICYmIHBhdGguaW5kZXhPZiggbCApID49IDAgKSApXG5cdFx0XHRoLnBvcCgpXG5cdFx0aWYgKCBhICE9IHRvIClcblx0XHRcdGgucHVzaCggYSApXG5cdFx0cGF0aCAmJiBoLnB1c2goIC4uLnBhdGguZmlsdGVyKCBpZCA9PiBpZCAhPSB0aGlzLm1haW4gKS5yZXZlcnNlKCkgKVxuXHRcdGxvY2FsLmFjdGl2ZURldmljZUlkID0gdG9cblx0XHR0aGlzLmRpYWxvZyA9IGBgXG5cdH0sXG5cblx0YmFjaygpIHtcblx0XHR3aGlsZSAoIHRoaXMuaGlzdG9yeS5sZW5ndGggKSB7XG5cdFx0XHRsZXQgZGV2aWNlID0gdGhpcy5oaXN0b3J5LnBvcCgpXG5cdFx0XHRpZiAoIHRoaXMuZ2V0RGV2aWNlKCBkZXZpY2UgKSApXG5cdFx0XHRcdHJldHVybiBsb2NhbC5hY3RpdmVEZXZpY2VJZCA9IGRldmljZVxuXHRcdH1cblx0XHRsb2NhbC5hY3RpdmVEZXZpY2VJZCA9IHRoaXMubWFpblxuXHR9LFxuXG5cdHdpbmRvd1NpemU6IHJlcXVpcmUoIGB3aW5kb3dTaXplYCApLmdldFJlYWRPbmx5KCksXG5cblx0cGxhY2VzU2hpZnRzOiB7XG5cdH0sXG5cblx0Ly8gVE9ETyDQsNCx0L3QsNGe0LvRj9GG0YwhISDRltC90YLRjdGA0YTQtdC50YHRiyDRj9C6INGC0L7Qu9GM0LrRliDRj9C90Ysg0Z4g0LzQsNC00Y3QvNCwINCw0LHQvdCw0Z7Qu9GP0Y7RhtGG0LAhIVxuXHRnZXQgbW9kZW1Mb2NhdGlvbnMoKSB7IHJldHVybiBodHRwQ2xpZW50LmdldCggYC9tb2RlbV9sb2NhdGlvbnNgICkgfSxcblxuXHRnZXQgbG9jYWxNb2RlbSgpIHsgcmV0dXJuIHRoaXMubW9kZW1Mb2NhdGlvbnMgPyB0aGlzLm1vZGVtTG9jYXRpb25zWyAwIF0udXJsLnJlcGxhY2UoIC9eaHR0cCg/PXM/XFw6XFwvXFwvKS8sIGB3c2AgKSA6IGBgIH0sXG5cblx0Z2V0IGRvTG9naW4oKSB7IHJldHVybiBmdW5jdGlvbiogKCkge1xuXHRcdHdoaWxlICggIXRoaXMubG9nZ2VkaW4gJiYgdGhpcy5tb2RlbUxvY2F0aW9ucyApIHtcblx0XHRcdGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgc2NyaXB0YCApXG5cdFx0XHRzY3JpcHQuc3JjID0gYCR7IHRoaXMubW9kZW1Mb2NhdGlvbnNbIDAgXS51cmwgfS9sb2dpbj8keyBVSUQoKSB9YFxuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggc2NyaXB0IClcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHlpZWxkIHNjcmlwdFxuXHRcdFx0XHQvLyB5aWVsZCBQcm9taXNlLnJhY2UoIFsgY28ucHJvbWlzZSggc2NyaXB0ICksIGNvLnRpbWVvdXQoIDE1MDAwICkgXSApXG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0XHRMT0coIGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gbG9naW46ICR7IGVycm9yICYmIGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IgfWAgKVxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApXG5cdFx0XHRcdHlpZWxkIGNvLnNsZWVwKCAzMDAgKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIHNjcmlwdCApXG5cdFx0XHR9XG5cdFx0XHRMT0coIGBsb2dnZWQgaW5gIClcblx0XHRcdHJhLmRldGFjaCggKCkgPT4gdGhpcy5sb2dnZWRpbiA9IHRydWUgKVxuXHRcdFx0Ly8gVE9ETzogdGhpcyBjb2RlIHdpdGggYW4gWE1MSHR0cFJlcXVlc3QgZG9lcyBub3Qgd29yayBvbiBpUGhvbmUgOigoKFxuXHRcdFx0Ly8gbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdFxuXHRcdFx0Ly8geGhyLm9wZW4oIGBQT1NUYCwgdGhpcy5tb2RlbUxvY2F0aW9uc1sgMCBdLnVybCArIGAvbG9naW5gLCB0cnVlLCBgbmVyb2AsIGAxMjNgIClcblx0XHRcdC8vIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG5cdFx0XHQvLyB0cnkge1xuXHRcdFx0Ly8gXHR4aHIuc2VuZCgpXG5cdFx0XHQvLyBcdHlpZWxkIHhoclxuXHRcdFx0Ly8gXHQvLyBhbGVydCggeGhyLnN0YXR1cyApXG5cdFx0XHQvLyBcdExPRyggKCBgYCArIHhoci5zdGF0dXMgKS5ibHVlIClcblx0XHRcdC8vIFx0aWYgKCB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDw9IDI5OSApXG5cdFx0XHQvLyBcdFx0cmV0dXJuIHJhLmRldGFjaCggKCkgPT4gdGhpcy5sb2dnZWRpbiA9IHRydWUgKVxuXHRcdFx0Ly8gfVxuXHRcdFx0Ly8gY2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdC8vIFx0Ly8gYWxlcnQoIGBFUlJgIClcblx0XHRcdC8vIFx0Y29uc29sZS5sb2coIGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gbG9naW5gLCBlcnJvciApXG5cdFx0XHQvLyB9XG5cdFx0XHQvLyB5aWVsZCBjby5zbGVlcCggMzAwIClcblx0XHR9XG5cdH0uY2FsbCggdGhpcyApIH0sXG5cblx0bG9naW4oIG5hbWUsIHB3ZCApIHt9LFxuXG5cdGdldCBzZXJ2ZXJEZXZpY2VzKCkgeyByZXR1cm4gd3NKU09OY2xpZW50KCB0aGlzLCBgL2RhdGFiYXNlYCApIH0sXG5cdGdldCBsb2NhbERldmljZXMoKSB7IHJldHVybiByYS5kYiggdGhpcy5zZXJ2ZXJEZXZpY2VzLmRhdGEsIGRhdGEgPT4gdGhpcy5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggZGF0YSApICkgfSxcblx0Z2V0IGRldmljZXMoKSB7IHJldHVybiB0aGlzLmxvY2FsRGV2aWNlcy52YWx1ZU9mKCkgfHwge30gfSxcblxuXHRnZXQgY29tbWFuZHMoKSB7IHJldHVybiB3c0NsaWVudCggdGhpcywgYC9jb21tYW5kc2AgKSB9LFxuXHRnZXQgY29ubmVjdGVkVG9TZXJ2ZXIoKSB7IHJldHVybiB0cnVlXG5cdFx0JiYgdGhpcy5zZXJ2ZXJEZXZpY2VzLmFjdGl2ZS52YWx1ZU9mKClcblx0XHQmJiB0aGlzLmNvbW1hbmRzLmFjdGl2ZS52YWx1ZU9mKClcblx0fSxcblxuXHRnZXQgbWFpbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kZXZpY2VzLm1haW5cblx0fSxcblxuXHRnZXREZXZpY2UoIGRldmljZUlkICkge1xuXHRcdHJldHVybiB0aGlzLmRldmljZXMuY29udGVudCAmJiB0aGlzLmRldmljZXMuY29udGVudFsgbHUudmFsdWVPZiggZGV2aWNlSWQgKSBdXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZURldmljZUlkKCkge1xuXHRcdHJldHVybiBsb2NhbC5hY3RpdmVEZXZpY2VJZCB8fCB0aGlzLm1haW5cblx0fSxcblxuXHRnZXQgYWN0aXZlRGV2aWNlKCkge1xuXHRcdHJldHVybiB0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZUNvbnRlbnRJZHMoKSB7XG5cdFx0bGV0IGRldmljZSA9IHRoaXMuYWN0aXZlRGV2aWNlXG5cdFx0cmV0dXJuIHJhLkFycmF5KCBsb2Rhc2gua2V5cyggZGV2aWNlICYmIGRldmljZS5jb250ZW50ICkuc29ydCggKCBhLCBiICkgPT4gZGV2aWNlLmNvbnRlbnRbIGEgXS5pbmRleCAtIGRldmljZS5jb250ZW50WyBiIF0uaW5kZXggKSApXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZUNvbnRlbnQoKSB7XG5cdFx0cmV0dXJuIHJhLkFycmF5KCB0aGlzLmFjdGl2ZUNvbnRlbnRJZHMubWFwKCB0aGlzLmdldERldmljZSApIClcblx0fSxcblxuXHRsaW5raW5nUGxhY2VJZDogbnVsbCxcblx0Z2V0IGNsZWFyTGlua2luZ1BsYWNlSWQoKSB7XG5cdFx0aWYgKCB0aGlzLmRpYWxvZyAhPSBgQXNrVG9MaW5rRGV2aWNlYCAmJiB0aGlzLmRpYWxvZyAhPSBgQXNrSWZEZXZpY2VIYXNCZWVuTGlua2VkYCApXG5cdFx0XHR0aGlzLmxpbmtpbmdQbGFjZUlkID0gbnVsbFxuXHR9LFxuXG5cdGdldCBjaGVja0lmVGltZVRvR29CYWNrKCkge1xuXHRcdC8vIGx1LnZhbHVlT2YoIHRoaXMucGxhY2VzIClcblx0XHRpZiAoICF0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApIClcblx0XHRcdHRoaXMuYmFjaygpXG5cdH0sXG5cblx0Z2V0IGNhcHRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWVzc2FnZSggdGhpcy5nZXREZXZpY2UoIHRoaXMuYWN0aXZlRGV2aWNlSWQgKSApIHx8IHRoaXMubWVzc2FnZSggYGZhdm9yaXRlc2AgKVxuXHR9LFxuXG5cdGdldCBkZXZpY2VUeXBlKCkge1xuXHRcdGxldCByZXQgPSB0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApXG5cdFx0aWYgKCAhcmV0IClcblx0XHRcdHJldCA9IHRoaXMuZ2V0RGV2aWNlKCB0aGlzLm1haW4gKVxuXHRcdHJldHVybiAoIHJldCAmJiByZXQudHlwZSApIHx8IGBwbGFjZWBcblx0fSxcblxuXHRnZXQgZGV2aWNlSWRzKCkge1xuXHRcdHJldHVybiByYS5BcnJheSggbG9kYXNoLmtleXMoIHRoaXMuZGV2aWNlcy5jb250ZW50ICkuc29ydCgpIClcblx0fSxcblxuXHRnZXQgaW5pdGlhbExvYWRpbmcoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRldmljZXMudWlkXG5cdH0sXG5cblx0Z2V0IGluaXRpYWxpemVkKCkge1xuXHRcdHJldHVybiAhdGhpcy5pbml0aWFsTG9hZGluZyAmJiAhIXRoaXMuZGV2aWNlcy5tYWluXG5cdH0sXG5cblx0c2V0RGF0YWJhc2UoIGRldmljZXMgKSB7XG5cdFx0dGhpcy5zZXJ2ZXJEZXZpY2VzLnNlbmQoIGRldmljZXMgKVxuXHR9LFxuXG5cdHJlc2V0KCkge1xuXHRcdGxvY2FsLnJlc2V0KClcblx0XHR0aGlzLnNldERhdGFiYXNlKCB7IHVpZDogVUlEKCkgfSApXG5cdFx0dGhpcy5kaWFsb2cgPSBgYFxuXHRcdHRoaXMuZWRpdGluZyA9IGZhbHNlXG5cdFx0dGhpcy5oaXN0b3J5Lmxlbmd0aCA9IDBcblx0fSxcblxuXHRzZXRUZW1wbGF0ZSggdGVtcGxhdGUgKSB7XG5cdFx0Y29uc29sZS5sb2coIHRlbXBsYXRlIClcblx0XHRsZXQgZGV2aWNlcyA9IHtcblx0XHRcdHVpZDogVUlEKCksXG5cdFx0XHRjb250ZW50OiB7fSxcblx0XHR9XG5cdFx0ZnVuY3Rpb24gY29weSggdGVtcGxhdGUsIGRldmljZSApIHtcblx0XHRcdE9iamVjdC5rZXlzKCB0ZW1wbGF0ZSApLmZvckVhY2goIGtleSA9PlxuXHRcdFx0XHRrZXkgIT0gYGltYWdlYCAmJiAvLyBUT0RPOiAhISEhISEhIVxuXHRcdFx0XHRrZXkgIT0gYGNvbnRlbnRgICYmXG5cdFx0XHRcdGtleSAhPSBgdHlwZWAgJiZcblx0XHRcdFx0KCBkZXZpY2VbIGtleSBdID0gdGVtcGxhdGVbIGtleSBdIClcblx0XHRcdClcblx0XHRcdHJldHVybiBkZXZpY2Vcblx0XHR9XG5cdFx0ZnVuY3Rpb24gd2FsayggdGVtcGxhdGUsIGlkICkge1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5jb250ZW50IHx8IHRlbXBsYXRlLnR5cGUgPT0gYHBsYWNlYCApIHtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSB7fVxuXHRcdFx0XHRkZXZpY2VzLmNvbnRlbnRbIGlkIF0gPSBjb3B5KCB0ZW1wbGF0ZSwgeyB0eXBlOiBgcGxhY2VgLCBjb250ZW50OiBjb250ZW50IH0gKVxuXHRcdFx0XHRsZXQgaW5kZXggPSAwXG5cdFx0XHRcdHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5mb3JFYWNoKCBwID0+XG5cdFx0XHRcdFx0Y29udGVudFsgd2FsayggcCwgVUlEKCkgKSBdID0geyBpbmRleDogaW5kZXgrKyB9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkZXZpY2VzLmNvbnRlbnRbIGlkIF0gPSBjb3B5KCB0ZW1wbGF0ZSwgeyB0eXBlOiBgc2luZ2xlYCB9IClcblx0XHRcdH1cblx0XHRcdHJldHVybiBpZFxuXHRcdH1cblx0XHRkZXZpY2VzLm1haW4gPSB3YWxrKCB0ZW1wbGF0ZSwgVUlEKCkgKVxuXHRcdHRoaXMuc2V0RGF0YWJhc2UoIGRldmljZXMgKVxuXHR9LFxuXG5cdGdldCB0ZW1wbGF0ZXMoKSB7IHJldHVybiBmdW5jdGlvbiogKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4geWllbGQgaHR0cENsaWVudC5nZXQoIGAvdGVtcGxhdGVzYCApXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gZXJyb3Jcblx0XHR9XG5cdH0uY2FsbCggdGhpcyApIH0sXG5cblx0Z2V0IGFsbE1lc3NhZ2VzKCkgeyByZXR1cm4gZnVuY3Rpb24qICgpIHtcblx0XHRyZXR1cm4geWllbGQgaHR0cENsaWVudC5nZXQoIGAvbWVzc2FnZXNgIClcblx0fS5jYWxsKCB0aGlzICkgfSxcblxuXHRnZXQgbWVzc2FnZXMoKSB7XG5cdFx0bGV0IGFsbE1lc3NhZ2VzID0gdGhpcy5hbGxNZXNzYWdlc1xuXHRcdGlmICggYWxsTWVzc2FnZXMgPT0gbnVsbCApXG5cdFx0XHRyZXR1cm5cblx0XHRsZXQgcmV0ID0ge31cblx0XHRsZXQgbGFuZ3VhZ2UgPSBsb2NhbC5sYW5ndWFnZSB8fCBgcnVgXG5cdFx0bG9kYXNoLmZvck93biggYWxsTWVzc2FnZXMsICggdmFsdWUsIGtleSApID0+XG5cdFx0XHRyZXRbIGtleSBdID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB2YWx1ZSwgbGFuZ3VhZ2UgKSA/IHZhbHVlWyBsYW5ndWFnZSBdIDoga2V5IClcblx0XHRyZXR1cm4gcmV0XG5cdH0sXG5cblx0bWVzc2FnZSggaWQgKSB7XG5cdFx0bGV0IHJldCA9IHRoaXMubWVzc2FnZXMgJiYgdGhpcy5tZXNzYWdlc1sgaWQgXVxuXHRcdGlmICggcmV0ID09IG51bGwgKVxuXHRcdFx0cmV0ID0gaWRcblx0XHRyZXR1cm4gcmV0XG5cdH0sXG5cblx0bm90aWZpY2F0aW9uKCBtZXNzYWdlICkge1xuXHRcdC8vIGFsZXJ0KCBtZXNzYWdlIClcblx0fSxcblxuXHRzYXZlRGV2aWNlKCBkZXZpY2VJZCwgZGV2aWNlICkge1xuXHRcdGxldCBkaWZmID0gbHUubWFrZURpZmYoIHRoaXMuZ2V0RGV2aWNlKCBkZXZpY2VJZCApLCBkZXZpY2UgKVxuXHRcdHJldHVybiBkaWZmID09IG51bGwgPyBQcm9taXNlLnJlc29sdmUoKSA6IHRoaXMuc2VydmVyRGV2aWNlcy51cGRhdGUoIHsgY29udGVudDogeyBbIGRldmljZUlkIF06IGRpZmYgfSB9IClcblx0fSxcblxuXHRuZXdJbmRleCggaWNvbklkICkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyggdGhpcy5nZXREZXZpY2UoIGljb25JZCApLmNvbnRlbnQgfHwge30gKS5sZW5ndGggKyAxXG5cdH0sXG5cblx0bGlua0l0ZW0oIGljb25JZCwgaXRlbUlkLCBleHRyYSApIHsgcmV0dXJuIGNvLmdvY2FsbCggZnVuY3Rpb24qICgpIHtcblx0XHRpZiAoIGljb25JZCA9PSBpdGVtSWQgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbm5vdCBsaW5rIHBsYWNlIHRvIGl0c2VsZlwiIClcblx0XHRsZXQgcGxhY2UgPSB0aGlzLmdldERldmljZSggaWNvbklkIClcblx0XHRsZXQgZGV2aWNlID0gdGhpcy5nZXREZXZpY2UoIGl0ZW1JZCApXG5cdFx0aWYgKCBwbGFjZS50eXBlID09IGBncm91cGAgKSB7XG5cdFx0XHRpZiAoICFwbGFjZS5ncm91cCApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYGludGVybmFsIGVycm9yOiBubyBHUk9VUCBudW1iZXIgZm91bmRgIClcblx0XHRcdGlmICggIWRldmljZS5ncm91cCApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYGNhbm5vdCBhZGQgdW5saW5rZWQgZGV2aWNlIHRvIGEgZ3JvdXBgIClcblx0XHR9XG5cdFx0bGV0IHJlYyA9IHRoaXMubG9jYWxEZXZpY2VzLmNyZWF0ZVJlY29yZCgpXG5cdFx0dHJ5IHtcblx0XHRcdGxldCBwYWNrZXQgPSB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXTogeyBjb250ZW50OiB7IFsgaXRlbUlkIF06IHsgaW5kZXg6IHRoaXMubmV3SW5kZXgoIGljb25JZCApIH0gfSB9IH0gfVxuXHRcdFx0bGV0IHJlc3VsdCA9ICFleHRyYSA/IHBhY2tldCA6IGx1Lm1lcmdlRGlmZnMoIGV4dHJhLCBwYWNrZXQgKVxuXHRcdFx0ZGVidWdnZXJcblx0XHRcdHJlYy5hc3NpZ24oIHJlc3VsdCApXG5cdFx0XHRpZiAoIHBsYWNlLnR5cGUgPT0gYGdyb3VwYCApXG5cdFx0XHRcdHlpZWxkIHRoaXMuY29tbWFuZCggaXRlbUlkLCBgQXBwZW5kVG9gLCBwbGFjZS5ncm91cCApXG5cdFx0XHR5aWVsZCByZWMuc2F2ZSgpXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0cmVjLmNsb3NlKClcblx0XHR9XG5cdH0sIHRoaXMgKSB9LFxuXG5cdGxpbmtUb0Zhdm91cml0ZXMoIGl0ZW1JZCApIHtcblx0XHRyZXR1cm4gdGhpcy5saW5rSXRlbSggdGhpcy5tYWluLCBpdGVtSWQgKVxuXHR9LFxuXG5cdGxpbmtBY3RpdmVUb0Zhdm91cml0ZXMoIGl0ZW1JZCApIHtcblx0XHRyZXR1cm4gdGhpcy5saW5rVG9GYXZvdXJpdGVzKCB0aGlzLmFjdGl2ZURldmljZUlkIClcblx0fSxcblxuXHRhZGRJdGVtKCBpY29uSWQsIGl0ZW0sIGlkID0gVUlEKCksIGluZGV4ID0gbnVsbCApIHtcblx0XHRyZXR1cm4gdGhpcy5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggeyBjb250ZW50OiB7XG5cdFx0XHRbIGljb25JZCBdOiB7IGNvbnRlbnQ6IHsgWyBpZCBdOiB7IGluZGV4OiBpbmRleCAhPSBudWxsID8gaW5kZXggOiB0aGlzLm5ld0luZGV4KCBpY29uSWQgKSB9IH0gfSxcblx0XHRcdFsgaWQgXTogaXRlbSxcblx0XHR9IH0gKVxuXHR9LFxuXG5cdGFkZFBsYWNlKCBpY29uSWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkSXRlbSggaWNvbklkLCB7XG5cdFx0XHR0eXBlOiBgcGxhY2VgLFxuXHRcdFx0cnU6IGDQn9C+0LzQtdGJ0LXQvdC40LVgLFxuXHRcdFx0ZW46IGBSb29tYCxcblx0XHR9IClcblx0fSxcblxuXHRhZGREZXZpY2UoIGljb25JZCApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRJdGVtKCBpY29uSWQsIHtcblx0XHRcdHR5cGU6IGBzaW5nbGVgLFxuXHRcdFx0cnU6IGDQo9GB0YLRgNC+0LnRgdGC0LLQvmAsXG5cdFx0XHRlbjogYERldmljZWAsXG5cdFx0fSApXG5cdH0sXG5cblx0YWRkR3JvdXAoIGljb25JZCwgaWQgKSB7IHJldHVybiBjby5nb2NhbGwoIGZ1bmN0aW9uKiAoKSB7XG5cdFx0aWYgKCAhaWQgKVxuXHRcdFx0aWQgPSBVSUQoKVxuXHRcdHlpZWxkIHRoaXMuYWRkSXRlbSggaWNvbklkLCB7XG5cdFx0XHR0eXBlOiBgZ3JvdXBgLFxuXHRcdFx0cnU6IGDQk9GA0YPQv9C/0LBgLFxuXHRcdFx0ZW46IGBHcm91cGAsXG5cdFx0fSwgaWQgKVxuXHRcdHlpZWxkIHRoaXMuY29tbWFuZCggaWQsIGBSZXNlcnZlYCApXG5cdFx0cmV0dXJuIGlkXG5cdH0sIHRoaXMgKSB9LFxuXG5cdGRlbGV0ZUl0ZW0oIGljb25JZCwgaXRlbUlkICkgeyByZXR1cm4gY28uZ29jYWxsKCBmdW5jdGlvbiogKCkge1xuXHRcdGxldCBwbGFjZSA9IHRoaXMuZ2V0RGV2aWNlKCBpY29uSWQgKVxuXHRcdGxldCByZWMgPSB0aGlzLmxvY2FsRGV2aWNlcy5jcmVhdGVSZWNvcmQoKVxuXHRcdHRyeSB7XG5cdFx0XHRyZWMuYXNzaWduKCB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXTogeyBjb250ZW50OiB7IFsgaXRlbUlkIF06IG51bGwgfSB9IH0gfSApXG5cdFx0XHRpZiAoIHBsYWNlLnR5cGUgPT0gYGdyb3VwYCAmJiBwbGFjZS5ncm91cCApXG5cdFx0XHRcdHlpZWxkIHRoaXMuY29tbWFuZCggaXRlbUlkLCBgUmVtb3ZlRnJvbWAsIHBsYWNlLmdyb3VwIClcblx0XHRcdHlpZWxkIHJlYy5zYXZlKClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRyZWMuY2xvc2UoKVxuXHRcdH1cblx0fSwgdGhpcyApIH0sXG5cblx0aW5zZXJ0SW50byggaWNvbklkLCBpdGVtSWQsIGZyb21JZCApIHtcblx0XHRyZXR1cm4gdGhpcy5saW5rSXRlbSggaWNvbklkLCBpdGVtSWQsIHsgY29udGVudDogeyBbIGZyb21JZCBdOiB7IGNvbnRlbnQ6IHsgWyBpdGVtSWQgXTogbnVsbCB9IH0gfSB9IClcblx0fSxcblxuXHRlcnJvcnM6IG51bGwsXG5cdHRocm93KCBkaWFsb2csIGRhdGEsIHJldHJ5ICkge1xuXHRcdGlmICggIWRpYWxvZyApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBhbiBlcnJvciBoYXMgdG8gaGF2ZSBpdHMgb3duIGRpYWxvZ2AgKVxuXHRcdHRoaXMuZXJyb3JzID0gKCB0aGlzLmVycm9ycyB8fCBbXSApLmNvbmNhdCggWyB7XG5cdFx0XHRkaWFsb2csXG5cdFx0XHRkYXRhLFxuXHRcdFx0cmV0cnksXG5cdFx0fSBdIClcblx0fSxcblx0Y2xlYXJFcnJvcigpIHsgcmEuZGV0YWNoKCAoKSA9PiB7XG5cdFx0aWYgKCB0aGlzLmVycm9yICkge1xuXHRcdFx0dGhpcy5kaWFsb2cgPSBgYFxuXHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycyAmJiB0aGlzLmVycm9ycy5zbGljZSggMSApXG5cdFx0fVxuXHR9ICkgfSxcblx0Z2V0IGNoZWNrRXJyb3IoKSB7XG5cdFx0aWYgKCAhdGhpcy5kaWFsb2cgKVxuXHRcdFx0aWYgKCB0aGlzLmVycm9ycyAmJiB0aGlzLmVycm9ycy5sZW5ndGggKSByYS5kZXRhY2goICgpID0+IHtcblx0XHRcdFx0bGV0IGVycm9yID0gdGhpcy5lcnJvcnNbIDAgXVxuXHRcdFx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzICYmIHRoaXMuZXJyb3JzLnNsaWNlKCAxIClcblx0XHRcdFx0dGhpcy5kaWFsb2cgPSBlcnJvci5kaWFsb2dcblx0XHRcdFx0dGhpcy5lcnJvciA9IGVycm9yXG5cdFx0XHR9IClcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5lcnJvciA9IG51bGxcblx0fSxcblx0ZXJyb3I6IG51bGwsXG5cblx0cHVyZ2VJdGVtKCBkZXZpY2VJZCwgZm9yY2UgKSB7IHJldHVybiBjby5nb2NhbGwoIGZ1bmN0aW9uKiAoKSB7XG5cdFx0Ly8gZGVidWdnZXJcblx0XHRsZXQgZGV2aWNlID0gdGhpcy5nZXREZXZpY2UoIGRldmljZUlkIClcblx0XHRsZXQgcmVjID0gdGhpcy5sb2NhbERldmljZXMuY3JlYXRlUmVjb3JkKClcblx0XHR0cnkge1xuXHRcdFx0cmVjLmFzc2lnbiggZGV2ZGIuQ2xlYXIoIHRoaXMuZGV2aWNlcywgZGV2aWNlSWQgKSApXG5cdFx0XHRsZXQgY21kXG5cdFx0XHRpZiAoIGRldmljZSAmJiBkZXZpY2UuZ3JvdXAgIT0gbnVsbCApXG5cdFx0XHRcdGlmICggZGV2aWNlLnR5cGUgPT0gYGdyb3VwYCApXG5cdFx0XHRcdFx0Y21kID0gYENsZWFyYFxuXHRcdFx0XHRlbHNlIGlmICggZGV2aWNlLnR5cGUgPT0gYHNpbmdsZWAgKVxuXHRcdFx0XHRcdGNtZCA9IGBVbmxpbmtgXG5cdFx0XHRpZiAoIGNtZCApXG5cdFx0XHRcdHlpZWxkIHRoaXMuY29tbWFuZCggZGV2aWNlSWQsIGNtZCApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHlpZWxkIHJlYy5zYXZlKClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRpZiAoIGZvcmNlIClcblx0XHRcdFx0eWllbGQgcmVjLnNhdmUoKVxuXHRcdFx0cmVjLmNsb3NlKClcblx0XHRcdC8vIHNlcnZlciBNVVNUIHNlbmQgdXMgYWN0dWFsIHN0YXRlIEJFRk9SRSByZXR1cm5pbmcgcmVzdWx0IG9mIGNvbW1hbmQgZXhlY3V0aW9uXG5cdFx0XHRpZiAoICggbHUudmFsdWVPZiggdGhpcy5zZXJ2ZXJEZXZpY2VzLmRhdGEgKSB8fCAxIClbIGRldmljZUlkIF0gKVxuXHRcdFx0XHR0aGlzLnRocm93KCBgRXJyb3JVbmxpbmtpbmdEZXZpY2VgLCB7IGRldmljZUlkIH0sIClcblx0XHR9XG5cdH0sIHRoaXMgKSB9LFxuXG5cdHJlbmFtZUl0ZW0oIGljb25JZCwgbmFtZSApIHtcblx0XHRsZXQgcmV0ID0gbG9kYXNoLnJlZHVjZSggdGhpcy5nZXREZXZpY2UoIGljb25JZCApLCAoIHJldCwgXywga2V5ICkgPT4ge1xuXHRcdFx0aWYgKCBrZXkubGVuZ3RoID09IDIgKVxuXHRcdFx0XHRyZXRbIGtleSBdID0gbnVsbFxuXHRcdFx0cmV0dXJuIHJldFxuXHRcdH0sIHt9IClcblx0XHRyZXRbIGxvY2FsRGVmYXVsdHMubGFuZ3VhZ2UgfHwgYHJ1YCBdID0gbmFtZVxuXHRcdHJldHVybiB0aGlzLnNlcnZlckRldmljZXMudXBkYXRlKCB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXTogcmV0IH0gfSApXG5cdH0sXG5cblx0Y29tbWFuZCggZGV2aWNlSWQsIGNtZCwgZGF0YSApIHtcblxuXHRcdC8vIGRlYnVnZ2VyXG5cblx0XHQvLyBUT0RPOlxuXHRcdGxldCBuZXdzdGF0ZSA9IGRldmljZUFjdGlvbnMuZ2V0TmV3U3RhdGUoIHRoaXMuZ2V0RGV2aWNlKCBkZXZpY2VJZCApLCBjbWQgKVxuXHRcdGlmICggbmV3c3RhdGUgIT0gbnVsbCApIHtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jb21tYW5kcy5hc2soIHsgZGV2aWNlOiBkZXZpY2VJZCwgY29tbWFuZDogY21kLCBkYXRhOiBkYXRhIH0gKVxuXHR9LFxuXG5cdGljb25Db21tYW5kKCBpY29uLCBpY29uSWQsIGNtZCwgZGF0YSApIHtcblx0XHQvLyBjb25zb2xlLmxvZyggaWNvbiwgaWNvbklkLCBjbWQgKVxuXHRcdGljb24gPSBsdS52YWx1ZU9mKCBpY29uIClcblx0XHRpZiAoIGljb24udHlwZSA9PSBgcGxhY2VgID8gY21kID09IGBTaG9ydGAgOiBjbWQgPT0gYExvbmdgIClcblx0XHRcdHJldHVybiB0aGlzLmdvKCBpY29uSWQgKVxuXHRcdGlmICggaWNvbi50eXBlICE9IGBwbGFjZWAgJiYgIWljb24uZ3JvdXAgKSB7XG5cdFx0XHR0aGlzLmRpYWxvZyA9IGBBc2tUb0xpbmtEZXZpY2VgXG5cdFx0XHR0aGlzLmxpbmtpbmdQbGFjZUlkID0gaWNvbklkXG5cdFx0XHQvLyByZXR1cm4gUHJvbWlzZS5yZWplY3QoIG5ldyBFcnJvciggYGRldmljZSBub3QgY29uZmlndXJlZGAgKSApXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHR9XG5cdFx0aWYgKCBjbWQgPT0gYFNob3J0YCB8fCBjbWQgPT0gYExvbmdgICkge1xuXHRcdFx0aWYgKCBpY29uICYmIGljb24uc3RhdGUgKSB7XG5cdFx0XHRcdGNtZCA9IGBTZXRgXG5cdFx0XHRcdGRhdGEgPSAwXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y21kID0gYFNldGBcblx0XHRcdFx0ZGF0YSA9IDFcblx0XHRcdH1cblx0XHRcdC8vIGNtZCA9IGBDb21mb3J0XzFgXG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmNvbW1hbmQoIGljb25JZCwgY21kLCBkYXRhIClcblx0fSxcblxuXHRmb2N1cyggbm9kZSApIHtcblx0XHQvLyBtYWdpYyBhY3Rpb25zIHRvIGZvcmNlIGFsbG93IHRvIHNob3cga2V5Ym9hcmQgYnkgaW5wdXQuZm9jdXMoKSBvbiBpT1MgKCBzbyBmYXIgY2hlY2tlZCBpT1MgOCApXG5cdFx0c2V0VGltZW91dCggKCkgPT4gbm9kZS5mb2N1cygpLCA0MDAgKVxuXHR9LFxuXG5cdHNlYXJjaEFjdGlvbjogbnVsbCxcblx0c2VhcmNoRmlsdGVyOiBudWxsLFxuXHRnZXQgY2hlY2tTZWFyY2hEaWFsb2coKSB7XG5cdFx0aWYgKCB0aGlzLmRpYWxvZyAhPSBgU2VhcmNoSXRlbXNgICkge1xuXHRcdFx0dGhpcy5zZWFyY2hBY3Rpb24gPSBudWxsXG5cdFx0XHR0aGlzLnNlYXJjaEZpbHRlciA9IG51bGxcblx0XHR9XG5cdH0sXG5cblx0aWNvbnM6IG51bGwsXG5cblx0bW9kdWxlczogbmV3IFdlYWtNYXAsXG5cdGxvYWQoIG1vZHVsZSApIHtcblx0XHRsZXQgcmV0ID0gdGhpcy5tb2R1bGVzLmdldCggbW9kdWxlIClcblx0XHRpZiAoIHJldCA9PSBudWxsICkge1xuXHRcdFx0cmV0ID0gbW9kdWxlKCBhcHAsIGxvY2FsIClcblx0XHRcdHRoaXMubW9kdWxlcy5zZXQoIG1vZHVsZSwgcmV0IClcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdGhvdmVyOiBudWxsLFxuXG5cdGRlYnVnZ2VyKCkgeyBkZWJ1Z2dlciB9LFxuXG59ICkuc2V0TmFtZSggYGFwcGAgKVxuXG5yZXR1cm4geyBhcHAsIGxvY2FsIH1cblxufVxuIiwibGV0IE1BWF9USUNLUyA9IDEwMDBcblxubGV0IHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dFxubGV0IHNldEludGVydmFsID0gd2luZG93LnNldEludGVydmFsXG5cbnByb2Nlc3MubmV4dFRpY2sgPSBuZXh0VGlja1xuXG5sZXQgcXVldWUgPSBbXVxubGV0IHRpbWVyID0gbnVsbFxubGV0IHByb2Nlc3NpbmcgPSBmYWxzZVxubGV0IHNlY3JldCA9IFwicHJvY2Vzcy10aWNrLVwiICsgTWF0aC5yYW5kb20oKVxuXG5sZXQgaW5zdGFsbFRpbWVyID0gZnVuY3Rpb24gKCkgeyB0aW1lciA9IHNldFRpbWVvdXQoIG9uVGltZXIsIDEgKSB9XG5cbmlmICggd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJtZXNzYWdlXCIsIGZ1bmN0aW9uICggZXYgKSB7XG5cdFx0bGV0IHNvdXJjZSA9IGV2LnNvdXJjZTtcblx0XHRpZiAoICggc291cmNlID09IHdpbmRvdyB8fCBzb3VyY2UgPT0gbnVsbCApICYmIGV2LmRhdGEgPT0gc2VjcmV0ICkge1xuXHRcdFx0ZXYuc3RvcFByb3BhZ2F0aW9uKClcblx0XHRcdG9uVGltZXIoKVxuXHRcdH1cblx0fSApXG5cdGxldCBwb3N0TWVzc2FnZSA9IHdpbmRvdy5wb3N0TWVzc2FnZVxuXHRpbnN0YWxsVGltZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cG9zdE1lc3NhZ2UoIHNlY3JldCwgXCIqXCIgKVxuXHRcdHRpbWVyID0gdHJ1ZVxuXHR9XG59XG5cbiFbIFwic2V0VGltZW91dFwiLCBcInNldEludGVydmFsXCIsIFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIgXS5mb3JFYWNoKCBuYW1lID0+IHtcblx0bGV0IHByb2MgPSBob29rTWV0aG9kKCB3aW5kb3csIG5hbWUsIGZ1bmN0aW9uICggaGFuZGxlciwgdGltZSApIHtcblx0XHRpZiAoIHR5cGVvZiBhcmd1bWVudHNbIDAgXSA9PSBcImZ1bmN0aW9uXCIgKVxuXHRcdFx0YXJndW1lbnRzWyAwIF0gPSBnZXRQcm94eSggYXJndW1lbnRzWyAwIF0gKVxuXHRcdHJldHVybiBwcm9jLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHR9IClcbn0gKVxuXG4hWyB3aW5kb3csIGRvY3VtZW50IF0uZm9yRWFjaCggaG9va0V2ZW50TGlzdGVuZXIgKVxuXG5mdW5jdGlvbiBvblRpbWVyKCkge1xuXHR0aW1lciA9IG51bGxcblx0cHJvY2Vzc1F1ZXVlKClcbn1cblxuZnVuY3Rpb24gZW5zdXJlVGltZXIoKSB7XG5cdGlmICggIXRpbWVyICYmICFwcm9jZXNzaW5nIClcblx0XHRpbnN0YWxsVGltZXIoKVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayggZnVuICkge1xuXHRxdWV1ZS5wdXNoKCBmdW4gKVxuXHRlbnN1cmVUaW1lcigpXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcblx0aWYgKCBwcm9jZXNzaW5nIHx8ICFxdWV1ZS5sZW5ndGggKVxuXHRcdHJldHVyblxuXHRsZXQgaW5kZXggPSAwXG5cdHByb2Nlc3NpbmcgPSB0cnVlXG5cdHRyeSB7XG5cdFx0d2hpbGUgKCBpbmRleCA8IE1BWF9USUNLUyAmJiBpbmRleCA8IHF1ZXVlLmxlbmd0aCApXG5cdFx0XHRxdWV1ZVsgaW5kZXgrKyBdKClcblx0fVxuXHRmaW5hbGx5IHtcblx0XHQvLyBjb25zb2xlLmxvZyggXCJ0aWNrczogXCIgKyBpbmRleCApXG5cdFx0cHJvY2Vzc2luZyA9IGZhbHNlXG5cdFx0cXVldWUuc3BsaWNlKCAwLCBpbmRleCApXG5cdFx0aWYgKCBxdWV1ZS5sZW5ndGggKVxuXHRcdFx0ZW5zdXJlVGltZXIoKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGdldFByb3h5KCBoYW5kbGVyICkge1xuXHRmdW5jdGlvbiBwcm94eSgpIHtcblx0XHRsZXQgcmV0ID0gaGFuZGxlci5oYW5kbGVFdmVudCA/IGhhbmRsZXIuaGFuZGxlRXZlbnQuYXBwbHkoIGhhbmRsZXIsIGFyZ3VtZW50cyApIDogaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRwcm9jZXNzUXVldWUoKVxuXHRcdHJldHVybiByZXRcblx0fVxuXHRsZXQgcmV0XG5cdGlmICggKCByZXQgPSBoYW5kbGVyWyBzZWNyZXQgXSApICE9IG51bGwgKVxuXHRcdHJldHVybiByZXRcblx0ZWxzZSB7XG5cdFx0YXNzaWduUHJvcGVydHkoIHByb3h5LCBzZWNyZXQsIHByb3h5IClcblx0XHRyZXR1cm4gYXNzaWduUHJvcGVydHkoIGhhbmRsZXIsIHNlY3JldCwgcHJveHkgKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGhvb2tFdmVudExpc3RlbmVyKCBvYmogKSB7XG5cdGlmICggb2JqLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0bGV0IGFkZEV2ZW50TGlzdGVuZXIgPSBob29rTWV0aG9kKCBvYmosIFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuXHRcdFx0ZnVuY3Rpb24gKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdFx0YXJndW1lbnRzWyAxIF0gPSBnZXRQcm94eSggYXJndW1lbnRzWyAxIF0gKVxuXHRcdFx0XHRyZXR1cm4gYWRkRXZlbnRMaXN0ZW5lci5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRcdH0gKVxuXHRcdGxldCByZW1vdmVFdmVudExpc3RlbmVyID0gaG9va01ldGhvZCggb2JqLCBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcblx0XHRcdGZ1bmN0aW9uICggZXZlbnQsIGhhbmRsZXIgKSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzWyAxIF1bIHNlY3JldCBdIClcblx0XHRcdFx0XHRhcmd1bWVudHNbIDEgXSA9IGFyZ3VtZW50c1sgMSBdWyBzZWNyZXQgXVxuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRcdH0gKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGhvb2tNZXRob2QoIG9iaiwgbmFtZSwgcHJveHkgKSB7XG5cdGxldCByZXQgPSBvYmpbIG5hbWUgXVxuXHRpZiAoIHJldCApIHtcblx0XHRhc3NpZ25Qcm9wZXJ0eSggcHJveHksIFwidG9TdHJpbmdcIiwgKCkgPT4gcmV0LnRvU3RyaW5nKCkgKVxuXHRcdG9ialsgbmFtZSBdID0gcHJveHlcblx0fVxuXHRyZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb3BlcnR5KCBvYmosIG5hbWUsIHZhbHVlICkge1xuXHRpZiAoIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSApXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIG5hbWUsIHsgdmFsdWUgfSApXG5cdGVsc2Vcblx0XHRvYmpbIG5hbWUgXSA9IHZhbHVlXG5cdHJldHVybiB2YWx1ZVxufVxuXG4vKlxuRG9lcyBub3Qgd29yay4gd2luZG93WyBzZWNyZXQgXSBpcyBleGVjdXRlZCBiZWZvcmUsIG5vdCBhZnRlciwgY3VycmVudCBzY3JpcHQgd2lsbCBmaW5pc2guXG4qL1xuXG4vL1xuLy8gd2luZG93WyBzZWNyZXQgXSA9ICgpID0+IHtcbi8vIFx0ZGVsZXRlIHdpbmRvd1sgc2VjcmV0IF1cbi8vIFx0bGV0IHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBzZWNyZXQgKVxuLy8gXHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0IClcbi8vIFx0Y29uc29sZS5sb2coIDk4NzY1LCBxdWV1ZS5sZW5ndGggKVxuLy8gXHRwcm9jZXNzUXVldWUoKVxuLy8gXHRjb25zb2xlLmxvZyggOTg3NjUsIHF1ZXVlLmxlbmd0aCApXG4vLyB9XG5cbi8vIGxldCBjb2RlID0gYHdpbmRvd1sgXCIkeyBzZWNyZXQgfVwiIF0oKWBcblxuLy8gaWYgKCBkb2N1bWVudC5ib2R5ICkge1xuLy8gXHRsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApXG4vLyBcdHNjcmlwdC5pZCA9IHNlY3JldFxuLy8gXHRzY3JpcHQuaW5uZXJIVE1MID0gY29kZVxuLy8gXHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBzY3JpcHQgKVxuLy8gfVxuLy8gZWxzZVxuLy8gXHRkb2N1bWVudC53cml0ZSggYDxzY3JpcHQgaWQgPSBcIiR7IHNlY3JldCB9MVwiID4keyBjb2RlIH08L3NjcmlwdD5gIClcblxuLy8gY29uc29sZS5sb2coIDU0MzIxLCBxdWV1ZS5sZW5ndGggKVxuIiwibGV0IGxhdGVyID0gcmVxdWlyZSggYGxhdGVyYCApXG5sZXQgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSggYGV2ZW50c2AgKS5FdmVudEVtaXR0ZXJcblxubGV0IGNvID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlclxuXG5sZXQgdGhyZWFkQ2F0Y2hlciA9IG51bGxcblxuZXhwb3J0cy5jYiA9IG51bGxcbmV4cG9ydHMuZ2xvYmFsID0gbnVsbFxuXG5sZXQgaWQgPSB2YWx1ZSA9PiB2YWx1ZVxuXG5leHBvcnRzLmdvID0gKCBmdW4sIC4uLmFyZ3MgKSA9PiB7XG5cdGlmICggdHlwZW9mIGZ1biA9PSBgZnVuY3Rpb25gIClcblx0XHRmdW4gPSBmdW4uYXBwbHkoIG51bGwsIGFyZ3MgKVxuXHRpZiAoICFmdW4ubmV4dCApIHtcblx0XHRsZXQgdmFsdWUgPSBmdW5cblx0XHRmdW4gPSB7XG5cdFx0XHRuZXh0KCkge1xuXHRcdFx0XHRsZXQgcmV0ID0geyB2YWx1ZSwgZG9uZTogIXZhbHVlIH1cblx0XHRcdFx0dmFsdWUgPSBudWxsXG5cdFx0XHRcdHJldHVybiByZXRcblx0XHRcdH0sXG5cdFx0fVxuXHR9XG5cdHJldHVybiBuZXcgVGhyZWFkKCBmdW4gKVxufVxuXG5leHBvcnRzLmdvY2FsbCA9ICggZnVuLCBjb250ZXh0LCAuLi5hcmdzICkgPT5cblx0bmV3IFRocmVhZCggZnVuLmFwcGx5KCBjb250ZXh0LCBhcmdzICkgKVxuXG5leHBvcnRzLmZ1bmMgPSBmdW5jdGlvbiAoIGZ1biApIHtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID49IDIgKVxuXHRcdGZ1biA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodC5jYWxsKCBhcmd1bWVudHMsICggZywgZiApID0+IGYoIGcgKSApXG5cdHJldHVybiBmdW5jdGlvbiBwcm9jKCkge1xuXHRcdHJldHVybiBuZXcgVGhyZWFkKCBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIClcblx0fVxufVxuXG5leHBvcnRzLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICggZnVuICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gcHJvYygpIHtcblx0XHRsZXQgcmV0ID0gbmV3IFRocmVhZCggZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApXG5cdFx0cmV0LndhaXRGb3JJbnB1dCgpXG5cdFx0cmV0dXJuIHJldFxuXHR9XG59XG5cbi8vIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBlcnJvciwgdGhlIHNlY29uZCBvbmUgaXMgYSByZXN1bHRcbmV4cG9ydHMuY2JmdW5jID0gZnVuV2l0aENCID0+IGZ1bmN0aW9uICggLi4uYXJncyApIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+XG5cdFx0ZnVuV2l0aENCLmNhbGwoIHRoaXMsIC4uLmFyZ3MsICggZXJyb3IsIHZhbHVlICkgPT4ge1xuXHRcdFx0aWYgKCBlcnJvciAhPSBudWxsIClcblx0XHRcdFx0cmVqZWN0KCBlcnJvciApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlc29sdmUoIHZhbHVlIClcblx0XHR9IClcblx0KVxufVxuXG5leHBvcnRzLmNhdGNoVGhyZWFkcyA9ICggY2IsIG9uVGhyZWFkICkgPT4ge1xuXHRsZXQgb2xkQ2F0Y2hlciA9IHRocmVhZENhdGNoZXJcblx0dGhyZWFkQ2F0Y2hlciA9IG9uVGhyZWFkXG5cdHRyeSB7XG5cdFx0cmV0dXJuIGNiKClcblx0fVxuXHRmaW5hbGx5IHtcblx0XHR0aHJlYWRDYXRjaGVyID0gb2xkQ2F0Y2hlclxuXHR9XG59XG5cbmV4cG9ydHMucmVjZWl2ZSA9ICggZW1pdHRlciwgZXZlbnRzICkgPT4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRsZXQgaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0bGV0IHRpbWVyXG5cdGxldCByZWplY3RlciA9IGNvLmRlZmVyKCAoKSA9PiB7XG5cdFx0Y2xlYXIoKVxuXHRcdHJlamVjdCgpXG5cdH0gKVxuXHRmb3IgKCBsZXQgZXZlbnQgaW4gZXZlbnRzICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGV2ZW50cywgZXZlbnQgKSApIHtcblx0XHRsZXQgcHJlZGljYXRlID0gZXZlbnRzWyBldmVudCBdXG5cdFx0aWYgKCBwcmVkaWNhdGUgPT0gbnVsbCApXG5cdFx0XHQvL1xuXHRcdFx0Ly8gYWxsb3cgc2ltcGxlciBldmVudHMgZGVmaW5pbmcgbGlrZVxuXHRcdFx0Ly9cblx0XHRcdC8vIHlpZWxkIGNvLnJlY2VpdmUoIG9iaiwgeyBkYXRhOiB0cnVlLCB0aW1lb3V0OiBnZXRUaW1lb3V0KCAuLi4gKSB9IClcblx0XHRcdC8vXG5cdFx0XHQvLyBpbnN0ZWFkIG9mXG5cdFx0XHQvL1xuXHRcdFx0Ly8gbGV0IGV2ZW50cyA9IHsgZGF0YTogdHJ1ZSB9XG5cdFx0XHQvLyBpZiAoIGdldFRpbWVvdXQoIC4uLiApICE9IG51bGwgKSBldmVudHMudGltZW91dCA9IGdldFRpbWVvdXQoIC4uLiApXG5cdFx0XHQvLyB5aWVsZCBjby5yZWNlaXZlKCBvYmosIGV2ZW50cyApXG5cdFx0XHQvL1xuXHRcdFx0Y29udGludWVcblx0XHRpZiAoIGV2ZW50ID09IGB0aW1lb3V0YCApXG5cdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoICgpID0+IGRvbmUoIGB0aW1lb3V0YCwgbnVsbCApLCBwcmVkaWNhdGUgKVxuXHRcdGVsc2Vcblx0XHRcdGVtaXR0ZXIuYWRkTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyc1sgZXZlbnQgXSA9IGRhdGEgPT4ge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBwcmVkaWNhdGUgIT0gYGZ1bmN0aW9uYCB8fCBwcmVkaWNhdGUoIGRhdGEgKSApXG5cdFx0XHRcdFx0ZG9uZSggZXZlbnQsIGRhdGEgKVxuXHRcdFx0fSApXG5cdH1cblx0ZnVuY3Rpb24gY2xlYXIoKSB7XG5cdFx0aWYgKCAhaGFuZGxlcnMgKVxuXHRcdFx0cmV0dXJuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aW1lciApXG5cdFx0Zm9yICggbGV0IGV2ZW50IGluIGhhbmRsZXJzIClcblx0XHRcdGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyc1sgZXZlbnQgXSApXG5cdFx0cmVqZWN0ZXIuY2xvc2UoKVxuXHRcdGhhbmRsZXJzID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGRvbmUoIGV2ZW50LCBkYXRhICkge1xuXHRcdGNsZWFyKClcblx0XHRyZXNvbHZlKCB7IGV2ZW50LCBkYXRhIH0gKVxuXHR9XG59IClcblxubGV0IG5vb3B0aGVuID0geyB0aGVuKCkge30gfVxuZXhwb3J0cy53YWl0ID0gKCkgPT4gbm9vcHRoZW5cblxuZXhwb3J0cy5zbGVlcCA9IG1pbGxpc2Vjb25kcyA9PiAoIHsgdGhlbjogcmVzb2x2ZSA9PiB7XG5cdGxldCB0aW1lciA9IHNldFRpbWVvdXQoIHJlc29sdmUsIG1pbGxpc2Vjb25kcyApXG5cdHJldHVybiB7IGtpbGwoKSB7IGNsZWFyVGltb3V0KCB0aW1lciApIH0gfVxufSB9IClcblxuZXhwb3J0cy50aWNrID0gZXhwb3J0cy5zbGVlcCggMSApXG5cbmV4cG9ydHMudGltZW91dCA9IG1pbGxpc2Vjb25kcyA9PiAoIHsgdGhlbjogKCBfLCByZWplY3QgKSA9PiB7XG5cdGxldCB0aW1lciA9IHNldFRpbWVvdXQoIHJlamVjdCwgbWlsbGlzZWNvbmRzIClcblx0cmV0dXJuIHsga2lsbCgpIHsgY2xlYXJUaW1vdXQoIHRpbWVyICkgfSB9XG59IH0gKVxuXG5leHBvcnRzLnByb21pc2UgPSB2YWx1ZSA9PiBQcm9taXNlLmFsbCggWyBjby5nbyggZnVuY3Rpb24qICgpIHtcblx0eWllbGQgdmFsdWVcbn0gKSBdIClcblxuZXhwb3J0cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB7IHRoZW46IHJlc29sdmUgPT4ge1xuXHRpZiAoIHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PSBgZnVuY3Rpb25gICkge1xuXHRcdGxldCBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggcmVzb2x2ZSApXG5cdFx0cmV0dXJuIHsga2lsbCgpIHsgY2FuY2VsQW5pbWF0aW9uRnJhbWUoIHRpbWVyICkgfSB9XG5cdH1cblx0ZWxzZVxuXHRcdHJldHVybiBleHBvcnRzLnNsZWVwKCAxICkudGhlbiggcmVzb2x2ZSApXG59IH1cblxubGV0IHJldGhyb3cgPSBlID0+IHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZSB9LCAxIClcblxuZnVuY3Rpb24gaXRlcmF0b3JGYWlsZWQoIGVycm9yICkge1xuXHRyZXR1cm4geyBkb25lOiB0cnVlLCBpdGVyYXRvckZhaWxlZDogdHJ1ZSwgdmFsdWU6IGVycm9yIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JOZXh0KCBpdGVyYXRvciwgcmVzdWx0ICkge1xuXHR0cnkge1xuXHRcdHJldHVybiBpdGVyYXRvci5uZXh0KCByZXN1bHQgKVxuXHR9XG5cdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0cmV0dXJuIGl0ZXJhdG9yRmFpbGVkKCBlcnJvciApXG5cdH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JUaHJvdyggaXRlcmF0b3IsIHJlc3VsdCApIHtcblx0aWYgKCAhaXRlcmF0b3IudGhyb3cgKVxuXHRcdHJldHVybiBpdGVyYXRvckZhaWxlZCggcmVzdWx0IClcblx0dHJ5IHtcblx0XHRyZXR1cm4gaXRlcmF0b3IudGhyb3coIHJlc3VsdCApXG5cdH1cblx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRyZXR1cm4gaXRlcmF0b3JGYWlsZWQoIGVycm9yIClcblx0fVxufVxuXG5jb25zdCBET05FID0geyBkb25lOiB0cnVlIH1cblxuY2xhc3MgRUtpbGwgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKCBtZXNzYWdlID0gYGtpbGxgICkge1xuXHRcdHN1cGVyKCBtZXNzYWdlIClcblx0fVxufVxuZXhwb3J0cy5FS2lsbCA9IEVLaWxsXG5cbmZ1bmN0aW9uIGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciApIHtcblx0aWYgKCBpdGVyYXRvci5yZXR1cm4gKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGl0ZXJhdG9yLnJldHVybigpXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gaXRlcmF0b3JGYWlsZWQoIGVycm9yIClcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIGl0ZXJhdG9yLnRocm93ICkge1xuXHRcdGxldCBlID0gbmV3IEVLaWxsXG5cdFx0bGV0IHYgPSBpdGVyYXRvclRocm93KCBpdGVyYXRvciwgZSApXG5cdFx0aWYgKCAhdi5kb25lIHx8ICF2Lml0ZXJhdG9yRmFpbGVkIClcblx0XHRcdHJldGhyb3coIG5ldyBFcnJvciggYHRocmVhZCBoYXMgZWF0ZW4gRUtpbGxgICkgKVxuXHRcdGVsc2UgaWYgKCB2LnZhbHVlICE9IGUgKVxuXHRcdFx0cmV0dXJuIHZcblx0fVxuXHRyZXR1cm4gRE9ORVxufVxuXG5mdW5jdGlvbiBpdGVyYXRvckNoZWNrKCByZXQgKSB7XG5cdGlmICggcmV0ICYmIHJldC5kb25lICYmIHJldC5pdGVyYXRvckZhaWxlZCApXG5cdFx0dGhyb3cgcmV0LnZhbHVlXG5cdGVsc2Vcblx0XHRyZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGtpbGxJdGVyYXRvciggaXRlcmF0b3IgKSB7XG5cdGlmICggaXRlcmF0b3IgKSB7XG5cdFx0bGV0IHJlcyA9IGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciApXG5cdFx0aWYgKCByZXMuZG9uZSAmJiByZXMuaXRlcmF0b3JGYWlsZWQgKVxuXHRcdFx0cmV0aHJvdyggcmVzLnZhbHVlIClcblx0fVxufVxuXG4vLyBUaHJlYWRcblxubGV0IF9wcml2YXRlID0geyB3cml0YWJsZTogdHJ1ZSB9XG5sZXQgbm90RW51bWVyYWJsZSA9IHsgZW51bWVyYWJsZTogZmFsc2UgfVxuXG5sZXQgY2F0Y2hEZWZlciA9IGZ1bmMgPT4ge1xuXHQvLyBvcHRpbWl6YXRpb24gLS0gdXNpbmcgdHJ5L2NhdGNoIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uXG5cdHRyeSB7XG5cdFx0cmV0dXJuIGZ1bmMoKVxuXHR9XG5cdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0cmV0dXJuIHsgbmV4dDogKCkgPT4gaXRlcmF0b3JGYWlsZWQoIGVycm9yICkgfVxuXHR9XG59XG5cbmNsYXNzIEl0ZXJhdG9yUHJveHkge1xuXHRjb25zdHJ1Y3RvciggaXRlcmF0b3IgKSB7XG5cdFx0aWYgKCBpdGVyYXRvciBpbnN0YW5jZW9mIEl0ZXJhdG9yUHJveHkgKVxuXHRcdFx0cmV0dXJuIGl0ZXJhdG9yXG5cdFx0dGhpcy5faXRlcmF0b3IgPSBpdGVyYXRvclxuXHRcdHRoaXMuX2RlZmVycmVkID0gbnVsbFxuXHRcdHRoaXMuX3Jlc3VsdCA9IG51bGxcblx0fVxuXHRkZWZlciggcHJvYyApIHtcblx0XHRpZiAoIHR5cGVvZiBwcm9jICE9IGBmdW5jdGlvbmAgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgdHlwZSBlcnJvcjogb25seSBmdW5jdGlvbnMgY2FuIGJlIGRlZmVycmVkYCApXG5cdFx0aWYgKCAhdGhpcy5fZGVmZXJyZWQgKVxuXHRcdFx0dGhpcy5fZGVmZXJyZWQgPSBbXVxuXHRcdHRoaXMuX2RlZmVycmVkLnB1c2goIHByb2MgKVxuXHRcdHJldHVybiB7IGNsb3NlOiAoKSA9PiB7XG5cdFx0XHRpZiAoIHRoaXMuX2RlZmVycmVkIClcblx0XHRcdFx0Zm9yICggbGV0IGkgPSB0aGlzLl9kZWZlcnJlZC5sZW5ndGggLSAxOyBpID49IDA7IC0taSApXG5cdFx0XHRcdFx0aWYgKCB0aGlzLl9kZWZlcnJlZFsgaSBdID09IHByb2MgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZlcnJlZC5zcGxpY2UoIGksIDEgKVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdH0gfVxuXHR9XG5cdHNhdmUoIHJlc3VsdCApIHtcblx0XHRpZiAoICF0aGlzLl9yZXN1bHQgKVxuXHRcdFx0dGhpcy5fcmVzdWx0ID0gcmVzdWx0XG5cdFx0ZWxzZSBpZiAoIHJlc3VsdC5pdGVyYXRvckZhaWxlZCApIHtcblx0XHRcdGlmICggdGhpcy5fcmVzdWx0Lml0ZXJhdG9yRmFpbGVkIClcblx0XHRcdFx0cmV0aHJvdyggdGhpcy5fcmVzdWx0LnZhbHVlIClcblx0XHRcdHRoaXMuX3Jlc3VsdCA9IHJlc3VsdFxuXHRcdH1cblx0fVxuXHRjYWxsKCBwcm9jLCB2YWx1ZSApIHtcblx0XHRsZXQgb2xkID0gSXRlcmF0b3JQcm94eS5faXRlcmF0b3Jcblx0XHRJdGVyYXRvclByb3h5Ll9pdGVyYXRvciA9IHRoaXNcblx0XHR0cnkge1xuXHRcdFx0c3RhcnQ6IGZvciAoOzspIHtcblx0XHRcdFx0bGV0IHJldCA9IHByb2MoIHRoaXMuX2l0ZXJhdG9yLCB2YWx1ZSApXG5cdFx0XHRcdGlmICggIXJldC5kb25lIClcblx0XHRcdFx0XHRyZXR1cm4gcmV0XG5cdFx0XHRcdHRoaXMuX2l0ZXJhdG9yID0gbnVsbFxuXHRcdFx0XHRpZiAoICF0aGlzLl9kZWZlcnJlZCApXG5cdFx0XHRcdFx0cmV0dXJuIHJldFxuXHRcdFx0XHR0aGlzLnNhdmUoIHJldCApXG5cdFx0XHRcdHdoaWxlICggdGhpcy5fZGVmZXJyZWQubGVuZ3RoICkge1xuXHRcdFx0XHRcdGxldCBkZWYgPSBjYXRjaERlZmVyKCB0aGlzLl9kZWZlcnJlZC5wb3AoKSApXG5cdFx0XHRcdFx0aWYgKCBkZWYgPT0gbnVsbCB8fCB0eXBlb2YgZGVmLm5leHQgIT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdHRoaXMuX2l0ZXJhdG9yID0gZGVmXG5cdFx0XHRcdFx0dmFsdWUgPSB1bmRlZmluZWRcblx0XHRcdFx0XHRwcm9jID0gaXRlcmF0b3JOZXh0XG5cdFx0XHRcdFx0Y29udGludWUgc3RhcnRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXQgPSB0aGlzLl9yZXN1bHRcblx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gbnVsbFxuXHRcdFx0XHRyZXR1cm4gcmV0XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0SXRlcmF0b3JQcm94eS5faXRlcmF0b3IgPSBvbGRcblx0XHR9XG5cdH1cblx0bmV4dCggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGl0ZXJhdG9yQ2hlY2soIHRoaXMuY2FsbCggaXRlcmF0b3JOZXh0LCB2YWx1ZSApIClcblx0fVxuXHR0aHJvdyggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGl0ZXJhdG9yQ2hlY2soIHRoaXMuY2FsbCggaXRlcmF0b3JUaHJvdywgdmFsdWUgKSApXG5cdH1cblx0cmV0dXJuKCB2YWx1ZSApIHtcblx0XHRpZiAoICF0aGlzLl9pdGVyYXRvciApXG5cdFx0XHRyZXR1cm5cblx0XHR0aGlzLnNhdmUoIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0gKVxuXHRcdGxldCBvbGQgPSBJdGVyYXRvclByb3h5Ll9pdGVyYXRvclxuXHRcdEl0ZXJhdG9yUHJveHkuX2l0ZXJhdG9yID0gdGhpc1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgcmV0ID0gaXRlcmF0b3JSZXR1cm4oIHRoaXMuX2l0ZXJhdG9yIClcblx0XHRcdHRoaXMuX2l0ZXJhdG9yID0gbnVsbFxuXHRcdFx0aWYgKCAhdGhpcy5kZWZlcnJlZCApIHtcblx0XHRcdFx0aXRlcmF0b3JDaGVjayggcmV0IClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNhdmUoIHJldCApXG5cdFx0XHR3aGlsZSAoIHRoaXMuX2RlZmVycmVkLmxlbmd0aCApIHtcblx0XHRcdFx0bGV0IGRlZiA9IGNhdGNoRGVmZXIoIHRoaXMuX2RlZmVycmVkLnBvcCgpIClcblx0XHRcdFx0aWYgKCBkZWYgIT0gbnVsbCAmJiB0eXBlb2YgZGVmLm5leHQgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdFx0XHRsZXQgcmV0ID0gaXRlcmF0b3JOZXh0KCBkZWYgKVxuXHRcdFx0XHRcdGlmICggIXJldC5kb25lIClcblx0XHRcdFx0XHRcdHJldCA9IGl0ZXJhdG9yUmV0dXJuKCBkZWYgKVxuXHRcdFx0XHRcdHRoaXMuc2F2ZSggcmV0IClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0ID0gdGhpcy5fcmVzdWx0XG5cdFx0XHR0aGlzLl9yZXN1bHQgPSBudWxsXG5cdFx0XHRpdGVyYXRvckNoZWNrKCByZXQgKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdEl0ZXJhdG9yUHJveHkuX2l0ZXJhdG9yID0gb2xkXG5cdFx0fVxuXHR9XG59XG5JdGVyYXRvclByb3h5Ll9pdGVyYXRvciA9IG51bGxcblxuZnVuY3Rpb24qIF9JdGVyYXRvclByb3h5KCBpdGVyYXRvciApIHtcblx0bGV0IGRlZmZlcmVkID0gW11cblx0bGV0IHJldCA9IG51bGxcblx0ZnVuY3Rpb24gc2F2ZSggaXQgKSB7XG5cdFx0aWYgKCByZXQgPT0gbnVsbCB8fCBpdC5pdGVyYXRvckZhaWxlZCApIHtcblx0XHRcdGlmICggcmV0ICYmIHJldC5pdGVyYXRvckZhaWxlZCApXG5cdFx0XHRcdHJldGhyb3coIHJldC52YWx1ZSApXG5cdFx0XHRyZXQgPSBpdFxuXHRcdH1cblx0fVxuXHRsZXQgc3RlcCA9IGl0ZXJhdG9yTmV4dFxuXHRsZXQgaXQgPSBudWxsXG5cdHRyeSB7XG5cdFx0bWFpbjogd2hpbGUgKCB0cnVlICkge1xuXHRcdFx0bGV0IHlpZWxkUmVzdWx0XG5cdFx0XHRzdGVwID0gaXRlcmF0b3JOZXh0XG5cdFx0XHRpZiAoIGl0ICE9IG51bGwgKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0eWllbGRSZXN1bHQgPSB5aWVsZCBpdC52YWx1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdFx0eWllbGRSZXN1bHQgPSBlcnJvclxuXHRcdFx0XHRcdHN0ZXAgPSBpdGVyYXRvclRocm93XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0eWllbGRSZXN1bHQgPSB1bmRlZmluZWRcblx0XHRcdF9JdGVyYXRvclByb3h5LmRlZmVycmVkID0gZGVmZXJyZWRcblx0XHRcdGl0ID0gc3RlcCggaXRlcmF0b3IsIHlpZWxkUmVzdWx0IClcblx0XHRcdF9JdGVyYXRvclByb3h5LmRlZmVycmVkID0gbnVsbFxuXHRcdFx0aWYgKCAhaXQuZG9uZSApXG5cdFx0XHRcdGNvbnRpbnVlIG1haW5cblx0XHRcdHNhdmUoIGl0IClcblx0XHRcdGl0ID0gdW5kZWZpbmVkXG5cdFx0XHR3aGlsZSAoIGRlZmZlcmVkLmxlbmd0aCApIHtcblx0XHRcdFx0aXRlcmF0b3IgPSBjYXRjaERlZmVyKCBkZWZmZXJlZC5zaGlmdCgpIClcblx0XHRcdFx0aWYgKCBpdGVyYXRvciAhPSBudWxsICYmIHR5cGVvZiBpdGVyYXRvci5uZXh0ID09IGBmdW5jdGlvbmAgKVxuXHRcdFx0XHRcdGNvbnRpbnVlIG1haW5cblx0XHRcdH1cblx0XHRcdGl0ZXJhdG9yID0gbnVsbFxuXHRcdFx0YnJlYWsgbWFpblxuXHRcdH1cblx0fVxuXHRmaW5hbGx5IHtcblx0XHRpZiAoIGl0ZXJhdG9yIClcblx0XHRcdHNhdmUoIGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciApIClcblx0XHR3aGlsZSAoIGRlZmZlcmVkLmxlbmd0aCApIHtcblx0XHRcdGl0ZXJhdG9yID0gY2F0Y2hEZWZlciggZGVmZmVyZWQuc2hpZnQoKSApXG5cdFx0XHRpZiAoIGl0ZXJhdG9yICE9IG51bGwgJiYgdHlwZW9mIGl0ZXJhdG9yLm5leHQgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdFx0aXQgPSBpdGVyYXRvck5leHQoIGl0ZXJhdG9yLCB1bmRlZmluZWQgKVxuXHRcdFx0XHRpZiAoICFpdC5kb25lIClcblx0XHRcdFx0XHRpdCA9IGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciApXG5cdFx0XHRcdHNhdmUoIGl0IClcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCByZXQgKVxuXHRcdFx0aWYgKCByZXQuaXRlcmF0b3JGYWlsZWQgKVxuXHRcdFx0XHR0aHJvdyByZXQudmFsdWVcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIHJldC52YWx1ZVxuXHR9XG59XG5cbmV4cG9ydHMuZGVmZXIgPSBwcm9jID0+IHtcblx0aWYgKCAhSXRlcmF0b3JQcm94eS5faXRlcmF0b3IgKVxuXHRcdHRocm93IG5ldyBFcnJvciggYGRlZmVyOiBub3QgaW4gYSBjby10aHJlYWRgIClcblx0cmV0dXJuIEl0ZXJhdG9yUHJveHkuX2l0ZXJhdG9yLmRlZmVyKCBwcm9jIClcbn1cblxuZXhwb3J0cy5fZGVmZXIgPSBwcm9jID0+IHtcblx0aWYgKCB0eXBlb2YgcHJvYyAhPSBgZnVuY3Rpb25gIClcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGB0eXBlIGVycm9yOiBvbmx5IGZ1bmN0aW9ucyBjYW4gYmUgZGVmZXJyZWRgIClcblx0bGV0IGRlZmVycmVkID0gX0l0ZXJhdG9yUHJveHkuZGVmZXJyZWRcblx0aWYgKCBkZWZlcnJlZCApXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgZGVmZXI6IG5vdCBpbiBhIGNvLXRocmVhZGAgKVxuXHRkZWZlcnJlZC5wdXNoKCBwcm9jIClcblx0cmV0dXJuIHsgY2xvc2U6ICgpID0+IHtcblx0XHRpZiAoIGRlZmVycmVkIClcblx0XHRcdGZvciAoIGxldCBpID0gZGVmZXJyZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkgKVxuXHRcdFx0XHRpZiAoIGRlZmVycmVkWyBpIF0gPT0gcHJvYyApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5zcGxpY2UoIGksIDEgKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdH0gfVxufVxuXG5jbGFzcyBUaHJlYWQge1xuXG5cdGNvbnN0cnVjdG9yKCBpdGVyYXRvciApIHtcblx0XHR0aGlzLl9hdHRhY2hlZFRvU3RhY2sgPSB0cnVlXG5cdFx0dGhpcy5faXRlcmF0b3IgPSBuZXcgSXRlcmF0b3JQcm94eSggaXRlcmF0b3IgKVxuXHRcdHRoaXMuX3N0b3BDb3VudCA9IDBcblx0XHR0aGlzLl9zdGFjayA9IFtdXG5cdFx0dGhpcy5nbG9iYWwgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHR0aGlzLl9jdXJyZW50UHJvbWlzZSA9IG51bGxcblx0XHR0aGlzLl9ydW5uaW5nID0gZmFsc2Vcblx0XHR0aGlzLl9raWxsaW5nID0gbnVsbFxuXHRcdHRoaXMuX2NiID0gKCBlcnJvciwgZGF0YSApID0+IHtcblx0XHRcdGlmICggdGhpcy5fc3RlcCApXG5cdFx0XHRcdGlmICggZXJyb3IgKVxuXHRcdFx0XHRcdHRoaXMuX3N0ZXAuZmFpbCggZXJyb3IgKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dGhpcy5fc3RlcC5uZXh0KCBkYXRhIClcblx0XHR9XG5cdFx0dGhpcy4kbmFtZSA9IHsgdG9TdHJpbmc6ICgpID0+IGA8VGhyZWFkPmAgfVxuXG5cdFx0dGhpcy5fbmV3U3RlcCgpXG5cdFx0dGhpcy5fc3RhcnQgPSAoKSA9PiB7XG5cdFx0XHRpZiAoIHRoaXMuX3N0YXJ0ICYmIHRoaXMuX3N0ZXAgJiYgdGhpcy5fc3RlcC5uZXh0ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuX3N0b3BDb3VudCA+IDAgKVxuXHRcdFx0XHRcdHRoaXMuX3N0ZXAucmVzdW1lID0gdGhpcy5fc3RhcnRcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnQgPSBudWxsXG5cdFx0XHRcdFx0dGhpcy5fc3RlcC5uZXh0KClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cdFx0XHR0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZVxuXHRcdFx0dGhpcy5fcmVqZWN0ID0gcmVqZWN0XG5cdFx0fSApXG5cdFx0aWYgKCAhdGhpcy5fcmVzb2x2ZSApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBhc3NlcnRpb24gZmFpbHVyZTogd3JvbmcgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZWAgKVxuXG5cdFx0bGF0ZXIudGhlbiggdGhpcy5fc3RhcnQgKVxuXHRcdGlmICggdGhyZWFkQ2F0Y2hlciApXG5cdFx0XHR0aHJlYWRDYXRjaGVyKCB0aGlzIClcblxuXHRcdGV4cG9ydHMuZW1pdCggYHN0YXJ0YCwgdGhpcyApXG5cdH1cblxuXHRsaW5rTmFtZSggdmFsdWUsIHN1ZmZpeCA9IGA6dGhyZWFkYCApIHtcblx0XHRpZiAoIHZhbHVlLiRuYW1lIClcblx0XHRcdHZhbHVlID0gdmFsdWUuJG5hbWVcblx0XHR0aGlzLiRuYW1lLnRvU3RyaW5nID0gKCkgPT4gYGAgKyB2YWx1ZSArIHN1ZmZpeFxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHR3YWl0Rm9ySW5wdXQoKSB7XG5cdFx0dGhpcy5fY2hlY2tGaW5pc2hlZCgpXG5cdFx0aWYgKCB0aGlzLl9zdG9wQ291bnQgPiAwIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHRocmVhZCBpcyBwYXVzZWRgIClcblx0XHRpZiAoIHRoaXMuX3N0YXJ0IClcblx0XHRcdHRoaXMuX3N0YXJ0KClcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0X2F0dGFjaFByb21pc2UoIHByb21pc2UgKSB7XG5cdFx0cHJvbWlzZS5raWxsID0gdGhpcy5raWxsLmJpbmQoIHRoaXMgKVxuXHRcdHJldHVybiBwcm9taXNlXG5cdH1cblxuXHR0aGVuKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCApIHtcblx0XHR0aGlzLl9hdHRhY2hlZFRvU3RhY2sgPSBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9hdHRhY2hQcm9taXNlKCB0aGlzLl9wcm9taXNlLnRoZW4oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkICkgKVxuXHR9XG5cblx0Y2F0Y2goIG9uUmVqZWN0ZWQgKSB7XG5cdFx0dGhpcy5fYXR0YWNoZWRUb1N0YWNrID0gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fYXR0YWNoUHJvbWlzZSggdGhpcy5fcHJvbWlzZS5jYXRjaCggb25SZWplY3RlZCApIClcblx0fVxuXG5cdGlzRmluaXNoZWQoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9zdGVwIHx8IHRoaXMuX2tpbGxpbmdcblx0fVxuXG5cdGlzUGF1c2VkKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdG9wQ291bnQgPiAwXG5cdH1cblxuXHR0aHJvdyggZXhjZXB0aW9uICkge1xuXHRcdGlmICggdGhpcy5nbG9iYWwgPT0gZXhwb3J0cy5nbG9iYWwgKVxuXHRcdFx0dGhyb3cgZXhjZXB0aW9uXG5cdFx0dGhpcy5fY2hlY2tGaW5pc2hlZCgpXG5cdFx0dGhpcy5fbmV3U3RlcCgpXG5cdFx0aWYgKCB0aGlzLl9zdG9wQ291bnQgPiAwIClcblx0XHRcdHRoaXMuX3N0ZXAucmVzdW1lID0gdGhpcy5fc3RlcC5mYWlsLmJpbmQoIHRoaXMuX3N0ZXAsIGV4Y2VwdGlvbiApXG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5fc3RlcC5mYWlsKCBleGNlcHRpb24gKVxuXHR9XG5cblx0YXR0YWNoVG9TdGFjaygpIHtcblx0XHR0aGlzLl9hdHRhY2hlZFRvU3RhY2sgPSB0cnVlXG5cdH1cblxuXHRraWxsKCByZWFzb24gKSB7XG5cdFx0aWYgKCB0aGlzLmlzRmluaXNoZWQoKSApXG5cdFx0XHRyZXR1cm5cblx0XHR0aGlzLl9yZWplY3QoIHJlYXNvbiApXG5cdFx0aWYgKCB0aGlzLl9ydW5uaW5nICkge1xuXHRcdFx0dGhpcy5fa2lsbGluZyA9IHsgcmVhc29uIH1cblx0XHRcdHRocm93IG5ldyBFS2lsbFxuXHRcdH1cblx0XHRsZXQgcHJldmlvdXNUaHJlYWQgPSBleHBvcnRzLmN1cnJlbnRcblx0XHRsZXQgcHJldmlvc0NCID0gZXhwb3J0cy5jYlxuXHRcdGxldCBwcmV2aW9zR2xvYmFsID0gZXhwb3J0cy5nbG9iYWxcblx0XHRleHBvcnRzLmNiID0gdGhpcy5fY2Jcblx0XHRleHBvcnRzLmdsb2JhbCA9IHRoaXMuZ2xvYmFsXG5cdFx0ZXhwb3J0cy5jdXJyZW50ID0gdGhpc1xuXHRcdGtpbGxJdGVyYXRvciggdGhpcy5faXRlcmF0b3IgKVxuXHRcdGZvciAoIGxldCBhID0gdGhpcy5fc3RhY2ssIGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pIClcblx0XHRcdGtpbGxJdGVyYXRvciggYVsgaSBdIClcblx0XHRleHBvcnRzLmNiID0gcHJldmlvc0NCXG5cdFx0ZXhwb3J0cy5nbG9iYWwgPSBwcmV2aW9zR2xvYmFsXG5cdFx0ZXhwb3J0cy5jdXJyZW50ID0gcHJldmlvdXNUaHJlYWRcblx0XHRpZiAoIHRoaXMuX2N1cnJlbnRQcm9taXNlICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fY3VycmVudFByb21pc2Uua2lsbCggcmVhc29uIClcblx0XHRcdH1cblx0XHRcdGNhdGNoICggZSApIHtcblx0XHRcdFx0cmV0aHJvdyggZSApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2RvbmUoKVxuXHR9XG5cblx0cGF1c2UoKSB7XG5cdFx0dGhpcy5fY2hlY2tGaW5pc2hlZCgpXG5cdFx0Kyt0aGlzLl9zdG9wQ291bnRcblx0fVxuXG5cdHJlc3VtZSgpIHtcblx0XHRpZiAoIHRoaXMuX3N0b3BDb3VudCA9PSAwIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHRocmVhZCBub3QgcGF1c2VkYCApXG5cdFx0aWYgKCAwID09IC0tdGhpcy5fc3RvcENvdW50ICYmIHRoaXMuX3N0ZXAgJiYgdGhpcy5fc3RlcC5yZXN1bWUgKSB7XG5cdFx0XHRsYXRlci50aGVuKCB0aGlzLl9zdGVwLnJlc3VtZSApXG5cdFx0XHR0aGlzLl9zdGVwLnJlc3VtZSA9IG51bGxcblx0XHR9XG5cdH1cblxuXHRfdGljayggc3RlcCwgaW1ldGhvZCwgcmVzdWx0ICkge1xuXHRcdGlmICggdGhpcy5kZWJ1Z2dlciB8fCBzdGVwLmRlYnVnZ2VyIClcblx0XHRcdGRlYnVnZ2VyXG5cdFx0aWYgKCB0aGlzLl9ydW5uaW5nIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJGQVRBTDogcmVlbnRlcmluZyB0aHJlYWQgdGlja1wiIClcblx0XHRpZiAoIHN0ZXAgIT09IHRoaXMuX3N0ZXAgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCB0aGlzLl9zdG9wQ291bnQgPiAwICkge1xuXHRcdFx0c3RlcC5yZXN1bWUgPSB0aGlzLl90aWNrLmJpbmQoIHRoaXMsIHN0ZXAsIGltZXRob2QsIHJlc3VsdCApXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0dGhpcy5fY3VycmVudFByb21pc2UgPSBudWxsXG5cdFx0XHR0aGlzLl9ydW5uaW5nID0gdHJ1ZVxuXHRcdFx0bGV0IHByZXZpb3VzVGhyZWFkID0gZXhwb3J0cy5jdXJyZW50XG5cdFx0XHRsZXQgcHJldmlvc0NCID0gZXhwb3J0cy5jYlxuXHRcdFx0bGV0IHByZXZpb3NHbG9iYWwgPSBleHBvcnRzLmdsb2JhbFxuXHRcdFx0ZXhwb3J0cy5jYiA9IHRoaXMuX2NiXG5cdFx0XHRleHBvcnRzLmdsb2JhbCA9IHRoaXMuZ2xvYmFsXG5cdFx0XHRleHBvcnRzLmN1cnJlbnQgPSB0aGlzXG5cdFx0XHRsZXQgdiA9IHRoaXMuX2l0ZXJhdG9yLmNhbGwoIGltZXRob2QsIHJlc3VsdCApXG5cdFx0XHRleHBvcnRzLmNiID0gcHJldmlvc0NCXG5cdFx0XHRleHBvcnRzLmdsb2JhbCA9IHByZXZpb3NHbG9iYWxcblx0XHRcdGV4cG9ydHMuY3VycmVudCA9IHByZXZpb3VzVGhyZWFkXG5cdFx0XHR0aGlzLl9ydW5uaW5nID0gZmFsc2Vcblx0XHRcdGlmICggdGhpcy5kZWJ1Z2dlciB8fCBzdGVwLmRlYnVnZ2VyIClcblx0XHRcdFx0ZGVidWdnZXJcblx0XHRcdGlmICggdGhpcy5fa2lsbGluZyApIHtcblx0XHRcdFx0bGV0IHJlYXNvbiA9IHRoaXMuX2tpbGxpbmcucmVhc29uXG5cdFx0XHRcdHRoaXMuX2tpbGxpbmcgPSBudWxsXG5cdFx0XHRcdHRoaXMua2lsbCggcmVhc29uIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAoIHYuZG9uZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmlzRmluaXNoZWQoKSApXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGlmICggdGhpcy5faXRlcmF0b3IgPSB0aGlzLl9zdGFjay5wb3AoKSApIHtcblx0XHRcdFx0XHRpbWV0aG9kID0gdi5pdGVyYXRvckZhaWxlZCA/IGl0ZXJhdG9yVGhyb3cgOiBpdGVyYXRvck5leHRcblx0XHRcdFx0XHRyZXN1bHQgPSB2LnZhbHVlXG5cdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgciA9IHYuaXRlcmF0b3JGYWlsZWQgPyB0aGlzLl9yZWplY3QgOiB0aGlzLl9yZXNvbHZlXG5cdFx0XHRcdHRoaXMuX2RvbmUoKVxuXHRcdFx0XHRpZiAoIHYuaXRlcmF0b3JGYWlsZWQgJiYgdGhpcy5fYXR0YWNoZWRUb1N0YWNrIClcblx0XHRcdFx0XHRyZXRocm93KCB2LnZhbHVlIClcblx0XHRcdFx0ciggdi52YWx1ZSApXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggIXYudmFsdWUgKSAvLyBhbnkgZmFsc3kgdmFsdWVcblx0XHRcdFx0ZXhwb3J0cy50aWNrLnRoZW4oIHN0ZXAubmV4dCApXG5cdFx0XHRlbHNlIGlmICggdi52YWx1ZS50aGVuICkge1xuXHRcdFx0XHRsZXQgcCA9IHYudmFsdWUudGhlbiggc3RlcC5uZXh0LCBzdGVwLmZhaWwgKVxuXHRcdFx0XHRpZiAoIHAgJiYgcC5raWxsIClcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50UHJvbWlzZSA9IHBcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB2LnZhbHVlLm5leHQgKSB7XG5cdFx0XHRcdHRoaXMuX3N0YWNrLnB1c2goIHRoaXMuX2l0ZXJhdG9yIClcblx0XHRcdFx0dGhpcy5faXRlcmF0b3IgPSBuZXcgSXRlcmF0b3JQcm94eSggdi52YWx1ZSApXG5cdFx0XHRcdGltZXRob2QgPSBpdGVyYXRvck5leHRcblx0XHRcdFx0cmVzdWx0ID0gdW5kZWZpbmVkXG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggYG9ubG9hZGAgaW4gdi52YWx1ZSAmJiAhdi52YWx1ZS5vbmxvYWQgJiYgYG9uZXJyb3JgIGluIHYudmFsdWUgJiYgIXYudmFsdWUub25lcnJvciApIHtcblx0XHRcdFx0di52YWx1ZS5vbmxvYWQgPSBzdGVwLm5leHRcblx0XHRcdFx0di52YWx1ZS5vbmVycm9yID0gc3RlcC5mYWlsXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggYG9uc3VjY2Vzc2AgaW4gdi52YWx1ZSAmJiAhdi52YWx1ZS5vbmxvYWQgJiYgYG9uZXJyb3JgIGluIHYudmFsdWUgJiYgIXYudmFsdWUub25lcnJvciApIHtcblx0XHRcdFx0aWYgKCAhc3RlcC5zdWNjZXNzX2Vycm9yIClcblx0XHRcdFx0XHRzdGVwLnN1Y2Nlc3NfZXJyb3IgPSB7XG5cdFx0XHRcdFx0XHRvbnN1Y2Nlc3MoIGV2ZW50ICkgeyBzdGVwLm5leHQoIGV2ZW50LnRhcmdldC5yZXN1bHQgKSB9LFxuXHRcdFx0XHRcdFx0b25lcnJvciggZXZlbnQgKSB7IHN0ZXAuZmFpbCggZXZlbnQudGFyZ2V0LmVycm9yIHx8IGV2ZW50ICkgfSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdHYudmFsdWUub25zdWNjZXNzID0gc3RlcC5zdWNjZXNzX2Vycm9yLm9uc3VjY2Vzc1xuXHRcdFx0XHR2LnZhbHVlLm9uZXJyb3IgPSBzdGVwLnN1Y2Nlc3NfZXJyb3Iub25lcnJvclxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGB0aHJlYWQgdHlwZSBlcnJvcmAgKVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblxuXHRfZG9uZSgpIHtcblx0XHR0aGlzLl9zdGVwID0gbnVsbFxuXHRcdHRoaXMuX2l0ZXJhdG9yID0gbnVsbFxuXHRcdHRoaXMuX3N0YWNrID0gbnVsbFxuXHRcdHRoaXMuX3Jlc29sdmUgPSBudWxsXG5cdFx0dGhpcy5fcmVqZWN0ID0gbnVsbFxuXHRcdHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbnVsbFxuXHRcdHRoaXMuX2tpbGxpbmcgPSBudWxsXG5cdH1cblxuXHRfbmV3U3RlcCgpIHtcblx0XHRsZXQgc3RlcCA9IHRoaXMuX3N0ZXAgPSB7IHJlc3VtZTogbnVsbCB9XG5cdFx0c3RlcC5uZXh0ID0gdGhpcy5fdGljay5iaW5kKCB0aGlzLCBzdGVwLCBpdGVyYXRvck5leHQgKVxuXHRcdHN0ZXAuZmFpbCA9IHRoaXMuX3RpY2suYmluZCggdGhpcywgc3RlcCwgaXRlcmF0b3JUaHJvdyApXG5cdFx0bGV0ICRuYW1lID0gdGhpcy4kbmFtZVxuXHRcdHN0ZXAubmV4dC4kbmFtZSA9IHsgdG9TdHJpbmc6ICgpID0+ICRuYW1lICsgYDpuZXh0YCB9XG5cdFx0c3RlcC5mYWlsLiRuYW1lID0geyB0b1N0cmluZzogKCkgPT4gJG5hbWUgKyBgOmZhaWxgIH1cblx0fVxuXG5cdF9vblByb21pc2UoIHJlc29sdmUsIHJlamVjdCApIHtcblx0XHR0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZVxuXHRcdHRoaXMuX3JlamVjdCA9IHJlamVjdFxuXHRcdHRoaXMucmVzdW1lKClcblx0fVxuXG5cdF9jaGVja0ZpbmlzaGVkKCkge1xuXHRcdGlmICggdGhpcy5pc0ZpbmlzaGVkKCkgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgdGhyZWFkIGlzIGFscmVhZHkgZmluaXNoZWRgIClcblx0fVxuXG59XG5leHBvcnRzLlRocmVhZCA9IFRocmVhZFxuXG5PYmplY3Qua2V5cyggVGhyZWFkLnByb3RvdHlwZSApLmZvckVhY2goIGsgPT4gay5tYXRjaCggL15fLyApICYmXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggVGhyZWFkLnByb3RvdHlwZSwgaywgbm90RW51bWVyYWJsZSApIClcblxubGV0IG1haW5UaHJlYWQgPSAoIG5ldyBUaHJlYWQoIHsgbmV4dCgpIHsgcmV0dXJuIHsgdmFsdWU6IHsgdGhlbigpIHt9IH0gfSB9IH0gKSApLndhaXRGb3JJbnB1dCgpXG5leHBvcnRzLmN1cnJlbnQgPSBudWxsXG5leHBvcnRzLmdsb2JhbCA9IG1haW5UaHJlYWQuZ2xvYmFsXG5leHBvcnRzLmNiID0gbnVsbFxuIiwibGV0IGNvID0gcmVxdWlyZSggYGNvYCApXG5sZXQgcmEgPSByZXF1aXJlKCBgcmFgIClcbmxldCBsb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5cbmZ1bmN0aW9uIHRvTm9kZSggY2hpbGQsIG5vZGUgKSB7XG5cdHJlc3RhcnQ6IGZvciAoOzspIHtcblx0XHRjaGlsZCA9IGNoaWxkICYmIHR5cGVvZiBjaGlsZC52YWx1ZU9mID09IGBmdW5jdGlvbmAgPyBjaGlsZC52YWx1ZU9mKCkgOiBjaGlsZFxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggY2hpbGQgKSApIHtcblx0XHRcdGlmICggY2hpbGQubGVuZ3RoID09IDAgKVxuXHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0aWYgKCBjaGlsZC5sZW5ndGggPT0gMSApIHtcblx0XHRcdFx0Y2hpbGQgPSBjaGlsZFsgMCBdXG5cdFx0XHRcdGNvbnRpbnVlIHJlc3RhcnRcblx0XHRcdH1cblx0XHRcdGlmICggIW5vZGUgKVxuXHRcdFx0XHRub2RlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRjaGlsZC5mb3JFYWNoKCBjaGlsZCA9PiB0b05vZGUoIGNoaWxkLCBub2RlICkgKVxuXHRcdFx0Y2hpbGQgPSBub2RlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKCB0eXBlb2YgY2hpbGQgPT0gYHN0cmluZ2AgKVxuXHRcdFx0XHRjaGlsZCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBjaGlsZCApXG5cdFx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoIGNoaWxkIClcblx0XHRcdFx0Y2hpbGQgPSBub2RlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjaGlsZFxuXHR9XG59XG5cbmZ1bmN0aW9uIGZjYWxjKCBmLCBjYiApIHtcblx0aWYgKCB0eXBlb2YgZiAhPSBgZnVuY3Rpb25gIClcblx0XHRjYiggZiApXG5cdGVsc2Uge1xuXHRcdGxldCBmaXJzdCA9IHRydWVcblx0XHRyYSggZmFsc2UsIGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHRpZiAoIGZpcnN0IClcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR5aWVsZCBjby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHRcdGxldCByZXQgPSBmKClcblx0XHRcdGlmICggcmV0ICYmIHJldC5uZXh0ICYmIHJldC50aHJvdyApXG5cdFx0XHRcdHJldCA9IHlpZWxkIHJldFxuXHRcdFx0Y2IoIHJldCApXG5cdFx0fSApXG5cdH1cbn1cblxuZnVuY3Rpb24gY2hlY2tET01Db250cm9sKCBjb250cm9sICkge1xuXHRsZXQgcSA9IFtcblx0XHRjb250cm9sLm93bmVyRG9jdW1lbnQgJiYgY29udHJvbC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0Y29udHJvbC5vd25lckRvY3VtZW50ICYmIGNvbnRyb2wub3duZXJEb2N1bWVudC5ib2R5LFxuXHRcdGRvY3VtZW50LmJvZHksXG5cdF0uZmlsdGVyKCBCb29sZWFuIClcblx0bGV0IHAgPSBjb250cm9sXG5cdHdoaWxlICggcCApIHtcblx0XHRpZiAoIHEuaW5kZXhPZiggcCApID49IDAgKSB7XG5cdFx0XHRyYS5mb3JjZUNhbGN1bGF0aW9ucygpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0cCA9IHAucGFyZW50Tm9kZVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldENvbnRlbnQoIGNvbnRyb2wsIGNvbnRlbnQsIGNiID0gbnVsbCApIHsgZmNhbGMoIGNvbnRlbnQsIGNvbnRlbnQgPT4ge1xuXHRjaGVja0RPTUNvbnRyb2woIGNvbnRyb2wgKVxuXHRsZXQgYyA9IHRvTm9kZSggY29udGVudCApXG5cdGlmICggYyApIHtcblx0XHRjaGVja0RPTUNvbnRyb2woIGNvbnRyb2wgKVxuXHRcdGNvbnRyb2wuaW5uZXJIVE1MID0gYGBcblx0XHRjb250cm9sLmFwcGVuZENoaWxkKCBjIClcblx0fVxuXHRlbHNlXG5cdFx0Y29udHJvbC5pbm5lckhUTUwgPSBgYFxuXHRjYiAmJiBjYigpXG59ICkgfVxuXG5mdW5jdGlvbiB0b0F0dHJTdHJpbmcoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKVxuXHRcdHJldHVybiB2YWx1ZS5tYXAoIHRvQXR0clN0cmluZyApLmpvaW4oIGAgYCApXG5cdGVsc2UgaWYgKCB2YWx1ZSApXG5cdFx0cmV0dXJuIGAkeyB2YWx1ZSB9YFxuXHRlbHNlXG5cdFx0cmV0dXJuIGBgXG59XG5cbmZ1bmN0aW9uIGFwcGVuZENvbnRlbnQoIGNvbnRlbnQsIGYgKSB7XG5cdGlmICggIWYgKVxuXHRcdGYgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0Zm9yICggbGV0IGMgb2YgY29udGVudCApIHtcblx0XHRpZiAoIHR5cGVvZiBjID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRsZXQgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGBzcGFuYCApXG5cdFx0XHRzZXRDb250ZW50KCBwLCBjIClcblx0XHRcdGYuYXBwZW5kQ2hpbGQoIHAgKVxuXHRcdH1cblx0XHRlbHNlIGlmICggYyBpbnN0YW5jZW9mIE5vZGUgKVxuXHRcdFx0Zi5hcHBlbmRDaGlsZCggYyApXG5cdFx0ZWxzZSBpZiAoIGMgIT0gbnVsbCAmJiB0eXBlb2YgYyAhPSBgc3RyaW5nYCAmJiBjWyBTeW1ib2wuaXRlcmF0b3IgXSApXG5cdFx0XHRmb3IgKCBsZXQgY2Mgb2YgYyApXG5cdFx0XHRcdGFwcGVuZENvbnRlbnQoIGNjLCBmIClcblx0XHRlbHNlXG5cdFx0XHRmLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggYyApIClcblx0fVxuXHRyZXR1cm4gZlxufVxuXG5sZXQgRXZlbnRzID0ge1xufVxuXG5sZXQgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIGZ1bmN0aW9uKiAoKSB7fSApXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGVFbGVtZW50KCBuYW1lLCBhdHRyaWJ1dGVzLCAuLi5jb250ZW50ICkge1xuXHRcdGlmICggdHlwZW9mIG5hbWUgPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRyZXR1cm4gbmFtZSggYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLl8gPyBPYmplY3QuYXNzaWduKCB7fSwgYXR0cmlidXRlcywgYXR0cmlidXRlcy5fLCB7IF86IG51bGwgfSApIDogKCBhdHRyaWJ1dGVzIHx8IDAgKSwgYXBwZW5kQ29udGVudCggY29udGVudCApIClcblx0XHRsZXQgb25DcmVhdGVcblx0XHRsZXQgcmV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggbmFtZSApXG5cdFx0bGV0IGNsYXNzZXMgPSBbXVxuXHRcdGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyggYXR0cmlidXRlcyApIHtcblx0XHRcdGlmICggYXR0cmlidXRlcyA9PSBudWxsIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRsb2Rhc2guZm9yRWFjaCggYXR0cmlidXRlcywgKCB2YWx1ZSwgbmFtZSApID0+IHtcblx0XHRcdFx0aWYgKCBuYW1lID09IGBfYCApXG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRlbHNlIGlmICggbmFtZSA9PSBgY2xhc3NgIClcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goIHZhbHVlIClcblx0XHRcdFx0ZWxzZSBpZiAoIG5hbWUgPT0gYHN0eWxlYCApXG5cdFx0XHRcdFx0Ly8gVE9ETzogc210aCBsaWtlIHRvIFwiY2xhc3NcIiBhdHRyaWJ1dGUgLSBwYXJzZSBwYXJlbnQgc3R5bGUgYW5kIHVwZGF0ZSBpdFxuXHRcdFx0XHRcdGZjYWxjKCB2YWx1ZSwgdmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYHN0cmluZ2AgKVxuXHRcdFx0XHRcdFx0XHRyZXQuc2V0QXR0cmlidXRlKCBgc3R5bGVgLCB2YWx1ZSApXG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdGxvZGFzaC5mb3JFYWNoKCB2YWx1ZSwgKCB2YWx1ZSwgbmFtZSApID0+IGZjYWxjKCB2YWx1ZSwgdmFsdWUgPT4gcmV0LnN0eWxlWyBuYW1lIF0gPSB2YWx1ZSApIClcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0ZWxzZSBpZiAoIG5hbWUgPT0gYG9uY3JlYXRlYCApXG5cdFx0XHRcdFx0b25DcmVhdGUgPSB2YWx1ZVxuXHRcdFx0XHRlbHNlIGlmICggbmFtZS5tYXRjaCggL15vbi8gKSApIHtcblx0XHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PSBgZnVuY3Rpb25gIClcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBbIHZhbHVlIF1cblx0XHRcdFx0XHRcdGZvciAoIGxldCBoYW5kbGVyIG9mIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIE9iamVjdC5nZXRQcm90b3R5cGVPZiggaGFuZGxlciApID09IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIClcblx0XHRcdFx0XHRcdFx0XHRoYW5kbGVyID0gY28uZXZlbnRIYW5kbGVyKCBoYW5kbGVyIClcblx0XHRcdFx0XHRcdFx0XHRyZXQuYWRkRXZlbnRMaXN0ZW5lciggbmFtZS5zbGljZSggYG9uYC5sZW5ndGggKSwgaGFuZGxlciApXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRmY2FsYyggdmFsdWUsIHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdG9BdHRyU3RyaW5nKCB2YWx1ZSApXG5cdFx0XHRcdFx0XHRpZiAoIHJldC5nZXRBdHRyaWJ1dGUoIG5hbWUgKSAhPSB2YWx1ZSApXG5cdFx0XHRcdFx0XHRcdHJldC5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlIClcblx0XHRcdFx0XHR9IClcblx0XHRcdH0gKVxuXHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGF0dHJpYnV0ZXMsIGBfYCApIClcblx0XHRcdFx0YXBwbHlBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzLl8gKVxuXHRcdH1cblx0XHRhcHBseUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMgKVxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHRsZXQgY29weSA9IGNsYXNzZXMubWFwKCAoKSA9PiBudWxsIClcblx0XHRcdGNsYXNzZXMuZm9yRWFjaCggKCBjLCBpICkgPT4gZmNhbGMoIGMsIGMgPT4ge1xuXHRcdFx0XHRjb3B5WyBpIF0gPSBjXG5cdFx0XHRcdGxldCBjbGFzc05hbWUgPSB0b0F0dHJTdHJpbmcoIGNvcHkgKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCAvKF58XFxzfFxccnxcXG4pKG51bGx8dW5kZWZpbmVkfGZhbHNlfDB8XFwtMHxOYU4pKD89JHxcXHN8XFxyfFxcbikvZywgYGAgKVxuXHRcdFx0XHRpZiAoIHJldC5jbGFzc05hbWUgIT0gY2xhc3NOYW1lIClcblx0XHRcdFx0XHRyZXQuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG5cdFx0XHR9ICkgKVxuXHRcdH1cblx0XHRzd2l0Y2ggKCBjb250ZW50Lmxlbmd0aCApIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMTpcblx0XHRcdHNldENvbnRlbnQoIHJldCwgY29udGVudFsgMCBdIClcblx0XHRcdGJyZWFrXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldC5hcHBlbmRDaGlsZCggYXBwZW5kQ29udGVudCggY29udGVudCApIClcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIG9uQ3JlYXRlID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRvbkNyZWF0ZS5jYWxsKCByZXQsIHtcblx0XHRcdFx0dHlwZTogYGNyZWF0ZWAsXG5cdFx0XHRcdHRhcmdldDogcmV0LFxuXHRcdFx0XHRzcmNFbGVtZW50OiByZXQsXG5cdFx0XHRcdGN1cnJlbnRUYXJnZXQ6IHJldCxcblx0XHRcdH0gKVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH0sXG59XG5cbmxldCB1cGRhdGVJbnB1dFZhbHVlID0gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KCAoKSA9PiB0aGlzLl9yYVZhbHVlLmFzc2lnbiggdGhpcy52YWx1ZSApICkgfVxubGV0IHJhVmFsdWUgPSB7XG5cdGdldCgpIHtcblx0XHRpZiAoICF0aGlzLl9yYVZhbHVlICkgcmEuZGV0YWNoKCAoKSA9PiB7XG5cdFx0XHR0aGlzLl9yYVZhbHVlID0gcmEoKVxuXHRcdFx0dGhpcy5fcmFWYWx1ZS5hc3NpZ24oIHRoaXMudmFsdWUgKVxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBgY2hhbmdlYCwgdXBkYXRlSW5wdXRWYWx1ZSApXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGBrZXlwcmVzc2AsIHVwZGF0ZUlucHV0VmFsdWUgKVxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBga2V5ZG93bmAsIHVwZGF0ZUlucHV0VmFsdWUgKVxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBga2V5dXBgLCB1cGRhdGVJbnB1dFZhbHVlIClcblx0XHR9IClcblx0XHRyZXR1cm4gdGhpcy5fcmFWYWx1ZS52YWx1ZU9mKClcblx0fSxcblx0c2V0KCB2YWx1ZSApIHtcblx0XHRpZiAoIHRoaXMudmFsdWUgIT0gdmFsdWUgKSB7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWVcblx0XHRcdGlmICggdGhpcy5fcmFWYWx1ZSApXG5cdFx0XHRcdHRoaXMuX3JhVmFsdWUuYXNzaWduKCB0aGlzLnZhbHVlIClcblx0XHR9XG5cdH0sXG59XG5cbmZvciAoIGxldCBDIG9mIFsgSFRNTElucHV0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCBdIClcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBDLnByb3RvdHlwZSwgYHJhVmFsdWVgLCByYVZhbHVlIClcbiIsImxldCBsb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5sZXQgVUlEID0gcmVxdWlyZSggYHVpZGAgKVxubGV0IGx1ID0gcmVxdWlyZSggYGxvY2FsVXRpbHNgIClcblxuZXhwb3J0cy5DbGVhciA9IGV4cG9ydHMuVW5saW5rID0gKCBkZXZpY2VzLCBkZXZpY2VJZCApID0+IGxvZGFzaC5yZWR1Y2UoIGRldmljZXMuY29udGVudCwgKCByZXQsIHEsIGluZGV4ICkgPT4ge1xuXHRpZiAoIHEgKVxuXHRcdGlmICggaW5kZXggPT0gZGV2aWNlSWQgKVxuXHRcdFx0cmV0LmNvbnRlbnRbIGluZGV4IF0gPSBudWxsXG5cdFx0ZWxzZSBpZiAoIHEuY29udGVudCAmJiBxLmNvbnRlbnRbIGRldmljZUlkIF0gKVxuXHRcdFx0cmV0LmNvbnRlbnRbIGluZGV4IF0gPSB7IGNvbnRlbnQ6IHsgWyBkZXZpY2VJZCBdOiBudWxsIH0gfVxuXHRyZXR1cm4gcmV0XG59LCB7IGNvbnRlbnQ6IHt9IH0gKVxuXG5leHBvcnRzLlNldCA9ICggZGV2aWNlcywgZGV2aWNlSWQsIGRhdGEgKSA9PiB7XG5cdGxldCBkZXZpY2UgPSBkZXZpY2VzLmNvbnRlbnRbIGRldmljZUlkIF1cblx0aWYgKCAhZGV2aWNlIHx8ICFkZXZpY2UuZ3JvdXAgKVxuXHRcdHJldHVyblxuXHRsZXQgcmV0ID0geyBjb250ZW50OiB7IFsgZGV2aWNlSWQgXTogZGF0YSB9IH1cblx0aWYgKCBkZXZpY2UudHlwZSA9PSBgZ3JvdXBgIClcblx0XHRyZXQgPSBsb2Rhc2gucmVkdWNlKCBkZXZpY2UuY29udGVudCwgKCByZXQsIHEsIGluZGV4ICkgPT4ge1xuXHRcdFx0aWYgKCBxIClcblx0XHRcdFx0cmV0LmNvbnRlbnRbIGluZGV4IF0gPSBkYXRhXG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fSwgcmV0IClcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnRzLmZpbmRGcmVlR3JvdXAgPSBkZXZpY2VzID0+IHtcblx0bGV0IGdyb3VwcyA9IFtdXG5cdGZvciAoIGxldCBpID0gMTsgaSA8PSAxMDIyOyArK2kgKVxuXHRcdGdyb3Vwc1sgaSBdID0gaVxuXHRsb2Rhc2guZm9yRWFjaCggZGV2aWNlcy5jb250ZW50LCBkZXZpY2UgPT4gZGV2aWNlICYmIE51bWJlci5pc0Zpbml0ZSggZGV2aWNlLmdyb3VwICkgJiYgKCBncm91cHNbIGRldmljZS5ncm91cCBdID0gZmFsc2UgKSApXG5cdGdyb3VwcyA9IGdyb3Vwcy5maWx0ZXIoIEJvb2xlYW4gKVxuXHRyZXR1cm4gIWdyb3Vwcy5sZW5ndGggPyBudWxsIDogZ3JvdXBzWyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogZ3JvdXBzLmxlbmd0aCApICUgZ3JvdXBzLmxlbmd0aCBdXG59XG5cbmV4cG9ydHMuY2xlYW5EYXRhYmFzZSA9IGRldmljZXMgPT4ge1xuXHRsZXQgcmV0ID0gZGV2aWNlcyB8fCB7fVxuXHRmdW5jdGlvbiBfc2F2ZSggZGlmZiApIHtcblx0XHRyZXQgPSBsdS5hcHBseURpZmYoIHJldCwgZGlmZiApXG5cdH1cblx0ZnVuY3Rpb24gX2NoYW5nZSggcGF0aCwgdmFsdWUgKSB7XG5cdFx0X3NhdmUoIHBhdGgucmVkdWNlUmlnaHQoICggcmV0LCBrZXkgKSA9PiAoIHsgWyBrZXkgXTogcmV0IH0gKSwgdmFsdWUgKSApXG5cdH1cblx0ZnVuY3Rpb24gYXNzaWduKCAuLi5wYXRoICkge1xuXHRcdF9jaGFuZ2UoIHBhdGgsIHBhdGgucG9wKCkgKVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZSggLi4ucGF0aCApIHtcblx0XHRfY2hhbmdlKCBwYXRoLCBudWxsIClcblx0fVxuXG5cdC8vIG1vdmUgcm9vdCBpdGVtcyB0byBjb250ZW50XG5cdGlmICggIXJldC5jb250ZW50IClcblx0XHRsb2Rhc2guZm9yRWFjaCggcmV0LCAoIHBsYWNlLCBwbGFjZUlkICkgPT4ge1xuXHRcdFx0aWYgKCBwbGFjZSAhPSBudWxsICYmIHR5cGVvZiBwbGFjZSAhPSBgb2JqZWN0YCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0cmVtb3ZlKCBwbGFjZUlkIClcblx0XHRcdGFzc2lnbiggYGNvbnRlbnRgLCBwbGFjZUlkLCBwbGFjZSApXG5cdFx0fSApXG5cdGVsc2UgLy8gVE9ETyBkZWxldGUgbGF0ZXJcblx0XHRsb2Rhc2guZm9yRWFjaCggcmV0LCAoIHBsYWNlLCBwbGFjZUlkICkgPT4ge1xuXHRcdFx0aWYgKCBwbGFjZSAhPSBudWxsICYmIHR5cGVvZiBwbGFjZSAhPSBgb2JqZWN0YCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0aWYgKCBwbGFjZUlkID09IGBjb250ZW50YCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0cmVtb3ZlKCBwbGFjZUlkIClcblx0XHR9IClcblxuXHQvLyByZW1vdmUgaXRlbXMgd2l0aCB3cm9uZyB0eXBlICYgcmVtb3ZlIGdyb3VwIGZyb20gcGxhY2VzXG5cdGxvZGFzaC5mb3JFYWNoKCByZXQuY29udGVudCwgKCBwbGFjZSwgcGxhY2VJZCApID0+IHtcblx0XHRpZiAoIHBsYWNlID09IG51bGwgfHwgdHlwZW9mIHBsYWNlICE9IGBvYmplY3RgIClcblx0XHRcdHJldHVybiByZW1vdmUoIGBjb250ZW50YCwgcGxhY2VJZCAgKVxuXHRcdGlmICggcGxhY2UudHlwZSA9PSBgZGV2aWNlYCApIC8vIFRPRE86IHJlbW92ZSBsYXRlclxuXHRcdFx0YXNzaWduKCBgY29udGVudGAsIHBsYWNlSWQsIGB0eXBlYCwgYHNpbmdsZWAgKVxuXHRcdGlmICggcGxhY2UuZGV2aWNlID09IHBsYWNlSWQgKVxuXHRcdFx0cmVtb3ZlKCBgY29udGVudGAsIHBsYWNlSWQsIGBkZXZpY2VgIClcblx0XHRlbHNlIGlmICggISggcGxhY2UudHlwZSB8fCBgYCApLm1hdGNoKCAvXihwbGFjZXxncm91cHxzaW5nbGUpJC8gKSApXG5cdFx0XHRyZXR1cm4gcmVtb3ZlKCBgY29udGVudGAsIHBsYWNlSWQgKVxuXHRcdGlmICggcGxhY2UuZ3JvdXAgIT0gbnVsbCAmJiAoICFOdW1iZXIuaXNGaW5pdGUoIHBsYWNlLmdyb3VwICkgfHwgcGxhY2UudHlwZSA9PSBgcGxhY2VgICkgKVxuXHRcdFx0cmVtb3ZlKCBgY29udGVudGAsIHBsYWNlSWQsIGBncm91cGAgKVxuXHR9IClcblxuXHQvLyBjcmVhdGUgbWFpblxuXHRpZiAoIHJldCAmJiB0eXBlb2YgcmV0Lm1haW4gIT0gYHN0cmluZ2AgKSB7XG5cdFx0bGV0IG1haW4gPSBVSUQoKVxuXHRcdGxldCBpID0gMFxuXHRcdGxvZGFzaC5mb3JFYWNoKCByZXQuY29udGVudCwgKCBwbGFjZSwga2V5ICkgPT4gYXNzaWduKCBgY29udGVudGAsIG1haW4sIGBjb250ZW50YCwga2V5LCArK2kgKSApXG5cdFx0aWYgKCByZXQuY29udGVudCAmJiByZXQuY29udGVudFsgbWFpbiBdIClcblx0XHRcdGFzc2lnbiggYG1haW5gLCBtYWluIClcblx0fVxuXG5cdC8vIHJlbW92ZSBpdGVtcyB3aXRoIGR1cGxpY2F0ZSBncm91cFxuXHRsZXQgcmVhY2hhYmxlXG5cdGZ1bmN0aW9uIGdyb3VwSW5kZXgoIGtleSApIHtcblx0XHRpZiAoICFyZWFjaGFibGUgKSB7XG5cdFx0XHRyZWFjaGFibGUgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGxldCByZWFjaGFibGVLZXlzID0gW11cblx0XHRcdGZ1bmN0aW9uIHB1c2goIGtleSApIHtcblx0XHRcdFx0aWYgKCAhKCBrZXkgaW4gcmVhY2hhYmxlICkgJiYgcmV0LmNvbnRlbnQuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHJlYWNoYWJsZVsga2V5IF0gPSB0cnVlXG5cdFx0XHRcdFx0cmVhY2hhYmxlS2V5cy5wdXNoKCBrZXkgKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBrZXlcblx0XHRcdH1cblx0XHRcdHB1c2goIHJldC5tYWluIClcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJlYWNoYWJsZUtleXMubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdGxldCBwbGFjZSA9IHJldC5jb250ZW50WyByZWFjaGFibGVLZXlzWyBpIF0gXVxuXHRcdFx0XHRpZiAoIHBsYWNlICYmIHBsYWNlLmNvbnRlbnQgKVxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKCBwbGFjZS5jb250ZW50ICkuZm9yRWFjaCggcHVzaCApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxldCBpID0gMFxuXHRcdGlmICggcmV0LmNvbnRlbnRbIGtleSBdLnR5cGUgPT0gYGdyb3VwYCApXG5cdFx0XHRpICs9IDJcblx0XHRpZiAoIGtleSBpbiByZWFjaGFibGUgKVxuXHRcdFx0aSArPSAxXG5cdH1cblxuXHRsZXQgZ3JvdXBzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdGxvZGFzaC5mb3JFYWNoKCByZXQuY29udGVudCwgKCBwbGFjZSwga2V5ICkgPT4ge1xuXHRcdGlmICggIXBsYWNlIHx8IHBsYWNlLmdyb3VwID09IG51bGwgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCAhZ3JvdXBzWyBwbGFjZS5ncm91cCBdIClcblx0XHRcdGdyb3Vwc1sgcGxhY2UuZ3JvdXAgXSA9IGtleVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKCBncm91cEluZGV4KCBncm91cHNbIHBsYWNlLmdyb3VwIF0gKSA8IGdyb3VwSW5kZXgoIGtleSApICkge1xuXHRcdFx0XHRyZW1vdmUoIGBjb250ZW50YCwgZ3JvdXBzWyBwbGFjZS5ncm91cCBdIClcblx0XHRcdFx0Z3JvdXBzWyBwbGFjZS5ncm91cCBdID0ga2V5XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlbW92ZSggYGNvbnRlbnRgLCBrZXkgKVxuXHRcdH1cblx0fSApXG5cblx0Ly8gY2hlY2sgY29udGVudFxuXHRsb2Rhc2guZm9yRWFjaCggcmV0LmNvbnRlbnQsICggcGxhY2UsIGtleSApID0+IHtcblx0XHRpZiAoICFwbGFjZSB8fCBwbGFjZS5jb250ZW50ID09IG51bGwgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCB0eXBlb2YgcGxhY2UuY29udGVudCAhPSBgb2JqZWN0YCApXG5cdFx0XHRyZXR1cm4gcmVtb3ZlKCBgY29udGVudGAsIGtleSwgYGNvbnRlbnRgIClcblx0XHRsb2Rhc2guZm9yRWFjaCggcGxhY2UuY29udGVudCwgKCBfLCBja2V5ICkgPT4ge1xuXHRcdFx0aWYgKCAhcmV0LmNvbnRlbnRbIGNrZXkgXSB8fCB0eXBlb2YgcmV0LmNvbnRlbnRbIGNrZXkgXSAhPSBgb2JqZWN0YCApXG5cdFx0XHRcdHJlbW92ZSggYGNvbnRlbnRgLCBrZXksIGBjb250ZW50YCwgY2tleSApXG5cdFx0fSApXG5cdFx0cGxhY2UgPSByZXQuY29udGVudFsga2V5IF0gLy8gcmVhc3NpZ24gcGxhY2UgY2F1c2UgaXQgY291bGQgY2hhbmdlIGluIHByZXZpb3VzIGZvckVhY2hcblx0XHRsb2Rhc2gua2V5cyggcGxhY2UuY29udGVudCApXG5cdFx0LnNvcnQoICggYSwgYiApID0+ICggcGxhY2UuY29udGVudFsgYSBdLmluZGV4IHx8IDAgKSAtICggcGxhY2UuY29udGVudFsgYiBdLmluZGV4IHx8IDAgKSApXG5cdFx0LmZvckVhY2goICggY2tleSwgaW5kZXggKSA9PiB7XG5cdFx0XHRpZiAoIHBsYWNlLmNvbnRlbnRbIGNrZXkgXS5pbmRleCAhPSBpbmRleCApXG5cdFx0XHRcdGFzc2lnbiggYGNvbnRlbnRgLCBrZXksIGBjb250ZW50YCwgY2tleSwgYGluZGV4YCwgaW5kZXggKVxuXHRcdH0gKVxuXHR9IClcblxuXHRyZXR1cm4gbHUubWFrZURpZmYoIGRldmljZXMsIHJldCApXG59XG4iLCIvKlxuXG4yMDE0LjA5LjIyXG5cbml0IHNob3VsZCBiZSBiZXR0ZXIgdG8gdXNlIGhhbW1lci5qcywgYnV0IGkgY2Fubm90IHVzZSBpdCB3aXRob3V0IHByb2JsZW1zIC1cbmhhbW1lci5qcyBvZnRlbiBkcm9wcyBldmVudHMsIHdoaWxlIGRpcmVjdCBhZGRFdmVudExpc3RlbmVyIGRvZXMgbm90LlxuXG4qL1xuXG5sZXQgY28gPSByZXF1aXJlKCBgY29gIClcbmxldCBzcGFyc2VxdWV1ZSA9IHJlcXVpcmUoIGBzcGFyc2VxdWV1ZWAgKVxuXG5sZXQgVFJBQ0Vcbi8vIGxldCBUQyA9IDBcbi8vIFRSQUNFID0gKCAuLi5pbmZvICkgPT4gTE9HKCBgJHsgKytUQyB9IGcgJHsgSlNPTi5zdHJpbmdpZnkoIGluZm8gKS5zbGljZSggMCwgMTAwICkgfWAuZ3JlZW4gKVxuXG5sZXQgU1dJUEVfVElNRU9VVCA9IDQwMCAvLyBtc1xubGV0IFBSRVNTX1RJTUVPVVQgPSA1MDAgLy8gbXNcbmxldCBQUkVTU19NT1ZFX09VVCA9IDIgLyogfm1tICovICogKCA5NiAvIDI1LjQgKVxuXG5mdW5jdGlvbiBzcXVhcmVEaXN0YW5jZSggcDEsIHAyICkge1xuXHRyZXR1cm4gKCBwMS5wYWdlWCAtIHAyLnBhZ2VYICkgKiAoIHAxLnBhZ2VYIC0gcDIucGFnZVggKSArICggcDEucGFnZVkgLSBwMi5wYWdlWSApICogKCBwMS5wYWdlWSAtIHAyLnBhZ2VZIClcbn1cblxuZnVuY3Rpb24gZ2V0WCggcCApIHsgcmV0dXJuIHAucGFnZVggfVxuZnVuY3Rpb24gZ2V0WSggcCApIHsgcmV0dXJuIHAucGFnZVkgfVxuZnVuY3Rpb24gaW5jcmVhc2luZyggdiwgaSwgcCApIHsgcmV0dXJuIGkgPT0gMCB8fCB2ID49IHBbIGkgLSAxIF0gfVxuZnVuY3Rpb24gZGVjcmVhc2luZyggdiwgaSwgcCApIHsgcmV0dXJuIGkgPT0gMCB8fCB2IDw9IHBbIGkgLSAxIF0gfVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2hgLCBjby5ldmVudEhhbmRsZXIoIGZ1bmN0aW9uKiAoIGV2ZW50ICkge1xuXG5cdGxldCBhbGxcblx0bGV0IHRyYWNlID0gWyBldmVudCBdXG5cdGxldCBsYXN0ID0gZXZlbnRcblx0bGV0IHByZXNzZWQgPSBudWxsXG5cdGxldCBzd2lwZWQgPSBmYWxzZVxuXG5cdGxldCBwYW4gPSBudWxsXG5cdGxldCBwYW5sb2NrID0gbnVsbFxuXHRsZXQgc2VudCA9IGV2ZW50XG5cblx0Y28uZGVmZXIoICgpID0+IHtcblx0XHRwYW5sb2NrICYmIHBhbmxvY2suZm9yRWFjaCggbG9jayA9PiBsb2NrLnF1ZXVlLmNsb3NlKCkgKVxuXHRcdHBhbiAmJiBwYW4ucXVldWUuY2xvc2UoKVxuXHR9IClcblxuXHRmdW5jdGlvbiBzZW5kKCB0eXBlLCBkaXJlY3Rpb24sIHB0LCBkZXRhaWwsIHR5cGVEaXJlY3Rpb24gKSB7XG5cdFx0VFJBQ0UgJiYgVFJBQ0UoIHR5cGUsIGFsbCApXG5cdFx0aWYgKCB0eXBlRGlyZWN0aW9uID09IG51bGwgKVxuXHRcdFx0dHlwZURpcmVjdGlvbiA9IGRpcmVjdGlvblxuXHRcdGlmICggIWRldGFpbCApXG5cdFx0XHRkZXRhaWwgPSB7fVxuXHRcdGRldGFpbC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25cblx0XHRkZXRhaWwucHJlc3NlZCA9IHByZXNzZWRcblx0XHRkZXRhaWwudHlwZSA9IHR5cGVcblx0XHRkZXRhaWwuc3RhcnQgPSBldmVudFxuXHRcdGRldGFpbC5vcmlnaW5hbCA9IHB0IHx8IGV2ZW50XG5cdFx0bGV0IHJldCA9IG5ldyBDdXN0b21FdmVudCggdHlwZSArICggdHlwZURpcmVjdGlvbiB8fCBgYCApLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbCB9IClcblx0XHRyZXQucGFnZVggPSBsYXN0LnBhZ2VYXG5cdFx0cmV0LnBhZ2VZID0gbGFzdC5wYWdlWVxuXHRcdHJldC5jbGllbnRYID0gbGFzdC5jbGllbnRYXG5cdFx0cmV0LmNsaWVudFkgPSBsYXN0LmNsaWVudFlcblx0XHRyZXQuc2NyZWVuWCA9IGxhc3Quc2NyZWVuWFxuXHRcdHJldC5zY3JlZW5ZID0gbGFzdC5zY3JlZW5ZXG5cdFx0cmV0LmRlbHRhWCA9IGxhc3QucGFnZVggLSBldmVudC5wYWdlWFxuXHRcdHJldC5kZWx0YVkgPSBsYXN0LnBhZ2VZIC0gZXZlbnQucGFnZVlcblx0XHRyZXQubGFzdERlbHRhWCA9IGxhc3QucGFnZVggLSBzZW50LnBhZ2VYXG5cdFx0cmV0Lmxhc3REZWx0YVkgPSBsYXN0LnBhZ2VZIC0gc2VudC5wYWdlWVxuXHRcdHNlbnQgPSBsYXN0XG5cdFx0cmV0LnByZXZlbnREZWZhdWx0ID0gKCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdGV2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KCByZXQgKVxuXHRcdHJldHVybiByZXRcblx0fVxuXG5cdGZ1bmN0aW9uIGVuc3VyZXBhbiggZGlyZWN0aW9uICkge1xuXHRcdGlmICggcGFuIClcblx0XHRcdHJldHVyblxuXHRcdHBhbiA9IHsgcXVldWU6IG5ldyBzcGFyc2VxdWV1ZSB9XG5cdFx0c2VuZCggYHBhbmAsIGRpcmVjdGlvbiwgbGFzdCwge1xuXHRcdFx0bmV4dDogcGFuLnF1ZXVlLFxuXHRcdFx0bG9jaygpIHtcblx0XHRcdFx0aWYgKCAhcGFubG9jayApXG5cdFx0XHRcdFx0cGFubG9jayA9IFtdXG5cdFx0XHRcdGxldCByZXQgPSB7IHF1ZXVlOiBuZXcgc3BhcnNlcXVldWUgfVxuXHRcdFx0XHRwYW5sb2NrLnB1c2goIHJldCApXG5cdFx0XHRcdHJldHVybiByZXQucXVldWVcblx0XHRcdH0sXG5cdFx0XHR1bmxvY2soIGxvY2sgKSB7XG5cdFx0XHRcdGxldCBsYXN0bG9jayA9IHBhbmxvY2tbIDAgXVxuXHRcdFx0XHRwYW5sb2NrID0gcGFubG9jay5maWx0ZXIoIGwgPT4gbCAhPSBsb2NrIClcblx0XHRcdFx0bGV0IHAgPSBwYW5sb2NrWyAwIF0gfHwgcGFuXG5cdFx0XHRcdGlmICggcC5kaXJ0eSApIHtcblx0XHRcdFx0XHRwLmRpcnR5ID0gZmFsc2Vcblx0XHRcdFx0XHRzZW5kcGFuKCBgcGFuYCwgYHVubG9ja2VkYCApXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSwgYGAgKVxuXHR9XG5cblx0ZnVuY3Rpb24gc2VuZHBhbiggdHlwZSwgZGlyZWN0aW9uLCBwdCwgZGV0YWlsICkge1xuXHRcdGxldCBkYXRhID0gc2VuZCggdHlwZSwgZGlyZWN0aW9uLCBwdCwgZGV0YWlsIClcblx0XHRpZiAoIHBhbiApIHtcblx0XHRcdGlmICggcGFubG9jayAmJiBwYW5sb2NrLmxlbmd0aCApIHtcblx0XHRcdFx0cGFubG9ja1sgMCBdLnF1ZXVlLnB1c2goIGRhdGEgKVxuXHRcdFx0XHRwYW5sb2NrLmZvckVhY2goICggcCwgaSApID0+IGkgPiAwICYmICggcC5kaXJ0eSA9IHRydWUgKSApXG5cdFx0XHRcdHBhbi5kaXJ0eSA9IHRydWVcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0cGFuLnF1ZXVlLnB1c2goIGRhdGEgKVxuXHRcdH1cblx0fVxuXG5cdGxldCBwcmVzc1RpbWVvdXRcblx0bGV0IHN0b3BwZWRUaW1lb3V0XG5cdGNvLmRlZmVyKCAoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KCBwcmVzc1RpbWVvdXQgKVxuXHRcdGNsZWFyVGltZW91dCggc3RvcHBlZFRpbWVvdXQgKVxuXHR9IClcblxuXHRwcmVzc1RpbWVvdXQgPSBzZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0cHJlc3NlZCA9IHRydWVcblx0XHRzZW5kKCBgcHJlc3NgIClcblx0fSwgUFJFU1NfVElNRU9VVCApXG5cblx0ZnVuY3Rpb24gc3RhcnRTdG9wcGVkVGltZW91dCgpIHtcblx0XHRjbGVhclRpbWVvdXQoIHN0b3BwZWRUaW1lb3V0IClcblx0XHRzdG9wcGVkVGltZW91dCA9IHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdGVuc3VyZXBhbigpXG5cdFx0XHRzZW5kcGFuKCBgc3RvcGAgKVxuXHRcdFx0c3RhcnRTdG9wcGVkVGltZW91dCgpXG5cdFx0fSwgUFJFU1NfVElNRU9VVCApXG5cdH1cblxuXHRzdGFydFN0b3BwZWRUaW1lb3V0KClcblxuXHRUUkFDRSAmJiBUUkFDRSggYGVudGVyYCwgeyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVksIHQ6IGV2ZW50LnRpbWVTdGFtcCB9IClcblxuXHRsZXQgc3RvcFBvaW50ID0gZXZlbnRcblxuXHRmb3IgKCBsZXQgcHQ7IHB0ID0geWllbGQgZXZlbnQuZGV0YWlsLm5leHQ7ICkge1xuXHRcdGlmICggVFJBQ0UgKSB7XG5cdFx0XHQoIGFsbCB8fCAoIGFsbCA9IFtdICkgKS5wdXNoKCB7IHg6IHB0LnBhZ2VYLCB5OiBwdC5wYWdlWSwgdDogcHQudGltZVN0YW1wIC0gZXZlbnQudGltZVN0YW1wIH0gKVxuXHRcdFx0VFJBQ0UoIGBuZXh0YCwgYWxsIClcblx0XHR9XG5cdFx0aWYgKCBsYXN0LnRpbWVTdGFtcCAtIGV2ZW50LnRpbWVTdGFtcCA+IFNXSVBFX1RJTUVPVVQgKVxuXHRcdFx0dHJhY2UgPSBudWxsXG5cblx0XHRsZXQgbG9uZ21vdmUgPSBzcXVhcmVEaXN0YW5jZSggcHQsIHN0b3BQb2ludCApID4gUFJFU1NfTU9WRV9PVVQgKiBQUkVTU19NT1ZFX09VVFxuXHRcdGlmICggbG9uZ21vdmUgKSB7XG5cdFx0XHRzdG9wUG9pbnQgPSBwdFxuXHRcdFx0c3RhcnRTdG9wcGVkVGltZW91dCgpXG5cdFx0fVxuXG5cdFx0aWYgKCBsb25nbW92ZSB8fCAhdHJhY2UgfHwgdHJhY2UubGVuZ3RoID4gMSApIHtcblx0XHRcdGlmICggcHJlc3NlZCA9PSBudWxsICkge1xuXHRcdFx0XHRwcmVzc2VkID0gZmFsc2Vcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCBwcmVzc1RpbWVvdXQgKVxuXHRcdFx0fVxuXHRcdFx0bGV0IGR4ID0gcHQucGFnZVggLSBsYXN0LnBhZ2VYXG5cdFx0XHRsZXQgZHkgPSBwdC5wYWdlWSAtIGxhc3QucGFnZVlcblx0XHRcdGlmICggZHggfHwgZHkgKSB7XG5cdFx0XHRcdGxldCBzaXpleCA9IE1hdGguYWJzKCBkeCApXG5cdFx0XHRcdGxldCBzaXpleSA9IE1hdGguYWJzKCBkeSApXG5cdFx0XHRcdGxldCBwcmV2ID0gbGFzdFxuXHRcdFx0XHRpZiAoIHRyYWNlIClcblx0XHRcdFx0XHR0cmFjZS5wdXNoKCBsYXN0IClcblx0XHRcdFx0bGFzdCA9IHB0XG5cdFx0XHRcdGxldCBkaXJlY3Rpb24gPSBgYFxuXHRcdFx0XHRpZiAoIHNpemV4ID49IHNpemV5ICYmIGR4ID4gMCApXG5cdFx0XHRcdFx0ZGlyZWN0aW9uID0gYHJpZ2h0YFxuXHRcdFx0XHRlbHNlIGlmICggc2l6ZXggPj0gc2l6ZXkgJiYgZHggPCAwIClcblx0XHRcdFx0XHRkaXJlY3Rpb24gPSBgbGVmdGBcblx0XHRcdFx0ZWxzZSBpZiAoIHNpemV4IDwgc2l6ZXkgJiYgZHkgPiAwIClcblx0XHRcdFx0XHRkaXJlY3Rpb24gPSBgZG93bmBcblx0XHRcdFx0ZWxzZSBpZiAoIHNpemV4IDwgc2l6ZXkgJiYgZHkgPCAwIClcblx0XHRcdFx0XHRkaXJlY3Rpb24gPSBgdXBgXG5cdFx0XHRcdGVuc3VyZXBhbiggZGlyZWN0aW9uIClcblx0XHRcdFx0c2VuZHBhbiggYHBhbmAsIGRpcmVjdGlvbiwgbGFzdCApXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGNsZWFyVGltZW91dCggcHJlc3NUaW1lb3V0IClcblx0aWYgKCBsYXN0LnRpbWVTdGFtcCAtIGV2ZW50LnRpbWVTdGFtcCA8IFNXSVBFX1RJTUVPVVQgJiYgdHJhY2UgJiYgdHJhY2UubGVuZ3RoID4gMiApIHtcblx0XHQvLyByZW1vdmUgZmlyc3QgcG9pbnQgdG8gZWxpbWluYXRlIHRvdWNoIGJvdW5jaW5nIGVmZmVjdFxuXHRcdHRyYWNlLnNoaWZ0KClcblx0XHRsZXQgdHJhY2VYID0gdHJhY2UubWFwKCBnZXRYIClcblx0XHRsZXQgdHJhY2VZID0gdHJhY2UubWFwKCBnZXRZIClcblx0XHRsZXQgYm91bmRzID0ge1xuXHRcdFx0eDogTWF0aC5tYXgoIC4uLnRyYWNlWCApIC0gTWF0aC5taW4oIC4uLnRyYWNlWCApLFxuXHRcdFx0eTogTWF0aC5tYXgoIC4uLnRyYWNlWSApIC0gTWF0aC5taW4oIC4uLnRyYWNlWSApLFxuXHRcdH1cblx0XHRsZXQgZGlyZWN0aW9uID0gYGBcblx0XHRpZiAoIGJvdW5kcy54ID4gYm91bmRzLnkgJiYgdHJhY2VYLmV2ZXJ5KCBpbmNyZWFzaW5nICkgKVxuXHRcdFx0ZGlyZWN0aW9uID0gYHJpZ2h0YFxuXHRcdGVsc2UgaWYgKCBib3VuZHMueCA+IGJvdW5kcy55ICYmIHRyYWNlWC5ldmVyeSggZGVjcmVhc2luZyApIClcblx0XHRcdGRpcmVjdGlvbiA9IGBsZWZ0YFxuXHRcdGVsc2UgaWYgKCBib3VuZHMueCA8IGJvdW5kcy55ICYmIHRyYWNlWS5ldmVyeSggaW5jcmVhc2luZyApIClcblx0XHRcdGRpcmVjdGlvbiA9IGBkb3duYFxuXHRcdGVsc2UgaWYgKCBib3VuZHMueCA8IGJvdW5kcy55ICYmIHRyYWNlWS5ldmVyeSggZGVjcmVhc2luZyApIClcblx0XHRcdGRpcmVjdGlvbiA9IGB1cGBcblx0XHRpZiAoIGRpcmVjdGlvbiApIHtcblx0XHRcdHN3aXBlZCA9IHRydWVcblx0XHRcdHNlbmRwYW4oIGBzd2lwZWAsIGRpcmVjdGlvbiwgbGFzdCApXG5cdFx0fVxuXHR9XG5cdGlmICggIXByZXNzZWQgJiYgIXN3aXBlZCAmJiAhcGFuIClcblx0XHRzZW5kcGFuKCBgdGFwYCApXG5cdFRSQUNFICYmIFRSQUNFKCBgZG9uZWAsIGFsbCApXG59ICkgKVxuIiwibGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYGRpdmAgKS5zdHlsZVxuaWYgKCAhKCBgdHJhbnNmb3JtYCBpbiBzdHlsZSApICYmICggYHdlYmtpdFRyYW5zZm9ybWAgaW4gc3R5bGUgKSApIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBDU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZSwgYHRyYW5zZm9ybWAsIHtcblx0XHRnZXQoKSB7IHJldHVybiB0aGlzLndlYmtpdFRyYW5zZm9ybSB9LFxuXHRcdHNldCggdmFsdWUgKSB7IHRoaXMud2Via2l0VHJhbnNmb3JtID0gdmFsdWUgfSxcblx0fSApXG59XG5cbi8vIGxldCBzbGljZSA9IFtdLnNsaWNlXG5cbmlmICggIU5vZGVMaXN0LnByb3RvdHlwZVsgU3ltYm9sLml0ZXJhdG9yIF0gKVxuXHROb2RlTGlzdC5wcm90b3R5cGVbIFN5bWJvbC5pdGVyYXRvciBdID0gZnVuY3Rpb24qICgpIHtcblx0XHQvLyByZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApWyBTeW1ib2wuaXRlcmF0b3IgXVxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgKytpIClcblx0XHRcdHlpZWxkIHRoaXMuaXRlbSggaSApXG5cdH1cblxuIiwiZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IGV2ZW50ID0+IGV2ZW50ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuZXhwb3J0cy5TdWJtaXQgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRldmVudCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdGxldCBjID0gdGhpc1xuXHR3aGlsZSAoIGMgJiYgISggYyBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCApIClcblx0XHRjID0gYy5wYXJlbnROb2RlXG5cdGlmICggYyApXG5cdFx0Yy5kaXNwYXRjaEV2ZW50KCBuZXcgQ3VzdG9tRXZlbnQoIGBzdWJtaXRgLCBudWxsICkgKVxuXHRyZXR1cm4gZmFsc2Vcbn1cblxubGV0IGNlbnRlcmVkID0gYFxuXHR3aWR0aDogMTAwJTtcblx0aGVpZ2h0OiAxMDAlO1xuXHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5gXG5cbmV4cG9ydHMuQ2VudGVyZWQgPSAoIF8sIGNvbnRlbnQgKSA9PlxuXHQ8dGFibGUgc3R5bGUgPSB7IGNlbnRlcmVkIH0gPlxuXHRcdDx0ciBzdHlsZSA9IHsgY2VudGVyZWQgfSA+XG5cdFx0XHQ8dGQgc3R5bGUgPSB7IGNlbnRlcmVkIH0gPntcblx0XHRcdFx0Y29udGVudFxuXHRcdFx0fTwvdGQ+XG5cdFx0PC90cj5cblx0PC90YWJsZT5cblxuZXhwb3J0cy5pc0VtcHR5Tm9kZSA9IG5vZGUgPT5cblx0bm9kZSBpbnN0YW5jZW9mIENvbW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFByb2Nlc3NpbmdJbnN0cnVjdGlvbiB8fCBub2RlIGluc3RhbmNlb2YgVGV4dCAmJiAhbm9kZS5ub2RlVmFsdWUudHJpbSgpXG5cbmV4cG9ydHMuaW1wb3J0VGVtcGxhdGUgPSB0ZW1wbGF0ZSA9PiBkb2N1bWVudC5pbXBvcnROb2RlKCB0ZW1wbGF0ZS5jb250ZW50LCB0cnVlIClcblxuZXhwb3J0cy5pbXBvcnRFbGVtZW50ID0gdGVtcGxhdGUgPT4ge1xuXHRsZXQgcmV0ID0gZXhwb3J0cy5pbXBvcnRUZW1wbGF0ZSggdGVtcGxhdGUgKVxuXHRpZiAoICFyZXQgKVxuXHRcdHJldHVybiBudWxsXG5cdHdoaWxlICggcmV0Lmxhc3RDaGlsZCAmJiBleHBvcnRzLmlzRW1wdHlOb2RlKCByZXQubGFzdENoaWxkICkgKVxuXHRcdHJldC5yZW1vdmVDaGlsZCggcmV0Lmxhc3RDaGlsZCApXG5cdHdoaWxlICggcmV0LmZpcnN0Q2hpbGQgJiYgZXhwb3J0cy5pc0VtcHR5Tm9kZSggcmV0LmZpcnN0Q2hpbGQgKSApXG5cdFx0cmV0LnJlbW92ZUNoaWxkKCByZXQuZmlyc3RDaGlsZCApXG5cdGlmICggIXJldC5maXJzdENoaWxkIClcblx0XHRyZXR1cm4gbnVsbFxuXHRpZiAoIHJldC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxIClcblx0XHRyZXR1cm4gcmV0LmNoaWxkTm9kZXMuaXRlbSggMCApXG5cdGxldCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYHNwYW5gIClcblx0cm9vdC5hcHBlbmRDaGlsZCggcmV0IClcblx0cmV0dXJuIHJvb3Rcbn1cblxuZXhwb3J0cy5pbXBvcnRDb21wb25lbnQgPSB0ZW1wbGF0ZSA9PiB7XG5cdGxldCBkYXRhID0gZXhwb3J0cy5pbXBvcnRFbGVtZW50KCB0ZW1wbGF0ZSApXG5cdGlmICggZGF0YSApIHtcblx0XHRsZXQgaW5pdCA9IGRhdGEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggYGluaXRgIClbIDAgXVxuXHRcdGlmICggaW5pdCAmJiBpbml0LnR5cGUgPT0gYGluaXRgICkge1xuXHRcdFx0bGV0IG1ldGhvZHMgPSBbIGBzZXREZXZpY2VTdGF0ZWAgXVxuXHRcdFx0bGV0IGZpbml0ID0gbmV3IEZ1bmN0aW9uKCBgY29tcG9uZW50YCwgW10uc2xpY2UuY2FsbCggaW5pdC5jaGlsZE5vZGVzICkubWFwKCB4ID0+IHguZGF0YSB8fCBgYCApLmpvaW4oIGBgICkgKVxuXHRcdFx0ZmluaXQoIGRhdGEgKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YVxufVxuXG5leHBvcnRzLnRpY2tDYWNoZSA9IGZ1biA9PiB7XG5cdGxldCBjYWNoZWRSZXN1bHRcblx0bGV0IGNhY2hlZCA9IGZhbHNlXG5cblx0bGV0IGNsZWFyQ2FjaGUgPSAoKSA9PiB7XG5cdFx0Y2FjaGVkUmVzdWx0ID0gbnVsbFxuXHRcdGNhY2hlZCA9IGZhbHNlXG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICggIWNhY2hlZCApIHtcblx0XHRcdGNhY2hlZFJlc3VsdCA9IGZ1bi5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRcdGNhY2hlZCA9IHRydWVcblx0XHRcdHNldEltbWVkaWF0ZSggY2xlYXJDYWNoZSApXG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZWRSZXN1bHRcblx0fVxufVxuXG5leHBvcnRzLmNyZWF0ZUV2ZW50ID0gKCB0eXBlLCBkZXRhaWwsIG9uICkgPT4ge1xuXHRsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoIHR5cGUsIHsgZGV0YWlsLCBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0gKVxuXHRpZiAoIG9uICkge1xuXHRcdGV2ZW50LnBhZ2VYID0gb24ucGFnZVhcblx0XHRldmVudC5wYWdlWSA9IG9uLnBhZ2VZXG5cdFx0ZXZlbnQuY2xpZW50WCA9IG9uLmNsaWVudFhcblx0XHRldmVudC5jbGllbnRZID0gb24uY2xpZW50WVxuXHRcdGV2ZW50LnNjcmVlblggPSBvbi5zY3JlZW5YXG5cdFx0ZXZlbnQuc2NyZWVuWSA9IG9uLnNjcmVlbllcblx0fVxuXHRyZXR1cm4gZXZlbnRcbn1cblxuZXhwb3J0cy5zZW5kRXZlbnQgPSAoIHR5cGUsIGRldGFpbCwgb24gKSA9PiBvbi50YXJnZXQuZGlzcGF0Y2hFdmVudCggZXhwb3J0cy5jcmVhdGVFdmVudCggdHlwZSwgZGV0YWlsLCBvbiApIClcbiIsImxldCBsb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5sZXQgbHUgPSByZXF1aXJlKCBgbG9jYWxVdGlsc2AgKVxuXG5sZXQgaHR0cENsaWVudCA9IHtcblx0Z2V0KCB1cmwsIGVuY29kaW5nICkge1xuXHRcdHJldHVybiBodHRwQ2xpZW50LnhociggeyBtZXRob2Q6IGBHRVRgLCB1cmwsIGVuY29kaW5nIH0gKVxuXHR9LFxuXG5cdHBvc3QoIHVybCwgZGF0YSwgZW5jb2RpbmcgKSB7XG5cdFx0cmV0dXJuIGh0dHBDbGllbnQueGhyKCB7IG1ldGhvZDogYFBPU1RgLCB1cmwsIGRhdGEsIGVuY29kaW5nIH0gKVxuXHR9LFxuXG5cdHhociggb3B0aW9ucyApIHtcblx0XHRsZXQgeyBtZXRob2QsIHVybCwgZW5jb2RpbmcsIGRhdGEgfSA9IG9wdGlvbnNcblx0XHRsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblx0XHRpZiAoIGVuY29kaW5nID09IGBiaW5hcnlgIClcblx0XHRcdHhoci5yZXNwb25zZVR5cGUgPSBgYXJyYXlidWZmZXJgXG5cdFx0ZWxzZVxuXHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9IGB0ZXh0YFxuXHRcdGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdFx0bGV0IG9uZXJyb3IgPSBlcnJvciA9PiB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGVycm9yID09IGBzdHJpbmdgICkge1xuXHRcdFx0XHRcdGVycm9yID0gbmV3IEVycm9yKCBlcnJvciApXG5cdFx0XHRcdFx0ZXJyb3IubWV0aG9kID0gbWV0aG9kXG5cdFx0XHRcdFx0ZXJyb3IudXJsID0gdXJsXG5cdFx0XHRcdH1cblx0XHRcdFx0Z2xvYmFsLl9BTEVSVCAmJiBnbG9iYWwuX0FMRVJUKCBgdHJ5IGAgKyBlcnJvciArIHVybCApXG5cdFx0XHRcdHJlamVjdCggZXJyb3IgKVxuXHRcdFx0fVxuXHRcdFx0eGhyLm9udGltZW91dCA9ICgpID0+IG9uZXJyb3IoIG5ldyBFcnJvciggYFRJTUVPVVQgJHsgdXJsIH1gICkgKVxuXHRcdFx0eGhyLm9uZXJyb3IgPSBlID0+IG9uZXJyb3IoIGUgfHwgYEVSUk9SYCApXG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuXHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09IHhoci5ET05FICYmIHhoci5zdGF0dXMgPT0gMCApXG5cdFx0XHRcdFx0eGhyLm9udGltZW91dCgpXG5cdFx0XHR9XG5cdFx0XHR4aHIub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0XHQvLyBhbGVydCggeGhyLnN0YXR1cyApXG5cdFx0XHRcdGlmICggeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8PSAyOTkgKVxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlKCB4aHIucmVzcG9uc2UgPT0gbnVsbCA/IG51bGwgOiB4aHIucmVzcG9uc2UgKVxuXHRcdFx0XHRpZiAoIHhoci5zdGF0dXMgPT0gNDAxICkge1xuXHRcdFx0XHRcdC8vIGFwcGVuZCBzb21lIHRoaW5nIHRvIHRoZSBwYWdlIHRvIGZvcmNlIHN0YW5kYWxvbmUgYnJvd3NlciB0byBzaG93IGxvZ2luIGRpYWxvZ1xuXHRcdFx0XHRcdGxldCBzdXJsID0gcmVxdWlyZSggYHVybGAgKS5wYXJzZSggdXJsIClcblx0XHRcdFx0XHRpZiAoIHN1cmwuaG9zdCApIHtcblx0XHRcdFx0XHRcdHN1cmwgPSBgJHsgc3VybC5wcm90b2NvbCB9Ly8keyBzdXJsLmhvc3QgfS9kdW1teS4keyBNYXRoLnJhbmRvbSgpIH0uanNgXG5cdFx0XHRcdFx0XHRsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYHNjcmlwdGAgKVxuXHRcdFx0XHRcdFx0c2NyaXB0LnNyYyA9IHN1cmxcblx0XHRcdFx0XHRcdC8vIGFsZXJ0KCBzdXJsIClcblx0XHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIHNjcmlwdCApXG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KCAoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKCBzY3JpcHQgKSwgMTAwMCApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG9uZXJyb3IoIGAkeyB4aHIuc3RhdHVzIH0gJHsgeGhyLnN0YXR1c1RleHQgfWAgKVxuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdHN3aXRjaCAoIGVuY29kaW5nICkge1xuXHRcdGNhc2UgYGltbXV0YWJsZWA6XG5cdFx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKCBkYXRhID0+IEltbXV0YWJsZS5mcm9tSlMoIEpTT04ucGFyc2UoIGRhdGEgKSApIClcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSBgYmluYXJ5YDpcblx0XHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oIGRhdGEgPT4gbmV3IFVpbnQ4QXJyYXkoIGRhdGEgKSApXG5cdFx0XHRicmVha1xuXHRcdGNhc2UgYHRleHRgOlxuXHRcdFx0YnJlYWtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHJvbWlzZSA9IHByb21pc2UudGhlbiggZGF0YSA9PiB7XG5cdFx0XHRcdGxldCBhY3R1YWxFbmNvZGluZyA9IGVuY29kaW5nXG5cdFx0XHRcdGlmICggIWFjdHVhbEVuY29kaW5nICkge1xuXHRcdFx0XHRcdGxldCBjdCA9IHhoci5nZXRSZXNwb25zZUhlYWRlciggYGNvbnRlbnQtdHlwZWAgKSB8fCBgYFxuXHRcdFx0XHRcdGlmICggY3QubWF0Y2goIC9eYXBwbGljYXRpb25cXC9qc29uLyApIClcblx0XHRcdFx0XHRcdGFjdHVhbEVuY29kaW5nID0gYGpzb25gXG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoICggYWN0dWFsRW5jb2RpbmcgKSB7XG5cdFx0XHRcdGNhc2UgYGpzb25gOlxuXHRcdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhIClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGF0YVxuXHRcdFx0fSApXG5cdFx0fVxuXHRcdHhoci5vcGVuKCBtZXRob2QgfHwgYEdFVGAsIHVybCApXG5cdFx0eGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcblx0XHR4aHIuc2VuZCggZGF0YSApXG5cdFx0eGhyLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZCggcHJvbWlzZSApXG5cdFx0eGhyLmNhdGNoID0gcHJvbWlzZS5jYXRjaC5iaW5kKCBwcm9taXNlIClcblx0XHRyZXR1cm4geGhyXG5cdH0sXG5cblx0dXJsKCB1cmwsIHBhcmFtcyApIHtcblx0XHRwYXJhbXMgJiYgT2JqZWN0LmtleXMoIHBhcmFtcyApLmZvckVhY2goICggaywgaSApID0+IHVybCA9IHVybFxuXHRcdFx0KyAoIGkgPiAwID8gYCZgIDogYD9gIClcblx0XHRcdCsgZW5jb2RlVVJJQ29tcG9uZW50KCBrIClcblx0XHRcdCsgYD1gXG5cdFx0XHQrIGVuY29kZVVSSUNvbXBvbmVudCggcGFyYW1zWyBrIF0gKVxuXHRcdClcblx0XHRyZXR1cm4gdXJsXG5cdH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHR0cENsaWVudFxuIiwiLypcblxudmFkemltIHppZW5rYVxuXG4yMDE1LjA1LjExXG5hZGRlZCB0aGlzLnN0b3BwZWRUcmFuc2l0aW9uIHRvIG5vdCB0byBmaXJlIHRhcCB3aGVuIHNjcm9sbGluZyBpcyBzdG9wcGVkIGJ5IHRoYXQgdGFwLlxuXG4gKi9cblxuLyohIGlTY3JvbGwgdjUuMS4zIH4gKGMpIDIwMDgtMjAxNCBNYXR0ZW8gU3BpbmVsbGkgfiBodHRwOi8vY3ViaXEub3JnL2xpY2Vuc2UgKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgTWF0aCkge1xudmFyIHJBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdGZ1bmN0aW9uIChjYWxsYmFjaykgeyB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTsgfTtcblxudmFyIHV0aWxzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG1lID0ge307XG5cblx0dmFyIF9lbGVtZW50U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblx0dmFyIF92ZW5kb3IgPSAoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ZW5kb3JzID0gWyd0JywgJ3dlYmtpdFQnLCAnTW96VCcsICdtc1QnLCAnT1QnXSxcblx0XHRcdHRyYW5zZm9ybSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHZlbmRvcnMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dHJhbnNmb3JtID0gdmVuZG9yc1tpXSArICdyYW5zZm9ybSc7XG5cdFx0XHRpZiAoIHRyYW5zZm9ybSBpbiBfZWxlbWVudFN0eWxlICkgcmV0dXJuIHZlbmRvcnNbaV0uc3Vic3RyKDAsIHZlbmRvcnNbaV0ubGVuZ3RoLTEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBfcHJlZml4U3R5bGUgKHN0eWxlKSB7XG5cdFx0aWYgKCBfdmVuZG9yID09PSBmYWxzZSApIHJldHVybiBmYWxzZTtcblx0XHRpZiAoIF92ZW5kb3IgPT09ICcnICkgcmV0dXJuIHN0eWxlO1xuXHRcdHJldHVybiBfdmVuZG9yICsgc3R5bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHlsZS5zdWJzdHIoMSk7XG5cdH1cblxuXHRtZS5nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gZ2V0VGltZSAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuXHRtZS5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYmopIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBvYmogKSB7XG5cdFx0XHR0YXJnZXRbaV0gPSBvYmpbaV07XG5cdFx0fVxuXHR9O1xuXG5cdG1lLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuXHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sICEhY2FwdHVyZSk7XG5cdH07XG5cblx0bWUucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKSB7XG5cdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgISFjYXB0dXJlKTtcblx0fTtcblxuXHRtZS5wcmVmaXhQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAocG9pbnRlckV2ZW50KSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5NU1BvaW50ZXJFdmVudCA/IFxuXHRcdFx0J01TUG9pbnRlcicgKyBwb2ludGVyRXZlbnQuY2hhckF0KDkpLnRvVXBwZXJDYXNlKCkgKyBwb2ludGVyRXZlbnQuc3Vic3RyKDEwKTpcblx0XHRcdHBvaW50ZXJFdmVudDtcblx0fTtcblxuXHRtZS5tb21lbnR1bSA9IGZ1bmN0aW9uIChjdXJyZW50LCBzdGFydCwgdGltZSwgbG93ZXJNYXJnaW4sIHdyYXBwZXJTaXplLCBkZWNlbGVyYXRpb24pIHtcblx0XHR2YXIgZGlzdGFuY2UgPSBjdXJyZW50IC0gc3RhcnQsXG5cdFx0XHRzcGVlZCA9IE1hdGguYWJzKGRpc3RhbmNlKSAvIHRpbWUsXG5cdFx0XHRkZXN0aW5hdGlvbixcblx0XHRcdGR1cmF0aW9uO1xuXG5cdFx0ZGVjZWxlcmF0aW9uID0gZGVjZWxlcmF0aW9uID09PSB1bmRlZmluZWQgPyAwLjAwMDYgOiBkZWNlbGVyYXRpb247XG5cblx0XHRkZXN0aW5hdGlvbiA9IGN1cnJlbnQgKyAoIHNwZWVkICogc3BlZWQgKSAvICggMiAqIGRlY2VsZXJhdGlvbiApICogKCBkaXN0YW5jZSA8IDAgPyAtMSA6IDEgKTtcblx0XHRkdXJhdGlvbiA9IHNwZWVkIC8gZGVjZWxlcmF0aW9uO1xuXG5cdFx0aWYgKCBkZXN0aW5hdGlvbiA8IGxvd2VyTWFyZ2luICkge1xuXHRcdFx0ZGVzdGluYXRpb24gPSB3cmFwcGVyU2l6ZSA/IGxvd2VyTWFyZ2luIC0gKCB3cmFwcGVyU2l6ZSAvIDIuNSAqICggc3BlZWQgLyA4ICkgKSA6IGxvd2VyTWFyZ2luO1xuXHRcdFx0ZGlzdGFuY2UgPSBNYXRoLmFicyhkZXN0aW5hdGlvbiAtIGN1cnJlbnQpO1xuXHRcdFx0ZHVyYXRpb24gPSBkaXN0YW5jZSAvIHNwZWVkO1xuXHRcdH0gZWxzZSBpZiAoIGRlc3RpbmF0aW9uID4gMCApIHtcblx0XHRcdGRlc3RpbmF0aW9uID0gd3JhcHBlclNpemUgPyB3cmFwcGVyU2l6ZSAvIDIuNSAqICggc3BlZWQgLyA4ICkgOiAwO1xuXHRcdFx0ZGlzdGFuY2UgPSBNYXRoLmFicyhjdXJyZW50KSArIGRlc3RpbmF0aW9uO1xuXHRcdFx0ZHVyYXRpb24gPSBkaXN0YW5jZSAvIHNwZWVkO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRkZXN0aW5hdGlvbjogTWF0aC5yb3VuZChkZXN0aW5hdGlvbiksXG5cdFx0XHRkdXJhdGlvbjogZHVyYXRpb25cblx0XHR9O1xuXHR9O1xuXG5cdHZhciBfdHJhbnNmb3JtID0gX3ByZWZpeFN0eWxlKCd0cmFuc2Zvcm0nKTtcblxuXHRtZS5leHRlbmQobWUsIHtcblx0XHRoYXNUcmFuc2Zvcm06IF90cmFuc2Zvcm0gIT09IGZhbHNlLFxuXHRcdGhhc1BlcnNwZWN0aXZlOiBfcHJlZml4U3R5bGUoJ3BlcnNwZWN0aXZlJykgaW4gX2VsZW1lbnRTdHlsZSxcblx0XHRoYXNUb3VjaDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93LFxuXHRcdGhhc1BvaW50ZXI6IHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgd2luZG93Lk1TUG9pbnRlckV2ZW50LCAvLyBJRTEwIGlzIHByZWZpeGVkXG5cdFx0aGFzVHJhbnNpdGlvbjogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uJykgaW4gX2VsZW1lbnRTdHlsZVxuXHR9KTtcblxuXHQvLyBUaGlzIHNob3VsZCBmaW5kIGFsbCBBbmRyb2lkIGJyb3dzZXJzIGxvd2VyIHRoYW4gYnVpbGQgNTM1LjE5IChib3RoIHN0b2NrIGJyb3dzZXIgYW5kIHdlYnZpZXcpXG5cdG1lLmlzQmFkQW5kcm9pZCA9IC9BbmRyb2lkIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24pICYmICEoL0Nocm9tZVxcL1xcZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24pKTtcblxuXHRtZS5leHRlbmQobWUuc3R5bGUgPSB7fSwge1xuXHRcdHRyYW5zZm9ybTogX3RyYW5zZm9ybSxcblx0XHR0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJyksXG5cdFx0dHJhbnNpdGlvbkR1cmF0aW9uOiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25EdXJhdGlvbicpLFxuXHRcdHRyYW5zaXRpb25EZWxheTogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uRGVsYXknKSxcblx0XHR0cmFuc2Zvcm1PcmlnaW46IF9wcmVmaXhTdHlsZSgndHJhbnNmb3JtT3JpZ2luJylcblx0fSk7XG5cblx0bWUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGMgKyBcIihcXFxcc3wkKVwiKTtcblx0XHRyZXR1cm4gcmUudGVzdChlLmNsYXNzTmFtZSk7XG5cdH07XG5cblx0bWUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdGlmICggbWUuaGFzQ2xhc3MoZSwgYykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG5ld2NsYXNzID0gZS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcblx0XHRuZXdjbGFzcy5wdXNoKGMpO1xuXHRcdGUuY2xhc3NOYW1lID0gbmV3Y2xhc3Muam9pbignICcpO1xuXHR9O1xuXG5cdG1lLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGUsIGMpIHtcblx0XHRpZiAoICFtZS5oYXNDbGFzcyhlLCBjKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjICsgXCIoXFxcXHN8JClcIiwgJ2cnKTtcblx0XHRlLmNsYXNzTmFtZSA9IGUuY2xhc3NOYW1lLnJlcGxhY2UocmUsICcgJyk7XG5cdH07XG5cblx0bWUub2Zmc2V0ID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0dmFyIGxlZnQgPSAtZWwub2Zmc2V0TGVmdCxcblx0XHRcdHRvcCA9IC1lbC5vZmZzZXRUb3A7XG5cblx0XHQvLyBqc2hpbnQgLVcwODRcblx0XHR3aGlsZSAoZWwgPSBlbC5vZmZzZXRQYXJlbnQpIHtcblx0XHRcdGxlZnQgLT0gZWwub2Zmc2V0TGVmdDtcblx0XHRcdHRvcCAtPSBlbC5vZmZzZXRUb3A7XG5cdFx0fVxuXHRcdC8vIGpzaGludCArVzA4NFxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IGxlZnQsXG5cdFx0XHR0b3A6IHRvcFxuXHRcdH07XG5cdH07XG5cblx0bWUucHJldmVudERlZmF1bHRFeGNlcHRpb24gPSBmdW5jdGlvbiAoZWwsIGV4Y2VwdGlvbnMpIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBleGNlcHRpb25zICkge1xuXHRcdFx0aWYgKCBleGNlcHRpb25zW2ldLnRlc3QoZWxbaV0pICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0bWUuZXh0ZW5kKG1lLmV2ZW50VHlwZSA9IHt9LCB7XG5cdFx0dG91Y2hzdGFydDogMSxcblx0XHR0b3VjaG1vdmU6IDEsXG5cdFx0dG91Y2hlbmQ6IDEsXG5cblx0XHRtb3VzZWRvd246IDIsXG5cdFx0bW91c2Vtb3ZlOiAyLFxuXHRcdG1vdXNldXA6IDIsXG5cblx0XHRwb2ludGVyZG93bjogMyxcblx0XHRwb2ludGVybW92ZTogMyxcblx0XHRwb2ludGVydXA6IDMsXG5cblx0XHRNU1BvaW50ZXJEb3duOiAzLFxuXHRcdE1TUG9pbnRlck1vdmU6IDMsXG5cdFx0TVNQb2ludGVyVXA6IDNcblx0fSk7XG5cblx0bWUuZXh0ZW5kKG1lLmVhc2UgPSB7fSwge1xuXHRcdHF1YWRyYXRpYzoge1xuXHRcdFx0c3R5bGU6ICdjdWJpYy1iZXppZXIoMC4yNSwgMC40NiwgMC40NSwgMC45NCknLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHJldHVybiBrICogKCAyIC0gayApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2lyY3VsYXI6IHtcblx0XHRcdHN0eWxlOiAnY3ViaWMtYmV6aWVyKDAuMSwgMC41NywgMC4xLCAxKScsXHQvLyBOb3QgcHJvcGVybHkgXCJjaXJjdWxhclwiIGJ1dCB0aGlzIGxvb2tzIGJldHRlciwgaXQgc2hvdWxkIGJlICgwLjA3NSwgMC44MiwgMC4xNjUsIDEpXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCggMSAtICggLS1rICogayApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRiYWNrOiB7XG5cdFx0XHRzdHlsZTogJ2N1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIsIDEuMjc1KScsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0dmFyIGIgPSA0O1xuXHRcdFx0XHRyZXR1cm4gKCBrID0gayAtIDEgKSAqIGsgKiAoICggYiArIDEgKSAqIGsgKyBiICkgKyAxO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ym91bmNlOiB7XG5cdFx0XHRzdHlsZTogJycsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0aWYgKCAoIGsgLz0gMSApIDwgKCAxIC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiBrICogaztcblx0XHRcdFx0fSBlbHNlIGlmICggayA8ICggMiAvIDIuNzUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMS41IC8gMi43NSApICkgKiBrICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmICggayA8ICggMi41IC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjI1IC8gMi43NSApICkgKiBrICsgMC45Mzc1O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjYyNSAvIDIuNzUgKSApICogayArIDAuOTg0Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbGFzdGljOiB7XG5cdFx0XHRzdHlsZTogJycsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0dmFyIGYgPSAwLjIyLFxuXHRcdFx0XHRcdGUgPSAwLjQ7XG5cblx0XHRcdFx0aWYgKCBrID09PSAwICkgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHRpZiAoIGsgPT0gMSApIHsgcmV0dXJuIDE7IH1cblxuXHRcdFx0XHRyZXR1cm4gKCBlICogTWF0aC5wb3coIDIsIC0gMTAgKiBrICkgKiBNYXRoLnNpbiggKCBrIC0gZiAvIDQgKSAqICggMiAqIE1hdGguUEkgKSAvIGYgKSArIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdG1lLnRhcCA9IGZ1bmN0aW9uIChlLCBldmVudE5hbWUpIHtcblx0XHR2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblx0XHRldi5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKTtcblx0XHRldi5wYWdlWCA9IGUucGFnZVg7XG5cdFx0ZXYucGFnZVkgPSBlLnBhZ2VZO1xuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuXHR9O1xuXG5cdG1lLmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQsXG5cdFx0XHRldjtcblxuXHRcdGlmICggISgvKFNFTEVDVHxJTlBVVHxURVhUQVJFQSkvaSkudGVzdCh0YXJnZXQudGFnTmFtZSkgKSB7XG5cdFx0XHRldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdFx0ZXYuaW5pdE1vdXNlRXZlbnQoJ2NsaWNrJywgdHJ1ZSwgdHJ1ZSwgZS52aWV3LCAxLFxuXHRcdFx0XHR0YXJnZXQuc2NyZWVuWCwgdGFyZ2V0LnNjcmVlblksIHRhcmdldC5jbGllbnRYLCB0YXJnZXQuY2xpZW50WSxcblx0XHRcdFx0ZS5jdHJsS2V5LCBlLmFsdEtleSwgZS5zaGlmdEtleSwgZS5tZXRhS2V5LFxuXHRcdFx0XHQwLCBudWxsKTtcblxuXHRcdFx0ZXYuX2NvbnN0cnVjdGVkID0gdHJ1ZTtcblx0XHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG1lO1xufSkoKTtcblxuZnVuY3Rpb24gSVNjcm9sbCAoZWwsIG9wdGlvbnMpIHtcblx0dGhpcy53cmFwcGVyID0gdHlwZW9mIGVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcblx0dGhpcy5zY3JvbGxlciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5zY3JvbGxlclN0eWxlID0gdGhpcy5zY3JvbGxlci5zdHlsZTtcdFx0Ly8gY2FjaGUgc3R5bGUgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXG5cdHRoaXMub3B0aW9ucyA9IHtcblxuXHRcdHJlc2l6ZVNjcm9sbGJhcnM6IHRydWUsXG5cblx0XHRtb3VzZVdoZWVsU3BlZWQ6IDIwLFxuXG5cdFx0c25hcFRocmVzaG9sZDogMC4zMzQsXG5cbi8vIElOU0VSVCBQT0lOVDogT1BUSU9OUyBcblxuXHRcdHN0YXJ0WDogMCxcblx0XHRzdGFydFk6IDAsXG5cdFx0c2Nyb2xsWTogdHJ1ZSxcblx0XHRkaXJlY3Rpb25Mb2NrVGhyZXNob2xkOiA1LFxuXHRcdG1vbWVudHVtOiB0cnVlLFxuXG5cdFx0Ym91bmNlOiB0cnVlLFxuXHRcdGJvdW5jZVRpbWU6IDYwMCxcblx0XHRib3VuY2VFYXNpbmc6ICcnLFxuXG5cdFx0cHJldmVudERlZmF1bHQ6IHRydWUsXG5cdFx0cHJldmVudERlZmF1bHRFeGNlcHRpb246IHsgdGFnTmFtZTogL14oSU5QVVR8VEVYVEFSRUF8QlVUVE9OfFNFTEVDVCkkLyB9LFxuXG5cdFx0SFdDb21wb3NpdGluZzogdHJ1ZSxcblx0XHR1c2VUcmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVzZVRyYW5zZm9ybTogdHJ1ZVxuXHR9O1xuXG5cdGZvciAoIHZhciBpIGluIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHRpb25zXG5cdHRoaXMudHJhbnNsYXRlWiA9IHRoaXMub3B0aW9ucy5IV0NvbXBvc2l0aW5nICYmIHV0aWxzLmhhc1BlcnNwZWN0aXZlID8gJyB0cmFuc2xhdGVaKDApJyA6ICcnO1xuXG5cdHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uID0gdXRpbHMuaGFzVHJhbnNpdGlvbiAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbjtcblx0dGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSA9IHV0aWxzLmhhc1RyYW5zZm9ybSAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtO1xuXG5cdHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT09IHRydWUgPyAndmVydGljYWwnIDogdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9ICF0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCAmJiB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ7XG5cblx0Ly8gSWYgeW91IHdhbnQgZXZlbnRQYXNzdGhyb3VnaCBJIGhhdmUgdG8gbG9jayBvbmUgb2YgdGhlIGF4ZXNcblx0dGhpcy5vcHRpb25zLnNjcm9sbFkgPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2Nyb2xsWTtcblx0dGhpcy5vcHRpb25zLnNjcm9sbFggPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgPyBmYWxzZSA6IHRoaXMub3B0aW9ucy5zY3JvbGxYO1xuXG5cdC8vIFdpdGggZXZlbnRQYXNzdGhyb3VnaCB3ZSBhbHNvIG5lZWQgbG9ja0RpcmVjdGlvbiBtZWNoYW5pc21cblx0dGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgPSB0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCAmJiAhdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPyAwIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQ7XG5cblx0dGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nID09ICdzdHJpbmcnID8gdXRpbHMuZWFzZVt0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nXSB8fCB1dGlscy5lYXNlLmNpcmN1bGFyIDogdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblxuXHR0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyA9IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nID09PSB1bmRlZmluZWQgPyA2MCA6IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nO1xuXG5cdGlmICggdGhpcy5vcHRpb25zLnRhcCA9PT0gdHJ1ZSApIHtcblx0XHR0aGlzLm9wdGlvbnMudGFwID0gJ3RhcCc7XG5cdH1cblxuXHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzID09ICdzY2FsZScgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gPSBmYWxzZTtcblx0fVxuXG5cdHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA/IC0xIDogMTtcblxuXHRpZiAoIHRoaXMub3B0aW9ucy5wcm9iZVR5cGUgPT0gMyApIHtcblx0XHR0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiA9IGZhbHNlO1x0fVxuXG4vLyBJTlNFUlQgUE9JTlQ6IE5PUk1BTElaQVRJT05cblxuXHQvLyBTb21lIGRlZmF1bHRzXHRcblx0dGhpcy54ID0gMDtcblx0dGhpcy55ID0gMDtcblx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0dGhpcy5fZXZlbnRzID0ge307XG5cbi8vIElOU0VSVCBQT0lOVDogREVGQVVMVFNcblxuXHR0aGlzLl9pbml0KCk7XG5cdHRoaXMucmVmcmVzaCgpO1xuXG5cdHRoaXMuc2Nyb2xsVG8odGhpcy5vcHRpb25zLnN0YXJ0WCwgdGhpcy5vcHRpb25zLnN0YXJ0WSk7XG5cdHRoaXMuZW5hYmxlKCk7XG59XG5cbklTY3JvbGwucHJvdG90eXBlID0ge1xuXHR2ZXJzaW9uOiAnNS4xLjMnLFxuXG5cdF9pbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyB8fCB0aGlzLm9wdGlvbnMuaW5kaWNhdG9ycyApIHtcblx0XHRcdHRoaXMuX2luaXRJbmRpY2F0b3JzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubW91c2VXaGVlbCApIHtcblx0XHRcdHRoaXMuX2luaXRXaGVlbCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgKSB7XG5cdFx0XHR0aGlzLl9pbml0U25hcCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzICkge1xuXHRcdFx0dGhpcy5faW5pdEtleXMoKTtcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX2luaXRcblxuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdkZXN0cm95Jyk7XG5cdH0sXG5cblx0X3RyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCBlLnRhcmdldCAhPSB0aGlzLnNjcm9sbGVyIHx8ICF0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKCk7XG5cdFx0aWYgKCAhdGhpcy5yZXNldFBvc2l0aW9uKHRoaXMub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBSZWFjdCB0byBsZWZ0IG1vdXNlIGJ1dHRvbiBvbmx5XG5cdFx0aWYgKCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPSAxICkge1xuXHRcdFx0aWYgKCBlLmJ1dHRvbiAhPT0gMCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCAodGhpcy5pbml0aWF0ZWQgJiYgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAmJiAhdXRpbHMuaXNCYWRBbmRyb2lkICYmICF1dGlscy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbihlLnRhcmdldCwgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0cG9zO1xuXG5cdFx0dGhpcy5pbml0aWF0ZWRcdD0gdXRpbHMuZXZlbnRUeXBlW2UudHlwZV07XG5cdFx0dGhpcy5tb3ZlZFx0XHQ9IGZhbHNlO1xuXHRcdHRoaXMuZGlzdFhcdFx0PSAwO1xuXHRcdHRoaXMuZGlzdFlcdFx0PSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9IDA7XG5cblx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSgpO1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHR0aGlzLnN0b3BwZWRUcmFuc2l0aW9uID0gZmFsc2Vcblx0XHRpZiAoIHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRoaXMuaXNJblRyYW5zaXRpb24gKSB7XG5cdFx0XHR0aGlzLnN0b3BwZWRUcmFuc2l0aW9uID0gdHJ1ZVxuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IGZhbHNlO1xuXHRcdFx0cG9zID0gdGhpcy5nZXRDb21wdXRlZFBvc2l0aW9uKCk7XG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoTWF0aC5yb3VuZChwb3MueCksIE1hdGgucm91bmQocG9zLnkpKTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fSBlbHNlIGlmICggIXRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRoaXMuaXNBbmltYXRpbmcgKSB7XG5cdFx0XHR0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RhcnRYICAgID0gdGhpcy54O1xuXHRcdHRoaXMuc3RhcnRZICAgID0gdGhpcy55O1xuXHRcdHRoaXMuYWJzU3RhcnRYID0gdGhpcy54O1xuXHRcdHRoaXMuYWJzU3RhcnRZID0gdGhpcy55O1xuXHRcdHRoaXMucG9pbnRYICAgID0gcG9pbnQucGFnZVg7XG5cdFx0dGhpcy5wb2ludFkgICAgPSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuX2V4ZWNFdmVudCgnYmVmb3JlU2Nyb2xsU3RhcnQnKTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ICkge1x0Ly8gaW5jcmVhc2VzIHBlcmZvcm1hbmNlIG9uIEFuZHJvaWQ/IFRPRE86IGNoZWNrIVxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHZhciBwb2ludFx0XHQ9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG5cdFx0XHRkZWx0YVhcdFx0PSBwb2ludC5wYWdlWCAtIHRoaXMucG9pbnRYLFxuXHRcdFx0ZGVsdGFZXHRcdD0gcG9pbnQucGFnZVkgLSB0aGlzLnBvaW50WSxcblx0XHRcdHRpbWVzdGFtcFx0PSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0YWJzRGlzdFgsIGFic0Rpc3RZO1xuXG5cdFx0dGhpcy5wb2ludFhcdFx0PSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLnBvaW50WVx0XHQ9IHBvaW50LnBhZ2VZO1xuXG5cdFx0dGhpcy5kaXN0WFx0XHQrPSBkZWx0YVg7XG5cdFx0dGhpcy5kaXN0WVx0XHQrPSBkZWx0YVk7XG5cdFx0YWJzRGlzdFhcdFx0PSBNYXRoLmFicyh0aGlzLmRpc3RYKTtcblx0XHRhYnNEaXN0WVx0XHQ9IE1hdGguYWJzKHRoaXMuZGlzdFkpO1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBtb3ZlIGF0IGxlYXN0IDEwIHBpeGVscyBmb3IgdGhlIHNjcm9sbGluZyB0byBpbml0aWF0ZVxuXHRcdGlmICggdGltZXN0YW1wIC0gdGhpcy5lbmRUaW1lID4gMzAwICYmIChhYnNEaXN0WCA8IDEwICYmIGFic0Rpc3RZIDwgMTApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHlvdSBhcmUgc2Nyb2xsaW5nIGluIG9uZSBkaXJlY3Rpb24gbG9jayB0aGUgb3RoZXJcblx0XHRpZiAoICF0aGlzLmRpcmVjdGlvbkxvY2tlZCAmJiAhdGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgKSB7XG5cdFx0XHRpZiAoIGFic0Rpc3RYID4gYWJzRGlzdFkgKyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZCApIHtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAnaCc7XHRcdC8vIGxvY2sgaG9yaXpvbnRhbGx5XG5cdFx0XHR9IGVsc2UgaWYgKCBhYnNEaXN0WSA+PSBhYnNEaXN0WCArIHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkICkge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICd2JztcdFx0Ly8gbG9jayB2ZXJ0aWNhbGx5XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICduJztcdFx0Ly8gbm8gbG9ja1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kaXJlY3Rpb25Mb2NrZWQgPT0gJ2gnICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgKSB7XG5cdFx0XHRcdHRoaXMuaW5pdGlhdGVkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGFZID0gMDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmRpcmVjdGlvbkxvY2tlZCA9PSAndicgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICdob3Jpem9udGFsJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ3ZlcnRpY2FsJyApIHtcblx0XHRcdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YVggPSAwO1xuXHRcdH1cblxuXHRcdGRlbHRhWCA9IHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IGRlbHRhWCA6IDA7XG5cdFx0ZGVsdGFZID0gdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCA/IGRlbHRhWSA6IDA7XG5cblx0XHRuZXdYID0gdGhpcy54ICsgZGVsdGFYO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBkZWx0YVk7XG5cblx0XHQvLyBTbG93IGRvd24gaWYgb3V0c2lkZSBvZiB0aGUgYm91bmRhcmllc1xuXHRcdGlmICggbmV3WCA+IDAgfHwgbmV3WCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdG5ld1ggPSB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy54ICsgZGVsdGFYIC8gMyA6IG5ld1ggPiAwID8gMCA6IHRoaXMubWF4U2Nyb2xsWDtcblx0XHR9XG5cdFx0aWYgKCBuZXdZID4gMCB8fCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLnkgKyBkZWx0YVkgLyAzIDogbmV3WSA+IDAgPyAwIDogdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IGRlbHRhWCA+IDAgPyAtMSA6IGRlbHRhWCA8IDAgPyAxIDogMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSBkZWx0YVkgPiAwID8gLTEgOiBkZWx0YVkgPCAwID8gMSA6IDA7XG5cblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxTdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubW92ZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy5fdHJhbnNsYXRlKG5ld1gsIG5ld1kpO1xuXG4vKiBSRVBMQUNFIFNUQVJUOiBfbW92ZSAqL1xuXHRcdGlmICggdGltZXN0YW1wIC0gdGhpcy5zdGFydFRpbWUgPiAzMDAgKSB7XG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcblx0XHRcdHRoaXMuc3RhcnRYID0gdGhpcy54O1xuXHRcdFx0dGhpcy5zdGFydFkgPSB0aGlzLnk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnByb2JlVHlwZSA9PSAxICkge1xuXHRcdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnByb2JlVHlwZSA+IDEgKSB7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdH1cbi8qIFJFUExBQ0UgRU5EOiBfbW92ZSAqL1xuXG5cdH0sXG5cblx0X2VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ICYmICF1dGlscy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbihlLnRhcmdldCwgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnQgPSBlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGUsXG5cdFx0XHRtb21lbnR1bVgsXG5cdFx0XHRtb21lbnR1bVksXG5cdFx0XHRkdXJhdGlvbiA9IHV0aWxzLmdldFRpbWUoKSAtIHRoaXMuc3RhcnRUaW1lLFxuXHRcdFx0bmV3WCA9IE1hdGgucm91bmQodGhpcy54KSxcblx0XHRcdG5ld1kgPSBNYXRoLnJvdW5kKHRoaXMueSksXG5cdFx0XHRkaXN0YW5jZVggPSBNYXRoLmFicyhuZXdYIC0gdGhpcy5zdGFydFgpLFxuXHRcdFx0ZGlzdGFuY2VZID0gTWF0aC5hYnMobmV3WSAtIHRoaXMuc3RhcnRZKSxcblx0XHRcdHRpbWUgPSAwLFxuXHRcdFx0ZWFzaW5nID0gJyc7XG5cblx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gMDtcblx0XHR0aGlzLmluaXRpYXRlZCA9IDA7XG5cdFx0dGhpcy5lbmRUaW1lID0gdXRpbHMuZ2V0VGltZSgpO1xuXG5cdFx0Ly8gcmVzZXQgaWYgd2UgYXJlIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJpZXNcblx0XHRpZiAoIHRoaXMucmVzZXRQb3NpdGlvbih0aGlzLm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxUbyhuZXdYLCBuZXdZKTtcdC8vIGVuc3VyZXMgdGhhdCB0aGUgbGFzdCBwb3NpdGlvbiBpcyByb3VuZGVkXG5cblx0XHQvLyB3ZSBzY3JvbGxlZCBsZXNzIHRoYW4gMTAgcGl4ZWxzXG5cdFx0aWYgKCAhdGhpcy5tb3ZlZCApIHtcblx0XHRcdGlmICggIXRoaXMuc3RvcHBlZFRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnRhcCApIHtcblx0XHRcdFx0XHR1dGlscy50YXAoZSwgdGhpcy5vcHRpb25zLnRhcCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5jbGljayApIHtcblx0XHRcdFx0XHR1dGlscy5jbGljayhlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbENhbmNlbCcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fZXZlbnRzLmZsaWNrICYmIGR1cmF0aW9uIDwgMjAwICYmIGRpc3RhbmNlWCA8IDEwMCAmJiBkaXN0YW5jZVkgPCAxMDAgKSB7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ2ZsaWNrJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gc3RhcnQgbW9tZW50dW0gYW5pbWF0aW9uIGlmIG5lZWRlZFxuXHRcdGlmICggdGhpcy5vcHRpb25zLm1vbWVudHVtICYmIGR1cmF0aW9uIDwgMzAwICkge1xuXHRcdFx0bW9tZW50dW1YID0gdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsID8gdXRpbHMubW9tZW50dW0odGhpcy54LCB0aGlzLnN0YXJ0WCwgZHVyYXRpb24sIHRoaXMubWF4U2Nyb2xsWCwgdGhpcy5vcHRpb25zLmJvdW5jZSA/IHRoaXMud3JhcHBlcldpZHRoIDogMCwgdGhpcy5vcHRpb25zLmRlY2VsZXJhdGlvbikgOiB7IGRlc3RpbmF0aW9uOiBuZXdYLCBkdXJhdGlvbjogMCB9O1xuXHRcdFx0bW9tZW50dW1ZID0gdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCA/IHV0aWxzLm1vbWVudHVtKHRoaXMueSwgdGhpcy5zdGFydFksIGR1cmF0aW9uLCB0aGlzLm1heFNjcm9sbFksIHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLndyYXBwZXJIZWlnaHQgOiAwLCB0aGlzLm9wdGlvbnMuZGVjZWxlcmF0aW9uKSA6IHsgZGVzdGluYXRpb246IG5ld1ksIGR1cmF0aW9uOiAwIH07XG5cdFx0XHRuZXdYID0gbW9tZW50dW1YLmRlc3RpbmF0aW9uO1xuXHRcdFx0bmV3WSA9IG1vbWVudHVtWS5kZXN0aW5hdGlvbjtcblx0XHRcdHRpbWUgPSBNYXRoLm1heChtb21lbnR1bVguZHVyYXRpb24sIG1vbWVudHVtWS5kdXJhdGlvbik7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gMTtcblx0XHR9XG5cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgKSB7XG5cdFx0XHR2YXIgc25hcCA9IHRoaXMuX25lYXJlc3RTbmFwKG5ld1gsIG5ld1kpO1xuXHRcdFx0dGhpcy5jdXJyZW50UGFnZSA9IHNuYXA7XG5cdFx0XHR0aW1lID0gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdFx0XHRNYXRoLm1heChcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKG5ld1ggLSBzbmFwLngpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKG5ld1kgLSBzbmFwLnkpLCAxMDAwKVxuXHRcdFx0XHRcdCksIDMwMCk7XG5cdFx0XHRuZXdYID0gc25hcC54O1xuXHRcdFx0bmV3WSA9IHNuYXAueTtcblxuXHRcdFx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0XHRcdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cdFx0XHRlYXNpbmcgPSB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nO1xuXHRcdH1cblxuLy8gSU5TRVJUIFBPSU5UOiBfZW5kXG5cblx0XHRpZiAoIG5ld1ggIT0gdGhpcy54IHx8IG5ld1kgIT0gdGhpcy55ICkge1xuXHRcdFx0Ly8gY2hhbmdlIGVhc2luZyBmdW5jdGlvbiB3aGVuIHNjcm9sbGVyIGdvZXMgb3V0IG9mIHRoZSBib3VuZGFyaWVzXG5cdFx0XHRpZiAoIG5ld1ggPiAwIHx8IG5ld1ggPCB0aGlzLm1heFNjcm9sbFggfHwgbmV3WSA+IDAgfHwgbmV3WSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdFx0ZWFzaW5nID0gdXRpbHMuZWFzZS5xdWFkcmF0aWM7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2Nyb2xsVG8obmV3WCwgbmV3WSwgdGltZSwgZWFzaW5nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHR9LFxuXG5cdF9yZXNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcblxuXHRcdHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5yZWZyZXNoKCk7XG5cdFx0fSwgdGhpcy5vcHRpb25zLnJlc2l6ZVBvbGxpbmcpO1xuXHR9LFxuXG5cdHJlc2V0UG9zaXRpb246IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0dmFyIHggPSB0aGlzLngsXG5cdFx0XHR5ID0gdGhpcy55O1xuXG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblxuXHRcdGlmICggIXRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCB8fCB0aGlzLnggPiAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy54IDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0eCA9IHRoaXMubWF4U2Nyb2xsWDtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsIHx8IHRoaXMueSA+IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnkgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHR5ID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdGlmICggeCA9PSB0aGlzLnggJiYgeSA9PSB0aGlzLnkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxUbyh4LCB5LCB0aW1lLCB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmYgPSB0aGlzLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1x0XHQvLyBGb3JjZSByZWZsb3dcblxuXHRcdHRoaXMud3JhcHBlcldpZHRoXHQ9IHRoaXMud3JhcHBlci5jbGllbnRXaWR0aDtcblx0XHR0aGlzLndyYXBwZXJIZWlnaHRcdD0gdGhpcy53cmFwcGVyLmNsaWVudEhlaWdodDtcblxuLyogUkVQTEFDRSBTVEFSVDogcmVmcmVzaCAqL1xuXG5cdFx0dGhpcy5zY3JvbGxlcldpZHRoXHQ9IHRoaXMuc2Nyb2xsZXIub2Zmc2V0V2lkdGg7XG5cdFx0dGhpcy5zY3JvbGxlckhlaWdodFx0PSB0aGlzLnNjcm9sbGVyLm9mZnNldEhlaWdodDtcblxuXHRcdHRoaXMubWF4U2Nyb2xsWFx0XHQ9IHRoaXMud3JhcHBlcldpZHRoIC0gdGhpcy5zY3JvbGxlcldpZHRoO1xuXHRcdHRoaXMubWF4U2Nyb2xsWVx0XHQ9IHRoaXMud3JhcHBlckhlaWdodCAtIHRoaXMuc2Nyb2xsZXJIZWlnaHQ7XG5cbi8qIFJFUExBQ0UgRU5EOiByZWZyZXNoICovXG5cblx0XHR0aGlzLmhhc0hvcml6b250YWxTY3JvbGxcdD0gdGhpcy5vcHRpb25zLnNjcm9sbFggJiYgdGhpcy5tYXhTY3JvbGxYIDwgMDtcblx0XHR0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsXHRcdD0gdGhpcy5vcHRpb25zLnNjcm9sbFkgJiYgdGhpcy5tYXhTY3JvbGxZIDwgMDtcblxuXHRcdGlmICggIXRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCApIHtcblx0XHRcdHRoaXMubWF4U2Nyb2xsWCA9IDA7XG5cdFx0XHR0aGlzLnNjcm9sbGVyV2lkdGggPSB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0dGhpcy5tYXhTY3JvbGxZID0gMDtcblx0XHRcdHRoaXMuc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLndyYXBwZXJIZWlnaHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbmRUaW1lID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cblx0XHR0aGlzLndyYXBwZXJPZmZzZXQgPSB1dGlscy5vZmZzZXQodGhpcy53cmFwcGVyKTtcblxuXHRcdHRoaXMuX2V4ZWNFdmVudCgncmVmcmVzaCcpO1xuXG5cdFx0dGhpcy5yZXNldFBvc2l0aW9uKCk7XG5cbi8vIElOU0VSVCBQT0lOVDogX3JlZnJlc2hcblxuXHR9LFxuXG5cdG9uOiBmdW5jdGlvbiAodHlwZSwgZm4pIHtcblx0XHRpZiAoICF0aGlzLl9ldmVudHNbdHlwZV0gKSB7XG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcblx0XHR9XG5cblx0XHR0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChmbik7XG5cdH0sXG5cblx0b2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4pIHtcblx0XHRpZiAoICF0aGlzLl9ldmVudHNbdHlwZV0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fZXZlbnRzW3R5cGVdLmluZGV4T2YoZm4pO1xuXG5cdFx0aWYgKCBpbmRleCA+IC0xICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9leGVjRXZlbnQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpID0gMCxcblx0XHRcdGwgPSB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuXG5cdFx0aWYgKCAhbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV1baV0uYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHR9XG5cdH0sXG5cblx0c2Nyb2xsQnk6IGZ1bmN0aW9uICh4LCB5LCB0aW1lLCBlYXNpbmcpIHtcblx0XHR4ID0gdGhpcy54ICsgeDtcblx0XHR5ID0gdGhpcy55ICsgeTtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXG5cdFx0dGhpcy5zY3JvbGxUbyh4LCB5LCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdHNjcm9sbFRvOiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0ZWFzaW5nID0gZWFzaW5nIHx8IHV0aWxzLmVhc2UuY2lyY3VsYXI7XG5cblx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGltZSA+IDA7XG5cblx0XHRpZiAoICF0aW1lIHx8ICh0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiBlYXNpbmcuc3R5bGUpICkge1xuXHRcdFx0dGhpcy5fdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKGVhc2luZy5zdHlsZSk7XG5cdFx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSh0aW1lKTtcblx0XHRcdHRoaXMuX3RyYW5zbGF0ZSh4LCB5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYW5pbWF0ZSh4LCB5LCB0aW1lLCBlYXNpbmcuZm4pO1xuXHRcdH1cblx0fSxcblxuXHRzY3JvbGxUb0VsZW1lbnQ6IGZ1bmN0aW9uIChlbCwgdGltZSwgb2Zmc2V0WCwgb2Zmc2V0WSwgZWFzaW5nKSB7XG5cdFx0ZWwgPSBlbC5ub2RlVHlwZSA/IGVsIDogdGhpcy5zY3JvbGxlci5xdWVyeVNlbGVjdG9yKGVsKTtcblxuXHRcdGlmICggIWVsICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwb3MgPSB1dGlscy5vZmZzZXQoZWwpO1xuXG5cdFx0cG9zLmxlZnQgLT0gdGhpcy53cmFwcGVyT2Zmc2V0LmxlZnQ7XG5cdFx0cG9zLnRvcCAgLT0gdGhpcy53cmFwcGVyT2Zmc2V0LnRvcDtcblxuXHRcdC8vIGlmIG9mZnNldFgvWSBhcmUgdHJ1ZSB3ZSBjZW50ZXIgdGhlIGVsZW1lbnQgdG8gdGhlIHNjcmVlblxuXHRcdGlmICggb2Zmc2V0WCA9PT0gdHJ1ZSApIHtcblx0XHRcdG9mZnNldFggPSBNYXRoLnJvdW5kKGVsLm9mZnNldFdpZHRoIC8gMiAtIHRoaXMud3JhcHBlci5vZmZzZXRXaWR0aCAvIDIpO1xuXHRcdH1cblx0XHRpZiAoIG9mZnNldFkgPT09IHRydWUgKSB7XG5cdFx0XHRvZmZzZXRZID0gTWF0aC5yb3VuZChlbC5vZmZzZXRIZWlnaHQgLyAyIC0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodCAvIDIpO1xuXHRcdH1cblxuXHRcdHBvcy5sZWZ0IC09IG9mZnNldFggfHwgMDtcblx0XHRwb3MudG9wICAtPSBvZmZzZXRZIHx8IDA7XG5cblx0XHRwb3MubGVmdCA9IHBvcy5sZWZ0ID4gMCA/IDAgOiBwb3MubGVmdCA8IHRoaXMubWF4U2Nyb2xsWCA/IHRoaXMubWF4U2Nyb2xsWCA6IHBvcy5sZWZ0O1xuXHRcdHBvcy50b3AgID0gcG9zLnRvcCAgPiAwID8gMCA6IHBvcy50b3AgIDwgdGhpcy5tYXhTY3JvbGxZID8gdGhpcy5tYXhTY3JvbGxZIDogcG9zLnRvcDtcblxuXHRcdHRpbWUgPSB0aW1lID09PSB1bmRlZmluZWQgfHwgdGltZSA9PT0gbnVsbCB8fCB0aW1lID09PSAnYXV0bycgPyBNYXRoLm1heChNYXRoLmFicyh0aGlzLngtcG9zLmxlZnQpLCBNYXRoLmFicyh0aGlzLnktcG9zLnRvcCkpIDogdGltZTtcblxuXHRcdHRoaXMuc2Nyb2xsVG8ocG9zLmxlZnQsIHBvcy50b3AsIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0X3RyYW5zaXRpb25UaW1lOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9IHRpbWUgKyAnbXMnO1xuXG5cdFx0aWYgKCAhdGltZSAmJiB1dGlscy5pc0JhZEFuZHJvaWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9ICcwLjAwMXMnO1xuXHRcdH1cblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltZSh0aW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWVcblxuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uIChlYXNpbmcpIHtcblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZztcblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24oZWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXG5cblx0fSxcblxuXHRfdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblxuLyogUkVQTEFDRSBTVEFSVDogX3RyYW5zbGF0ZSAqL1xuXG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyArIHRoaXMudHJhbnNsYXRlWjtcblxuLyogUkVQTEFDRSBFTkQ6IF90cmFuc2xhdGUgKi9cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gTWF0aC5yb3VuZCh4KTtcblx0XHRcdHkgPSBNYXRoLnJvdW5kKHkpO1xuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuc2Nyb2xsZXJTdHlsZS50b3AgPSB5ICsgJ3B4Jztcblx0XHR9XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblxuXHRpZiAoIHRoaXMuaW5kaWNhdG9ycyApIHtcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udXBkYXRlUG9zaXRpb24oKTtcblx0XHR9XG5cdH1cblxuXG4vLyBJTlNFUlQgUE9JTlQ6IF90cmFuc2xhdGVcblxuXHR9LFxuXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0dmFyIGV2ZW50VHlwZSA9IHJlbW92ZSA/IHV0aWxzLnJlbW92ZUV2ZW50IDogdXRpbHMuYWRkRXZlbnQsXG5cdFx0XHR0YXJnZXQgPSB0aGlzLm9wdGlvbnMuYmluZFRvV3JhcHBlciA/IHRoaXMud3JhcHBlciA6IHdpbmRvdztcblxuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdyZXNpemUnLCB0aGlzKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNrICkge1xuXHRcdFx0ZXZlbnRUeXBlKHRoaXMud3JhcHBlciwgJ2NsaWNrJywgdGhpcywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVNb3VzZSApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICdtb3VzZWRvd24nLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZW1vdmUnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZWNhbmNlbCcsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoIHV0aWxzLmhhc1BvaW50ZXIgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlUG9pbnRlciApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyY2FuY2VsJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCB1dGlscy5oYXNUb3VjaCAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVUb3VjaCApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2hjYW5jZWwnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ01TVHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHR9LFxuXG5cdGdldENvbXB1dGVkUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWF0cml4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxlciwgbnVsbCksXG5cdFx0XHR4LCB5O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4W3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0uc3BsaXQoJyknKVswXS5zcGxpdCgnLCAnKTtcblx0XHRcdHggPSArKG1hdHJpeFsxMl0gfHwgbWF0cml4WzRdKTtcblx0XHRcdHkgPSArKG1hdHJpeFsxM10gfHwgbWF0cml4WzVdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9ICttYXRyaXgubGVmdC5yZXBsYWNlKC9bXi1cXGQuXS9nLCAnJyk7XG5cdFx0XHR5ID0gK21hdHJpeC50b3AucmVwbGFjZSgvW14tXFxkLl0vZywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblx0fSxcblxuXHRfaW5pdEluZGljYXRvcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaW50ZXJhY3RpdmUgPSB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmVTY3JvbGxiYXJzLFxuXHRcdFx0Y3VzdG9tU3R5bGUgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMgIT0gJ3N0cmluZycsXG5cdFx0XHRpbmRpY2F0b3JzID0gW10sXG5cdFx0XHRpbmRpY2F0b3I7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmluZGljYXRvcnMgPSBbXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMgKSB7XG5cdFx0XHQvLyBWZXJ0aWNhbCBzY3JvbGxiYXJcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbFkgKSB7XG5cdFx0XHRcdGluZGljYXRvciA9IHtcblx0XHRcdFx0XHRlbDogY3JlYXRlRGVmYXVsdFNjcm9sbGJhcigndicsIGludGVyYWN0aXZlLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyksXG5cdFx0XHRcdFx0aW50ZXJhY3RpdmU6IGludGVyYWN0aXZlLFxuXHRcdFx0XHRcdGRlZmF1bHRTY3JvbGxiYXJzOiB0cnVlLFxuXHRcdFx0XHRcdGN1c3RvbVN0eWxlOiBjdXN0b21TdHlsZSxcblx0XHRcdFx0XHRyZXNpemU6IHRoaXMub3B0aW9ucy5yZXNpemVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdHNocmluazogdGhpcy5vcHRpb25zLnNocmlua1Njcm9sbGJhcnMsXG5cdFx0XHRcdFx0ZmFkZTogdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGxpc3Rlblg6IGZhbHNlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvci5lbCk7XG5cdFx0XHRcdGluZGljYXRvcnMucHVzaChpbmRpY2F0b3IpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb3Jpem9udGFsIHNjcm9sbGJhclxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2Nyb2xsWCApIHtcblx0XHRcdFx0aW5kaWNhdG9yID0ge1xuXHRcdFx0XHRcdGVsOiBjcmVhdGVEZWZhdWx0U2Nyb2xsYmFyKCdoJywgaW50ZXJhY3RpdmUsIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzKSxcblx0XHRcdFx0XHRpbnRlcmFjdGl2ZTogaW50ZXJhY3RpdmUsXG5cdFx0XHRcdFx0ZGVmYXVsdFNjcm9sbGJhcnM6IHRydWUsXG5cdFx0XHRcdFx0Y3VzdG9tU3R5bGU6IGN1c3RvbVN0eWxlLFxuXHRcdFx0XHRcdHJlc2l6ZTogdGhpcy5vcHRpb25zLnJlc2l6ZVNjcm9sbGJhcnMsXG5cdFx0XHRcdFx0c2hyaW5rOiB0aGlzLm9wdGlvbnMuc2hyaW5rU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRmYWRlOiB0aGlzLm9wdGlvbnMuZmFkZVNjcm9sbGJhcnMsXG5cdFx0XHRcdFx0bGlzdGVuWTogZmFsc2Vcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yLmVsKTtcblx0XHRcdFx0aW5kaWNhdG9ycy5wdXNoKGluZGljYXRvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaW5kaWNhdG9ycyApIHtcblx0XHRcdC8vIFRPRE86IGNoZWNrIGNvbmNhdCBjb21wYXRpYmlsaXR5XG5cdFx0XHRpbmRpY2F0b3JzID0gaW5kaWNhdG9ycy5jb25jYXQodGhpcy5vcHRpb25zLmluZGljYXRvcnMpO1xuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvcnMucHVzaCggbmV3IEluZGljYXRvcih0aGlzLCBpbmRpY2F0b3JzW2ldKSApO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IGNoZWNrIGlmIHdlIGNhbiB1c2UgYXJyYXkubWFwICh3aWRlIGNvbXBhdGliaWxpdHkgYW5kIHBlcmZvcm1hbmNlIGlzc3Vlcylcblx0XHRmdW5jdGlvbiBfaW5kaWNhdG9yc01hcCAoZm4pIHtcblx0XHRcdGZvciAoIHZhciBpID0gdGhhdC5pbmRpY2F0b3JzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGF0LmluZGljYXRvcnNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzICkge1xuXHRcdFx0dGhpcy5vbignc2Nyb2xsRW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMub24oJ3Njcm9sbENhbmNlbCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLm9uKCdzY3JvbGxTdGFydCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgxKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbignYmVmb3JlU2Nyb2xsU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoMSwgdHJ1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cblx0XHR0aGlzLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZGVsZXRlIHRoaXMuaW5kaWNhdG9ycztcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFdoZWVsOiBmdW5jdGlvbiAoKSB7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnd2hlZWwnLCB0aGlzKTtcblx0XHR1dGlscy5hZGRFdmVudCh0aGlzLndyYXBwZXIsICdtb3VzZXdoZWVsJywgdGhpcyk7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnRE9NTW91c2VTY3JvbGwnLCB0aGlzKTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICd3aGVlbCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy53cmFwcGVyLCAnbW91c2V3aGVlbCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy53cmFwcGVyLCAnRE9NTW91c2VTY3JvbGwnLCB0aGlzKTtcblx0XHR9KTtcblx0fSxcblxuXHRfd2hlZWw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dmFyIHdoZWVsRGVsdGFYLCB3aGVlbERlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGlmICggdGhpcy53aGVlbFRpbWVvdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBFeGVjdXRlIHRoZSBzY3JvbGxFbmQgZXZlbnQgYWZ0ZXIgNDAwbXMgdGhlIHdoZWVsIHN0b3BwZWQgc2Nyb2xsaW5nXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2hlZWxUaW1lb3V0KTtcblx0XHR0aGlzLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHRcdHRoYXQud2hlZWxUaW1lb3V0ID0gdW5kZWZpbmVkO1xuXHRcdH0sIDQwMCk7XG5cblx0XHRpZiAoICdkZWx0YVgnIGluIGUgKSB7XG5cdFx0XHRpZiAoZS5kZWx0YU1vZGUgPT09IDEpIHtcblx0XHRcdFx0d2hlZWxEZWx0YVggPSAtZS5kZWx0YVggKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdFx0XHR3aGVlbERlbHRhWSA9IC1lLmRlbHRhWSAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGVlbERlbHRhWCA9IC1lLmRlbHRhWDtcblx0XHRcdFx0d2hlZWxEZWx0YVkgPSAtZS5kZWx0YVk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggJ3doZWVsRGVsdGFYJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSBlLndoZWVsRGVsdGFYIC8gMTIwICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHRcdHdoZWVsRGVsdGFZID0gZS53aGVlbERlbHRhWSAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0fSBlbHNlIGlmICggJ3doZWVsRGVsdGEnIGluIGUgKSB7XG5cdFx0XHR3aGVlbERlbHRhWCA9IHdoZWVsRGVsdGFZID0gZS53aGVlbERlbHRhIC8gMTIwICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHR9IGVsc2UgaWYgKCAnZGV0YWlsJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWSA9IC1lLmRldGFpbCAvIDMgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0d2hlZWxEZWx0YVggKj0gdGhpcy5vcHRpb25zLmludmVydFdoZWVsRGlyZWN0aW9uO1xuXHRcdHdoZWVsRGVsdGFZICo9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbjtcblxuXHRcdGlmICggIXRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR3aGVlbERlbHRhWCA9IHdoZWVsRGVsdGFZO1xuXHRcdFx0d2hlZWxEZWx0YVkgPSAwO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWDtcblx0XHRcdG5ld1kgPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZO1xuXG5cdFx0XHRpZiAoIHdoZWVsRGVsdGFYID4gMCApIHtcblx0XHRcdFx0bmV3WC0tO1xuXHRcdFx0fSBlbHNlIGlmICggd2hlZWxEZWx0YVggPCAwICkge1xuXHRcdFx0XHRuZXdYKys7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2hlZWxEZWx0YVkgPiAwICkge1xuXHRcdFx0XHRuZXdZLS07XG5cdFx0XHR9IGVsc2UgaWYgKCB3aGVlbERlbHRhWSA8IDAgKSB7XG5cdFx0XHRcdG5ld1krKztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5nb1RvUGFnZShuZXdYLCBuZXdZKTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5ld1ggPSB0aGlzLnggKyBNYXRoLnJvdW5kKHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IHdoZWVsRGVsdGFYIDogMCk7XG5cdFx0bmV3WSA9IHRoaXMueSArIE1hdGgucm91bmQodGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCA/IHdoZWVsRGVsdGFZIDogMCk7XG5cblx0XHRpZiAoIG5ld1ggPiAwICkge1xuXHRcdFx0bmV3WCA9IDA7XG5cdFx0fSBlbHNlIGlmICggbmV3WCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdG5ld1ggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdZID4gMCApIHtcblx0XHRcdG5ld1kgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRuZXdZID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8obmV3WCwgbmV3WSwgMCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcm9iZVR5cGUgPiAxICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX3doZWVsXG5cdH0sXG5cblx0X2luaXRTbmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jdXJyZW50UGFnZSA9IHt9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLnNuYXAgPT0gJ3N0cmluZycgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc25hcCA9IHRoaXMuc2Nyb2xsZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc25hcCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBpID0gMCwgbCxcblx0XHRcdFx0bSA9IDAsIG4sXG5cdFx0XHRcdGN4LCBjeSxcblx0XHRcdFx0eCA9IDAsIHksXG5cdFx0XHRcdHN0ZXBYID0gdGhpcy5vcHRpb25zLnNuYXBTdGVwWCB8fCB0aGlzLndyYXBwZXJXaWR0aCxcblx0XHRcdFx0c3RlcFkgPSB0aGlzLm9wdGlvbnMuc25hcFN0ZXBZIHx8IHRoaXMud3JhcHBlckhlaWdodCxcblx0XHRcdFx0ZWw7XG5cblx0XHRcdHRoaXMucGFnZXMgPSBbXTtcblxuXHRcdFx0aWYgKCAhdGhpcy53cmFwcGVyV2lkdGggfHwgIXRoaXMud3JhcHBlckhlaWdodCB8fCAhdGhpcy5zY3JvbGxlcldpZHRoIHx8ICF0aGlzLnNjcm9sbGVySGVpZ2h0ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgPT09IHRydWUgKSB7XG5cdFx0XHRcdGN4ID0gTWF0aC5yb3VuZCggc3RlcFggLyAyICk7XG5cdFx0XHRcdGN5ID0gTWF0aC5yb3VuZCggc3RlcFkgLyAyICk7XG5cblx0XHRcdFx0d2hpbGUgKCB4ID4gLXRoaXMuc2Nyb2xsZXJXaWR0aCApIHtcblx0XHRcdFx0XHR0aGlzLnBhZ2VzW2ldID0gW107XG5cdFx0XHRcdFx0bCA9IDA7XG5cdFx0XHRcdFx0eSA9IDA7XG5cblx0XHRcdFx0XHR3aGlsZSAoIHkgPiAtdGhpcy5zY3JvbGxlckhlaWdodCApIHtcblx0XHRcdFx0XHRcdHRoaXMucGFnZXNbaV1bbF0gPSB7XG5cdFx0XHRcdFx0XHRcdHg6IE1hdGgubWF4KHgsIHRoaXMubWF4U2Nyb2xsWCksXG5cdFx0XHRcdFx0XHRcdHk6IE1hdGgubWF4KHksIHRoaXMubWF4U2Nyb2xsWSksXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBzdGVwWCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBzdGVwWSxcblx0XHRcdFx0XHRcdFx0Y3g6IHggLSBjeCxcblx0XHRcdFx0XHRcdFx0Y3k6IHkgLSBjeVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0eSAtPSBzdGVwWTtcblx0XHRcdFx0XHRcdGwrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR4IC09IHN0ZXBYO1xuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwgPSB0aGlzLm9wdGlvbnMuc25hcDtcblx0XHRcdFx0bCA9IGVsLmxlbmd0aDtcblx0XHRcdFx0biA9IC0xO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGkgPT09IDAgfHwgZWxbaV0ub2Zmc2V0TGVmdCA8PSBlbFtpLTFdLm9mZnNldExlZnQgKSB7XG5cdFx0XHRcdFx0XHRtID0gMDtcblx0XHRcdFx0XHRcdG4rKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICF0aGlzLnBhZ2VzW21dICkge1xuXHRcdFx0XHRcdFx0dGhpcy5wYWdlc1ttXSA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHggPSBNYXRoLm1heCgtZWxbaV0ub2Zmc2V0TGVmdCwgdGhpcy5tYXhTY3JvbGxYKTtcblx0XHRcdFx0XHR5ID0gTWF0aC5tYXgoLWVsW2ldLm9mZnNldFRvcCwgdGhpcy5tYXhTY3JvbGxZKTtcblx0XHRcdFx0XHRjeCA9IHggLSBNYXRoLnJvdW5kKGVsW2ldLm9mZnNldFdpZHRoIC8gMik7XG5cdFx0XHRcdFx0Y3kgPSB5IC0gTWF0aC5yb3VuZChlbFtpXS5vZmZzZXRIZWlnaHQgLyAyKTtcblxuXHRcdFx0XHRcdHRoaXMucGFnZXNbbV1bbl0gPSB7XG5cdFx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdFx0eTogeSxcblx0XHRcdFx0XHRcdHdpZHRoOiBlbFtpXS5vZmZzZXRXaWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogZWxbaV0ub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHRcdFx0Y3g6IGN4LFxuXHRcdFx0XHRcdFx0Y3k6IGN5XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmICggeCA+IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdFx0XHRcdG0rKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5nb1RvUGFnZSh0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYIHx8IDAsIHRoaXMuY3VycmVudFBhZ2UucGFnZVkgfHwgMCwgMCk7XG5cblx0XHRcdC8vIFVwZGF0ZSBzbmFwIHRocmVzaG9sZCBpZiBuZWVkZWRcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQgJSAxID09PSAwICkge1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRYID0gdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQ7XG5cdFx0XHRcdHRoaXMuc25hcFRocmVzaG9sZFkgPSB0aGlzLm9wdGlvbnMuc25hcFRocmVzaG9sZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc25hcFRocmVzaG9sZFggPSBNYXRoLnJvdW5kKHRoaXMucGFnZXNbdGhpcy5jdXJyZW50UGFnZS5wYWdlWF1bdGhpcy5jdXJyZW50UGFnZS5wYWdlWV0ud2lkdGggKiB0aGlzLm9wdGlvbnMuc25hcFRocmVzaG9sZCk7XG5cdFx0XHRcdHRoaXMuc25hcFRocmVzaG9sZFkgPSBNYXRoLnJvdW5kKHRoaXMucGFnZXNbdGhpcy5jdXJyZW50UGFnZS5wYWdlWF1bdGhpcy5jdXJyZW50UGFnZS5wYWdlWV0uaGVpZ2h0ICogdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5vbignZmxpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnggLSB0aGlzLnN0YXJ0WCksIDEwMDApLFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy55IC0gdGhpcy5zdGFydFkpLCAxMDAwKVxuXHRcdFx0XHRcdCksIDMwMCk7XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UoXG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UucGFnZVggKyB0aGlzLmRpcmVjdGlvblgsXG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UucGFnZVkgKyB0aGlzLmRpcmVjdGlvblksXG5cdFx0XHRcdHRpbWVcblx0XHRcdCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X25lYXJlc3RTbmFwOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggIXRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgeDogMCwgeTogMCwgcGFnZVg6IDAsIHBhZ2VZOiAwIH07XG5cdFx0fVxuXG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMucGFnZXMubGVuZ3RoLFxuXHRcdFx0bSA9IDA7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSBleGNlZWRlZCB0aGUgc25hcCB0aHJlc2hvbGRcblx0XHRpZiAoIE1hdGguYWJzKHggLSB0aGlzLmFic1N0YXJ0WCkgPCB0aGlzLnNuYXBUaHJlc2hvbGRYICYmXG5cdFx0XHRNYXRoLmFicyh5IC0gdGhpcy5hYnNTdGFydFkpIDwgdGhpcy5zbmFwVGhyZXNob2xkWSApIHtcblx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRQYWdlO1xuXHRcdH1cblxuXHRcdGlmICggeCA+IDAgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB4IDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0eCA9IHRoaXMubWF4U2Nyb2xsWDtcblx0XHR9XG5cblx0XHRpZiAoIHkgPiAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggeSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdHkgPSB0aGlzLm1heFNjcm9sbFk7XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0aWYgKCB4ID49IHRoaXMucGFnZXNbaV1bMF0uY3ggKSB7XG5cdFx0XHRcdHggPSB0aGlzLnBhZ2VzW2ldWzBdLng7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGwgPSB0aGlzLnBhZ2VzW2ldLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgbSA8IGw7IG0rKyApIHtcblx0XHRcdGlmICggeSA+PSB0aGlzLnBhZ2VzWzBdW21dLmN5ICkge1xuXHRcdFx0XHR5ID0gdGhpcy5wYWdlc1swXVttXS55O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGkgPT0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCApIHtcblx0XHRcdGkgKz0gdGhpcy5kaXJlY3Rpb25YO1xuXG5cdFx0XHRpZiAoIGkgPCAwICkge1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdH0gZWxzZSBpZiAoIGkgPj0gdGhpcy5wYWdlcy5sZW5ndGggKSB7XG5cdFx0XHRcdGkgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XG5cdFx0XHR9XG5cblx0XHRcdHggPSB0aGlzLnBhZ2VzW2ldWzBdLng7XG5cdFx0fVxuXG5cdFx0aWYgKCBtID09IHRoaXMuY3VycmVudFBhZ2UucGFnZVkgKSB7XG5cdFx0XHRtICs9IHRoaXMuZGlyZWN0aW9uWTtcblxuXHRcdFx0aWYgKCBtIDwgMCApIHtcblx0XHRcdFx0bSA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCBtID49IHRoaXMucGFnZXNbMF0ubGVuZ3RoICkge1xuXHRcdFx0XHRtID0gdGhpcy5wYWdlc1swXS5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXG5cdFx0XHR5ID0gdGhpcy5wYWdlc1swXVttXS55O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeSxcblx0XHRcdHBhZ2VYOiBpLFxuXHRcdFx0cGFnZVk6IG1cblx0XHR9O1xuXHR9LFxuXG5cdGdvVG9QYWdlOiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0ZWFzaW5nID0gZWFzaW5nIHx8IHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmc7XG5cblx0XHRpZiAoIHggPj0gdGhpcy5wYWdlcy5sZW5ndGggKSB7XG5cdFx0XHR4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSBpZiAoIHggPCAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCB5ID49IHRoaXMucGFnZXNbeF0ubGVuZ3RoICkge1xuXHRcdFx0eSA9IHRoaXMucGFnZXNbeF0ubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKCB5IDwgMCApIHtcblx0XHRcdHkgPSAwO1xuXHRcdH1cblxuXHRcdHZhciBwb3NYID0gdGhpcy5wYWdlc1t4XVt5XS54LFxuXHRcdFx0cG9zWSA9IHRoaXMucGFnZXNbeF1beV0ueTtcblxuXHRcdHRpbWUgPSB0aW1lID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHBvc1ggLSB0aGlzLngpLCAxMDAwKSxcblx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnMocG9zWSAtIHRoaXMueSksIDEwMDApXG5cdFx0XHQpLCAzMDApIDogdGltZTtcblxuXHRcdHRoaXMuY3VycmVudFBhZ2UgPSB7XG5cdFx0XHR4OiBwb3NYLFxuXHRcdFx0eTogcG9zWSxcblx0XHRcdHBhZ2VYOiB4LFxuXHRcdFx0cGFnZVk6IHlcblx0XHR9O1xuXG5cdFx0dGhpcy5zY3JvbGxUbyhwb3NYLCBwb3NZLCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdG5leHQ6IGZ1bmN0aW9uICh0aW1lLCBlYXNpbmcpIHtcblx0XHR2YXIgeCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVgsXG5cdFx0XHR5ID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdHgrKztcblxuXHRcdGlmICggeCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCAmJiB0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0XHR5Kys7XG5cdFx0fVxuXG5cdFx0dGhpcy5nb1RvUGFnZSh4LCB5LCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdHByZXY6IGZ1bmN0aW9uICh0aW1lLCBlYXNpbmcpIHtcblx0XHR2YXIgeCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVgsXG5cdFx0XHR5ID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdHgtLTtcblxuXHRcdGlmICggeCA8IDAgJiYgdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eS0tO1xuXHRcdH1cblxuXHRcdHRoaXMuZ29Ub1BhZ2UoeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRfaW5pdEtleXM6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gZGVmYXVsdCBrZXkgYmluZGluZ3Ncblx0XHR2YXIga2V5cyA9IHtcblx0XHRcdHBhZ2VVcDogMzMsXG5cdFx0XHRwYWdlRG93bjogMzQsXG5cdFx0XHRlbmQ6IDM1LFxuXHRcdFx0aG9tZTogMzYsXG5cdFx0XHRsZWZ0OiAzNyxcblx0XHRcdHVwOiAzOCxcblx0XHRcdHJpZ2h0OiAzOSxcblx0XHRcdGRvd246IDQwXG5cdFx0fTtcblx0XHR2YXIgaTtcblxuXHRcdC8vIGlmIHlvdSBnaXZlIG1lIGNoYXJhY3RlcnMgSSBnaXZlIHlvdSBrZXljb2RlXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzID09ICdvYmplY3QnICkge1xuXHRcdFx0Zm9yICggaSBpbiB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5nc1tpXSA9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyA9IHt9O1xuXHRcdH1cblxuXHRcdGZvciAoIGkgaW4ga2V5cyApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5rZXlCaW5kaW5nc1tpXSA9IHRoaXMub3B0aW9ucy5rZXlCaW5kaW5nc1tpXSB8fCBrZXlzW2ldO1xuXHRcdH1cblxuXHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgJ2tleWRvd24nLCB0aGlzKTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICdrZXlkb3duJywgdGhpcyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2tleTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNuYXAgPSB0aGlzLm9wdGlvbnMuc25hcCxcdC8vIHdlIGFyZSB1c2luZyB0aGlzIGFsb3QsIGJldHRlciB0byBjYWNoZSBpdFxuXHRcdFx0bmV3WCA9IHNuYXAgPyB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYIDogdGhpcy54LFxuXHRcdFx0bmV3WSA9IHNuYXAgPyB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZIDogdGhpcy55LFxuXHRcdFx0bm93ID0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0cHJldlRpbWUgPSB0aGlzLmtleVRpbWUgfHwgMCxcblx0XHRcdGFjY2VsZXJhdGlvbiA9IDAuMjUwLFxuXHRcdFx0cG9zO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiB0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0cG9zID0gdGhpcy5nZXRDb21wdXRlZFBvc2l0aW9uKCk7XG5cblx0XHRcdHRoaXMuX3RyYW5zbGF0ZShNYXRoLnJvdW5kKHBvcy54KSwgTWF0aC5yb3VuZChwb3MueSkpO1xuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gbm93IC0gcHJldlRpbWUgPCAyMDAgPyBNYXRoLm1pbih0aGlzLmtleUFjY2VsZXJhdGlvbiArIGFjY2VsZXJhdGlvbiwgNTApIDogMDtcblxuXHRcdHN3aXRjaCAoIGUua2V5Q29kZSApIHtcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLnBhZ2VVcDpcblx0XHRcdFx0aWYgKCB0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgJiYgIXRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHRcdFx0bmV3WCArPSBzbmFwID8gMSA6IHRoaXMud3JhcHBlcldpZHRoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1kgKz0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5wYWdlRG93bjpcblx0XHRcdFx0aWYgKCB0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgJiYgIXRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHRcdFx0bmV3WCAtPSBzbmFwID8gMSA6IHRoaXMud3JhcHBlcldpZHRoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1kgLT0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5lbmQ6XG5cdFx0XHRcdG5ld1ggPSBzbmFwID8gdGhpcy5wYWdlcy5sZW5ndGgtMSA6IHRoaXMubWF4U2Nyb2xsWDtcblx0XHRcdFx0bmV3WSA9IHNuYXAgPyB0aGlzLnBhZ2VzWzBdLmxlbmd0aC0xIDogdGhpcy5tYXhTY3JvbGxZO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmhvbWU6XG5cdFx0XHRcdG5ld1ggPSAwO1xuXHRcdFx0XHRuZXdZID0gMDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5sZWZ0OlxuXHRcdFx0XHRuZXdYICs9IHNuYXAgPyAtMSA6IDUgKyB0aGlzLmtleUFjY2VsZXJhdGlvbj4+MDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy51cDpcblx0XHRcdFx0bmV3WSArPSBzbmFwID8gMSA6IDUgKyB0aGlzLmtleUFjY2VsZXJhdGlvbj4+MDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5yaWdodDpcblx0XHRcdFx0bmV3WCAtPSBzbmFwID8gLTEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MuZG93bjpcblx0XHRcdFx0bmV3WSAtPSBzbmFwID8gMSA6IDUgKyB0aGlzLmtleUFjY2VsZXJhdGlvbj4+MDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBzbmFwICkge1xuXHRcdFx0dGhpcy5nb1RvUGFnZShuZXdYLCBuZXdZKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5ld1ggPiAwICkge1xuXHRcdFx0bmV3WCA9IDA7XG5cdFx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IDA7XG5cdFx0fSBlbHNlIGlmICggbmV3WCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdG5ld1ggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdZID4gMCApIHtcblx0XHRcdG5ld1kgPSAwO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRuZXdZID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8obmV3WCwgbmV3WSwgMCk7XG5cblx0XHR0aGlzLmtleVRpbWUgPSBub3c7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uIChkZXN0WCwgZGVzdFksIGR1cmF0aW9uLCBlYXNpbmdGbikge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHN0YXJ0WCA9IHRoaXMueCxcblx0XHRcdHN0YXJ0WSA9IHRoaXMueSxcblx0XHRcdHN0YXJ0VGltZSA9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdGRlc3RUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG5cblx0XHRmdW5jdGlvbiBzdGVwICgpIHtcblx0XHRcdHZhciBub3cgPSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHRcdGVhc2luZztcblxuXHRcdFx0aWYgKCBub3cgPj0gZGVzdFRpbWUgKSB7XG5cdFx0XHRcdHRoYXQuaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0dGhhdC5fdHJhbnNsYXRlKGRlc3RYLCBkZXN0WSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoICF0aGF0LnJlc2V0UG9zaXRpb24odGhhdC5vcHRpb25zLmJvdW5jZVRpbWUpICkge1xuXHRcdFx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG5vdyA9ICggbm93IC0gc3RhcnRUaW1lICkgLyBkdXJhdGlvbjtcblx0XHRcdGVhc2luZyA9IGVhc2luZ0ZuKG5vdyk7XG5cdFx0XHRuZXdYID0gKCBkZXN0WCAtIHN0YXJ0WCApICogZWFzaW5nICsgc3RhcnRYO1xuXHRcdFx0bmV3WSA9ICggZGVzdFkgLSBzdGFydFkgKSAqIGVhc2luZyArIHN0YXJ0WTtcblx0XHRcdHRoYXQuX3RyYW5zbGF0ZShuZXdYLCBuZXdZKTtcblxuXHRcdFx0aWYgKCB0aGF0LmlzQW5pbWF0aW5nICkge1xuXHRcdFx0XHRyQUYoc3RlcCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhhdC5vcHRpb25zLnByb2JlVHlwZSA9PSAzICkge1xuXHRcdFx0XHR0aGF0Ll9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuXHRcdHN0ZXAoKTtcblx0fSxcblxuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRzd2l0Y2ggKCBlLnR5cGUgKSB7XG5cdFx0XHRjYXNlICd0b3VjaHN0YXJ0Jzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJkb3duJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckRvd24nOlxuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0dGhpcy5fc3RhcnQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJtb3ZlJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlck1vdmUnOlxuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0dGhpcy5fbW92ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRjYXNlICdwb2ludGVydXAnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyVXAnOlxuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRjYXNlICd0b3VjaGNhbmNlbCc6XG5cdFx0XHRjYXNlICdwb2ludGVyY2FuY2VsJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckNhbmNlbCc6XG5cdFx0XHRjYXNlICdtb3VzZWNhbmNlbCc6XG5cdFx0XHRcdHRoaXMuX2VuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdvcmllbnRhdGlvbmNoYW5nZSc6XG5cdFx0XHRjYXNlICdyZXNpemUnOlxuXHRcdFx0XHR0aGlzLl9yZXNpemUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0cmFuc2l0aW9uZW5kJzpcblx0XHRcdGNhc2UgJ3dlYmtpdFRyYW5zaXRpb25FbmQnOlxuXHRcdFx0Y2FzZSAnb1RyYW5zaXRpb25FbmQnOlxuXHRcdFx0Y2FzZSAnTVNUcmFuc2l0aW9uRW5kJzpcblx0XHRcdFx0dGhpcy5fdHJhbnNpdGlvbkVuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd3aGVlbCc6XG5cdFx0XHRjYXNlICdET01Nb3VzZVNjcm9sbCc6XG5cdFx0XHRjYXNlICdtb3VzZXdoZWVsJzpcblx0XHRcdFx0dGhpcy5fd2hlZWwoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAna2V5ZG93bic6XG5cdFx0XHRcdHRoaXMuX2tleShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjbGljayc6XG5cdFx0XHRcdGlmICggIWUuX2NvbnN0cnVjdGVkICkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxufTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIgKGRpcmVjdGlvbiwgaW50ZXJhY3RpdmUsIHR5cGUpIHtcblx0dmFyIHNjcm9sbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5cdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTknO1xuXHRcdGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gJy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMC41KTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC45KTtib3JkZXItcmFkaXVzOjNweCc7XG5cdH1cblxuXHRpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2lTY3JvbGxJbmRpY2F0b3InO1xuXG5cdGlmICggZGlyZWN0aW9uID09ICdoJyApIHtcblx0XHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO2hlaWdodDo3cHg7bGVmdDoycHg7cmlnaHQ6MnB4O2JvdHRvbTowJztcblx0XHRcdGluZGljYXRvci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdFx0fVxuXHRcdHNjcm9sbGJhci5jbGFzc05hbWUgPSAnaVNjcm9sbEhvcml6b250YWxTY3JvbGxiYXInO1xuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRcdHNjcm9sbGJhci5zdHlsZS5jc3NUZXh0ICs9ICc7d2lkdGg6N3B4O2JvdHRvbToycHg7dG9wOjJweDtyaWdodDoxcHgnO1xuXHRcdFx0aW5kaWNhdG9yLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XHRzY3JvbGxiYXIuY2xhc3NOYW1lID0gJ2lTY3JvbGxWZXJ0aWNhbFNjcm9sbGJhcic7XG5cdH1cblxuXHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO292ZXJmbG93OmhpZGRlbic7XG5cblx0aWYgKCAhaW50ZXJhY3RpdmUgKSB7XG5cdFx0c2Nyb2xsYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cdH1cblxuXHRzY3JvbGxiYXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcblxuXHRyZXR1cm4gc2Nyb2xsYmFyO1xufVxuXG5mdW5jdGlvbiBJbmRpY2F0b3IgKHNjcm9sbGVyLCBvcHRpb25zKSB7XG5cdHRoaXMud3JhcHBlciA9IHR5cGVvZiBvcHRpb25zLmVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmVsKSA6IG9wdGlvbnMuZWw7XG5cdHRoaXMud3JhcHBlclN0eWxlID0gdGhpcy53cmFwcGVyLnN0eWxlO1xuXHR0aGlzLmluZGljYXRvciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5pbmRpY2F0b3JTdHlsZSA9IHRoaXMuaW5kaWNhdG9yLnN0eWxlO1xuXHR0aGlzLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG5cblx0dGhpcy5vcHRpb25zID0ge1xuXHRcdGxpc3Rlblg6IHRydWUsXG5cdFx0bGlzdGVuWTogdHJ1ZSxcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cdFx0cmVzaXplOiB0cnVlLFxuXHRcdGRlZmF1bHRTY3JvbGxiYXJzOiBmYWxzZSxcblx0XHRzaHJpbms6IGZhbHNlLFxuXHRcdGZhZGU6IGZhbHNlLFxuXHRcdHNwZWVkUmF0aW9YOiAwLFxuXHRcdHNwZWVkUmF0aW9ZOiAwXG5cdH07XG5cblx0Zm9yICggdmFyIGkgaW4gb3B0aW9ucyApIHtcblx0XHR0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xuXHR9XG5cblx0dGhpcy5zaXplUmF0aW9YID0gMTtcblx0dGhpcy5zaXplUmF0aW9ZID0gMTtcblx0dGhpcy5tYXhQb3NYID0gMDtcblx0dGhpcy5tYXhQb3NZID0gMDtcblxuXHRpZiAoIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSApIHtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVRvdWNoICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBvaW50ZXIgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlTW91c2UgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgJ21vdXNlZG93bicsIHRoaXMpO1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGlmICggdGhpcy5vcHRpb25zLmZhZGUgKSB7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9IHRoaXMuc2Nyb2xsZXIudHJhbnNsYXRlWjtcblx0XHR0aGlzLndyYXBwZXJTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dID0gdXRpbHMuaXNCYWRBbmRyb2lkID8gJzAuMDAxcycgOiAnMG1zJztcblx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gJzAnO1xuXHR9XG59XG5cbkluZGljYXRvci5wcm90b3R5cGUgPSB7XG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHN3aXRjaCAoIGUudHlwZSApIHtcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmRvd24nOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyRG93bic6XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHR0aGlzLl9zdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcm1vdmUnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyTW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJ1cCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJVcCc6XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGNhc2UgJ3RvdWNoY2FuY2VsJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyQ2FuY2VsJzpcblx0XHRcdGNhc2UgJ21vdXNlY2FuY2VsJzpcblx0XHRcdFx0dGhpcy5fZW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmludGVyYWN0aXZlICkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMuaW5kaWNhdG9yLCAnbW91c2Vkb3duJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNoZW5kJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICkge1xuXHRcdFx0dGhpcy53cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHRoaXMudHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdHRoaXMuaW5pdGlhdGVkID0gdHJ1ZTtcblx0XHR0aGlzLm1vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5sYXN0UG9pbnRYXHQ9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMubGFzdFBvaW50WVx0PSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuc3RhcnRUaW1lXHQ9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlVG91Y2ggKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVQb2ludGVyICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZU1vdXNlICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdiZWZvcmVTY3JvbGxTdGFydCcpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG5cdFx0XHRkZWx0YVgsIGRlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aW1lc3RhbXAgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdzY3JvbGxTdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubW92ZWQgPSB0cnVlO1xuXG5cdFx0ZGVsdGFYID0gcG9pbnQucGFnZVggLSB0aGlzLmxhc3RQb2ludFg7XG5cdFx0dGhpcy5sYXN0UG9pbnRYID0gcG9pbnQucGFnZVg7XG5cblx0XHRkZWx0YVkgPSBwb2ludC5wYWdlWSAtIHRoaXMubGFzdFBvaW50WTtcblx0XHR0aGlzLmxhc3RQb2ludFkgPSBwb2ludC5wYWdlWTtcblxuXHRcdG5ld1ggPSB0aGlzLnggKyBkZWx0YVg7XG5cdFx0bmV3WSA9IHRoaXMueSArIGRlbHRhWTtcblxuXHRcdHRoaXMuX3BvcyhuZXdYLCBuZXdZKTtcblxuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMucHJvYmVUeXBlID09IDEgJiYgdGltZXN0YW1wIC0gdGhpcy5zdGFydFRpbWUgPiAzMDAgKSB7XG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnc2Nyb2xsJyk7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5zY3JvbGxlci5vcHRpb25zLnByb2JlVHlwZSA+IDEgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdH1cblxuXG4vLyBJTlNFUlQgUE9JTlQ6IGluZGljYXRvci5fbW92ZVxuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0sXG5cblx0X2VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmluaXRpYXRlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmluaXRpYXRlZCA9IGZhbHNlO1xuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcm1vdmUnKSwgdGhpcyk7XG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cblx0XHRpZiAoIHRoaXMuc2Nyb2xsZXIub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dmFyIHNuYXAgPSB0aGlzLnNjcm9sbGVyLl9uZWFyZXN0U25hcCh0aGlzLnNjcm9sbGVyLngsIHRoaXMuc2Nyb2xsZXIueSk7XG5cblx0XHRcdHZhciB0aW1lID0gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdFx0XHRNYXRoLm1heChcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMuc2Nyb2xsZXIueCAtIHNuYXAueCksIDEwMDApLFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy5zY3JvbGxlci55IC0gc25hcC55KSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2Nyb2xsZXIueCAhPSBzbmFwLnggfHwgdGhpcy5zY3JvbGxlci55ICE9IHNuYXAueSApIHtcblx0XHRcdFx0dGhpcy5zY3JvbGxlci5kaXJlY3Rpb25YID0gMDtcblx0XHRcdFx0dGhpcy5zY3JvbGxlci5kaXJlY3Rpb25ZID0gMDtcblx0XHRcdFx0dGhpcy5zY3JvbGxlci5jdXJyZW50UGFnZSA9IHNuYXA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuc2Nyb2xsVG8oc25hcC54LCBzbmFwLnksIHRpbWUsIHRoaXMuc2Nyb2xsZXIub3B0aW9ucy5ib3VuY2VFYXNpbmcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tb3ZlZCApIHtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyYW5zaXRpb25UaW1lOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dID0gdGltZSArICdtcyc7XG5cblx0XHRpZiAoICF0aW1lICYmIHV0aWxzLmlzQmFkQW5kcm9pZCApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9ICcwLjAwMXMnO1xuXHRcdH1cblx0fSxcblxuXHR0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uIChlYXNpbmcpIHtcblx0XHR0aGlzLmluZGljYXRvclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbl0gPSBlYXNpbmc7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMudHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggJiYgIXRoaXMub3B0aW9ucy5saXN0ZW5ZICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5kaXNwbGF5ID0gdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWSAmJiAhdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc1ZlcnRpY2FsU2Nyb2xsID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5kaXNwbGF5ID0gdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsIHx8IHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsICYmIHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR1dGlscy5hZGRDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsQm90aFNjcm9sbGJhcnMnKTtcblx0XHRcdHV0aWxzLnJlbW92ZUNsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxMb25lU2Nyb2xsYmFyJyk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICYmIHRoaXMub3B0aW9ucy5jdXN0b21TdHlsZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUucmlnaHQgPSAnOHB4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUuYm90dG9tID0gJzhweCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dXRpbHMucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbEJvdGhTY3JvbGxiYXJzJyk7XG5cdFx0XHR1dGlscy5hZGRDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsTG9uZVNjcm9sbGJhcicpO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5kZWZhdWx0U2Nyb2xsYmFycyAmJiB0aGlzLm9wdGlvbnMuY3VzdG9tU3R5bGUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLnJpZ2h0ID0gJzJweCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLmJvdHRvbSA9ICcycHgnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHIgPSB0aGlzLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1x0Ly8gZm9yY2UgcmVmcmVzaFxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdHRoaXMud3JhcHBlcldpZHRoID0gdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMucmVzaXplICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcldpZHRoID0gTWF0aC5tYXgoTWF0aC5yb3VuZCh0aGlzLndyYXBwZXJXaWR0aCAqIHRoaXMud3JhcHBlcldpZHRoIC8gKHRoaXMuc2Nyb2xsZXIuc2Nyb2xsZXJXaWR0aCB8fCB0aGlzLndyYXBwZXJXaWR0aCB8fCAxKSksIDgpO1xuXHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLndpZHRoID0gdGhpcy5pbmRpY2F0b3JXaWR0aCArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcldpZHRoID0gdGhpcy5pbmRpY2F0b3IuY2xpZW50V2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWCA9IHRoaXMud3JhcHBlcldpZHRoIC0gdGhpcy5pbmRpY2F0b3JXaWR0aDtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdjbGlwJyApIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVggPSAtdGhpcy5pbmRpY2F0b3JXaWR0aCArIDg7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlYID0gdGhpcy53cmFwcGVyV2lkdGggLSA4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVggPSAwO1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WCA9IHRoaXMubWF4UG9zWDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zaXplUmF0aW9YID0gdGhpcy5vcHRpb25zLnNwZWVkUmF0aW9YIHx8ICh0aGlzLnNjcm9sbGVyLm1heFNjcm9sbFggJiYgKHRoaXMubWF4UG9zWCAvIHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWCkpO1x0XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWSApIHtcblx0XHRcdHRoaXMud3JhcHBlckhlaWdodCA9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9ySGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5yb3VuZCh0aGlzLndyYXBwZXJIZWlnaHQgKiB0aGlzLndyYXBwZXJIZWlnaHQgLyAodGhpcy5zY3JvbGxlci5zY3JvbGxlckhlaWdodCB8fCB0aGlzLndyYXBwZXJIZWlnaHQgfHwgMSkpLCA4KTtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodCArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvckhlaWdodCA9IHRoaXMuaW5kaWNhdG9yLmNsaWVudEhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnY2xpcCcgKSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlZID0gLXRoaXMuaW5kaWNhdG9ySGVpZ2h0ICsgODtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVkgPSB0aGlzLndyYXBwZXJIZWlnaHQgLSA4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVkgPSAwO1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WSA9IHRoaXMubWF4UG9zWTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cdFx0XHR0aGlzLnNpemVSYXRpb1kgPSB0aGlzLm9wdGlvbnMuc3BlZWRSYXRpb1kgfHwgKHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWSAmJiAodGhpcy5tYXhQb3NZIC8gdGhpcy5zY3JvbGxlci5tYXhTY3JvbGxZKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHR9LFxuXG5cdHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHggPSB0aGlzLm9wdGlvbnMubGlzdGVuWCAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWCAqIHRoaXMuc2Nyb2xsZXIueCkgfHwgMCxcblx0XHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWSAqIHRoaXMuc2Nyb2xsZXIueSkgfHwgMDtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5pZ25vcmVCb3VuZGFyaWVzICkge1xuXHRcdFx0aWYgKCB4IDwgdGhpcy5taW5Cb3VuZGFyeVggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLmluZGljYXRvcldpZHRoICsgeCwgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHggPSB0aGlzLm1pbkJvdW5kYXJ5WDtcblx0XHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heEJvdW5kYXJ5WCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMuaW5kaWNhdG9yV2lkdGggLSAoeCAtIHRoaXMubWF4UG9zWCksIDgpO1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHR4ID0gdGhpcy5tYXhQb3NYICsgdGhpcy5pbmRpY2F0b3JXaWR0aCAtIHRoaXMud2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHRoaXMubWF4Qm91bmRhcnlYO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgJiYgdGhpcy53aWR0aCAhPSB0aGlzLmluZGljYXRvcldpZHRoICkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5pbmRpY2F0b3JXaWR0aDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHkgPCB0aGlzLm1pbkJvdW5kYXJ5WSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmluZGljYXRvckhlaWdodCArIHkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR5ID0gdGhpcy5taW5Cb3VuZGFyeVk7XG5cdFx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhCb3VuZGFyeVkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JIZWlnaHQgLSAoeSAtIHRoaXMubWF4UG9zWSkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhQb3NZICsgdGhpcy5pbmRpY2F0b3JIZWlnaHQgLSB0aGlzLmhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhCb3VuZGFyeVk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyAmJiB0aGlzLmhlaWdodCAhPSB0aGlzLmluZGljYXRvckhlaWdodCApIHtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2Zvcm1dID0gJ3RyYW5zbGF0ZSgnICsgeCArICdweCwnICsgeSArICdweCknICsgdGhpcy5zY3JvbGxlci50cmFuc2xhdGVaO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUudG9wID0geSArICdweCc7XG5cdFx0fVxuXHR9LFxuXG5cdF9wb3M6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0aWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heFBvc1ggKSB7XG5cdFx0XHR4ID0gdGhpcy5tYXhQb3NYO1xuXHRcdH1cblxuXHRcdGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhQb3NZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4UG9zWTtcblx0XHR9XG5cblx0XHR4ID0gdGhpcy5vcHRpb25zLmxpc3RlblggPyBNYXRoLnJvdW5kKHggLyB0aGlzLnNpemVSYXRpb1gpIDogdGhpcy5zY3JvbGxlci54O1xuXHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSA/IE1hdGgucm91bmQoeSAvIHRoaXMuc2l6ZVJhdGlvWSkgOiB0aGlzLnNjcm9sbGVyLnk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHgsIHkpO1xuXHR9LFxuXG5cdGZhZGU6IGZ1bmN0aW9uICh2YWwsIGhvbGQpIHtcblx0XHRpZiAoIGhvbGQgJiYgIXRoaXMudmlzaWJsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5mYWRlVGltZW91dCk7XG5cdFx0dGhpcy5mYWRlVGltZW91dCA9IG51bGw7XG5cblx0XHR2YXIgdGltZSA9IHZhbCA/IDI1MCA6IDUwMCxcblx0XHRcdGRlbGF5ID0gdmFsID8gMCA6IDMwMDtcblxuXHRcdHZhbCA9IHZhbCA/ICcxJyA6ICcwJztcblxuXHRcdHRoaXMud3JhcHBlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSB0aW1lICsgJ21zJztcblxuXHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gdmFsO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gK3ZhbDtcblx0XHR9KS5iaW5kKHRoaXMsIHZhbCksIGRlbGF5KTtcblx0fVxufTtcblxuSVNjcm9sbC51dGlscyA9IHV0aWxzO1xuXG5pZiAoIHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gSVNjcm9sbDtcbn0gZWxzZSB7XG5cdHdpbmRvdy5JU2Nyb2xsID0gSVNjcm9sbDtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgTWF0aCk7IiwibW9kdWxlLmV4cG9ydHMgPSBuZXcgKCByZXF1aXJlKCBcInNjaGVkdWxlclwiICkgKSgpXG4iLCJsZXQgbG9kYXNoID0gcmVxdWlyZSggYGxvZGFzaGAgKVxubGV0IGNvID0gcmVxdWlyZSggYGNvYCApXG5sZXQgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSggYGV2ZW50c2AgKS5FdmVudEVtaXR0ZXIgfHwgcmVxdWlyZSggYGV2ZW50c2AgKVxuXG5sZXQgTk9OX1BBUlRJQUwgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcbk5PTl9QQVJUSUFMLl9fcGFydGlhbF9fID0gZmFsc2VcblxubGV0IFBBUlRJQUwgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblxuZnVuY3Rpb24gYXNzZXJ0KCB2YWx1ZSwgbWVzc2FnZSApIHtcblx0aWYgKCAhdmFsdWUgKVxuXHRcdHRocm93IG5ldyBFcnJvciggYGAgKyBtZXNzYWdlIClcbn1cblxubGV0IExpdGVyYWxQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIHt9IClcblxubGV0IGx1ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0ZHVtcFByb21pc2U6IHAgPT4gcC50aGVuKFxuXHRcdHJlc3VsdCA9PiBsdS5sb2coIGByZXN1bHQ6YCwgcmVzdWx0ICksXG5cdFx0ZXJyb3IgPT4gbHUuZXJyb3IoIGBlcnJvcjpgLCBlcnJvciApXG5cdCksXG5cblx0ZHVtcCggbXNnLCB2YWx1ZSApIHtcblx0XHRjb25zb2xlLmxvZyggbXNnLCB2YWx1ZSApXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0sXG5cblx0bG9nOiBjb25zb2xlLmxvZy5iaW5kKCBjb25zb2xlICksXG5cdGluZm86ICggY29uc29sZS5pbmZvIHx8IGNvbnNvbGUubG9nICkuYmluZCggY29uc29sZSApLFxuXHR3YXJuOiAoIGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZyApLmJpbmQoIGNvbnNvbGUgKSxcblx0ZXJyb3I6ICggY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZyApLmJpbmQoIGNvbnNvbGUgKSxcblx0dHJhY2U6ICggY29uc29sZS50cmFjZSB8fCBjb25zb2xlLmxvZyApLmJpbmQoIGNvbnNvbGUgKSxcblxuXHRtYXBPYmooIG9iaiwgcHJvcHMgKSB7XG5cdFx0bGV0IHJldCA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdC5nZXRQcm90b3R5cGVPZiggb2JqICkgKSwgb2JqIClcblx0XHRsb2Rhc2guZm9yRWFjaCggcHJvcHMsICggZnVuLCBrZXkgKSA9PiByZXRbIGtleSBdID0gdHlwZW9mIGZ1biA9PSBgZnVuY3Rpb25gID8gZnVuKCBvYmpbIGtleSBdICkgOiBmdW4gKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRyZXN0cyggbnVtLCAuLi5yZXN0cyApIHtcblx0XHRsZXQgcmV0ID0gW11cblx0XHRmb3IgKCBsZXQgciBvZiByZXN0cyApIHtcblx0XHRcdGxldCBuID0gbnVtICUgclxuXHRcdFx0bnVtID0gKCBudW0gLSBuICkgLyByXG5cdFx0XHRyZXQucHVzaCggbiApXG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRwYWQoIHMsIG4sIHAgKSB7XG5cdFx0cyA9IFN0cmluZyggcyApXG5cdFx0bGV0IHggPSBgYFxuXHRcdG4gLT0gcy5sZW5ndGhcblx0XHR3aGlsZSAoIG4gPiAwICkge1xuXHRcdFx0eCArPSBwXG5cdFx0XHQtLW5cblx0XHR9XG5cdFx0cmV0dXJuIHggKyBzXG5cdH0sXG5cblx0dGltZSgpIHtcblx0XHRsZXQgZCA9IG5ldyBEYXRlKClcblx0XHRyZXR1cm4gYCR7IGQuZ2V0SG91cnMoKSB9OiR7IGx1LnBhZCggZC5nZXRNaW51dGVzKCksIDIsIDAgKSB9OiR7IGx1LnBhZCggZC5nZXRTZWNvbmRzKCksIDIsIDAgKSB9LiR7IGx1LnBhZCggZC5nZXRNaWxsaXNlY29uZHMoKSwgMywgMCApIH1gXG5cdH0sXG5cblx0c3RhY2s6ICgpID0+ICggbmV3IEVycm9yICkuc3RhY2ssXG5cblx0b3B0aW9ucyggb3B0aW9ucywgZGVmICkge1xuXHRcdGxldCByZXQgPSB7fVxuXHRcdGZvciAoIGxldCBpIGluIGRlZiApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkZWYsIGkgKSApXG5cdFx0XHRpZiAoIG9wdGlvbnMgPT0gbnVsbCApXG5cdFx0XHRcdHJldFsgaSBdID0gZGVmWyBpIF1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgb3AgPSBvcHRpb25zWyBpIF1cblx0XHRcdFx0aWYgKCBvcCA9PSBudWxsIClcblx0XHRcdFx0XHRvcCA9IGRlZlsgaSBdXG5cdFx0XHRcdHJldFsgaSBdID0gb3Bcblx0XHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH0sXG5cblx0c3RyOiAoIG9iaiwgZGVwdGggKSA9PiB7XG5cdFx0aWYgKCBkZXB0aCA9PSBudWxsIClcblx0XHRcdGRlcHRoID0gMVxuXHRcdGlmICggIW9iaiB8fCAhZGVwdGggfHwgZGVwdGggPCAxIClcblx0XHRcdHJldHVybiBgYCArIG9ialxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKVxuXHRcdFx0cmV0dXJuICggYFsgYCArIG9iai5tYXAoIHggPT4gbHUuc3RyKCB4LCBkZXB0aCAtIDEgKSApLmpvaW4oIGAgYCApICsgYCBdYCApXG5cdFx0aWYgKCAhb2JqLmNvbnN0cnVjdG9yIHx8IG9iai5jb25zdHJ1Y3RvciA9PSBPYmplY3QgKVxuXHRcdFx0cmV0dXJuICggYHsgYCArIE9iamVjdC5rZXlzKCBvYmogKS5tYXAoIHggPT4geCArIGA9YCArIGx1LnN0ciggb2JqWyB4IF0sIGRlcHRoIC0gMSApICkuam9pbiggYCBgICkgKyBgIH1gIClcblx0XHRyZXR1cm4gU3RyaW5nKCBvYmogKVxuXHR9LFxuXG5cdHRvT25lTGluZSggb2JqICkge1xuXHRcdGxldCByZXQgPSBKU09OLnN0cmluZ2lmeSggb2JqIClcblx0XHRyZXQgKz0gXCJcXG5cIlxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRieUxpbmVzKCBjYWxsYmFjayApIHtcblx0XHRsZXQgYnVmZmVyID0gYGBcblx0XHRyZXR1cm4gY2h1bmsgPT4ge1xuXHRcdFx0YnVmZmVyICs9IFN0cmluZyggY2h1bmsgKVxuXHRcdFx0bGV0IHJldCA9IGJ1ZmZlci5zcGxpdCggYFxcbmAgKVxuXHRcdFx0YnVmZmVyID0gcmV0LnBvcCgpXG5cdFx0XHRyZXQuZm9yRWFjaCggY2FsbGJhY2sgKVxuXHRcdH1cblx0fSxcblxuXHRieUpTT04oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBieUxpbmVzKCBsaW5lID0+IGNhbGxiYWNrKCBKU09OLnBhcnNlKCBsaW5lLnRyaW0oKSApICkgKVxuXHR9LFxuXG5cdHZhbHVlT2Y6IHZhbCA9PiB2YWwgPT0gbnVsbCA/IG51bGwgOiB2YWwudmFsdWVPZiA9PSBudWxsID8gdmFsIDogdmFsLnZhbHVlT2YoKSxcblxuXHRyZXR1cm5UaGlzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzIH0sXG5cdHJldHVybk51bGw6ICgpID0+IG51bGwsXG5cdHJldHVyblRydWU6ICgpID0+IHRydWUsXG5cdHJldHVybkZhbHNlOiAoKSA9PiBmYWxzZSxcblx0cmV0dXJuWmVybzogKCkgPT4gMCxcblx0cmV0dXJuT25lOiAoKSA9PiAxLFxuXG5cdHByb21pc2VTdWNjZWVkZWQ6IFByb21pc2UucmVzb2x2ZSgpLFxuXHRwcm9taXNlTnVsbDogUHJvbWlzZS5yZXNvbHZlKCBudWxsICksXG5cdHByb21pc2VUcnVlOiBQcm9taXNlLnJlc29sdmUoIHRydWUgKSxcblx0cHJvbWlzZUZhbHNlOiBQcm9taXNlLnJlc29sdmUoIGZhbHNlICksXG5cdHByb21pc2VaZXJvOiBQcm9taXNlLnJlc29sdmUoIDAgKSxcblx0cHJvbWlzZU9uZTogUHJvbWlzZS5yZXNvbHZlKCAxICksXG5cblx0cmV0dXJuTnVsbFByb21pc2U6ICgpID0+IGx1LnByb21pc2VOdWxsLFxuXHRyZXR1cm5UcnVlUHJvbWlzZTogKCkgPT4gbHUucHJvbWlzZVRydWUsXG5cdHJldHVybkZhbHNlUHJvbWlzZTogKCkgPT4gbHUucHJvbWlzZUZhbHNlLFxuXHRyZXR1cm5aZXJvUHJvbWlzZTogKCkgPT4gbHUucHJvbWlzZVplcm8sXG5cdHJldHVybk9uZVByb21pc2U6ICgpID0+IGx1LnByb21pc2VPbmUsXG5cblx0d2hlbiggcHJvbWlzZSwgY2IgKSB7XG5cdFx0aWYgKCBwcm9taXNlICE9IG51bGwgKVxuXHRcdFx0cHJvbWlzZS50aGVuKCBjYiwgY2IgKVxuXHRcdGVsc2Vcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soIGNiIClcblx0XHRyZXR1cm4gcHJvbWlzZVxuXHR9LFxuXG5cdHdhaXRGb3IoIHRpbWVvdXQsIGludGVydmFsLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiB0aW1lb3V0ID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRpbnRlcnZhbCA9IHRpbWVvdXRcblx0XHRcdHRpbWVvdXQgPSA1MDAwXG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGludGVydmFsID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRjYWxsYmFjayA9IGludGVydmFsXG5cdFx0XHRpbnRlcnZhbCA9IDIwMFxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdFx0bGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gY2hlY2soKSB7XG5cdFx0XHRcdGxldCByZXRcblx0XHRcdFx0aWYgKCByZXQgPSBjYWxsYmFjaygpIClcblx0XHRcdFx0XHRyZXNvbHZlKCByZXQgKVxuXHRcdFx0XHRlbHNlIGlmICggRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCApXG5cdFx0XHRcdFx0cmVqZWN0KCBuZXcgRXJyb3IoIGB0aW1lb3V0YCApIClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGNoZWNrLCBpbnRlcnZhbCApXG5cdFx0XHR9LCBpbnRlcnZhbCApXG5cdFx0fSApXG5cdH0sXG5cblx0ZW1wdHk6IE9iamVjdC5mcmVlemUoIE9iamVjdC5jcmVhdGUoIG51bGwgKSApLFxuXG5cdEpTT05FcXVhbCggYSwgYiApIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoIGEgKSA9PSBKU09OLnN0cmluZ2lmeSggYiApXG5cdH0sXG5cblx0bmV3KCAuLi5kZXNjZWRlbnRzICkge1xuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKCB7fSwgLi4uZGVzY2VkZW50cyApXG5cdH0sXG5cblx0Y2FsbCggZnVuLCAuLi5hcmdzICkge1xuXHRcdHJldHVybiBmdW4oIC4uLmFyZ3MgKVxuXHR9LFxuXG5cdHJldGhyb3coIGUgKSB7IHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZSB9LCAxICkgfSxcblxuXHQvLyBvcHRpbWl6YXRpb24gLS0gdXNpbmcgdHJ5L2NhdGNoIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uXG5cdGNhdGNoKCBjYiwgcmV0ICkgeyB0cnkgeyByZXR1cm4gY2IoKSB9IGNhdGNoICggZSApIHsgcmV0dXJuIHJldCggZSApIH0gfSxcblxuXHRjYXRjaE1hcCggY2IsIG1hcFJlc3VsdCwgbWFwRXJyb3IgKSB7XG5cdFx0bGV0IHJlc3VsdFxuXHRcdHRyeSB7XG5cdFx0XHRyZXN1bHQgPSBjYigpXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gbWFwRXJyb3IoIGVycm9yIClcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFJlc3VsdCggcmVzdWx0IClcblx0fSxcblxuXHRjYXRjaENhbGwoIGNiICkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4geyBvazogdHJ1ZSwgcmVzdWx0OiBjYigpIH1cblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGVycm9yIH1cblx0XHR9XG5cdH0sXG5cblx0KnRyeSggZnVuLCBzdGFydFRpbWVUb1dhaXQgPSAxMDAsIG1heFRpbWVUb1dhaXQgPSAzMDAwLCBtdWx0aXBseSA9IDEuNSApIHtcblx0XHRsZXQgdGltZVRvV2FpdCA9IHN0YXJ0VGltZVRvV2FpdFxuXHRcdGZvciAoOzspIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiB5aWVsZCBmdW4oKVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlICkge1xuXHRcdFx0XHRsdS5yZXRocm93KCBlIClcblx0XHRcdFx0eWllbGQgY28uc2xlZXAoIHRpbWVUb1dhaXQgKVxuXHRcdFx0XHR0aW1lVG9XYWl0ID0gTWF0aC5taW4oIHRpbWVUb1dhaXQgKiBtdWx0aXBseSwgbWF4VGltZVRvV2FpdCApXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHVuaXF1ZSggdmFsdWUsIGluZGV4LCBhcnJheSApIHtcblx0XHRyZXR1cm4gaW5kZXggPT0gMCB8fCB2YWx1ZSAhPSBhcnJheVsgaW5kZXggLSAxIF1cblx0fSxcblxuXHRqb2luRGF0YSggYXJyYXkgKSB7XG5cdFx0cmV0dXJuIGFycmF5Lmxlbmd0aCA9PSAwID9cblx0XHRcdGBgXG5cdFx0OiB0eXBlb2YgYXJyYXlbIDAgXSA9PSBgc3RyaW5nYCA/XG5cdFx0XHRhcnJheS5qb2luKCBgYCApXG5cdFx0OiBCdWZmZXIuaXNCdWZmZXIoIGFycmF5WyAwIF0gKSA/XG5cdFx0XHRCdWZmZXIuY29uY2F0KCBhcnJheSApXG5cdFx0OlxuXHRcdFx0YXJyYXkuam9pbiggYGAgKVxuXHR9LFxuXG5cdG9uKCBlbWl0dGVyLCBldmVudHMgKSB7XG5cdFx0bG9kYXNoLmZvckVhY2goIGV2ZW50cywgKCBoYW5kbGVyLCBldmVudCApID0+IGVtaXR0ZXIub24oIGV2ZW50LCBoYW5kbGVyICkgKVxuXHR9LFxuXG5cdG9mZiggZW1pdHRlciwgZXZlbnRzICkge1xuXHRcdGxvZGFzaC5mb3JFYWNoKCBldmVudHMsICggaGFuZGxlciwgZXZlbnQgKSA9PiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCBldmVudCwgaGFuZGxlciApIClcblx0fSxcblxuXHQqcmVhZFN0cmVhbSggc3RyZWFtICkge1xuXHRcdHJldHVybiB5aWVsZCB7IHRoZW4oIHJlc29sdmUsIHJlamVjdCApIHtcblx0XHRcdGxldCBjb250ZW50ID0gW11cblx0XHRcdHN0cmVhbS5vbiggYGRhdGFgLCBjaHVuayA9PiBjb250ZW50LnB1c2goIGNodW5rICkgKVxuXHRcdFx0c3RyZWFtLm9uKCBgZW5kYCwgKCkgPT4gcmVzb2x2ZSggbHUuam9pbkRhdGEoIGNvbnRlbnQgKSApIClcblx0XHRcdHN0cmVhbS5vbiggYGVycm9yYCwgcmVqZWN0IClcblx0XHR9IH1cblx0fSxcblxuXHQqcmVhZEpTT04oIHN0cmVhbSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggeWllbGQgbHUucmVhZFN0cmVhbSggc3RyZWFtICkgKVxuXHR9LFxuXG5cdCpyZWFkQ2h1bmsoIHN0cmVhbSApIHtcblx0XHRyZXR1cm4geWllbGQgeyB0aGVuKCByZXNvbHZlLCByZWplY3QgKSB7XG5cdFx0XHRzdHJlYW0ub24oIGBkYXRhYCwgb25EYXRhIClcblx0XHRcdHN0cmVhbS5vbiggYGVuZGAsIG9uRW5kIClcblx0XHRcdHN0cmVhbS5vbiggYGVycm9yYCwgb25FcnJvciApXG5cdFx0XHRmdW5jdGlvbiBkb25lKCkge1xuXHRcdFx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoIGBkYXRhYCwgb25EYXRhIClcblx0XHRcdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCBgZW5kYCwgb25FbmQgKVxuXHRcdFx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoIGBlcnJvcmAsIG9uRXJyb3IgKVxuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gb25EYXRhKCBjaHVuayApIHtcblx0XHRcdFx0ZG9uZSgpXG5cdFx0XHRcdHJlc29sdmUoIGNodW5rIClcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIG9uRW5kKCkge1xuXHRcdFx0XHRkb25lKClcblx0XHRcdFx0cmVzb2x2ZSggbnVsbCApXG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBvbkVycm9yKCBlcnJvciApIHtcblx0XHRcdFx0ZG9uZSgpXG5cdFx0XHRcdHJlamVjdCggZXJyb3IgKVxuXHRcdFx0fVxuXHRcdH0gfVxuXHR9LFxuXG5cdHN0YXRpYyggZnVuICkge1xuXHRcdHJldHVybiBjby5mdW5jKCBmdW5jdGlvbiogKCByZXF1ZXN0LCByZXNwb25zZSApIHtcblx0XHRcdGxldCBoZWFkV3JpdHRlbiA9IGZhbHNlLCByZXNwb25zZUVuZGVkID0gZmFsc2Vcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGxldCBib2R5ID0geWllbGQgZnVuKClcblx0XHRcdFx0cmVzcG9uc2Uud3JpdGVIZWFkKCAyMDAsIHsgWyBgQ29udGVudC1UeXBlYCBdOiBgdGV4dC9odG1sOyBjaGFyc2V0PVVURi04YCB9IClcblx0XHRcdFx0aGVhZFdyaXR0ZW4gPSB0cnVlXG5cdFx0XHRcdGlmICggdHlwZW9mIGJvZHkgIT0gYHN0cmluZ2AgKVxuXHRcdFx0XHRcdGJvZHkgPSBSZWFjdC5yZW5kZXJDb21wb25lbnRUb1N0cmluZyggYm9keSApXG5cdFx0XHRcdHJlc3BvbnNlLmVuZCggYm9keSApXG5cdFx0XHRcdHJlc3BvbnNlRW5kZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0aWYgKCAhaGVhZFdyaXR0ZW4gKVxuXHRcdFx0XHRcdHJlc3BvbnNlLndyaXRlSGVhZCggNTAwLCB7IFsgYENvbnRlbnQtVHlwZWAgXTogYHRleHQvcGxhaW5gIH0gKVxuXHRcdFx0XHRpZiAoICFyZXNwb25zZUVuZGVkIClcblx0XHRcdFx0XHRyZXNwb25zZS5lbmQoIGA8PDwgRVJST1IgPj4+YCApXG5cdFx0XHR9XG5cdFx0fSApXG5cdH0sXG5cblx0cHJvcGVydHkoIG9iaiwgbmFtZSwgZGVmYXVsdFZhbHVlICkge1xuXHRcdGxldCBwcml2YXRlTmFtZSA9IGBfYCArIG5hbWVcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAyIClcblx0XHRcdG9ialsgcHJpdmF0ZU5hbWUgXSA9IGRlZmF1bHRWYWx1ZVxuXHRcdG9ialsgbmFtZSBdID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PSAwIClcblx0XHRcdFx0cmV0dXJuIG9ialsgcHJpdmF0ZU5hbWUgXVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG9ialsgcHJpdmF0ZU5hbWUgXSA9IHZhbHVlXG5cdFx0XHRcdHJldHVybiBvYmpcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG9ialxuXHR9LFxuXG5cdHBvbGxpbmcoIHN0cmVhbSApIHtcblx0XHRsZXQgcmV0ID0ge1xuXHRcdFx0c3RvcCgpIHtcblx0XHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0aWYgKCByZXQuX3BvbGxpbmcgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHJldC5fcG9sbGluZyApXG5cdFx0XHRcdFx0cmV0Ll9wb2xsaW5nID0gbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldCA9IG51bGxcblx0XHRcdH0sXG5cdFx0XHRfcG9sbGluZzogbnVsbCxcblx0XHRcdF90cnlUb1NlbmRDaHVuaygpIHtcblx0XHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0cmV0Ll9wb2xsaW5nID0gbnVsbFxuXHRcdFx0XHRpZiAoICFzdHJlYW0ud3JpdGUoIHJldC5fY2h1bmsgKSApXG5cdFx0XHRcdFx0c3RyZWFtLm9uY2UoIGBkcmFpbmAsIHJldC5fdHJ5VG9TZW5kQ2h1bmsgKVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBzdHJlYW0uZmx1c2ggPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRcdFx0XHRzdHJlYW0uZmx1c2goKVxuXHRcdFx0XHRcdHJldC5fcG9sbGluZyA9IHNldFRpbWVvdXQoIHJldC5fdHJ5VG9TZW5kQ2h1bmssIHJldC5faW50ZXJ2YWwgKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH1cblxuXHRcdGx1LnByb3BlcnR5KCByZXQsIGBjaHVua2AsIGBcXG5gIClcblx0XHRsdS5wcm9wZXJ0eSggcmV0LCBgaW50ZXJ2YWxgLCA2MDAwMCApXG5cblx0XHQvLyBUT0RPOiB0aGlzIGV2ZW50IG5ldmVyIGZpcmVzISB3aGF0J3MgdGhlIHNoaXQ/IGNoZWNrIGl0ISBtYXkgYmUgdGhlIHJlYXNvbiBpcyAudXNlKCByZXF1aXJlKCBgY29tcHJlc3Npb25gICkoIHsgdGhyZXNob2xkOiAwIH0gKSApP1xuXHRcdHN0cmVhbS5vbmNlKCBgZW5kYCwgcmV0LnN0b3AgKVxuXHRcdC8vIFRPRE86IHRoaXMgZXZlbnQgbmV2ZXIgZmlyZXMhIHdoYXQncyB0aGUgc2hpdD8gY2hlY2sgaXQhIG1heSBiZSB0aGUgcmVhc29uIGlzIC51c2UoIHJlcXVpcmUoIGBjb21wcmVzc2lvbmAgKSggeyB0aHJlc2hvbGQ6IDAgfSApICk/XG5cdFx0c3RyZWFtLm9uY2UoIGBjbG9zZWAsIHJldC5zdG9wIClcblx0XHQvLyBUT0RPOiB0aGlzIGV2ZW50IG5ldmVyIGZpcmVzISB3aGF0J3MgdGhlIHNoaXQ/IGNoZWNrIGl0ISBtYXkgYmUgdGhlIHJlYXNvbiBpcyAudXNlKCByZXF1aXJlKCBgY29tcHJlc3Npb25gICkoIHsgdGhyZXNob2xkOiAwIH0gKSApP1xuXHRcdHN0cmVhbS5vbmNlKCBgZXJyb3JgLCByZXQuc3RvcCApXG5cblx0XHRwcm9jZXNzLm5leHRUaWNrKCByZXQuX3RyeVRvU2VuZENodW5rIClcblxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHR0ZXN0RGlmZigpIHtcblx0XHRsZXQgcCA9IHsgYTogMSwgeDogeyB1OiA5IH0gfVxuXHRcdGxldCBxID0geyB4OiB7IGM6IDIgfSB9XG5cdFx0YXNzZXJ0KCBKU09OLnN0cmluZ2lmeSggcSApID09IEpTT04uc3RyaW5naWZ5KCBsdS5hcHBseURpZmYoIHAsIGx1Lm1ha2VEaWZmKCBwLCBxICkgKSApIClcblx0fSxcblxuXHRpc1NldDogb2JqID0+IHtcblx0XHRpZiAoIG9iaiA9PSBudWxsIClcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiggb2JqIClcblx0XHRyZXR1cm4gcHJvdG8gPT09IExpdGVyYWxQcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGxcblx0fSxcblxuXHRhcHBseURpZmYoIGRlc3QsIGRpZmYsIHBhcnRpYWwgKSB7XG5cdFx0bGV0IHJldCA9IGRlc3Rcblx0XHRsZXQgY250ID0gMFxuXG5cdFx0ZnVuY3Rpb24gY29weURlc3QoKSB7XG5cdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGZvciAoIGxldCBrZXkgaW4gZGVzdCApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkZXN0LCBrZXkgKSApIHtcblx0XHRcdFx0bGV0IHZhbHVlID0gZGVzdFsga2V5IF1cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRyZXRbIGtleSBdID0gZGVzdFsga2V5IF1cblx0XHRcdFx0KytjbnRcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGRpZmYgJiYgZGlmZi5fX3BhcnRpYWxfXyA9PT0gZmFsc2UgKVxuXHRcdFx0cGFydGlhbCA9IGZhbHNlXG5cblx0XHRmb3IgKCBsZXQga2V5IGluIGRpZmYgKSBpZiAoIGtleSAhPSBgX19wYXJ0aWFsX19gICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggZGlmZiwga2V5ICkgKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBkaWZmWyBrZXkgXVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0Y29udGludWVcblx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gYG9iamVjdGAgKVxuXHRcdFx0XHR2YWx1ZSA9IGx1LmFwcGx5RGlmZiggcmV0ICYmIHJldFsga2V5IF0sIHZhbHVlLCBwYXJ0aWFsIClcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCApIHtcblx0XHRcdFx0aWYgKCByZXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHJldCwga2V5ICkgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXQgPT09IGRlc3QgKVxuXHRcdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRcdGRlbGV0ZSByZXRbIGtleSBdXG5cdFx0XHRcdFx0LS1jbnRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICggcmV0ID09IG51bGwgfHwgcmV0WyBrZXkgXSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXQgPT09IGRlc3QgKVxuXHRcdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRcdHJldFsga2V5IF0gPSB2YWx1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNudCA9IEluZmluaXR5XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBwYXJ0aWFsID09PSBmYWxzZSApXG5cdFx0XHRmb3IgKCBsZXQga2V5IGluIHJldCApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCByZXQsIGtleSApICkge1xuXHRcdFx0XHRpZiAoICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRpZmYsIGtleSApIHx8IGRpZmZbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXQgPT09IGRlc3QgKVxuXHRcdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRcdGRlbGV0ZSByZXRbIGtleSBdXG5cdFx0XHRcdFx0LS1jbnRcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y250ID0gSW5maW5pdHlcblx0XHRcdH1cblxuXHRcdGlmICggcmV0ICE9PSBkZXN0ICYmIGNudCA9PSAwIClcblx0XHRcdHJldCA9IG51bGxcblxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRtZXJnZURpZmZzKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhID09IG51bGwgKVxuXHRcdFx0YSA9IE5PTl9QQVJUSUFMXG5cdFx0aWYgKCBiID09IG51bGwgKVxuXHRcdFx0YiA9IE5PTl9QQVJUSUFMXG5cblx0XHRpZiAoIGIuX19wYXJ0aWFsX18gPT09IGZhbHNlIClcblx0XHRcdHJldHVybiBiXG5cblx0XHRsZXQgcmV0ID0gYVxuXG5cdFx0ZnVuY3Rpb24gY29weURlc3QoKSB7XG5cdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGZvciAoIGxldCBrZXkgaW4gYSApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBhLCBrZXkgKSApIHtcblx0XHRcdFx0bGV0IHZhbHVlID0gYVsga2V5IF1cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRyZXRbIGtleSBdID0gYVsga2V5IF1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQga2V5IGluIGIgKSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggYiwga2V5ICkgKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBiWyBrZXkgXVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0Y29udGludWVcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCApXG5cdFx0XHRcdHZhbHVlID0gTk9OX1BBUlRJQUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09IGBvYmplY3RgICkge1xuXHRcdFx0XHRsZXQgciA9IHJldCA/IHJldFsga2V5IF0gOiB1bmRlZmluZWRcblx0XHRcdFx0aWYgKCByID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRcdHIgPSBQQVJUSUFMXG5cdFx0XHRcdHZhbHVlID0gbHUubWVyZ2VEaWZmcyggciwgdmFsdWUgKVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByZXQgPT0gbnVsbCB8fCByZXRbIGtleSBdICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCByZXQgPT09IGEgKVxuXHRcdFx0XHRcdGNvcHlEZXN0KClcblx0XHRcdFx0cmV0WyBrZXkgXSA9IHZhbHVlXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCByZXQgIT09IGEgJiYgdHlwZW9mIGEgIT0gYG9iamVjdGAgKVxuXHRcdFx0cmV0Ll9fcGFydGlhbF9fID0gZmFsc2VcblxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRtYWtlRGlmZiggcHJldmlvdXMsIG5leHQgKSB7XG5cdFx0aWYgKCBwcmV2aW91cyA9PT0gbmV4dCApXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0bGV0IHJldCA9IHVuZGVmaW5lZFxuXHRcdGZ1bmN0aW9uIHRvQXJyYXkoIG9iaiApIHtcblx0XHRcdGxldCByZXQgPSBbXVxuXHRcdFx0bG9kYXNoLmZvckVhY2goIG9iaiwgKCB2YWx1ZSwga2V5ICkgPT4gcmV0LnB1c2goIHsgdmFsdWUsIGtleSB9ICkgKVxuXHRcdFx0cmV0dXJuIHJldC5zb3J0KCAoIHYxLCB2MiApID0+XG5cdFx0XHRcdHYxLmtleSA8IHYyLmtleSA/IC0xIDogdjEua2V5ID4gdjIua2V5ID8gMSA6IDAgKVxuXHRcdH1cblx0XHRsZXQgcGEgPSB0b0FycmF5KCBwcmV2aW91cyApXG5cdFx0bGV0IG5hID0gdG9BcnJheSggbmV4dCApXG5cdFx0bGV0IHAgPSBwYS5wb3AoKVxuXHRcdGxldCBuID0gbmEucG9wKClcblx0XHR3aGlsZSAoIHAgfHwgbiApIHtcblx0XHRcdGlmICggIW4gfHwgcCAmJiBwLmtleSA+IG4ua2V5ICkge1xuXHRcdFx0XHRpZiAoICFyZXQgKVxuXHRcdFx0XHRcdHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHRyZXRbIHAua2V5IF0gPSBudWxsIC8vIGRlbGV0aW5nXG5cdFx0XHRcdHAgPSBwYS5wb3AoKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICFwIHx8IHAua2V5IDwgbi5rZXkgKSB7XG5cdFx0XHRcdGlmICggIXJldCApXG5cdFx0XHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdHJldFsgbi5rZXkgXSA9IG4udmFsdWVcblx0XHRcdFx0biA9IG5hLnBvcCgpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCBwLnZhbHVlICE9PSBuLnZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggbHUuaXNTZXQoIHAudmFsdWUgKSAmJiBsdS5pc1NldCggbi52YWx1ZSApICkge1xuXHRcdFx0XHRcdFx0bGV0IGRpZmYgPSBsdS5tYWtlRGlmZiggcC52YWx1ZSwgbi52YWx1ZSApXG5cdFx0XHRcdFx0XHRpZiAoIGRpZmYgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggIXJldCApXG5cdFx0XHRcdFx0XHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdFx0XHRcdHJldFsgbi5rZXkgXSA9IGRpZmZcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXQgKVxuXHRcdFx0XHRcdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdFx0XHRcdHJldFsgbi5rZXkgXSA9IG4udmFsdWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cCA9IHBhLnBvcCgpXG5cdFx0XHRcdG4gPSBuYS5wb3AoKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0ID8gcmV0IDogdW5kZWZpbmVkXG5cdH0sXG5cblx0Y29uY2F0U3RyaW5nOiBhcnJheSA9PiB7XG5cdFx0bGV0IHJldCA9IGBgXG5cdFx0IWZ1bmN0aW9uIHdhbGsoIGFycmF5ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgYXJyYXkgIT0gYG9iamVjdGAgKVxuXHRcdFx0XHRyZXQgKz0gYXJyYXlcblx0XHRcdGVsc2UgaWYgKCBhcnJheS5sZW5ndGggIT0gbnVsbCApXG5cdFx0XHRcdGFycmF5LmZvckVhY2goIHdhbGsgKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmb3IgKCBsZXQgcyBvZiBhcnJheSApXG5cdFx0XHRcdFx0d2FsayggcyApXG5cdFx0fSggYXJyYXkgKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRzb3J0ZWREaWZmKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdGxldCBmaSA9IGZpcnN0WyBTeW1ib2wuaXRlcmF0b3IgXSgpXG5cdFx0bGV0IHNpID0gc2Vjb25kWyBTeW1ib2wuaXRlcmF0b3IgXSgpXG5cdFx0bGV0IHJldCA9IHtcblx0XHRcdGNvbW1vbjogW10sXG5cdFx0XHRmaXJzdDogW10sXG5cdFx0XHRzZWNvbmQ6IFtdLFxuXHRcdH1cblx0XHRsZXQgZnYgPSBmaS5uZXh0KCksIHN2ID0gc2kubmV4dCgpXG5cdFx0d2hpbGUgKCAhZnYuZG9uZSB8fCAhc3YuZG9uZSApIHtcblx0XHRcdGlmICggc3YuZG9uZSB8fCBmdi52YWx1ZSA8IHN2LnZhbHVlICkge1xuXHRcdFx0XHRyZXQuZmlyc3QucHVzaCggZnYudmFsdWUgKVxuXHRcdFx0XHRmdiA9IGZpLm5leHQoKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGZ2LmRvbmUgfHwgZnYudmFsdWUgPiBzdi52YWx1ZSApIHtcblx0XHRcdFx0cmV0LnNlY29uZC5wdXNoKCBzdi52YWx1ZSApXG5cdFx0XHRcdHN2ID0gc2kubmV4dCgpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0LmNvbW1vbi5wdXNoKCBmdi52YWx1ZSApXG5cdFx0XHRcdGZ2ID0gZmkubmV4dCgpXG5cdFx0XHRcdHN2ID0gc2kubmV4dCgpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRtZWFzdXJlKCBmdW4gKSB7XG5cdFx0bGV0IG5vdyA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCBnbG9iYWwuRGF0ZVxuXHRcdGxldCB0ID0gbm93Lm5vdygpXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBmdW4oKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHQgPSAoIG5vdy5ub3coKSAtIHQgKSAvIDEwMDBcblx0XHRcdGlmICggdCA+IDAgKSB7XG5cdFx0XHRcdGxldCBpID0gMVxuXHRcdFx0XHR3aGlsZSAoIHQgPCAxMDAwICkge1xuXHRcdFx0XHRcdGkgKj0gMTBcblx0XHRcdFx0XHR0ICo9IDEwXG5cdFx0XHRcdH1cblx0XHRcdFx0dCA9IE1hdGgucm91bmQoIHQgKSAvIGlcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKCB0IClcblx0XHR9XG5cdH0sXG5cblx0KnNraXAoIGMsIGJ1ZiApIHtcblx0XHRmb3IgKCBsZXQgYiBvZiBidWYgKSB7XG5cdFx0XHRpZiAoIGMgPiAwIClcblx0XHRcdFx0LS1jXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHlpZWxkIGJcblx0XHR9XG5cdH0sXG5cblx0KnRha2UoIGMsIGJ1ZiApIHtcblx0XHRmb3IgKCBsZXQgYiBvZiBidWYgKSB7XG5cdFx0XHRpZiAoIGMgPiAwICkge1xuXHRcdFx0XHQtLWNcblx0XHRcdFx0eWllbGQgYlxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRicmVha1xuXHRcdH1cblx0fSxcblxuXHRjb3B5KCBidWYgKSB7XG5cdFx0bGV0IHJldCA9IGx1LmFycmF5KCBidWYgKVxuXHRcdGlmICggcmV0ID09IGJ1ZiApXG5cdFx0XHRyZXQgPSBidWYuc2xpY2UoKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRhcnJheTEoIHZhbHVlICkge1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApXG5cdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gWyB2YWx1ZSBdXG5cdH0sXG5cblx0YXJyYXkoIGJ1ZiApIHtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGJ1ZiApIClcblx0XHRcdHJldHVybiBidWZcblx0XHRsZXQgcmV0ID0gW11cblx0XHRpZiAoICFidWZbIFN5bWJvbC5pdGVyYXRvciBdIClcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSApXG5cdFx0XHRcdHJldC5wdXNoKCBidWZbIGkgXSApXG5cdFx0ZWxzZVxuXHRcdFx0Zm9yICggbGV0IGIgb2YgYnVmIClcblx0XHRcdFx0cmV0LnB1c2goIGIgKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRidWZmZXIoIGJ1ZiApIHtcblx0XHRpZiAoIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlciApXG5cdFx0XHRyZXR1cm4gYnVmXG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXIoIGx1LmFycmF5KCBidWYgKSApXG5cdH0sXG5cblx0dmVjdG9yKCBidWYgKSB7XG5cdFx0cmV0dXJuIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlciA/IGJ1ZiA6IGx1LmFycmF5KCBidWYgKVxuXHR9LFxuXG5cdCpjb25jYXQoIGxpc3QgKSB7XG5cdFx0Zm9yICggbGV0IGwgb2YgbGlzdCApIGZvciAoIGxldCB4IG9mIGwgKSB5aWVsZCB4XG5cdH0sXG5cblx0d29yZCggdyApIHtcblx0XHRyZXR1cm4gWyB3ICYgMHhmZiwgKCB3ID4+IDggKSAmIDB4ZmYgXVxuXHR9LFxuXG5cdGR3b3JkKCB3ICkge1xuXHRcdHJldHVybiBbIHcgJiAweGZmLCAoIHcgPj4gOCApICYgMHhmZiwgKCB3ID4+IDE2ICkgJiAweGZmLCAoIHcgPj4gMjQgKSAmIDB4ZmYgXVxuXHR9LFxuXG5cdG1ha2VXb3JkKCBsbywgaGkgKSB7XG5cdFx0cmV0dXJuICggbG8gJiAweGZmICkgKyAoIGhpICYgMHhmZiApIDw8IDhcblx0fSxcblxuXHRhcnJheUVxdWFsKCBhLCBiICkge1xuXHRcdHJldHVybiBhICYmIGIgJiYgYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSggKCBhaSwgaSApID0+IGFpID09IGJbIGkgXSApXG5cdH0sXG5cblx0Y29tcGFyZSggYSwgYiApIHtcblx0XHRpZiAoIGEgPT0gYiApXG5cdFx0XHRyZXR1cm4gMFxuXHRcdGlmICggYSA8IGIgKVxuXHRcdFx0cmV0dXJuIC0xXG5cdFx0cmV0dXJuIDFcblx0fSxcblxuXHRmb3JtYXRtcyggdmFsdWUgKSB7XG5cdFx0bGV0IHJldCA9IGBgXG5cdFx0dmFsdWUgPSBNYXRoLnJvdW5kKCB2YWx1ZSApXG5cdFx0bGV0IG1zID0gdmFsdWUgJSAxMDAwXG5cdFx0dmFsdWUgLT0gbXNcblx0XHR2YWx1ZSAvPSAxMDAwXG5cdFx0bGV0IHMgPSB2YWx1ZSAlIDYwXG5cdFx0dmFsdWUgLT0gc1xuXHRcdHZhbHVlIC89IDYwXG5cdFx0bGV0IG0gPSB2YWx1ZSAlIDYwXG5cdFx0dmFsdWUgLT0gbVxuXHRcdHZhbHVlIC89IDYwXG5cdFx0bGV0IGggPSB2YWx1ZVxuXHRcdHJldCArPSBoID8gaCA6IGBgXG5cdFx0cmV0ICs9IHJldCA/IGA6YCArIHooIG0sIDIgKSA6IG0gPyBtIDogYGBcblx0XHRyZXQgKz0gcmV0ID8gYDpgICsgeiggcywgMiApIDogc1xuXHRcdHJldCArPSBgLmAgKyB6KCBtcywgMyApXG5cdFx0cmV0dXJuIHJldFxuXHRcdGZ1bmN0aW9uIHooIHZhbHVlLCBsZW4gKSB7XG5cdFx0XHRsZXQgc3RyID0gU3RyaW5nKCB2YWx1ZSApXG5cdFx0XHRsZXQgcmV0ID0gYGBcblx0XHRcdGZvciAoIGxldCBpID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpIClcblx0XHRcdFx0cmV0ICs9IGAwYFxuXHRcdFx0cmV0ICs9IHN0clxuXHRcdFx0cmV0dXJuIHJldFxuXHRcdH1cblx0fSxcblxuXHRnZXQoIG9iaiwgLi4ucGF0aCApIHtcblx0XHRmb3IgKCBsZXQgcCBvZiBwYXRoIClcblx0XHRcdGlmICggb2JqID09IG51bGwgKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvYmogPSBvYmpbIHAgXVxuXHRcdHJldHVybiBvYmpcblx0fSxcblxuXHRsaW1pdENhbGxzKCBsaW1pdCwgcGVyaW9kLCBtZXNzYWdlICkge1xuXHRcdGxldCBjYWxscyA9IDBcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0aWYgKCBjYWxscyA+PSBsaW1pdCApXG5cdFx0XHRcdGlmICggbWVzc2FnZSApXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yLmNyZWF0ZSggbWVzc2FnZSApXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdCsrY2FsbHNcblx0XHRcdHNldFRpbWVvdXQoICgpID0+IC0tY2FsbHMsIHBlcmlvZCApXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0fSxcblxufVxuXG5mdW5jdGlvbiBfY29weSggb2JqICkge1xuXHRsZXQgcmV0ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdGZvciAoIGxldCBrZXkgaW4gb2JqICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIG9iaiwga2V5ICkgKSB7XG5cdFx0bGV0IHZhbHVlID0gb2JqWyBrZXkgXVxuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRjb250aW51ZVxuXHRcdHJldFsga2V5IF0gPSBvYmpbIGtleSBdXG5cdH1cblx0cmV0dXJuIHJldFxufVxuXG4iLCJsZXQgZGV2aWNlVHlwZXMgPSByZXF1aXJlKCBgbmV0cm8vZGV2aWNlVHlwZXNgIClcblxubGV0IGFjdGlvbnMgPSB7XG5cdFVwOiBkZXZpY2UgPT4gMSxcblx0RG93bjogZGV2aWNlID0+IDAsXG5cdENvbWZvcnRfMTogZGV2aWNlID0+IGRldmljZS5jb21mb3J0XzEsXG5cdENvbWZvcnRfMjogZGV2aWNlID0+IGRldmljZS5jb21mb3J0XzIsXG5cdFN0b3A6IGRldmljZSA9PiBudWxsLFxuXHRMb29wOiBkZXZpY2UgPT4gZGV2aWNlLnN0YXRlID8gMCA6IDEsXG5cdFNjcmlwdDogZGV2aWNlID0+IG51bGwsXG5cdExpbms6IGRldmljZSA9PiBudWxsLFxuXHRTZXQ6ICggXywgZGF0YSApID0+IGRhdGEsXG59XG5cbmZ1bmN0aW9uIGdldE5ld1N0YXRlKCBkZXZpY2UsIGFjdGlvbiwgZGF0YSApIHtcblx0Ly8gbGV0IHR5cGUgPSBkZXZpY2VUeXBlc1sgZGV2aWNlLm1vZGVsIF1cblx0cmV0dXJuIGRldmljZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGFjdGlvbnMsIGFjdGlvbiApID8gYWN0aW9uc1sgYWN0aW9uIF0oIGRldmljZSwgZGF0YSApIDogbnVsbFxufVxuXG5leHBvcnRzLmdldE5ld1N0YXRlID0gZ2V0TmV3U3RhdGVcbiIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJOZXJvIElJIDg3MTMtNTBcIjoge1xuXHRcdFwiYnV0dG9uc1wiOiBcIlJvbGxTaHV0dGVyXCJcblx0fSxcblx0XCJJbnRybyBJSSA4NTEzLTUwXCI6IHtcblx0XHRcImJ1dHRvbnNcIjogXCJSb2xsU2h1dHRlclwiXG5cdH0sXG5cdFwiTmVybyBJSSA4NDIxXCI6IHtcblx0XHRcImJ1dHRvbnNcIjogXCJEaW1lZXJcIlxuXHR9XG59IiwiXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoIE9iamVjdC5wcm90b3R5cGUsIGBfTE9HX2AsIHsgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0Y29uc29sZS5sb2coIHRoaXMgKVxuXHRyZXR1cm4gdGhpc1xufSwgY29uZmlndXJhYmxlOiB0cnVlIH0gKVxuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT0gYGZ1bmN0aW9uYCAmJiBTeW1ib2wuaXRlcmF0b3IgKSB7XG5cdGxldCB4ID0gbnVsbFxuXHR0cnkge1xuXHRcdHggPSBldmFsLmNhbGwoIG51bGwsIGAoZnVuY3Rpb24qKCl7fSgpLmNvbnN0cnVjdG9yLnByb3RvdHlwZSlgIClcblx0fSBjYXRjaCAoIF8gKSB7fVxuXHRpZiAoIHggJiYgIXhbIFN5bWJvbC5pdGVyYXRvciBdIClcblx0XHR4WyBTeW1ib2wuaXRlcmF0b3IgXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMgfVxufVxuIiwiLypcblxuVE9ETzpcblxuKiBXYXJuaW5nIGlmIGEgbGl2ZSBwcm9wZXJ0eSBoYXMgbm90IGJlZW4gcmVhZCBkdXJpbmcgdGhlIGxpZmUgdGltZSBvZiBvYnNlcnZhYmxlIHZhbHVlIG9yIGR1cmluZyBzb21lIHBlcmlvZCBvZiB0aW1lIChlLmcuIDEtMzAgbWludXRlcykgc2luY2UgY3JlYXRpbmcgdGhhdCBvYnNlcnZhYmxlIHZhbHVlLlxuXG4qIGNoZWNrIGZvciBjaGFuZ2VzIGR1cmluZyBleGVjdXRpb24gb2YgKGZ1bmN0aW9uKikgYW5kIHJlc3RhcnQgY2FsY3VsdXMuXG5cblxuVE9ETyBCVUc6XG5sZXQgYXBwID0gcmEuY2xlYW4oIHtcblx0bW92aW5nMToge1xuXHRcdGE6IDEsXG5cdFx0YjogMixcblx0XHRjOiB7XG5cdFx0XHRkOiAzLFxuXHRcdH0sXG5cdH0sXG59XG5fYXBwLm1vdmluZzEuYVxuMVxuX2FwcC5tb3ZpbmcxLmMuZFxuM1xuX2FwcC5tb3ZpbmcxPXthOjR9XG5PYmplY3Qge2E6IDR9XG5fYXBwLm1vdmluZzEuYy5kXG4zICAgICAgICAgICAgICAgICAgICAgICA8LS0tLS0tLS0tLS0gISEhICBNVVNUIEJFIE5VTEwgISEhIVxuX2FwcC5tb3ZpbmcxLmNcbkNlbGwge19pZDogXCJqODd5cWtvcXBwdXZcIiwgX3ZhbHVlOiBudWxsLCBfZXJyb3I6IG51bGwsIF9pc1ZhbHVlRXF1YWw6IGZ1bmN0aW9uLCBfaW5pdGlhbGl6ZWQ6IHRydWXigKZ9XG5fYXBwLm1vdmluZzEuYy52YWx1ZU9mKClcbm51bGxcblxuXG4qL1xuXG5sZXQgbGF0ZXIgPSByZXF1aXJlKCBgbGF0ZXJgICkucHVzaFxubGV0IGNvID0gcmVxdWlyZSggYGNvYCApXG5sZXQgVUlEID0gcmVxdWlyZSggYHVpZGAgKVxubGV0IGxvZGFzaCA9IHJlcXVpcmUoIGBsb2Rhc2hgIClcbmxldCB7IExPRyB9ID0gcmVxdWlyZSggYExPR2AgKVxuXG5sZXQgYWN0aW9uS2V5ID0gYF9SQV9BQ1RJT05fJHsgVUlEKCkgfWBcbmxldCByYVZhbHVlID0gYF9SQV9WQUxVRV8keyBVSUQoKSB9YFxuXG4vLyBsZXQgZGVidWdMb2cgPSBmYWxzZVxuXG5sZXQgdXBkYXRlcyA9IHt9XG51cGRhdGVzLnNjaGVkdWxlZCA9IGZhbHNlXG51cGRhdGVzLnByb2NzID0gW11cbnVwZGF0ZXMuaW5kZXggPSAwXG51cGRhdGVzLm1heEluZGV4ID0gMzI3NjhcbnVwZGF0ZXMucHJvY2Vzc2luZyA9IGZhbHNlXG51cGRhdGVzLnRvdGFsVGltZSA9IDBcbnVwZGF0ZXMubWF4VGltZSA9IDBcbnVwZGF0ZXMubWF4VGltZTEgPSAwXG51cGRhdGVzLm1pblRpbWUgPSBJbmZpbml0eVxudXBkYXRlcy5ydW5Db3VudCA9IDBcbnVwZGF0ZXMucnVuQWxsQ291bnQgPSAwXG5cbmdsb2JhbC51cGRhdGVzID0gdXBkYXRlcyAvLyBkZWJ1Z2dlclxuXG5sZXQgcGVyZm9ybWFuY2UgPSBnbG9iYWwucGVyZm9ybWFuY2UgfHwgZ2xvYmFsLkRhdGVcbnVwZGF0ZXMuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG51cGRhdGVzLmxvZyA9ICgpID0+IGNvbnNvbGUubG9nKCBgOjogJHsgdXBkYXRlcy50b3RhbFRpbWUgLyAxMDAwIH0gLyAkeyAoIHBlcmZvcm1hbmNlLm5vdygpIC0gdXBkYXRlcy5zdGFydCApIC8gMTAwMCB9ICgkeyB1cGRhdGVzLm1heFRpbWUgLyAxMDAwIH0sICR7IHVwZGF0ZXMubWF4VGltZTEgLyAxMDAwIH0sICR7IHVwZGF0ZXMubWluVGltZSAvIDEwMDAgfSwgJHsgQWN0aW9uLm1heENvdW50IH0sICR7IHVwZGF0ZXMucnVuQ291bnQgfSwgJHsgdXBkYXRlcy5ydW5BbGxDb3VudCB9KWAgKVxuXG4vLyBjby5nbyggZnVuY3Rpb24qICgpIHsgLy8gZGVidWdnZXJcbi8vIFx0bGV0IHNsZWVwNTAwMCA9IGNvLnNsZWVwKCA1MDAwIClcbi8vIFx0Zm9yICg7Oykge1xuLy8gXHRcdGxldCB0b3RhbFRpbWUgPSB1cGRhdGVzLnRvdGFsVGltZVxuLy8gXHRcdHlpZWxkIHNsZWVwNTAwMFxuLy8gXHRcdGlmICggdG90YWxUaW1lICE9IHVwZGF0ZXMudG90YWxUaW1lIClcbi8vIFx0XHRcdHVwZGF0ZXMubG9nKClcbi8vIFx0fVxuLy8gfSApXG5cbnVwZGF0ZXMuY2hlY2tTY2hlZHVsZSA9ICgpID0+IHtcblx0aWYgKCAhdXBkYXRlcy5zY2hlZHVsZWQgJiYgdXBkYXRlcy5wcm9jcy5sZW5ndGggPiAwICkge1xuXHRcdHVwZGF0ZXMuc2NoZWR1bGVkID0gdHJ1ZVxuXHRcdGxhdGVyKCB1cGRhdGVzLnRpY2sgKVxuXHR9XG59XG5cbnVwZGF0ZXMudGljayA9ICgpID0+IHtcblx0dXBkYXRlcy5zY2hlZHVsZWQgPSBmYWxzZVxuXHRmb3IgKCBsZXQgX3RyeSA9IDA7IF90cnkgPCAxMDAwOyArK190cnkgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHVwZGF0ZXMucnVuQWxsKClcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCAoKSA9PiB7IHRocm93IGVycm9yIH0sIDEgKVxuXHRcdH1cblx0fVxuXHR1cGRhdGVzLmNoZWNrU2NoZWR1bGUoKVxufVxuXG51cGRhdGVzLnJ1bkFsbCA9ICgpID0+IHtcblx0Ly8gaWYgKCB1cGRhdGVzLnByb2Nlc3NpbmcgKVxuXHQvLyBcdHJldHVyblxuXG5cdGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cdGxldCBzdDEgPSBzdGFydFxuXHRsZXQgcnVuQ291bnQgPSB1cGRhdGVzLnJ1bkNvdW50XG5cblx0bGV0IHByb2Nlc3NpbmcgPSB1cGRhdGVzLnByb2Nlc3Npbmdcblx0dXBkYXRlcy5wcm9jZXNzaW5nID0gdHJ1ZVxuXHRsZXQgYWN0aW9uID0gY28uZ2xvYmFsWyBhY3Rpb25LZXkgXVxuXHRpZiAoIGFjdGlvbiAhPSBudWxsIClcblx0XHRjby5nbG9iYWxbIGFjdGlvbktleSBdID0gbnVsbFxuXHR0cnkge1xuXHRcdHdoaWxlICggdXBkYXRlcy5pbmRleCA8IHVwZGF0ZXMucHJvY3MubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBnbG9iYWwuQVBQX1RJTUVPVVQgJiYgZ2xvYmFsLkFQUF9USU1FT1VUIDwgRGF0ZS5ub3cgKSB7XG5cdFx0XHRcdGFsZXJ0KCBgQXBwbGljYXRpb24gaXMgcnVubmluZyB0b28gbG9uZ2AgKVxuXHRcdFx0fVxuXHRcdFx0bGV0IHByb2MgPSB1cGRhdGVzLnByb2NzWyB1cGRhdGVzLmluZGV4IF1cblx0XHRcdCsrdXBkYXRlcy5pbmRleFxuXHRcdFx0Kyt1cGRhdGVzLnJ1bkNvdW50XG5cdFx0XHRpZiAoIHVwZGF0ZXMuaW5kZXggPj0gdXBkYXRlcy5tYXhJbmRleCAmJiB1cGRhdGVzLmluZGV4ICogMyA+IHVwZGF0ZXMucHJvY3MubGVuZ3RoICkge1xuXHRcdFx0XHR1cGRhdGVzLnByb2NzLnNwbGljZSggMCwgdXBkYXRlcy5pbmRleCApXG5cdFx0XHRcdHVwZGF0ZXMuaW5kZXggPSAwXG5cdFx0XHR9XG5cdFx0XHRwcm9jKClcblx0XHRcdGxldCB0MSA9IHBlcmZvcm1hbmNlLm5vdygpXG5cdFx0XHRpZiAoIHVwZGF0ZXMubWF4VGltZTEgPCB0MSAtIHN0MSApXG5cdFx0XHRcdHVwZGF0ZXMubWF4VGltZTEgPSB0MSAtIHN0MVxuXHRcdFx0Ly8gaWYgKCB0MSAtIHN0MSA+IDEwIClcblx0XHRcdC8vIFx0Y29uc29sZS5sb2coIHQxIC0gc3QxLCBgYCArIHByb2MuJG5hbWUgKSAvLyBkZWJ1Z2dlclxuXHRcdFx0c3QxID0gdDFcblx0XHR9XG5cdFx0dXBkYXRlcy5pbmRleCA9IHVwZGF0ZXMucHJvY3MubGVuZ3RoID0gMFxuXHR9XG5cdGZpbmFsbHkge1xuXHRcdGlmICggYWN0aW9uICE9IG51bGwgKVxuXHRcdFx0Y28uZ2xvYmFsWyBhY3Rpb25LZXkgXSA9IGFjdGlvblxuXHRcdHVwZGF0ZXMucHJvY2Vzc2luZyA9IHByb2Nlc3Npbmdcblx0XHRpZiAoICFwcm9jZXNzaW5nICkge1xuXHRcdFx0bGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0XG5cdFx0XHR1cGRhdGVzLnRvdGFsVGltZSArPSB0aW1lXG5cdFx0XHRpZiAoIHVwZGF0ZXMubWF4VGltZSA8IHRpbWUgKVxuXHRcdFx0XHR1cGRhdGVzLm1heFRpbWUgPSB0aW1lXG5cdFx0XHRydW5Db3VudCA9IHVwZGF0ZXMucnVuQ291bnQgLSBydW5Db3VudFxuXHRcdFx0aWYgKCBydW5Db3VudCAgKSB7XG5cdFx0XHRcdCsrdXBkYXRlcy5ydW5BbGxDb3VudFxuXHRcdFx0XHRpZiAoIHVwZGF0ZXMubWluVGltZSA+IHRpbWUgKVxuXHRcdFx0XHRcdHVwZGF0ZXMubWluVGltZSA9IHRpbWVcblx0XHRcdH1cblx0XHRcdGlmICggdGltZSA+IDMwMCApXG5cdFx0XHRcdExPRyggYHVwZGF0ZXMgaGF2ZSBiZWVuIHJ1biBmb3IgJHsgdGltZS50b1N0cmluZygpLnJlZCB9IG1zYCApXG5cdFx0fVxuXHR9XG59XG5cbnVwZGF0ZXMubGF0ZXIgPSBwcm9jID0+IHtcblx0dXBkYXRlcy5wcm9jcy5wdXNoKCBwcm9jIClcblx0dXBkYXRlcy5jaGVja1NjaGVkdWxlKClcbn1cblxudXBkYXRlcy5sYXRlci50aGVuID0gdXBkYXRlcy5sYXRlclxuXG5sZXQgZW1wdHlNYXAgPSB0eXBlb2YgSW1tdXRhYmxlID09IGB1bmRlZmluZWRgID8gbnVsbCA6IEltbXV0YWJsZS5NYXAoKVxubGV0IGNoZWNrTnVsbCA9IHZhbHVlID0+IHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT0gZW1wdHlNYXAgPyBudWxsIDogdmFsdWVcbmxldCBjaGVja01hcCA9IHZhbHVlID0+IHZhbHVlID09IG51bGwgPyBlbXB0eU1hcCA6IHZhbHVlXG5sZXQgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMgfVxuXG5sZXQgaXNMaXRlcmFsID0gdmFsdWUgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IGBvYmplY3RgICYmIHZhbHVlLmNvbnN0cnVjdG9yID09IE9iamVjdFxubGV0IGdldFZhbHVlID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZS52YWx1ZU9mID09IG51bGwgPyB2YWx1ZSA6IHZhbHVlLnZhbHVlT2YoKVxubGV0IGNsb3NlID0gdmFsdWUgPT4gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5jbG9zZSAhPSBudWxsICYmIHZhbHVlLmNsb3NlKClcblxuLy8gbGV0IF9tID0gb2JqID0+IGNoZWNrTWFwKCBvYmoudmFsdWVPZigpIClcblxuZnVuY3Rpb24gQWJzdHJhY3RHdWFyZCgpIHt9XG5cbmxldCBpbnZhbGlkS2V5Q2FsbCA9IGZ1bmN0aW9uICgga2V5ICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIGBhY2Nlc3MgdG8gYW4gdW5kZWNsYXJlZCBwcm9wZXJ0eSBcIiR7IHRoaXMuJG5hbWUgfS4keyBrZXkgfVwiYCApXG59XG5cbmxldCB1c2VkUHJvcHMgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcbmxldCB1c2VkUHJvcHNQcm90byA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxubGV0IGd1YXJkUHJvcCA9IGtleSA9PiB7XG5cdGlmICggIXVzZWRQcm9wc1sga2V5IF0gKSB7XG5cdFx0dXNlZFByb3BzWyBrZXkgXSA9IHRydWVcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVzZWRQcm9wc1Byb3RvLCBrZXksIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG5cdFx0fSApXG5cdH1cbn1cbkFic3RyYWN0R3VhcmQucHJvdG90eXBlID0gdXNlZFByb3BzUHJvdG9cblxuLy8g0J3QtSDQt9GA0LDQt9GD0LzQtdC70LAg0YLQvtC70LrQsNC8LCDRj9C6INCz0Y3RgtGLIFByb3h5INC/0YDQsNGG0YPQtSDRniDRj9C60LDRgdGM0YbRliDQv9GA0LDRgtCw0YLRi9C/0YMuXG4vLyDQn9Cw0LrRg9C70Ywg0YjRgtC+LCDQt9C00LDQtdGG0YbQsCwg0L/QsNCy0L7QtNC30ZbQvdGLINC90LUg0LDQtNC/0LDQstGP0LTQsNGO0YbRjCDRgdGM0L/QtdGG0YvRhNGW0LrQsNGG0YvRliAoMjAxNC4xMS4yNSlcblxuLy8gaWYgKCB0eXBlb2YgUHJveHkgPT0gXCJmdW5jdGlvblwiICkge1xuLy8gXHRBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSA9IG5ldyBQcm94eSggQWJzdHJhY3RHdWFyZC5wcm90b3R5cGUsIHtcbi8vIFx0XHRnZXQ6IGZ1bmN0aW9uICggXywga2V5ICkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuLy8gXHRcdHNldDogZnVuY3Rpb24gKCBfLCBrZXkgKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG4vLyBcdH0gKVxuLy8gfVxuXG5pZiAoIGdsb2JhbC5BUFBfREVCVUcgKSB7XG5cdC8vXG5cdC8vINCw0LEn0Y/RntC70LXQvdGM0L3QtSDQsNCxJ9C10LrRgtCwINC3IH43MDAtODAwINGD0LvQsNGB0YzRhtGW0LLQsNGB0YzRhtGP0Z4g0Lcg0YTRg9C90LrRhtGL0Y/QvNGWINGH0YvRgtCw0L3RjNC90Y8v0LfQsNC/0ZbRgdGDXG5cdC8vINC30LDQudC80LDQtSDRniBHb29nbGUgQ2hyb21lJ9C1INC60LDQu9GPINGC0YDQsNGG0ZbQvdGLINGB0LXQutGD0L3QtNGLLlxuXHQvLyDQn9GA0LDQstC10YDQsNC90YvRjyDRgdC/0L7RgdCw0LHRizpcblx0Ly8gLSDQtNCw0LHQsNGe0LvQtdC90YzQvdC1INC/0LAg0LDQtNC90YvQvCDQv9GA0LDQtyBPYmplY3QuZGVmaW5lUHJvcGVydHlcblx0Ly8gLSDQtNCw0LHQsNGe0LvQtdC90YzQvdC1INCz0YPRgNGC0LDQvCDQv9GA0LDQtyBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuXHQvLyAtINC60LDQvNC/0ZbQu9GP0YbRi9GPINC30YvRhdC+0LTQvdGW0LrQsCDQv9GA0LDQtyDQu9Cw0LrQsNC70YzQvdGLIGV2YWxcblx0Ly8gLSDQutCw0LzQv9GW0LvRj9GG0YvRjyDQt9GL0YXQvtC00L3RltC60LAg0L/RgNCw0Lcg0LPQu9Cw0LHQsNC70YzQvdGLIGV2YWxcblx0Ly8gLSDQutCw0LzQv9GW0LvRj9GG0YvRjyDQt9GL0YXQvtC00L3RltC60LAg0L/RgNCw0Lcg0LTQsNCx0LDRntC70LXQvdGM0L3QtSDRgtGN0LPRgyBzY3JpcHQg0Lcg0LfRi9GF0L7QtNC90ZbQutCw0Lxcblx0Ly8g0J3QtSDQv9GA0LDQstC10YDQsNC90YvRjyDRgdC/0L7RgdCw0LHRizpcblx0Ly8gLSDQtNCw0LHQsNGe0LvQtdC90YzQvdC1INGC0Y3Qs9GDIHNjcmlwdCDQtyDQv9Cw0LfQvdCw0LrQsNC5IHNyY1xuXHQvLyDQn9Cw0LvRj9C/0YjQsNC1INGB0ZbRgtGD0LDRhtGL0Y4gKNC90LDQv9Cw0LvQvtCy0YMpOlxuXHQvLyAtINGB0YLQstCw0YDRjdC90YzQvdC1INC00LvRjyDQutC+0LbQvdCw0Lkg0YPQu9Cw0YHRjNGG0ZbQstCw0YHRjNGG0ZYg0L3QvtCy0LDQs9CwINCw0LEn0LXQutGC0LAg0YHQsCDRgdGC0LDRgNGL0Lwg0LDQsSfQtdC60YLQsNC8XG5cdC8vINGDINGP0LrQsNGB0YzRhtGWINC/0YDQsNGC0LDRgtGL0L/Rgy4g0J/RgNGLINCz0Y3RgtGL0Lwg0LTQvtGB0YLRg9C/INC00LAg0L3QtdCw0LEn0Y/RntC70LXQvdGL0YUg0YPQu9Cw0YHRjNGG0ZbQstCw0YHRjNGG0Y/RniDQvNC+0LbQsFxuXHQvLyDRgdGC0LDRhtGMINCw0LTQvdC+0YHQvdCwINC00L7RntCz0ZbQvCDQv9CwINGH0LDRgdC1LCDQsNC70LUg0LYg0LPRjdGC0LAg0L3RjyDRgtCw0Log0LLQsNC20L3QsCwg0LHQviDRniDQstGL0L3RltC60YMg0Z7RgdGRINCw0LTQvdC+XG5cdC8vINC60ZbQtNCw0LXRhtGG0LAg0L/QsNC80YvQu9C60LAuXG5cdC8vXG5cdC8vINCT0LXQvdC10YDQsNGG0YvRjyDRgtGN0LrRgdGC0YMg0LfRi9GF0L7QtNC90ZbQutCwINCw0LTQsdGL0LLQsNC10YbRhtCwINGW0LzQs9C90LXQvdC90LAuXG5cdC8vXG5cdC8vINCX0YvRhdC+0LTQt9GP0YfRiyDQtyDQs9GN0YLQsNCz0LAg0YPQu9GD0YfQsNGG0Ywg0YHRgtGA0LDQttC90ZbQutCw0Z4g0LTQvtGB0YLRg9C/0YMg0LTQsCDQvdC10LDQsSfRj9Ge0LvQtdC90YvRhSDRg9C70LDRgdGM0YbRltCy0LDRgdGM0YbRj9GeXG5cdC8vINGC0YDRjdCx0LAg0YLQvtC70YzQutGWINC/0YDRiyDQsNC00LvQsNC00YbRiy5cblx0Ly9cblx0QWJzdHJhY3RHdWFyZC5wcm90b3R5cGUgPVxuXHRcdCggZ2xvYmFsLl9fVXNlZFNjcmlwdElkZW50aWZpZXJzX18gKyBgYCApXG5cdFx0LnNwbGl0KCAvW1xccyxdKy8gKVxuXHRcdC5yZWR1Y2UoICggcHJvdG8sIGtleSApID0+XG5cdFx0XHRPYmplY3QuY3JlYXRlKCBwcm90bywgeyBbIGtleSBdOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggXyApIHsgaW52YWxpZEtleUNhbGwuY2FsbCggdGhpcywga2V5ICkgfSxcblx0XHRcdH0gfSApLFxuXHRcdFx0QWJzdHJhY3RHdWFyZC5wcm90b3R5cGUgKVxufVxuXG5BYnN0cmFjdEd1YXJkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFic3RyYWN0R3VhcmQucHJvdG90eXBlLCB7XG5cdHRvU3RyaW5nOiB7IHZhbHVlOiB7fS50b1N0cmluZyB9LFxuXHR2YWx1ZU9mOiB7IHZhbHVlOiB7fS52YWx1ZU9mIH0sXG5cdHRvTG9jYWxlU3RyaW5nOiB7IHZhbHVlOiB7fS50b0xvY2FsZVN0cmluZyB9LFxuXHRoYXNPd25Qcm9wZXJ0eTogeyB2YWx1ZToge30uaGFzT3duUHJvcGVydHkgfSxcblx0aXNQcm90b3R5cGVPZjogeyB2YWx1ZToge30uaXNQcm90b3R5cGVPZiB9LFxuXHRwcm9wZXJ0eUlzRW51bWVyYWJsZTogeyB2YWx1ZToge30ucHJvcGVydHlJc0VudW1lcmFibGUgfSxcblx0JG5hbWU6IHsgdmFsdWU6IGA8Li4uPmAsIHdyaXRhYmxlOiAxIH0sXG59IClcblxubGV0IEVNUFRZX0FSUkFZID0gW11cbk9iamVjdC5mcmVlemUoIEVNUFRZX0FSUkFZIClcblxuY2xhc3MgSW1tdXRhYmxlSW50ZXJmYWNlIGV4dGVuZHMgQWJzdHJhY3RHdWFyZCB7XG5cblx0Ly8gZGVidWdnZXJcblx0Z2V0IHByb3BzKCkgeyB0aHJvdyBuZXcgRXJyb3IoIGBhY2Nlc3MgdG8gZGVwcmVjYXRlZCAncHJvcHMnIHByb3BlcnR5IGRldGVjdGVkYCApIH1cblxuXHRnZXQgZGVjbGFyZWRQcm9wZXJ0aWVzKCkgeyByZXR1cm4gdGhpcy5saXZlIH1cblxuXHRnZXQgbGVuZ3RoKCkgeyBsZXQgbSA9IHRoaXMudmFsdWVPZigpOyByZXR1cm4gbSA9PSBudWxsID8gMCA6IE9iamVjdC5rZXlzKCBtICkubGVuZ3RoIH1cblxuXHRnZXQoIGtleSApIHtcblx0XHRpZiAoIGtleSAhPSBudWxsICkge1xuXHRcdFx0bGV0IG0gPSB0aGlzLnZhbHVlT2YoKVxuXHRcdFx0aWYgKCBtICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBtLCBrZXkgKSApXG5cdFx0XHRcdHJldHVybiBtWyBrZXkgXVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbFxuXHR9XG5cblx0bWFwKCBmdW4gKSB7XG5cdFx0bGV0IG0gPSB0aGlzLnZhbHVlT2YoKVxuXHRcdHJldHVybiBtICYmICggQXJyYXkuaXNBcnJheSggbSApID8gbG9kYXNoLm1hcCggbSwgZnVuICkgOiBsb2Rhc2gubWFwVmFsdWVzKCBtLCBmdW4gKSApXG5cdH1cblxuXHRrZXlzKCkge1xuXHRcdGxldCBtID0gdGhpcy52YWx1ZU9mKClcblx0XHRyZXR1cm4gbSA9PSBudWxsID8gRU1QVFlfQVJSQVkgOiBPYmplY3Qua2V5cyggbSApXG5cdH1cblxuXHQvLyBjbGVhcigpIHsgbGV0IG0gPSBfbSggdGhpcyApOyByZXR1cm4gbS5jbGVhci5hcHBseSggbSwgYXJndW1lbnRzICkgfVxuXHQvLyBlbnRyaWVzKCkgeyBsZXQgbSA9IF9tKCB0aGlzICk7IHJldHVybiBtLmVudHJpZXMuYXBwbHkoIG0sIGFyZ3VtZW50cyApIH1cblx0Ly8gZ2V0KCkgeyBsZXQgbSA9IF9tKCB0aGlzICk7IHJldHVybiBtLmdldC5hcHBseSggbSwgYXJndW1lbnRzICkgfVxuXHQvLyBrZXlzKCkgeyBsZXQgbSA9IF9tKCB0aGlzICk7IHJldHVybiBtLmtleXMuYXBwbHkoIG0sIGFyZ3VtZW50cyApIH1cblx0Ly8gbGFzdCgpIHsgbGV0IG0gPSBfbSggdGhpcyApOyByZXR1cm4gbS5sYXN0LmFwcGx5KCBtLCBhcmd1bWVudHMgKSB9XG5cdC8vIG1hcCgpIHsgbGV0IG0gPSBfbSggdGhpcyApOyByZXR1cm4gbS5tYXAuYXBwbHkoIG0sIGFyZ3VtZW50cyApIH1cblx0Ly8gbWVyZ2UoKSB7IGxldCBtID0gX20oIHRoaXMgKTsgcmV0dXJuIG0ubWVyZ2UuYXBwbHkoIG0sIGFyZ3VtZW50cyApIH1cblx0Ly8gbWVyZ2VEZWVwKCkgeyBsZXQgbSA9IF9tKCB0aGlzICk7IHJldHVybiBtLm1lcmdlRGVlcC5hcHBseSggbSwgYXJndW1lbnRzICkgfVxuXHQvLyBtZXJnZURlZXBXaXRoKCkgeyBsZXQgbSA9IF9tKCB0aGlzICk7IHJldHVybiBtLm1lcmdlRGVlcFdpdGguYXBwbHkoIG0sIGFyZ3VtZW50cyApIH1cblx0Ly8gbWVyZ2VXaXRoKCkgeyBsZXQgbSA9IF9tKCB0aGlzICk7IHJldHVybiBtLm1lcmdlV2l0aC5hcHBseSggbSwgYXJndW1lbnRzICkgfVxuXHQvLyByZW1vdmUoKSB7IGxldCBtID0gX20oIHRoaXMgKTsgcmV0dXJuIG0ucmVtb3ZlLmFwcGx5KCBtLCBhcmd1bWVudHMgKSB9XG5cdC8vIHNldCgpIHsgbGV0IG0gPSBfbSggdGhpcyApOyByZXR1cm4gbS5zZXQuYXBwbHkoIG0sIGFyZ3VtZW50cyApIH1cblx0Ly8gdXBkYXRlKCkgeyBsZXQgbSA9IF9tKCB0aGlzICk7IHJldHVybiBtLnVwZGF0ZS5hcHBseSggbSwgYXJndW1lbnRzICkgfVxuXHQvLyB1cGRhdGVJbigpIHsgbGV0IG0gPSBfbSggdGhpcyApOyByZXR1cm4gbS51cGRhdGVJbi5hcHBseSggbSwgYXJndW1lbnRzICkgfVxuXHQvLyB2YWx1ZXMoKSB7IGxldCBtID0gX20oIHRoaXMgKTsgcmV0dXJuIG0udmFsdWVzLmFwcGx5KCBtLCBhcmd1bWVudHMgKSB9XG5cdC8vIHdpdGhNdXRhdGlvbnMoKSB7IGxldCBtID0gX20oIHRoaXMgKTsgcmV0dXJuIG0ud2l0aE11dGF0aW9ucy5hcHBseSggbSwgYXJndW1lbnRzICkgfVxuXHQvLyB0b0pTKCkgeyBsZXQgbSA9IF9tKCB0aGlzICk7IHJldHVybiBtLnRvSlMoKSB9XG5cbn1cblxuY2xhc3MgUmVhZE9ubHlDZWxsIGV4dGVuZHMgSW1tdXRhYmxlSW50ZXJmYWNlIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50ICkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLl9wYXJlbnQgPSBwYXJlbnRcblx0fVxuXG5cdGdldFJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcyB9XG5cdGdldCBsaXZlKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LmxpdmUgfVxuXHRnZXQgJG5hbWUoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuJG5hbWUgfVxuXG5cdHZhbHVlT2YoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQudmFsdWVPZi5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cdG5vVG91Y2goKSB7IHJldHVybiB0aGlzLl9wYXJlbnQubm9Ub3VjaC5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cdHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LnRvU3RyaW5nLmFwcGx5KCB0aGlzLl9wYXJlbnQsIGFyZ3VtZW50cyApIH1cblx0dG9KU09OKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LnRvSlNPTi5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cdGdldE5hbWUoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuZ2V0TmFtZS5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cbn1cblxubGV0IEdldHRlciA9ICggZnVuLCBpc1ZhbHVlRXF1YWwgKSA9PiB7XG5cdGxldCBsYXN0XG5cdGxldCByZXQgPSAhaXNWYWx1ZUVxdWFsID9cblx0XHRmdW5jdGlvbiAoKSB7IHJldHVybiBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIH1cblx0OlxuXHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdGxldCByZXQgPSBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0XHRpZiAoICFpcyggbGFzdCwgcmV0LCBpc1ZhbHVlRXF1YWwgKSApXG5cdFx0XHRcdGxhc3QgPSByZXRcblx0XHRcdHJldHVybiBsYXN0XG5cdFx0fVxuXHRyZXQuaXNHZXR0ZXIgPSB0cnVlXG5cdHJldHVybiByZXRcbn1cblxubGV0IFR5cGUgPSAoIGYgKSA9PiB7XG5cdGcudHlwZURlc2NyaXB0b3IgPSB0cnVlXG5cdHJldHVybiBnXG5cdGZ1bmN0aW9uIGcoKSB7IHJldHVybiBmLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSB9XG59XG5cbmxldCBydW5HZXR0ZXIgPSAoIGNlbGwsIGdldHRlciwgc3RpY2t5ICkgPT4gKCBuZXcgQWN0aW9uKCBnZXR0ZXIsIGNlbGwsIHN0aWNreSApICkubGlua05hbWUoIGNlbGwsIGA6Z2V0dGVyYCApXG5cbmxldCBydW5TZXR0ZXIgPSAoIGNlbGwsIHNldHRlciwgc3RpY2t5ICkgPT4gKCBuZXcgQWN0aW9uKCAoKSA9PiBzZXR0ZXIoIGNlbGwudmFsdWVPZigpICksIG51bGwsIHN0aWNreSApICkubGlua05hbWUoIGNlbGwsIGA6c2V0dGVyYCApXG5cbmZ1bmN0aW9uIGlzKCBhLCBiLCBpc0VxdWFsICkge1xuXHRyZXR1cm4gT2JqZWN0LmlzKCBhLCBiICkgfHwgYiAmJiB0eXBlb2YgYi5pc0VxdWFsVG8gPT0gYGZ1bmN0aW9uYCAmJiBiLmlzRXF1YWxUbyggYSApIHx8IGEgJiYgdHlwZW9mIGEuaXNFcXVhbFRvID09IGBmdW5jdGlvbmAgJiYgYS5pc0VxdWFsVG8oIGIgKSB8fCB0eXBlb2YgaXNFcXVhbCA9PSBgZnVuY3Rpb25gICYmIGlzRXF1YWwoIGEsIGIgKVxufVxuXG5jbGFzcyBUaGlzIHtcblx0c3RhdGljIGNyZWF0ZSggcGFyZW50LCB0aGF0ICkge1xuXHRcdGxldCByZXQgPSBudWxsXG5cdFx0aWYgKCAhcGFyZW50IClcblx0XHRcdHJldCA9IG5ldyBUaGlzXG5cdFx0ZWxzZVxuXHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggcGFyZW50IClcblx0XHRyZXQudmFsdWVPZiA9ICgpID0+IHRoYXQudmFsdWVPZigpXG5cdFx0cmV0LnRvU3RyaW5nID0gKCkgPT4gdGhhdC50b1N0cmluZygpXG5cdFx0cmV0LnRvSlNPTiA9ICgpID0+IHRoYXQudG9KU09OKClcblx0XHRyZXQuYXNzaWduID0gdmFsdWUgPT4gdGhhdC5hc3NpZ24oIHZhbHVlIClcblx0XHRyZXQudGhyb3cgPSB2YWx1ZSA9PiB0aGF0LnRocm93KCB2YWx1ZSApXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCByZXQsIGBsaXZlYCwgeyBnZXQ6ICgpID0+IHRoYXQubGl2ZSB9IClcblx0XHRyZXR1cm4gcmV0XG5cdH1cblx0X2RlZmluZVRoYXRQcm9wZXJ0eSgga2V5LCB0aGF0ICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywga2V5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0KCkgeyByZXR1cm4gdGhhdFsga2V5IF0gfSxcblx0XHRcdHNldCggdmFsdWUgKSB7IHRoYXRbIGtleSBdID0gdmFsdWUgfSxcblx0XHR9IClcblx0fVxufVxuXG5jbGFzcyBDZWxsIGV4dGVuZHMgSW1tdXRhYmxlSW50ZXJmYWNlIHtcblxuXHRjb25zdHJ1Y3Rvciggc3RpY2t5ICkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLl9pZCA9IFVJRCgpXG5cdFx0dGhpcy5fdGhhdCA9IG51bGxcblx0XHR0aGlzLl92YWx1ZSA9IG51bGxcblx0XHR0aGlzLl9lcnJvciA9IG51bGxcblx0XHR0aGlzLl9pc1ZhbHVlRXF1YWwgPSBpc1xuXHRcdHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2Vcblx0XHR0aGlzLl9mcm96ZW4gPSBmYWxzZVxuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlXG5cdFx0dGhpcy5fZGlydHkgPSBmYWxzZVxuXHRcdHRoaXMuX2xpdmUgPSBudWxsXG5cdFx0dGhpcy5fbGl2ZUFycmF5ID0gbnVsbFxuXHRcdHRoaXMuX2FjdGlvbnNBcnIgPSBbXVxuXHRcdHRoaXMuX3BhcmVudCA9IG51bGxcblx0XHR0aGlzLl9vbmNoYW5nZSA9IFtdXG5cdFx0dGhpcy4kbmFtZSA9IHsgdG9TdHJpbmc6ICgpID0+IHRoaXMuZ2V0TmFtZSgpIH1cblx0XHR0aGlzLl9ub3RpZnlXcml0dGVuKClcblx0XHR0aGlzLl9zdGlja3kgPSAhIXN0aWNreVxuXHR9XG5cblx0dmFsdWVPZigpIHsgcmV0dXJuIHRoaXMuX3JlYWQoKSB9XG5cdGFzc2lnbiggdmFsdWUgKSB7IHJldHVybiB0aGlzLl93cml0ZSggdmFsdWUsIGZhbHNlLCBudWxsICkgfVxuXHR1cGRhdGUoIGRpZmYgKSB7IHJldHVybiB0aGlzLmFzc2lnbiggbHUuYXBwbHlEaWZmKCB0aGlzLm5vVG91Y2goKSwgZGlmZiApICkgfVxuXHR0aHJvdyggdmFsdWUgKSB7IHJldHVybiB0aGlzLl93cml0ZSggbnVsbCwgZmFsc2UsIHZhbHVlICkgfVxuXHR0b3VjaCgpIHsgdGhpcy5fZmlyZSgpIH1cblxuXHRub1RvdWNoKCkge1xuXHRcdGlmICggdGhpcy5fZGlydHkgKVxuXHRcdFx0dGhpcy5fdXBkYXRlU2VsZigpXG5cdFx0aWYgKCB0aGlzLl9lcnJvciApXG5cdFx0XHR0aHJvdyB0aGlzLl9lcnJvclxuXHRcdHJldHVybiB0aGlzLl92YWx1ZVxuXHR9XG5cblx0dGhlbiggcHJvYyApIHtcblx0XHR0aGlzLl9vbmNoYW5nZS5wdXNoKCBwcm9jIClcblx0fVxuXG5cdGNsb3NlKCkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkIClcblx0XHRcdHJldHVyblxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWVcblx0XHR0aGlzLl9maXJlKClcblx0XHRpZiAoIHRoaXMuX3BhcmVudCApXG5cdFx0XHR0aGlzLl9wYXJlbnQuY2xvc2UoKVxuXHRcdGlmICggdGhpcy5fbGl2ZUFycmF5ICkge1xuXHRcdFx0Zm9yICggbGV0IHAgb2YgdGhpcy5fbGl2ZUFycmF5IClcblx0XHRcdFx0cC5jbG9zZSgpXG5cdFx0XHR0aGlzLl9saXZlQXJyYXkgPSBudWxsXG5cdFx0fVxuXHRcdHRoaXMuX3ZhbHVlID0gbnVsbFxuXHRcdHRoaXMuX2Vycm9yID0gbnVsbFxuXHRcdHRoaXMuX2FjdGlvbnNBcnIgPSBudWxsXG5cdFx0dGhpcy5fcGFyZW50ID0gbnVsbFxuXHR9XG5cblx0ZnJlZXplKCkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkIHx8IHRoaXMuX2Zyb3plbiApXG5cdFx0XHRyZXR1cm5cblx0XHR0aGlzLl9mcm96ZW4gPSB0cnVlXG5cdFx0dGhpcy5fZmlyZSgpIC8vIFRPRE8g0LTQu9GPINCy0YvQtNCw0LvQtdC90YzQvdGPINGB0L/QsNGB0YvQu9Cw0Log0LDQsdGL0YHRjNGG0ZbRgdGPINCx0LXQtyBfZmlyZSDRliDQsNC00L/QsNCy0LXQtNC90LAg0LHQtdC3INC70ZbRiNC90Y/Qs9CwINC/0YDQsNCz0L7QvdGDXG5cdFx0aWYgKCB0aGlzLl9wYXJlbnQgKVxuXHRcdFx0dGhpcy5fcGFyZW50LmZyZWV6ZSgpXG5cdFx0aWYgKCB0aGlzLl9saXZlQXJyYXkgKSB7XG5cdFx0XHRmb3IgKCBsZXQgcCBvZiB0aGlzLl9saXZlQXJyYXkgKVxuXHRcdFx0XHRwLmZyZWV6ZSgpXG5cdFx0fVxuXHR9XG5cblx0Z2V0IGxpdmUoKSB7IHJldHVybiB0aGlzLl9saXZlIH1cblxuXHRnZXRSZWFkT25seSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVhZE9ubHkgfHwgKCB0aGlzLl9yZWFkT25seSA9IG5ldyBSZWFkT25seUNlbGwoIHRoaXMgKSApXG5cdH1cblxuXHR0b1N0cmluZyggLi4uYXJncyApIHtcblx0XHRsZXQgdiA9IHRoaXMuX3JlYWQoKVxuXHRcdHJldHVybiAoIHYgPT0gbnVsbCApIHx8ICF2LnRvU3RyaW5nID8gYGAgKyB2IDogdi50b1N0cmluZyggLi4uYXJncyApXG5cdH1cblxuXHR0b0pTT04oIC4uLmFyZ3MgKSB7XG5cdFx0bGV0IHYgPSB0aGlzLl9yZWFkKClcblx0XHRyZXR1cm4gKCB2ID09IG51bGwgKSB8fCAhdi50b0pTT04gPyB2IDogdi50b0pTT04oIC4uLmFyZ3MgKVxuXHR9XG5cblx0d2l0aCggY2IgKSB7IHJldHVybiBjYi5jYWxsKCB0aGlzLl9nZXRUaGF0KCkgKSB9XG5cblx0c2V0TmFtZSggbmFtZSApIHtcblx0XHR0aGlzLl9uYW1lID0gbmFtZVxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRnZXROYW1lKCkge1xuXHRcdGxldCByZXQgPSB0aGlzLl9uYW1lIHx8IHRoaXMuX2tleVxuXHRcdGxldCBwID0gdGhpcy5fcGFyZW50XG5cdFx0d2hpbGUgKCBwICkge1xuXHRcdFx0cmV0ID0gKCBwLl9uYW1lIHx8IHAuX2tleSApICsgYC5gICsgcmV0XG5cdFx0XHRwID0gcC5fcGFyZW50XG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fVxuXG5cdF9nZXRUaGF0KCkge1xuXHRcdGlmICggIXRoaXMuX3RoYXQgKSB7XG5cdFx0XHR0aGlzLl90aGF0ID0gVGhpcy5jcmVhdGUoIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2dldFRoYXQoKSwgdGhpcyApXG5cdFx0XHRpZiAoIHRoaXMuX2xpdmUgKVxuXHRcdFx0XHRmb3IgKCBsZXQgaSBpbiB0aGlzLl9saXZlIClcblx0XHRcdFx0XHR0aGlzLl90aGF0Ll9kZWZpbmVUaGF0UHJvcGVydHkoIGksIHRoaXMgKVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fdGhhdFxuXHR9XG5cblx0ZGVmaW5lUHJvcGVydHkoIGtleSwgaW5oZXJpdFBhcmVudCA9IGZhbHNlICkge1xuXHRcdC8vIHBhc3Mga2V5ID09IGBgIHRvIG1ha2UgQ2VsbCBvYmplY3QsIG5vdCB2YWx1ZVxuXHRcdGlmICggIXRoaXMuX2xpdmUgKSB7XG5cdFx0XHR0aGlzLl9saXZlID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHR0aGlzLl9saXZlQXJyYXkgPSBbXVxuXHRcdH1cblx0XHRpZiAoICFrZXkgKVxuXHRcdFx0cmV0dXJuXG5cdFx0Z3VhcmRQcm9wKCBrZXkgKVxuXHRcdGxldCBjID0gdGhpcy5fbGl2ZVsga2V5IF1cblx0XHRpZiAoIGMgKVxuXHRcdFx0cmV0dXJuIGNcblx0XHRjID0gbmV3IENlbGwoIHRoaXMuX3N0aWNreSApXG5cdFx0dGhpcy5fbGl2ZVsga2V5IF0gPSBjXG5cdFx0dGhpcy5fbGl2ZUFycmF5LnB1c2goIGMgKVxuXHRcdGMuX2tleSA9IGtleVxuXHRcdGMuX3BhcmVudCA9IHRoaXNcblx0XHRjLl9sZXZlbCA9ICggdGhpcy5fbGV2ZWwgfHwgMCApICsgMVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywga2V5LCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmICggYy5fbGl2ZSApXG5cdFx0XHRcdFx0cmV0dXJuIGNcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldHVybiBjLl9yZWFkKClcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHZhbHVlID0+IHtcblx0XHRcdFx0aWYgKCBjLl9saXZlIClcblx0XHRcdFx0XHR2YWx1ZSA9IGdldFZhbHVlKCB2YWx1ZSApXG5cdFx0XHRcdGMuX3dyaXRlKCB2YWx1ZSwgZmFsc2UgKVxuXHRcdFx0fSxcblx0XHR9IClcblx0XHRpZiAoIHRoaXMuX3RoYXQgKVxuXHRcdFx0dGhpcy5fdGhhdC5fZGVmaW5lVGhhdFByb3BlcnR5KCBrZXksIHRoaXMgKVxuXHRcdGlmICggdGhpcy5fdmFsdWUgIT0gbnVsbCApXG5cdFx0XHRjLl93cml0ZSggdGhpcy5fdmFsdWVbIGtleSBdLCB0cnVlIClcblx0XHRyZXR1cm4gY1xuXHR9XG5cblx0aW5pdCggdmFsdWUgKSB7XG5cdFx0dGhpcy5faW5pdCggdmFsdWUsIGZhbHNlLCBmYWxzZSApXG5cdH1cblxuXHRzZXRDb25zdCggcHJvcCwgdmFsdWUgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBwcm9wLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogKCkgPT4gdmFsdWUgfSApXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdHNldFZhciggcHJvcCwgdmFsdWUgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBwcm9wLCB7IGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9IClcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0Z2V0IFsgcmFWYWx1ZSBdKCkgeyByZXR1cm4gdHJ1ZSB9XG5cblx0X2luaXQoIHZhbHVlLCByZWN1cnNpdmUsIGlzR2V0dGVyLCBpc1ZhbHVlRXF1YWwgKSB7XG5cdFx0bGV0IGNlbGwgPSB0aGlzXG5cdFx0aWYgKCAhcmVjdXJzaXZlICYmIGNlbGwuX2luaXRpYWxpemVkIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYGFscmVhZHkgaW5pdGlhbGl6ZWRgIClcblx0XHRpZiAoIHRoaXMuX3BhcmVudCApXG5cdFx0XHR0aGlzLl9wYXJlbnQuX2RpcnR5ID0gdHJ1ZVxuXHRcdGNlbGwuX2luaXRpYWxpemVkID0gdHJ1ZVxuXHRcdGlmICggaXNWYWx1ZUVxdWFsIClcblx0XHRcdHRoaXMuX2lzVmFsdWVFcXVhbCA9IGlzVmFsdWVFcXVhbFxuXHRcdHZhbHVlID0gY2hlY2tOdWxsKCB2YWx1ZSApXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYGZ1bmN0aW9uYCAmJiB2YWx1ZS50eXBlRGVzY3JpcHRvciApXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKCBjZWxsLl9rZXkgKVxuXHRcdGlmICggdmFsdWUgPT0gbnVsbCApIC8vIHdlIGFyZSBhbHJlYWR5IG51bGwgYXQgdGhlIHBvaW50IG9mIGJpcnRoXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoIHZhbHVlWyByYVZhbHVlIF0gKSAvLyBmb3JjZSBqdXN0IGEgdmFsdWVcblx0XHRcdHJldHVybiBjZWxsLl92YWx1ZSA9IHZhbHVlXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdGlmICggaXNHZXR0ZXIgfHwgdmFsdWUuaXNHZXR0ZXIgKSAvLyBnZXR0ZXJcblx0XHRcdFx0cnVuR2V0dGVyKCBjZWxsLCAoKSA9PiB2YWx1ZS5jYWxsKCBjZWxsLl9wYXJlbnQgJiYgY2VsbC5fcGFyZW50Ll9nZXRUaGF0KCkgKSwgdGhpcy5fc3RpY2t5IClcblx0XHRcdGVsc2UgLy8gbWV0aG9kXG5cdFx0XHRcdGNlbGwuX3ZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuYXBwbHkoIGNlbGwuX3BhcmVudCAmJiBjZWxsLl9wYXJlbnQuX2dldFRoYXQoKSwgYXJndW1lbnRzICkgfVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGlmICggIWlzTGl0ZXJhbCggdmFsdWUgKSApIC8vIGp1c3QgYSB2YWx1ZVxuXHRcdFx0cmV0dXJuIGNlbGwuX3ZhbHVlID0gdmFsdWVcblx0XHQvLyBzdWJyZWNvcmQgZGVzY3JpcHRpb25cblx0XHRpZiAoIHJlY3Vyc2l2ZSApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGB3cm9uZyBwYXJhbWV0ZXJzYCApXG5cdFx0Y2VsbC5kZWZpbmVQcm9wZXJ0eSgpXG5cdFx0Zm9yICggbGV0IGtleSBpbiB2YWx1ZSApIHtcblx0XHRcdGxldCBkZXNjciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHZhbHVlLCBrZXkgKVxuXHRcdFx0aWYgKCAhZGVzY3IgKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0bGV0IGdldCA9IGRlc2NyLmdldFxuXHRcdFx0bGV0IHN1YlZhbHVlID0gZGVzY3IudmFsdWVcblx0XHRcdGlmICggZGVzY3Iuc2V0IClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgd3JvbmcgcGFyYW1ldGVyc2AgKVxuXHRcdFx0ZWxzZSBpZiAoIGdldCApXG5cdFx0XHRcdHN1YlZhbHVlID0gZ2V0XG5cdFx0XHRpZiAoIGtleSA9PSBgJGAgKVxuXHRcdFx0XHRjZWxsLl9pbml0KCBzdWJWYWx1ZSwgdHJ1ZSwgISFnZXQgKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjZWxsLmRlZmluZVByb3BlcnR5KCBrZXksIHRydWUgKS5faW5pdCggc3ViVmFsdWUsIGZhbHNlLCAhIWdldCApXG5cdFx0fVxuXHR9XG5cblx0X3JlYWQoKSB7XG5cdFx0aWYgKCB0aGlzLl9kaXJ0eSApXG5cdFx0XHR0aGlzLl91cGRhdGVTZWxmKClcblx0XHRsZXQgYWN0aW9uID0gY28uZ2xvYmFsWyBhY3Rpb25LZXkgXVxuXHRcdGlmICggYWN0aW9uICkge1xuXHRcdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0XHRhY3Rpb24uY2xvc2UoKVxuXHRcdFx0ZWxzZSBpZiAoICF0aGlzLl9mcm96ZW4gKVxuXHRcdFx0XHRhY3Rpb24ub25yZWFkKCB0aGlzIClcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9lcnJvciApXG5cdFx0XHR0aHJvdyB0aGlzLl9lcnJvclxuXHRcdHJldHVybiB0aGlzLl92YWx1ZVxuXHR9XG5cblx0X3dyaXRlKCBuZXdWYWx1ZSwgZG93biwgbmV3RXJyb3IgKSB7XG5cdFx0aWYgKCBuZXdFcnJvciA9PSBudWxsIClcblx0XHRcdG5ld0Vycm9yID0gbnVsbFxuXHRcdGlmICggdGhpcy5fZnJvemVuIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJUcnkgdG8gY2hhbmdlIGEgZnJvemVuIHZhbHVlXCIgKVxuXHRcdHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZVxuXHRcdHRoaXMuX2RpcnR5ID0gZmFsc2Vcblx0XHRuZXdWYWx1ZSA9IGNoZWNrTnVsbCggbmV3VmFsdWUgKVxuXHRcdGlmICggdGhpcy5fY2xvc2VkICkge1xuXHRcdFx0bGV0IGFjdGlvbiA9IGNvLmdsb2JhbFsgYWN0aW9uS2V5IF1cblx0XHRcdGlmICggYWN0aW9uIClcblx0XHRcdFx0YWN0aW9uLmNsb3NlKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICF0aGlzLl9pc1ZhbHVlRXF1YWwoIHRoaXMuX3ZhbHVlLCBuZXdWYWx1ZSApIHx8IHRoaXMuX2Vycm9yICE9IG5ld0Vycm9yICkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coYD5gK3RoaXMuJG5hbWUpLy9kZWJ1Z2dlclxuXHRcdFx0dGhpcy5fdmFsdWUgPSBuZXdWYWx1ZVxuXHRcdFx0dGhpcy5fZXJyb3IgPSBuZXdFcnJvclxuXHRcdFx0aWYgKCB0aGlzLl9saXZlIClcblx0XHRcdFx0Zm9yICggbGV0IHAgb2YgdGhpcy5fbGl2ZUFycmF5IClcblx0XHRcdFx0XHRwLl93cml0ZSggbmV3VmFsdWUgJiYgbmV3VmFsdWVbIHAuX2tleSBdLCB0cnVlIClcblx0XHRcdHRoaXMuX2ZpcmUoKVxuXHRcdFx0aWYgKCAhZG93biApIHtcblx0XHRcdFx0bGV0IHAgPSB0aGlzLl9wYXJlbnRcblx0XHRcdFx0d2hpbGUgKCBwICYmICFwLl9kaXJ0eSApIHtcblx0XHRcdFx0XHRwLl9kaXJ0eSA9IHRydWVcblx0XHRcdFx0XHRwLl9maXJlKClcblx0XHRcdFx0XHRwID0gcC5fcGFyZW50XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAhZG93biApXG5cdFx0XHR0aGlzLl9ub3RpZnlXcml0dGVuKClcblx0XHRyZXR1cm4gbmV3VmFsdWVcblx0fVxuXG5cdF91cGRhdGVTZWxmKCkge1xuXHRcdGxldCBjbnQgPSAwXG5cdFx0bGV0IHJldCA9IHt9XG5cdFx0Zm9yICggbGV0IGtleSBpbiB0aGlzLl92YWx1ZSApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB0aGlzLl92YWx1ZSwga2V5ICkgKSB7XG5cdFx0XHRyZXRbIGtleSBdID0gdGhpcy5fdmFsdWVbIGtleSBdXG5cdFx0XHQrK2NudFxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBwIG9mIHRoaXMuX2xpdmVBcnJheSApIHtcblx0XHRcdGlmICggcC5fZGlydHkgKVxuXHRcdFx0XHRwLl91cGRhdGVTZWxmKClcblx0XHRcdGlmICggcC5fZXJyb3IgKSB7XG5cdFx0XHRcdHRoaXMuX2Vycm9yID0gcC5fZXJyb3Jcblx0XHRcdFx0dGhpcy5fdmFsdWUgPSBudWxsXG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2Vcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRsZXQgdmFsdWUgPSBwLl92YWx1ZVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsICkge1xuXHRcdFx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggcmV0LCBwLl9rZXkgKSApIHtcblx0XHRcdFx0XHRkZWxldGUgcmV0WyBwLl9rZXkgXVxuXHRcdFx0XHRcdC0tY250XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXRbIHAuX2tleSBdID0gdmFsdWVcblx0XHRcdFx0Y250ID0gSW5maW5pdHlcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGNudCA9PSAwIClcblx0XHRcdHJldCA9IG51bGxcblxuXHRcdHRoaXMuX3ZhbHVlID0gcmV0XG5cdFx0dGhpcy5fZGlydHkgPSBmYWxzZVxuXHR9XG5cblx0ZGVidWcoIGNiICkge1xuXHRcdHRoaXMuX2FjdGlvbnNBcnIucHVzaCggeyBhY3Rpb246IHsgX2ZpcmU6IGNiIH0gfSApXG5cdH1cblxuXHRkZWJ1Z2dlcigpIHtcblx0XHR0aGlzLmRlYnVnKCAoKSA9PiB7IGRlYnVnZ2VyIH0gKVxuXHR9XG5cblx0X2ZpcmUoKSB7XG5cdFx0bGV0IGFcblx0XHRhID0gdGhpcy5fYWN0aW9uc0FyclxuXHRcdGlmICggYS5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRsZXQgYyA9IGFbIGkgXVxuXHRcdFx0XHRpZiAoIGMuYWN0aW9uIClcblx0XHRcdFx0XHRjLmFjdGlvbi5fZmlyZSgpXG5cdFx0XHRcdGMucHVzaGVkQyA9IGZhbHNlXG5cdFx0XHR9XG5cdFx0XHRhLmxlbmd0aCA9IDBcblx0XHR9XG5cdFx0YSA9IHRoaXMuX29uY2hhbmdlXG5cdFx0aWYgKCBhLmxlbmd0aCApIHtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKysgKVxuXHRcdFx0XHR1cGRhdGVzLmxhdGVyKCBhWyBpIF0gKVxuXHRcdFx0YS5sZW5ndGggPSAwXG5cdFx0fVxuXHR9XG5cblx0X25vdGlmeVdyaXR0ZW4oKSB7XG5cdFx0bGV0IGFjdGlvbiA9IGNvLmdsb2JhbFsgYWN0aW9uS2V5IF1cblx0XHRpZiAoIGFjdGlvbiApXG5cdFx0XHRhY3Rpb24ub253cml0dGVuKCB0aGlzIClcblx0fVxuXG59XG5cbmxldCByZXRocm93ID0gZXJyb3IgPT4gc2V0VGltZW91dCggKCkgPT4geyB0aHJvdyBlcnJvciB9LCAxIClcblxuY2xhc3MgQWN0aW9uIHtcblxuXHRjb25zdHJ1Y3RvciggZnVuLCBkZXN0LCBzdGlja3kgKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQoKVxuXHRcdHRoaXMuX2Z1biA9IGZ1blxuXHRcdHRoaXMuX2Rlc3QgPSBkZXN0XG5cdFx0dGhpcy5fY2VsbFNldCA9IHt9XG5cdFx0dGhpcy5fY2VsbFNldFNpemUgPSAwXG5cdFx0dGhpcy5fY2VsbEFyciA9IFtdXG5cdFx0dGhpcy4kbmFtZSA9IHsgdG9TdHJpbmc6ICgpID0+IGA8QWN0aW9uPmAgfVxuXHRcdHRoaXMuX3RocmVhZCA9IGNvLmdvY2FsbCggdGhpcy5fbG9vcCwgdGhpcyApLmxpbmtOYW1lKCB0aGlzICkud2FpdEZvcklucHV0KClcblx0XHR0aGlzLl9ydW5Db3VudCA9IDBcblx0XHRsZXQgb3duZXJcblx0XHRpZiAoICggb3duZXIgPSBjby5nbG9iYWxbIGFjdGlvbktleSBdICkgJiYgb3duZXIuX2NoaWxkcmVuIClcblx0XHRcdG93bmVyLl9jaGlsZHJlbi5wdXNoKCB0aGlzIClcblx0XHR0aGlzLl9jaGlsZHJlbiA9IG51bGxcblx0XHR0aGlzLl90aHJlYWRzID0gbnVsbFxuXHRcdHRoaXMuX29udGhyZWFkID0gbnVsbFxuXHRcdHRoaXMuX2dlbmVyYXRvclByb3h5ID0gbnVsbFxuXHRcdHRoaXMuX2dlbmVyYXRvciA9IG51bGxcblx0XHRpZiAoIHN0aWNreSApIHtcblx0XHRcdHRoaXMuX2NoaWxkcmVuID0gW11cblx0XHRcdHRoaXMuX3RocmVhZHMgPSBbXVxuXHRcdFx0dGhpcy5fb250aHJlYWQgPSB0aHJlYWQgPT4gdGhpcy5fdGhyZWFkcy5wdXNoKCB0aHJlYWQgKVxuXHRcdH1cblx0fVxuXG5cdGxpbmtOYW1lKCB2YWx1ZSwgc3VmZml4ID0gYDphY3Rpb25gICkge1xuXHRcdGlmICggdmFsdWUuJG5hbWUgKVxuXHRcdFx0dmFsdWUgPSB2YWx1ZS4kbmFtZVxuXHRcdHRoaXMuJG5hbWUudG9TdHJpbmcgPSAoKSA9PiBgYCArIHZhbHVlICsgc3VmZml4XG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdF9pbml0R2VuZXJhdG9yUHJveHkoKSB7XG5cdFx0bGV0IF92YWx1ZVxuXHRcdGxldCBfbmV4dCA9ICgpID0+IHRoaXMuX2dlbmVyYXRvci5uZXh0KCBfdmFsdWUgKVxuXHRcdGxldCBfdGhyb3cgPSAoKSA9PiB0aGlzLl9nZW5lcmF0b3IudGhyb3coIF92YWx1ZSApXG5cdFx0bGV0IF9yZXR1cm4gPSAoKSA9PiB0aGlzLl9nZW5lcmF0b3IucmV0dXJuKCBfdmFsdWUgKVxuXHRcdHRoaXMuX2dlbmVyYXRvclByb3h5ID0ge1xuXHRcdFx0WyBTeW1ib2wuaXRlcmF0b3IgXTogcmV0dXJuVGhpcyxcblx0XHRcdG5leHQ6IHYgPT4ge1xuXHRcdFx0XHRfdmFsdWUgPSB2XG5cdFx0XHRcdHRyeSB7IHJldHVybiBjby5jYXRjaFRocmVhZHMoIF9uZXh0LCB0aGlzLl9vbnRocmVhZCApIH1cblx0XHRcdFx0ZmluYWxseSB7IF92YWx1ZSA9IG51bGwgfVxuXHRcdFx0fSxcblx0XHRcdHRocm93OiB2ID0+IHtcblx0XHRcdFx0X3ZhbHVlID0gdlxuXHRcdFx0XHR0cnkgeyByZXR1cm4gY28uY2F0Y2hUaHJlYWRzKCBfdGhyb3csIHRoaXMuX29udGhyZWFkICkgfVxuXHRcdFx0XHRmaW5hbGx5IHsgX3ZhbHVlID0gbnVsbCB9XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuOiB2ID0+IHtcblx0XHRcdFx0X3ZhbHVlID0gdlxuXHRcdFx0XHR0cnkgeyByZXR1cm4gY28uY2F0Y2hUaHJlYWRzKCBfcmV0dXJuLCB0aGlzLl9vbnRocmVhZCApIH1cblx0XHRcdFx0ZmluYWxseSB7IF92YWx1ZSA9IG51bGwgfVxuXHRcdFx0fSxcblx0XHR9XG5cdH1cblxuXHQqX2xvb3AoKSB7XG5cdFx0eWllbGQgdXBkYXRlcy5sYXRlclxuXHRcdGxldCBuZXh0ID0geyB0aGVuOiBuZXh0ID0+IHsgdGhpcy5fb25jaGFuZ2UgPSBuZXh0IH0gfVxuXHRcdGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSB0aGlzXG5cdFx0bGV0IGVycm9yQ2F0Y2hlZCA9IGZhbHNlXG5cdFx0ZXh0ZXJuYWw6IGZvciAoOzspIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAoOzspIHtcblx0XHRcdFx0XHRpZiAoICFlcnJvckNhdGNoZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuaXNDbG9zZWQoKSApXG5cdFx0XHRcdFx0XHRcdGJyZWFrIGV4dGVybmFsXG5cdFx0XHRcdFx0XHR0aGlzLl9iZWdpbigpXG5cdFx0XHRcdFx0XHRlcnJvckNhdGNoZWQgPSB0cnVlXG5cdFx0XHRcdFx0XHRsZXQgcmV0XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuX2NoaWxkcmVuICkge1xuXHRcdFx0XHRcdFx0XHRyZXQgPSBjby5jYXRjaFRocmVhZHMoIHRoaXMuX2Z1biwgdGhpcy5fb250aHJlYWQgKVxuXHRcdFx0XHRcdFx0XHRpZiAoICFyZXQgfHwgcmV0WyByYVZhbHVlIF0gKVxuXHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoIHJldC5uZXh0ICYmIHJldC50aHJvdyApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICF0aGlzLl9nZW5lcmF0b3JQcm94eSApXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0R2VuZXJhdG9yUHJveHkoKVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2dlbmVyYXRvciA9IHJldFxuXHRcdFx0XHRcdFx0XHRcdHRyeSB7IHJldCA9IHlpZWxkKiB0aGlzLl9nZW5lcmF0b3JQcm94eSB9XG5cdFx0XHRcdFx0XHRcdFx0ZmluYWxseSB7IHRoaXMuX2dlbmVyYXRvciA9IG51bGwgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKCByZXQudGhlbiApXG5cdFx0XHRcdFx0XHRcdFx0cmV0ID0geWllbGQgcmV0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gKCAwLCB0aGlzLl9mdW4gKSgpXG5cdFx0XHRcdFx0XHRcdGlmICggIXJldCB8fCByZXRbIHJhVmFsdWUgXSApXG5cdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmICggcmV0Lm5leHQgJiYgcmV0LnRocm93IClcblx0XHRcdFx0XHRcdFx0XHRyZXQgPSB5aWVsZCogcmV0XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKCByZXQudGhlbiApXG5cdFx0XHRcdFx0XHRcdFx0cmV0ID0geWllbGQgcmV0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuX2Rlc3QgKVxuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZXN0LmFzc2lnbiggcmV0IClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXJyb3JDYXRjaGVkID0gZmFsc2Vcblx0XHRcdFx0XHRpZiAoIHRoaXMuaXNDbG9zZWQoKSApXG5cdFx0XHRcdFx0XHRicmVhayBleHRlcm5hbFxuXHRcdFx0XHRcdHN3aXRjaCAoIHRoaXMuX2VuZCgpICkge1xuXHRcdFx0XHRcdGNhc2UgZmFsc2U6XG5cdFx0XHRcdFx0XHRicmVhayBleHRlcm5hbFxuXHRcdFx0XHRcdGNhc2UgdHJ1ZTpcblx0XHRcdFx0XHRcdHlpZWxkIG5leHRcblx0XHRcdFx0XHQvLyBjYXNlIG51bGw6XG5cdFx0XHRcdFx0XHQvKiBpbW1lZGlhdGUgcmVjYWxjdWxhdGlvbiAqL1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0aWYgKCBlcnJvckNhdGNoZWQgKVxuXHRcdFx0XHRcdHRoaXMuX2Rlc3QudGhyb3coIGVycm9yIClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldGhyb3coIGVycm9yIClcblx0XHRcdH1cblx0XHR9XG5cdFx0Y28uZ2xvYmFsWyBhY3Rpb25LZXkgXSA9IG51bGxcblx0XHR0aGlzLl9maW5hbGl6ZSgpXG5cdH1cblxuXHRpc0Nsb3NlZCgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NlbGxTZXRcblx0fVxuXG5cdGNsb3NlKCkge1xuXHRcdGxldCB0aHJlYWQgPSB0aGlzLl90aHJlYWRcblx0XHR0aGlzLl9maXJlKClcblx0XHR0aGlzLl9maW5hbGl6ZSgpXG5cdFx0dGhyZWFkICYmIHRocmVhZC5raWxsKClcblx0fVxuXG5cdF9jbG9zZUNoaWxkcmVuKCkge1xuXHRcdGxldCBjXG5cdFx0aWYgKCBjID0gdGhpcy5fY2hpbGRyZW4gKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjLmxlbmd0aDsgaSA8IGw7ICsraSApXG5cdFx0XHRcdGNbIGkgXS5jbG9zZSgpXG5cdFx0XHRjLmxlbmd0aCA9IDBcblx0XHR9XG5cdFx0aWYgKCBjID0gdGhpcy5fdGhyZWFkcyApIHtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGMubGVuZ3RoOyBpIDwgbDsgKytpIClcblx0XHRcdFx0Y1sgaSBdLmtpbGwoKVxuXHRcdFx0Yy5sZW5ndGggPSAwXG5cdFx0fVxuXHR9XG5cblx0X2ZpbmFsaXplKCkge1xuXHRcdHRoaXMuX3Vuc3Vic2NyaWJlKClcblx0XHR0aGlzLl9jZWxsU2V0ID0gbnVsbFxuXHRcdHRoaXMuX2NlbGxBcnIgPSBudWxsXG5cdFx0dGhpcy5fZnVuID0gbnVsbFxuXHRcdHRoaXMuX2Rlc3QgPSBudWxsXG5cdFx0dGhpcy5fdGhyZWFkID0gbnVsbFxuXHR9XG5cblx0X2JlZ2luKCkge1xuXHRcdHRoaXMuX3Vuc3Vic2NyaWJlKClcblx0XHQrK3RoaXMuX3J1bkNvdW50XG5cdFx0aWYgKCBBY3Rpb24ubWF4Q291bnQgPCB0aGlzLl9ydW5Db3VudCApIHtcblx0XHRcdEFjdGlvbi5tYXhDb3VudCA9IHRoaXMuX3J1bkNvdW50XG5cdFx0fVxuXHR9XG5cblx0X3Vuc3Vic2NyaWJlKCkge1xuXHRcdHRoaXMuX29uY2hhbmdlID0gbnVsbFxuXHRcdGxldCBhID0gdGhpcy5fY2VsbEFyclxuXHRcdGlmICggYSApIHtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdGxldCBjID0gYVsgaSBdXG5cdFx0XHRcdGMuY2VsbCA9IG51bGxcblx0XHRcdFx0Yy52YWx1ZSA9IG51bGxcblx0XHRcdFx0Yy5hY3Rpb24gPSBudWxsXG5cdFx0XHRcdGMucmVhZCA9IGZhbHNlXG5cdFx0XHRcdGMud3JpdHRlbiA9IGZhbHNlXG5cdFx0XHRcdGMucHVzaGVkQSA9IGZhbHNlXG5cdFx0XHRcdC8vIGRvIG5vdCBjaGFuZ2UgYy5wdXNoZWRDIGhlcmUhIVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLl9jZWxsU2V0U2l6ZSA+IDMyICYmIGEubGVuZ3RoIDwgdGhpcy5fY2VsbFNldFNpemUgLyA0ICkge1xuXHRcdFx0XHR0aGlzLl9jZWxsU2V0ID0ge31cblx0XHRcdFx0dGhpcy5fY2VsbFNldFNpemUgPSAwXG5cdFx0XHR9XG5cdFx0XHRhLmxlbmd0aCA9IDBcblx0XHR9XG5cdFx0dGhpcy5fY2xvc2VDaGlsZHJlbigpXG5cdH1cblxuXHRfZW5kKCkge1xuXHRcdGxldCByZXQgPSBmYWxzZVxuXHRcdGxldCBhID0gdGhpcy5fY2VsbEFyclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRsZXQgYyA9IGFbIGkgXVxuXHRcdFx0aWYgKCBjLndyaXR0ZW4gKVxuXHRcdFx0XHRjLmFjdGlvbiA9IG51bGxcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoICFjLnB1c2hlZEMgKSB7XG5cdFx0XHRcdFx0Yy5jZWxsLl9hY3Rpb25zQXJyLnB1c2goIGMgKVxuXHRcdFx0XHRcdGMucHVzaGVkQyA9IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpcyggYy52YWx1ZSwgYy5jZWxsLl92YWx1ZSApIHx8IGMuZXJyb3IgIT0gYy5jZWxsLl9lcnJvciApXG5cdFx0XHRcdFx0cmV0dXJuIG51bGxcblx0XHRcdFx0Yy5hY3Rpb24gPSB0aGlzXG5cdFx0XHRcdHJldCA9IHRydWVcblx0XHRcdH1cblx0XHRcdGMudmFsdWUgPSBudWxsXG5cdFx0XHRjLmNlbGwgPSBudWxsXG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fVxuXG5cdF9saW5rQ2VsbCggY2VsbCApIHtcblx0XHRsZXQgYyA9IHRoaXMuX2NlbGxTZXRbIGNlbGwuX2lkIF1cblx0XHRpZiAoIGMgPT0gbnVsbCApIHtcblx0XHRcdGMgPSB0aGlzLl9jZWxsU2V0WyBjZWxsLl9pZCBdID0ge1xuXHRcdFx0XHRjZWxsOiBudWxsLFxuXHRcdFx0XHR2YWx1ZTogbnVsbCxcblx0XHRcdFx0ZXJyb3I6IG51bGwsXG5cdFx0XHRcdGFjdGlvbjogbnVsbCxcblx0XHRcdFx0cmVhZDogZmFsc2UsXG5cdFx0XHRcdHdyaXR0ZW46IGZhbHNlLFxuXHRcdFx0XHRwdXNoZWRBOiBmYWxzZSxcblx0XHRcdFx0cHVzaGVkQzogZmFsc2UsXG5cdFx0XHR9XG5cdFx0XHQrK3RoaXMuX2NlbGxTZXRTaXplXG5cdFx0fVxuXHRcdGlmICggIWMucHVzaGVkQSApIHtcblx0XHRcdHRoaXMuX2NlbGxBcnIucHVzaCggYyApXG5cdFx0XHRjLmNlbGwgPSBjZWxsXG5cdFx0XHRjLnB1c2hlZEEgPSB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBjXG5cdH1cblxuXHRvbnJlYWQoIGNlbGwgKSB7XG5cdFx0bGV0IGMgPSB0aGlzLl9saW5rQ2VsbCggY2VsbCApXG5cdFx0Yy5yZWFkID0gdHJ1ZVxuXHRcdGMudmFsdWUgPSBjZWxsLl92YWx1ZVxuXHRcdGMuZXJyb3IgPSBjZWxsLl9lcnJvclxuXHR9XG5cblx0b253cml0dGVuKCBjZWxsICkge1xuXHRcdHRoaXMuX2xpbmtDZWxsKCBjZWxsICkud3JpdHRlbiA9IHRydWVcblx0fVxuXG5cdF9maXJlKCkge1xuXHRcdGlmICggdGhpcy5fb25jaGFuZ2UgKVxuXHRcdFx0dXBkYXRlcy5sYXRlciggdGhpcy5fb25jaGFuZ2UgKVxuXHRcdHRoaXMuX3Vuc3Vic2NyaWJlKClcblx0fVxuXG59XG5cbkFjdGlvbi5tYXhDb3VudCA9IDBcblxubGV0IG5ld1JlYWN0aXZlID0gKCBnZXR0ZXIsIGhhbmRsZXJzLCBzdGlja3ksIGlzVmFsdWVFcXVhbCApID0+IHtcblx0Zm9yICggbGV0IGggb2YgaGFuZGxlcnMgKVxuXHRcdGlmICggaCAhPSBudWxsICYmIHR5cGVvZiBoICE9IGBmdW5jdGlvbmAgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgd3JvbmcgcGFyYW1ldGVyc2AgKVxuXHRsZXQgY2VsbCA9IG5ldyBDZWxsKCBzdGlja3kgKVxuXHRpZiAoIGdldHRlciAhPT0gdW5kZWZpbmVkIClcblx0XHRjZWxsLl9pbml0KCBnZXR0ZXIsIGZhbHNlLCB0cnVlLCBpc1ZhbHVlRXF1YWwgKVxuXHRmb3IgKCBsZXQgaCBvZiBoYW5kbGVycyApXG5cdFx0aCAmJiAoIGgubGVuZ3RoID8gcnVuU2V0dGVyIDogcnVuR2V0dGVyICkoIGNlbGwsIGgsIHN0aWNreSApXG5cdHJldHVybiBjZWxsXG59XG5cbmxldCByYSA9IGZ1bmN0aW9uICgpIHtcblx0bGV0IG5hbWUsIGZ1biwgc3RpY2t5LCBpc1ZhbHVlRXF1YWwsIGluZGV4ID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDFcblx0aWYgKCB0eXBlb2YgYXJndW1lbnRzWyBpbmRleCBdID09IFwic3RyaW5nXCIgKVxuXHRcdG5hbWUgPSBhcmd1bWVudHNbIGluZGV4KysgXVxuXHRpZiAoIHR5cGVvZiBhcmd1bWVudHNbIGluZGV4IF0gPT0gXCJib29sZWFuXCIgKVxuXHRcdHN0aWNreSA9IGFyZ3VtZW50c1sgaW5kZXgrKyBdXG5cdGZ1biA9IGFyZ3VtZW50c1sgaW5kZXgrKyBdXG5cdGlmICggdHlwZW9mIGFyZ3VtZW50c1sgaW5kZXggXSA9PSBcImZ1bmN0aW9uXCIgKVxuXHRcdGlzVmFsdWVFcXVhbCA9IGFyZ3VtZW50c1sgaW5kZXgrKyBdXG5cdHJldHVybiBuZXdSZWFjdGl2ZSggZnVuLCBbXSwgc3RpY2t5LCBpc1ZhbHVlRXF1YWwgKVxufVxuXG5mdW5jdGlvbiBBcnJheUlzRXF1YWxUbyggYSApIHtcblx0cmV0dXJuICggdGhpcyA9PSBhICkgfHwgQXJyYXkuaXNBcnJheSggYSApICYmIHRoaXMubGVuZ3RoID09IGEubGVuZ3RoICYmIHRoaXMuZXZlcnkoICggZSwgaSApID0+IGlzKCBlLCBhWyBpIF0gKSApXG59XG5cbmZ1bmN0aW9uIEpzb25Jc0VxdWFsVG8oIGEgKSB7XG5cdHJldHVybiAoIHRoaXMgPT0gYSApIHx8IEpTT04uc3RyaW5naWZ5KCB0aGlzICkgPT0gSlNPTi5zdHJpbmdpZnkoIGEgKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByYVxuXG5leHBvcnRzLnJhID0gcmFcblxuZXhwb3J0cy5pcyA9IGlzXG5cbmV4cG9ydHMuQXJyYXkgPSBhcnJheSA9PiB7XG5cdGFycmF5LmlzRXF1YWxUbyA9IEFycmF5SXNFcXVhbFRvXG5cdHJldHVybiBhcnJheVxufVxuXG5leHBvcnRzLkpTT04gPSBvYmogPT4ge1xuXHRvYmouaXNFcXVhbFRvID0gSnNvbklzRXF1YWxUb1xuXHRyZXR1cm4gb2JqXG59XG5cbmV4cG9ydHMuVmFsdWUgPSBvYmogPT4ge1xuXHRvYmogJiYgb2JqLmRlZmluZVByb3BlcnR5KCByYVZhbHVlLCB7IHZhbHVlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UgfSApXG5cdHJldHVybiBvYmpcbn1cblxuZXhwb3J0cy5jbGVhbiA9ICggZ2V0dGVyLCAuLi5oYW5kZXJzICkgPT4gbmV3UmVhY3RpdmUoIGdldHRlciwgaGFuZGVycywgZmFsc2UgKVxuXG5leHBvcnRzLmRldGFjaCA9IGZ1biA9PiB7XG5cdGxldCBvbGRcblx0aWYgKCBvbGQgPSBjby5nbG9iYWxbIGFjdGlvbktleSBdICkge1xuXHRcdGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBudWxsXG5cdFx0dHJ5IHsgcmV0dXJuIGZ1bigpIH0gZmluYWxseSB7IGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBvbGQgfVxuXHR9XG5cdGVsc2Vcblx0XHRyZXR1cm4gZnVuKClcbn1cblxuZXhwb3J0cy5kZXRhY2hlZCA9IGZ1biA9PiBmdW5jdGlvbiAoKSB7XG5cdGxldCBvbGRcblx0aWYgKCBvbGQgPSBjby5nbG9iYWxbIGFjdGlvbktleSBdICkge1xuXHRcdGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBudWxsXG5cdFx0dHJ5IHsgcmV0dXJuIGZ1bi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgfSBmaW5hbGx5IHsgY28uZ2xvYmFsWyBhY3Rpb25LZXkgXSA9IG9sZCB9XG5cdH1cblx0ZWxzZVxuXHRcdHJldHVybiBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG59XG5cbmV4cG9ydHMub24gPSAoIGVtaXR0ZXIsIGV2ZW50LCBnZXR0ZXIgKSA9PiB7XG5cdGxldCByZXQgPSByYSgpXG5cdGxldCBoYW5kbGVyID0gZGF0YSA9PiByZXQuYXNzaWduKCBnZXR0ZXIoIGRhdGEgKSApXG5cdGlmICggZXZlbnQgPT0gYHN0cmluZ2AgKVxuXHRcdGVtaXR0ZXIub24oIGV2ZW50LCBoYW5kbGVyIClcblx0ZWxzZSBmb3IgKCBsZXQgZSBvZiBldmVudCApXG5cdFx0ZW1pdHRlci5vbiggZSwgaGFuZGxlciApXG5cdGhhbmRsZXIoKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydHMuQ2VsbCA9IENlbGxcbmV4cG9ydHMuSW1tdXRhYmxlSW50ZXJmYWNlID0gSW1tdXRhYmxlSW50ZXJmYWNlXG5leHBvcnRzLkFic3RyYWN0R3VhcmQgPSBBYnN0cmFjdEd1YXJkXG5leHBvcnRzLkdldHRlciA9IEdldHRlclxuZXhwb3J0cy5UeXBlID0gVHlwZVxuZXhwb3J0cy5pbXBvcnRGcm9tID0gb2JzZXJ2YWJsZSA9PiBUeXBlKCBuYW1lID0+IEdldHRlciggKCkgPT4gb2JzZXJ2YWJsZS5saXZlWyBuYW1lIF0udmFsdWVPZigpICkgKVxuZXhwb3J0cy5mb3JjZUNhbGN1bGF0aW9ucyA9ICgpID0+IHVwZGF0ZXMucnVuQWxsKClcblxuZnVuY3Rpb24gY3JlYXRlQWN0dWFsKCkge1xuXHRsZXQgcmV0ID0gcmEoKVxuXHRyZXQuYXNzaWduKCByZXQgKVxuXHRyYSggKCkgPT4ge1xuXHRcdGxldCB2YWx1ZSA9IHJldC52YWx1ZU9mKClcblx0XHRyYS5kZXRhY2goICgpID0+IHJldC5hc3NpZ24oIHZhbHVlICkgKVxuXHR9IClcblx0cmV0dXJuIHJldFxufVxuXG5sZXQgX0RCQ2h1bmtfR2V0dGVyID0gVUlEKClcblxuY2xhc3MgREJDaHVuayB7XG5cdGNvbnN0cnVjdG9yKCBnZXR0ZXIsIHNhdmUsIGluaXRpYWwsIHByZXZpb3VzICkge1xuXHRcdHRoaXMuX3ByZXZpb3VzID0gcHJldmlvdXNcblx0XHR0aGlzLl9nZXR0ZXIgPSBnZXR0ZXJcblx0XHR0aGlzLl9zYXZlID0gc2F2ZVxuXHRcdGxldCBjaHVuayA9IHRoaXMuX2NodW5rID0gcmEoKVxuXHRcdGNodW5rLmFzc2lnbiggaW5pdGlhbCApXG5cdFx0bGV0IGFjdHVhbCA9IHRoaXMuX2FjdHVhbCA9IGNyZWF0ZUFjdHVhbCgpXG5cdFx0YWN0dWFsWyBfREJDaHVua19HZXR0ZXIgXSA9IHJhKCAoKSA9PiBsdS5hcHBseURpZmYoIGdldHRlci52YWx1ZU9mKCksIGNodW5rLnZhbHVlT2YoKSApIClcblx0XHR0aGlzLl9zdW1tYXJ5ID0gcmEoICgpID0+IGFjdHVhbC52YWx1ZU9mKClbIF9EQkNodW5rX0dldHRlciBdLnZhbHVlT2YoKSApXG5cdH1cblx0Y3JlYXRlTmV4dCggaW5pdGlhbCA9IG51bGwgKSB7IHJldHVybiBuZXcgREJDaHVuayggdGhpcy5fc3VtbWFyeSwgdGhpcy5fc2F2ZSwgaW5pdGlhbCwgdGhpcy5fYWN0dWFsICkgfVxuXHRnZXQgYmVmb3JlKCkgeyByZXR1cm4gdGhpcy5fZ2V0dGVyLnZhbHVlT2YoKSB9XG5cdGdldCBzdW1tYXJ5KCkgeyByZXR1cm4gdGhpcy5fc3VtbWFyeS52YWx1ZU9mKCkgfVxuXHRnZXQgY2h1bmsoKSB7IHJldHVybiB0aGlzLl9jaHVuay52YWx1ZU9mKCkgfVxuXHRzZXQgY2h1bmsoIHZhbHVlICkgeyB0aGlzLl9jaHVuay5hc3NpZ24oIHZhbHVlICkgfVxuXHR2YWx1ZU9mKCkgeyByZXR1cm4gdGhpcy5jaHVuayB9XG5cdGFzc2lnbiggdmFsdWUgKSB7IHRoaXMuY2h1bmsgPSB2YWx1ZSB9XG5cdHNhdmUoKSB7IHJldHVybiB0aGlzLl9zYXZlKCB0aGlzLmNodW5rICkgfVxuXHR1cGRhdGUoIGRpZmYgKSB7IHJldHVybiB0aGlzLl9jaHVuay51cGRhdGUoIGRpZmYgKSB9XG5cdHNldCggbmFtZSwgdmFsdWUgKSB7IHJldHVybiB0aGlzLl9jaHVuay5zZXQoIG5hbWUsIHZhbHVlICkgfVxuXHRnZXQoIG5hbWUgKSB7IHJldHVybiB0aGlzLl9jaHVuay5nZXQoIG5hbWUgKSB9XG5cdGNsb3NlKCkge1xuXHRcdHRoaXMuX2NodW5rLmFzc2lnbiggbnVsbCApXG5cdFx0aWYgKCB0aGlzLl9wcmV2aW91cyApIHtcblx0XHRcdHRoaXMuX2FjdHVhbC5hc3NpZ24oIHRoaXMuX3ByZXZpb3VzIClcblx0XHRcdHRoaXMuX3ByZXZpb3VzID0gbnVsbFxuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBEQiB7XG5cdGNvbnN0cnVjdG9yKCBnZXR0ZXIsIHNhdmUgKSB7XG5cdFx0dGhpcy5faGVhZCA9IHJhKClcblx0XHR0aGlzLl9oZWFkLmFzc2lnbiggbmV3IERCQ2h1bmsoIGdldHRlciwgc2F2ZSApIClcblx0XHR0aGlzLl92YWx1ZSA9IHJhKCAoKSA9PiB0aGlzLl9oZWFkLnZhbHVlT2YoKS5zdW1tYXJ5IClcblx0fVxuXHRnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMudmFsdWVPZigpIH1cblx0dmFsdWVPZigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUudmFsdWVPZigpXG5cdH1cblx0Y3JlYXRlUmVjb3JkKCBpbml0aWFsID0gbnVsbCApIHsgLy8gbm90IGRldGFjaGVkXG5cdFx0bGV0IHJldCA9IHRoaXMuX2hlYWQudmFsdWVPZigpLmNyZWF0ZU5leHQoKVxuXHRcdHRoaXMuX2hlYWQuYXNzaWduKCByZXQgKVxuXHRcdHJldHVybiByZXRcblx0fVxufVxuXG5leHBvcnRzLmRiID0gKCBnZXR0ZXIsIHNhdmUgKSA9PiBuZXcgREIoIGdldHRlciwgc2F2ZSApXG5cbmZ1bmN0aW9uIHRvS2V5KCBvYmogKSB7XG5cdGlmICggIXRvS2V5LktleXMgKVxuXHRcdHRvS2V5LktleXMgPSB0eXBlb2YgV2Vha01hcCAhPSBgdW5kZWZpbmVkYCA/IG5ldyBXZWFrTWFwIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0bGV0IGlkID0gYF90b19rZXlfJHsgVUlEKCkgfWBcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNldCggb2JqLCB2YWx1ZSApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIGlkLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdH0gKSB9LFxuXHRcdFx0XHRnZXQoIG9iaiApIHsgcmV0dXJuIG9ialsgaWQgXSB9LFxuXHRcdFx0XHRoYXMoIG9iaiApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggb2JqLCBpZCApIH0sXG5cdFx0XHRcdC8vIGRlbGV0ZSggb2JqICkgeyBkZWxldGUgb2JqWyBpZCBdIH0sXG5cdFx0XHR9XG5cdFx0fSgpXG5cdGlmICggb2JqICYmICggdHlwZW9mIG9iaiA9PSBgb2JqZWN0YCB8fCB0eXBlb2Ygb2JqID09IGBmdW5jdGlvbmAgKSApIHtcblx0XHRpZiAoICF0b0tleS5LZXlzLmhhcyggb2JqICkgKVxuXHRcdFx0dG9LZXkuS2V5cy5zZXQoIG9iaiwgVUlEKCkgKVxuXHRcdHJldHVybiB0b0tleS5LZXlzLmdldCggb2JqIClcblx0fVxuXHRyZXR1cm4gdHlwZW9mIG9iaiArIG9ialxufVxuXG5leHBvcnRzLm1ha2VLZXkgPSAoIG9iaiwga2V5ICkgPT4gcmEoICgpID0+IG9iai5nZXQoIGtleSApIClcblxuZXhwb3J0cy5tYXAgPSAoIGFycmF5LCBtYXBwZXIgKSA9PiB7XG5cdGlmICggISggYXJyYXkgaW5zdGFuY2VvZiBDZWxsICkgKVxuXHRcdHRocm93IG5ldyBFcnJvciggXCJyYS5tYXA6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjZWxsXCIgKVxuXHRsZXQgY2FjaGUgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0bGV0IHJldCA9IHJhKClcblx0cmEuZGV0YWNoKCAoKSA9PiByYSggKCkgPT4ge1xuXHRcdC8vIFRPRE8g0L/RgNCw0LLQtdGA0YvRhtGMLCDRiNGC0L4g0L/RgNGLIGFycmF5LmNsb3NlKCkg0LPRjdGC0LAg0YTRg9C90LrRhtGL0Y8g0LDQtNC/0YDQsNGG0L7RntCy0LDQtSDRliDQv9GA0YvQsdGW0LLQsNC1INGe0YHQtSBjYWNoZVtdLmluZGV4INGWIGNhY2hlW10ucHJvY1xuXHRcdGxldCBhID0gYXJyYXkudmFsdWVPZigpXG5cdFx0cmEuZGV0YWNoKCAoKSA9PiB7XG5cdFx0XHRsZXQgcmV0YXJyID0gW11cblx0XHRcdGxldCBpbmRleCA9IDBcblx0XHRcdGxvZGFzaC5mb3JFYWNoKCBjYWNoZSwgYyA9PiBjLmFiYW5kb25lZCA9IHRydWUgKVxuXHRcdFx0YSAmJiBhLmZvckVhY2goIHZhbHVlID0+IHtcblx0XHRcdFx0bGV0IGtleSA9IHRvS2V5KCB2YWx1ZSApXG5cdFx0XHRcdGxldCBjXG5cdFx0XHRcdGlmICggISggYyA9IGNhY2hlWyBrZXkgXSApIClcblx0XHRcdFx0XHRjID0gY2FjaGVbIGtleSBdID0ge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0aW5kZXg6IHJhKCksXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjLmFiYW5kb25lZCA9IGZhbHNlXG5cdFx0XHRcdGMuaW5kZXguYXNzaWduKCBpbmRleCsrIClcblx0XHRcdFx0aWYgKCAhYy5wcm9jIClcblx0XHRcdFx0XHRjLnByb2MgPSByYSggKCkgPT4gbWFwcGVyKCB2YWx1ZSwgYy5pbmRleCApIClcblx0XHRcdFx0cmV0YXJyLnB1c2goIGMucHJvYyApXG5cdFx0XHR9IClcblx0XHRcdGxvZGFzaC5rZXlzKCBjYWNoZSApLmZvckVhY2goIGtleSA9PiB7XG5cdFx0XHRcdGxldCBjID0gY2FjaGVbIGtleSBdXG5cdFx0XHRcdGlmICggYy5hYmFuZG9uZWQgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXkgXVxuXHRcdFx0XHRcdGMuaW5kZXguY2xvc2UoKVxuXHRcdFx0XHRcdGMucHJvYy5jbG9zZSgpXG5cdFx0XHRcdH1cblx0XHRcdH0gKVxuXHRcdFx0cmV0LmFzc2lnbiggcmEuQXJyYXkoIHJldGFyciApIClcblx0XHR9IClcblx0fSApIClcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnRzLmtleW1hcCA9ICggYXJyYXksIG1hcHBlciApID0+IHtcblx0bGV0IG1hcHBlZCA9IHJhLm1hcCggYXJyYXksIG1hcHBlciApXG5cdHJldHVybiByYSggKCkgPT4gbG9kYXNoLnppcE9iamVjdCggYXJyYXkudmFsdWVPZigpLCBtYXBwZWQudmFsdWVPZigpICkgKVxufVxuXG5leHBvcnRzLnNsaWNlID0gKCBkZXN0LCBzb3VyY2UsIGtleXNWYXIgKSA9PiB7XG5cdHRocm93IG5ldyBFcnJvciggXCJtZXNzYWdlXCIgKVxuXHQvLyBUT0RPOiBvcHRpbWl6YXRpb25cblx0aWYgKCAhKCBkZXN0IGluc3RhbmNlb2YgQ2VsbCApIClcblx0XHRkZXN0ID0gcmEuY2xlYW4oIGRlc3QgKVxuXHRsZXQgY2FjaGVIb2xkZXIgPSByYS5jbGVhbigpXG5cdHJhLmNsZWFuKCAoKSA9PiB7XG5cdFx0bGV0IGtleXMgPSBnZXRWYWx1ZSgga2V5c1ZhciApXG5cdFx0aWYgKCBrZXlzIClcblx0XHRcdGtleXMuc29ydCgpXG5cdFx0dXBkYXRlcy5sYXRlciggKCkgPT4ge1xuXHRcdFx0bGV0IGMgPSByYS5jbGVhbigpXG5cdFx0XHRsZXQgcyA9IGMuZGVmaW5lUHJvcGVydHkoIGBzb3VyY2VgIClcblx0XHRcdGxldCBkID0gYy5kZWZpbmVQcm9wZXJ0eSggYGRlc3RgIClcblx0XHRcdGtleXMgJiYga2V5cy5mb3JFYWNoKCBrID0+IHtcblx0XHRcdFx0bGV0IHNrID0gcy5kZWZpbmVQcm9wZXJ0eSggayApXG5cdFx0XHRcdGxldCBkayA9IGQuZGVmaW5lUHJvcGVydHkoIGsgKVxuXHRcdFx0XHRyYS5jbGVhbiggKCkgPT4gZGsuYXNzaWduKCBzay52YWx1ZU9mKCkgKSApXG5cdFx0XHR9IClcblx0XHRcdGxldCB0ID0gY2FjaGVIb2xkZXIudmFsdWVPZigpXG5cdFx0XHRjYWNoZUhvbGRlci5hc3NpZ24oIGMgKVxuXHRcdFx0dCAmJiB0LmNsb3NlKClcblx0XHR9IClcblx0fSApXG5cdHJhLmNsZWFuKCAoKSA9PiB7XG5cdFx0bGV0IGMgPSBjYWNoZUhvbGRlci52YWx1ZU9mKClcblx0XHRjICYmIGMuc291cmNlICYmIGMuc291cmNlLmFzc2lnbiggc291cmNlLnZhbHVlT2YoKSApXG5cdH0gKVxuXHRyYS5jbGVhbiggKCkgPT4ge1xuXHRcdGxldCBjID0gY2FjaGVIb2xkZXIudmFsdWVPZigpXG5cdFx0ZGVzdC5hc3NpZ24oIGMgJiYgYy5kZXN0ICYmIGMuZGVzdC52YWx1ZU9mKCkgKVxuXHR9IClcblx0cmV0dXJuIGRlc3Rcbn1cbiIsImNvbnN0IG1heEluZGV4ID0gMzI3NjhcblxuY2xhc3MgU2NoZWR1bGVyIHtcblx0Y29uc3RydWN0b3IoIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5zZXRJbW1lZGlhdGUgPSAoIG9wdGlvbnMgJiYgb3B0aW9ucy5zZXRJbW1lZGlhdGUgKSB8fCBwcm9jZXNzLm5leHRUaWNrXG5cdFx0dGhpcy5tYXhUaWNrcyA9ICggb3B0aW9ucyAmJiBvcHRpb25zLm1heFRpY2tzICkgfHwgSW5maW5pdHlcblx0XHR0aGlzLl9wcm9jcyA9IFtdXG5cdFx0dGhpcy5faW5kZXggPSAwXG5cdFx0dGhpcy5fc2NoZWR1bGVkID0gZmFsc2Vcblx0XHR0aGlzLl9wcm9jZXNzaW5nID0gZmFsc2Vcblx0XHR0aGlzLl9oYW5kbGVyID0gdGhpcy5faGFuZGxlci5iaW5kKCB0aGlzIClcblx0XHR0aGlzLnB1c2ggPSB0aGlzLnRoZW4uYmluZCggdGhpcyApXG5cdH1cblxuXHR0aGVuKCBwcm9jICkge1xuXHRcdHRoaXMuX3Byb2NzLnB1c2goIHByb2MgKVxuXHRcdGlmICggIXRoaXMuX3Byb2Nlc3NpbmcgKVxuXHRcdFx0dGhpcy5fc2NoZWR1bGUoKVxuXHR9XG5cblx0X3NjaGVkdWxlKCkge1xuXHRcdGlmICggIXRoaXMuX3NjaGVkdWxlZCApIHtcblx0XHRcdHRoaXMuc2V0SW1tZWRpYXRlKCB0aGlzLl9oYW5kbGVyIClcblx0XHRcdHRoaXMuX3NjaGVkdWxlZCA9IHRydWVcblx0XHR9XG5cdH1cblxuXHRfaGFuZGxlcigpIHtcblx0XHR0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZVxuXHRcdHdoaWxlICggdGhpcy5fcHJvY3MubGVuZ3RoICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5faGFuZGxlcjEoKVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0c2V0VGltZW91dCggKCkgPT4geyB0aHJvdyBlcnJvciB9LCAwIClcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRfaGFuZGxlcjEoKSB7XG5cdFx0dGhpcy5fcHJvY2Vzc2luZyA9IHRydWVcblx0XHR0cnkge1xuXHRcdFx0bGV0IHQgPSAwXG5cdFx0XHR3aGlsZSAoIHRoaXMuX2luZGV4IDwgdGhpcy5fcHJvY3MubGVuZ3RoICYmICggKyt0IDw9IHRoaXMubWF4VGlja3MgKSApIHtcblx0XHRcdFx0bGV0IHByb2MgPSB0aGlzLl9wcm9jc1sgdGhpcy5faW5kZXggXVxuXHRcdFx0XHR0aGlzLl9wcm9jc1sgdGhpcy5faW5kZXggXSA9IG51bGxcblx0XHRcdFx0Kyt0aGlzLl9pbmRleFxuXHRcdFx0XHRpZiAoIHRoaXMuX2luZGV4ID49IG1heEluZGV4ICYmIHRoaXMuX2luZGV4ICogMyA+IHRoaXMuX3Byb2NzLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLl9wcm9jcy5zcGxpY2UoIDAsIHRoaXMuX2luZGV4IClcblx0XHRcdFx0XHR0aGlzLl9pbmRleCA9IDBcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9jKClcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLl9wcm9jZXNzaW5nID0gZmFsc2Vcblx0XHRcdGlmICggdGhpcy5fcHJvY3MubGVuZ3RoICYmIHRoaXMuX2luZGV4ID49IHRoaXMuX3Byb2NzLmxlbmd0aCApXG5cdFx0XHRcdHRoaXMuX3Byb2NzLmxlbmd0aCA9IHRoaXMuX2luZGV4ID0gMFxuXHRcdFx0aWYgKCB0aGlzLl9pbmRleCApXG5cdFx0XHRcdHRoaXMuX3NjaGVkdWxlKClcblx0XHR9XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlZHVsZXJcbiIsImZ1bmN0aW9uIHJldGhyb3coIGVycm9yICkge1xuXHRzZXRUaW1lb3V0KCAoKSA9PiB7IHRocm93IGVycm9yIH0gKVxufVxuXG5mdW5jdGlvbiBzYWZlRWFjaCggYXJyYXksIGNiICkge1xuXHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArK2kgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNiKCBhcnJheS5zaGlmdCgpIClcblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdHJldGhyb3coIGVycm9yIClcblx0XHR9XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTcGFyc2VRdWV1ZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2NicyA9IFtdXG5cdH1cblx0dGhlbiggY2IgKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayggKCkgPT4gY2IoIHVuZGVmaW5lZCApIClcblx0XHRlbHNlXG5cdFx0XHR0aGlzLl9jYnMucHVzaCggY2IgKVxuXHR9XG5cdGlzQ2xvc2VkKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZWRcblx0fVxuXHRjbG9zZSgpIHtcblx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlXG5cdFx0c2FmZUVhY2goIHRoaXMuX2NicywgaGFuZGxlciA9PiBoYW5kbGVyKCB1bmRlZmluZWQgKSApXG5cdH1cblx0cHVzaCggZGF0YSApIHtcblx0XHRpZiAoIHRoaXMuX2Nsb3NlZCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBxdWV1ZSBpcyBhcmVhZHkgY2xvc2VkYCApXG5cdFx0c2FmZUVhY2goIHRoaXMuX2NicywgaGFuZGxlciA9PiBoYW5kbGVyKCBkYXRhICkgKVxuXHR9XG5cdHB1c2hjYiggZGF0YSApIHtcblx0XHRpZiAoIHRoaXMuX2Nsb3NlZCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBxdWV1ZSBpcyBhcmVhZHkgY2xvc2VkYCApXG5cdFx0c2FmZUVhY2goIHRoaXMuX2NicywgaGFuZGxlciA9PiBoYW5kbGVyKCBkYXRhKCkgKSApXG5cdH1cbn1cbiIsIi8qXG5ieSBkZXNpZ246XG7QndC1INGB0YLQstCw0YDQsNC10Lwg0L3RltGP0LrRltGFINCx0YPRhNC10YDQsNGeINC00LvRjyDQv9Cw0LTQt9C10LkgKNC90LDQutGI0YLQsNC70YIgdG91Y2htb3ZlINGG0ZYgbW91c2Vtb3ZlKSAtINC/0LDQtNC30LXRliDRntGB0ZEg0LDQtNC90L4g0LDQu9GM0LHQviDQsNC/0YDQsNGG0L7RntCy0LDRjtGG0YbQsCDRhdGD0YLQutCwLCDQsNC70YzQsdC+INGC0L7Qu9GM0LrRliDQt9Cw0LnQvNCw0Y7RhtGMINC80LXRgdGG0LAg0Z4g0LHRg9GE0LXRgNCw0YUg0ZYg0LfQsNGC0LDRgNC80L7QttCy0LDRjtGG0Ywg0LDQv9GA0LDRhtC+0Z7QutGDLCDQutCw0LvRliDQsNC/0YDQsNGG0L7RntGI0YfRi9C60ZYg0Z7RgdGRINC2INC/0YDQsNGH0L3Rg9GG0YbQsC5cbiovXG5cbmxldCBodG1sdXRpbHMgPSByZXF1aXJlKCBgaHRtbHV0aWxzYCApXG5sZXQgc3BhcnNlcXVldWUgPSByZXF1aXJlKCBgc3BhcnNlcXVldWVgIClcblxubGV0IHRyYWNrcyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXG5zZXRJbnRlcnZhbCggKCkgPT4ge1xuXHRmb3IgKCBsZXQgaWRlbnRpZmllciBpbiB0cmFja3MgKSB7XG5cdFx0bGV0IHRyYWNrID0gdHJhY2tzWyBpZGVudGlmaWVyIF1cblx0XHRpZiAoIHRyYWNrLmFiYW5kb25lZCApIHtcblx0XHRcdC8vIGlmICggdHJhY2suaGFuZGxlci5yZXR1cm4gKVxuXHRcdFx0Ly8gXHR0cmFjay5oYW5kbGVyLnJldHVybigpXG5cdFx0XHQvLyBkZWxldGUgdHJhY2tzWyBpZGVudGlmaWVyIF1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0dHJhY2suYWJhbmRvbmVkID0gdHJ1ZVxuXHR9XG59LCA3MDAwIClcblxuZnVuY3Rpb24gcHVzaEV2ZW50KCB0cmFjaywgZXZlbnQgKSB7XG5cdHRyYWNrLnBvaW50cy5wdXNoKCBldmVudCApXG5cdGlmICggdHJhY2sucHJldmVudERlZmF1bHQgJiYgZXZlbnQucHJldmVudERlZmF1bHQgKVxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KClcbn1cblxuZnVuY3Rpb24gc3RvcEV2ZW50cyggdHJhY2sgKSB7XG5cdHRyYWNrLnBvaW50cy5jbG9zZSgpXG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhY2soIGlkZW50aWZpZXIsIGV2ZW50ICkge1xuXHRsZXQgcG9pbnRzID0gbmV3IHNwYXJzZXF1ZXVlKClcblx0bGV0IGRldGFpbCA9IHtcblx0XHRjYW5jZWxFdmVudDogbnVsbCxcblx0XHRuZXh0OiBwb2ludHMsXG5cdH1cblx0bGV0IHRyYWNrID0ge1xuXHRcdGFiYW5kb25lZDogZmFsc2UsXG5cdFx0Y2xvc2VkOiBmYWxzZSxcblx0XHRkZXRhaWwsXG5cdFx0cG9pbnRzLFxuXHRcdHByZXZlbnREZWZhdWx0OiBmYWxzZSxcblx0fVxuXHR0cmFja3NbIGlkZW50aWZpZXIgXSA9IHRyYWNrXG5cdGxldCByZXQgPSBuZXcgQ3VzdG9tRXZlbnQoIGB0b3VjaGAsIHsgZGV0YWlsLCBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0gKVxuXHRyZXQucGFnZVggPSBldmVudC5wYWdlWFxuXHRyZXQucGFnZVkgPSBldmVudC5wYWdlWVxuXHRyZXQuY2xpZW50WCA9IGV2ZW50LmNsaWVudFhcblx0cmV0LmNsaWVudFkgPSBldmVudC5jbGllbnRZXG5cdHJldC5zY3JlZW5YID0gZXZlbnQuc2NyZWVuWFxuXHRyZXQuc2NyZWVuWSA9IGV2ZW50LnNjcmVlbllcblx0cmV0LnByZXZlbnREZWZhdWx0ID0gKCkgPT4ge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHR0cmFjay5wcmV2ZW50RGVmYXVsdCA9IHRydWVcblx0fVxuXHRldmVudC50YXJnZXQuZGlzcGF0Y2hFdmVudCggcmV0IClcblx0cHVzaEV2ZW50KCB0cmFjaywgZXZlbnQgKVxufVxuXG5mdW5jdGlvbiBvbkV4aXN0aW5nVHJhY2soIGZ1biApIHsgcmV0dXJuICggaWRlbnRpZmllciwgYXJnICkgPT4ge1xuXHRsZXQgdHJhY2sgPSB0cmFja3NbIGlkZW50aWZpZXIgXVxuXHRpZiAoICF0cmFjayApXG5cdFx0cmV0dXJuXG5cdHRyYWNrLmFiYW5kb25lZCA9IGZhbHNlXG5cdGZ1biggdHJhY2ssIGFyZyApXG59IH1cblxubGV0IGNvbnRpbnVlVHJhY2sgPSBvbkV4aXN0aW5nVHJhY2soIHB1c2hFdmVudCApXG5cbmxldCBzdG9wVHJhY2sgPSBvbkV4aXN0aW5nVHJhY2soICggdHJhY2ssIGV2ZW50ICkgPT4ge1xuXHRwdXNoRXZlbnQoIHRyYWNrLCBldmVudCApXG5cdHN0b3BFdmVudHMoIHRyYWNrIClcbn0gKVxuXG5sZXQgcmVtb3ZlVHJhY2sgPSBvbkV4aXN0aW5nVHJhY2soIHN0b3BFdmVudHMgKVxuXG5sZXQgY2FuY2VsVHJhY2sgPSBvbkV4aXN0aW5nVHJhY2soICggdHJhY2ssIGV2ZW50ICkgPT4ge1xuXHR0cmFjay5kZXRhaWwuY2FuY2VsRXZlbnQgPSBldmVudFxuXHRzdG9wRXZlbnRzKCB0cmFjayApXG59IClcblxuZnVuY3Rpb24gZm9yVG91Y2hlcyggZXZlbnQsIGNiICkge1xuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7ICsraSApIHtcblx0XHRsZXQgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5pdGVtKCBpIClcblx0XHRjYiggdG91Y2guaWRlbnRpZmllciwge1xuXHRcdFx0dHlwZTogYHRvdWNobW92ZWAsXG5cdFx0XHRpZGVudGlmaWVyOiB0b3VjaC5pZGVudGlmaWVyLFxuXHRcdFx0dGFyZ2V0OiB0b3VjaC50YXJnZXQsXG5cdFx0XHRzY3JlZW5YOiB0b3VjaC5zY3JlZW5YLFxuXHRcdFx0c2NyZWVuWTogdG91Y2guc2NyZWVuWSxcblx0XHRcdGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG5cdFx0XHRjbGllbnRZOiB0b3VjaC5jbGllbnRZLFxuXHRcdFx0cGFnZVg6IHRvdWNoLnBhZ2VYLFxuXHRcdFx0cGFnZVk6IHRvdWNoLnBhZ2VZLFxuXHRcdFx0cmFkaXVzWDogdG91Y2gucmFkaXVzWCxcblx0XHRcdHJhZGl1c1k6IHRvdWNoLnJhZGl1c1ksXG5cdFx0XHRyb3RhdGlvbkFuZ2xlOiB0b3VjaC5yb3RhdGlvbkFuZ2xlLFxuXHRcdFx0Zm9yY2U6IHRvdWNoLmZvcmNlLFxuXHRcdFx0dGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAsXG5cdFx0XHRwcmV2ZW50RGVmYXVsdDogOjpldmVudC5wcmV2ZW50RGVmYXVsdCxcblx0XHR9IClcblx0fVxuXHRsZXQgY3VycmVudCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBldmVudC50b3VjaGVzLmxlbmd0aDsgKytpIClcblx0XHRjdXJyZW50WyBldmVudC50b3VjaGVzLml0ZW0oIGkgKS5pZGVudGlmaWVyIF0gPSB0cnVlXG5cdGZvciAoIGxldCBpZGVudGlmaWVyIGluIHRyYWNrcyApXG5cdFx0aWYgKCAhKCBpZGVudGlmaWVyIGluIGN1cnJlbnQgKSApXG5cdFx0XHRyZW1vdmVUcmFjayggaWRlbnRpZmllciApXG5cdFx0ZWxzZVxuXHRcdFx0dHJhY2tzWyBpZGVudGlmaWVyIF0uYWJhbmRvbmVkID0gZmFsc2Vcbn1cblxubGV0IGNvbnRhaW5lciA9IGRvY3VtZW50XG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgbW91c2Vkb3duYCwgZXZlbnQgPT4ge1xuXHRpZiAoIGV2ZW50LmJ1dHRvbiA9PSAwIClcblx0XHRzdGFydFRyYWNrKCBgbW91c2VgLCBldmVudCApXG5cdGVsc2UgaWYgKCAhKCBldmVudC5idXR0b25zICYgMSApIClcblx0XHRyZW1vdmVUcmFjayggYG1vdXNlYCApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGBtb3VzZW1vdmVgLCBldmVudCA9PiB7XG5cdGlmICggZXZlbnQuYnV0dG9ucyAmIDEgKVxuXHRcdGNvbnRpbnVlVHJhY2soIGBtb3VzZWAsIGV2ZW50IClcblx0ZWxzZVxuXHRcdHJlbW92ZVRyYWNrKCBgbW91c2VgIClcbn0gKVxuXG5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lciggYG1vdXNldXBgLCBldmVudCA9PiB7XG5cdGlmICggZXZlbnQuYnV0dG9uID09IDAgKVxuXHRcdHN0b3BUcmFjayggYG1vdXNlYCwgZXZlbnQgKVxuXHRlbHNlIGlmICggISggZXZlbnQuYnV0dG9ucyAmIDEgKSApXG5cdFx0cmVtb3ZlVHJhY2soIGBtb3VzZWAgKVxufSApXG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2hzdGFydGAsIGV2ZW50ID0+IHtcblx0Zm9yVG91Y2hlcyggZXZlbnQsIHN0YXJ0VHJhY2sgKVxufSApXG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2htb3ZlYCwgZXZlbnQgPT4ge1xuXHRmb3JUb3VjaGVzKCBldmVudCwgY29udGludWVUcmFjayApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGB0b3VjaGVuZGAsIGV2ZW50ID0+IHtcblx0Zm9yVG91Y2hlcyggZXZlbnQsIHN0b3BUcmFjayApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGB0b3VjaGNhbmNlbGAsIGV2ZW50ID0+IHtcblx0Zm9yVG91Y2hlcyggZXZlbnQsIGNhbmNlbFRyYWNrIClcbn0gKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4ge1xuXHRsZXQgQ29tbWFuZCA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQ29tbWFuZGAgKSApXG5cdHJldHVybiBhdHRyID0+IDxDb21tYW5kXG5cdFx0bWVzc2FnZSA9IFwiY29tbWFuZEFkZEV4aXN0aW5nSXRlbVwiXG5cdFx0b25jbGljayA9IHsgKCkgPT4ge1xuXHRcdFx0YXBwLmRpYWxvZyA9IGBTZWFyY2hJdGVtc2Bcblx0XHRcdGFwcC5zZWFyY2hBY3Rpb24gPSBpdGVtSWQgPT4ge1xuXHRcdFx0XHRhcHAubGlua0l0ZW0oIGFwcC5hY3RpdmVEZXZpY2VJZCwgaXRlbUlkIClcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHR9XG5cdFx0XHRhcHAuc2VhcmNoRmlsdGVyID0gbnVsbFxuXHRcdFx0aWYgKCBhcHAuZGV2aWNlVHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdFx0YXBwLnNlYXJjaEZpbHRlciA9IGl0ZW1JZCA9PiB7XG5cdFx0XHRcdFx0bGV0IGRldmljZSA9IGFwcC5nZXREZXZpY2UoIGl0ZW1JZCApXG5cdFx0XHRcdFx0cmV0dXJuIGRldmljZSAmJiBkZXZpY2UudHlwZSA9PSBgc2luZ2xlYFxuXHRcdFx0XHR9XG5cdFx0fSB9XG5cdFx0XyA9IHsgYXR0ciB9XG5cdC8+XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiB7XG5cdGxldCBDb21tYW5kID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9Db21tYW5kYCApIClcblx0bGV0IEFkZEV4aXN0aW5nSXRlbSA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQWRkRXhpc3RpbmdJdGVtYCApIClcblx0cmV0dXJuIDxkaXY+XG5cdFx0PEFkZEV4aXN0aW5nSXRlbSAvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQ3JlYXRlTmV3R3JvdXBcIlxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4geyBhcHAuYWRkR3JvdXAoIGFwcC5hY3RpdmVEZXZpY2VJZCApIH0gfVxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRBZGROZXdEZXZpY2VcIlxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4gYXBwLmFkZERldmljZSggYXBwLmFjdGl2ZURldmljZUlkICkgfVxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRBZGRQbGFjZVwiXG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiB7XG5cdFx0XHRcdC8vIGFwcC5kaWFsb2cgPSBgQWRkUGxhY2VgXG5cdFx0XHRcdGFwcC5hZGRQbGFjZSggYXBwLmFjdGl2ZURldmljZUlkIClcblx0XHRcdH0gfVxuXHRcdC8+XG5cdDwvZGl2PlxufVxuIiwibGV0IGx1ID0gcmVxdWlyZSggYGxvY2FsVXRpbHNgIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIHsgYXBwaWQsIEljb25UZW1wbGF0ZXMgfSApID0+IHtcblxuXHRsZXQgeyBhcHAsIGxvY2FsIH0gPSByZXF1aXJlKCBgYXBwYCApKCBhcHBpZCApXG5cdGFwcC5wYWdlU3RhcnRpbmcgPSB0cnVlXG5cblx0d2luZG93Ll9hcHAgPSBhcHBcblx0d2luZG93Ll9sb2NhbCA9IGxvY2FsXG5cdHdpbmRvdy5fZGV2ZGIgPSByZXF1aXJlKCBgZGV2ZGJgIClcblxuXHRsZXQgaHR0cENsaWVudCA9IHJlcXVpcmUoIGBodHRwQ2xpZW50YCApXG5cdC8vIGxldCBjb29raWVzID0gcmVxdWlyZSggYGNvb2tpZXNgIClcblx0aWYgKCBuYXZpZ2F0b3Iuc3RhbmRhbG9uZSApXG5cdFx0dm9pZCAwIC8vIGNvb2tpZXMuc2V0SXRlbSggYHN0YW5kYWxvbmVgLCAxLCBJbmZpbml0eSApIC0tINGD0YHRkSDQsNC00L3QviDQvdC1INC/0LDRgdGM0L/Rj9Cy0LDQtdC8INC/0LDRgdGC0LDQstGW0YbRjCDQutGD0LrRgyDQv9C10YDQsNC0INC/0LXRgNGI0YvQvCDQt9Cy0LDRgNC+0YLQsNC8INC00LAg0YHQtdGA0LLQtdGA0LBcblx0ZWxzZSB7XG5cdFx0cmEoICgpID0+IHtcblx0XHRcdGlmICggbG9jYWwuYWN0aXZlRGV2aWNlSWQgJiYgbG9jYWwuYWN0aXZlRGV2aWNlSWQudmFsdWVPZigpICkge1xuXHRcdFx0XHRsZXQgdGl0bGUgPSBgVElUTEVfJHsgbG9jYWwuYWN0aXZlRGV2aWNlSWQgfWBcblx0XHRcdFx0bGV0IGljb24gPSBgSUNPTl8keyBsb2NhbC5hY3RpdmVEZXZpY2VJZCB9YFxuXHRcdFx0XHRzY3JlZW5UaXRsZS5zZXRBdHRyaWJ1dGUoIGBjb250ZW50YCwgdGl0bGUgKVxuXHRcdFx0XHRpZiAoIGxvY2FsLmFjdGl2ZURldmljZUlkICYmIGxvY2FsLmFjdGl2ZURldmljZUlkICE9IGBtYWluYCApXG5cdFx0XHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUoIG51bGwsIHRpdGxlLCBgP2FwcGljb249JHsgaWNvbiB9YClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGhpc3RvcnkucmVwbGFjZVN0YXRlKCBudWxsLCB0aXRsZSwgYD9gKVxuXHRcdFx0XHQvLyBodHRwQ2xpZW50LnBvc3QoIGAvY29va2llP2FwcGljb249JHsgaWNvbiB9YCwgYGAgKVxuXHRcdFx0XHQvLyBjb29raWVzLnNldEl0ZW0oIGBhcHBpY29uYCwgaWNvbiwgSW5maW5pdHkgKVxuXHRcdFx0XHQvLyBMT0coIGxvY2FsLmFjdGl2ZURldmljZUlkLmJsdWUgKVxuXHRcdFx0fVxuXHRcdH0gKVxuXHR9XG5cblx0bGV0IE1haW5TY3JlZW4gPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL01haW5TY3JlZW5gICkgKVxuXHRsZXQgU3RhcnR1cFNjcmVlbiA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvU3RhcnR1cFNjcmVlbmAgKSApXG5cdGxldCBMb2FkaW5nU2NyZWVuID0gKCkgPT4gPGRpdiBjbGFzcyA9IFwibG9hZGluZ1NjcmVlblwiID48L2Rpdj5cblxuXHRsZXQgYXBwbGljYXRpb24gPSA8ZGl2IGNsYXNzID0geyAoKSA9PiBgXG5cdFx0YXBwbGljYXRpb25cblx0XHQkeyBhcHAucGFnZVN0YXJ0aW5nID8gYHBhZ2VTdGFydGluZ2AgOiBgcGFnZVJ1bm5pbmdgIH1cblx0XHQkeyBhcHAuaW5pdGlhbExvYWRpbmcgPyBgSlNPTmxvYWRpbmdgIDogYEpTT05sb2FkZWRgIH1cblx0XHQkeyBhcHAuaW5pdGlhbGl6ZWQgPyBgYWxyZWFkeVJ1bmAgOiBgZmlyc3RSdW5gIH1cblx0XHQkeyBhcHAuY29ubmVjdGVkVG9TZXJ2ZXIgPyBgYXBwQ29ubmVjdGVkYCA6IGBhcHBEaXNjb25uZWN0ZWRgIH1cblx0XHQkeyBgYCAvKiBhcHAuY3JlZGVudGlhbHMgPT0gbnVsbCA/IGBzaG93TG9naW5gIDogYGhpZGVMb2dpbmAgKi8gfVxuXHRcdCR7IGFwcC50ZW1wbGF0ZXMgPyBgdGVtcGxhdGVzTG9hZGVkYCA6IGB0ZW1wbGF0ZXNMb2FkaW5nYCB9XG5cdFx0JHsgYXBwLmRpYWxvZyAmJiBgZGlhbG9nJHsgYXBwLmRpYWxvZyB9YCB9XG5cdFx0JHsgYXBwLmRpYWxvZyA/IGBkaWFsb2dJc1ByZXNlbnRgIDogYGRpYWxvZ0lzQWJzZW50YCB9XG5cdFx0YXBwX2xhYmVsc18keyAhIWxvY2FsLmxhYmVscyB9XG5cdFx0YXBwX2VkaXRpbmdfJHsgISFhcHAuZWRpdGluZyB9XG5cdGAgfSA+XG5cdFx0PE1haW5TY3JlZW4gLz5cblx0XHQ8U3RhcnR1cFNjcmVlbiAvPlxuXHRcdDxMb2FkaW5nU2NyZWVuIC8+XG5cdDwvZGl2PlxuXG5cdGFwcC5pY29ucyA9IEljb25UZW1wbGF0ZXMucmVkdWNlKCAoIGljb25zLCB0ZW1wbGF0ZSApID0+IHtcblx0XHRpY29uc1sgdGVtcGxhdGUuZGF0YXNldC5uYW1lIF0gPSB0ZW1wbGF0ZVxuXHRcdHJldHVybiBpY29uc1xuXHR9LCBPYmplY3QuY3JlYXRlKCBudWxsICkgKVxuXG5cdGxldCBCdXR0b24gPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL0J1dHRvbmAgKSApXG5cblx0bGV0IENsb3NlRXJyb3IgPSAoIGF0dHIsIHRleHQgKSA9PiB7XG5cdFx0cmV0dXJuIDxwXG5cdFx0XHRvbnRvdWNoID0geyAoKSA9PiB7XG5cdFx0XHRcdGxldCBlcnJvciA9IGFwcC5lcnJvclxuXHRcdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdFx0YXBwLmVycm9yID0gbnVsbFxuXHRcdFx0XHRhdHRyLm9uY2xpY2sgJiYgYXR0ci5vbmNsaWNrKCBlcnJvciApXG5cdFx0XHR9IH1cblx0XHRcdF8gPSB7IE9iamVjdC5hc3NpZ24oIHt9LCBhdHRyLCB7IG9uY2xpY2s6IG51bGwgfSApIH1cblx0XHQ+eyB0ZXh0IH08L3A+XG5cdH1cblxuXHRsZXQgQ2xvc2VEaWFsb2cgPSAoIGF0dHIsIHRleHQgKSA9PiB7XG5cdFx0cmV0dXJuIDxwXG5cdFx0XHRvbnRvdWNoID0geyAoKSA9PiB7XG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0XHRhdHRyLm9uY2xpY2sgJiYgYXR0ci5vbmNsaWNrKClcblx0XHRcdH0gfVxuXHRcdFx0XyA9IHsgT2JqZWN0LmFzc2lnbigge30sIGF0dHIsIHsgb25jbGljazogbnVsbCB9ICkgfVxuXHRcdD57IHRleHQgfTwvcD5cblx0fVxuXG5cdC8vIGRpYWxvZ3Ncblx0bGV0IGRpYWxvZ1RlbXBsYXRlcyA9IHtcblxuXHRcdFNlcnZpY2VEaWFsb2c6ICgpID0+IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvU2VydmljZURpYWxvZ2AgKSApLFxuXHRcdENvbnRleHRNZW51OiAoKSA9PiBhcHAubG9hZCggcmVxdWlyZSggYHVpL0NvbnRleHRNZW51YCApICksXG5cdFx0QWRkTWVudTogKCkgPT4gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9BZGRNZW51YCApICksXG5cdFx0U2VhcmNoSXRlbXM6ICgpID0+IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvU2VhcmNoSXRlbXNgICkgKSxcblx0XHRBc2tOZXdOYW1lOiAoKSA9PiBhcHAubG9hZCggcmVxdWlyZSggYHVpL0Fza05ld05hbWVgICkgKSxcblx0XHRBc2tUb0xpbmtEZXZpY2U6ICgpID0+IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQXNrVG9MaW5rRGV2aWNlYCApICksXG5cblx0XHRBc2tJZkRldmljZUhhc0JlZW5MaW5rZWQ6ICgpID0+IDxkaXY+XG5cdFx0XHQ8cD7Qo9GB0YLRgNC+0LnRgdGC0LLQviDQsdGL0LvQviDRg9GB0L/QtdGI0L3QviDQv9GA0LjQstGP0LfQsNC90L4/PC9wPlxuXHRcdFx0PEJ1dHRvbiBvbmNsaWNrID0gXCJTdG9wRGV2aWNlTm90aWZpY2F0aW9uXCIgPtC00LA8L0J1dHRvbj5cblx0XHRcdDxCdXR0b24gb25jbGljayA9IFwiQXNrVG9MaW5rRGV2aWNlXCIgPtC90LXRgjwvQnV0dG9uPlxuXHRcdDwvZGl2PixcblxuXHRcdFN0b3BEZXZpY2VOb3RpZmljYXRpb246ICgpID0+IDxkaXY+XG5cdFx0XHQ8cD7Qn9C+0LbQsNC70YPQudGB0YLQsCw8YnIvPtC/0LXRgNC10LLQtdC00LjRgtC1INGD0YHRgtGA0L7QudGB0YLQstC+INCyINGA0LDQsdC+0YfQuNC5INGA0LXQttC40LwuPC9wPlxuXHRcdFx0PEJ1dHRvbj7Ql9Cw0LrRgNGL0YLRjDwvQnV0dG9uPlxuXHRcdDwvZGl2PixcblxuXHRcdEVycm9yTm9DYXJyaWVyOiAoKSA9PiA8ZGl2IGNsYXNzID0gXCJlcnJvckRpYWxvZ1wiID5cblx0XHRcdDxwPtCe0YjQuNCx0LrQsDwvcD5cblx0XHRcdDxwPtCf0YDQvtC40LfQvtGI0LvQsCDQvtGI0LjQsdC60LAg0L/RgNC4INC/0L7Qv9GL0YLQutC1INGB0LLRj9C30LDRgtGM0YHRjyDRgSDQvNC+0LTQtdC80L7QvC48L3A+XG5cdFx0XHQ8QnV0dG9uPtCX0LDQutGA0YvRgtGMPC9CdXR0b24+XG5cdFx0PC9kaXY+LFxuXG5cdFx0RXJyb3JVbmxpbmtpbmdEZXZpY2U6ICgpID0+IDxkaXYgY2xhc3MgPSBcImVycm9yRGlhbG9nXCIgPlxuXHRcdFx0PHA+0J7RiNC40LHQutCwPC9wPlxuXHRcdFx0PHA+0J3QtSDRg9C00LDQu9C+0YHRjCDRgdCy0Y/Qt9Cw0YLRjNGB0Y8g0YEg0YPRgdGC0YDQvtC50YHRgtCy0L7QvCDQuCDQvtGC0LLRj9C30LDRgtGMINC10LPQvi48L3A+XG5cdFx0XHQ8cD7Qp9GC0L4g0YHQu9C10LTRg9C10YIg0YHQtNC10LvQsNGC0Yw/PC9wPlxuXHRcdFx0PHVsPlxuXHRcdFx0PENsb3NlRXJyb3Igb25jbGljayA9IHsgZXJyb3IgPT4gYXBwLnB1cmdlSXRlbSggZXJyb3IuZGF0YS5kZXZpY2VJZCApIH1cblx0XHRcdFx0PjxsaT7Qn9C+0L/Ri9GC0LDRgtGM0YHRjyDQvtGC0LLRj9C30LDRgtGMINGD0YHRgtGA0L7QudGB0YLQstC+INC10YnRkSDRgNCw0Lc8L2xpPjwvQ2xvc2VFcnJvcj5cblx0XHRcdDxDbG9zZUVycm9yXG5cdFx0XHRcdD48bGk+0J7RgtC80LXQvdC40YLRjCDRg9C00LDQu9C10L3QuNC1PC9saT48L0Nsb3NlRXJyb3I+XG5cdFx0XHQ8Q2xvc2VFcnJvciBvbmNsaWNrID0geyBlcnJvciA9PiBhcHAucHVyZ2VJdGVtKCBlcnJvci5kYXRhLmRldmljZUlkLCB0cnVlICkgfVxuXHRcdFx0XHQ+PGxpPtCX0LDQsdGL0YLRjCDQuNC90YTQvtGA0LzQsNGG0LjRjiDQvtCxINGD0YHRgtGA0L7QudGB0YLQstC1PC9saT48L0Nsb3NlRXJyb3I+XG5cdFx0XHQ8L3VsPlxuXHRcdDwvZGl2PixcblxuXHRcdERlbGV0ZURldmljZTogKCkgPT4gPGRpdj5cblx0XHRcdDxwPnsgKCB7XG5cdFx0XHRcdHBsYWNlOiA8c3Bhbj7Qn9C+0LzQtdGJ0LXQvdC40LUgKNC80LXRgdGC0L4pIFwieyBhcHAuY2FwdGlvbiB9XCIg0LHRg9C00LXRgiDRg9C00LDQu9C10L3QviDQuNC3INC/0YDQvtCz0YDQsNC80LzRiy48L3NwYW4+LFxuXHRcdFx0XHRzaW5nbGU6IDxzcGFuPtCj0YHRgtGA0L7QudGB0YLQstC+IFwieyBhcHAuY2FwdGlvbiB9XCIg0LHRg9C00LXRgiDRg9C00LDQu9C10L3QviDQuNC3INC/0YDQvtCz0YDQsNC80LzRiy48L3NwYW4+LFxuXHRcdFx0XHRncm91cDogPHNwYW4+0JPRgNGD0L/Qv9CwIFwieyBhcHAuY2FwdGlvbiB9XCIg0LHRg9C00LXRgiDRg9C00LDQu9C10L3QsCDQuNC3INC/0YDQvtCz0YDQsNC80LzRiy48L3NwYW4+LFxuXHRcdFx0fSApWyBhcHAuZGV2aWNlVHlwZSBdIH08L3A+XG5cdFx0XHQ8dWw+XG5cdFx0XHQ8Q2xvc2VEaWFsb2cgY2xhc3MgPSBcImRhbmdlcm91c0FjdGlvblwiIG9uY2xpY2sgPSB7ICgpID0+IGFwcC5wdXJnZUl0ZW0oIGFwcC5hY3RpdmVEZXZpY2VJZCApIH1cblx0XHRcdFx0PjxsaT7Qo9C00LDQu9C40YLRjDwvbGk+PC9DbG9zZURpYWxvZz5cblx0XHRcdDxDbG9zZURpYWxvZ1xuXHRcdFx0XHQ+PGxpPtCd0LUg0YPQtNCw0LvRj9GC0Yw8L2xpPjwvQ2xvc2VEaWFsb2c+XG5cdFx0XHQ8L3VsPlxuXHRcdDwvZGl2PixcblxuXHRcdFN0YXRlV2FpdDogKCkgPT4gPGRpdj5cblx0XHRcdDxwPtCf0L7QtNC+0LbQtNC40YLQtS4uLjwvcD5cblx0XHQ8L2Rpdj4sXG5cblx0XHRBc2tUb1Jlc2V0OiAoKSA9PiA8ZGl2PlxuXHRcdFx0PHA+0J/QsNC80Y/RgtGMINC60L7QvdGC0YDQvtC70LvQtdGA0LAg0LHRg9C00LXRgiDQvtGH0LjRidC10L3QsCw8YnIvPtC90L4g0L/QsNC80Y/RgtGMINGD0YHRgtGA0L7QudGB0YLQsiDQvtGH0LjRidCw0YLRjNGB0Y8g0L3QtSDQsdGD0LTQtdGCLjwvcD5cblx0XHRcdDxCdXR0b24gY2xhc3MgPSBcImRhbmdlcm91c0FjdGlvblwiIG9uY2xpY2sgPSB7IGFwcC5yZXNldCB9ID7QntGH0LjRgdGC0LjRgtGMPGJyLz7Qv9Cw0LzRj9GC0Yw8L0J1dHRvbj5cblx0XHQ8L2Rpdj4sXG5cblx0XHQvLyBBZGRQbGFjZSxcblx0XHQvLyBBZGREZXZpY2UsXG5cdH1cblxuXHRyYSggKCkgPT4ge1xuXHRcdGxldCBkaWFsb2dOYW1lID0gYXBwLmRpYWxvZ1xuXHRcdGlmICggIWRpYWxvZ05hbWUgKVxuXHRcdFx0cmV0dXJuXG5cblx0XHRpZiAoICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRpYWxvZ1RlbXBsYXRlcywgZGlhbG9nTmFtZSApICkge1xuXHRcdFx0YWxlcnQoIGBFcnJvcjogQ291bGQgbm90IGZpbmQgZGlhbG9nIG5hbWVkXFxuXCIkeyBkaWFsb2dOYW1lIH1cImAgKVxuXHRcdFx0cmEuZGV0YWNoKCAoKSA9PiBhcHAuZGlhbG9nID0gYGAgKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGxldCBUZW1wbGF0ZSA9IGRpYWxvZ1RlbXBsYXRlc1sgZGlhbG9nTmFtZSBdXG5cdFx0aWYgKCAhVGVtcGxhdGUgKVxuXHRcdFx0cmV0dXJuXG5cdFx0ZGlhbG9nVGVtcGxhdGVzWyBkaWFsb2dOYW1lIF0gPSBudWxsXG5cblx0XHRsZXQgZGlhbG9nID0gVGVtcGxhdGUoKVxuXHRcdGRpYWxvZy5jbGFzc0xpc3QuYWRkKCBkaWFsb2dOYW1lIClcblx0XHRkaWFsb2cuY2xhc3NMaXN0LmFkZCggYG1vZGFsRGlhbG9nYCApXG5cdFx0cmEoIHtcblx0XHRcdGdldCBpc0FjdGl2ZSgpIHsgcmV0dXJuIGRpYWxvZ05hbWUgPT0gYXBwLmRpYWxvZyB9LFxuXHRcdFx0Z2V0IHVwZGF0ZUNsYXNzKCkge1xuXHRcdFx0XHRsZXQgZXZlbnRcblx0XHRcdFx0aWYgKCB0aGlzLmlzQWN0aXZlICkge1xuXHRcdFx0XHRcdGV2ZW50ID0gYGRpYWxvZ3Nob3dgXG5cdFx0XHRcdFx0ZGlhbG9nLmNsYXNzTGlzdC5hZGQoIGBkaWFsb2dTaG93bmAgKVxuXHRcdFx0XHRcdGRpYWxvZy5jbGFzc0xpc3QucmVtb3ZlKCBgZGlhbG9nSGlkZGVuYCApXG5cdFx0XHRcdFx0bGV0IGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoIGAqWyBhdXRvZm9jdXMgXWAgKVxuXHRcdFx0XHRcdGlmICggaW5wdXQgKVxuXHRcdFx0XHRcdFx0YXBwLmZvY3VzKCBpbnB1dCApXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZXZlbnQgPSBgZGlhbG9naGlkZWBcblx0XHRcdFx0XHRkaWFsb2cuY2xhc3NMaXN0LnJlbW92ZSggYGRpYWxvZ1Nob3duYCApXG5cdFx0XHRcdFx0ZGlhbG9nLmNsYXNzTGlzdC5hZGQoIGBkaWFsb2dIaWRkZW5gIClcblx0XHRcdFx0XHRmb3IgKCBsZXQgZWxlbSBvZiBkaWFsb2cucXVlcnlTZWxlY3RvckFsbCggYCo6Zm9jdXNgICkgKVxuXHRcdFx0XHRcdFx0ZWxlbS5ibHVyKClcblx0XHRcdFx0XHRkaWFsb2cuYmx1cigpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlhbG9nLmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudCggZXZlbnQsIHsgZGV0YWlsOiBudWxsIH0gKSApXG5cdFx0XHR9LFxuXHRcdH0gKVxuXHRcdGFwcGxpY2F0aW9uLmFwcGVuZENoaWxkKCBkaWFsb2cgKVxuXHR9IClcblxuXHRzZXRUaW1lb3V0KCAoKSA9PiBhcHAucGFnZVN0YXJ0aW5nID0gZmFsc2UsIDEgKVxuXG5cdHJldHVybiBhcHBsaWNhdGlvblxufVxuIiwibGV0IGh0bWx1dGlscyA9IHJlcXVpcmUoIGBodG1sdXRpbHNgIClcblxubW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4ge1xuXHRsZXQgJCA9IHt9XG5cdHJldHVybiA8ZGl2IG9uZGlhbG9nc2hvdyA9IHsgKCkgPT4ge1xuXHRcdCQuc3RyaW5nLnZhbHVlID0gYXBwLmdldE1lc3NhZ2UoIGFwcC5nZXREZXZpY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCApIClcblx0XHQkLnN0cmluZy5zZXRTZWxlY3Rpb25SYW5nZSggMCwgJC5zdHJpbmcudmFsdWUubGVuZ3RoIClcblx0fSB9ID5cblx0XHQ8cD7QndCw0LfQstCw0L3QuNC1OjwvcD5cblx0XHQ8Zm9ybSBvbnN1Ym1pdCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0ZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0bGV0IG5hbWUgPSAkLnN0cmluZy52YWx1ZS50cmltKClcblx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0aWYgKCBuYW1lIClcblx0XHRcdFx0YXBwLnJlbmFtZUl0ZW0oIGFwcC5hY3RpdmVEZXZpY2VJZCwgbmFtZSApXG5cdFx0fSB9ID5cblx0XHRcdHsgJC5zdHJpbmcgPSA8dGV4dGFyZWEgbmFtZSA9IFwic3RyaW5nXCIgY29scyA9IFwiMzVcIiByb3dzID0gXCIyXCIgYXV0b2ZvY3VzID0gXCJhdXRvZm9jdXNcIiAvPiB9XG5cdFx0XHQ8cD48YSBjbGFzcyA9IFwiYnV0dG9uXCIgaHJlZiA9IFwiamF2YXNjcmlwdDp2b2lkKDApXCIgdGFyZ2V0ID0gXCJfc2VsZlwiIG9udG91Y2ggPSB7IGh0bWx1dGlscy5TdWJtaXQgfSA+0JfQsNC60YDRi9GC0Yw8L2E+PC9wPlxuXHRcdDwvZm9ybT5cblx0PC9kaXY+XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiB7XG5cdGxldCBCdXR0b24gPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL0J1dHRvbmAgKSApXG5cdHJldHVybiA8ZGl2PlxuXHRcdDxwPtCf0L7QttCw0LvRg9C50YHRgtCwLDxici8+0L/QtdGA0LXQstC10LTQuNGC0LUg0YPRgdGC0YDQvtC50YHRgtCy0L4g0LIg0YDQtdC20LjQvDxici8+0L/RgNC+0LPRgNCw0LzQvNC40YDQvtCy0LDQvdC40Y8g0Lgg0L3QsNC20LzQuNGC0LU8L3A+XG5cdFx0PEJ1dHRvbiBvbmNsaWNrID0geyAoKSA9PiB7XG5cdFx0XHRsZXQgcGxhY2VJZCA9IGFwcC5saW5raW5nUGxhY2VJZCB8fCBhcHAuYWN0aXZlRGV2aWNlSWRcblx0XHRcdGFwcC5kaWFsb2cgPSBgU3RhdGVXYWl0YFxuXHRcdFx0Y28uZ28oIGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHRcdHlpZWxkIGFwcC5jb21tYW5kKCBwbGFjZUlkLCBgTGlua2AgKVxuXHRcdFx0XHRhcHAuZGlhbG9nID0gYEFza0lmRGV2aWNlSGFzQmVlbkxpbmtlZGBcblx0XHRcdFx0YXBwLmxpbmtpbmdQbGFjZUlkID0gcGxhY2VJZFxuXHRcdFx0fSApLmNhdGNoKCBlcnJvciA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCBlcnJvciApXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgRXJyb3JOb0NhcnJpZXJgXG5cdFx0XHR9IClcblx0XHR9IH1cblx0XHQ+0LfQtNC10YHRjDwvQnV0dG9uPlxuXHQ8L2Rpdj5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXBwID0+ICggYXR0ciwgY29udGVudCApID0+XG5cdDxhIGNsYXNzID0gXCJidXR0b25cIiBocmVmID0gXCJqYXZhc2NyaXB0OnZvaWQoMClcIiB0YXJnZXQgPSBcIl9zZWxmXCIgb250b3VjaCA9IHsgZXZlbnQgPT4ge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHRpZiAoIHR5cGVvZiBhdHRyLm9uY2xpY2sgPT0gYHN0cmluZ2AgKVxuXHRcdFx0YXBwLmRpYWxvZyA9IGF0dHIub25jbGlja1xuXHRcdGVsc2Uge1xuXHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRhdHRyLm9uY2xpY2sgJiYgYXR0ci5vbmNsaWNrKClcblx0XHR9XG5cdH0gfVxuXHRfID0geyBPYmplY3QuYXNzaWduKCB7fSwgYXR0ciwgeyBvbmNsaWNrOiBudWxsIH0gKSB9XG5cdD57XG5cdFx0Y29udGVudFxuXHR9PC9hPlxuIiwibW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4gKCB7IG9uY2xpY2ssIHVybCwgdmlzaWJsZSwgZW5hYmxlZCwgbWVzc2FnZSB9ICkgPT4ge1xuXHRsZXQgY29udGVudCA9IGFwcC5tZXNzYWdlKCBtZXNzYWdlIClcblx0bGV0IGlzRW5hYmxlZCA9ICgpID0+ICggdXJsIHx8IG9uY2xpY2sgKSAmJiAoICFlbmFibGVkIHx8IGVuYWJsZWQoKSApXG5cdGlmICggdHlwZW9mIHZpc2libGUgPT0gYHN0cmluZ2AgKSB7XG5cdFx0bGV0IGRldmljZVR5cGUgPSB2aXNpYmxlXG5cdFx0dmlzaWJsZSA9ICgpID0+IGFwcC5kZXZpY2VUeXBlID09IGRldmljZVR5cGVcblx0fVxuXHRsZXQgY2xhc3NOYW1lID0gKCkgPT4gYGNvbW1hbmQgJHsgbWVzc2FnZSB9ICR7IGlzRW5hYmxlZCgpID8gYGVuYWJsZWRgIDogYGRpc2FibGVkYCB9ICR7IHZpc2libGUgPT0gbnVsbCB8fCB2aXNpYmxlKCkgPyBgaXRlbVZpc2libGVgIDogYGl0ZW1IaWRkZW5gIH1gXG5cdGlmICggdXJsICYmICFvbmNsaWNrIClcblx0XHRyZXR1cm4gPGEgY2xhc3MgPSB7IGNsYXNzTmFtZSB9IGhyZWYgPSB7IHVybCB9IHJlbCA9IFwiZXh0ZXJuYWxcIiB0YXJnZXQgPSBcIl9ibGFua1wiID57IGNvbnRlbnQgfTwvYT5cblx0ZWxzZVxuXHRcdHJldHVybiA8YSBjbGFzcyA9IHsgY2xhc3NOYW1lIH0gaHJlZiA9IFwiamF2YXNjcmlwdDp2b2lkKDApXCIgdGFyZ2V0ID0gXCJfc2VsZlwiIG9udG91Y2ggPSB7IGV2ZW50ID0+IHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHRcdGlmICggb25jbGljayAmJiBpc0VuYWJsZWQoKSApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2Ygb25jbGljayA9PSBgc3RyaW5nYCApXG5cdFx0XHRcdFx0YXBwLmRpYWxvZyA9IG9uY2xpY2tcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRcdFx0b25jbGljaygpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IH0gPnsgY29udGVudCB9PC9hPlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSAoIGFwcCwgbG9jYWwgKSA9PiB7XG5cdGxldCBDb21tYW5kID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9Db21tYW5kYCApIClcblx0bGV0IEFkZEV4aXN0aW5nSXRlbSA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQWRkRXhpc3RpbmdJdGVtYCApIClcblx0cmV0dXJuIDxkaXY+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRTZWFyY2hEZXZpY2VzXCJcblx0XHRcdG9uY2xpY2sgPSBcIlNlYXJjaEl0ZW1zXCJcblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kVG9GYXZvdXJpdGVzXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuYWN0aXZlRGV2aWNlSWQgIT0gYXBwLm1haW4gfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4ge1xuXHRcdFx0XHRhcHAubGlua0FjdGl2ZVRvRmF2b3VyaXRlcygpXG5cdFx0XHRcdGFwcC5ub3RpZmljYXRpb24oIGDQlNC+0LHQsNCy0LvQtdC90L4g0LIg0LjQt9Cx0YDQsNC90L3QvtC1YCApXG5cdFx0XHR9IH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kTGlua0RldmljZVwiXG5cdFx0XHR2aXNpYmxlID0gXCJkZXZpY2VcIlxuXHRcdFx0b25jbGljayA9IFwiQXNrVG9MaW5rRGV2aWNlXCJcblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuZGV2aWNlVHlwZSA9PSBgcGxhY2VgIH1cblx0XHRcdG9uY2xpY2sgPSBcIkFkZE1lbnVcIlxuXHRcdC8+XG5cdFx0PEFkZEV4aXN0aW5nSXRlbVxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZEFkZFwiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgYXBwLmRldmljZVR5cGUgPT0gYGdyb3VwYCB9XG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZE1vdmVJY29uc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgYXBwLmRldmljZVR5cGUgIT0gYHNpbmdsZWAgfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4gYXBwLmVkaXRpbmcgPSB0cnVlIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kUmVuYW1lSXRlbVwiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgfVxuXHRcdFx0b25jbGljayA9IFwiQXNrTmV3TmFtZVwiXG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZFB1cmdlSXRlbVwiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgYXBwLmFjdGl2ZURldmljZUlkICE9IGFwcC5tYWluIH1cblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IHtcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBEZWxldGVEZXZpY2VgXG5cdFx0XHRcdC8vIGFwcC5wdXJnZUl0ZW0oIGFwcC5hY3RpdmVEZXZpY2VJZCApXG5cdFx0XHR9IH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kU2hvd0xhYmVsc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhbG9jYWwubGFiZWxzICYmIGFwcC5hY3RpdmVEZXZpY2VJZCA9PSBhcHAubWFpbiB9XG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiBsb2NhbC5sYWJlbHMgPSB0cnVlIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kSGlkZUxhYmVsc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiBsb2NhbC5sYWJlbHMgJiYgYXBwLmFjdGl2ZURldmljZUlkID09IGFwcC5tYWluIH1cblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IGxvY2FsLmxhYmVscyA9IGZhbHNlIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kUmVzZXRUb0ZhY3RvcnlTZXR0aW5nc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiBhcHAuYWN0aXZlRGV2aWNlSWQgPT0gYXBwLm1haW4gfVxuXHRcdFx0ZW5hYmxlZCA9IHsgKCkgPT4gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICE9IGB0ZXN0LnNoLm5lcm9lbGVjdHJvbmljcy5ieWAgfVxuXHRcdFx0b25jbGljayA9IFwiQXNrVG9SZXNldFwiXG5cdFx0Lz5cblx0PC9kaXY+XG59XG4iLCJsZXQgbG9kYXNoID0gcmVxdWlyZSggYGxvZGFzaGAgKVxubGV0IGh0bWx1dGlscyA9IHJlcXVpcmUoIGBodG1sdXRpbHNgIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGFwcCwgbG9jYWwgKSA9PiAoIHsgcGxhY2VJZCwgaWNvbklkLCBpY29uRGVzY3IsIHBvc2l0aW9uIH0gKSA9PiB7XG5cdC8vIFRPRE86IHJlZmFjdG9yaW5nOiBtb3ZlIHRvIG1vcmUgSlNYICg/KVxuXHQvLyBUT0RPOiBvblRhcCwgb25QcmVzcywgb25DbGljayBoYW5kbGVycyBtdXN0IHJlbW92ZSB0aGVtc2VsZiB3aGVuIHRocmVhZCBpcyBiZWluZyBraWxsZWRcblx0bGV0IGljb24sIG9mZiwgb24sIGFic2VudCwgaW1hZ2Vcblx0bGV0IGlzTW91c2UgPSBmYWxzZVxuXG5cdGxldCBwbGFjZVJlY3QgPSBodG1sdXRpbHMudGlja0NhY2hlKCAoKSA9PiB7XG5cdFx0bGV0IHggPSBpY29uLnBhcmVudE5vZGVcblx0XHRsZXQgclxuXHRcdHdoaWxlICggciA9IHguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksICFyLndpZHRoIHx8ICFyLmhlaWdodCApXG5cdFx0XHR4ID0geC5wYXJlbnROb2RlXG5cdFx0cmV0dXJuIHJcblx0fSApXG5cblx0bGV0IHJlbFBvaW50ID0gcCA9PiB7XG5cdFx0bGV0IHIgPSBwbGFjZVJlY3QoKVxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiAoIHAueCAtIHIubGVmdCApIC8gci53aWR0aCAqIDEwMCxcblx0XHRcdHk6ICggcC55IC0gci50b3AgKSAvIHIuaGVpZ2h0ICogMTAwLFxuXHRcdH1cblx0fVxuXG5cdGxldCBnZXRQb2ludCA9IGRhdGEgPT4ge1xuXHRcdHJldHVybiByZWxQb2ludCggeyB4OiBkYXRhLnBhZ2VYLCB5OiBkYXRhLnBhZ2VZIH0gKVxuXHR9XG5cblx0bGV0IGdldExlZnRUb3AgPSBkYXRhID0+IHtcblx0XHRsZXQgcCA9IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblx0XHRyZXR1cm4gcmVsUG9pbnQoIHsgeDogcC5sZWZ0LCB5OiBwLnRvcCB9IClcblx0fVxuXG5cdGxldCBpY29uc0NvdW50ID0gKCkgPT4ge1xuXHRcdGxldCBwbGFjZSA9IGFwcC5nZXREZXZpY2UoIHBsYWNlSWQgKVxuXHRcdHJldHVybiBsb2Rhc2gua2V5cyggcGxhY2UgJiYgcGxhY2UuY29udGVudCApLmxlbmd0aFxuXHR9XG5cblx0bGV0IGltYWdlSGVpZ2h0ID0gaHRtbHV0aWxzLnRpY2tDYWNoZSggKCkgPT4ge1xuXHRcdGlmICggIWlzTW91c2UgKVxuXHRcdFx0cmV0dXJuIGljb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG5cdFx0aWYgKCBvcHRzLmljb25EYXRhICkge1xuXHRcdFx0aWYgKCBvcHRzLmljb25EYXRhLmRldmljZUltYWdlR2V0SGVpZ2h0ICkge1xuXHRcdFx0XHRsZXQgciA9IG9wdHMuaWNvbkRhdGEuZGV2aWNlSW1hZ2VHZXRIZWlnaHQoKVxuXHRcdFx0XHRpZiAoIHIgKVxuXHRcdFx0XHRcdHJldHVybiByXG5cdFx0XHR9XG5cdFx0XHRsZXQgaCA9IG9wdHMuaWNvbkRhdGEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggYGRldmljZV9pbWFnZV9oZWlnaHRgIClbIDAgXVxuXHRcdFx0aWYgKCBoICE9IG51bGwgJiYgaC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgKSB7XG5cdFx0XHRcdGxldCByID0gaC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblx0XHRcdFx0aWYgKCByIClcblx0XHRcdFx0XHRyZXR1cm4gclxuXHRcdFx0fVxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb3B0cy5pY29uRGF0YS5jaGlsZE5vZGVzLmxlbmd0aDsgKytpICkge1xuXHRcdFx0XHRsZXQgciA9IG9wdHMuaWNvbkRhdGEuY2hpbGROb2Rlcy5pdGVtKCBpIClcblx0XHRcdFx0aWYgKCByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCApIHtcblx0XHRcdFx0XHRyID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblx0XHRcdFx0XHRpZiAoIHIgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaW1hZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG5cdH0gKVxuXG5cdGxldCBvcHRzID0gcmEoIHtcblxuXHRcdGdldCBpY29uTmFtZSgpIHsgcmV0dXJuIGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpICYmIGljb25EZXNjci52YWx1ZU9mKCkuaWNvbiB8fCBudWxsIH0sXG5cdFx0Z2V0IGljb25UZW1wbGF0ZSgpIHsgcmV0dXJuIHRoaXMuaWNvbk5hbWUgJiYgYXBwLmljb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggYXBwLmljb25zLCB0aGlzLmljb25OYW1lICkgJiYgYXBwLmljb25zWyB0aGlzLmljb25OYW1lIF0gfHwgbnVsbCB9LFxuXHRcdGljb25EYXRhOiBudWxsLFxuXHRcdGdldCB1cGRhdGVJY29uRGF0YVN0YXRlKCkge1xuXHRcdFx0bGV0IGRhdGEgPSB0aGlzLmljb25EYXRhXG5cdFx0XHRpZiAoIGRhdGEgJiYgZGF0YS5kZXZpY2VTZXRTdGF0ZSApXG5cdFx0XHRcdGRhdGEuZGV2aWNlU2V0U3RhdGUoIHRoaXMuc3RhdGUgKVxuXHRcdH0sXG5cblx0XHRnZXQgZGltbWVyaW5nKCkge1xuXHRcdFx0bGV0IGkgPSBpY29uRGVzY3IgPT0gbnVsbCA/IG51bGwgOiBpY29uRGVzY3IudmFsdWVPZigpXG5cdFx0XHRsZXQgaWQgPSBpID09IG51bGwgPyBudWxsIDogaS5kaW1tZXJpbmcgPT0gbnVsbCA/IG51bGwgOiAhIWkuZGltbWVyaW5nXG5cdFx0XHRpZiAoIGlkICE9IG51bGwgKVxuXHRcdFx0XHRyZXR1cm4gaWRcblx0XHRcdGlmICggaSAhPSBudWxsICYmIGkudHlwZSA9PT0gYHBsYWNlYCApXG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9LFxuXHRcdGdldCBpbWFnZV9vbigpIHtcblx0XHRcdGxldCBpID0gaWNvbkRlc2NyICYmIGljb25EZXNjci52YWx1ZU9mKClcblx0XHRcdGxldCBmaWxlID0gYGBcblx0XHRcdFx0fHwgaSAmJiBpLmltYWdlX29uXG5cdFx0XHRcdHx8IGkgJiYgaS5pbWFnZVxuXHRcdFx0cmV0dXJuIGZpbGUgJiYgYC9pbWFnZXMvJHsgZmlsZSB9YFxuXHRcdH0sXG5cdFx0Z2V0IHVwZGF0ZV9pbWFnZV9vbigpIHtcblx0XHRcdGlmICggb3B0cy5pbWFnZV9vbiApXG5cdFx0XHRcdG9uLnNyYyA9IG9wdHMuaW1hZ2Vfb25cblx0XHR9LFxuXHRcdGdldCBpbWFnZV9vZmYoKSB7XG5cdFx0XHRsZXQgaSA9IGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpXG5cdFx0XHRsZXQgZmlsZSA9IGBgXG5cdFx0XHRcdHx8IGkgJiYgaS5pbWFnZV9vZmZcblx0XHRcdFx0fHwgaSAmJiBpLmltYWdlXG5cdFx0XHRyZXR1cm4gZmlsZSAmJiBgL2ltYWdlcy8keyBmaWxlIH1gXG5cdFx0fSxcblx0XHRnZXQgdXBkYXRlX2ltYWdlX29mZigpIHtcblx0XHRcdGlmICggb3B0cy5pbWFnZV9vZmYgKVxuXHRcdFx0XHRvZmYuc3JjID0gb3B0cy5pbWFnZV9vZmZcblx0XHR9LFxuXG5cdFx0aWNvbkNvbW1hbmQoIGNtZCwgZGF0YSApIHsgcmV0dXJuIGFwcC5pY29uQ29tbWFuZCggaWNvbkRlc2NyLCBpY29uSWQsIGNtZCwgZGF0YSApIH0sXG5cblx0XHRpc0RpbW1lcmluZzogZmFsc2UsXG5cdFx0bW92aW5nOiBmYWxzZSxcblx0XHRtb3ZlZDogZmFsc2UsXG5cdFx0eDogbnVsbCxcblx0XHR5OiBudWxsLFxuXG5cdFx0Z2V0IHByZXNlbnQoKSB7IHJldHVybiAhISggaWNvbkRlc2NyLmdldCggYGNvbnRlbnRgICkgfHwgaWNvbkRlc2NyLmdldCggYGdyb3VwYCApICkgfSxcblx0XHRzdGF0ZTogMCxcblx0XHRvbm5pbmc6IGZhbHNlLFxuXHRcdG9mZmluZzogZmFsc2UsXG5cdFx0ZmluYWw6IHRydWUsXG5cdFx0ZXJyb3JuZW91czogZmFsc2UsXG5cdFx0Z2V0IHVwZGF0ZVN0YXRlKCkge1xuXHRcdFx0bGV0IGQgPSBpY29uRGVzY3IgJiYgaWNvbkRlc2NyLnZhbHVlT2YoKVxuXHRcdFx0aWYgKCAhZCApXG5cdFx0XHRcdHJldHVybiAwXG5cdFx0XHRpZiAoIGQubmV3c3RhdGVfdGltZXN0YW1wICYmICggIWQuc3RhdGVfdGltZXN0YW1wIHx8IGQubmV3c3RhdGVfdGltZXN0YW1wID4gZC5zdGF0ZV90aW1lc3RhbXAgKSApIHtcblx0XHRcdFx0bGV0IGZvbm5pbmcgPSBkLm5ld3N0YXRlID49IGQuc3RhdGVcblx0XHRcdFx0dGhpcy5vbm5pbmcgPSBmb25uaW5nXG5cdFx0XHRcdHRoaXMub2ZmaW5nID0gIWZvbm5pbmdcblx0XHRcdFx0dGhpcy5maW5hbCA9IGZhbHNlXG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBkLm5ld3N0YXRlXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5vbm5pbmcgPSBmYWxzZVxuXHRcdFx0XHR0aGlzLm9mZmluZyA9IGZhbHNlXG5cdFx0XHRcdHRoaXMuZmluYWwgPSB0cnVlXG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBkLnN0YXRlXG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVycm9ybmVvdXMgPSAhIWQuZXJyb3JuZW91c1xuXHRcdH0sXG5cblx0XHRzZXRPcGFjaXR5KCBub2RlLCBvcGFjaXR5ICkge1xuXHRcdFx0aWYgKCBvcGFjaXR5ID09IG51bGwgKSB7XG5cdFx0XHRcdGRlbGV0ZSBub2RlLnN0eWxlLm9wYWNpdHlcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRub2RlLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXQgdXBkYXRlT3BhY2l0eSgpIHtcblx0XHRcdGlmICggdGhpcy5pY29uVGVtcGxhdGUgKSB7XG5cdFx0XHRcdG9uLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiXG5cdFx0XHRcdG9mZi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIlxuXHRcdFx0XHRhYnNlbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCJcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhdGhpcy5wcmVzZW50ICkge1xuXHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9uLCAwIClcblx0XHRcdFx0dGhpcy5zZXRPcGFjaXR5KCBvZmYsIDAgKVxuXHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIGFic2VudCwgMC43IClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIGFic2VudCwgMCApXG5cdFx0XHRcdGlmICggdGhpcy5kaW1tZXJpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRPcGFjaXR5KCBvbiwgdGhpcy5zdGF0ZSApXG5cdFx0XHRcdFx0dGhpcy5zZXRPcGFjaXR5KCBvZmYsICggMSAtIHRoaXMuc3RhdGUgKSAqIDAuMzMzIClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9uLCArISF0aGlzLnN0YXRlIClcblx0XHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9mZiwgKyF0aGlzLnN0YXRlIClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH0gKVxuXG5cdGNvbnN0IE1PVkVfUEFHRV9ESVNUID0gMC4xXG5cdGNvbnN0IE1PVkVfU0lERV9ESVNUID0gMC4yNVxuXG5cdGZ1bmN0aW9uIGNvbXBhcmVJbmRleCggYSwgYiApIHtcblx0XHRyZXR1cm4gYS5pbmRleCAtIGIuaW5kZXhcblx0fVxuXG5cdGxldCBtb3ZlID0gZnVuY3Rpb24qICggc3RhcnQsIG5leHQgKSB7XG5cdFx0aWYgKCBvcHRzLm1vdmluZyApXG5cdFx0XHRvcHRzLm1vdmluZy5raWxsKCBgcmVzdGFydGluZyBieSBhbm90aGVyIGZpbmdlcmAgKVxuXG5cdFx0bGV0IGNoYW5nZXMgPSBhcHAubG9jYWxEZXZpY2VzLmNyZWF0ZVJlY29yZCgpXG5cdFx0bGV0IGN1cnJlbnRQb3NpdGlvbiA9IHBvc2l0aW9uLnZhbHVlT2YoKVxuXHRcdGxldCBkb25lID0gZmFsc2Vcblx0XHRsZXQgaG92ZXJJZCA9IG51bGxcblxuXHRcdGZ1bmN0aW9uIHNldEhvdmVyKCB2YWx1ZSApIHtcblx0XHRcdGlmICggaG92ZXJJZCA9PSB2YWx1ZSApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0aWYgKCBob3ZlcklkIClcblx0XHRcdFx0YXBwLmhvdmVyID0gbHUuYXBwbHlEaWZmKCBhcHAuaG92ZXIsIHsgWyBob3ZlcklkIF06IHsgWyBwbGFjZUlkIF06IHsgWyBpY29uSWQgXTogbnVsbCB9IH0gfSApXG5cdFx0XHRob3ZlcklkID0gdmFsdWVcblx0XHRcdGlmICggaG92ZXJJZCApXG5cdFx0XHRcdGFwcC5ob3ZlciA9IGx1LmFwcGx5RGlmZiggYXBwLmhvdmVyLCB7IFsgaG92ZXJJZCBdOiB7IFsgcGxhY2VJZCBdOiB7IFsgaWNvbklkIF06IHRydWUgfSB9IH0gKVxuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRsZXQgc2VsZiA9IGNvLmN1cnJlbnRcblx0XHRcdHJhKCAoKSA9PiAhZG9uZSAmJiAhYXBwLmVkaXRpbmcgJiYgc2VsZi5raWxsKCkgKVxuXG5cdFx0XHRsZXQgcCA9IGdldFBvaW50KCBzdGFydCApXG5cdFx0XHRsZXQgciA9IGdldExlZnRUb3AoIGljb24gKVxuXHRcdFx0b3B0cy5tb3ZpbmcgPSBjby5jdXJyZW50XG5cdFx0XHRvcHRzLm1vdmVkID0gZmFsc2Vcblx0XHRcdGxldCBmaW5nZXJTaGlmdCA9IHtcblx0XHRcdFx0eDogci54IC0gcC54LFxuXHRcdFx0XHR5OiByLnkgLSBwLnksXG5cdFx0XHR9XG5cdFx0XHRvcHRzLnggPSByLnhcblx0XHRcdG9wdHMueSA9IHIueVxuXG5cdFx0XHRmb3IgKCBsZXQgcHQ7IHB0ID0geWllbGQgbmV4dDsgKSB7XG5cdFx0XHRcdGxldCBmaW5nZXIgPSBnZXRQb2ludCggcHQgKVxuXHRcdFx0XHRsZXQgY29ybmVyID0ge1xuXHRcdFx0XHRcdHg6IGZpbmdlci54ICsgZmluZ2VyU2hpZnQueCxcblx0XHRcdFx0XHR5OiBmaW5nZXIueSArIGZpbmdlclNoaWZ0LnksXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcHRzLnggIT0gY29ybmVyLnggfHwgb3B0cy55ICE9IGNvcm5lci55IClcblx0XHRcdFx0XHRvcHRzLm1vdmVkID0gdHJ1ZVxuXHRcdFx0XHRvcHRzLnggPSBjb3JuZXIueFxuXHRcdFx0XHRvcHRzLnkgPSBjb3JuZXIueVxuXHRcdFx0XHRpZiAoIHB0LnR5cGUgIT0gYHN0b3BgIClcblx0XHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRcdGxldCBuZXdIb3ZlcklkID0gbnVsbFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxldCBwYWdlU2l6ZSA9IHtcblx0XHRcdFx0XHRcdHg6IGFwcC5wYWdlV2lkdGgsXG5cdFx0XHRcdFx0XHR5OiBhcHAucGFnZUhlaWdodCxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGNlbGxTaXplID0ge1xuXHRcdFx0XHRcdFx0eDogMTAwIC8gcGFnZVNpemUueCxcblx0XHRcdFx0XHRcdHk6IDEwMCAvIHBhZ2VTaXplLnksXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCBpbmRleCA9IHtcblx0XHRcdFx0XHRcdHg6IE1hdGgubWluKCBwYWdlU2l6ZS54IC0gMSwgTWF0aC5tYXgoIDAsIE1hdGguZmxvb3IoIGZpbmdlci54IC8gY2VsbFNpemUueCApICkgKSxcblx0XHRcdFx0XHRcdHk6IE1hdGgubWluKCBwYWdlU2l6ZS55IC0gMSwgTWF0aC5tYXgoIDAsIE1hdGguZmxvb3IoIGZpbmdlci55IC8gY2VsbFNpemUueSApICkgKSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGluQ2VsbCA9IHtcblx0XHRcdFx0XHRcdHg6IGZpbmdlci54IC8gY2VsbFNpemUueCAtIGluZGV4LngsXG5cdFx0XHRcdFx0XHR5OiBmaW5nZXIueSAvIGNlbGxTaXplLnkgLSBpbmRleC55LFxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaW5DZWxsID4gMSAtIE1PVkVfUEFHRV9ESVNUICYmIGNlbGxTaXplLnggPT0gcGFnZVNpemUueCAtIDEgKSB7XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBzY3JvbGwgcGFnZSByaWdodFxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBpbkNlbGwgPCBNT1ZFX1BBR0VfRElTVCAmJiBjZWxsU2l6ZS54ID09IHBhZ2VTaXplLnggLSAxICkge1xuXHRcdFx0XHRcdFx0Ly8gVE9ETzogc2Nyb2xsIHBhZ2UgbGVmdFxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgcGxhY2VQb3NpdGlvbiA9IGluZGV4LnggKyBpbmRleC55ICogcGFnZVNpemUueCArICggbG9jYWwucGxhY2VzUGFnZXNbIHBsYWNlSWQgXSB8fCAwICkgKiBwYWdlU2l6ZS54ICogcGFnZVNpemUueVxuXG5cdFx0XHRcdFx0bGV0IHBsYWNlID0gbHUuZ2V0KCBjaGFuZ2VzLCBgc3VtbWFyeWAsIGBjb250ZW50YCwgcGxhY2VJZCwgYGNvbnRlbnRgIClcblx0XHRcdFx0XHRpZiAoICFwbGFjZSB8fCAhcGxhY2VbIGljb25JZCBdIClcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdGxldCBrZXlzID0gbG9kYXNoLmtleXMoIHBsYWNlIClcblx0XHRcdFx0XHRcdC5tYXAoIGtleSA9PiAoIHsga2V5LCBpbmRleDogcGxhY2VbIGtleSBdLmluZGV4IH0gKSApXG5cdFx0XHRcdFx0XHQuc29ydCggY29tcGFyZUluZGV4IClcblxuXHRcdFx0XHRcdGxldCBuZXdJbmRleFxuXG5cdFx0XHRcdFx0aWYgKCBwbGFjZVBvc2l0aW9uIDwgMCApIHtcblx0XHRcdFx0XHRcdGlmICggY3VycmVudFBvc2l0aW9uIDw9IDAgKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyAwIF0uaW5kZXggLSAxXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBwbGFjZVBvc2l0aW9uID4ga2V5cy5sZW5ndGggLSAxICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50UG9zaXRpb24gPj0ga2V5cy5sZW5ndGggLSAxIClcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdG5ld0luZGV4ID0ga2V5c1sga2V5cy5sZW5ndGggLSAxIF0uaW5kZXggKyAxXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50UG9zaXRpb24gPT0gcGxhY2VQb3NpdGlvbiApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRpZiAoIGluQ2VsbC54ID4gTU9WRV9TSURFX0RJU1QgJiYgaW5DZWxsLnggPCAxIC0gTU9WRV9TSURFX0RJU1QgJiYgaW5DZWxsLnkgPiBNT1ZFX1NJREVfRElTVCAmJiBpbkNlbGwueSA8IDEgLSBNT1ZFX1NJREVfRElTVCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gVE9ET1xuXHRcdFx0XHRcdFx0XHRuZXdIb3ZlcklkID0ga2V5c1sgcGxhY2VQb3NpdGlvbiBdLmtleVxuXHRcdFx0XHRcdFx0XHRsZXQgc3JjVHlwZSA9IGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpICYmIGljb25EZXNjci52YWx1ZU9mKCkudHlwZVxuXHRcdFx0XHRcdFx0XHRsZXQgZHN0RGV2aWNlID0gYXBwLmdldERldmljZSggbmV3SG92ZXJJZCApXG5cdFx0XHRcdFx0XHRcdGxldCBkc3RUeXBlID0gZHN0RGV2aWNlICYmIGRzdERldmljZS50eXBlXG5cdFx0XHRcdFx0XHRcdGlmICggZHN0VHlwZSA9PSBgcGxhY2VgIClcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRzdFR5cGUgPT0gYGdyb3VwYCAmJiBzcmNUeXBlID09IGBzaW5nbGVgIClcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBhbGxvdyBkc3RUeXBlID09IGBzaW5nbGVgICYmIHNyY1R5cGUgPT0gYHNpbmdsZWBcblx0XHRcdFx0XHRcdFx0bmV3SG92ZXJJZCA9IG51bGxcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaW5DZWxsLnggPiAwLjUgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggY3VycmVudFBvc2l0aW9uID09IHBsYWNlUG9zaXRpb24gKyAxIClcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4LnggPT0gcGFnZVNpemUueCAtIDEgJiYgY3VycmVudFBvc2l0aW9uID4gcGxhY2VQb3NpdGlvbiApXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdFx0aWYgKCBwbGFjZVBvc2l0aW9uID49IGtleXMubGVuZ3RoIC0gMSApXG5cdFx0XHRcdFx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyBwbGFjZVBvc2l0aW9uIF0uaW5kZXggKyAxXG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRuZXdJbmRleCA9ICgga2V5c1sgcGxhY2VQb3NpdGlvbiBdLmluZGV4ICsga2V5c1sgcGxhY2VQb3NpdGlvbiArIDEgXS5pbmRleCApIC8gMlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICggY3VycmVudFBvc2l0aW9uID09IHBsYWNlUG9zaXRpb24gLSAxIClcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4LnggPT0gMCAmJiBjdXJyZW50UG9zaXRpb24gPCBwbGFjZVBvc2l0aW9uIClcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHBsYWNlUG9zaXRpb24gPD0gMCApXG5cdFx0XHRcdFx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyBwbGFjZVBvc2l0aW9uIF0uaW5kZXggLSAxXG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRuZXdJbmRleCA9ICgga2V5c1sgcGxhY2VQb3NpdGlvbiBdLmluZGV4ICsga2V5c1sgcGxhY2VQb3NpdGlvbiAtIDEgXS5pbmRleCApIC8gMlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBuZXdQb3NpdGlvbiA9IGtleXMubWFwKCBrID0+IGsua2V5ICE9IGljb25JZCA/IGsgOiB7IGtleTogay5rZXksIGluZGV4OiBuZXdJbmRleCB9ICkuc29ydCggY29tcGFyZUluZGV4ICkuZmluZEluZGV4KCBrID0+IGsua2V5ID09IGljb25JZCApXG5cblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRQb3NpdGlvbiA9PSBuZXdQb3NpdGlvbiApXG5cdFx0XHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRcdFx0Y3VycmVudFBvc2l0aW9uID0gbmV3UG9zaXRpb25cblx0XHRcdFx0XHRjaGFuZ2VzLmFzc2lnbiggeyBjb250ZW50OiB7IFsgcGxhY2VJZCBdOiB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXTogeyBpbmRleDogbmV3SW5kZXggfSB9IH0gfSB9IClcblx0XHRcdFx0fVxuXHRcdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0XHRzZXRIb3ZlciggbmV3SG92ZXJJZCApXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRvbmUgPSB0cnVlXG5cdFx0XHRpZiAoIGhvdmVySWQgKSB7XG5cdFx0XHRcdGNoYW5nZXMuY2xvc2UoKVxuXHRcdFx0XHQvLyBUT0RPXG5cdFx0XHRcdC8vIGxldCBuZXdQbGFjZSA9IGFwcC5nZXREZXZpY2UoIGhvdmVySWQgKVxuXHRcdFx0XHQvLyBpZiAoIG5ld1BsYWNlICYmIG5ld1BsYWNlLnR5cGUgPT0gYHNpbmdsZWAgKSB7XG5cdFx0XHRcdC8vIFx0YXBwLmxpbmtpbmdEZXZpY2VzID0gWyBob3ZlcklkLCBpY29uSWQgXVxuXHRcdFx0XHQvLyBcdGFwcC5kaWFsb2cgPSBgQ3JlYXRlUGxhY2VPckdyb3VwYFxuXHRcdFx0XHQvLyB9XG5cdFx0XHRcdC8vIGVsc2Vcblx0XHRcdFx0YXBwLmluc2VydEludG8oIGhvdmVySWQsIGljb25JZCwgcGxhY2VJZCApXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0eWllbGQgY28uc2xlZXAoKVxuXHRcdFx0XHRsdS53aGVuKCBjaGFuZ2VzLnNhdmUoKSwgKCkgPT4gY2hhbmdlcy5jbG9zZSgpIClcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRzZXRIb3ZlciggbnVsbCApXG5cdFx0XHRpZiAoICFkb25lICkge1xuXHRcdFx0XHRkb25lID0gdHJ1ZVxuXHRcdFx0XHRjaGFuZ2VzLmNsb3NlKClcblx0XHRcdH1cblx0XHRcdGlmICggb3B0cy5tb3ZpbmcgPT0gY28uY3VycmVudCApIHtcblx0XHRcdFx0b3B0cy5tb3ZpbmcgPSBudWxsXG5cdFx0XHRcdG9wdHMubW92ZWQgPSBmYWxzZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGxldCBkaW1tID0gZnVuY3Rpb24qICggbmV4dCApIHtcblx0XHRsZXQgY2hhbmdlcyA9IGFwcC5sb2NhbERldmljZXMuY3JlYXRlUmVjb3JkKClcblx0XHR0cnkge1xuXHRcdFx0bGV0IHN0YXRlXG5cdFx0XHRvcHRzLmlzRGltbWVyaW5nID0gdHJ1ZVxuXHRcdFx0bGV0IGluaXRpYWxEaW1tZXJpbmdTdGF0ZSA9IGljb25EZXNjciAmJiBpY29uRGVzY3IuZ2V0KCBgc3RhdGVgIClcblx0XHRcdGZvciAoIGxldCBwdDsgcHQgPSB5aWVsZCBuZXh0OyApIHtcblx0XHRcdFx0aWYgKCBwdC5kZXRhaWwudHlwZSA9PSBgc3dpcGVgICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGB1cGAgKVxuXHRcdFx0XHRcdFx0c3RhdGUgPSAxXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0c3RhdGUgPSAwXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGRlbHRhID0gLXB0LmRlbHRhWSAvICggaW1hZ2VIZWlnaHQoKSAqIDEuMCAvKiBtb3ZlIG11bHRpcGx5ZXIgKi8gKVxuXHRcdFx0XHRcdHN0YXRlID0gTWF0aC5taW4oIDEsIE1hdGgubWF4KCAwLCBpbml0aWFsRGltbWVyaW5nU3RhdGUgKyBkZWx0YSApIClcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09IDAgfHwgc3RhdGUgPT0gMSApXG5cdFx0XHRcdFx0XHRpbml0aWFsRGltbWVyaW5nU3RhdGUgPSBzdGF0ZSAtIGRlbHRhXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hhbmdlcy51cGRhdGUoIHsgY29udGVudDogeyBbIGljb25JZCBdOiB7IHN0YXRlIH0gfSB9IClcblx0XHRcdH1cblx0XHRcdGlmICggc3RhdGUgIT0gbnVsbCApXG5cdFx0XHRcdG9wdHMuaWNvbkNvbW1hbmQoIGBTZXRgLCBzdGF0ZSApXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0Y2hhbmdlcy5jbG9zZSgpXG5cdFx0XHRvcHRzLmlzRGltbWVyaW5nID0gZmFsc2Vcblx0XHR9XG5cdH1cblxuXHRsZXQgUGljdHVyZSA9IGF0dHJpYnV0ZXMgPT4gPGltZ1xuXHRcdGNsYXNzID0gXCJlcnJvclwiXG5cdFx0b25lcnJvciA9IHsgZnVuY3Rpb24gKCkgeyB0aGlzLmNsYXNzTGlzdC5hZGQoIGBlcnJvcmAgKSB9IH1cblx0XHRvbmxvYWQgPSB7IGZ1bmN0aW9uICgpIHsgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCBgZXJyb3JgICkgfSB9XG5cdFx0XyA9IHsgYXR0cmlidXRlcyB9XG5cdC8+XG5cblx0cmV0dXJuIDxkaXZcblx0XHRvbmNyZWF0ZSA9IHsgZSA9PiBpY29uID0gZS50YXJnZXQgfVxuXHRcdG9ubW91c2Vkb3duID0geyAoKSA9PiBpc01vdXNlID0gdHJ1ZSB9XG5cdFx0b253aGVlbCA9IHsgZSA9PiBjb25zb2xlLmxvZyggZS5kZWx0YVksIGUuZGVsdGFNb2RlLCBlICkgfVxuXHRcdGNsYXNzID0geyAoKSA9PiBgXG5cdFx0XHRpY29uXG5cdFx0XHQkeyBvcHRzLm9ubmluZyAmJiBgb25uaW5nYCB9XG5cdFx0XHQkeyBvcHRzLm9mZmluZyAmJiBgb2ZmaW5nYCB9XG5cdFx0XHQkeyBvcHRzLmZpbmFsICYmIGBmaW5hbGAgfVxuXHRcdFx0JHsgb3B0cy5lcnJvcm5lb3VzICYmIGBlcnJvcm5lb3VzYCB9XG5cdFx0XHQkeyBvcHRzLmRpbW1lcmluZy52YWx1ZU9mKCkgPyBgZGltbWVyaW5nYCA6IGBzd2l0Y2hpbmdgIH1cblx0XHRcdCR7IGljb25JZCB9XG5cdFx0XHRpY29uX21vdmluZ18keyAhIW9wdHMubW92aW5nIH1cblx0XHRcdGljb25fbW92ZWRfJHsgISFvcHRzLm1vdmluZyAmJiAhIW9wdHMubW92ZWQgfVxuXHRcdFx0aWNvbl9kZXN0aW5hdGlvbl8keyAhISggYXBwLmhvdmVyICYmIGFwcC5ob3ZlclsgaWNvbklkIF0gKSB9XG5cdFx0YCB9XG5cdFx0c3R5bGUgPSB7IGZ1bmN0aW9uKiBibG9jaygpIHtcblx0XHRcdC8vINC60LDQu9GWINCw0LTRgNCw0LfRgyDQv9GA0YvRgdCy0L7RltGG0YwgbGVmdCDRliB0b3Ag0YLQviDRh9Cw0LzRg9GB0YzRhtGWINC90LUg0L/RgNCw0YbRg9C1IHRyYW5zaXRpb25cblx0XHRcdC8vIFRPRE86INGA0LDQt9Cw0LHRgNCw0YbRhtCwLCDRhtGWINGR0YHRjNGG0Ywg0Y/QutGWINC3INCz0Y3RgtGL0YUg0LTQstGD0YUg0YDQsNC00LrQvtGeINC70ZbRiNC90ZY/XG5cdFx0XHRhcHAuZWRpdGluZyAmJiAoIHlpZWxkIGNvLnNsZWVwKCkgKVxuXHRcdFx0IWJsb2NrLnJ1biA/IGJsb2NrLnJ1biA9IHRydWUgOiAoIHlpZWxkIGNvLnJlcXVlc3RBbmltYXRpb25GcmFtZSApXG5cdFx0XHQvL1xuXG5cdFx0XHRsZXQgcHRcblx0XHRcdGlmICggb3B0cy5tb3ZpbmcgKVxuXHRcdFx0XHRwdCA9IHsgeDogb3B0cy54LCB5OiBvcHRzLnkgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBpID0gbHUudmFsdWVPZiggcG9zaXRpb24gKVxuXHRcdFx0XHRsZXQgcGggPSBhcHAucGFnZUhlaWdodCB8fCAxXG5cdFx0XHRcdGxldCBwdyA9IGFwcC5wYWdlV2lkdGggfHwgMVxuXHRcdFx0XHRsZXQgcHMgPSBwdyAqIHBoXG5cdFx0XHRcdGxldCBwaSA9IGkgJSBwc1xuXHRcdFx0XHRsZXQgcCA9ICggaSAtIHBpICkgLyBwc1xuXHRcdFx0XHRsZXQgdyA9IHBpICUgcHdcblx0XHRcdFx0bGV0IGggPSAoIHBpIC0gdyApIC8gcHdcblx0XHRcdFx0dyArPSBwdyAqIHBcblx0XHRcdFx0cHQgPSB7IHg6IHcgKiAxMDAgLyBwdywgeTogaCAqIDEwMCAvIHBoIH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGxlZnQ6IGAkeyBwdC54IH0lYCxcblx0XHRcdFx0dG9wOiBgJHsgcHQueSB9JWAsXG5cdFx0XHR9XG5cdFx0fSB9XG5cdD5cblx0XHQ8ZGl2IGNsYXNzID0gXCJpY29uQ29udHJvbFwiXG5cdFx0XHRvbnRvdWNoID0geyBodG1sdXRpbHMucHJldmVudERlZmF1bHQgfVxuXHRcdFx0b250YXAgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBvcHRzLmljb25Db21tYW5kKCBgU2hvcnRgICkgfVxuXHRcdFx0b25wcmVzcyA9IHsgKCkgPT4gIWFwcC5lZGl0aW5nICYmIG9wdHMuaWNvbkNvbW1hbmQoIGBMb25nYCApIH1cblx0XHRcdG9ucGFuID0geyBmdW5jdGlvbiogKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoIGFwcC5lZGl0aW5nICkge1xuXHRcdFx0XHRcdC8vIG1vdmluZ1xuXHRcdFx0XHRcdGxldCBuZXh0ID0gZGF0YS5kZXRhaWwubG9jaygpXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGZvciAoIGxldCBwdDsgcHQgPSB5aWVsZCBuZXh0OyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBwdC5kZXRhaWwucHJlc3NlZCA9PSBmYWxzZSApXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdGlmICggcHQuZGV0YWlsLnByZXNzZWQgPT0gbnVsbCApXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdFx0eWllbGQqIG1vdmUoIHB0LCBuZXh0IClcblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdFx0XHRkYXRhLmRldGFpbC51bmxvY2soIG5leHQgKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGB1cGAgfHwgZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGBkb3duYCApIHtcblx0XHRcdFx0XHQvLyBkaW1tZXJpbmdcblx0XHRcdFx0XHRkYXRhLnN0b3BQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0eWllbGQqIGRpbW0oIGRhdGEuZGV0YWlsLm5leHQgKVxuXHRcdFx0XHR9XG5cdFx0XHR9IH1cblx0XHQ+XG5cdFx0XHQ8ZGl2IGNsYXNzID0gXCJpbWFnZVwiIG9uY3JlYXRlID0geyBlID0+IGltYWdlID0gZS50YXJnZXQgfSA+XG5cdFx0XHRcdDxQaWN0dXJlIGNsYXNzID0gXCJ3YWl0XCIgc3JjID0gXCIvaW1hZ2VzL3dhaXQuc3ZnXCIgc3R5bGUgPSB7e1xuXHRcdFx0XHRcdHZpc2liaWxpdHk6ICgpID0+IHRoaXMuZmluYWwgPyBgaGlkZGVuYCA6IG51bGwsXG5cdFx0XHRcdH19IC8+XG5cdFx0XHRcdDxQaWN0dXJlIGNsYXNzID0gXCJvZmZcIiBzcmMgPSBcIi9pbWFnZXMvcm9vbS5zdmdcIiBvbmNyZWF0ZSA9IHsgZSA9PiBvZmYgPSBlLnRhcmdldCB9IC8+XG5cdFx0XHRcdDxQaWN0dXJlIGNsYXNzID0gXCJvblwiIHNyYyA9IFwiL2ltYWdlcy9yb29tX29uLnN2Z1wiIG9uY3JlYXRlID0geyBlID0+IG9uID0gZS50YXJnZXQgfSAvPlxuXHRcdFx0XHQ8UGljdHVyZSBjbGFzcyA9IFwiYWJzZW50XCIgc3JjID0gXCIvaW1hZ2VzL3Jvb21fYWJzZW50LnN2Z1wiIG9uY3JlYXRlID0geyBlID0+IGFic2VudCA9IGUudGFyZ2V0IH0gLz5cblx0XHRcdFx0PGRpdiBjbGFzcyA9IHsgKCkgPT4gYFxuXHRcdFx0XHRcdHN2Z1xuXHRcdFx0XHRcdCR7IGBzdGF0ZWAgKyAoICFvcHRzLnByZXNlbnQgPyBgQWJzZW50YCA6ICggTWF0aC5yb3VuZCggb3B0cy5zdGF0ZSAqIDEwMCApICsgMTAwMCApLnRvU3RyaW5nKCkuc2xpY2UoIDEgKSApIH1cblx0XHRcdFx0XHQkeyAhb3B0cy5pc0RpbW1lcmluZyA/IGBzbW9vdGhpbmdgIDogYGAgfVxuXHRcdFx0XHRgIH0gPntcblx0XHRcdFx0XHQoKSA9PiBvcHRzLmljb25EYXRhID0gb3B0cy5pY29uVGVtcGxhdGUgJiYgaHRtbHV0aWxzLmltcG9ydENvbXBvbmVudCggb3B0cy5pY29uVGVtcGxhdGUgKSB8fCBudWxsXG5cdFx0XHRcdH08L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImljb25MYWJlbFwiID57ICgpID0+XG5cdFx0XHRcdGljb25EZXNjci5nZXQoIGxvY2FsLmxhbmd1YWdlICkgfHwgaWNvbkRlc2NyLmdldCggYHJ1YCApIHx8IGljb25EZXNjci5nZXQoIGBlbmAgKVxuXHRcdFx0fTwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJpY29uUGVyY2VudGFnZVwiID57ICgpID0+XG5cdFx0XHRcdG9wdHMucHJlc2VudCAmJiBvcHRzLmRpbW1lcmluZyAmJiBgJHsgTWF0aC5yb3VuZCggb3B0cy5zdGF0ZSAqIDEwMCApIH0lYFxuXHRcdFx0fTwvc3Bhbj5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzID0gXCJkZWxldGVTaWduXCIgb250b3VjaHN0YXJ0ID0geyAoKSA9PiBhcHAuZGVsZXRlSXRlbSggcGxhY2VJZCwgaWNvbklkICkgfSBvbm1vdXNlZG93biA9IHsgKCkgPT4gYXBwLmRlbGV0ZUl0ZW0oIHBsYWNlSWQsIGljb25JZCApIH0gLz5cblx0PC9kaXY+XG59XG4iLCJsZXQgaHRtbHV0aWxzID0gcmVxdWlyZSggYGh0bWx1dGlsc2AgKVxubGV0IFVJRCA9IHJlcXVpcmUoIGB1aWRgIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGFwcCwgbG9jYWwgKSA9PiB7XG5cblx0bGV0IFBsYWNlID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9QbGFjZWAgKSApXG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRsZXQgaWQgPSBVSUQoKVxuXG5cdFx0ZnVuY3Rpb24qIHBhbiggbmV4dCApIHtcblx0XHRcdC8vIFRPRE86IG5vIHRyYW5zaXRpb24gd2hpbGUgcGFubmluZ1xuXHRcdFx0bGV0IGxhc3REZWx0YVgsIHBhZ2UsIHNpemVcblx0XHRcdGxldCBkZXZpY2VpZCA9IGFwcC5hY3RpdmVEZXZpY2VJZFxuXHRcdFx0YXBwLnBsYWNlc1NoaWZ0cy5kZWZpbmVQcm9wZXJ0eSggZGV2aWNlaWQgKVxuXHRcdFx0bG9jYWwucGxhY2VzUGFnZXMuZGVmaW5lUHJvcGVydHkoIGRldmljZWlkIClcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAoIGxldCBkYXRhOyBkYXRhID0geWllbGQgbmV4dDsgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmxhc3REZWx0YVggKVxuXHRcdFx0XHRcdFx0bGFzdERlbHRhWCA9IGRhdGEubGFzdERlbHRhWFxuXHRcdFx0XHRcdGxldCBkZWx0YVggPSBkYXRhLmRlbHRhWFxuXHRcdFx0XHRcdGxldCByZWN0ID0gYXBwLm1lbnVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cdFx0XHRcdFx0bGV0IGRldmljZSA9IGFwcC5nZXREZXZpY2UoIGRldmljZWlkIClcblx0XHRcdFx0XHRpZiAoICFkZXZpY2UgfHwgIWRldmljZS5jb250ZW50IClcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdHNpemUgPSBNYXRoLmNlaWwoIE9iamVjdC5rZXlzKCBkZXZpY2UuY29udGVudCApLmxlbmd0aCAvICggYXBwLnBhZ2VXaWR0aCAqIGFwcC5wYWdlSGVpZ2h0ICkgKVxuXHRcdFx0XHRcdGlmICggc2l6ZSA9PSAwIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0cGFnZSA9IGxvY2FsLnBsYWNlc1BhZ2VzWyBkZXZpY2VpZCBdIHx8IDBcblx0XHRcdFx0XHRsZXQgaW5pdGlhbFNoaWZ0ID0gLXBhZ2UgKiByZWN0LndpZHRoXG5cdFx0XHRcdFx0bGV0IHNoaWZ0ID0gZGF0YS5kZWx0YVhcblx0XHRcdFx0XHRpZiAoIHNoaWZ0ID4gMCAmJiBwYWdlID09IDAgfHwgc2hpZnQgPCAwICYmIHBhZ2UgPT0gc2l6ZSAtIDEgKVxuXHRcdFx0XHRcdFx0c2hpZnQgLz0gM1xuXHRcdFx0XHRcdGFwcC5wbGFjZXNTaGlmdHNbIGRldmljZWlkIF0gPSBzaGlmdFxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbGFzdERlbHRhWCApIHtcblx0XHRcdFx0XHRpZiAoIGxhc3REZWx0YVggPiAwICYmIHBhZ2UgPiAwIClcblx0XHRcdFx0XHRcdGxvY2FsLnBsYWNlc1BhZ2VzWyBkZXZpY2VpZCBdID0gcGFnZSAtIDFcblx0XHRcdFx0XHRlbHNlIGlmICggbGFzdERlbHRhWCA8IDAgJiYgcGFnZSA8IHNpemUgLSAxIClcblx0XHRcdFx0XHRcdGxvY2FsLnBsYWNlc1BhZ2VzWyBkZXZpY2VpZCBdID0gcGFnZSArIDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdGFwcC5wbGFjZXNTaGlmdHNbIGRldmljZWlkIF0gPSAwXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDxkaXYgPlxuXHRcdFx0PHN0eWxlIGNsYXNzID0gXCJzdHlsZVwiID57ICgpID0+IGBcblx0XHRcdFx0LiR7IGlkIH0gLmljb24ge1xuXHRcdFx0XHRcdHdpZHRoOiAkeyAxMDAgLyBhcHAucGFnZVdpZHRoIH0lO1xuXHRcdFx0XHRcdGhlaWdodDogJHsgMTAwIC8gYXBwLnBhZ2VIZWlnaHQgfSU7XG5cdFx0XHRcdH1cblx0XHRcdGAgfTwvc3R5bGU+XG5cdFx0XHQ8ZGl2IGNsYXNzID0gXCJ0b3BcIiA+XG5cdFx0XHRcdDxzcGFuIGNsYXNzID0gXCJ0b3Bfc2VsZlwiID5cblx0XHRcdFx0XHQ8aHRtbHV0aWxzLkNlbnRlcmVkPnsgKCkgPT4gYXBwLmNhcHRpb24gfTwvaHRtbHV0aWxzLkNlbnRlcmVkPlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3MgPSB7ICgpID0+IGBtZW51ICR7IGlkIH0gJHsgYXBwLmFjdGl2ZURldmljZUlkIH1gIH1cblx0XHRcdFx0b25wYW4gPSB7IGZ1bmN0aW9uKiAoIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmRldGFpbC5kaXJlY3Rpb24gPT0gYGxlZnRgIHx8IGRhdGEuZGV0YWlsLmRpcmVjdGlvbiA9PSBgcmlnaHRgICkge1xuXHRcdFx0XHRcdFx0ZGF0YS5zdG9wUHJvcGFnYXRpb24oKVxuXHRcdFx0XHRcdFx0eWllbGQqIHBhbiggZXZlbnQuZGV0YWlsLm5leHQgKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB9XG5cdFx0XHRcdG9uY3JlYXRlID0geyBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0YXBwLm1lbnVFbGVtZW50ID0gdGhpc1xuXHRcdFx0XHRcdGxldCBzaG93biA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHRcdHJhKCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgaWQgPSBhcHAuYWN0aXZlRGV2aWNlSWRcblx0XHRcdFx0XHRcdGlmICggIWlkIHx8IHNob3duWyBpZCBdIClcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRhcHAucGxhY2VzU2hpZnRzLmRlZmluZVByb3BlcnR5KCBpZCApXG5cdFx0XHRcdFx0XHRsb2NhbC5wbGFjZXNQYWdlcy5kZWZpbmVQcm9wZXJ0eSggaWQgKVxuXHRcdFx0XHRcdFx0c2hvd25bIGlkIF0gPSB0cnVlXG5cdFx0XHRcdFx0XHQvLyBUT0RPOiByZW1vdmUgPFBsYWNlLz4gd2hlbiBzdWNoIGEgcGxhY2UgaXMgYWN0dWFsbHkgcmVtb3ZlZCBmcm9tIGRhdGFiYXNlXG5cdFx0XHRcdFx0XHR0aGlzLmFwcGVuZENoaWxkKCA8UGxhY2UgcGxhY2VJZCA9IHsgaWQgfSBwbGFjZURlc2NyID0geyByYSggKCkgPT4gYXBwLmdldERldmljZSggaWQgKSApIH0gLz4gKVxuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHR9IH1cblx0XHRcdC8+XG5cdFx0XHQ8ZGl2IGNsYXNzID0gXCJib3R0b21cIiA+XG5cdFx0XHRcdDxkaXYgY2xhc3MgPSBcImhlbHBcIlxuXHRcdFx0XHRcdG9ucHJlc3MgPSB7ICgpID0+IGFwcC5kaWFsb2cgPSBgU2VydmljZURpYWxvZ2AgfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzID0gXCJsb2dvXCJcblx0XHRcdFx0XHRvbnByZXNzID0geyAoKSA9PiBhcHAuZGlhbG9nID0gYENvbnRleHRNZW51YCB9XG5cdFx0XHRcdFx0b250YXAgPSB7IGV2ZW50ID0+IHtcblx0XHRcdFx0XHRcdGlmICggZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuc3JjRXZlbnQgJiYgZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkgKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYXBwLmRpYWxvZyA9IGBDb250ZXh0TWVudWBcblx0XHRcdFx0XHRcdGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5zcmNFdmVudCAmJiBldmVudC5zcmNFdmVudC5jdHJsS2V5IClcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGFwcC5kaWFsb2cgPSBgU2VhcmNoSXRlbXNgXG5cdFx0XHRcdFx0XHRhcHAuZWRpdGluZyA9IGZhbHNlXG5cdFx0XHRcdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdFx0XHRcdGFwcC5nbyggYXBwLm1haW4gKVxuXHRcdFx0XHRcdH0gfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzID0gXCJiYWNrXCJcblx0XHRcdFx0XHRvbnRvdWNoID0geyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIGFwcC5lZGl0aW5nIClcblx0XHRcdFx0XHRcdFx0YXBwLmVkaXRpbmcgPSBmYWxzZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoIGFwcC5kaWFsb2cgKVxuXHRcdFx0XHRcdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0YXBwLmJhY2soKVxuXHRcdFx0XHRcdH0gfVxuXHRcdFx0XHQvPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdH1cbn1cbiIsImxldCBBcHBsaWNhdGlvbiA9IHJlcXVpcmUoIGB1aS9BcHBsaWNhdGlvbmAgKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggeyBJY29uVGVtcGxhdGVzIH0gKSA9PiA8c3Bhbj5cblx0PHN0eWxlPiB7IGAuYXBwbGljYXRpb24geyBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDsgfSB9IGAgfSA8L3N0eWxlPlxuXHQ8QXBwbGljYXRpb24gSWNvblRlbXBsYXRlcyA9IHsgSWNvblRlbXBsYXRlcyB9IC8+XG48L3NwYW4+XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICggYXBwLCBsb2NhbCApID0+IHtcblxuXHRsZXQgSWNvbiA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvSWNvbmAgKSApXG5cblx0cmV0dXJuICggeyBwbGFjZUlkLCBwbGFjZURlc2NyIH0gKSA9PiB7XG5cdFx0bGV0IGlkcyA9IHJhKCAoKSA9PiB7XG5cdFx0XHRsZXQgY29udGVudCA9IHBsYWNlRGVzY3IuZ2V0KCBgY29udGVudGAgKVxuXHRcdFx0cmV0dXJuIHJhLkFycmF5KCBsb2Rhc2gua2V5cyggY29udGVudCApLnNvcnQoICggYSwgYiApID0+IGx1LmNvbXBhcmUoIGNvbnRlbnRbIGEgXS5pbmRleCwgY29udGVudFsgYiBdLmluZGV4ICkgKSApXG5cdFx0fSApXG5cdFx0bGV0IGNvbnRlbnQgPSByYS5tYXAoIGlkcywgKCBpY29uSWQsIHBvc2l0aW9uICkgPT4gPEljb25cblx0XHRcdHBsYWNlSWQgPSB7IHBsYWNlSWQgfVxuXHRcdFx0aWNvbklkID0geyBpY29uSWQgfVxuXHRcdFx0cG9zaXRpb24gPSB7IHBvc2l0aW9uIH1cblx0XHRcdGljb25EZXNjciA9IHsgcmEoICgpID0+IGFwcC5nZXREZXZpY2UoIGljb25JZCApICkgfVxuXHRcdC8+IClcblx0XHRyZXR1cm4gPGRpdj5cblx0XHRcdDxzdHlsZT57IGBcblx0XHRcdFx0LiR7IHBsYWNlSWQgfSAucGxhY2UuJHsgcGxhY2VJZCB9IHtcblx0XHRcdFx0XHRkaXNwbGF5OiBpbml0aWFsO1xuXHRcdFx0XHR9XG5cdFx0XHRgIH08L3N0eWxlPlxuXHRcdFx0PGRpdiBjbGFzcyA9IHsgYHBsYWNlICR7IHBsYWNlSWQgfWAgfSBzdHlsZSA9IHt7XG5cdFx0XHRcdHRyYW5zZm9ybTogKCkgPT4gYHRyYW5zbGF0ZVgoICR7XG5cdFx0XHRcdFx0LSggbG9jYWwucGxhY2VzUGFnZXNbIHBsYWNlSWQgXSB8fCAwICkgKiBhcHAubWVudUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyBhcHAucGxhY2VzU2hpZnRzWyBwbGFjZUlkIF0gfHwgMFxuXHRcdFx0XHR9cHggKWAsXG5cdFx0XHR9fSA+e1xuXHRcdFx0XHQoKSA9PiBjb250ZW50XG5cdFx0XHR9PC9kaXY+XG5cdFx0PC9kaXY+XG5cdH1cbn1cbiIsImxldCBETCA9IHJlcXVpcmUoIGBEYW1lcmF1TGV2ZW5zaHRlaW5gIClcblxubGV0IG5vdEFDaGFyID0gY2hhciA9PiBjaGFyIDw9IGAgYCB8fCBjaGFyID09IGAtYFxuXG5sZXQgZnV6enkgPSAoIG1hc2ssIHRleHQgKSA9PiBETCggbWFzay50b1VwcGVyQ2FzZSgpLCB0ZXh0LnRvVXBwZXJDYXNlKCksIHtcblx0cmVwbGFjZTogSW5maW5pdHksXG5cdGRlbGV0ZTogY2hhciA9PiBub3RBQ2hhciggY2hhciApID8gMWUtMiA6IEluZmluaXR5LFxuXHRpbnNlcnQ6IGNoYXIgPT4gbm90QUNoYXIoIGNoYXIgKSA/IDFlLTIgOiAxLFxuXHR0cmFuc3Bvc2U6IDEsXG59IClcblxuZnVuY3Rpb24gd2F0Y2goIGRhdGEsIGNiICkge1xuXHRsZXQgdlxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICggdiA9PSBudWxsICkgcmEuZGV0YWNoKCAoKSA9PiB7XG5cdFx0XHR2ID0gcmEoIGRhdGEgKVxuXHRcdFx0cmEoICgpID0+IHtcblx0XHRcdFx0di52YWx1ZU9mKClcblx0XHRcdFx0Y2IoKVxuXHRcdFx0fSApXG5cdFx0fSApXG5cdFx0cmV0dXJuIHYudmFsdWVPZigpXG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4ge1xuXHRsZXQgb3B0cywgJCA9IHt9XG5cblx0bGV0IFNlYXJjaEl0ZW0gPSAoIHsgcGxhY2VJZCB9ICkgPT5cblx0XHQ8ZGl2IGNsYXNzID0geyBgc2VhcmNoSXRlbSAkeyBwbGFjZUlkIH1gIH0gb25zY3JvbGx0YXAgPSB7ICgpID0+IG9wdHMuZ290byggcGxhY2VJZCApIH0gPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImNhcHRpb25cIiA+eyAoKSA9PiBvcHRzLnBsYWNlSW5mb3NbIHBsYWNlSWQgXS5jYXB0aW9uIH08L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcyA9IFwicGxhY2VzXCIgPnsgKCkgPT4gb3B0cy5wbGFjZUluZm9zWyBwbGFjZUlkIF0ucHRleHQgfTwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJjbWREZWxldGVGcm9tUHJvZ3JhbVwiPjwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJjbWRBcHBlbmRcIj48L3NwYW4+XG5cdFx0PC9kaXY+XG5cblx0b3B0cyA9IHJhKCB7XG5cdFx0Z290byggaWQgKSB7XG5cdFx0XHRpZiAoICFpZCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0bGV0IHBsYWNlSW5mbyA9IG9wdHMucGxhY2VJbmZvc1sgaWQgXVxuXHRcdFx0figgYXBwLnNlYXJjaEFjdGlvbiB8fCBhcHAuZ28gKSggaWQsIHBsYWNlSW5mbyAmJiBwbGFjZUluZm8ucGxhY2VzIClcblx0XHR9LFxuXHRcdGdldCBkZXZpY2VJZHMoKSB7IHJldHVybiByYS5BcnJheSggYXBwLmRldmljZUlkcy5maWx0ZXIoIGlkID0+IGlkICE9IGFwcC5tYWluICkgKSB9LFxuXHRcdGdldCBwbGFjZUluZm9zKCkge1xuXHRcdFx0bGV0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRmb3IgKCBsZXQgaWQgb2YgdGhpcy5kZXZpY2VJZHMgKSB7XG5cdFx0XHRcdGxldCBpbmZvID0gYXBwLmdldERldmljZSggaWQgKVxuXHRcdFx0XHRjYWNoZVsgaWQgXSA9IHtcblx0XHRcdFx0XHRpbmZvLFxuXHRcdFx0XHRcdGNhcHRpb246IGFwcC5nZXRNZXNzYWdlKCBpbmZvICksXG5cdFx0XHRcdFx0cGxhY2VzOiBbXSxcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yICggbGV0IGlkIG9mIHRoaXMuZGV2aWNlSWRzIClcblx0XHRcdFx0bG9kYXNoLmZvckVhY2goIGNhY2hlWyBpZCBdLmluZm8uY29udGVudCwgKCBfLCBrZXkgKSA9PlxuXHRcdFx0XHRcdGNhY2hlWyBrZXkgXSAmJiAoIGNhY2hlWyBrZXkgXS5wbGFjZXMucHVzaCggaWQgKSApXG5cdFx0XHRcdClcblx0XHRcdGxldCByZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGZvciAoIGxldCBpZCBvZiB0aGlzLmRldmljZUlkcyApIHtcblx0XHRcdFx0bGV0IGMgPSBjYWNoZVsgaWQgXVxuXHRcdFx0XHRsZXQgcHRleHQgPSBjLnBsYWNlcy5tYXAoIGlkID0+IGNhY2hlWyBpZCBdLmNhcHRpb24gKS5qb2luKCBgLCBgIClcblx0XHRcdFx0aWYgKCBwdGV4dCApXG5cdFx0XHRcdFx0cHRleHQgPSBgKCR7IHB0ZXh0IH0pYFxuXHRcdFx0XHRyZXRbIGlkIF0gPSB7IGlkLCBjYXB0aW9uOiBjLmNhcHRpb24gfHwgYDwqKio+YCwgcGxhY2VzOiBjLnBsYWNlcywgcHRleHQgfVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJhLkpTT04oIHJldCApXG5cdFx0fSxcblx0XHRnZXQgbGFiZWxzKCkgeyByZXR1cm4gcmEua2V5bWFwKCBvcHRzLmxpdmUuZGV2aWNlSWRzLCBwbGFjZUlkID0+IDxTZWFyY2hJdGVtIHBsYWNlSWQgPSB7IHBsYWNlSWQgfSAvPiApIH0sXG5cdFx0Z2V0IGZpbHRlcmVkKCkge1xuXHRcdFx0bGV0IHZhbHVlID0gJC5tYXNrLnJhVmFsdWVcblx0XHRcdGxldCBhcnIgPSBbXVxuXHRcdFx0Zm9yICggbGV0IGlkIG9mIHRoaXMuZGV2aWNlSWRzLmZpbHRlciggYXBwLnNlYXJjaEZpbHRlciB8fCBCb29sZWFuICkgKSB7XG5cdFx0XHRcdGxldCBpID0gb3B0cy5wbGFjZUluZm9zWyBpZCBdXG5cdFx0XHRcdGxldCBrZXkgPSBbXVxuXHRcdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRcdGtleS5wdXNoKFxuXHRcdFx0XHRcdFx0ZnV6enkoIHZhbHVlLCBpLmNhcHRpb24gKSxcblx0XHRcdFx0XHRcdC8vID8/PyBNYXRoLm1heCggLi4uaS5wbGFjZXMubWFwKCBpZCA9PiBmdXp6eSggdmFsdWUsIG9wdHMucGxhY2VJbmZvc1sgaWQgXS5jYXB0aW9uICkgKSApLFxuXHRcdFx0XHRcdFx0ZnV6enkoIHZhbHVlLCBpLmNhcHRpb24gKyBgIGAgKyBpLnB0ZXh0IClcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0aWYgKCBrZXkuZXZlcnkoIGsgPT4gTWF0aC5hYnMoIGsgKSA9PSBJbmZpbml0eSApIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5LnB1c2goIGkuY2FwdGlvbi50b1VwcGVyQ2FzZSgpIClcblx0XHRcdFx0YXJyLnB1c2goIHsgaWQsIGtleSB9IClcblx0XHRcdH1cblx0XHRcdHJldHVybiByYS5BcnJheSggYXJyXG5cdFx0XHRcdC5zb3J0KCAoIGEsIGIgKSA9PiBsb2Rhc2hcblx0XHRcdFx0XHQuemlwKCBhLmtleSwgYi5rZXkgKVxuXHRcdFx0XHRcdC5tYXAoIHBhaXIgPT4gbHUuY29tcGFyZSggLi4ucGFpciApIClcblx0XHRcdFx0XHQucmVkdWNlKCAoIGEsIGIgKSA9PiBhIHx8IGIgKVxuXHRcdFx0XHQpXG5cdFx0XHRcdC5tYXAoIGEgPT4gYS5pZCApXG5cdFx0XHQpXG5cdFx0fSxcblx0XHRnZXQgaXRlbXMoKSB7XG5cdFx0XHRyZXR1cm4gcmEuQXJyYXkoIHRoaXMuZmlsdGVyZWQubWFwKCBpZCA9PiB0aGlzLmxhYmVscy5nZXQoIGlkICkgKSApXG5cdFx0fSxcblx0fSApXG5cdHdpbmRvdy5fc2VhcmNoID0gb3B0c1xuXHRyZXR1cm4gPGRpdlxuXHRcdG9uZGlhbG9nc2hvdyA9IHsgKCkgPT4ge1xuXHRcdFx0JC5zY3JvbGxlciAmJiAkLnNjcm9sbGVyLnJlZnJlc2goKVxuXHRcdFx0Ly8gVE9ETzog0YDQsNC30LDQsdGA0LDRhtGG0LAsINCwINGG0ZYg0YLRgNGN0LHQsCDQt9Cw0YbRltGA0LDRhtGMINC/0L7RiNGD0Lo/XG5cdFx0XHQkLm1hc2sucmFWYWx1ZSA9IGBgXG5cdFx0fSB9XG5cdD5cblx0XHQ8Zm9ybVxuXHRcdFx0b25zdWJtaXQgPSB7IGV2ZW50ID0+IHtcblx0XHRcdFx0ZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0XHRvcHRzLmdvdG8oIG9wdHMuZmlsdGVyZWRbIDAgXSApXG5cdFx0XHR9IH1cblx0XHQ+XG5cdFx0XHQ8aW5wdXQgbmFtZSA9IFwibWFza1wiIHR5cGUgPSBcInRleHRcIiBhdXRvZm9jdXMgPSBcImF1dG9mb2N1c1wiIG9uY3JlYXRlID0geyBldmVudCA9PiAkLm1hc2sgPSBldmVudC50YXJnZXQgfSAvPlxuXHRcdFx0PGRpdiBjbGFzcyA9IFwic2Nyb2xsXCIgb25jcmVhdGUgPSB7IGV2ZW50ID0+ICQuc2Nyb2xsID0gZXZlbnQudGFyZ2V0IH0gPlxuXHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3MgPSBcIml0ZW1zXCIgPntcblx0XHRcdFx0XHRcdHdhdGNoKCAoKSA9PiBvcHRzLml0ZW1zLCAoKSA9PiBzZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmICggISQuc2Nyb2xsZXIgKVxuXHRcdFx0XHRcdFx0XHRcdCQuc2Nyb2xsZXIgPSBuZXcgKCByZXF1aXJlKCBgaXNjcm9sbGAgKSApKCAkLnNjcm9sbCwge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW91c2VXaGVlbDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdHNjcm9sbGJhcnM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXA6IGBzY3JvbGx0YXBgLFxuXHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0JC5zY3JvbGxlci5yZWZyZXNoKClcblx0XHRcdFx0XHRcdH0sIDEwMCApIClcblx0XHRcdFx0XHR9PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcyA9IFwic2Nyb2xsQXJlYUJvdHRvbUZpbGxlclwiIC8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9mb3JtPlxuXHQ8L2Rpdj5cbn1cbiIsImxldCBodG1sdXRpbHMgPSByZXF1aXJlKCBgaHRtbHV0aWxzYCApXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwID0+IHtcblx0bGV0IGpzb25cblx0cmV0dXJuIDxkaXYgb25kaWFsb2dzaG93ID0geyAoKSA9PiBqc29uLnZhbHVlID0gSlNPTi5zdHJpbmdpZnkoIGFwcC5nZXREZXZpY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCApLCBudWxsLCAzICkgfSA+XG5cdFx0PGZvcm1cblx0XHRcdG9uc3VibWl0ID0geyBldmVudCA9PiB7XG5cdFx0XHRcdGV2ZW50ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHRcdFx0bGV0IHRleHQgPSBqc29uLnZhbHVlLnRyaW0oKSB8fCBudWxsXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGV4dCA9IHRleHQgJiYgSlNPTi5wYXJzZSggdGV4dCApXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWxlcnQoIGVycm9yIClcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWJ1Z2dlclxuXHRcdFx0XHRpZiAoIHRleHQgKVxuXHRcdFx0XHRcdGFwcC5zYXZlRGV2aWNlKCBhcHAuYWN0aXZlRGV2aWNlSWQsIHRleHQgKVxuXHRcdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdH0gfVxuXHRcdD5cblx0XHRcdDx0ZXh0YXJlYVxuXHRcdFx0XHRuYW1lID0gXCJqc29uXCJcblx0XHRcdFx0YXV0b2ZvY3VzID0gXCJhdXRvZm9jdXNcIlxuXHRcdFx0XHRvbmNyZWF0ZSA9IHsgZXZlbnQgPT4ganNvbiA9IGV2ZW50LnRhcmdldCB9XG5cdFx0XHRcdHN0eWxlID0ge3tcblx0XHRcdFx0XHRwb3NpdGlvbjogYGFic29sdXRlYCxcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdHRvcDogYDEwbW1gLFxuXHRcdFx0XHRcdGJvdHRvbTogYDE1bW1gLFxuXHRcdFx0XHRcdGZvbnRTaXplOiBgNTAlYCxcblx0XHRcdFx0fX1cblx0XHRcdC8+XG5cdFx0XHQ8YVxuXHRcdFx0XHRjbGFzcyA9IFwic2F2ZVwiXG5cdFx0XHRcdGhyZWYgPSBcImphdmFzY3JpcHQ6dm9pZCgwKVwiXG5cdFx0XHRcdHRhcmdldCA9IFwiX3NlbGZcIlxuXHRcdFx0XHRvbnRvdWNoID0geyBodG1sdXRpbHMuU3VibWl0IH1cblx0XHRcdFx0c3R5bGUgPSB7e1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBgYWJzb2x1dGVgLFxuXHRcdFx0XHRcdGRpc3BsYXk6IGBibG9ja2AsXG5cdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0XHRoZWlnaHQ6IGAxMG1tYCxcblx0XHRcdFx0XHRib3R0b206IGAwYCxcblx0XHRcdFx0fX1cblx0XHRcdD5TYXZlPC9hPlxuXHRcdDwvZm9ybT5cblx0PC9kaXY+XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiAoKSA9PiA8ZGl2IGNsYXNzID0gXCJzdGFydHVwU2NyZWVuXCIgPlxuXHQ8cD7QlNC+0LHRgNC+INC/0L7QttCw0LvQvtCy0LDRgtGMINCyINCS0LDRiDxici8+0KPQvNC90YvQuSDQlNC+0LwhPC9wPlxuXHQ8ZGl2IGNsYXNzID0gXCJ0ZW1wbGF0ZXNcIiA+XG5cdFx0PHA+0J/QvtC20LDQu9GD0LnRgdGC0LAsINCy0YvQsdC10YDQuNGC0LUg0LzQtdGB0YLQviwg0LPQtNC1INC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDRjdGC0L7RgiDQv9GD0LvRjNGCOjwvcD5cblx0XHQ8dWwgY2xhc3MgPSBcImhvdXNlVGVtcGxhdGVzXCIgPnsgKCkgPT4gKCBhcHAudGVtcGxhdGVzIHx8IFtdICkuY29uY2F0KCBbIHtcblx0XHRcdG1lbnU6IGDQvdCw0YfQsNGC0Ywg0YEg0YfQuNGB0YLQvtCz0L4g0LvQuNGB0YLQsGAsXG5cdFx0XHRydTogYNCc0L7QuSDQtNC+0LxgLFxuXHRcdFx0ZW46IGBIb21lYCxcblx0XHRcdHR5cGU6IGBwbGFjZWAsXG5cdFx0fSBdICkubWFwKCBob3VzZVRlbXBsYXRlID0+XG5cdFx0XHQ8bGkgY2xhc3MgPSBcImhvdXNlVGVtcGxhdGVcIiBvbnRvdWNoID0geyAoKSA9PiBhcHAuc2V0VGVtcGxhdGUoIGhvdXNlVGVtcGxhdGUgKSB9ID57XG5cdFx0XHRcdGhvdXNlVGVtcGxhdGUubWVudSB8fCBhcHAuZ2V0TWVzc2FnZSggaG91c2VUZW1wbGF0ZSApXG5cdFx0XHR9PC9saT5cblx0XHQpIH08L3VsPlxuXHQ8L2Rpdj5cblx0PGRpdiBjbGFzcyA9IFwibG9hZGluZ1wiID48L2Rpdj5cbjwvZGl2PlxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubGV0IGNvdW50ZXIgPSAwXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdWlkKCBvYmogKSB7XG5cdGxldCBpID0gKCArK2NvdW50ZXIgKS50b1N0cmluZyggMzYgKVxuXHRsZXQgciA9IHBhcnNlSW50KCBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc2xpY2UoIDIsIDE3ICkgKS50b1N0cmluZyggMzYgKVxuXHRsZXQgaWQgPSAoIHIubGVuZ3RoICsgOSApLnRvU3RyaW5nKCAzNiApICsgciArIGlcblx0aWYgKCBvYmogPT0gbnVsbCApXG5cdFx0cmV0dXJuIGlkXG5cdGVsc2Uge1xuXHRcdG9iai51aWQgPSBpZFxuXHRcdHJldHVybiBvYmpcblx0fVxufVxuIiwiLypcbnBvc3QgL2RldmljZXMge1wiUFwiOjF9XG4qL1xuXG5mdW5jdGlvbiBjaGVja0Jyb3dzZXJGdW5jdGlvbnMoKSB7XG5cdGxldCByZXQgPSB0cnVlXG5cdFx0JiYgdHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgIT0gYHVuZGVmaW5lZGAgJiYgSFRNTFRlbXBsYXRlRWxlbWVudFxuXHRyZXR1cm4gISFyZXRcbn1cblxuaWYgKCAhY2hlY2tCcm93c2VyRnVuY3Rpb25zKCkgKSB7XG5cdHdpbmRvdy5fX1VOU1VQUE9SVEVEX18oKVxuXHR0aHJvdyBuZXcgRXJyb3IoIFwidW5zdXBwb3J0ZWRcIiApXG59XG5cbmxldCBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCBnbG9iYWwuRGF0ZVxubGV0IHN0YXJ0VXBUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcblxucmVxdWlyZSggYGJyb3dzZXItbmV4dHRpY2tgIClcbnJlcXVpcmUoIGBwbGF0Zm9ybWAgKVxucmVxdWlyZSggYGh0bWxwb2x5ZmlsbGAgKVxucmVxdWlyZSggYHRyYWNrYCApXG5yZXF1aXJlKCBgZ2VzdHVyZWAgKVxuXG5nbG9iYWwubHUgPSByZXF1aXJlKCBgbG9jYWxVdGlsc2AgKVxuZ2xvYmFsLnJhID0gcmVxdWlyZSggYHJhYCApXG5nbG9iYWwuY28gPSByZXF1aXJlKCBgY29gIClcbmdsb2JhbC5sb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5yZXF1aXJlKCBgY29sb3JzYCApXG5cbmxldCBVSUQgPSByZXF1aXJlKCBgdWlkYCApXG5sZXQgaHR0cENsaWVudCA9IHJlcXVpcmUoIGBodHRwQ2xpZW50YCApXG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCBldmVudCApIHtcblx0aWYgKCBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSggYHJlbGAgKSA9PSBgZXh0ZXJuYWxgIClcblx0XHRyZXR1cm5cblx0Zm9yICggbGV0IEMgb2YgWyBIVE1MSW5wdXRFbGVtZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50LCBIVE1MT3B0aW9uRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQgXSApXG5cdFx0aWYgKCBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBDIClcblx0XHRcdHJldHVyblxuXHQvLyBhdHRlbXB0IHRvIHVzZSBuYXRpdmUgc2Nyb2xsaW5nIC0gdW5zdWNjZXNzZnVsbFxuXHQvLyBsZXQgQyA9IGV2ZW50LnRhcmdldFxuXHQvLyB3aGlsZSAoIEMgJiYgQy5jbGFzc0xpc3QgKSB7XG5cdC8vIFx0aWYgKCBDLmNsYXNzTGlzdC5jb250YWlucyggYHNjcm9sbGAgKSApXG5cdC8vIFx0XHRyZXR1cm5cblx0Ly8gXHRDID0gQy5wYXJlbnROb2RlXG5cdC8vIH1cblx0ZXZlbnQucHJldmVudERlZmF1bHQoKVxufVxuXG5mb3IgKCBsZXQgdHlwZSBvZiBbIGB0b3VjaHN0YXJ0YCwgYHRvdWNobW92ZWAsIGB0b3VjaGVuZGAsIGB0b3VjaGNhbmNlbGAgXSApXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBwcmV2ZW50RGVmYXVsdCApXG5cbmdsb2JhbC5MT0cgPSBmdW5jdGlvbiAoIHN0ciApIHtcblx0Ly8gaWYgKCBTdHJpbmcoIHN0ciApID09IGB1bmRlZmluZWRgIClcblx0Ly8gXHRkZWJ1Z2dlclxuXHRjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzIClcblx0Z2xvYmFsLl9BTEVSVCAmJiBnbG9iYWwuX0FMRVJUKCBzdHIgKVxuXHRsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblx0eGhyLm9wZW4oIGBQT1NUYCwgYC9sb2c/JHsgZW5jb2RlVVJJQ29tcG9uZW50KCBzdHIgKSB9YCApXG5cdHhoci5vbmVycm9yID0gbG9kYXNoLm5vb3Bcblx0eGhyLnNlbmQoKVxuXHRyZXR1cm4gc3RyXG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBgZXJyb3JgLCBmdW5jdGlvbiBvbkVycm9yKCBlICkge1xuXHRpZiAoICFlLm1lc3NhZ2UubWF0Y2goIDQwNCApICYmICFvbkVycm9yLnByb2Nlc3NpbmcgKSB7XG5cdFx0b25FcnJvci5wcm9jZXNzaW5nID0gdHJ1ZVxuXHRcdHRyeSB7XG5cdFx0XHRMT0coIGAkeyBlLm1lc3NhZ2UucmVkIH0gYXQgJHsgZS5saW5lbm8gfTokeyBlLmNvbG5vIH0gaW4gJHsgZS5maWxlbmFtZSB9YCApXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0b25FcnJvci5wcm9jZXNzaW5nID0gZmFsc2Vcblx0XHR9XG5cdH1cbn0gKVxuXG5sZXQgb25lcnJvciA9IHdpbmRvdy5vbmVycm9yXG53aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uICggbWVzc2FnZSwgdXJsLCBsaW5lLCBjb2x1bW4sIGVycm9yICkge1xuXHRsZXQgcmV0XG5cdGlmICggZXJyb3IgKSB7XG5cdFx0TE9HKCBgc3RhY2s6IGAgKyBlcnJvci5zdGFjayApXG5cdH1cblx0aWYgKCBvbmVycm9yICkge1xuXHRcdHRyeSB7XG5cdFx0XHR3aW5kb3cub25lcnJvciA9IG9uZXJyb3Jcblx0XHRcdHJldCA9IG9uZXJyb3IuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0b25lcnJvciA9IHdpbmRvdy5vbmVycm9yXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXRcbn1cblxuLy8gcmVxdWlyZSggYHRvdWNoTG9nYCApXG4vLyByZXF1aXJlKCBgdG91Y2hTaG93YCApXG4vLyByZXF1aXJlKCBgdG91Y2hlc2AgKVxuXG5nbG9iYWwuUmVhY3QgPSByZXF1aXJlKCBgY29tcG9uZW50c2AgKVxuXG5mdW5jdGlvbiBzY3JpcHQoIHRleHQgKSB7XG5cdGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgc2NyaXB0YCApXG5cdHNjcmlwdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRleHQgKSApXG5cdHJldHVybiBzY3JpcHRcbn1cblxuY28uZ28oIGZ1bmN0aW9uKiAoKSB7XG5cdGxldCBodG1sID0gY2FjaGVVcmxSZXNvdXJjZSggYC4vbWFpbi5odG1sYCApXG5cdGh0bWwgPSB5aWVsZCBodG1sXG5cblx0bGV0IGRhdGEgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblxuXHRsZXQgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYGRpdmAgKVxuXHR0bXAuaW5uZXJIVE1MID0gaHRtbFxuXHR0bXAgPSB0bXAuY2hpbGRyZW5bIDAgXVxuXHRsZXQgY2hpbGRyZW4gPSBbXVxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0bXAuY2hpbGROb2Rlcy5sZW5ndGg7ICsraSApXG5cdFx0Y2hpbGRyZW4ucHVzaCggdG1wLmNoaWxkTm9kZXNbIGkgXSApXG5cdGNoaWxkcmVuLmZvckVhY2goIGMgPT4gdG1wLnJlbW92ZUNoaWxkKCBjICkgKVxuXHRjaGlsZHJlbi5mb3JFYWNoKCBjID0+IHtcblx0XHRpZiAoIGMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCApXG5cdFx0XHRjID0gc2NyaXB0KCBjLmlubmVySFRNTCApXG5cdFx0ZGF0YS5hcHBlbmRDaGlsZCggYyApXG5cdH0gKVxuXG5cdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGRhdGEgKVxufSApXG5cbi8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAvLyBUT0RPOiDQstGL0LTQsNC70ZbRhtGMINC/0LDRgdGM0LvRjyDQstGL0YHRgtCw0LLRiy4g0J3QsNC00YLQsCDRgdGC0YDQsNGI0L3QsCDRj9C90L4g0LTQt9GR0YDQs9Cw0LXRhtGG0LAg0L/RgNGLINC/0LXRgNCw0LfQsNCz0YDRg9C30YbRi1xuLy8gXHRgbWVzc2FnZWAsXG4vLyBcdGV2ZW50ID0+IHtcbi8vIFx0XHRpZiAoIGV2ZW50ICYmIGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS53aGF0ID09IGB1cmxSZXNvdXJjZVVwZGF0ZWRgIClcbi8vIFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KFxuLy8gXHRcdFx0XHQoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCksXG4vLyBcdFx0XHRcdDEwMDBcbi8vIFx0XHRcdClcbi8vIFx0fSxcbi8vIFx0ZmFsc2Vcbi8vIClcbiIsImxldCByYSA9IHJlcXVpcmUoIGByYWAgKVxuXG5sZXQgd2luZG93U2l6ZSA9IHJhLmNsZWFuKCB7XG5cdHdpZHRoOiAxLFxuXHRoZWlnaHQ6IDEsXG5cdHBwbW06IDEsXG5cdHdpZHRobW06IDEsXG5cdGhlaWdodG1tOiAxLFxuXHRwaXhlbFJhdGlvOiAxLFxuXHRvcmllbnRhdGlvbjogMCxcblx0bGF5b3V0OiBgdmVydGljYWxgLFxuXHR3aW5kb3c6IGBicm93c2VyYCxcbn0gKS5zZXROYW1lKCBgd2luZG93U2l6ZWAgKVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggYHJlc2l6ZWAsIHVwZGF0ZVNpemUgKVxuXG5sZXQgb3JpZW50YXRpb25zID0ge31cblxubGV0IGNtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYGRpdmAgKVxuY20uc3R5bGUubGVmdCA9IGAwYFxuY20uc3R5bGUudG9wID0gYDBgXG5jbS5zdHlsZS53aWR0aCA9IGAxMGNtYFxuY20uc3R5bGUuaGVpZ2h0ID0gYDEwY21gXG5jbS5zdHlsZS5wb3NpdGlvbiA9IGBmaXhlZGBcbmNtLnN0eWxlLnpJbmRleCA9IGAtOTk5OWBcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGNtIClcbmxldCBwcG1tID0gY20uY2xpZW50V2lkdGggLyAxMDBcbmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIGNtIClcblxudXBkYXRlU2l6ZSgpXG5cbmZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG5cblx0bGV0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGhcblx0bGV0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuXG5cdGxldCBvcmllbnRhdGlvbiA9ICggd2luZG93Lm9yaWVudGF0aW9uIHx8IDAgKSAlIDM2MFxuXHRpZiAoIG9yaWVudGF0aW9uIDwgMCApIG9yaWVudGF0aW9uICs9IDM2MFxuXG5cdHdpbmRvd1NpemUud2lkdGggPSB3aWR0aFxuXHR3aW5kb3dTaXplLmhlaWdodCA9IGhlaWdodFxuXHR3aW5kb3dTaXplLnBwbW0gPSBwcG1tXG5cdHdpbmRvd1NpemUud2lkdGhtbSA9IHdpZHRoIC8gcHBtbVxuXHR3aW5kb3dTaXplLmhlaWdodG1tID0gaGVpZ2h0IC8gcHBtbVxuXHR3aW5kb3dTaXplLnBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxXG5cdHdpbmRvd1NpemUub3JpZW50YXRpb24gPSBvcmllbnRhdGlvblxuXHR3aW5kb3dTaXplLmxheW91dCA9IHdpZHRoIDw9IGhlaWdodCA/IGB2ZXJ0aWNhbGAgOiBgaG9yaXpvbnRhbGBcblx0d2luZG93U2l6ZS53aW5kb3cgPSB3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgPyBgYXBwYCA6IGBicm93c2VyYFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1NpemVcbiIsInJlcXVpcmUoIFwid2VicGFnZVwiIClcbnJlcXVpcmUoIFwidWkvT25lQXBwXCIgKVxuZ2xvYmFsLnJlcXVpcmUgPSBmdW5jdGlvbiByKCBuYW1lICkge1xuXHRcdFx0XHRcdGdsb2JhbC5yZXF1aXJlID0gbnVsbFxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVxdWlyZS5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdFx0XHRnbG9iYWwucmVxdWlyZSA9IHJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cbiJdfQ==
