(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

require("core-js/shim");

require("regenerator/runtime");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/lib/babel/polyfill.js","/node_modules/babel-core/lib/babel")

},{"_process":99,"buffer":94,"core-js/shim":90,"regenerator/runtime":91}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// false -> Array#indexOf
// true  -> Array#includes
var $ = require('./$');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = $.toObject($this)
      , length = $.toLength(O.length)
      , index  = $.toIndex(fromIndex, length)
      , value;
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index;
    } return !IS_INCLUDES && -1;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.array-includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var $   = require('./$')
  , ctx = require('./$.ctx');
module.exports = function(TYPE){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that){
    var O      = Object($.assertDefined($this))
      , self   = $.ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = $.toLength(self.length)
      , index  = 0
      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.array-methods.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.ctx":11,"_process":99,"buffer":94}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
assert.def = $.assertDefined;
assert.fn = function(it){
  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');
  return it;
};
assert.obj = function(it){
  if(!$.isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
assert.inst = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
module.exports = assert;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.assert.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , enumKeys = require('./$.enum-keys');
// 19.1.2.1 Object.assign(target, source, ...)
/* eslint-disable no-unused-vars */
module.exports = Object.assign || function assign(target, source){
/* eslint-enable no-unused-vars */
  var T = Object($.assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = $.ES5Object(arguments[i++])
      , keys   = enumKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.assign.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.enum-keys":14,"_process":99,"buffer":94}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , TAG      = require('./$.wks')('toStringTag')
  , toString = {}.toString;
function cof(it){
  return toString.call(it).slice(8, -1);
}
cof.classof = function(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
};
cof.set = function(it, tag, stat){
  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);
};
module.exports = cof;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.cof.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.wks":41,"_process":99,"buffer":94}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , safe     = require('./$.uid').safe
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , step     = require('./$.iter').step
  , $has     = $.has
  , set      = $.set
  , isObject = $.isObject
  , hide     = $.hide
  , isExtensible = Object.isExtensible || isObject
  , ID       = safe('id')
  , O1       = safe('O1')
  , LAST     = safe('last')
  , FIRST    = safe('first')
  , ITER     = safe('iter')
  , SIZE     = $.DESC ? safe('size') : 'size'
  , id       = 0;

function fastKey(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
}

function getEntry(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that[O1][index];
  // frozen object case
  for(entry = that[FIRST]; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
}

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      assert.inst(that, C, NAME);
      set(that, O1, $.create(null));
      set(that, SIZE, 0);
      set(that, LAST, undefined);
      set(that, FIRST, undefined);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that[FIRST] = that[LAST] = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that[O1][entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that[FIRST] == entry)that[FIRST] = next;
          if(that[LAST] == entry)that[LAST] = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments[1], 3)
          , entry;
        while(entry = entry ? entry.n : this[FIRST]){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if($.DESC)$.setDesc(C.prototype, 'size', {
      get: function(){
        return assert.def(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that[O1][index] = entry;
    } return that;
  },
  getEntry: getEntry,
  // add .keys, .values, .entries, [@@iterator]
  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
  setIter: function(C, NAME, IS_MAP){
    require('./$.iter-define')(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-strong.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.ctx":11,"./$.for-of":15,"./$.iter":22,"./$.iter-define":20,"./$.mix":25,"./$.uid":39,"_process":99,"buffer":94}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def')
  , forOf = require('./$.for-of');
module.exports = function(NAME){
  $def($def.P, NAME, {
    toJSON: function toJSON(){
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    }
  });
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.for-of":15,"_process":99,"buffer":94}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $         = require('./$')
  , safe      = require('./$.uid').safe
  , assert    = require('./$.assert')
  , forOf     = require('./$.for-of')
  , $has      = $.has
  , isObject  = $.isObject
  , hide      = $.hide
  , isExtensible = Object.isExtensible || isObject
  , id        = 0
  , ID        = safe('id')
  , WEAK      = safe('weak')
  , LEAK      = safe('leak')
  , method    = require('./$.array-methods')
  , find      = method(5)
  , findIndex = method(6);
function findFrozen(store, key){
  return find(store.array, function(it){
    return it[0] === key;
  });
}
// fallback for frozen keys
function leakStore(that){
  return that[LEAK] || hide(that, LEAK, {
    array: [],
    get: function(key){
      var entry = findFrozen(this, key);
      if(entry)return entry[1];
    },
    has: function(key){
      return !!findFrozen(this, key);
    },
    set: function(key, value){
      var entry = findFrozen(this, key);
      if(entry)entry[1] = value;
      else this.array.push([key, value]);
    },
    'delete': function(key){
      var index = findIndex(this.array, function(it){
        return it[0] === key;
      });
      if(~index)this.array.splice(index, 1);
      return !!~index;
    }
  })[LEAK];
}

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      $.set(assert.inst(that, C, NAME), ID, id++);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this)['delete'](key);
        return $has(key, WEAK) && $has(key[WEAK], this[ID]) && delete key[WEAK][this[ID]];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this).has(key);
        return $has(key, WEAK) && $has(key[WEAK], this[ID]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    if(!isExtensible(assert.obj(key))){
      leakStore(that).set(key, value);
    } else {
      $has(key, WEAK) || hide(key, WEAK, {});
      key[WEAK][that[ID]] = value;
    } return that;
  },
  leakStore: leakStore,
  WEAK: WEAK,
  ID: ID
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-weak.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.array-methods":3,"./$.assert":4,"./$.for-of":15,"./$.mix":25,"./$.uid":39,"_process":99,"buffer":94}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $     = require('./$')
  , $def  = require('./$.def')
  , BUGGY = require('./$.iter').BUGGY
  , forOf = require('./$.for-of')
  , species = require('./$.species')
  , assertInstance = require('./$.assert').inst;

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = $.g[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  function fixMethod(KEY){
    var fn = proto[KEY];
    require('./$.redef')(proto, KEY,
      KEY == 'delete' ? function(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'has' ? function has(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'get' ? function get(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
      : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  }
  if(!$.isFunction(C) || !(IS_WEAK || !BUGGY && proto.forEach && proto.entries)){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    require('./$.mix')(C.prototype, methods);
  } else {
    var inst  = new C
      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
      , buggyZero;
    // wrap for init collections from iterable
    if(!require('./$.iter-detect')(function(iter){ new C(iter); })){ // eslint-disable-line no-new
      C = wrapper(function(target, iterable){
        assertInstance(target, C, NAME);
        var that = new Base;
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    IS_WEAK || inst.forEach(function(val, key){
      buggyZero = 1 / key === -Infinity;
    });
    // fix converting -0 key to +0
    if(buggyZero){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    // + fix .add & .set for chaining
    if(buggyZero || chain !== inst)fixMethod(ADDER);
  }

  require('./$.cof').set(C, NAME);

  O[NAME] = C;
  $def($def.G + $def.W + $def.F * (C != Base), O);
  species(C);
  species($.core[NAME]); // for wrapper

  if(!IS_WEAK)common.setIter(C, NAME, IS_MAP);

  return C;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.for-of":15,"./$.iter":22,"./$.iter-detect":21,"./$.mix":25,"./$.redef":28,"./$.species":33,"_process":99,"buffer":94}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Optional / simple context binding
var assertFunction = require('./$.assert').fn;
module.exports = function(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  } return function(/* ...args */){
      return fn.apply(that, arguments);
    };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.ctx.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assert":4,"_process":99,"buffer":94}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $          = require('./$')
  , global     = $.g
  , core       = $.core
  , isFunction = $.isFunction
  , $redef     = require('./$.redef');
function ctx(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
}
global.core = core;
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
function $def(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , isProto  = type & $def.P
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {}).prototype
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    if(type & $def.B && own)exp = ctx(out, global);
    else exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
    // extend global
    if(target && !own)$redef(target, key, out);
    // export
    if(exports[key] != out)$.hide(exports, key, exp);
    if(isProto)(exports.prototype || (exports.prototype = {}))[key] = out;
  }
}
module.exports = $def;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.def.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.redef":28,"_process":99,"buffer":94}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , document = $.g.document
  , isObject = $.isObject
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.dom-create.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getDesc    = $.getDesc
    , getSymbols = $.getSymbols;
  if(getSymbols)$.each.call(getSymbols(it), function(key){
    if(getDesc(it, key).enumerable)keys.push(key);
  });
  return keys;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.enum-keys.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var ctx  = require('./$.ctx')
  , get  = require('./$.iter').get
  , call = require('./$.iter-call');
module.exports = function(iterable, entries, fn, that){
  var iterator = get(iterable)
    , f        = ctx(fn, that, entries ? 2 : 1)
    , step;
  while(!(step = iterator.next()).done){
    if(call(iterator, f, step.value, entries) === false){
      return call.close(iterator);
    }
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.for-of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.ctx":11,"./$.iter":22,"./$.iter-call":19,"_process":99,"buffer":94}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function($){
  $.FW   = true;
  $.path = $.g;
  return $;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.fw.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var $ = require('./$')
  , toString = {}.toString
  , getNames = $.getNames;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

function getWindowNames(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
}

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames($.toObject(it));
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.get-names.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.invoke.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assertObject = require('./$.assert').obj;
function close(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)assertObject(ret.call(iterator));
}
function call(iterator, fn, value, entries){
  try {
    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
  } catch(e){
    close(iterator);
    throw e;
  }
}
call.close = close;
module.exports = call;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-call.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assert":4,"_process":99,"buffer":94}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def            = require('./$.def')
  , $redef          = require('./$.redef')
  , $               = require('./$')
  , cof             = require('./$.cof')
  , $iter           = require('./$.iter')
  , SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , FF_ITERATOR     = '@@iterator'
  , KEYS            = 'keys'
  , VALUES          = 'values'
  , Iterators       = $iter.Iterators;
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
  $iter.create(Constructor, NAME, next);
  function createMethod(kind){
    function $$(that){
      return new Constructor(that, kind);
    }
    switch(kind){
      case KEYS: return function keys(){ return $$(this); };
      case VALUES: return function values(){ return $$(this); };
    } return function entries(){ return $$(this); };
  }
  var TAG      = NAME + ' Iterator'
    , proto    = Base.prototype
    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , _default = _native || createMethod(DEFAULT)
    , methods, key;
  // Fix native
  if(_native){
    var IteratorPrototype = $.getProto(_default.call(new Base));
    // Set @@toStringTag to native iterators
    cof.set(IteratorPrototype, TAG, true);
    // FF fix
    if($.FW && $.has(proto, FF_ITERATOR))$iter.set(IteratorPrototype, $.that);
  }
  // Define iterator
  if($.FW || FORCE)$iter.set(proto, _default);
  // Plug for library
  Iterators[NAME] = _default;
  Iterators[TAG]  = $.that;
  if(DEFAULT){
    methods = {
      keys:    IS_SET            ? _default : createMethod(KEYS),
      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
      entries: DEFAULT != VALUES ? _default : createMethod('entries')
    };
    if(FORCE)for(key in methods){
      if(!(key in proto))$redef(proto, key, methods[key]);
    } else $def($def.P + $def.F * $iter.BUGGY, NAME, methods);
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-define.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.def":12,"./$.iter":22,"./$.redef":28,"./$.wks":41,"_process":99,"buffer":94}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , SAFE_CLOSING    = false;
try {
  var riter = [7][SYMBOL_ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }
module.exports = function(exec){
  if(!SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[SYMBOL_ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[SYMBOL_ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-detect.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.wks":41,"_process":99,"buffer":94}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $                 = require('./$')
  , cof               = require('./$.cof')
  , classof           = cof.classof
  , assert            = require('./$.assert')
  , assertObject      = assert.obj
  , SYMBOL_ITERATOR   = require('./$.wks')('iterator')
  , FF_ITERATOR       = '@@iterator'
  , Iterators         = require('./$.shared')('iterators')
  , IteratorPrototype = {};
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, $.that);
function setIterator(O, value){
  $.hide(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);
}

module.exports = {
  // Safari has buggy iterators w/o `next`
  BUGGY: 'keys' in [] && !('next' in [].keys()),
  Iterators: Iterators,
  step: function(done, value){
    return {value: value, done: !!done};
  },
  is: function(it){
    var O      = Object(it)
      , Symbol = $.g.Symbol;
    return (Symbol && Symbol.iterator || FF_ITERATOR) in O
      || SYMBOL_ITERATOR in O
      || $.has(Iterators, classof(O));
  },
  get: function(it){
    var Symbol = $.g.Symbol
      , getIter;
    if(it != undefined){
      getIter = it[Symbol && Symbol.iterator || FF_ITERATOR]
        || it[SYMBOL_ITERATOR]
        || Iterators[classof(it)];
    }
    assert($.isFunction(getIter), it, ' is not iterable!');
    return assertObject(getIter.call(it));
  },
  set: setIterator,
  create: function(Constructor, NAME, next, proto){
    Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});
    cof.set(Constructor, NAME + ' Iterator');
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.shared":32,"./$.wks":41,"_process":99,"buffer":94}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var global = typeof self != 'undefined' ? self : Function('return this')()
  , core   = {}
  , defineProperty = Object.defineProperty
  , hasOwnProperty = {}.hasOwnProperty
  , ceil  = Math.ceil
  , floor = Math.floor
  , max   = Math.max
  , min   = Math.min;
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
  try {
    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
  } catch(e){ /* empty */ }
}();
var hide = createDefiner(1);
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
}
function desc(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return $.setDesc(object, key, desc(bitmap, value));
  } : simpleSet;
}

function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
function assertDefined(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
}

var $ = module.exports = require('./$.fw')({
  g: global,
  core: core,
  html: global.document && document.documentElement,
  // http://jsperf.com/core-js-isobject
  isObject:   isObject,
  isFunction: isFunction,
  that: function(){
    return this;
  },
  // 7.1.4 ToInteger
  toInteger: toInteger,
  // 7.1.15 ToLength
  toLength: function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  },
  toIndex: function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  },
  has: function(it, key){
    return hasOwnProperty.call(it, key);
  },
  create:     Object.create,
  getProto:   Object.getPrototypeOf,
  DESC:       DESC,
  desc:       desc,
  getDesc:    Object.getOwnPropertyDescriptor,
  setDesc:    defineProperty,
  setDescs:   Object.defineProperties,
  getKeys:    Object.keys,
  getNames:   Object.getOwnPropertyNames,
  getSymbols: Object.getOwnPropertySymbols,
  assertDefined: assertDefined,
  // Dummy, fix for not array-like ES3 string in es5 module
  ES5Object: Object,
  toObject: function(it){
    return $.ES5Object(assertDefined(it));
  },
  hide: hide,
  def: createDefiner(0),
  set: global.Symbol ? simpleSet : hide,
  each: [].forEach
});
/* eslint-disable no-undef */
if(typeof __e != 'undefined')__e = core;
if(typeof __g != 'undefined')__g = global;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.fw":16,"_process":99,"buffer":94}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
module.exports = function(object, el){
  var O      = $.toObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.keyof.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $redef = require('./$.redef');
module.exports = function(target, src){
  for(var key in src)$redef(target, key, src[key]);
  return target;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.mix.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.redef":28,"_process":99,"buffer":94}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $            = require('./$')
  , assertObject = require('./$.assert').obj;
module.exports = function ownKeys(it){
  assertObject(it);
  var keys       = $.getNames(it)
    , getSymbols = $.getSymbols;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.own-keys.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"_process":99,"buffer":94}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $      = require('./$')
  , invoke = require('./$.invoke')
  , assertFunction = require('./$.assert').fn;
module.exports = function(/* ...pargs */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = $.path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !_length)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(_length > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.partial.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.invoke":18,"_process":99,"buffer":94}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $   = require('./$')
  , tpl = String({}.hasOwnProperty)
  , SRC = require('./$.uid').safe('src')
  , _toString = Function.toString;

function $redef(O, key, val, safe){
  if($.isFunction(val)){
    var base = O[key];
    $.hide(val, SRC, base ? String(base) : tpl.replace(/hasOwnProperty/, String(key)));
    if(!('name' in val))val.name = key;
  }
  if(O === $.g){
    O[key] = val;
  } else {
    if(!safe)delete O[key];
    $.hide(O, key, val);
  }
}

// add fake Function#toString for correct work wrapped methods / constructors
// with methods similar to LoDash isNative
$redef(Function.prototype, 'toString', function toString(){
  return $.has(this, SRC) ? this[SRC] : _toString.call(this);
});

$.core.inspectSource = function(it){
  return _toString.call(it);
};

module.exports = $redef;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.redef.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.uid":39,"_process":99,"buffer":94}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
module.exports = function(regExp, replace, isStatic){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.replacer.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.same.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],31:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var $      = require('./$')
  , assert = require('./$.assert');
function check(O, proto){
  assert.obj(O);
  assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
}
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line
    ? function(buggy, set){
        try {
          set = require('./$.ctx')(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
          set({}, []);
        } catch(e){ buggy = true; }
        return function setPrototypeOf(O, proto){
          check(O, proto);
          if(buggy)O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }()
    : undefined),
  check: check
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.set-proto.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.ctx":11,"_process":99,"buffer":94}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $      = require('./$')
  , SHARED = '__core-js_shared__'
  , store  = $.g[SHARED] || $.hide($.g, SHARED, {})[SHARED];
module.exports = function(key){
  return store[key] || (store[key] = {});
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.shared.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $       = require('./$')
  , SPECIES = require('./$.wks')('species');
module.exports = function(C){
  if($.DESC && !(SPECIES in C))$.setDesc(C, SPECIES, {
    configurable: true,
    get: $.that
  });
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.species.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.wks":41,"_process":99,"buffer":94}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// true  -> String#at
// false -> String#codePointAt
var $ = require('./$');
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String($.assertDefined(that))
      , i = $.toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l
      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://wiki.ecmascript.org/doku.php?id=strawman:string_padding
var $      = require('./$')
  , repeat = require('./$.string-repeat');

module.exports = function(that, minLength, fillChar, left){
  // 1. Let O be CheckObjectCoercible(this value).
  // 2. Let S be ToString(O).
  var S = String($.assertDefined(that));
  // 4. If intMinLength is undefined, return S.
  if(minLength === undefined)return S;
  // 4. Let intMinLength be ToInteger(minLength).
  var intMinLength = $.toInteger(minLength);
  // 5. Let fillLen be the number of characters in S minus intMinLength.
  var fillLen = intMinLength - S.length;
  // 6. If fillLen < 0, then throw a RangeError exception.
  // 7. If fillLen is +∞, then throw a RangeError exception.
  if(fillLen < 0 || fillLen === Infinity){
    throw new RangeError('Cannot satisfy string length ' + minLength + ' for string: ' + S);
  }
  // 8. Let sFillStr be the string represented by fillStr.
  // 9. If sFillStr is undefined, let sFillStr be a space character.
  var sFillStr = fillChar === undefined ? ' ' : String(fillChar);
  // 10. Let sFillVal be a String made of sFillStr, repeated until fillLen is met.
  var sFillVal = repeat.call(sFillStr, Math.ceil(fillLen / sFillStr.length));
  // truncate if we overflowed
  if(sFillVal.length > fillLen)sFillVal = left
    ? sFillVal.slice(sFillVal.length - fillLen)
    : sFillVal.slice(0, fillLen);
  // 11. Return a string made from sFillVal, followed by S.
  // 11. Return a String made from S, followed by sFillVal.
  return left ? sFillVal.concat(S) : S.concat(sFillVal);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-pad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.string-repeat":36,"_process":99,"buffer":94}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $ = require('./$');

module.exports = function repeat(count){
  var str = String($.assertDefined(this))
    , res = ''
    , n   = $.toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-repeat.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $      = require('./$')
  , ctx    = require('./$.ctx')
  , cof    = require('./$.cof')
  , invoke = require('./$.invoke')
  , cel    = require('./$.dom-create')
  , global             = $.g
  , isFunction         = $.isFunction
  , html               = $.html
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , postMessage        = global.postMessage
  , addEventListener   = global.addEventListener
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
function run(){
  var id = +this;
  if($.has(queue, id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
}
function listner(event){
  run.call(event.data);
}
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!isFunction(setTask) || !isFunction(clearTask)){
  setTask = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(cof(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    };
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.task.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.ctx":11,"./$.dom-create":13,"./$.invoke":18,"_process":99,"buffer":94}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(exec){
  try {
    exec();
    return false;
  } catch(e){
    return true;
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.throws.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var sid = 0;
function uid(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++sid + Math.random()).toString(36));
}
uid.safe = require('./$').g.Symbol || uid;
module.exports = uid;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.uid.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./$.wks')('unscopables');
if(!(UNSCOPABLES in []))require('./$').hide(Array.prototype, UNSCOPABLES, {});
module.exports = function(key){
  [][UNSCOPABLES][key] = true;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.unscope.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.wks":41,"_process":99,"buffer":94}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var global = require('./$').g
  , store  = require('./$.shared')('wks');
module.exports = function(name){
  return store[name] || (store[name] =
    global.Symbol && global.Symbol[name] || require('./$.uid').safe('Symbol.' + name));
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.wks.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.shared":32,"./$.uid":39,"_process":99,"buffer":94}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $                = require('./$')
  , cel              = require('./$.dom-create')
  , cof              = require('./$.cof')
  , $def             = require('./$.def')
  , invoke           = require('./$.invoke')
  , arrayMethod      = require('./$.array-methods')
  , IE_PROTO         = require('./$.uid').safe('__proto__')
  , assert           = require('./$.assert')
  , assertObject     = assert.obj
  , ObjectProto      = Object.prototype
  , html             = $.html
  , A                = []
  , _slice           = A.slice
  , _join            = A.join
  , classof          = cof.classof
  , has              = $.has
  , defineProperty   = $.setDesc
  , getOwnDescriptor = $.getDesc
  , defineProperties = $.setDescs
  , isFunction       = $.isFunction
  , isObject         = $.isObject
  , toObject         = $.toObject
  , toLength         = $.toLength
  , toIndex          = $.toIndex
  , IE8_DOM_DEFINE   = false
  , $indexOf         = require('./$.array-includes')(false)
  , $forEach         = arrayMethod(0)
  , $map             = arrayMethod(1)
  , $filter          = arrayMethod(2)
  , $some            = arrayMethod(3)
  , $every           = arrayMethod(4);

if(!$.DESC){
  try {
    IE8_DOM_DEFINE = defineProperty(cel('div'), 'x',
      {get: function(){ return 8; }}
    ).x == 8;
  } catch(e){ /* empty */ }
  $.setDesc = function(O, P, Attributes){
    if(IE8_DOM_DEFINE)try {
      return defineProperty(O, P, Attributes);
    } catch(e){ /* empty */ }
    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
    if('value' in Attributes)assertObject(O)[P] = Attributes.value;
    return O;
  };
  $.getDesc = function(O, P){
    if(IE8_DOM_DEFINE)try {
      return getOwnDescriptor(O, P);
    } catch(e){ /* empty */ }
    if(has(O, P))return $.desc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
  };
  $.setDescs = defineProperties = function(O, Properties){
    assertObject(O);
    var keys   = $.getKeys(Properties)
      , length = keys.length
      , i = 0
      , P;
    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
    return O;
  };
}
$def($def.S + $def.F * !$.DESC, 'Object', {
  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $.getDesc,
  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  defineProperty: $.setDesc,
  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
  defineProperties: defineProperties
});

  // IE 8- don't enum bug keys
var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
            'toLocaleString,toString,valueOf').split(',')
  // Additional keys for getOwnPropertyNames
  , keys2 = keys1.concat('length', 'prototype')
  , keysLen1 = keys1.length;

// Create object with `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = cel('iframe')
    , i      = keysLen1
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write('<script>document.F=Object</script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict.prototype[keys1[i]];
  return createDict();
};
function createGetKeys(names, length){
  return function(object){
    var O      = toObject(object)
      , i      = 0
      , result = []
      , key;
    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(length > i)if(has(O, key = names[i++])){
      ~$indexOf(result, key) || result.push(key);
    }
    return result;
  };
}
function Empty(){}
$def($def.S, 'Object', {
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  getPrototypeOf: $.getProto = $.getProto || function(O){
    O = Object(assert.def(O));
    if(has(O, IE_PROTO))return O[IE_PROTO];
    if(isFunction(O.constructor) && O instanceof O.constructor){
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  },
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  create: $.create = $.create || function(O, /*?*/Properties){
    var result;
    if(O !== null){
      Empty.prototype = assertObject(O);
      result = new Empty();
      Empty.prototype = null;
      // add "__proto__" for Object.getPrototypeOf shim
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : defineProperties(result, Properties);
  },
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false),
  // 19.1.2.17 / 15.2.3.8 Object.seal(O)
  seal: function seal(it){
    return it; // <- cap
  },
  // 19.1.2.5 / 15.2.3.9 Object.freeze(O)
  freeze: function freeze(it){
    return it; // <- cap
  },
  // 19.1.2.15 / 15.2.3.10 Object.preventExtensions(O)
  preventExtensions: function preventExtensions(it){
    return it; // <- cap
  },
  // 19.1.2.13 / 15.2.3.11 Object.isSealed(O)
  isSealed: function isSealed(it){
    return !isObject(it); // <- cap
  },
  // 19.1.2.12 / 15.2.3.12 Object.isFrozen(O)
  isFrozen: function isFrozen(it){
    return !isObject(it); // <- cap
  },
  // 19.1.2.11 / 15.2.3.13 Object.isExtensible(O)
  isExtensible: function isExtensible(it){
    return isObject(it); // <- cap
  }
});

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
$def($def.P, 'Function', {
  bind: function(that /*, args... */){
    var fn       = assert.fn(this)
      , partArgs = _slice.call(arguments, 1);
    function bound(/* args... */){
      var args   = partArgs.concat(_slice.call(arguments))
        , constr = this instanceof bound
        , ctx    = constr ? $.create(fn.prototype) : that
        , result = invoke(fn, args, ctx);
      return constr ? ctx : result;
    }
    if(fn.prototype)bound.prototype = fn.prototype;
    return bound;
  }
});

// Fix for not array-like ES3 string and DOM objects
if(!(0 in Object('z') && 'z'[0] == 'z')){
  $.ES5Object = function(it){
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
}

var buggySlice = true;
try {
  if(html)_slice.call(html);
  buggySlice = false;
} catch(e){ /* empty */ }

$def($def.P + $def.F * buggySlice, 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return _slice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

$def($def.P + $def.F * ($.ES5Object != Object), 'Array', {
  join: function join(){
    return _join.apply($.ES5Object(this), arguments);
  }
});

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
$def($def.S, 'Array', {
  isArray: function(arg){
    return cof(arg) == 'Array';
  }
});
function createArrayReduce(isRight){
  return function(callbackfn, memo){
    assert.fn(callbackfn);
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = isRight ? length - 1 : 0
      , i      = isRight ? -1 : 1;
    if(arguments.length < 2)for(;;){
      if(index in O){
        memo = O[index];
        index += i;
        break;
      }
      index += i;
      assert(isRight ? index >= 0 : length > index, 'Reduce of empty array with no initial value');
    }
    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
      memo = callbackfn(memo, O[index], index, this);
    }
    return memo;
  };
}
$def($def.P, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: $.each = $.each || function forEach(callbackfn/*, that = undefined */){
    return $forEach(this, callbackfn, arguments[1]);
  },
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn/*, that = undefined */){
    return $map(this, callbackfn, arguments[1]);
  },
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn/*, that = undefined */){
    return $filter(this, callbackfn, arguments[1]);
  },
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn/*, that = undefined */){
    return $some(this, callbackfn, arguments[1]);
  },
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn/*, that = undefined */){
    return $every(this, callbackfn, arguments[1]);
  },
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: createArrayReduce(false),
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: createArrayReduce(true),
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(el /*, fromIndex = 0 */){
    return $indexOf(this, el, arguments[1]);
  },
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, $.toInteger(fromIndex));
    if(index < 0)index = toLength(length + index);
    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
    return -1;
  }
});

// 21.1.3.25 / 15.5.4.20 String.prototype.trim()
$def($def.P, 'String', {trim: require('./$.replacer')(/^\s*([\s\S]*\S)?\s*$/, '$1')});

// 20.3.3.1 / 15.9.4.4 Date.now()
$def($def.S, 'Date', {now: function(){
  return +new Date;
}});

function lz(num){
  return num > 9 ? num : '0' + num;
}

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
// PhantomJS and old webkit had a broken Date implementation.
var date       = new Date(-5e13 - 1)
  , brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z'
      && require('./$.throws')(function(){ new Date(NaN).toISOString(); }));
$def($def.P + $def.F * brokenDate, 'Date', {toISOString: function(){
  if(!isFinite(this))throw RangeError('Invalid time value');
  var d = this
    , y = d.getUTCFullYear()
    , m = d.getUTCMilliseconds()
    , s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
}});

if(classof(function(){ return arguments; }()) == 'Object')cof.classof = function(it){
  var tag = classof(it);
  return tag == 'Object' && isFunction(it.callee) ? 'Arguments' : tag;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es5.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.array-includes":2,"./$.array-methods":3,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.dom-create":13,"./$.invoke":18,"./$.replacer":29,"./$.throws":38,"./$.uid":39,"_process":99,"buffer":94}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
  copyWithin: function copyWithin(target/* = 0 */, start /* = 0, end = @length */){
    var O     = Object($.assertDefined(this))
      , len   = $.toLength(O.length)
      , to    = toIndex(target, len)
      , from  = toIndex(start, len)
      , end   = arguments[2]
      , fin   = end === undefined ? len : toIndex(end, len)
      , count = Math.min(fin - from, len - to)
      , inc   = 1;
    if(from < to && to < from + count){
      inc  = -1;
      from = from + count - 1;
      to   = to   + count - 1;
    }
    while(count-- > 0){
      if(from in O)O[to] = O[from];
      else delete O[to];
      to   += inc;
      from += inc;
    } return O;
  }
});
require('./$.unscope')('copyWithin');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.copy-within.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
  fill: function fill(value /*, start = 0, end = @length */){
    var O      = Object($.assertDefined(this))
      , length = $.toLength(O.length)
      , index  = toIndex(arguments[1], length)
      , end    = arguments[2]
      , endPos = end === undefined ? length : toIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
  }
});
require('./$.unscope')('fill');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.fill.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var KEY    = 'findIndex'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(6);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.find-index.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-methods":3,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var KEY    = 'find'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(5);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.find.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-methods":3,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $     = require('./$')
  , ctx   = require('./$.ctx')
  , $def  = require('./$.def')
  , $iter = require('./$.iter')
  , call  = require('./$.iter-call');
$def($def.S + $def.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = Object($.assertDefined(arrayLike))
      , mapfn   = arguments[1]
      , mapping = mapfn !== undefined
      , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
      , index   = 0
      , length, result, step, iterator;
    if($iter.is(O)){
      iterator = $iter.get(O);
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result   = new (typeof this == 'function' ? this : Array);
      for(; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, f, [step.value, index], true) : step.value;
      }
    } else {
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result = new (typeof this == 'function' ? this : Array)(length = $.toLength(O.length));
      for(; length > index; index++){
        result[index] = mapping ? f(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.from.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.ctx":11,"./$.def":12,"./$.iter":22,"./$.iter-call":19,"./$.iter-detect":21,"_process":99,"buffer":94}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $          = require('./$')
  , setUnscope = require('./$.unscope')
  , ITER       = require('./$.uid').safe('iter')
  , $iter      = require('./$.iter')
  , step       = $iter.step
  , Iterators  = $iter.Iterators;

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , kind  = iter.k
    , index = iter.i++;
  if(!O || index >= O.length){
    iter.o = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

setUnscope('keys');
setUnscope('values');
setUnscope('entries');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.iterator.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.iter":22,"./$.iter-define":20,"./$.uid":39,"./$.unscope":40,"_process":99,"buffer":94}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def = require('./$.def');
$def($def.S, 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , length = arguments.length
      // strange IE quirks mode bug -> use typeof instead of isFunction
      , result = new (typeof this == 'function' ? this : Array)(length);
    while(length > index)result[index] = arguments[index++];
    result.length = length;
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"_process":99,"buffer":94}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./$.species')(Array);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.species.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.species":33,"_process":99,"buffer":94}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $             = require('./$')
  , HAS_INSTANCE  = require('./$.wks')('hasInstance')
  , FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(!$.isFunction(this) || !$.isObject(O))return false;
  if(!$.isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = $.getProto(O))if(this.prototype === O)return true;
  return false;
}});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.function.has-instance.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.wks":41,"_process":99,"buffer":94}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , NAME = 'name'
  , setDesc = $.setDesc
  , FunctionProto = Function.prototype;
// 19.2.4.2 name
NAME in FunctionProto || $.FW && $.DESC && setDesc(FunctionProto, NAME, {
  configurable: true,
  get: function(){
    var match = String(this).match(/^\s*function ([^ (]*)/)
      , name  = match ? match[1] : '';
    $.has(this, NAME) || setDesc(this, NAME, $.desc(5, name));
    return name;
  },
  set: function(value){
    $.has(this, NAME) || setDesc(this, NAME, $.desc(0, value));
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.function.name.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments[0]); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.map.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-strong":7,"_process":99,"buffer":94}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Infinity = 1 / 0
  , $def  = require('./$.def')
  , E     = Math.E
  , pow   = Math.pow
  , abs   = Math.abs
  , exp   = Math.exp
  , log   = Math.log
  , sqrt  = Math.sqrt
  , ceil  = Math.ceil
  , floor = Math.floor
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);
function roundTiesToEven(n){
  return n + 1 / EPSILON - 1 / EPSILON;
}

// 20.2.2.28 Math.sign(x)
function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
}
// 20.2.2.5 Math.asinh(x)
function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}
// 20.2.2.14 Math.expm1(x)
function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
}

$def($def.S, 'Math', {
  // 20.2.2.3 Math.acosh(x)
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
  },
  // 20.2.2.5 Math.asinh(x)
  asinh: asinh,
  // 20.2.2.7 Math.atanh(x)
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
  },
  // 20.2.2.9 Math.cbrt(x)
  cbrt: function cbrt(x){
    return sign(x = +x) * pow(abs(x), 1 / 3);
  },
  // 20.2.2.11 Math.clz32(x)
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * Math.LOG2E) : 32;
  },
  // 20.2.2.12 Math.cosh(x)
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  },
  // 20.2.2.14 Math.expm1(x)
  expm1: expm1,
  // 20.2.2.16 Math.fround(x)
  fround: function fround(x){
    var $abs  = abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  },
  // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , len  = arguments.length
      , larg = 0
      , arg, div;
    while(i < len){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  },
  // 20.2.2.18 Math.imul(x, y)
  imul: function imul(x, y){
    var UInt16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UInt16 & xn
      , yl = UInt16 & yn;
    return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
  },
  // 20.2.2.20 Math.log1p(x)
  log1p: function log1p(x){
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
  },
  // 20.2.2.21 Math.log10(x)
  log10: function log10(x){
    return log(x) / Math.LN10;
  },
  // 20.2.2.22 Math.log2(x)
  log2: function log2(x){
    return log(x) / Math.LN2;
  },
  // 20.2.2.28 Math.sign(x)
  sign: sign,
  // 20.2.2.30 Math.sinh(x)
  sinh: function sinh(x){
    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
  },
  // 20.2.2.33 Math.tanh(x)
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  },
  // 20.2.2.34 Math.trunc(x)
  trunc: function trunc(it){
    return (it > 0 ? floor : ceil)(it);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.math.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"_process":99,"buffer":94}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $          = require('./$')
  , isObject   = $.isObject
  , isFunction = $.isFunction
  , NUMBER     = 'Number'
  , $Number    = $.g[NUMBER]
  , Base       = $Number
  , proto      = $Number.prototype;
function toPrimitive(it){
  var fn, val;
  if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
  if(isFunction(fn = it.toString) && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to number");
}
function toNumber(it){
  if(isObject(it))it = toPrimitive(it);
  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
    var binary = false;
    switch(it.charCodeAt(1)){
      case 66 : case 98  : binary = true;
      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
    }
  } return +it;
}
if($.FW && !($Number('0o1') && $Number('0b1'))){
  $Number = function Number(it){
    return this instanceof $Number ? new Base(toNumber(it)) : toNumber(it);
  };
  $.each.call($.DESC ? $.getNames(Base) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES6 (in case, if modules with ES6 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
    ).split(','), function(key){
      if($.has(Base, key) && !$.has($Number, key)){
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    }
  );
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./$.redef')($.g, NUMBER, $Number);
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.number.constructor.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.redef":28,"_process":99,"buffer":94}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $     = require('./$')
  , $def  = require('./$.def')
  , abs   = Math.abs
  , floor = Math.floor
  , _isFinite = $.g.isFinite
  , MAX_SAFE_INTEGER = 0x1fffffffffffff; // pow(2, 53) - 1 == 9007199254740991;
function isInteger(it){
  return !$.isObject(it) && _isFinite(it) && floor(it) === it;
}
$def($def.S, 'Number', {
  // 20.1.2.1 Number.EPSILON
  EPSILON: Math.pow(2, -52),
  // 20.1.2.2 Number.isFinite(number)
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  },
  // 20.1.2.3 Number.isInteger(number)
  isInteger: isInteger,
  // 20.1.2.4 Number.isNaN(number)
  isNaN: function isNaN(number){
    return number != number;
  },
  // 20.1.2.5 Number.isSafeInteger(number)
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
  },
  // 20.1.2.6 Number.MAX_SAFE_INTEGER
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
  // 20.1.2.10 Number.MIN_SAFE_INTEGER
  MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
  // 20.1.2.12 Number.parseFloat(string)
  parseFloat: parseFloat,
  // 20.1.2.13 Number.parseInt(string, radix)
  parseInt: parseInt
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.number.statics.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"_process":99,"buffer":94}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');
$def($def.S, 'Object', {assign: require('./$.assign')});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.assign.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assign":5,"./$.def":12,"_process":99,"buffer":94}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.10 Object.is(value1, value2)
var $def = require('./$.def');
$def($def.S, 'Object', {
  is: require('./$.same')
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.is.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.same":30,"_process":99,"buffer":94}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $def = require('./$.def');
$def($def.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.set-prototype-of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.set-proto":31,"_process":99,"buffer":94}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , $def     = require('./$.def')
  , isObject = $.isObject
  , toObject = $.toObject;
$.each.call(('freeze,seal,preventExtensions,isFrozen,isSealed,isExtensible,' +
  'getOwnPropertyDescriptor,getPrototypeOf,keys,getOwnPropertyNames').split(',')
, function(KEY, ID){
  var fn     = ($.core.Object || {})[KEY] || Object[KEY]
    , forced = 0
    , method = {};
  method[KEY] = ID == 0 ? function freeze(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 1 ? function seal(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 2 ? function preventExtensions(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 3 ? function isFrozen(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 4 ? function isSealed(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 5 ? function isExtensible(it){
    return isObject(it) ? fn(it) : false;
  } : ID == 6 ? function getOwnPropertyDescriptor(it, key){
    return fn(toObject(it), key);
  } : ID == 7 ? function getPrototypeOf(it){
    return fn(Object($.assertDefined(it)));
  } : ID == 8 ? function keys(it){
    return fn(toObject(it));
  } : require('./$.get-names').get;
  try {
    fn('z');
  } catch(e){
    forced = 1;
  }
  $def($def.S + $def.F * forced, 'Object', method);
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.statics-accept-primitives.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.get-names":17,"_process":99,"buffer":94}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , tmp = {};
tmp[require('./$.wks')('toStringTag')] = 'z';
if(require('./$').FW && cof(tmp) != 'z'){
  require('./$.redef')(Object.prototype, 'toString', function toString(){
    return '[object ' + cof.classof(this) + ']';
  }, true);
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.to-string.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.redef":28,"./$.wks":41,"_process":99,"buffer":94}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , cof      = require('./$.cof')
  , $def     = require('./$.def')
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , setProto = require('./$.set-proto').set
  , same     = require('./$.same')
  , species  = require('./$.species')
  , SPECIES  = require('./$.wks')('species')
  , RECORD   = require('./$.uid').safe('record')
  , PROMISE  = 'Promise'
  , global   = $.g
  , process  = global.process
  , asap     = process && process.nextTick || require('./$.task').set
  , P        = global[PROMISE]
  , isFunction     = $.isFunction
  , isObject       = $.isObject
  , assertFunction = assert.fn
  , assertObject   = assert.obj
  , Wrapper;

function testResolve(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
}

var useNative = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = isFunction(P) && isFunction(P.resolve) && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
function isPromise(it){
  return isObject(it) && (useNative ? cof.classof(it) == 'Promise' : RECORD in it);
}
function sameConstructor(a, b){
  // library wrapper special case
  if(!$.FW && a === P && b === Wrapper)return true;
  return same(a, b);
}
function getConstructor(C){
  var S = assertObject(C)[SPECIES];
  return S != undefined ? S : C;
}
function isThenable(it){
  var then;
  if(isObject(it))then = it.then;
  return isFunction(then) ? then : false;
}
function notify(record){
  var chain = record.c;
  if(chain.length)asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    function run(react){
      var cb = ok ? react.ok : react.fail
        , ret, then;
      try {
        if(cb){
          if(!ok)record.h = true;
          ret = cb === true ? value : cb(value);
          if(ret === react.P){
            react.rej(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(ret)){
            then.call(ret, react.res, react.rej);
          } else react.res(ret);
        } else react.rej(value);
      } catch(err){
        react.rej(err);
      }
    }
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
  });
}
function isUnhandled(promise){
  var record = promise[RECORD]
    , chain  = record.a || record.c
    , i      = 0
    , react;
  if(record.h)return false;
  while(chain.length > i){
    react = chain[i++];
    if(react.fail || !isUnhandled(react.P))return false;
  } return true;
}
function $reject(value){
  var record = this
    , promise;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  setTimeout(function(){
    asap(function(){
      if(isUnhandled(promise = record.p)){
        if(cof(process) == 'process'){
          process.emit('unhandledRejection', value, promise);
        } else if(global.console && isFunction(console.error)){
          console.error('Unhandled promise rejection', value);
        }
      }
      record.a = undefined;
    });
  }, 1);
  notify(record);
}
function $resolve(value){
  var record = this
    , then, wrapper;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(then = isThenable(value)){
      wrapper = {r: record, d: false}; // wrap
      then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
    } else {
      record.v = value;
      record.s = 1;
      notify(record);
    }
  } catch(err){
    $reject.call(wrapper || {r: record, d: false}, err); // wrap
  }
}

// constructor polyfill
if(!useNative){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    assertFunction(executor);
    var record = {
      p: assert.inst(this, P, PROMISE),       // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false                                // <- handled rejection
    };
    $.hide(this, RECORD, record);
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.mix')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var S = assertObject(assertObject(this).constructor)[SPECIES];
      var react = {
        ok:   isFunction(onFulfilled) ? onFulfilled : true,
        fail: isFunction(onRejected)  ? onRejected  : false
      };
      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
        react.res = assertFunction(res);
        react.rej = assertFunction(rej);
      });
      var record = this[RECORD];
      record.c.push(react);
      if(record.a)record.a.push(react);
      if(record.s)notify(record);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

// export
$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
cof.set(P, PROMISE);
species(P);
species(Wrapper = $.core[PROMISE]);

// statics
$def($def.S + $def.F * !useNative, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    return new (getConstructor(this))(function(res, rej){ rej(r); });
  }
});
$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    return isPromise(x) && sameConstructor(x.constructor, this)
      ? x : new this(function(res){ res(x); });
  }
});
$def($def.S + $def.F * !(useNative && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C      = getConstructor(this)
      , values = [];
    return new C(function(res, rej){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        C.resolve(promise).then(function(value){
          results[index] = value;
          --remaining || res(results);
        }, rej);
      });
      else res(results);
    });
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C = getConstructor(this);
    return new C(function(res, rej){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(res, rej);
      });
    });
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.promise.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.ctx":11,"./$.def":12,"./$.for-of":15,"./$.iter-detect":21,"./$.mix":25,"./$.same":30,"./$.set-proto":31,"./$.species":33,"./$.task":37,"./$.uid":39,"./$.wks":41,"_process":99,"buffer":94}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $         = require('./$')
  , $def      = require('./$.def')
  , setProto  = require('./$.set-proto')
  , $iter     = require('./$.iter')
  , ITERATOR  = require('./$.wks')('iterator')
  , ITER      = require('./$.uid').safe('iter')
  , step      = $iter.step
  , assert    = require('./$.assert')
  , isObject  = $.isObject
  , getProto  = $.getProto
  , $Reflect  = $.g.Reflect
  , _apply    = Function.apply
  , assertObject = assert.obj
  , _isExtensible = Object.isExtensible || isObject
  , _preventExtensions = Object.preventExtensions
  // IE TP has broken Reflect.enumerate
  , buggyEnumerate = !($Reflect && $Reflect.enumerate && ITERATOR in $Reflect.enumerate({}));

function Enumerate(iterated){
  $.set(this, ITER, {o: iterated, k: undefined, i: 0});
}
$iter.create(Enumerate, 'Object', function(){
  var iter = this[ITER]
    , keys = iter.k
    , key;
  if(keys == undefined){
    iter.k = keys = [];
    for(key in iter.o)keys.push(key);
  }
  do {
    if(iter.i >= keys.length)return step(1);
  } while(!((key = keys[iter.i++]) in iter.o));
  return step(0, key);
});

var reflect = {
  // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
  apply: function apply(target, thisArgument, argumentsList){
    return _apply.call(target, thisArgument, argumentsList);
  },
  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
  construct: function construct(target, argumentsList /*, newTarget*/){
    var proto    = assert.fn(arguments.length < 3 ? target : arguments[2]).prototype
      , instance = $.create(isObject(proto) ? proto : Object.prototype)
      , result   = _apply.call(target, instance, argumentsList);
    return isObject(result) ? result : instance;
  },
  // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
  defineProperty: function defineProperty(target, propertyKey, attributes){
    assertObject(target);
    try {
      $.setDesc(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.4 Reflect.deleteProperty(target, propertyKey)
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = $.getDesc(assertObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  },
  // 26.1.6 Reflect.get(target, propertyKey [, receiver])
  get: function get(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = $.getDesc(assertObject(target), propertyKey), proto;
    if(desc)return $.has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getProto(target))
      ? get(proto, propertyKey, receiver)
      : undefined;
  },
  // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return $.getDesc(assertObject(target), propertyKey);
  },
  // 26.1.8 Reflect.getPrototypeOf(target)
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(assertObject(target));
  },
  // 26.1.9 Reflect.has(target, propertyKey)
  has: function has(target, propertyKey){
    return propertyKey in target;
  },
  // 26.1.10 Reflect.isExtensible(target)
  isExtensible: function isExtensible(target){
    return _isExtensible(assertObject(target));
  },
  // 26.1.11 Reflect.ownKeys(target)
  ownKeys: require('./$.own-keys'),
  // 26.1.12 Reflect.preventExtensions(target)
  preventExtensions: function preventExtensions(target){
    assertObject(target);
    try {
      if(_preventExtensions)_preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
  set: function set(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = $.getDesc(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getProto(target))){
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = $.desc(0);
    }
    if($.has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || $.desc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
};
// 26.1.14 Reflect.setPrototypeOf(target, proto)
if(setProto)reflect.setPrototypeOf = function setPrototypeOf(target, proto){
  setProto.check(target, proto);
  try {
    setProto.set(target, proto);
    return true;
  } catch(e){
    return false;
  }
};

$def($def.G, {Reflect: {}});

$def($def.S + $def.F * buggyEnumerate, 'Reflect', {
  // 26.1.5 Reflect.enumerate(target)
  enumerate: function enumerate(target){
    return new Enumerate(assertObject(target));
  }
});

$def($def.S, 'Reflect', reflect);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.reflect.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.def":12,"./$.iter":22,"./$.own-keys":26,"./$.set-proto":31,"./$.uid":39,"./$.wks":41,"_process":99,"buffer":94}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $       = require('./$')
  , cof     = require('./$.cof')
  , $RegExp = $.g.RegExp
  , Base    = $RegExp
  , proto   = $RegExp.prototype
  , re      = /a/g
  // "new" creates a new object
  , CORRECT_NEW = new $RegExp(re) !== re
  // RegExp allows a regex with flags as the pattern
  , ALLOWS_RE_WITH_FLAGS = function(){
    try {
      return $RegExp(re, 'i') == '/a/i';
    } catch(e){ /* empty */ }
  }();
if($.FW && $.DESC){
  if(!CORRECT_NEW || !ALLOWS_RE_WITH_FLAGS){
    $RegExp = function RegExp(pattern, flags){
      var patternIsRegExp  = cof(pattern) == 'RegExp'
        , flagsIsUndefined = flags === undefined;
      if(!(this instanceof $RegExp) && patternIsRegExp && flagsIsUndefined)return pattern;
      return CORRECT_NEW
        ? new Base(patternIsRegExp && !flagsIsUndefined ? pattern.source : pattern, flags)
        : new Base(patternIsRegExp ? pattern.source : pattern
          , patternIsRegExp && flagsIsUndefined ? pattern.flags : flags);
    };
    $.each.call($.getNames(Base), function(key){
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function(){ return Base[key]; },
        set: function(it){ Base[key] = it; }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    require('./$.redef')($.g, 'RegExp', $RegExp);
  }
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')$.setDesc(proto, 'flags', {
    configurable: true,
    get: require('./$.replacer')(/^.*\/(\w*)$/, '$1')
  });
}
require('./$.species')($RegExp);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.regexp.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.redef":28,"./$.replacer":29,"./$.species":33,"_process":99,"buffer":94}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments[0]); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.set.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-strong":7,"_process":99,"buffer":94}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(false);
$def($def.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.code-point-at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-at":34,"_process":99,"buffer":94}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def')
  , toLength = $.toLength;

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.endsWith(/./); }), 'String', {
  // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that = String($.assertDefined(this))
      , endPosition = arguments[1]
      , len = toLength(that.length)
      , end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    searchString += '';
    return that.slice(end - searchString.length, end) === searchString;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.ends-with.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.def":12,"./$.throws":38,"_process":99,"buffer":94}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def    = require('./$.def')
  , toIndex = require('./$').toIndex
  , fromCharCode = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res = []
      , len = arguments.length
      , i   = 0
      , code;
    while(len > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.from-code-point.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"_process":99,"buffer":94}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.7 String.prototype.includes(searchString, position = 0)
  includes: function includes(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    return !!~String($.assertDefined(this)).indexOf(searchString, arguments[1]);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.def":12,"_process":99,"buffer":94}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var set   = require('./$').set
  , $at   = require('./$.string-at')(true)
  , ITER  = require('./$.uid').safe('iter')
  , $iter = require('./$.iter')
  , step  = $iter.step;

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  set(this, ITER, {o: String(iterated), i: 0});
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , index = iter.i
    , point;
  if(index >= O.length)return step(1);
  point = $at(O, index);
  iter.i += point.length;
  return step(0, point);
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.iterator.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.iter":22,"./$.iter-define":20,"./$.string-at":34,"./$.uid":39,"_process":99,"buffer":94}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $    = require('./$')
  , $def = require('./$.def');

$def($def.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl = $.toObject(callSite.raw)
      , len = $.toLength(tpl.length)
      , sln = arguments.length
      , res = []
      , i   = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < sln)res.push(String(arguments[i]));
    } return res.join('');
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.raw.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"_process":99,"buffer":94}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./$.string-repeat')
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.repeat.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-repeat":36,"_process":99,"buffer":94}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.startsWith(/./); }), 'String', {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
  startsWith: function startsWith(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that  = String($.assertDefined(this))
      , index = $.toLength(Math.min(arguments[1], that.length));
    searchString += '';
    return that.slice(index, index + searchString.length) === searchString;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.starts-with.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.def":12,"./$.throws":38,"_process":99,"buffer":94}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// ECMAScript 6 symbols shim
var $        = require('./$')
  , setTag   = require('./$.cof').set
  , uid      = require('./$.uid')
  , shared   = require('./$.shared')
  , $def     = require('./$.def')
  , $redef   = require('./$.redef')
  , keyOf    = require('./$.keyof')
  , enumKeys = require('./$.enum-keys')
  , assertObject = require('./$.assert').obj
  , ObjectProto = Object.prototype
  , DESC     = $.DESC
  , has      = $.has
  , $create  = $.create
  , getDesc  = $.getDesc
  , setDesc  = $.setDesc
  , desc     = $.desc
  , $names   = require('./$.get-names')
  , getNames = $names.get
  , toObject = $.toObject
  , $Symbol  = $.g.Symbol
  , setter   = false
  , TAG      = uid('tag')
  , HIDDEN   = uid('hidden')
  , _propertyIsEnumerable = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols = shared('symbols')
  , useNative = $.isFunction($Symbol);

var setSymbolDesc = DESC ? function(){ // fallback for old Android
  try {
    return $create(setDesc({}, HIDDEN, {
      get: function(){
        return setDesc(this, HIDDEN, {value: false})[HIDDEN];
      }
    }))[HIDDEN] || setDesc;
  } catch(e){
    return function(it, key, D){
      var protoDesc = getDesc(ObjectProto, key);
      if(protoDesc)delete ObjectProto[key];
      setDesc(it, key, D);
      if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
    };
  }
}() : setDesc;

function wrap(tag){
  var sym = AllSymbols[tag] = $.set($create($Symbol.prototype), TAG, tag);
  DESC && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, desc(1, value));
    }
  });
  return sym;
}

function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, desc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = $create(D, {enumerable: desc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
}
function defineProperties(it, P){
  assertObject(it);
  var keys = enumKeys(P = toObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)defineProperty(it, key = keys[i++], P[key]);
  return it;
}
function create(it, P){
  return P === undefined ? $create(it) : defineProperties($create(it), P);
}
function propertyIsEnumerable(key){
  var E = _propertyIsEnumerable.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
}
function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
}
function getOwnPropertyNames(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
}
function getOwnPropertySymbols(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
}

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments[0]));
  };
  $redef($Symbol.prototype, 'toString', function(){
    return this[TAG];
  });

  $.create     = create;
  $.setDesc    = defineProperty;
  $.getDesc    = getOwnPropertyDescriptor;
  $.setDescs   = defineProperties;
  $.getNames   = $names.get = getOwnPropertyNames;
  $.getSymbols = getOwnPropertySymbols;

  if($.DESC && $.FW)$redef(ObjectProto, 'propertyIsEnumerable', propertyIsEnumerable, true);
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
    'species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), function(it){
    var sym = require('./$.wks')(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  }
);

setter = true;

$def($def.G + $def.W, {Symbol: $Symbol});

$def($def.S, 'Symbol', symbolStatics);

$def($def.S + $def.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: getOwnPropertySymbols
});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setTag($.g.JSON, 'JSON', true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.symbol.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.enum-keys":14,"./$.get-names":17,"./$.keyof":24,"./$.redef":28,"./$.shared":32,"./$.uid":39,"./$.wks":41,"_process":99,"buffer":94}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $         = require('./$')
  , weak      = require('./$.collection-weak')
  , leakStore = weak.leakStore
  , ID        = weak.ID
  , WEAK      = weak.WEAK
  , has       = $.has
  , isObject  = $.isObject
  , isExtensible = Object.isExtensible || isObject
  , tmp       = {};

// 23.3 WeakMap Objects
var $WeakMap = require('./$.collection')('WeakMap', function(get){
  return function WeakMap(){ return get(this, arguments[0]); };
}, {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      if(!isExtensible(key))return leakStore(this).get(key);
      if(has(key, WEAK))return key[WEAK][this[ID]];
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
}, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  $.each.call(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    require('./$.redef')(proto, key, function(a, b){
      // store frozen objects on leaky map
      if(isObject(a) && !isExtensible(a)){
        var result = leakStore(this)[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.weak-map.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.collection":10,"./$.collection-weak":9,"./$.redef":28,"_process":99,"buffer":94}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var weak = require('./$.collection-weak');

// 23.4 WeakSet Objects
require('./$.collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments[0]); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.weak-set.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-weak":9,"_process":99,"buffer":94}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def      = require('./$.def')
  , $includes = require('./$.array-includes')(true);
$def($def.P, 'Array', {
  // https://github.com/domenic/Array.prototype.includes
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments[1]);
  }
});
require('./$.unscope')('includes');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.array.includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-includes":2,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Map');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.map.to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection-to-json":8,"_process":99,"buffer":94}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://gist.github.com/WebReflection/9353781
var $       = require('./$')
  , $def    = require('./$.def')
  , ownKeys = require('./$.own-keys');

$def($def.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O      = $.toObject(object)
      , result = {};
    $.each.call(ownKeys(O), function(key){
      $.setDesc(result, key, $.desc(0, $.getDesc(O, key)));
    });
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.own-keys":26,"_process":99,"buffer":94}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://goo.gl/XkBrjD
var $    = require('./$')
  , $def = require('./$.def');
function createObjectToArray(isEntries){
  return function(object){
    var O      = $.toObject(object)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = Array(length)
      , key;
    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
    else while(length > i)result[i] = O[keys[i++]];
    return result;
  };
}
$def($def.S, 'Object', {
  values:  createObjectToArray(false),
  entries: createObjectToArray(true)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.object.to-array.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"_process":99,"buffer":94}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://gist.github.com/kangax/9698100
var $def = require('./$.def');
$def($def.S, 'RegExp', {
  escape: require('./$.replacer')(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.regexp.escape.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.replacer":29,"_process":99,"buffer":94}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Set');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.set.to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection-to-json":8,"_process":99,"buffer":94}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/mathiasbynens/String.prototype.at
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(true);
$def($def.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-at":34,"_process":99,"buffer":94}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  lpad: function lpad(n){
    return $pad(this, n, arguments[1], true);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.lpad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-pad":35,"_process":99,"buffer":94}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  rpad: function rpad(n){
    return $pad(this, n, arguments[1], false);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.rpad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-pad":35,"_process":99,"buffer":94}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// JavaScript 1.6 / Strawman array statics shim
var $       = require('./$')
  , $def    = require('./$.def')
  , $Array  = $.core.Array || Array
  , statics = {};
function setStatics(keys, length){
  $.each.call(keys.split(','), function(key){
    if(length == undefined && key in $Array)statics[key] = $Array[key];
    else if(key in [])statics[key] = require('./$.ctx')(Function.call, [][key], length);
  });
}
setStatics('pop,reverse,shift,keys,values,entries', 1);
setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
           'reduce,reduceRight,copyWithin,fill,turn');
$def($def.S, 'Array', statics);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/js.array.statics.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.ctx":11,"./$.def":12,"_process":99,"buffer":94}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./es6.array.iterator');
var $           = require('./$')
  , Iterators   = require('./$.iter').Iterators
  , ITERATOR    = require('./$.wks')('iterator')
  , ArrayValues = Iterators.Array
  , NL          = $.g.NodeList
  , HTC         = $.g.HTMLCollection
  , NLProto     = NL && NL.prototype
  , HTCProto    = HTC && HTC.prototype;
if($.FW){
  if(NL && !(ITERATOR in NLProto))$.hide(NLProto, ITERATOR, ArrayValues);
  if(HTC && !(ITERATOR in HTCProto))$.hide(HTCProto, ITERATOR, ArrayValues);
}
Iterators.NodeList = Iterators.HTMLCollection = ArrayValues;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.dom.iterable.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.iter":22,"./$.wks":41,"./es6.array.iterator":48,"_process":99,"buffer":94}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def  = require('./$.def')
  , $task = require('./$.task');
$def($def.G + $def.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.immediate.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.task":37,"_process":99,"buffer":94}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// ie9- setTimeout & setInterval additional parameters fix
var $         = require('./$')
  , $def      = require('./$.def')
  , invoke    = require('./$.invoke')
  , partial   = require('./$.partial')
  , navigator = $.g.navigator
  , MSIE      = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
function wrap(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      $.isFunction(fn) ? fn : Function(fn)
    ), time);
  } : set;
}
$def($def.G + $def.B + $def.F * MSIE, {
  setTimeout:  wrap($.g.setTimeout),
  setInterval: wrap($.g.setInterval)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.timers.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.invoke":18,"./$.partial":27,"_process":99,"buffer":94}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./modules/es5');
require('./modules/es6.symbol');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.object.statics-accept-primitives');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.number.constructor');
require('./modules/es6.number.statics');
require('./modules/es6.math');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.iterator');
require('./modules/es6.array.species');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.regexp');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.reflect');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.lpad');
require('./modules/es7.string.rpad');
require('./modules/es7.regexp.escape');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.to-array');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/js.array.statics');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/$').core;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/shim.js","/node_modules/babel-core/node_modules/core-js")

},{"./modules/$":23,"./modules/es5":42,"./modules/es6.array.copy-within":43,"./modules/es6.array.fill":44,"./modules/es6.array.find":46,"./modules/es6.array.find-index":45,"./modules/es6.array.from":47,"./modules/es6.array.iterator":48,"./modules/es6.array.of":49,"./modules/es6.array.species":50,"./modules/es6.function.has-instance":51,"./modules/es6.function.name":52,"./modules/es6.map":53,"./modules/es6.math":54,"./modules/es6.number.constructor":55,"./modules/es6.number.statics":56,"./modules/es6.object.assign":57,"./modules/es6.object.is":58,"./modules/es6.object.set-prototype-of":59,"./modules/es6.object.statics-accept-primitives":60,"./modules/es6.object.to-string":61,"./modules/es6.promise":62,"./modules/es6.reflect":63,"./modules/es6.regexp":64,"./modules/es6.set":65,"./modules/es6.string.code-point-at":66,"./modules/es6.string.ends-with":67,"./modules/es6.string.from-code-point":68,"./modules/es6.string.includes":69,"./modules/es6.string.iterator":70,"./modules/es6.string.raw":71,"./modules/es6.string.repeat":72,"./modules/es6.string.starts-with":73,"./modules/es6.symbol":74,"./modules/es6.weak-map":75,"./modules/es6.weak-set":76,"./modules/es7.array.includes":77,"./modules/es7.map.to-json":78,"./modules/es7.object.get-own-property-descriptors":79,"./modules/es7.object.to-array":80,"./modules/es7.regexp.escape":81,"./modules/es7.set.to-json":82,"./modules/es7.string.at":83,"./modules/es7.string.lpad":84,"./modules/es7.string.rpad":85,"./modules/js.array.statics":86,"./modules/web.dom.iterable":87,"./modules/web.immediate":88,"./modules/web.timers":89,"_process":99,"buffer":94}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(
      innerFn, self || null,
      new Context(tryLocsList || [])
    );

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function(arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument
        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
        : result;
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      var enqueueResult =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(function() {
          return invoke(method, arg);
        }) : new Promise(function(resolve) {
          resolve(invoke(method, arg));
        });

      // Avoid propagating enqueueResult failures to Promises returned by
      // later invocations of the iterator, and call generator.return() to
      // allow the generator a chance to clean up.
      previousPromise = enqueueResult.catch(invokeReturn);

      return enqueueResult;
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/regenerator/runtime.js","/node_modules/babel-core/node_modules/regenerator")

},{"_process":99,"buffer":94}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = require("./lib/babel/polyfill");

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/polyfill.js","/node_modules/babel-core")

},{"./lib/babel/polyfill":1,"_process":99,"buffer":94}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = require("babel-core/polyfill");

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babelify/polyfill.js","/node_modules/babelify")

},{"_process":99,"babel-core/polyfill":92,"buffer":94}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
    return fromTypedArray(that, object)
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = String(string)

  if (string.length === 0) return 0

  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      return string.length
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return string.length * 2
    case 'hex':
      return string.length >>> 1
    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(string).length
    case 'base64':
      return base64ToBytes(string).length
    default:
      return string.length
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/index.js","/node_modules/browserify/node_modules/buffer")

},{"_process":99,"base64-js":95,"buffer":94,"ieee754":96,"is-array":97}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib")

},{"_process":99,"buffer":94}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","/node_modules/browserify/node_modules/buffer/node_modules/ieee754")

},{"_process":99,"buffer":94}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js","/node_modules/browserify/node_modules/buffer/node_modules/is-array")

},{"_process":99,"buffer":94}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/events/events.js","/node_modules/browserify/node_modules/events")

},{"_process":99,"buffer":94}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/process/browser.js","/node_modules/browserify/node_modules/process")

},{"_process":99,"buffer":94}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/punycode/punycode.js","/node_modules/browserify/node_modules/punycode")

},{"_process":99,"buffer":94}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/decode.js","/node_modules/browserify/node_modules/querystring-es3")

},{"_process":99,"buffer":94}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/encode.js","/node_modules/browserify/node_modules/querystring-es3")

},{"_process":99,"buffer":94}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/index.js","/node_modules/browserify/node_modules/querystring-es3")

},{"./decode":101,"./encode":102,"_process":99,"buffer":94}],104:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/url/url.js","/node_modules/browserify/node_modules/url")

},{"_process":99,"buffer":94,"punycode":100,"querystring":103}],105:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

The MIT License (MIT)

Original Library 
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var ansiStyles = colors.styles = require('./styles');
var defineProps = Object.defineProperties;

colors.supportsColor = require('./system/supports-colors');

if (typeof colors.enabled === "undefined") {
  colors.enabled = colors.supportsColor;
}

colors.stripColors = colors.strip = function(str){
  return ("" + str).replace(/\x1B\[\d+m/g, '');
};


var stylize = colors.stylize = function stylize (str, style) {
  if (!colors.enabled) {
    return str+'';
  }

  return ansiStyles[style].open + str + ansiStyles[style].close;
}

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe,  '\\$&');
}

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function () {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function (key) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function () {
        return build(this._styles.concat(key));
      }
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = arguments;
  var argsLen = args.length;
  var str = argsLen !== 0 && String(arguments[0]);
  if (argsLen > 1) {
    for (var a = 1; a < argsLen; a++) {
      str += ' ' + args[a];
    }
  }

  if (!colors.enabled || !str) {
    return str;
  }

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
  }

  return str;
}

function applyTheme (theme) {
  for (var style in theme) {
    (function(style){
      colors[style] = function(str){
        if (typeof theme[style] === 'object'){
          var out = str;
          for (var i in theme[style]){
            out = colors[theme[style][i]](out);
          }
          return out;
        }
        return colors[theme[style]](str);
      };
    })(style)
  }
}

colors.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      colors.themes[theme] = require(theme);
      applyTheme(colors.themes[theme]);
      return colors.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function (name) {
    ret[name] = {
      get: function () {
        return build([name]);
      }
    };
  });
  return ret;
}

var sequencer = function sequencer (map, str) {
  var exploded = str.split(""), i = 0;
  exploded = exploded.map(map);
  return exploded.join("");
};

// custom formatter methods
colors.trap = require('./custom/trap');
colors.zalgo = require('./custom/zalgo');

// maps
colors.maps = {};
colors.maps.america = require('./maps/america');
colors.maps.zebra = require('./maps/zebra');
colors.maps.rainbow = require('./maps/rainbow');
colors.maps.random = require('./maps/random')

for (var map in colors.maps) {
  (function(map){
    colors[map] = function (str) {
      return sequencer(colors.maps[map], str);
    }
  })(map)
}

defineProps(colors, init());
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/colors.js","/node_modules/colors/lib")

},{"./custom/trap":106,"./custom/zalgo":107,"./maps/america":110,"./maps/rainbow":111,"./maps/random":112,"./maps/zebra":113,"./styles":114,"./system/supports-colors":115,"_process":99,"buffer":94}],106:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module['exports'] = function runTheTrap (text, options) {
  var result = "";
  text = text || "Run the trap, drop the bass";
  text = text.split('');
  var trap = {
    a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
    b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
    c: ["\u00a9", "\u023b", "\u03fe"],
    d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
    e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
    f: ["\u04fa"],
    g: ["\u0262"],
    h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
    i: ["\u0f0f"],
    j: ["\u0134"],
    k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
    l: ["\u0139"],
    m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
    n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
    o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
    p: ["\u01f7", "\u048e"],
    q: ["\u09cd"],
    r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
    s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
    t: ["\u0141", "\u0166", "\u0373"],
    u: ["\u01b1", "\u054d"],
    v: ["\u05d8"],
    w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
    x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
    y: ["\u00a5", "\u04b0", "\u04cb"],
    z: ["\u01b5", "\u0240"]
  }
  text.forEach(function(c){
    c = c.toLowerCase();
    var chars = trap[c] || [" "];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== "undefined") {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;

}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/custom/trap.js","/node_modules/colors/lib/custom")

},{"_process":99,"buffer":94}],107:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// please no
module['exports'] = function zalgo(text, options) {
  text = text || "   he is here   ";
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }
  

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] =   typeof options["up"]   !== 'undefined' ? options["up"]   : true;
    options["mid"] =  typeof options["mid"]  !== 'undefined' ? options["mid"]  : true;
    options["down"] = typeof options["down"] !== 'undefined' ? options["down"] : true;
    options["size"] = typeof options["size"] !== 'undefined' ? options["size"] : "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.mid = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.mid = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text, options);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/custom/zalgo.js","/node_modules/colors/lib/custom")

},{"_process":99,"buffer":94}],108:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('./colors');

module['exports'] = function () {

  //
  // Extends prototype of native string object to allow for "foo".red syntax
  //
  var addProperty = function (color, func) {
    String.prototype.__defineGetter__(color, func);
  };

  var sequencer = function sequencer (map, str) {
      return function () {
        var exploded = this.split(""), i = 0;
        exploded = exploded.map(map);
        return exploded.join("");
      }
  };

  addProperty('strip', function () {
    return colors.strip(this);
  });

  addProperty('stripColors', function () {
    return colors.strip(this);
  });

  addProperty("trap", function(){
    return colors.trap(this);
  });

  addProperty("zalgo", function(){
    return colors.zalgo(this);
  });

  addProperty("zebra", function(){
    return colors.zebra(this);
  });

  addProperty("rainbow", function(){
    return colors.rainbow(this);
  });

  addProperty("random", function(){
    return colors.random(this);
  });

  addProperty("america", function(){
    return colors.america(this);
  });

  //
  // Iterate through all default styles and colors
  //
  var x = Object.keys(colors.styles);
  x.forEach(function (style) {
    addProperty(style, function () {
      return colors.stylize(this, style);
    });
  });

  function applyTheme(theme) {
    //
    // Remark: This is a list of methods that exist
    // on String that you should not overwrite.
    //
    var stringPrototypeBlacklist = [
      '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
      'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
      'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
      'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
    ];

    Object.keys(theme).forEach(function (prop) {
      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
        console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
      }
      else {
        if (typeof(theme[prop]) === 'string') {
          colors[prop] = colors[theme[prop]];
          addProperty(prop, function () {
            return colors[theme[prop]](this);
          });
        }
        else {
          addProperty(prop, function () {
            var ret = this;
            for (var t = 0; t < theme[prop].length; t++) {
              ret = exports[theme[prop][t]](ret);
            }
            return ret;
          });
        }
      }
    });
  }

  colors.setTheme = function (theme) {
    if (typeof theme === 'string') {
      try {
        colors.themes[theme] = require(theme);
        applyTheme(colors.themes[theme]);
        return colors.themes[theme];
      } catch (err) {
        console.log(err);
        return err;
      }
    } else {
      applyTheme(theme);
    }
  };

};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/extendStringPrototype.js","/node_modules/colors/lib")

},{"./colors":105,"_process":99,"buffer":94}],109:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('./colors');
module['exports'] = colors;

// Remark: By default, colors will add style properties to String.prototype
//
// If you don't wish to extend String.prototype you can do this instead and native String will not be touched
//
//   var colors = require('colors/safe);
//   colors.red("foo")
//
//
require('./extendStringPrototype')();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/index.js","/node_modules/colors/lib")

},{"./colors":105,"./extendStringPrototype":108,"_process":99,"buffer":94}],110:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function() {
  return function (letter, i, exploded) {
    if(letter === " ") return letter;
    switch(i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter)
      case 2: return colors.blue(letter)
    }
  }
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/america.js","/node_modules/colors/lib/maps")

},{"../colors":105,"_process":99,"buffer":94}],111:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
})();


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/rainbow.js","/node_modules/colors/lib/maps")

},{"../colors":105,"_process":99,"buffer":94}],112:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function () {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
  return function(letter, i, exploded) {
    return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
  };
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/random.js","/node_modules/colors/lib/maps")

},{"../colors":105,"_process":99,"buffer":94}],113:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = function (letter, i, exploded) {
  return i % 2 === 0 ? letter : colors.inverse(letter);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/zebra.js","/node_modules/colors/lib/maps")

},{"../colors":105,"_process":99,"buffer":94}],114:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49]

};

Object.keys(codes).forEach(function (key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/styles.js","/node_modules/colors/lib")

},{"_process":99,"buffer":94}],115:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var argv = process.argv;

module.exports = (function () {
  if (argv.indexOf('--no-color') !== -1 ||
    argv.indexOf('--color=false') !== -1) {
    return false;
  }

  if (argv.indexOf('--color') !== -1 ||
    argv.indexOf('--color=true') !== -1 ||
    argv.indexOf('--color=always') !== -1) {
    return true;
  }

  if (process.stdout && !process.stdout.isTTY) {
    return false;
  }

  if (process.platform === 'win32') {
    return true;
  }

  if ('COLORTERM' in process.env) {
    return true;
  }

  if (process.env.TERM === 'dumb') {
    return false;
  }

  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    return true;
  }

  return false;
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/system/supports-colors.js","/node_modules/colors/lib/system")

},{"_process":99,"buffer":94}],116:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * @license
 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
      descriptor.value = null;
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * https://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.2';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/lodash/dist/lodash.js","/node_modules/lodash/dist")

},{"_process":99,"buffer":94}],117:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
	costs: {
		delete: number | function ( char )
		insert: number | function ( char )
		replace: number | function ( what, by )
		transpose: number | function ( left, right )
	}
*/

"use strict";

function getCost(costs, op, a, b) {
	var cost = typeof costs == "object" ? costs[op] : costs;
	return typeof cost == "function" ? cost.call(costs, a, b) : cost;
}

module.exports = function (s1, s2) {
	var costs = arguments[2] === undefined ? 1 : arguments[2];

	var d = [];
	for (var i = 0; i <= s1.length; ++i) {
		d[i] = i < 3 ? [] : d[i - 3]; // some optimization
		for (var j = 0; j <= s2.length; ++j) {
			d[i][j] = i == 0 && j == 0 ? 0 : i == 0 ? d[i][j - 1] + getCost(costs, "insert", s2[j - 1]) : j == 0 ? d[i - 1][j] + getCost(costs, "delete", s1[i - 1]) : Math.min(d[i - 1][j] + getCost(costs, "delete", s1[i - 1]), d[i][j - 1] + getCost(costs, "insert", s2[j - 1]), d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : getCost(costs, "replace", s1[i - 1], s2[j - 1])), i > 1 && j > 1 && s1[i - 1] == s2[j - 2] && s1[i - 2] == s2[j - 1] ? d[i - 2][j - 2] + getCost(costs, "transpose", s1[i - 2], s1[i - 1]) : Infinity);
		}
	}
	return d[s1.length][s2.length];
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/DamerauLevenshtein.js","/src")

},{"_process":99,"buffer":94}],118:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ra = require("ra");

module.exports = function (key) {
	var defaults = arguments[1] === undefined ? null : arguments[1];

	var ret = ra.clean(defaults).setConst("reset", function () {
		localStorage.removeItem(key);
		ret.assign(defaults);
	}).setName("localStorage." + key);
	var stored = localStorage.getItem(key);
	if (stored != null) ret.assign(JSON.parse(stored));
	ra.clean(function () {
		if (ret.valueOf() != defaults) localStorage.setItem(key, JSON.stringify(ret));
	});
	return ret;
};
// ret.loaded = true

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/JSONlocal.js","/src")

},{"_process":99,"buffer":94,"ra":136}],119:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

require("colors");

var LOG = function LOG(msg) {
  for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    data[_key - 1] = arguments[_key];
  }

  return console.log.apply(console, ["" + new Date().toISOString().replace("T", "=").replace("Z", "") + " " + msg].concat(data));
};
LOG.LOG = LOG;
LOG.INFO = LOG;
LOG.TRACE = LOG;
LOG.ERROR = LOG;
LOG.WARNING = LOG;

module.exports = LOG;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/LOG.js","/src")

},{"_process":99,"buffer":94,"colors":109}],120:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var lodash = require("lodash");

var PongJSON = (function (_require) {
	function PongJSON(q) {
		var _this = this;

		_classCallCheck(this, PongJSON);

		_get(Object.getPrototypeOf(PongJSON.prototype), "constructor", this).call(this);
		this._q = q;
		this.pipeFrom(q);
		q.onmessage = function (message) {
			return _this._message(message);
		};
	}

	_inherits(PongJSON, _require);

	_createClass(PongJSON, [{
		key: "unwise",
		value: function unwise() {
			var q = this._q;
			this._q = null;
			q.onopen = null;
			q.onclose = null;
			q.onerror = null;
			q.onmessage = null;
			return q.unwise ? q.unwise() : q;
		}
	}, {
		key: "_message",
		value: function _message(message) {
			if (message.what == "ping") this._q.send({ what: "pong", pong: message.ping });else this.domessage(message);
		}
	}, {
		key: "_send",
		value: function _send(message) {
			this._q.send(message);
		}
	}, {
		key: "_close",
		value: function _close() {
			this._q.onclose = null;
			this._q.close();
		}
	}]);

	return PongJSON;
})(require("WebQueue"));

var PingPongJSON = (function (_PongJSON) {
	function PingPongJSON(q) {
		var _this2 = this;

		var _ref = arguments[1] === undefined ? {} : arguments[1];

		var _ref$interval = _ref.interval;
		var interval = _ref$interval === undefined ? 60000 : _ref$interval;
		var _ref$timeout = _ref.timeout;
		var timeout = _ref$timeout === undefined ? 15000 : _ref$timeout;
		var _ref$maxpings = _ref.maxpings;
		var maxpings = _ref$maxpings === undefined ? 1000 : _ref$maxpings;

		_classCallCheck(this, PingPongJSON);

		_get(Object.getPrototypeOf(PingPongJSON.prototype), "constructor", this).call(this, q);
		this._pings = {};
		this._count = 0;
		this._pinterval = interval == Infinity ? null : setInterval(function () {
			return _this2.ping();
		}, interval);
		this._timeout = timeout;
		this._maxpings = maxpings;
	}

	_inherits(PingPongJSON, _PongJSON);

	_createClass(PingPongJSON, [{
		key: "_message",
		value: function _message(message) {
			if (message.what == "pong") {
				if (Object.prototype.hasOwnProperty.call(this._pings, message.pong)) {
					clearTimeout(this._pings[message.pong]);
					delete this._pings[message.pong];
					--this._count;
				}
			} else _get(Object.getPrototypeOf(PingPongJSON.prototype), "_message", this).call(this, message);
		}
	}, {
		key: "_send",
		value: function _send(message) {
			_get(Object.getPrototypeOf(PingPongJSON.prototype), "_send", this).call(this, message);
			this.ping();
		}
	}, {
		key: "_close",
		value: function _close() {
			clearInterval(this._pinterval);
			this._pinterval = null;
			lodash.forEach(this._pings, function (t) {
				return clearTimeout(t);
			});
			this._pings = null;
			_get(Object.getPrototypeOf(PingPongJSON.prototype), "_close", this).call(this);
		}
	}, {
		key: "ping",
		value: function ping() {
			var _this3 = this;

			if (!this._q) return;
			if (this._count > this._maxpings) return this._ontimeout();
			var id = "" + Math.random();
			this._q.send({ what: "ping", ping: id });
			this._pings[id] = setTimeout(function () {
				console.log(id.red);
				_this3._ontimeout();
			}, this._timeout);
			++this._count;
		}
	}, {
		key: "_ontimeout",
		value: function _ontimeout() {
			try {
				this.doerror(new Error("timeout"));
			} finally {
				this.close();
			}
		}
	}]);

	return PingPongJSON;
})(PongJSON);

module.exports = function (q, options) {
	return new PingPongJSON(q, options);
};
module.exports.silent = function (q) {
	return new PongJSON(q);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/PingPongJSON.js","/src")

},{"WebQueue":121,"_process":99,"buffer":94,"lodash":116}],121:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WebQueue = (function () {
	function WebQueue() {
		_classCallCheck(this, WebQueue);

		this.onopen = null;
		this.onclose = null;
		this.onmessage = null;
		this.onerror = null;
		this._closed = false;
		this._opened = false;
	}

	_createClass(WebQueue, [{
		key: "doopen",
		value: function doopen() {
			if (!this._closed && this.onopen && !this._opened) {
				this._opened = true;
				this.onopen();
			}
		}
	}, {
		key: "doclose",
		value: function doclose() {
			if (this.onclose) this.onclose();
		}
	}, {
		key: "domessage",
		value: function domessage(message) {
			if (!this._closed && this.onmessage) {
				if (!this._opened) this.doopen();
				this.onmessage(message);
			}
		}
	}, {
		key: "doerror",
		value: function doerror(error) {
			if (this.onerror) this.onerror(error);else process.nextTick(function () {
				throw error;
			});
		}
	}, {
		key: "_send",
		value: function _send() {}
	}, {
		key: "send",
		value: function send(message) {
			if (!this._closed) this._send(message);
		}
	}, {
		key: "_close",
		value: function _close() {}
	}, {
		key: "close",
		value: function close() {
			if (this._closed) return;
			try {
				this._close();
			} finally {
				this._closed = true;
				this.doclose();
			}
		}
	}, {
		key: "pipeFrom",
		value: function pipeFrom(q) {
			var _this = this;

			q.onopen = function () {
				return _this.doopen();
			};
			q.onclose = function () {
				return _this.close();
			};
			q.onerror = function (error) {
				return _this.doerror(error);
			};
			q.onmessage = function (message) {
				return _this.domessage(message);
			};
		}
	}]);

	return WebQueue;
})();

module.exports = WebQueue;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/WebQueue.js","/src")

},{"_process":99,"buffer":94}],122:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var WebSocketToJSON = (function (_require) {
	function WebSocketToJSON(ws) {
		var _this = this;

		_classCallCheck(this, WebSocketToJSON);

		_get(Object.getPrototypeOf(WebSocketToJSON.prototype), "constructor", this).call(this);
		this._ws = ws;
		this.pipeFrom(ws);
		ws.onmessage = function (event) {
			var message = undefined;
			try {
				message = JSON.parse(String(event.data));
			} catch (error) {
				return _this.doerror(error);
			}
			_this.domessage(message);
		};
	}

	_inherits(WebSocketToJSON, _require);

	_createClass(WebSocketToJSON, [{
		key: "unwise",
		value: function unwise() {
			var ws = this._ws;
			this._ws = null;
			ws.onopen = null;
			ws.onclose = null;
			ws.onerror = null;
			ws.onmessage = null;
			return ws;
		}
	}, {
		key: "_send",
		value: function _send(message) {
			this._ws.send(JSON.stringify(message));
		}
	}, {
		key: "_close",
		value: function _close() {
			this._ws.onclose = null;
			this._ws.close();
		}
	}]);

	return WebSocketToJSON;
})(require("WebQueue"));

module.exports = function (ws) {
	return new WebSocketToJSON(ws);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/WebSocketToJSON.js","/src")

},{"WebQueue":121,"_process":99,"buffer":94}],123:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

TODO 2015.03.25 У ТЗ не было: Рэдагаваньне месцаў магчыма патрэбнае толькі лакальна з асобнымі камандамі меню "захаваць для змоўчанага" і "загрузіць на ўсе прылады".

*/
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var JSONlocal = require("JSONlocal");
var lu = require("localUtils");
var ra = require("ra");
var lodash = require("lodash");
var UID = require("uid");
var httpClient = require("httpClient");
var EventEmitter = require("events").EventEmitter || require("events");
// let deviceActions = require( `netro/deviceActions` )
var WebSocketToJSON = require("WebSocketToJSON");
var PingPongJSON = require("PingPongJSON");
var devdb = require("devdb");

var WebSocketRetry = 1000;
var savePlacesTimeout = 3000;

var PersistentWebSocket = (function (_EventEmitter) {
	function PersistentWebSocket(url) {
		_classCallCheck(this, PersistentWebSocket);

		_get(Object.getPrototypeOf(PersistentWebSocket.prototype), "constructor", this).call(this);
		this.connected = false;
		this.closed = false;
		this._ws = null;
		this._sheduledCreating = null;
		this._first = true;
		this._lastClose = -Infinity;
		this.url = url;
		this.user = undefined;
		this.key = undefined
		// window.addEventListener( `_application_resumed` )
		;
	}

	_inherits(PersistentWebSocket, _EventEmitter);

	_createClass(PersistentWebSocket, [{
		key: "_setConnected",
		value: function _setConnected(value) {
			value = !!value;
			if (this.connected != value) {
				this.connected = value;
				this.emit("changed", value);
			}
		}
	}, {
		key: "_clearHandle",
		value: function _clearHandle() {
			if (this._ws) {
				this._ws.onclose = null;
				this._ws.close();
				this._ws = null;
				this._setConnected(false);
			}
			if (this._sheduledCreating) {
				clearTimeout(this._sheduledCreating);
				this._sheduledCreating = null;
			}
		}
	}, {
		key: "_ensureHandle",
		value: function _ensureHandle() {
			if (!this._ws) this._createHandle();
		}
	}, {
		key: "_createHandle",
		value: function _createHandle() {
			var _this = this;

			this._clearHandle();
			if (!this._url) return;
			this._ws = PingPongJSON(WebSocketToJSON(new WebSocket(this._url)));
			this._ws.onclose = function () {
				_this._ws = null;
				_this._setConnected(false);
				_this.emit("pause");
				if (!_this.closed) {
					var t = _this._lastClose;
					_this._lastClose = Date.now();
					_this._sheduledCreating = setTimeout(function () {
						_this._createHandle();
					}, Math.max(0, WebSocketRetry - (_this._lastClose - t)));
				}
			};
			this._ws.onerror = function (error) {
				_this.emit("error", error);
			};
			this._ws.onopen = function () {
				_this._setConnected(true);
				if (_this._first) {
					_this._first = false;
					_this.emit("open");
				}
				_this.emit("resume");
			};
			this._ws.onmessage = function (message) {
				_this.emit("message", message);
			};
		}
	}, {
		key: "reinit",
		value: function reinit() {
			this._ws && this._ws.close();
		}
	}, {
		key: "send",
		value: function send(data) {
			this._ensureHandle();
			if (!(this._ws && this.connected && !this.closed)) throw new Error("socket is not open");
			this._ws.send(data);
		}
	}, {
		key: "delete",
		value: function _delete() {
			this.close();
		}
	}, {
		key: "close",
		value: function close() {
			this.closed = true;
			this._clearHandle();
			this.emit("close");
		}
	}, {
		key: "ask",
		value: function ask(question) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var id, message;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							id = UID();

							this.send({ id: id, question: question });
							context$3$0.next = 4;
							return this.get(id);

						case 4:
							message = context$3$0.sent;

							if (!message.error) {
								context$3$0.next = 7;
								break;
							}

							throw new Error(message.error);

						case 7:
							return context$3$0.abrupt("return", message.answer);

						case 8:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		}
	}, {
		key: "get",
		value: function get(predicate, timeout) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var _ref, event, data;

				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (typeof predicate == "string" || typeof predicate == "number") {
								(function () {
									var id = predicate;
									predicate = function (msg) {
										return msg.id == id;
									};
								})();
							} else if (!(typeof predicate == "function")) {
								(function () {
									var p = predicate;
									predicate = function (msg) {
										return lodash.every(p, function (value, key) {
											return msg[key] == value;
										});
									};
								})();
							}
							context$3$0.next = 3;
							return co.receive(this, { close: true, message: predicate, timeout: timeout });

						case 3:
							_ref = context$3$0.sent;
							event = _ref.event;
							data = _ref.data;

							if (!(event == "message")) {
								context$3$0.next = 8;
								break;
							}

							return context$3$0.abrupt("return", data);

						case 8:
							throw new Error("timeout");

						case 9:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		}
	}, {
		key: "url",
		get: function () {
			return this._url;
		},
		set: function (url) {
			this._url = url;
			this._createHandle();
		}
	}]);

	return PersistentWebSocket;
})(EventEmitter);

function wsClient(app, url) {
	var ws = new PersistentWebSocket();
	ra(function () {
		return ws.url = app.localModem && app.localModem + url;
	});
	ws.active = ra.on(ws, ["pause", "resume"], function () {
		return ws.connected;
	});
	return ws;
}

function wsJSONclient(app, url) {

	var json = JSONlocal(url, { uid: null });
	var ws = wsClient(app, url);
	var init = function init() {
		return ws.send({ what: "init", id: json.uid });
	};
	var resolvers = {};

	var doError = function doError(message, data) {
		throw new Error("wsJSONclient: " + message + ": " + JSON.stringify(data));
	};

	lu.on(ws, {
		resume: init,
		message: function message(_message) {
			switch (_message.what) {
				case "error":
					doError("error from server", _message);
				case "saved":
					{
						var resolve = resolvers[_message.messageId];
						delete resolvers[_message.messageId];
						resolve && resolve();
						return;
					}
				case "data":
					{
						if (_message.partial && _message.previous != json.uid) init();else if (Object.prototype.hasOwnProperty.call(_message, "data")) json.assign(lu.applyDiff(json.valueOf(), _message.data, _message.partial));
						return;
					}
				default:
					doError("unknown message from server", _message);
			}
		},
		error: function error() {
			app.onCredentials();
		}
	});

	function doReject(messageId, reject) {
		delete resolvers[messageId];
		reject();
	}

	var save = function save(partial, data) {
		return new Promise(function (resolve, reject) {
			var messageId = UID();
			resolvers[messageId] = resolve;
			ws.send({ what: "save", data: partial ? data : Object.assign({ __partial__: false }, data || {}), messageId: messageId });
			setTimeout(doReject, savePlacesTimeout, messageId, reject);
		});
	};

	return {
		data: json.getReadOnly(),
		active: ws.active,
		send: function send(data) {
			return save(false, data);
		},
		update: function update(data) {
			return save(true, data);
		},
		"delete": function _delete() {
			ws.close();
		}
	};
}

module.exports = function (appid) {

	var localDefaults = {
		activeDeviceId: "",
		language: "ru",
		iconSize: 40, // millimeters
		labels: true,
		placesPages: {}
	};

	var local = JSONlocal(appid, localDefaults);

	var app = ra.clean(Object.defineProperties({

		getMessage: function getMessage(data) {
			var language = local.language || "ru";
			return [language, "ru", "en", "by"].filter(function (l) {
				return Object.prototype.hasOwnProperty.call(data, l);
			}).map(function (l) {
				return data[l];
			})[0];
		},

		pageWidth: 2,
		pageHeight: 3,
		pageStarting: false,
		dialog: "",
		editing: false,
		moving: 0,
		history: [],
		menuElement: null, // div

		loggedin: false,
		// credentials: 1,
		onCredentials: function onCredentials() {
			this.loggedin = false;
		},

		go: function go(to, path) {
			var _this2 = this;

			if (!to) return;
			var h = this.history;
			var a = local.activeDeviceId;
			var l = undefined;
			while (h.length && (l = h[h.length - 1], l == to || l == a || path && path.indexOf(l) >= 0)) h.pop();
			if (a != to) h.push(a);
			path && h.push.apply(h, _toConsumableArray(path.filter(function (id) {
				return id != _this2.main;
			}).reverse()));
			local.activeDeviceId = to;
			this.dialog = "";
		},

		back: function back() {
			while (this.history.length) {
				var device = this.history.pop();
				if (this.getDevice(device)) return local.activeDeviceId = device;
			}
			local.activeDeviceId = this.main;
		},

		windowSize: require("windowSize").getReadOnly(),

		placesShifts: {},

		login: function login(name, pwd) {},

		getDevice: function getDevice(deviceId) {
			return this.devices.content && this.devices.content[lu.valueOf(deviceId)];
		},

		linkingPlaceId: null,

		setDatabase: function setDatabase(devices) {
			this.serverDevices.send(devices);
		},

		reset: function reset() {
			local.reset();
			this.setDatabase({ uid: UID() });
			this.dialog = "";
			this.editing = false;
			this.history.length = 0;
		},

		setTemplate: function setTemplate(template) {
			console.log(template);
			var devices = {
				uid: UID(),
				content: {}
			};
			function copy(template, device) {
				Object.keys(template).forEach(function (key) {
					return key != "image" && // TODO: !!!!!!!!
					key != "content" && key != "type" && (device[key] = template[key]);
				});
				return device;
			}
			function walk(template, id) {
				if (template.content || template.type == "place") {
					(function () {
						var content = {};
						devices.content[id] = copy(template, { type: "place", content: content });
						var index = 0;
						template.content && template.content.forEach(function (p) {
							return content[walk(p, UID())] = { index: index++ };
						});
					})();
				} else {
					devices.content[id] = copy(template, { type: "single" });
				}
				return id;
			}
			devices.main = walk(template, UID());
			this.setDatabase(devices);
		},

		message: function message(id) {
			var ret = this.messages && this.messages[id];
			if (ret == null) ret = id;
			return ret;
		},

		notification: function notification(message) {},

		saveDevice: function saveDevice(deviceId, device) {
			var diff = lu.makeDiff(this.getDevice(deviceId), device);
			return diff == null ? Promise.resolve() : this.serverDevices.update({ content: _defineProperty({}, deviceId, diff) });
		},

		newIndex: function newIndex(iconId) {
			return Object.keys(this.getDevice(iconId).content || {}).length + 1;
		},

		linkItem: function linkItem(iconId, itemId, extra) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var place, device, rec, packet, result;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!(iconId == itemId)) {
								context$3$0.next = 2;
								break;
							}

							throw new Error("cannot link place to itself");

						case 2:
							place = this.getDevice(iconId);
							device = this.getDevice(itemId);

							if (!(place.type == "group")) {
								context$3$0.next = 9;
								break;
							}

							if (place.group) {
								context$3$0.next = 7;
								break;
							}

							throw new Error("internal error: no GROUP number found");

						case 7:
							if (device.group) {
								context$3$0.next = 9;
								break;
							}

							throw new Error("cannot add unlinked device to a group");

						case 9:
							rec = this.localDevices.createRecord();
							context$3$0.prev = 10;
							packet = { content: _defineProperty({}, iconId, { content: _defineProperty({}, itemId, { index: this.newIndex(iconId) }) }) };
							result = !extra ? packet : lu.mergeDiffs(extra, packet);

							rec.assign(result);

							if (!(place.type == "group")) {
								context$3$0.next = 17;
								break;
							}

							context$3$0.next = 17;
							return this.command(itemId, "AppendTo", place.group);

						case 17:
							context$3$0.next = 19;
							return rec.save();

						case 19:
							context$3$0.prev = 19;

							rec.close();
							return context$3$0.finish(19);

						case 22:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[10,, 19, 22]]);
			}), this);
		},

		linkToFavourites: function linkToFavourites(itemId) {
			return this.linkItem(this.main, itemId);
		},

		linkActiveToFavourites: function linkActiveToFavourites(itemId) {
			return this.linkToFavourites(this.activeDeviceId);
		},

		addItem: function addItem(iconId, item) {
			var _content5;

			var id = arguments[2] === undefined ? UID() : arguments[2];
			var index = arguments[3] === undefined ? null : arguments[3];

			return this.serverDevices.update({ content: (_content5 = {}, _defineProperty(_content5, iconId, { content: _defineProperty({}, id, { index: index != null ? index : this.newIndex(iconId) }) }), _defineProperty(_content5, id, item), _content5) });
		},

		addPlace: function addPlace(iconId) {
			return this.addItem(iconId, {
				type: "place",
				ru: "Помещение",
				en: "Room"
			});
		},

		addDevice: function addDevice(iconId) {
			return this.addItem(iconId, {
				type: "single",
				ru: "Устройство",
				en: "Device"
			});
		},

		addGroup: function addGroup(iconId, id) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!id) id = UID();
							context$3$0.next = 3;
							return this.addItem(iconId, {
								type: "group",
								ru: "Группа",
								en: "Group"
							}, id);

						case 3:
							context$3$0.next = 5;
							return this.command(id, "Reserve");

						case 5:
							return context$3$0.abrupt("return", id);

						case 6:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		},

		deleteItem: function deleteItem(iconId, itemId) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var place, rec;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							place = this.getDevice(iconId);
							rec = this.localDevices.createRecord();
							context$3$0.prev = 2;

							rec.assign({ content: _defineProperty({}, iconId, { content: _defineProperty({}, itemId, null) }) });

							if (!(place.type == "group" && place.group)) {
								context$3$0.next = 7;
								break;
							}

							context$3$0.next = 7;
							return this.command(itemId, "RemoveFrom", place.group);

						case 7:
							context$3$0.next = 9;
							return rec.save();

						case 9:
							context$3$0.prev = 9;

							rec.close();
							return context$3$0.finish(9);

						case 12:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[2,, 9, 12]]);
			}), this);
		},

		insertInto: function insertInto(iconId, itemId, fromId) {
			return this.linkItem(iconId, itemId, { content: _defineProperty({}, fromId, { content: _defineProperty({}, itemId, null) }) });
		},

		errors: null,
		"throw": function _throw(dialog, data, retry) {
			if (!dialog) throw new Error("an error has to have its own dialog");
			this.errors = (this.errors || []).concat([{
				dialog: dialog,
				data: data,
				retry: retry
			}]);
		},
		clearError: function clearError() {
			var _this3 = this;

			ra.detach(function () {
				if (_this3.error) {
					_this3.dialog = "";
					_this3.errors = _this3.errors && _this3.errors.slice(1);
				}
			});
		},

		error: null,

		purgeItem: function purgeItem(deviceId, force) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var device, rec, cmd;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							device = this.getDevice(deviceId);
							rec = this.localDevices.createRecord();
							context$3$0.prev = 2;

							rec.assign(devdb.Clear(this.devices, deviceId));
							cmd = undefined;

							if (device && device.group != null) if (device.type == "group") cmd = "Clear";else if (device.type == "single") cmd = "Unlink";

							if (!cmd) {
								context$3$0.next = 11;
								break;
							}

							context$3$0.next = 9;
							return this.command(deviceId, cmd);

						case 9:
							context$3$0.next = 13;
							break;

						case 11:
							context$3$0.next = 13;
							return rec.save();

						case 13:
							context$3$0.prev = 13;

							if (!force) {
								context$3$0.next = 17;
								break;
							}

							context$3$0.next = 17;
							return rec.save();

						case 17:
							rec.close();
							// server MUST send us actual state BEFORE returning result of command execution
							if ((lu.valueOf(this.serverDevices.data) || 1)[deviceId]) this["throw"]("ErrorUnlinkingDevice", { deviceId: deviceId });
							return context$3$0.finish(13);

						case 20:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[2,, 13, 20]]);
			}), this);
		},

		renameItem: function renameItem(iconId, name) {
			var ret = lodash.reduce(this.getDevice(iconId), function (ret, _, key) {
				if (key.length == 2) ret[key] = null;
				return ret;
			}, {});
			ret[localDefaults.language || "ru"] = name;
			return this.serverDevices.update({ content: _defineProperty({}, iconId, ret) });
		},

		command: function command(deviceId, cmd, data) {

			// debugger

			// TODO:
			// let newstate = deviceActions.getNewState( this.getDevice( deviceId ), cmd )
			// if ( newstate != null ) {
			// }

			return this.commands.ask({ device: deviceId, command: cmd, data: data });
		},

		iconCommand: function iconCommand(icon, iconId, cmd, data) {
			// console.log( icon, iconId, cmd )
			icon = lu.valueOf(icon);
			if (icon.type == "place" ? cmd == "Short" : cmd == "Long") return this.go(iconId);
			if (icon.type != "place" && !icon.group) {
				this.dialog = "AskToLinkDevice";
				this.linkingPlaceId = iconId;
				// return Promise.reject( new Error( `device not configured` ) )
				return Promise.resolve();
			}
			if (cmd == "Short" || cmd == "Long") {
				if (icon && icon.state) {
					cmd = "Set";
					data = 0;
				} else {
					cmd = "Set";
					data = 1;
				}
				// cmd = `Comfort_1`
			}
			return this.command(iconId, cmd, data);
		},

		focus: function focus(node) {
			// magic actions to force allow to show keyboard by input.focus() on iOS ( so far checked iOS 8 )
			setTimeout(function () {
				return node.focus();
			}, 400);
		},

		searchAction: null,
		searchFilter: null,

		icons: null,

		modules: new WeakMap(),
		load: function load(module) {
			var ret = this.modules.get(module);
			if (ret == null) {
				ret = module(app, local);
				this.modules.set(module, ret);
			}
			return ret;
		},

		hover: null,

		"debugger": function _debugger() {
			debugger;
		}

	}, {
		modemLocations: { // TODO абнаўляць!! інтэрфейсы як толькі яны ў мадэма абнаўляюцца!!

			get: function () {
				return httpClient.get("/modem_locations");
			},
			configurable: true,
			enumerable: true
		},
		localModem: {
			get: function () {
				return this.modemLocations ? this.modemLocations[0].url.replace(/^http(?=s?\:\/\/)/, "ws") : "";
			},
			configurable: true,
			enumerable: true
		},
		doLogin: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					var script;
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						var _this4 = this;

						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!(!this.loggedin && this.modemLocations)) {
									context$3$0.next = 23;
									break;
								}

								script = document.createElement("script");

								script.src = "" + this.modemLocations[0].url + "/login?" + UID();
								document.body.appendChild(script);
								context$3$0.prev = 4;
								context$3$0.next = 7;
								return script
								// yield Promise.race( [ co.promise( script ), co.timeout( 15000 ) ] )
								;

							case 7:
								context$3$0.next = 16;
								break;

							case 9:
								context$3$0.prev = 9;
								context$3$0.t0 = context$3$0["catch"](4);

								LOG("error while trying to login: " + (context$3$0.t0 && context$3$0.t0.message && context$3$0.t0));
								console.error(context$3$0.t0);
								context$3$0.next = 15;
								return co.sleep(300);

							case 15:
								return context$3$0.abrupt("continue", 0);

							case 16:
								context$3$0.prev = 16;

								document.body.removeChild(script);
								return context$3$0.finish(16);

							case 19:
								LOG("logged in");
								ra.detach(function () {
									return _this4.loggedin = true;
								});
								context$3$0.next = 0;
								break;

							case 23:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this, [[4, 9, 16, 19]]);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		serverDevices: {
			get: function () {
				return wsJSONclient(this, "/database");
			},
			configurable: true,
			enumerable: true
		},
		localDevices: {
			get: function () {
				var _this5 = this;

				return ra.db(this.serverDevices.data, function (data) {
					return _this5.serverDevices.update(data);
				});
			},
			configurable: true,
			enumerable: true
		},
		devices: {
			get: function () {
				return this.localDevices.valueOf() || {};
			},
			configurable: true,
			enumerable: true
		},
		commands: {
			get: function () {
				return wsClient(this, "/commands");
			},
			configurable: true,
			enumerable: true
		},
		connectedToServer: {
			get: function () {
				return true && this.serverDevices.active.valueOf() && this.commands.active.valueOf();
			},
			configurable: true,
			enumerable: true
		},
		main: {
			get: function () {
				return this.devices.main;
			},
			configurable: true,
			enumerable: true
		},
		activeDeviceId: {
			get: function () {
				return local.activeDeviceId || this.main;
			},
			configurable: true,
			enumerable: true
		},
		activeDevice: {
			get: function () {
				return this.getDevice(this.activeDeviceId);
			},
			configurable: true,
			enumerable: true
		},
		activeContentIds: {
			get: function () {
				var device = this.activeDevice;
				return ra.Array(lodash.keys(device && device.content).sort(function (a, b) {
					return device.content[a].index - device.content[b].index;
				}));
			},
			configurable: true,
			enumerable: true
		},
		activeContent: {
			get: function () {
				return ra.Array(this.activeContentIds.map(this.getDevice));
			},
			configurable: true,
			enumerable: true
		},
		clearLinkingPlaceId: {
			get: function () {
				if (this.dialog != "AskToLinkDevice" && this.dialog != "AskIfDeviceHasBeenLinked") this.linkingPlaceId = null;
			},
			configurable: true,
			enumerable: true
		},
		checkIfTimeToGoBack: {
			get: function () {
				// lu.valueOf( this.places )
				if (!this.getDevice(this.activeDeviceId)) this.back();
			},
			configurable: true,
			enumerable: true
		},
		caption: {
			get: function () {
				return this.getMessage(this.getDevice(this.activeDeviceId)) || this.message("favorites");
			},
			configurable: true,
			enumerable: true
		},
		deviceType: {
			get: function () {
				var ret = this.getDevice(this.activeDeviceId);
				if (!ret) ret = this.getDevice(this.main);
				return ret && ret.type || "place";
			},
			configurable: true,
			enumerable: true
		},
		deviceIds: {
			get: function () {
				return ra.Array(lodash.keys(this.devices.content).sort());
			},
			configurable: true,
			enumerable: true
		},
		initialLoading: {
			get: function () {
				return !this.devices.uid;
			},
			configurable: true,
			enumerable: true
		},
		initialized: {
			get: function () {
				return !this.initialLoading && !!this.devices.main;
			},
			configurable: true,
			enumerable: true
		},
		templates: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								context$3$0.prev = 0;
								context$3$0.next = 3;
								return httpClient.get("/templates");

							case 3:
								return context$3$0.abrupt("return", context$3$0.sent);

							case 6:
								context$3$0.prev = 6;
								context$3$0.t0 = context$3$0["catch"](0);
								return context$3$0.abrupt("return", context$3$0.t0);

							case 9:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this, [[0, 6]]);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		allMessages: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								context$3$0.next = 2;
								return httpClient.get("/messages");

							case 2:
								return context$3$0.abrupt("return", context$3$0.sent);

							case 3:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		messages: {
			get: function () {
				var allMessages = this.allMessages;
				if (allMessages == null) return;
				var ret = {};
				var language = local.language || "ru";
				lodash.forOwn(allMessages, function (value, key) {
					return ret[key] = Object.prototype.hasOwnProperty.call(value, language) ? value[language] : key;
				});
				return ret;
			},
			configurable: true,
			enumerable: true
		},
		checkError: {
			get: function () {
				var _this6 = this;

				if (!this.dialog) if (this.errors && this.errors.length) ra.detach(function () {
					var error = _this6.errors[0];
					_this6.errors = _this6.errors && _this6.errors.slice(1);
					_this6.dialog = error.dialog;
					_this6.error = error;
				});else this.error = null;
			},
			configurable: true,
			enumerable: true
		},
		checkSearchDialog: {
			get: function () {
				if (this.dialog != "SearchItems") {
					this.searchAction = null;
					this.searchFilter = null;
				}
			},
			configurable: true,
			enumerable: true
		}
	})).setName("app");

	return { app: app, local: local };
};
// TODO: this code with an XMLHttpRequest does not work on iPhone :(((
// let xhr = new XMLHttpRequest
// xhr.open( `POST`, this.modemLocations[ 0 ].url + `/login`, true, `nero`, `123` )
// xhr.withCredentials = true
// try {
// 	xhr.send()
// 	yield xhr
// 	// alert( xhr.status )
// 	LOG( ( `` + xhr.status ).blue )
// 	if ( xhr.status >= 200 && xhr.status <= 299 )
// 		return ra.detach( () => this.loggedin = true )
// }
// catch ( error ) {
// 	// alert( `ERR` )
// 	console.log( `error while trying to login`, error )
// }
// yield co.sleep( 300 )

// alert( message )

// debugger

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/app.js","/src")

},{"JSONlocal":118,"PingPongJSON":120,"WebSocketToJSON":122,"_process":99,"buffer":94,"devdb":127,"events":98,"httpClient":131,"localUtils":134,"lodash":116,"ra":136,"uid":155,"windowSize":157}],124:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var MAX_TICKS = 100000;

var setTimeout = window.setTimeout;
// let setInterval = window.setInterval

process.nextTick = nextTick;

var queue = [];
var timer = null;
var processing = false;
var secret = "process-tick-" + Math.random();

var installTimer = function installTimer() {
	timer = setTimeout(onTimer, 1);
};

if (window.postMessage && window.addEventListener) {
	(function () {
		window.addEventListener("message", function (ev) {
			var source = ev.source;
			if ((source == window || source == null) && ev.data == secret) {
				ev.stopPropagation();
				onTimer();
			}
		});
		var postMessage = window.postMessage;
		installTimer = function () {
			postMessage(secret, "*");
			timer = true;
		};
	})();
}

!["setTimeout", "setInterval", "requestAnimationFrame"].forEach(function (name) {
	var proc = hookMethod(window, name, function (handler, time) {
		if (typeof arguments[0] == "function") arguments[0] = getProxy(arguments[0]);
		return proc.apply(this, arguments);
	});
});

![window, document].forEach(hookEventListener);

function onTimer() {
	timer = null;
	processQueue();
}

function ensureTimer() {
	if (!timer && !processing) installTimer();
}

function nextTick(fun) {
	queue.push(fun);
	ensureTimer();
}

function processQueue() {
	if (processing || !queue.length) return;
	var index = 0;
	processing = true;
	try {
		while (index < MAX_TICKS && index < queue.length) queue[index++]();
	} finally {
		// console.log( `ticks: ` + index )
		processing = false;
		queue.splice(0, index);
		if (queue.length) ensureTimer();
	}
}

function getProxy(handler) {
	function proxy() {
		var ret = handler.handleEvent ? handler.handleEvent.apply(handler, arguments) : handler.apply(this, arguments);
		processQueue();
		return ret;
	}
	var ret = undefined;
	if ((ret = handler[secret]) != null) return ret;else {
		assignProperty(proxy, secret, proxy);
		return assignProperty(handler, secret, proxy);
	}
}

function hookEventListener(obj) {
	if (obj.addEventListener) {
		(function () {
			var addEventListener = hookMethod(obj, "addEventListener", function (event, handler) {
				arguments[1] = getProxy(arguments[1]);
				return addEventListener.apply(this, arguments);
			});
			var removeEventListener = hookMethod(obj, "removeEventListener", function (event, handler) {
				if (arguments[1][secret]) arguments[1] = arguments[1][secret];
				return removeEventListener.apply(this, arguments);
			});
		})();
	}
}

function hookMethod(obj, name, proxy) {
	var ret = obj[name];
	if (ret) {
		assignProperty(proxy, "toString", function () {
			return ret.toString();
		});
		obj[name] = proxy;
	}
	return ret;
}

function assignProperty(obj, name, value) {
	if (Object.defineProperty) Object.defineProperty(obj, name, { value: value });else obj[name] = value;
	return value;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/browser-nexttick.js","/src")

},{"_process":99,"buffer":94}],125:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var later = require("later");
var EventEmitter = require("events").EventEmitter;

var co = module.exports = exports = new EventEmitter();

var threadCatcher = null;

exports.cb = null;
exports.global = null;

exports.go = function (fun) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	if (typeof fun == "function") fun = fun.apply(null, args);
	if (!fun.next) {
		(function () {
			var value = fun;
			fun = {
				next: function next() {
					var ret = { value: value, done: !value };
					value = null;
					return ret;
				}
			};
		})();
	}
	return new Thread(fun);
};

exports.gocall = function (fun, context) {
	for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
		args[_key2 - 2] = arguments[_key2];
	}

	return new Thread(fun.apply(context, args));
};

exports.func = function (fun) {
	if (arguments.length >= 2) fun = Array.prototype.reduceRight.call(arguments, function (g, f) {
		return f(g);
	});
	return function proc() {
		return new Thread(fun.apply(this, arguments));
	};
};

exports.eventHandler = function (fun) {
	return function proc() {
		var ret = new Thread(fun.apply(this, arguments));
		ret.waitForInput();
		return ret;
	};
};

// the first argument is an error, the second one is a result
exports.cbfunc = function (funWithCB) {
	return function () {
		var _this = this;

		for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
			args[_key3] = arguments[_key3];
		}

		return new Promise(function (resolve, reject) {
			return funWithCB.call.apply(funWithCB, [_this].concat(args, [function (error, value) {
				if (error != null) reject(error);else resolve(value);
			}]));
		});
	};
};

exports.catchThreads = function (cb, onThread) {
	var oldCatcher = threadCatcher;
	threadCatcher = onThread;
	try {
		return cb();
	} finally {
		threadCatcher = oldCatcher;
	}
};

exports.receive = function (emitter, events) {
	return new Promise(function (resolve, reject) {
		var handlers = Object.create(null);
		var timer = undefined;
		var rejecter = co.defer(function () {
			clear();
			reject();
		});

		var _loop = function (_event) {
			if (Object.prototype.hasOwnProperty.call(events, _event)) {
				var _ret3 = (function () {
					var predicate = events[_event];
					if (predicate == null)
						//
						// allow simpler events defining like
						//
						// yield co.receive( obj, { data: true, timeout: getTimeout( ... ) } )
						//
						// instead of
						//
						// let events = { data: true }
						// if ( getTimeout( ... ) != null ) events.timeout = getTimeout( ... )
						// yield co.receive( obj, events )
						//
						return {
							v: "continue"
						};
					if (_event == "timeout") timer = setTimeout(function () {
						return done("timeout", null);
					}, predicate);else emitter.addListener(_event, handlers[_event] = function (data) {
						if (typeof predicate != "function" || predicate(data)) done(_event, data);
					});
				})();

				if (typeof _ret3 === "object") return _ret3.v;
			}
		};

		for (var _event in events) {
			var _ret2 = _loop(_event);

			if (_ret2 === "continue") continue;
		}function clear() {
			if (!handlers) return;
			clearTimeout(timer);
			for (var _event2 in handlers) {
				emitter.removeListener(_event2, handlers[_event2]);
			}rejecter.close();
			handlers = null;
		}
		function done(event, data) {
			clear();
			resolve({ event: event, data: data });
		}
	});
};

var noopthen = { then: function then() {} };
exports.wait = function () {
	return noopthen;
};

exports.sleep = function (milliseconds) {
	return { then: function then(resolve) {
			var timer = setTimeout(resolve, milliseconds);
			return { kill: function kill() {
					clearTimout(timer);
				} };
		} };
};

exports.tick = exports.sleep(1);

exports.timeout = function (milliseconds) {
	return { then: function then(_, reject) {
			var timer = setTimeout(reject, milliseconds);
			return { kill: function kill() {
					clearTimout(timer);
				} };
		} };
};

exports.promise = function (value) {
	return Promise.all([co.go(regeneratorRuntime.mark(function callee$1$0() {
		return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
			while (1) switch (context$2$0.prev = context$2$0.next) {
				case 0:
					context$2$0.next = 2;
					return value;

				case 2:
				case "end":
					return context$2$0.stop();
			}
		}, callee$1$0, this);
	}))]);
};

exports.requestAnimationFrame = { then: function then(resolve) {
		if (typeof cancelAnimationFrame == "function") {
			var _ret4 = (function () {
				var frame = requestAnimationFrame(resolve);
				return {
					v: { kill: function kill() {
							cancelAnimationFrame(frame);
						} }
				};
			})();

			if (typeof _ret4 === "object") return _ret4.v;
		} else return exports.sleep(1).then(resolve);
	} };

var rethrow = function rethrow(e) {
	return setTimeout(function () {
		throw e;
	}, 1);
};

function iteratorFailed(error) {
	return { done: true, iteratorFailed: true, value: error };
}

function iteratorNext(iterator, result) {
	try {
		return iterator.next(result);
	} catch (error) {
		return iteratorFailed(error);
	}
}

function iteratorThrow(iterator, result) {
	if (!iterator["throw"]) return iteratorFailed(result);
	try {
		return iterator["throw"](result);
	} catch (error) {
		return iteratorFailed(error);
	}
}

var DONE = { done: true };

var EKill = (function (_Error) {
	function EKill() {
		var message = arguments[0] === undefined ? "kill" : arguments[0];

		_classCallCheck(this, EKill);

		_get(Object.getPrototypeOf(EKill.prototype), "constructor", this).call(this, message);
	}

	_inherits(EKill, _Error);

	return EKill;
})(Error);

exports.EKill = EKill;

function iteratorReturn(iterator) {
	if (iterator["return"]) {
		try {
			iterator["return"]();
		} catch (error) {
			return iteratorFailed(error);
		}
	} else if (iterator["throw"]) {
		var e = new EKill();
		var v = iteratorThrow(iterator, e);
		if (!v.done || !v.iteratorFailed) rethrow(new Error("thread has eaten EKill"));else if (v.value != e) return v;
	}
	return DONE;
}

function iteratorCheck(ret) {
	if (ret && ret.done && ret.iteratorFailed) throw ret.value;else return ret;
}

function killIterator(iterator) {
	if (iterator) {
		var res = iteratorReturn(iterator);
		if (res.done && res.iteratorFailed) rethrow(res.value);
	}
}

// Thread

var catchDefer = function catchDefer(func) {
	// optimization -- using try/catch in a separate function.
	try {
		return func();
	} catch (error) {
		return { next: function next() {
				return iteratorFailed(error);
			} };
	}
};

var dummyIterator = {
	next: function next() {
		return DONE;
	},
	"throw": function _throw(error) {
		throw error;
	},
	"return": function _return(value) {
		return { value: value, done: true };
	}
};

exports.defer = function (proc) {
	if (typeof proc != "function") throw new Error("only functions can be deferred");
	var thread = exports.current;
	if (!thread) throw new Error("not in a thread");
	if (!thread._stack) thread._stack = [];
	var iterator = undefined;
	function createIterator() {
		iterator = proc();
		if (!iterator || typeof iterator.next != "function") iterator = dummyIterator;
		return iterator;
	}
	var rec = {
		next: function next(value) {
			return (iterator || createIterator()).next(value);
		},
		"throw": function _throw(error) {
			iterator || createIterator();
			return (iterator["throw"] ? iterator : dummyIterator)["throw"](error);
		},
		"return": function _return(value) {
			// let deffered iterator do one step
			iterator || createIterator().next(undefined);
			if (iterator["return"]) return iterator["return"](value);else {
				if (iterator["throw"]) !(function () {
					try {
						iterator["throw"](new EKill("return"));
					} catch (_) {}
				})();
				return dummyIterator["return"](value);
			}
		}
	};
	thread._stack.push(rec);
	return { close: function close() {
			if (!rec) return;
			if (thread._stack) {
				var i = thread._stack.indexOf(rec);
				if (i >= 0) thread._stack.splice(i, 1);
			}
			rec = null;
		} };
};

var Thread = (function () {
	function Thread(iterator) {
		var _this2 = this;

		_classCallCheck(this, Thread);

		this._attachedToStack = true;
		this._iterator = iterator;
		this._stopCount = 0;
		this._stack = null;
		this.global = Object.create(null);
		this._currentPromise = null;
		this._running = false;
		this._killing = null;
		this._cb = function (error, data) {
			if (_this2._step) if (error) _this2._step.fail(error);else _this2._step.next(data);
		};
		this.$name = { toString: function toString() {
				return "<Thread>";
			} };

		this._newStep();
		this._start = function () {
			if (_this2._start && _this2._step && _this2._step.next) {
				if (_this2._stopCount > 0) _this2._step.resume = _this2._start;else {
					_this2._start = null;
					_this2._step.next();
				}
			}
		};

		this._promise = new Promise(function (resolve, reject) {
			_this2._resolve = resolve;
			_this2._reject = reject;
		});
		if (!this._resolve) throw new Error("assertion failure: wrong implementation of Promise");

		later.then(this._start);
		if (threadCatcher) threadCatcher(this);

		exports.emit("start", this);
	}

	_createClass(Thread, [{
		key: "linkName",
		value: function linkName(value) {
			var suffix = arguments[1] === undefined ? ":thread" : arguments[1];

			if (value.$name) value = value.$name;
			this.$name.toString = function () {
				return "" + value + suffix;
			};
			return this;
		}
	}, {
		key: "waitForInput",
		value: function waitForInput() {
			this._checkFinished();
			if (this._stopCount > 0) throw new Error("thread is paused");
			if (this._start) this._start();
			return this;
		}
	}, {
		key: "_attachPromise",
		value: function _attachPromise(promise) {
			promise.kill = this.kill.bind(this);
			return promise;
		}
	}, {
		key: "then",
		value: function then(onFulfilled, onRejected) {
			this._attachedToStack = false;
			return this._attachPromise(this._promise.then(onFulfilled, onRejected));
		}
	}, {
		key: "catch",
		value: function _catch(onRejected) {
			this._attachedToStack = false;
			return this._attachPromise(this._promise["catch"](onRejected));
		}
	}, {
		key: "isFinished",
		value: function isFinished() {
			return !this._step || this._killing;
		}
	}, {
		key: "isPaused",
		value: function isPaused() {
			return this._stopCount > 0;
		}
	}, {
		key: "throw",
		value: function _throw(exception) {
			if (this.global == exports.global) throw exception;
			this._checkFinished();
			this._newStep();
			if (this._stopCount > 0) this._step.resume = this._step.fail.bind(this._step, exception);else this._step.fail(exception);
		}
	}, {
		key: "attachToStack",
		value: function attachToStack() {
			this._attachedToStack = true;
		}
	}, {
		key: "kill",
		value: function kill(reason) {
			if (this.isFinished()) return;
			this._reject(reason);
			if (this._running) {
				this._killing = { reason: reason };
				throw new EKill();
			}
			var previousThread = exports.current;
			var previosCB = exports.cb;
			var previosGlobal = exports.global;
			exports.cb = this._cb;
			exports.global = this.global;
			exports.current = this;
			killIterator(this._iterator);
			if (this._stack) for (var a = this._stack, i = a.length - 1; i >= 0; --i) {
				killIterator(a[i]);
			}exports.cb = previosCB;
			exports.global = previosGlobal;
			exports.current = previousThread;
			if (this._currentPromise) {
				try {
					this._currentPromise.kill(reason);
				} catch (e) {
					rethrow(e);
				}
			}
			this._done();
		}
	}, {
		key: "pause",
		value: function pause() {
			this._checkFinished();
			++this._stopCount;
		}
	}, {
		key: "resume",
		value: function resume() {
			if (this._stopCount == 0) throw new Error("thread not paused");
			if (0 == --this._stopCount && this._step && this._step.resume) {
				later.then(this._step.resume);
				this._step.resume = null;
			}
		}
	}, {
		key: "_tick",
		value: function _tick(step, imethod, result) {
			if (this["debugger"] || step["debugger"]) debugger;
			if (this._running) throw new Error("FATAL: reentering thread tick");
			if (step !== this._step) return;
			if (this._stopCount > 0) {
				step.resume = this._tick.bind(this, step, imethod, result);
				return;
			}
			for (;;) {
				this._currentPromise = null;
				this._running = true;
				var previousThread = exports.current;
				var previosCB = exports.cb;
				var previosGlobal = exports.global;
				exports.cb = this._cb;
				exports.global = this.global;
				exports.current = this;
				var v = imethod(this._iterator, result);
				exports.cb = previosCB;
				exports.global = previosGlobal;
				exports.current = previousThread;
				this._running = false;
				if (this["debugger"] || step["debugger"]) debugger;
				if (this._killing) {
					var reason = this._killing.reason;
					this._killing = null;
					this.kill(reason);
					return;
				}
				if (v.done) {
					if (this.isFinished()) return;
					if (this._iterator = this._stack && this._stack.pop()) {
						imethod = v.iteratorFailed ? iteratorThrow : iteratorNext;
						result = v.value;
						continue;
					}
					var r = v.iteratorFailed ? this._reject : this._resolve;
					this._done();
					if (v.iteratorFailed && this._attachedToStack) rethrow(v.value);
					r(v.value);
				} else if (!v.value) // any falsy value
					exports.tick.then(step.next);else if (v.value.then) {
					var p = v.value.then(step.next, step.fail);
					if (p && p.kill) this._currentPromise = p;
				} else if (v.value.next) {
					this._stack ? this._stack.push(this._iterator) : this._stack = [this._iterator];
					this._iterator = v.value;
					imethod = iteratorNext;
					result = undefined;
					continue;
				} else if ("onload" in v.value && !v.value.onload && "onerror" in v.value && !v.value.onerror) {
					v.value.onload = step.next;
					v.value.onerror = step.fail;
				} else if ("onsuccess" in v.value && !v.value.onload && "onerror" in v.value && !v.value.onerror) {
					if (!step.success_error) step.success_error = {
						onsuccess: function onsuccess(event) {
							step.next(event.target.result);
						},
						onerror: function onerror(event) {
							step.fail(event.target.error || event);
						}
					};
					v.value.onsuccess = step.success_error.onsuccess;
					v.value.onerror = step.success_error.onerror;
				} else throw new Error("thread type error");
				break;
			}
		}
	}, {
		key: "_done",
		value: function _done() {
			this._step = null;
			this._iterator = null;
			this._stack = null;
			this._resolve = null;
			this._reject = null;
			this._currentPromise = null;
			this._killing = null;
		}
	}, {
		key: "_newStep",
		value: function _newStep() {
			var step = this._step = { resume: null };
			step.next = this._tick.bind(this, step, iteratorNext);
			step.fail = this._tick.bind(this, step, iteratorThrow);
			var $name = this.$name;
			step.next.$name = { toString: function toString() {
					return $name + ":next";
				} };
			step.fail.$name = { toString: function toString() {
					return $name + ":fail";
				} };
		}
	}, {
		key: "_onPromise",
		value: function _onPromise(resolve, reject) {
			this._resolve = resolve;
			this._reject = reject;
			this.resume();
		}
	}, {
		key: "_checkFinished",
		value: function _checkFinished() {
			if (this.isFinished()) throw new Error("thread is already finished");
		}
	}]);

	return Thread;
})();

exports.Thread = Thread;

{
	(function () {
		var notEnumerable = { enumerable: false };
		Object.keys(Thread.prototype).forEach(function (k) {
			return k.match(/^_/) && Object.defineProperty(Thread.prototype, k, notEnumerable);
		});

		var mainThread = new Thread({ next: function next() {
				return { value: { then: function then() {} } };
			} }).waitForInput();
		exports.current = null;
		exports.global = mainThread.global;
		exports.cb = null;
	})();
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/co.js","/src")

},{"_process":99,"buffer":94,"events":98,"later":133}],126:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var co = require("co");
var ra = require("ra");
var lodash = require("lodash");

function toNode(child, node) {
	restart: for (;;) {
		child = child && typeof child.valueOf == "function" ? child.valueOf() : child;
		if (Array.isArray(child)) {
			if (child.length == 0) return null;
			if (child.length == 1) {
				child = child[0];
				continue restart;
			}
			if (!node) node = document.createDocumentFragment();
			child.forEach(function (child) {
				return toNode(child, node);
			});
			child = node;
		} else {
			if (typeof child == "string") child = document.createTextNode(child);
			if (node) {
				node.appendChild(child);
				child = node;
			}
		}
		return child;
	}
}

function fcalc(f, cb) {
	if (typeof f != "function") cb(f);else {
		(function () {
			var first = true;
			ra(false, regeneratorRuntime.mark(function callee$2$0() {
				var ret;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!first) {
								context$3$0.next = 4;
								break;
							}

							first = false;
							context$3$0.next = 6;
							break;

						case 4:
							context$3$0.next = 6;
							return co.requestAnimationFrame;

						case 6:
							ret = f();

							if (!(ret && ret.next && ret["throw"])) {
								context$3$0.next = 11;
								break;
							}

							context$3$0.next = 10;
							return ret;

						case 10:
							ret = context$3$0.sent;

						case 11:
							cb(ret);

						case 12:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}));
		})();
	}
}

function checkDOMControl(control) {
	var q = [control.ownerDocument && control.ownerDocument.documentElement, document.documentElement, control.ownerDocument && control.ownerDocument.body, document.body].filter(Boolean);
	var p = control;
	while (p) {
		if (q.indexOf(p) >= 0) {
			ra.forceCalculations();
			return;
		}
		p = p.parentNode;
	}
}

function setContent(control, content) {
	var cb = arguments[2] === undefined ? null : arguments[2];
	fcalc(content, function (content) {
		checkDOMControl(control);
		var c = toNode(content);
		if (c) {
			checkDOMControl(control);
			control.innerHTML = "";
			control.appendChild(c);
		} else control.innerHTML = "";
		cb && cb();
	});
}

function toAttrString(value) {
	if (Array.isArray(value)) return value.map(toAttrString).join(" ");else if (value) return "" + value;else return "";
}

function appendContent(content, f) {
	if (!f) f = document.createDocumentFragment();
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = content[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var c = _step.value;

			if (typeof c == "function") {
				var p = document.createElement("span");
				setContent(p, c);
				f.appendChild(p);
			} else if (c instanceof Node) f.appendChild(c);else if (c != null && typeof c != "string" && c[Symbol.iterator]) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = c[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _cc = _step2.value;

						appendContent(_cc, f);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			} else f.appendChild(document.createTextNode(c));
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator["return"]) {
				_iterator["return"]();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return f;
}

var GeneratorFunctionPrototype = Object.getPrototypeOf(regeneratorRuntime.mark(function callee$0$0() {
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
}));

module.exports = {
	createElement: function createElement(name, attributes) {
		for (var _len = arguments.length, content = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			content[_key - 2] = arguments[_key];
		}

		if (typeof name == "function") return name(attributes && attributes._ ? Object.assign({}, attributes, attributes._, { _: null }) : attributes || 0, appendContent(content));
		var onCreate = undefined;
		var ret = document.createElement(name);
		var classes = [];
		function applyAttributes(attributes) {
			if (attributes == null) return;
			lodash.forEach(attributes, function (value, name) {
				if (name == "_") {} else if (name == "class") classes.push(value);else if (name == "style")
					// TODO: smth like to "class" attribute - parse parent style and update it
					fcalc(value, function (value) {
						if (typeof value == "string") ret.setAttribute("style", value);else lodash.forEach(value, function (value, name) {
							return fcalc(value, function (value) {
								return ret.style[name] = value;
							});
						});
					});else if (name == "oncreate") onCreate = value;else if (name.match(/^on/)) {
					if (value != null) {
						if (typeof value == "function") value = [value];
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;

						try {
							for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var handler = _step3.value;

								if (Object.getPrototypeOf(handler) == GeneratorFunctionPrototype) handler = co.eventHandler(handler);
								ret.addEventListener(name.slice("on".length), handler);
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
									_iterator3["return"]();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
					}
				} else fcalc(value, function (value) {
					value = toAttrString(value);
					if (ret.getAttribute(name) != value) ret.setAttribute(name, value);
				});
			});
			if (Object.prototype.hasOwnProperty.call(attributes, "_")) applyAttributes(attributes._);
		}
		applyAttributes(attributes);
		if (classes.length) {
			(function () {
				var copy = classes.map(function () {
					return null;
				});
				classes.forEach(function (c, i) {
					return fcalc(c, function (c) {
						copy[i] = c;
						var className = toAttrString(copy).replace(/(^|\s|\r|\n)(null|undefined|false|0|\-0|NaN)(?=$|\s|\r|\n)/g, "");
						if (ret.className != className) ret.className = className;
					});
				});
			})();
		}
		switch (content.length) {
			case 0:
				break;
			case 1:
				setContent(ret, content[0]);
				break;
			default:
				ret.appendChild(appendContent(content));
				break;
		}
		if (typeof onCreate == "function") {
			onCreate.call(ret, {
				type: "create",
				target: ret,
				srcElement: ret,
				currentTarget: ret
			});
		}
		return ret;
	}
};

var updateInputValue = function updateInputValue() {
	var _this = this;

	setTimeout(function () {
		return _this._raValue.assign(_this.value);
	});
};
var raValue = {
	get: function get() {
		var _this2 = this;

		if (!this._raValue) ra.detach(function () {
			_this2._raValue = ra();
			_this2._raValue.assign(_this2.value);
			_this2.addEventListener("change", updateInputValue);
			_this2.addEventListener("keypress", updateInputValue);
			_this2.addEventListener("keydown", updateInputValue);
			_this2.addEventListener("keyup", updateInputValue);
		});
		return this._raValue.valueOf();
	},
	set: function set(value) {
		if (this.value != value) {
			this.value = value;
			if (this._raValue) this._raValue.assign(this.value);
		}
	}
};

var _arr = [HTMLInputElement, HTMLTextAreaElement];
for (var _i = 0; _i < _arr.length; _i++) {
	var C = _arr[_i];
	Object.defineProperty(C.prototype, "raValue", raValue);
}
// noop

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/components.js","/src")

},{"_process":99,"buffer":94,"co":125,"lodash":116,"ra":136}],127:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var UID = require("uid");
var lu = require("localUtils");

exports.Clear = exports.Unlink = function (devices, deviceId) {
	return lodash.reduce(devices.content, function (ret, q, index) {
		if (q) if (index == deviceId) ret.content[index] = null;else if (q.content && q.content[deviceId]) ret.content[index] = { content: _defineProperty({}, deviceId, null) };
		return ret;
	}, { content: {} });
};

exports.Set = function (devices, deviceId, data) {
	var device = devices.content[deviceId];
	if (!device || !device.group) return;
	var ret = { content: _defineProperty({}, deviceId, data) };
	if (device.type == "group") ret = lodash.reduce(device.content, function (ret, q, index) {
		if (q) ret.content[index] = data;
		return ret;
	}, ret);
	return ret;
};

exports.findFreeGroup = function (devices) {
	var groups = [];
	for (var i = 1; i <= 1022; ++i) {
		groups[i] = i;
	}lodash.forEach(devices.content, function (device) {
		return device && Number.isFinite(device.group) && (groups[device.group] = false);
	});
	groups = groups.filter(Boolean);
	return !groups.length ? null : groups[Math.floor(Math.random() * groups.length) % groups.length];
};

exports.cleanDatabase = function (devices) {
	var ret = devices || {};
	function _save(diff) {
		ret = lu.applyDiff(ret, diff);
	}
	function _change(path, value) {
		_save(path.reduceRight(function (ret, key) {
			return _defineProperty({}, key, ret);
		}, value));
	}
	function assign() {
		for (var _len = arguments.length, path = Array(_len), _key = 0; _key < _len; _key++) {
			path[_key] = arguments[_key];
		}

		_change(path, path.pop());
	}
	function remove() {
		for (var _len2 = arguments.length, path = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			path[_key2] = arguments[_key2];
		}

		_change(path, null);
	}

	// move root items to content
	if (!ret.content) lodash.forEach(ret, function (place, placeId) {
		if (place != null && typeof place != "object") return;
		remove(placeId);
		assign("content", placeId, place);
	});else // TODO delete later
		lodash.forEach(ret, function (place, placeId) {
			if (place != null && typeof place != "object") return;
			if (placeId == "content") return;
			remove(placeId);
		});

	// remove items with wrong type & remove group from places
	lodash.forEach(ret.content, function (place, placeId) {
		if (place == null || typeof place != "object") return remove("content", placeId);
		if (place.type == "device") // TODO: remove later
			assign("content", placeId, "type", "single");
		if (place.device == placeId) remove("content", placeId, "device");else if (!(place.type || "").match(/^(place|group|single)$/)) return remove("content", placeId);
		if (place.group != null && (!Number.isFinite(place.group) || place.type == "place")) remove("content", placeId, "group");
	});

	// create main
	if (ret && typeof ret.main != "string") {
		(function () {
			var main = UID();
			var i = 0;
			lodash.forEach(ret.content, function (place, key) {
				return assign("content", main, "content", key, ++i);
			});
			if (ret.content && ret.content[main]) assign("main", main);
		})();
	}

	// remove items with duplicate group
	var reachable = undefined;
	function groupIndex(key) {
		if (!reachable) {
			(function () {
				var push = function (key) {
					if (!(key in reachable) && ret.content.hasOwnProperty(key)) {
						reachable[key] = true;
						reachableKeys.push(key);
					}
					return key;
				};

				reachable = Object.create(null);
				var reachableKeys = [];

				push(ret.main);
				for (var _i = 0; _i < reachableKeys.length; ++_i) {
					var place = ret.content[reachableKeys[_i]];
					if (place && place.content) Object.keys(place.content).forEach(push);
				}
			})();
		}
		var i = 0;
		if (ret.content[key].type == "group") i += 2;
		if (key in reachable) i += 1;
	}

	var groups = Object.create(null);
	lodash.forEach(ret.content, function (place, key) {
		if (!place || place.group == null) return;
		if (!groups[place.group]) groups[place.group] = key;else {
			if (groupIndex(groups[place.group]) < groupIndex(key)) {
				remove("content", groups[place.group]);
				groups[place.group] = key;
			} else remove("content", key);
		}
	});

	// check content
	lodash.forEach(ret.content, function (place, key) {
		if (!place || place.content == null) return;
		if (typeof place.content != "object") return remove("content", key, "content");
		lodash.forEach(place.content, function (_, ckey) {
			if (!ret.content[ckey] || typeof ret.content[ckey] != "object") remove("content", key, "content", ckey);
		});
		place = ret.content[key]; // reassign place cause it could change in previous forEach
		lodash.keys(place.content).sort(function (a, b) {
			return (place.content[a].index || 0) - (place.content[b].index || 0);
		}).forEach(function (ckey, index) {
			if (place.content[ckey].index != index) assign("content", key, "content", ckey, "index", index);
		});
	});

	return lu.makeDiff(devices, ret);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/devdb.js","/src")

},{"_process":99,"buffer":94,"localUtils":134,"lodash":116,"uid":155}],128:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

2014.09.22

it should be better to use hammer.js, but i cannot use it without problems -
hammer.js often drops events, while direct addEventListener does not.

*/

"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var co = require("co");
var sparsequeue = require("sparsequeue");

var TRACE = undefined;
// let TC = 0
// TRACE = ( ...info ) => LOG( `${ ++TC } g ${ JSON.stringify( info ).slice( 0, 100 ) }`.green )

var SWIPE_TIMEOUT = 400; // ms
var PRESS_TIMEOUT = 500; // ms
var PRESS_MOVE_OUT = 2 /* ~mm */ * (96 / 25.4);

function squareDistance(p1, p2) {
	return (p1.pageX - p2.pageX) * (p1.pageX - p2.pageX) + (p1.pageY - p2.pageY) * (p1.pageY - p2.pageY);
}

function getX(p) {
	return p.pageX;
}
function getY(p) {
	return p.pageY;
}
function increasing(v, i, p) {
	return i == 0 || v >= p[i - 1];
}
function decreasing(v, i, p) {
	return i == 0 || v <= p[i - 1];
}

document.addEventListener("touch", co.eventHandler(regeneratorRuntime.mark(function callee$0$0(event) {
	var all, trace, last, pressed, swiped, pan, panlock, sent, send, ensurepan, sendpan, pressTimeout, stoppedTimeout, startStoppedTimeout, stopPoint, pt, longmove, dx, dy, sizex, sizey, prev, direction, traceX, traceY, bounds;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				startStoppedTimeout = function startStoppedTimeout() {
					clearTimeout(stoppedTimeout);
					stoppedTimeout = setTimeout(function () {
						ensurepan();
						sendpan("stop");
						startStoppedTimeout();
					}, PRESS_TIMEOUT);
				};

				sendpan = function sendpan(type, direction, pt, detail) {
					var data = send(type, direction, pt, detail);
					if (pan) {
						if (panlock && panlock.length) {
							panlock[0].queue.push(data);
							panlock.forEach(function (p, i) {
								return i > 0 && (p.dirty = true);
							});
							pan.dirty = true;
						} else pan.queue.push(data);
					}
				};

				ensurepan = function ensurepan(direction) {
					if (pan) return;
					pan = { queue: new sparsequeue() };
					send("pan", direction, last, {
						next: pan.queue,
						lock: function lock() {
							if (!panlock) panlock = [];
							var ret = { queue: new sparsequeue() };
							panlock.push(ret);
							return ret.queue;
						},
						unlock: function unlock(lock) {
							panlock = panlock.filter(function (l) {
								return l != lock;
							});
							var p = panlock[0] || pan;
							if (p.dirty) {
								p.dirty = false;
								sendpan("pan", "unlocked");
							}
						}
					}, "");
				};

				send = function send(type, direction, pt, detail, typeDirection) {
					TRACE && TRACE(type, all);
					if (typeDirection == null) typeDirection = direction;
					if (!detail) detail = {};
					detail.direction = direction;
					detail.pressed = pressed;
					detail.type = type;
					detail.start = event;
					detail.original = pt || event;
					var ret = new CustomEvent(type + (typeDirection || ""), { bubbles: true, cancelable: true, detail: detail });
					ret.pageX = last.pageX;
					ret.pageY = last.pageY;
					ret.clientX = last.clientX;
					ret.clientY = last.clientY;
					ret.screenX = last.screenX;
					ret.screenY = last.screenY;
					ret.deltaX = last.pageX - event.pageX;
					ret.deltaY = last.pageY - event.pageY;
					ret.lastDeltaX = last.pageX - sent.pageX;
					ret.lastDeltaY = last.pageY - sent.pageY;
					sent = last;
					ret.preventDefault = function () {
						return event.preventDefault();
					};
					event.target.dispatchEvent(ret);
					return ret;
				};

				all = undefined;
				trace = [event];
				last = event;
				pressed = null;
				swiped = false;
				pan = null;
				panlock = null;
				sent = event;

				co.defer(function () {
					panlock && panlock.forEach(function (lock) {
						return lock.queue.close();
					});
					pan && pan.queue.close();
				});

				pressTimeout = undefined;
				stoppedTimeout = undefined;

				co.defer(function () {
					clearTimeout(pressTimeout);
					clearTimeout(stoppedTimeout);
				});

				pressTimeout = setTimeout(function () {
					pressed = true;
					send("press");
				}, PRESS_TIMEOUT);

				startStoppedTimeout();

				TRACE && TRACE("enter", { x: event.pageX, y: event.pageY, t: event.timeStamp });

				stopPoint = event;
				pt = undefined;

			case 21:
				context$1$0.next = 23;
				return event.detail.next;

			case 23:
				if (!(pt = context$1$0.sent)) {
					context$1$0.next = 31;
					break;
				}

				if (TRACE) {
					(all || (all = [])).push({ x: pt.pageX, y: pt.pageY, t: pt.timeStamp - event.timeStamp });
					TRACE("next", all);
				}
				if (last.timeStamp - event.timeStamp > SWIPE_TIMEOUT) trace = null;

				longmove = squareDistance(pt, stopPoint) > PRESS_MOVE_OUT * PRESS_MOVE_OUT;

				if (longmove) {
					stopPoint = pt;
					startStoppedTimeout();
				}

				if (longmove || !trace || trace.length > 1) {
					if (pressed == null) {
						pressed = false;
						clearTimeout(pressTimeout);
					}
					dx = pt.pageX - last.pageX;
					dy = pt.pageY - last.pageY;

					if (dx || dy) {
						sizex = Math.abs(dx);
						sizey = Math.abs(dy);
						prev = last;

						if (trace) trace.push(last);
						last = pt;
						direction = "";

						if (sizex >= sizey && dx > 0) direction = "right";else if (sizex >= sizey && dx < 0) direction = "left";else if (sizex < sizey && dy > 0) direction = "down";else if (sizex < sizey && dy < 0) direction = "up";
						ensurepan(direction);
						sendpan("pan", direction, last);
					}
				}

			case 29:
				context$1$0.next = 21;
				break;

			case 31:
				clearTimeout(pressTimeout);
				if (last.timeStamp - event.timeStamp < SWIPE_TIMEOUT && trace && trace.length > 2) {
					// remove first point to eliminate touch bouncing effect
					trace.shift();
					traceX = trace.map(getX);
					traceY = trace.map(getY);
					bounds = {
						x: Math.max.apply(Math, _toConsumableArray(traceX)) - Math.min.apply(Math, _toConsumableArray(traceX)),
						y: Math.max.apply(Math, _toConsumableArray(traceY)) - Math.min.apply(Math, _toConsumableArray(traceY))
					};
					direction = "";

					if (bounds.x > bounds.y && traceX.every(increasing)) direction = "right";else if (bounds.x > bounds.y && traceX.every(decreasing)) direction = "left";else if (bounds.x < bounds.y && traceY.every(increasing)) direction = "down";else if (bounds.x < bounds.y && traceY.every(decreasing)) direction = "up";
					if (direction) {
						swiped = true;
						sendpan("swipe", direction, last);
					}
				}
				if (!pressed && !swiped && !pan) sendpan("tap");
				TRACE && TRACE("done", all);

			case 35:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/gesture.js","/src")

},{"_process":99,"buffer":94,"co":125,"sparsequeue":138}],129:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var style = document.createElement("div").style;
if (!("transform" in style) && "webkitTransform" in style) {
	Object.defineProperty(CSSStyleDeclaration.prototype, "transform", {
		get: function get() {
			return this.webkitTransform;
		},
		set: function set(value) {
			this.webkitTransform = value;
		}
	});
}

// let slice = [].slice

if (!NodeList.prototype[Symbol.iterator]) NodeList.prototype[Symbol.iterator] = regeneratorRuntime.mark(function callee$0$0() {
	var i, l;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				i = 0, l = this.length;

			case 1:
				if (!(i < l)) {
					context$1$0.next = 7;
					break;
				}

				context$1$0.next = 4;
				return this.item(i);

			case 4:
				++i;
				context$1$0.next = 1;
				break;

			case 7:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
});

// return slice.call( this )[ Symbol.iterator ]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/htmlpolyfill.js","/src")

},{"_process":99,"buffer":94}],130:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

exports.preventDefault = function (event) {
	return event && event.preventDefault && event.preventDefault();
};

exports.Submit = function (event) {
	event && event.preventDefault();
	var c = this;
	while (c && !(c instanceof HTMLFormElement)) c = c.parentNode;
	if (c) c.dispatchEvent(new CustomEvent("submit", null));
	return false;
};

var centered = "\n\twidth: 100%;\n\theight: 100%;\n\tvertical-align: middle;\n\ttext-align: center;\n";

exports.Centered = function (_, content) {
	return React.createElement(
		"table",
		{ style: centered },
		React.createElement(
			"tr",
			{ style: centered },
			React.createElement(
				"td",
				{ style: centered },
				content
			)
		)
	);
};

exports.isEmptyNode = function (node) {
	return node instanceof Comment || node instanceof ProcessingInstruction || node instanceof Text && !node.nodeValue.trim();
};

exports.importTemplate = function (template) {
	return document.importNode(template.content, true);
};

exports.importElement = function (template) {
	var ret = exports.importTemplate(template);
	if (!ret) return null;
	while (ret.lastChild && exports.isEmptyNode(ret.lastChild)) ret.removeChild(ret.lastChild);
	while (ret.firstChild && exports.isEmptyNode(ret.firstChild)) ret.removeChild(ret.firstChild);
	if (!ret.firstChild) return null;
	if (ret.childNodes.length == 1) return ret.childNodes.item(0);
	var root = document.createElement("span");
	root.appendChild(ret);
	return root;
};

exports.importComponent = function (template) {
	var data = exports.importElement(template);
	if (data) {
		var init = data.getElementsByClassName("init")[0];
		if (init && init.type == "init") {
			var finit = new Function("component", [].slice.call(init.childNodes).map(function (x) {
				return x.data || "";
			}).join(""));
			finit(data);
		}
	}
	return data;
};

exports.tickCache = function (fun) {
	var cachedResult = undefined;
	var cached = false;

	var clearCache = function clearCache() {
		cachedResult = null;
		cached = false;
	};

	return function () {
		if (!cached) {
			cachedResult = fun.apply(this, arguments);
			cached = true;
			setImmediate(clearCache);
		}
		return cachedResult;
	};
};

exports.createEvent = function (type, detail, on) {
	var event = new CustomEvent(type, { detail: detail, bubbles: true, cancelable: true });
	if (on) {
		event.pageX = on.pageX;
		event.pageY = on.pageY;
		event.clientX = on.clientX;
		event.clientY = on.clientY;
		event.screenX = on.screenX;
		event.screenY = on.screenY;
	}
	return event;
};

exports.sendEvent = function (type, detail, on) {
	return on.target.dispatchEvent(exports.createEvent(type, detail, on));
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/htmlutils.js","/src")

},{"_process":99,"buffer":94}],131:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var httpClient = {
	get: function get(url, encoding) {
		return httpClient.xhr({ method: "GET", url: url, encoding: encoding });
	},

	post: function post(url, data, encoding) {
		return httpClient.xhr({ method: "POST", url: url, data: data, encoding: encoding });
	},

	xhr: function xhr(options) {
		var method = options.method;
		var url = options.url;
		var encoding = options.encoding;
		var data = options.data;

		var xhr = new XMLHttpRequest();
		if (encoding == "binary") xhr.responseType = "arraybuffer";else xhr.responseType = "text";
		var promise = new Promise(function (resolve, reject) {
			var onerror = function onerror(error) {
				if (typeof error == "string") {
					error = new Error(error);
					error.method = method;
					error.url = url;
				}
				global._ALERT && global._ALERT("try " + error + url);
				reject(error);
			};
			xhr.ontimeout = function () {
				return onerror(new Error("TIMEOUT " + url));
			};
			xhr.onerror = function (e) {
				return onerror(e || "ERROR");
			};
			xhr.onreadystatechange = function () {
				if (xhr.readyState == xhr.DONE && xhr.status == 0) xhr.ontimeout();
			};
			xhr.onload = function () {
				// alert( xhr.status )
				if (xhr.status >= 200 && xhr.status <= 299) return resolve(xhr.response == null ? null : xhr.response);
				if (xhr.status == 401) {
					// append some thing to the page to force standalone browser to show login dialog
					var surl = require("url").parse(url);
					if (surl.host) {
						(function () {
							surl = "" + surl.protocol + "//" + surl.host + "/dummy." + Math.random() + ".js";
							var script = document.createElement("script");
							script.src = surl;
							// alert( surl )
							document.body.appendChild(script);
							setTimeout(function () {
								return document.body.removeChild(script);
							}, 1000);
						})();
					}
				}
				onerror("" + xhr.status + " " + xhr.statusText);
			};
		});
		switch (encoding) {
			case "immutable":
				promise = promise.then(function (data) {
					return Immutable.fromJS(JSON.parse(data));
				});
				break;
			case "binary":
				promise = promise.then(function (data) {
					return new Uint8Array(data);
				});
				break;
			case "text":
				break;
			default:
				promise = promise.then(function (data) {
					var actualEncoding = encoding;
					if (!actualEncoding) {
						var ct = xhr.getResponseHeader("content-type") || "";
						if (ct.match(/^application\/json/)) actualEncoding = "json";
					}
					switch (actualEncoding) {
						case "json":
							return JSON.parse(data);
					}
					return data;
				});
		}
		xhr.open(method || "GET", url);
		xhr.withCredentials = true;
		xhr.send(data);
		xhr.then = promise.then.bind(promise);
		xhr["catch"] = promise["catch"].bind(promise);
		return xhr;
	},

	url: function url(_url, params) {
		params && Object.keys(params).forEach(function (k, i) {
			return _url = _url + (i > 0 ? "&" : "?") + encodeURIComponent(k) + "=" + encodeURIComponent(params[k]);
		});
		return _url;
	}
};

module.exports = httpClient;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/httpClient.js","/src")

},{"_process":99,"buffer":94,"url":104}],132:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

vadzim zienka

2015.05.11
added this.stoppedTransition to not to fire tap when scrolling is stopped by that tap.

 */

/*! iScroll v5.1.3 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */
'use strict';

(function (window, document, Math) {
	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
		window.setTimeout(callback, 1000 / 60);
	};

	var utils = (function () {
		var me = {};

		var _elementStyle = document.createElement('div').style;
		var _vendor = (function () {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			    transform,
			    i = 0,
			    l = vendors.length;

			for (; i < l; i++) {
				transform = vendors[i] + 'ransform';
				if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
			}

			return false;
		})();

		function _prefixStyle(style) {
			if (_vendor === false) return false;
			if (_vendor === '') return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		}

		me.getTime = Date.now || function getTime() {
			return new Date().getTime();
		};

		me.extend = function (target, obj) {
			for (var i in obj) {
				target[i] = obj[i];
			}
		};

		me.addEvent = function (el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};

		me.removeEvent = function (el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};

		me.prefixPointerEvent = function (pointerEvent) {
			return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) : pointerEvent;
		};

		me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
			    speed = Math.abs(distance) / time,
			    destination,
			    duration;

			deceleration = deceleration === undefined ? 0.0006 : deceleration;

			destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
			duration = speed / deceleration;

			if (destination < lowerMargin) {
				destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if (destination > 0) {
				destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}

			return {
				destination: Math.round(destination),
				duration: duration
			};
		};

		var _transform = _prefixStyle('transform');

		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: window.PointerEvent || window.MSPointerEvent, // IE10 is prefixed
			hasTransition: _prefixStyle('transition') in _elementStyle
		});

		// This should find all Android browsers lower than build 535.19 (both stock browser and webview)
		me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !/Chrome\/\d/.test(window.navigator.appVersion);

		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});

		me.hasClass = function (e, c) {
			var re = new RegExp('(^|\\s)' + c + '(\\s|$)');
			return re.test(e.className);
		};

		me.addClass = function (e, c) {
			if (me.hasClass(e, c)) {
				return;
			}

			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};

		me.removeClass = function (e, c) {
			if (!me.hasClass(e, c)) {
				return;
			}

			var re = new RegExp('(^|\\s)' + c + '(\\s|$)', 'g');
			e.className = e.className.replace(re, ' ');
		};

		me.offset = function (el) {
			var left = -el.offsetLeft,
			    top = -el.offsetTop;

			// jshint -W084
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			// jshint +W084

			return {
				left: left,
				top: top
			};
		};

		me.preventDefaultException = function (el, exceptions) {
			for (var i in exceptions) {
				if (exceptions[i].test(el[i])) {
					return true;
				}
			}

			return false;
		};

		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,

			mousedown: 2,
			mousemove: 2,
			mouseup: 2,

			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,

			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});

		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function fn(k) {
					return k * (2 - k);
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
				fn: function fn(k) {
					return Math.sqrt(1 - --k * k);
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function fn(k) {
					var b = 4;
					return (k = k - 1) * k * ((b + 1) * k + b) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function fn(k) {
					if ((k /= 1) < 1 / 2.75) {
						return 7.5625 * k * k;
					} else if (k < 2 / 2.75) {
						return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
					} else if (k < 2.5 / 2.75) {
						return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
					} else {
						return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function fn(k) {
					var f = 0.22,
					    e = 0.4;

					if (k === 0) {
						return 0;
					}
					if (k == 1) {
						return 1;
					}

					return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
				}
			}
		});

		me.tap = function (e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};

		me.click = function (e) {
			var target = e.target,
			    ev;

			if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);

				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};

		return me;
	})();

	function IScroll(el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style; // cache style for better performance

		this.options = {

			resizeScrollbars: true,

			mouseWheelSpeed: 20,

			snapThreshold: 0.334,

			// INSERT POINT: OPTIONS

			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,

			bounce: true,
			bounceTime: 600,
			bounceEasing: '',

			preventDefault: true,
			preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

			HWCompositing: true,
			useTransition: true,
			useTransform: true
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		// Normalize options
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;

		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

		// If you want eventPassthrough I have to lock one of the axes
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

		// With eventPassthrough we also need lockDirection mechanism
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

		if (this.options.tap === true) {
			this.options.tap = 'tap';
		}

		if (this.options.shrinkScrollbars == 'scale') {
			this.options.useTransition = false;
		}

		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

		if (this.options.probeType == 3) {
			this.options.useTransition = false;
		}

		// INSERT POINT: NORMALIZATION

		// Some defaults	
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};

		// INSERT POINT: DEFAULTS

		this._init();
		this.refresh();

		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	}

	IScroll.prototype = {
		version: '5.1.3',

		_init: function _init() {
			this._initEvents();

			if (this.options.scrollbars || this.options.indicators) {
				this._initIndicators();
			}

			if (this.options.mouseWheel) {
				this._initWheel();
			}

			if (this.options.snap) {
				this._initSnap();
			}

			if (this.options.keyBindings) {
				this._initKeys();
			}

			// INSERT POINT: _init
		},

		destroy: function destroy() {
			this._initEvents(true);

			this._execEvent('destroy');
		},

		_transitionEnd: function _transitionEnd(e) {
			if (e.target != this.scroller || !this.isInTransition) {
				return;
			}

			this._transitionTime();
			if (!this.resetPosition(this.options.bounceTime)) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},

		_start: function _start(e) {
			// React to left mouse button only
			if (utils.eventType[e.type] != 1) {
				if (e.button !== 0) {
					return;
				}
			}

			if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    pos;

			this.initiated = utils.eventType[e.type];
			this.moved = false;
			this.distX = 0;
			this.distY = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;

			this._transitionTime();

			this.startTime = utils.getTime();

			this.stoppedTransition = false;
			if (this.options.useTransition && this.isInTransition) {
				this.stoppedTransition = true;
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if (!this.options.useTransition && this.isAnimating) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}

			this.startX = this.x;
			this.startY = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault) {
				// increases performance on Android? TODO: check!
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    deltaX = point.pageX - this.pointX,
			    deltaY = point.pageY - this.pointY,
			    timestamp = utils.getTime(),
			    newX,
			    newY,
			    absDistX,
			    absDistY;

			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this.distX += deltaX;
			this.distY += deltaY;
			absDistX = Math.abs(this.distX);
			absDistY = Math.abs(this.distY);

			// We need to move at least 10 pixels for the scrolling to initiate
			if (timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10)) {
				return;
			}

			// If you are scrolling in one direction lock the other
			if (!this.directionLocked && !this.options.freeScroll) {
				if (absDistX > absDistY + this.options.directionLockThreshold) {
					this.directionLocked = 'h'; // lock horizontally
				} else if (absDistY >= absDistX + this.options.directionLockThreshold) {
					this.directionLocked = 'v'; // lock vertically
				} else {
					this.directionLocked = 'n'; // no lock
				}
			}

			if (this.directionLocked == 'h') {
				if (this.options.eventPassthrough == 'vertical') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'horizontal') {
					this.initiated = false;
					return;
				}

				deltaY = 0;
			} else if (this.directionLocked == 'v') {
				if (this.options.eventPassthrough == 'horizontal') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'vertical') {
					this.initiated = false;
					return;
				}

				deltaX = 0;
			}

			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			// Slow down if outside of the boundaries
			if (newX > 0 || newX < this.maxScrollX) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if (newY > 0 || newY < this.maxScrollY) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}

			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

			if (!this.moved) {
				this._execEvent('scrollStart');
			}

			this.moved = true;

			this._translate(newX, newY);

			/* REPLACE START: _move */
			if (timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;

				if (this.options.probeType == 1) {
					this._execEvent('scroll');
				}
			}

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}
			/* REPLACE END: _move */
		},

		_end: function _end(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.changedTouches ? e.changedTouches[0] : e,
			    momentumX,
			    momentumY,
			    duration = utils.getTime() - this.startTime,
			    newX = Math.round(this.x),
			    newY = Math.round(this.y),
			    distanceX = Math.abs(newX - this.startX),
			    distanceY = Math.abs(newY - this.startY),
			    time = 0,
			    easing = '';

			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();

			// reset if we are outside of the boundaries
			if (this.resetPosition(this.options.bounceTime)) {
				return;
			}

			this.scrollTo(newX, newY); // ensures that the last position is rounded

			// we scrolled less than 10 pixels
			if (!this.moved) {
				if (!this.stoppedTransition) {
					if (this.options.tap) {
						utils.tap(e, this.options.tap);
					}

					if (this.options.click) {
						utils.click(e);
					}
				}

				this._execEvent('scrollCancel');
				return;
			}

			if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
				this._execEvent('flick');
				return;
			}

			// start momentum animation if needed
			if (this.options.momentum && duration < 300) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}

			if (this.options.snap) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
				newX = snap.x;
				newY = snap.y;

				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}

			// INSERT POINT: _end

			if (newX != this.x || newY != this.y) {
				// change easing function when scroller goes out of the boundaries
				if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
					easing = utils.ease.quadratic;
				}

				this.scrollTo(newX, newY, time, easing);
				return;
			}

			this._execEvent('scrollEnd');
		},

		_resize: function _resize() {
			var that = this;

			clearTimeout(this.resizeTimeout);

			this.resizeTimeout = setTimeout(function () {
				that.refresh();
			}, this.options.resizePolling);
		},

		resetPosition: function resetPosition(time) {
			var x = this.x,
			    y = this.y;

			time = time || 0;

			if (!this.hasHorizontalScroll || this.x > 0) {
				x = 0;
			} else if (this.x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (!this.hasVerticalScroll || this.y > 0) {
				y = 0;
			} else if (this.y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			if (x == this.x && y == this.y) {
				return false;
			}

			this.scrollTo(x, y, time, this.options.bounceEasing);

			return true;
		},

		disable: function disable() {
			this.enabled = false;
		},

		enable: function enable() {
			this.enabled = true;
		},

		refresh: function refresh() {
			var rf = this.wrapper.offsetHeight; // Force reflow

			this.wrapperWidth = this.wrapper.clientWidth;
			this.wrapperHeight = this.wrapper.clientHeight;

			/* REPLACE START: refresh */

			this.scrollerWidth = this.scroller.offsetWidth;
			this.scrollerHeight = this.scroller.offsetHeight;

			this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY = this.wrapperHeight - this.scrollerHeight;

			/* REPLACE END: refresh */

			this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

			if (!this.hasHorizontalScroll) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}

			if (!this.hasVerticalScroll) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}

			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;

			this.wrapperOffset = utils.offset(this.wrapper);

			this._execEvent('refresh');

			this.resetPosition();

			// INSERT POINT: _refresh
		},

		on: function on(type, fn) {
			if (!this._events[type]) {
				this._events[type] = [];
			}

			this._events[type].push(fn);
		},

		off: function off(type, fn) {
			if (!this._events[type]) {
				return;
			}

			var index = this._events[type].indexOf(fn);

			if (index > -1) {
				this._events[type].splice(index, 1);
			}
		},

		_execEvent: function _execEvent(type) {
			if (!this._events[type]) {
				return;
			}

			var i = 0,
			    l = this._events[type].length;

			if (!l) {
				return;
			}

			for (; i < l; i++) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},

		scrollBy: function scrollBy(x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;

			this.scrollTo(x, y, time, easing);
		},

		scrollTo: function scrollTo(x, y, time, easing) {
			easing = easing || utils.ease.circular;

			this.isInTransition = this.options.useTransition && time > 0;

			if (!time || this.options.useTransition && easing.style) {
				this._transitionTimingFunction(easing.style);
				this._transitionTime(time);
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},

		scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);

			if (!el) {
				return;
			}

			var pos = utils.offset(el);

			pos.left -= this.wrapperOffset.left;
			pos.top -= this.wrapperOffset.top;

			// if offsetX/Y are true we center the element to the screen
			if (offsetX === true) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if (offsetY === true) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}

			pos.left -= offsetX || 0;
			pos.top -= offsetY || 0;

			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

			this.scrollTo(pos.left, pos.top, time, easing);
		},

		_transitionTime: function _transitionTime(time) {
			time = time || 0;

			this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
			}

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTime(time);
				}
			}

			// INSERT POINT: _transitionTime
		},

		_transitionTimingFunction: function _transitionTimingFunction(easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}

			// INSERT POINT: _transitionTimingFunction
		},

		_translate: function _translate(x, y) {
			if (this.options.useTransform) {

				/* REPLACE START: _translate */

				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

				/* REPLACE END: _translate */
			} else {
				x = Math.round(x);
				y = Math.round(y);
				this.scrollerStyle.left = x + 'px';
				this.scrollerStyle.top = y + 'px';
			}

			this.x = x;
			this.y = y;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].updatePosition();
				}
			}

			// INSERT POINT: _translate
		},

		_initEvents: function _initEvents(remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
			    target = this.options.bindToWrapper ? this.wrapper : window;

			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);

			if (this.options.click) {
				eventType(this.wrapper, 'click', this, true);
			}

			if (!this.options.disableMouse) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}

			if (utils.hasPointer && !this.options.disablePointer) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}

			if (utils.hasTouch && !this.options.disableTouch) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}

			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},

		getComputedPosition: function getComputedPosition() {
			var matrix = window.getComputedStyle(this.scroller, null),
			    x,
			    y;

			if (this.options.useTransform) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}

			return { x: x, y: y };
		},

		_initIndicators: function _initIndicators() {
			var interactive = this.options.interactiveScrollbars,
			    customStyle = typeof this.options.scrollbars != 'string',
			    indicators = [],
			    indicator;

			var that = this;

			this.indicators = [];

			if (this.options.scrollbars) {
				// Vertical scrollbar
				if (this.options.scrollY) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}

				// Horizontal scrollbar
				if (this.options.scrollX) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}

			if (this.options.indicators) {
				// TODO: check concat compatibility
				indicators = indicators.concat(this.options.indicators);
			}

			for (var i = indicators.length; i--;) {
				this.indicators.push(new Indicator(this, indicators[i]));
			}

			// TODO: check if we can use array.map (wide compatibility and performance issues)
			function _indicatorsMap(fn) {
				for (var i = that.indicators.length; i--;) {
					fn.call(that.indicators[i]);
				}
			}

			if (this.options.fadeScrollbars) {
				this.on('scrollEnd', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollCancel', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1);
					});
				});

				this.on('beforeScrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1, true);
					});
				});
			}

			this.on('refresh', function () {
				_indicatorsMap(function () {
					this.refresh();
				});
			});

			this.on('destroy', function () {
				_indicatorsMap(function () {
					this.destroy();
				});

				delete this.indicators;
			});
		},

		_initWheel: function _initWheel() {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

			this.on('destroy', function () {
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},

		_wheel: function _wheel(e) {
			if (!this.enabled) {
				return;
			}

			e.preventDefault();
			e.stopPropagation();

			var wheelDeltaX,
			    wheelDeltaY,
			    newX,
			    newY,
			    that = this;

			if (this.wheelTimeout === undefined) {
				that._execEvent('scrollStart');
			}

			// Execute the scrollEnd event after 400ms the wheel stopped scrolling
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function () {
				that._execEvent('scrollEnd');
				that.wheelTimeout = undefined;
			}, 400);

			if ('deltaX' in e) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ('wheelDeltaX' in e) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ('wheelDelta' in e) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ('detail' in e) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}

			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;

			if (!this.hasVerticalScroll) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}

			if (this.options.snap) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;

				if (wheelDeltaX > 0) {
					newX--;
				} else if (wheelDeltaX < 0) {
					newX++;
				}

				if (wheelDeltaY > 0) {
					newY--;
				} else if (wheelDeltaY < 0) {
					newY++;
				}

				this.goToPage(newX, newY);

				return;
			}

			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

			if (newX > 0) {
				newX = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
			}

			if (newY > 0) {
				newY = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
			}

			this.scrollTo(newX, newY, 0);

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}

			// INSERT POINT: _wheel
		},

		_initSnap: function _initSnap() {
			this.currentPage = {};

			if (typeof this.options.snap == 'string') {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}

			this.on('refresh', function () {
				var i = 0,
				    l,
				    m = 0,
				    n,
				    cx,
				    cy,
				    x = 0,
				    y,
				    stepX = this.options.snapStepX || this.wrapperWidth,
				    stepY = this.options.snapStepY || this.wrapperHeight,
				    el;

				this.pages = [];

				if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
					return;
				}

				if (this.options.snap === true) {
					cx = Math.round(stepX / 2);
					cy = Math.round(stepY / 2);

					while (x > -this.scrollerWidth) {
						this.pages[i] = [];
						l = 0;
						y = 0;

						while (y > -this.scrollerHeight) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};

							y -= stepY;
							l++;
						}

						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;

					for (; i < l; i++) {
						if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
							m = 0;
							n++;
						}

						if (!this.pages[m]) {
							this.pages[m] = [];
						}

						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);

						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};

						if (x > this.maxScrollX) {
							m++;
						}
					}
				}

				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

				// Update snap threshold if needed
				if (this.options.snapThreshold % 1 === 0) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});

			this.on('flick', function () {
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);

				this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
			});
		},

		_nearestSnap: function _nearestSnap(x, y) {
			if (!this.pages.length) {
				return { x: 0, y: 0, pageX: 0, pageY: 0 };
			}

			var i = 0,
			    l = this.pages.length,
			    m = 0;

			// Check if we exceeded the snap threshold
			if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
				return this.currentPage;
			}

			if (x > 0) {
				x = 0;
			} else if (x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (y > 0) {
				y = 0;
			} else if (y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			for (; i < l; i++) {
				if (x >= this.pages[i][0].cx) {
					x = this.pages[i][0].x;
					break;
				}
			}

			l = this.pages[i].length;

			for (; m < l; m++) {
				if (y >= this.pages[0][m].cy) {
					y = this.pages[0][m].y;
					break;
				}
			}

			if (i == this.currentPage.pageX) {
				i += this.directionX;

				if (i < 0) {
					i = 0;
				} else if (i >= this.pages.length) {
					i = this.pages.length - 1;
				}

				x = this.pages[i][0].x;
			}

			if (m == this.currentPage.pageY) {
				m += this.directionY;

				if (m < 0) {
					m = 0;
				} else if (m >= this.pages[0].length) {
					m = this.pages[0].length - 1;
				}

				y = this.pages[0][m].y;
			}

			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},

		goToPage: function goToPage(x, y, time, easing) {
			easing = easing || this.options.bounceEasing;

			if (x >= this.pages.length) {
				x = this.pages.length - 1;
			} else if (x < 0) {
				x = 0;
			}

			if (y >= this.pages[x].length) {
				y = this.pages[x].length - 1;
			} else if (y < 0) {
				y = 0;
			}

			var posX = this.pages[x][y].x,
			    posY = this.pages[x][y].y;

			time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;

			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};

			this.scrollTo(posX, posY, time, easing);
		},

		next: function next(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x++;

			if (x >= this.pages.length && this.hasVerticalScroll) {
				x = 0;
				y++;
			}

			this.goToPage(x, y, time, easing);
		},

		prev: function prev(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x--;

			if (x < 0 && this.hasVerticalScroll) {
				x = 0;
				y--;
			}

			this.goToPage(x, y, time, easing);
		},

		_initKeys: function _initKeys(e) {
			// default key bindings
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;

			// if you give me characters I give you keycode
			if (typeof this.options.keyBindings == 'object') {
				for (i in this.options.keyBindings) {
					if (typeof this.options.keyBindings[i] == 'string') {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}

			for (i in keys) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}

			utils.addEvent(window, 'keydown', this);

			this.on('destroy', function () {
				utils.removeEvent(window, 'keydown', this);
			});
		},

		_key: function _key(e) {
			if (!this.enabled) {
				return;
			}

			var snap = this.options.snap,
			    // we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			    newY = snap ? this.currentPage.pageY : this.y,
			    now = utils.getTime(),
			    prevTime = this.keyTime || 0,
			    acceleration = 0.25,
			    pos;

			if (this.options.useTransition && this.isInTransition) {
				pos = this.getComputedPosition();

				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}

			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

			switch (e.keyCode) {
				case this.options.keyBindings.pageUp:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX += snap ? 1 : this.wrapperWidth;
					} else {
						newY += snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.pageDown:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX -= snap ? 1 : this.wrapperWidth;
					} else {
						newY -= snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.end:
					newX = snap ? this.pages.length - 1 : this.maxScrollX;
					newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
					break;
				case this.options.keyBindings.home:
					newX = 0;
					newY = 0;
					break;
				case this.options.keyBindings.left:
					newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.up:
					newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.right:
					newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.down:
					newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				default:
					return;
			}

			if (snap) {
				this.goToPage(newX, newY);
				return;
			}

			if (newX > 0) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}

			if (newY > 0) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}

			this.scrollTo(newX, newY, 0);

			this.keyTime = now;
		},

		_animate: function _animate(destX, destY, duration, easingFn) {
			var that = this,
			    startX = this.x,
			    startY = this.y,
			    startTime = utils.getTime(),
			    destTime = startTime + duration;

			function step() {
				var now = utils.getTime(),
				    newX,
				    newY,
				    easing;

				if (now >= destTime) {
					that.isAnimating = false;
					that._translate(destX, destY);

					if (!that.resetPosition(that.options.bounceTime)) {
						that._execEvent('scrollEnd');
					}

					return;
				}

				now = (now - startTime) / duration;
				easing = easingFn(now);
				newX = (destX - startX) * easing + startX;
				newY = (destY - startY) * easing + startY;
				that._translate(newX, newY);

				if (that.isAnimating) {
					rAF(step);
				}

				if (that.options.probeType == 3) {
					that._execEvent('scroll');
				}
			}

			this.isAnimating = true;
			step();
		},

		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
				case 'orientationchange':
				case 'resize':
					this._resize();
					break;
				case 'transitionend':
				case 'webkitTransitionEnd':
				case 'oTransitionEnd':
				case 'MSTransitionEnd':
					this._transitionEnd(e);
					break;
				case 'wheel':
				case 'DOMMouseScroll':
				case 'mousewheel':
					this._wheel(e);
					break;
				case 'keydown':
					this._key(e);
					break;
				case 'click':
					if (!e._constructed) {
						e.preventDefault();
						e.stopPropagation();
					}
					break;
			}
		}
	};
	function createDefaultScrollbar(direction, interactive, type) {
		var scrollbar = document.createElement('div'),
		    indicator = document.createElement('div');

		if (type === true) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}

		indicator.className = 'iScrollIndicator';

		if (direction == 'h') {
			if (type === true) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if (type === true) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}

		scrollbar.style.cssText += ';overflow:hidden';

		if (!interactive) {
			scrollbar.style.pointerEvents = 'none';
		}

		scrollbar.appendChild(indicator);

		return scrollbar;
	}

	function Indicator(scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;

		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;

		if (this.options.interactive) {
			if (!this.options.disableTouch) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}

		if (this.options.fade) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
			this.wrapperStyle.opacity = '0';
		}
	}

	Indicator.prototype = {
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
			}
		},

		destroy: function destroy() {
			if (this.options.interactive) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);

				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);

				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}

			if (this.options.defaultScrollbars) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},

		_start: function _start(e) {
			var point = e.touches ? e.touches[0] : e;

			e.preventDefault();
			e.stopPropagation();

			this.transitionTime();

			this.initiated = true;
			this.moved = false;
			this.lastPointX = point.pageX;
			this.lastPointY = point.pageY;

			this.startTime = utils.getTime();

			if (!this.options.disableTouch) {
				utils.addEvent(window, 'touchmove', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(window, 'mousemove', this);
			}

			this.scroller._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			var point = e.touches ? e.touches[0] : e,
			    deltaX,
			    deltaY,
			    newX,
			    newY,
			    timestamp = utils.getTime();

			if (!this.moved) {
				this.scroller._execEvent('scrollStart');
			}

			this.moved = true;

			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;

			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			this._pos(newX, newY);

			if (this.scroller.options.probeType == 1 && timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.scroller._execEvent('scroll');
			} else if (this.scroller.options.probeType > 1) {
				this.scroller._execEvent('scroll');
			}

			// INSERT POINT: indicator._move

			e.preventDefault();
			e.stopPropagation();
		},

		_end: function _end(e) {
			if (!this.initiated) {
				return;
			}

			this.initiated = false;

			e.preventDefault();
			e.stopPropagation();

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			if (this.scroller.options.snap) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

				if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}

			if (this.moved) {
				this.scroller._execEvent('scrollEnd');
			}
		},

		transitionTime: function transitionTime(time) {
			time = time || 0;
			this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
			}
		},

		transitionTimingFunction: function transitionTimingFunction(easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},

		refresh: function refresh() {
			this.transitionTime();

			if (this.options.listenX && !this.options.listenY) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if (this.options.listenY && !this.options.listenX) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}

			if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}

			var r = this.wrapper.offsetHeight; // force refresh

			if (this.options.listenX) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if (this.options.resize) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}

				this.maxPosX = this.wrapperWidth - this.indicatorWidth;

				if (this.options.shrink == 'clip') {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}

				this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
			}

			if (this.options.listenY) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if (this.options.resize) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;

				if (this.options.shrink == 'clip') {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
			}

			this.updatePosition();
		},

		updatePosition: function updatePosition() {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			    y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

			if (!this.options.ignoreBoundaries) {
				if (x < this.minBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if (x > this.maxBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}

				if (y < this.minBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if (y > this.maxBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}

			this.x = x;
			this.y = y;

			if (this.scroller.options.useTransform) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},

		_pos: function _pos(x, y) {
			if (x < 0) {
				x = 0;
			} else if (x > this.maxPosX) {
				x = this.maxPosX;
			}

			if (y < 0) {
				y = 0;
			} else if (y > this.maxPosY) {
				y = this.maxPosY;
			}

			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

			this.scroller.scrollTo(x, y);
		},

		fade: function fade(val, hold) {
			if (hold && !this.visible) {
				return;
			}

			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;

			var time = val ? 250 : 500,
			    delay = val ? 0 : 300;

			val = val ? '1' : '0';

			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

			this.fadeTimeout = setTimeout((function (val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}).bind(this, val), delay);
		}
	};

	IScroll.utils = utils;

	if (typeof module != 'undefined' && module.exports) {
		module.exports = IScroll;
	} else {
		window.IScroll = IScroll;
	}
})(window, document, Math);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/iscroll.js","/src")

},{"_process":99,"buffer":94}],133:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = new (require("scheduler"))();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/later.js","/src")

},{"_process":99,"buffer":94,"scheduler":137}],134:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var co = require("co");

var NON_PARTIAL = Object.create(null);
NON_PARTIAL.__partial__ = false;

var PARTIAL = Object.create(null);

function assert(value, message) {
	if (!value) throw new Error("" + message);
}

var LiteralPrototype = Object.getPrototypeOf({});

var lu = module.exports = {

	dumpPromise: function dumpPromise(p) {
		return p.then(function (result) {
			return lu.log("result:", result);
		}, function (error) {
			return lu.error("error:", error);
		});
	},

	dump: function dump(msg, value) {
		console.log(msg, value);
		return value;
	},

	log: console.log.bind(console),
	info: (console.info || console.log).bind(console),
	warn: (console.warn || console.log).bind(console),
	error: (console.error || console.log).bind(console),
	trace: (console.trace || console.log).bind(console),

	mapObj: function mapObj(obj, props) {
		var ret = Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
		lodash.forEach(props, function (fun, key) {
			return ret[key] = typeof fun == "function" ? fun(obj[key]) : fun;
		});
		return ret;
	},

	rests: function rests(num) {
		for (var _len = arguments.length, _rests = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			_rests[_key - 1] = arguments[_key];
		}

		var ret = [];
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = _rests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var r = _step.value;

				var n = num % r;
				num = (num - n) / r;
				ret.push(n);
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator["return"]) {
					_iterator["return"]();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return ret;
	},

	pad: function pad(s, n, p) {
		s = String(s);
		var x = "";
		n -= s.length;
		while (n > 0) {
			x += p;
			--n;
		}
		return x + s;
	},

	time: function time() {
		var d = new Date();
		return "" + d.getHours() + ":" + lu.pad(d.getMinutes(), 2, 0) + ":" + lu.pad(d.getSeconds(), 2, 0) + "." + lu.pad(d.getMilliseconds(), 3, 0);
	},

	stack: function stack() {
		return new Error().stack;
	},

	options: function options(_options, def) {
		var ret = {};
		for (var i in def) {
			if (Object.prototype.hasOwnProperty.call(def, i)) if (_options == null) ret[i] = def[i];else {
				var op = _options[i];
				if (op == null) op = def[i];
				ret[i] = op;
			}
		}return ret;
	},

	str: function str(obj, depth) {
		if (depth == null) depth = 1;
		if (!obj || !depth || depth < 1) return "" + obj;
		if (Array.isArray(obj)) return "[ " + obj.map(function (x) {
			return lu.str(x, depth - 1);
		}).join(" ") + " ]";
		if (!obj.constructor || obj.constructor == Object) return "{ " + Object.keys(obj).map(function (x) {
			return x + "=" + lu.str(obj[x], depth - 1);
		}).join(" ") + " }";
		return String(obj);
	},

	toOneLine: function toOneLine(obj) {
		var ret = JSON.stringify(obj);
		ret += "\n";
		return ret;
	},

	byLines: function byLines(callback) {
		var buffer = "";
		return function (chunk) {
			buffer += String(chunk);
			var ret = buffer.split("\n");
			buffer = ret.pop();
			ret.forEach(callback);
		};
	},

	byJSON: function byJSON(callback) {
		return byLines(function (line) {
			return callback(JSON.parse(line.trim()));
		});
	},

	valueOf: function valueOf(val) {
		return val == null ? null : val.valueOf == null ? val : val.valueOf();
	},

	returnThis: function returnThis() {
		return this;
	},
	returnNull: function returnNull() {
		return null;
	},
	returnTrue: function returnTrue() {
		return true;
	},
	returnFalse: function returnFalse() {
		return false;
	},
	returnZero: function returnZero() {
		return 0;
	},
	returnOne: function returnOne() {
		return 1;
	},

	promiseSucceeded: Promise.resolve(),
	promiseNull: Promise.resolve(null),
	promiseTrue: Promise.resolve(true),
	promiseFalse: Promise.resolve(false),
	promiseZero: Promise.resolve(0),
	promiseOne: Promise.resolve(1),

	returnNullPromise: function returnNullPromise() {
		return lu.promiseNull;
	},
	returnTruePromise: function returnTruePromise() {
		return lu.promiseTrue;
	},
	returnFalsePromise: function returnFalsePromise() {
		return lu.promiseFalse;
	},
	returnZeroPromise: function returnZeroPromise() {
		return lu.promiseZero;
	},
	returnOnePromise: function returnOnePromise() {
		return lu.promiseOne;
	},

	when: function when(promise, cb) {
		if (promise != null) promise.then(cb, cb);else process.nextTick(cb);
		return promise;
	},

	waitFor: function waitFor(timeout, interval, callback) {
		if (typeof timeout == "function") {
			interval = timeout;
			timeout = 5000;
		}
		if (typeof interval == "function") {
			callback = interval;
			interval = 200;
		}
		return new Promise(function (resolve, reject) {
			var start = Date.now();
			setTimeout(function check() {
				var ret = undefined;
				if (ret = callback()) resolve(ret);else if (Date.now() - start > timeout) reject(new Error("timeout"));else setTimeout(check, interval);
			}, interval);
		});
	},

	empty: Object.freeze(Object.create(null)),

	JSONEqual: function JSONEqual(a, b) {
		return JSON.stringify(a) == JSON.stringify(b);
	},

	"new": function _new() {
		for (var _len2 = arguments.length, descedents = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			descedents[_key2] = arguments[_key2];
		}

		return Object.assign.apply(Object, [{}].concat(descedents));
	},

	call: function call(fun) {
		for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
			args[_key3 - 1] = arguments[_key3];
		}

		return fun.apply(undefined, args);
	},

	rethrow: function rethrow(e) {
		setTimeout(function () {
			throw e;
		}, 1);
	},

	// optimization -- using try/catch in a separate function.
	"catch": function _catch(cb, ret) {
		try {
			return cb();
		} catch (e) {
			return ret(e);
		}
	},

	catchMap: function catchMap(cb, mapResult, mapError) {
		var result = undefined;
		try {
			result = cb();
		} catch (error) {
			return mapError(error);
		}
		return mapResult(result);
	},

	catchCall: function catchCall(cb) {
		try {
			return { ok: true, result: cb() };
		} catch (error) {
			return { ok: false, error: error };
		}
	},

	"try": regeneratorRuntime.mark(function _try(fun) {
		var startTimeToWait = arguments[1] === undefined ? 100 : arguments[1];
		var maxTimeToWait = arguments[2] === undefined ? 3000 : arguments[2];
		var multiply = arguments[3] === undefined ? 1.5 : arguments[3];
		var timeToWait;
		return regeneratorRuntime.wrap(function _try$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					timeToWait = startTimeToWait;

				case 1:
					context$1$0.prev = 1;
					context$1$0.next = 4;
					return fun();

				case 4:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 7:
					context$1$0.prev = 7;
					context$1$0.t0 = context$1$0["catch"](1);

					lu.rethrow(context$1$0.t0);
					context$1$0.next = 12;
					return co.sleep(timeToWait);

				case 12:
					timeToWait = Math.min(timeToWait * multiply, maxTimeToWait);

				case 13:
					context$1$0.next = 1;
					break;

				case 15:
				case "end":
					return context$1$0.stop();
			}
		}, _try, this, [[1, 7]]);
	}),

	unique: function unique(value, index, array) {
		return index == 0 || value != array[index - 1];
	},

	joinData: function joinData(array) {
		return array.length == 0 ? "" : typeof array[0] == "string" ? array.join("") : Buffer.isBuffer(array[0]) ? Buffer.concat(array) : array.join("");
	},

	on: function on(emitter, events) {
		lodash.forEach(events, function (handler, event) {
			return emitter.on(event, handler);
		});
	},

	off: function off(emitter, events) {
		lodash.forEach(events, function (handler, event) {
			return emitter.removeListener(event, handler);
		});
	},

	readStream: regeneratorRuntime.mark(function readStream(stream) {
		return regeneratorRuntime.wrap(function readStream$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return { then: function then(resolve, reject) {
							var content = [];
							stream.on("data", function (chunk) {
								return content.push(chunk);
							});
							stream.on("end", function () {
								return resolve(lu.joinData(content));
							});
							stream.on("error", reject);
						} };

				case 2:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 3:
				case "end":
					return context$1$0.stop();
			}
		}, readStream, this);
	}),

	readJSON: regeneratorRuntime.mark(function readJSON(stream) {
		return regeneratorRuntime.wrap(function readJSON$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return lu.readStream(stream);

				case 2:
					context$1$0.t0 = context$1$0.sent;
					return context$1$0.abrupt("return", JSON.parse(context$1$0.t0));

				case 4:
				case "end":
					return context$1$0.stop();
			}
		}, readJSON, this);
	}),

	readChunk: regeneratorRuntime.mark(function readChunk(stream) {
		return regeneratorRuntime.wrap(function readChunk$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return { then: function then(resolve, reject) {
							stream.on("data", onData);
							stream.on("end", onEnd);
							stream.on("error", onError);
							function done() {
								stream.removeListener("data", onData);
								stream.removeListener("end", onEnd);
								stream.removeListener("error", onError);
							}
							function onData(chunk) {
								done();
								resolve(chunk);
							}
							function onEnd() {
								done();
								resolve(null);
							}
							function onError(error) {
								done();
								reject(error);
							}
						} };

				case 2:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 3:
				case "end":
					return context$1$0.stop();
			}
		}, readChunk, this);
	}),

	"static": function _static(fun) {
		return co.func(regeneratorRuntime.mark(function callee$1$0(request, response) {
			var headWritten, responseEnded, body;
			return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						headWritten = false, responseEnded = false;
						context$2$0.prev = 1;
						context$2$0.next = 4;
						return fun();

					case 4:
						body = context$2$0.sent;

						response.writeHead(200, _defineProperty({}, "Content-Type", "text/html; charset=UTF-8"));
						headWritten = true;
						if (typeof body != "string") body = React.renderComponentToString(body);
						response.end(body);
						responseEnded = true;

					case 10:
						context$2$0.prev = 10;

						if (!headWritten) response.writeHead(500, _defineProperty({}, "Content-Type", "text/plain"));
						if (!responseEnded) response.end("<<< ERROR >>>");
						return context$2$0.finish(10);

					case 14:
					case "end":
						return context$2$0.stop();
				}
			}, callee$1$0, this, [[1,, 10, 14]]);
		}));
	},

	property: function property(obj, name, defaultValue) {
		var privateName = "_" + name;
		if (arguments.length > 2) obj[privateName] = defaultValue;
		obj[name] = function (value) {
			if (arguments.length == 0) return obj[privateName];else {
				obj[privateName] = value;
				return obj;
			}
		};
		return obj;
	},

	polling: function polling(stream) {
		var ret = {
			stop: function stop() {
				if (!ret) return;
				if (ret._polling != null) {
					clearTimeout(ret._polling);
					ret._polling = null;
				}
				ret = null;
			},
			_polling: null,
			_tryToSendChunk: function _tryToSendChunk() {
				if (!ret) return;
				ret._polling = null;
				if (!stream.write(ret._chunk)) stream.once("drain", ret._tryToSendChunk);else {
					if (typeof stream.flush == "function") stream.flush();
					ret._polling = setTimeout(ret._tryToSendChunk, ret._interval);
				}
			}
		};

		lu.property(ret, "chunk", "\n");
		lu.property(ret, "interval", 60000);

		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("end", ret.stop);
		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("close", ret.stop);
		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("error", ret.stop);

		process.nextTick(ret._tryToSendChunk);

		return ret;
	},

	testDiff: function testDiff() {
		var p = { a: 1, x: { u: 9 } };
		var q = { x: { c: 2 } };
		assert(JSON.stringify(q) == JSON.stringify(lu.applyDiff(p, lu.makeDiff(p, q))));
	},

	isSet: function isSet(obj) {
		if (obj == null) return false;
		var proto = Object.getPrototypeOf(obj);
		return proto === LiteralPrototype || proto === null;
	},

	applyDiff: function applyDiff(dest, diff, partial) {
		var ret = dest;
		var cnt = 0;

		function copyDest() {
			ret = Object.create(null);
			for (var key in dest) {
				if (Object.prototype.hasOwnProperty.call(dest, key)) {
					var value = dest[key];
					if (value === undefined) continue;
					ret[key] = dest[key];
					++cnt;
				}
			}
		}

		if (diff && diff.__partial__ === false) partial = false;

		for (var key in diff) {
			if (key != "__partial__" && Object.prototype.hasOwnProperty.call(diff, key)) {
				var value = diff[key];
				if (value === undefined) continue;
				if (value != null && typeof value == "object") value = lu.applyDiff(ret && ret[key], value, partial);
				if (value == null) {
					if (ret != null && Object.prototype.hasOwnProperty.call(ret, key)) {
						if (ret === dest) copyDest();
						delete ret[key];
						--cnt;
					}
				} else {
					if (ret == null || ret[key] !== value) {
						if (ret === dest) copyDest();
						ret[key] = value;
					}
					cnt = Infinity;
				}
			}
		}if (partial === false) for (var key in ret) {
			if (Object.prototype.hasOwnProperty.call(ret, key)) {
				if (!Object.prototype.hasOwnProperty.call(diff, key) || diff[key] === undefined) {
					if (ret === dest) copyDest();
					delete ret[key];
					--cnt;
				} else cnt = Infinity;
			}
		}if (ret !== dest && cnt == 0) ret = null;

		return ret;
	},

	mergeDiffs: function mergeDiffs(a, b) {

		if (a == null) a = NON_PARTIAL;
		if (b == null) b = NON_PARTIAL;

		if (b.__partial__ === false) return b;

		var ret = a;

		function copyDest() {
			ret = Object.create(null);
			for (var key in a) {
				if (Object.prototype.hasOwnProperty.call(a, key)) {
					var value = a[key];
					if (value === undefined) continue;
					ret[key] = a[key];
				}
			}
		}

		for (var key in b) {
			if (Object.prototype.hasOwnProperty.call(b, key)) {
				var value = b[key];
				if (value === undefined) continue;
				if (value == null) value = NON_PARTIAL;
				if (typeof value == "object") {
					var r = ret ? ret[key] : undefined;
					if (r === undefined) r = PARTIAL;
					value = lu.mergeDiffs(r, value);
				}
				if (ret == null || ret[key] !== value) {
					if (ret === a) copyDest();
					ret[key] = value;
				}
			}
		}if (ret !== a && typeof a != "object") ret.__partial__ = false;

		return ret;
	},

	makeDiff: function makeDiff(previous, next) {
		if (previous === next) return undefined;
		var ret = undefined;
		function toArray(obj) {
			var ret = [];
			lodash.forEach(obj, function (value, key) {
				return ret.push({ value: value, key: key });
			});
			return ret.sort(function (v1, v2) {
				return v1.key < v2.key ? -1 : v1.key > v2.key ? 1 : 0;
			});
		}
		var pa = toArray(previous);
		var na = toArray(next);
		var p = pa.pop();
		var n = na.pop();
		while (p || n) {
			if (!n || p && p.key > n.key) {
				if (!ret) ret = Object.create(null);
				ret[p.key] = null; // deleting
				p = pa.pop();
			} else if (!p || p.key < n.key) {
				if (!ret) ret = Object.create(null);
				ret[n.key] = n.value;
				n = na.pop();
			} else {
				if (p.value !== n.value) {
					if (lu.isSet(p.value) && lu.isSet(n.value)) {
						var diff = lu.makeDiff(p.value, n.value);
						if (diff) {
							if (!ret) ret = Object.create(null);
							ret[n.key] = diff;
						}
					} else {
						if (!ret) ret = Object.create(null);
						ret[n.key] = n.value;
					}
				}
				p = pa.pop();
				n = na.pop();
			}
		}
		return ret ? ret : undefined;
	},

	concatString: function concatString(array) {
		var ret = "";
		!(function walk(array) {
			if (typeof array != "object") ret += array;else if (array.length != null) array.forEach(walk);else {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _s = _step2.value;

						walk(_s);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		})(array);
		return ret;
	},

	sortedDiff: function sortedDiff(first, second) {
		var fi = first[Symbol.iterator]();
		var si = second[Symbol.iterator]();
		var ret = {
			common: [],
			first: [],
			second: []
		};
		var fv = fi.next(),
		    sv = si.next();
		while (!fv.done || !sv.done) {
			if (sv.done || fv.value < sv.value) {
				ret.first.push(fv.value);
				fv = fi.next();
			} else if (fv.done || fv.value > sv.value) {
				ret.second.push(sv.value);
				sv = si.next();
			} else {
				ret.common.push(fv.value);
				fv = fi.next();
				sv = si.next();
			}
		}
		return ret;
	},

	measure: function measure(fun) {
		var now = global.performance || global.Date;
		var t = now.now();
		try {
			return fun();
		} finally {
			t = (now.now() - t) / 1000;
			if (t > 0) {
				var i = 1;
				while (t < 1000) {
					i *= 10;
					t *= 10;
				}
				t = Math.round(t) / i;
			}
			console.log(t);
		}
	},

	skip: regeneratorRuntime.mark(function skip(c, buf) {
		var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, b;

		return regeneratorRuntime.wrap(function skip$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion3 = true;
					_didIteratorError3 = false;
					_iteratorError3 = undefined;
					context$1$0.prev = 3;
					_iterator3 = buf[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
						context$1$0.next = 16;
						break;
					}

					b = _step3.value;

					if (!(c > 0)) {
						context$1$0.next = 11;
						break;
					}

					--c;
					context$1$0.next = 13;
					break;

				case 11:
					context$1$0.next = 13;
					return b;

				case 13:
					_iteratorNormalCompletion3 = true;
					context$1$0.next = 5;
					break;

				case 16:
					context$1$0.next = 22;
					break;

				case 18:
					context$1$0.prev = 18;
					context$1$0.t0 = context$1$0["catch"](3);
					_didIteratorError3 = true;
					_iteratorError3 = context$1$0.t0;

				case 22:
					context$1$0.prev = 22;
					context$1$0.prev = 23;

					if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
						_iterator3["return"]();
					}

				case 25:
					context$1$0.prev = 25;

					if (!_didIteratorError3) {
						context$1$0.next = 28;
						break;
					}

					throw _iteratorError3;

				case 28:
					return context$1$0.finish(25);

				case 29:
					return context$1$0.finish(22);

				case 30:
				case "end":
					return context$1$0.stop();
			}
		}, skip, this, [[3, 18, 22, 30], [23,, 25, 29]]);
	}),

	take: regeneratorRuntime.mark(function take(c, buf) {
		var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, b;

		return regeneratorRuntime.wrap(function take$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion4 = true;
					_didIteratorError4 = false;
					_iteratorError4 = undefined;
					context$1$0.prev = 3;
					_iterator4 = buf[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
						context$1$0.next = 17;
						break;
					}

					b = _step4.value;

					if (!(c > 0)) {
						context$1$0.next = 13;
						break;
					}

					--c;
					context$1$0.next = 11;
					return b;

				case 11:
					context$1$0.next = 14;
					break;

				case 13:
					return context$1$0.abrupt("break", 17);

				case 14:
					_iteratorNormalCompletion4 = true;
					context$1$0.next = 5;
					break;

				case 17:
					context$1$0.next = 23;
					break;

				case 19:
					context$1$0.prev = 19;
					context$1$0.t0 = context$1$0["catch"](3);
					_didIteratorError4 = true;
					_iteratorError4 = context$1$0.t0;

				case 23:
					context$1$0.prev = 23;
					context$1$0.prev = 24;

					if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
						_iterator4["return"]();
					}

				case 26:
					context$1$0.prev = 26;

					if (!_didIteratorError4) {
						context$1$0.next = 29;
						break;
					}

					throw _iteratorError4;

				case 29:
					return context$1$0.finish(26);

				case 30:
					return context$1$0.finish(23);

				case 31:
				case "end":
					return context$1$0.stop();
			}
		}, take, this, [[3, 19, 23, 31], [24,, 26, 30]]);
	}),

	copy: function copy(buf) {
		var ret = lu.array(buf);
		if (ret == buf) ret = buf.slice();
		return ret;
	},

	array1: function array1(value) {
		if (Array.isArray(value)) return value;else return [value];
	},

	array: function array(buf) {
		if (Array.isArray(buf)) return buf;
		var ret = [];
		if (!buf[Symbol.iterator]) for (var i = 0; i < buf.length; ++i) {
			ret.push(buf[i]);
		} else {
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = buf[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var _b = _step5.value;

					ret.push(_b);
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
						_iterator5["return"]();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}return ret;
	},

	buffer: function buffer(buf) {
		if (buf instanceof Buffer) return buf;else return new Buffer(lu.array(buf));
	},

	vector: function vector(buf) {
		return buf instanceof Buffer ? buf : lu.array(buf);
	},

	concat: regeneratorRuntime.mark(function concat(list) {
		var _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, l, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, x;

		return regeneratorRuntime.wrap(function concat$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion6 = true;
					_didIteratorError6 = false;
					_iteratorError6 = undefined;
					context$1$0.prev = 3;
					_iterator6 = list[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
						context$1$0.next = 36;
						break;
					}

					l = _step6.value;
					_iteratorNormalCompletion7 = true;
					_didIteratorError7 = false;
					_iteratorError7 = undefined;
					context$1$0.prev = 10;
					_iterator7 = l[Symbol.iterator]();

				case 12:
					if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
						context$1$0.next = 19;
						break;
					}

					x = _step7.value;
					context$1$0.next = 16;
					return x;

				case 16:
					_iteratorNormalCompletion7 = true;
					context$1$0.next = 12;
					break;

				case 19:
					context$1$0.next = 25;
					break;

				case 21:
					context$1$0.prev = 21;
					context$1$0.t0 = context$1$0["catch"](10);
					_didIteratorError7 = true;
					_iteratorError7 = context$1$0.t0;

				case 25:
					context$1$0.prev = 25;
					context$1$0.prev = 26;

					if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
						_iterator7["return"]();
					}

				case 28:
					context$1$0.prev = 28;

					if (!_didIteratorError7) {
						context$1$0.next = 31;
						break;
					}

					throw _iteratorError7;

				case 31:
					return context$1$0.finish(28);

				case 32:
					return context$1$0.finish(25);

				case 33:
					_iteratorNormalCompletion6 = true;
					context$1$0.next = 5;
					break;

				case 36:
					context$1$0.next = 42;
					break;

				case 38:
					context$1$0.prev = 38;
					context$1$0.t1 = context$1$0["catch"](3);
					_didIteratorError6 = true;
					_iteratorError6 = context$1$0.t1;

				case 42:
					context$1$0.prev = 42;
					context$1$0.prev = 43;

					if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
						_iterator6["return"]();
					}

				case 45:
					context$1$0.prev = 45;

					if (!_didIteratorError6) {
						context$1$0.next = 48;
						break;
					}

					throw _iteratorError6;

				case 48:
					return context$1$0.finish(45);

				case 49:
					return context$1$0.finish(42);

				case 50:
				case "end":
					return context$1$0.stop();
			}
		}, concat, this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
	}),

	word: function word(w) {
		return [w & 255, w >> 8 & 255];
	},

	dword: function dword(w) {
		return [w & 255, w >> 8 & 255, w >> 16 & 255, w >> 24 & 255];
	},

	makeWord: function makeWord(lo, hi) {
		return (lo & 255) + (hi & 255) << 8;
	},

	arrayEqual: function arrayEqual(a, b) {
		return a && b && a.length == b.length && a.every(function (ai, i) {
			return ai == b[i];
		});
	},

	compare: function compare(a, b) {
		if (a == b) return 0;
		if (a < b) return -1;
		return 1;
	},

	formatms: function formatms(value) {
		var ret = "";
		value = Math.round(value);
		var ms = value % 1000;
		value -= ms;
		value /= 1000;
		var s = value % 60;
		value -= s;
		value /= 60;
		var m = value % 60;
		value -= m;
		value /= 60;
		var h = value;
		ret += h ? h : "";
		ret += ret ? ":" + z(m, 2) : m ? m : "";
		ret += ret ? ":" + z(s, 2) : s;
		ret += "." + z(ms, 3);
		return ret;
		function z(value, len) {
			var str = String(value);
			var ret = "";
			for (var i = str.length; i < len; ++i) {
				ret += "0";
			}ret += str;
			return ret;
		}
	},

	get: function get(obj) {
		for (var _len4 = arguments.length, path = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
			path[_key4 - 1] = arguments[_key4];
		}

		var _iteratorNormalCompletion8 = true;
		var _didIteratorError8 = false;
		var _iteratorError8 = undefined;

		try {
			for (var _iterator8 = path[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
				var p = _step8.value;

				if (obj == null) break;else obj = obj[p];
			}
		} catch (err) {
			_didIteratorError8 = true;
			_iteratorError8 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion8 && _iterator8["return"]) {
					_iterator8["return"]();
				}
			} finally {
				if (_didIteratorError8) {
					throw _iteratorError8;
				}
			}
		}

		return obj;
	},

	limitCalls: function limitCalls(limit, period, message) {
		var calls = 0;
		return function () {
			if (calls >= limit) if (message) throw new Error.create(message);else return false;
			++calls;
			setTimeout(function () {
				return --calls;
			}, period);
			return true;
		};
	}

};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/localUtils.js","/src")

},{"_process":99,"buffer":94,"co":125,"lodash":116}],135:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

Object.defineProperty(Object.prototype, "_LOG_", { value: function value() {
		console.log(this);
		return this;
	}, configurable: true });

if (typeof Symbol == "function" && Symbol.iterator) {
	var x = null;
	try {
		x = eval.call(null, "(function*(){}().constructor.prototype)");
	} catch (_) {}
	if (x && !x[Symbol.iterator]) x[Symbol.iterator] = function () {
		return this;
	};
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/platform.js","/src")

},{"_process":99,"buffer":94}],136:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

TODO:

* Warning if a live property has not been read during the life time of observable value or during some period of time (e.g. 1-30 minutes) since creating that observable value.

* check for changes during execution of (function*) and restart calculus.


TODO BUG:
let app = ra.clean( {
	moving1: {
		a: 1,
		b: 2,
		c: {
			d: 3,
		},
	},
}
_app.moving1.a
1
_app.moving1.c.d
3
_app.moving1={a:4}
Object {a: 4}
_app.moving1.c.d
3                       <----------- !!!  MUST BE NULL !!!!
_app.moving1.c
Cell {_id: "j87yqkoqppuv", _value: null, _error: null, _isValueEqual: function, _initialized: true…}
_app.moving1.c.valueOf()
null


*/

"use strict";

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var later = require("later").push;
var co = require("co");
var UID = require("uid");
var lodash = require("lodash");

var _require = require("LOG");

var LOG = _require.LOG;

var actionKey = "_RA_ACTION_" + UID();
var raValue = "_RA_VALUE_" + UID();

// let debugLog = false

var updates = {};
updates.scheduled = false;
updates.procs = [];
updates.index = 0;
updates.maxIndex = 32768;
updates.processing = false;
updates.totalTime = 0;
updates.maxTime = 0;
updates.maxTime1 = 0;
updates.minTime = Infinity;
updates.runCount = 0;
updates.runAllCount = 0;

global.updates = updates; // debugger

var performance = global.performance || global.Date;
updates.start = performance.now();

updates.log = function () {
	return console.log(":: " + updates.totalTime / 1000 + " / " + (performance.now() - updates.start) / 1000 + " (" + updates.maxTime / 1000 + ", " + updates.maxTime1 / 1000 + ", " + updates.minTime / 1000 + ", " + Action.maxCount + ", " + updates.runCount + ", " + updates.runAllCount + ")");
};

// co.go( function* () { // debugger
// 	let sleep5000 = co.sleep( 5000 )
// 	for (;;) {
// 		let totalTime = updates.totalTime
// 		yield sleep5000
// 		if ( totalTime != updates.totalTime )
// 			updates.log()
// 	}
// } )

updates.checkSchedule = function () {
	if (!updates.scheduled && updates.procs.length > 0) {
		updates.scheduled = true;
		later(updates.tick);
	}
};

updates.tick = function () {
	updates.scheduled = false;
	for (var _try = 0; _try < 1000; ++_try) {
		try {
			updates.runAll();
			break;
		} catch (error) {
			setTimeout(function () {
				throw error;
			}, 1);
		}
	}
	updates.checkSchedule();
};

updates.runAll = function () {
	// if ( updates.processing )
	// 	return

	var start = performance.now();
	var st1 = start;
	var runCount = updates.runCount;

	var processing = updates.processing;
	updates.processing = true;
	var action = co.global[actionKey];
	if (action != null) co.global[actionKey] = null;
	try {
		while (updates.index < updates.procs.length) {
			if (global.APP_TIMEOUT && global.APP_TIMEOUT < Date.now) {
				alert("Application is running too long");
			}
			var proc = updates.procs[updates.index];
			++updates.index;
			++updates.runCount;
			if (updates.index >= updates.maxIndex && updates.index * 3 > updates.procs.length) {
				updates.procs.splice(0, updates.index);
				updates.index = 0;
			}
			proc();
			var t1 = performance.now();
			if (updates.maxTime1 < t1 - st1) updates.maxTime1 = t1 - st1;
			// if ( t1 - st1 > 10 )
			// 	console.log( t1 - st1, `` + proc.$name ) // debugger
			st1 = t1;
		}
		updates.index = updates.procs.length = 0;
	} finally {
		if (action != null) co.global[actionKey] = action;
		updates.processing = processing;
		if (!processing) {
			var time = performance.now() - start;
			updates.totalTime += time;
			if (updates.maxTime < time) updates.maxTime = time;
			runCount = updates.runCount - runCount;
			if (runCount) {
				++updates.runAllCount;
				if (updates.minTime > time) updates.minTime = time;
			}
			if (time > 300) LOG("updates have been run for " + time.toString().red + " ms");
		}
	}
};

updates.later = function (proc) {
	updates.procs.push(proc);
	updates.checkSchedule();
};

updates.later.then = updates.later;

var checkNull = function checkNull(value) {
	return value == null ? null : value;
};
var returnThis = function returnThis() {
	return this;
};

var isLiteral = function isLiteral(value) {
	return value && typeof value == "object" && value.constructor == Object;
};
var getValue = function getValue(value) {
	return value == null || value.valueOf == null ? value : value.valueOf();
};

function AbstractGuard() {}

var invalidKeyCall = function invalidKeyCall(key) {
	throw new Error("access to an undeclared property \"" + this.$name + "." + key + "\"");
};

var usedProps = Object.create(null);
var usedPropsProto = Object.create(null);
var guardProp = function guardProp(key) {
	if (!usedProps[key]) {
		usedProps[key] = true;
		Object.defineProperty(usedPropsProto, key, {
			get: function get() {
				invalidKeyCall.call(this, key);
			},
			set: function set() {
				invalidKeyCall.call(this, key);
			}
		});
	}
};
AbstractGuard.prototype = usedPropsProto;

// Не зразумела толкам, як гэты Proxy працуе ў якасьці прататыпу.
// Пакуль што, здаецца, паводзіны не адпавядаюць сьпецыфікацыі (2014.11.25)

// if ( typeof Proxy == "function" ) {
// 	AbstractGuard.prototype = new Proxy( AbstractGuard.prototype, {
// 		get: function ( _, key ) { invalidKeyCall.call( this, key ) },
// 		set: function ( _, key ) { invalidKeyCall.call( this, key ) },
// 	} )
// }

if (global.APP_DEBUG) {
	//
	// аб'яўленьне аб'екта з ~700-800 уласьцівасьцяў з функцыямі чытаньня/запісу
	// займае ў Google Chrome'е каля траціны секунды.
	// Правераныя спосабы:
	// - дабаўленьне па адным праз Object.defineProperty
	// - дабаўленьне гуртам праз Object.defineProperties
	// - кампіляцыя зыходніка праз лакальны eval
	// - кампіляцыя зыходніка праз глабальны eval
	// - кампіляцыя зыходніка праз дабаўленьне тэгу script з зыходнікам
	// Не правераныя спосабы:
	// - дабаўленьне тэгу script з пазнакай src
	// Паляпшае сітуацыю (напалову):
	// - стварэньне для кожнай уласьцівасьці новага аб'екта са старым аб'ектам
	// у якасьці прататыпу. Пры гэтым доступ да неаб'яўленых уласьцівасьцяў можа
	// стаць адносна доўгім па часе, але ж гэта ня так важна, бо ў выніку ўсё адно
	// кідаецца памылка.
	//
	// Генерацыя тэксту зыходніка адбываецца імгненна.
	//
	// Зыходзячы з гэтага улучаць стражнікаў доступу да неаб'яўленых уласьцівасьцяў
	// трэба толькі пры адладцы.
	//
	AbstractGuard.prototype = (global.__UsedScriptIdentifiers__ + "").split(/[\s,]+/).reduce(function (proto, key) {
		return Object.create(proto, _defineProperty({}, key, {
			get: function get() {
				invalidKeyCall.call(this, key);
			},
			set: function set(_) {
				invalidKeyCall.call(this, key);
			}
		}));
	}, AbstractGuard.prototype);
}

AbstractGuard.prototype = Object.create(AbstractGuard.prototype, {
	toString: { value: ({}).toString },
	valueOf: { value: ({}).valueOf },
	toLocaleString: { value: ({}).toLocaleString },
	hasOwnProperty: { value: ({}).hasOwnProperty },
	isPrototypeOf: { value: ({}).isPrototypeOf },
	propertyIsEnumerable: { value: ({}).propertyIsEnumerable },
	$name: { value: "<...>", writable: 1 }
});

var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);

var ImmutableInterface = (function (_AbstractGuard) {
	function ImmutableInterface() {
		_classCallCheck(this, ImmutableInterface);

		if (_AbstractGuard != null) {
			_AbstractGuard.apply(this, arguments);
		}
	}

	_inherits(ImmutableInterface, _AbstractGuard);

	_createClass(ImmutableInterface, [{
		key: "get",
		value: function get(key) {
			if (key != null) {
				var m = this.valueOf();
				if (m != null && Object.prototype.hasOwnProperty.call(m, key)) return m[key];
			}
			return null;
		}
	}, {
		key: "map",
		value: function map(fun) {
			var m = this.valueOf();
			return m && (Array.isArray(m) ? lodash.map(m, fun) : lodash.mapValues(m, fun));
		}
	}, {
		key: "keys",
		value: function keys() {
			var m = this.valueOf();
			return m == null ? EMPTY_ARRAY : Object.keys(m);
		}
	}, {
		key: "props",

		// debugger
		get: function () {
			throw new Error("access to deprecated 'props' property detected");
		}
	}, {
		key: "declaredProperties",
		get: function () {
			return this.live;
		}
	}, {
		key: "length",
		get: function () {
			var m = this.valueOf();return m == null ? 0 : Object.keys(m).length;
		}
	}]);

	return ImmutableInterface;
})(AbstractGuard);

var ReadOnlyCell = (function (_ImmutableInterface) {
	function ReadOnlyCell(parent) {
		_classCallCheck(this, ReadOnlyCell);

		_get(Object.getPrototypeOf(ReadOnlyCell.prototype), "constructor", this).call(this);
		this._parent = parent;
	}

	_inherits(ReadOnlyCell, _ImmutableInterface);

	_createClass(ReadOnlyCell, [{
		key: "getReadOnly",
		value: function getReadOnly() {
			return this;
		}
	}, {
		key: "valueOf",
		value: function valueOf() {
			return this._parent.valueOf.apply(this._parent, arguments);
		}
	}, {
		key: "noTouch",
		value: function noTouch() {
			return this._parent.noTouch.apply(this._parent, arguments);
		}
	}, {
		key: "toString",
		value: function toString() {
			return this._parent.toString.apply(this._parent, arguments);
		}
	}, {
		key: "toJSON",
		value: function toJSON() {
			return this._parent.toJSON.apply(this._parent, arguments);
		}
	}, {
		key: "getName",
		value: function getName() {
			return this._parent.getName.apply(this._parent, arguments);
		}
	}, {
		key: "live",
		get: function () {
			return this._parent.live;
		}
	}, {
		key: "$name",
		get: function () {
			return this._parent.$name;
		}
	}]);

	return ReadOnlyCell;
})(ImmutableInterface);

var Getter = function Getter(fun, isValueEqual) {
	var last = undefined;
	var ret = !isValueEqual ? function () {
		return fun.apply(this, arguments);
	} : function () {
		var ret = fun.apply(this, arguments);
		if (!is(last, ret, isValueEqual)) last = ret;
		return last;
	};
	ret.isGetter = true;
	return ret;
};

var Type = function Type(f) {
	g.typeDescriptor = true;
	return g;
	function g() {
		return f.apply(this, arguments);
	}
};

var runGetter = function runGetter(cell, getter, sticky) {
	return new Action(getter, cell, sticky).linkName(cell, ":getter");
};

var runSetter = function runSetter(cell, setter, sticky) {
	return new Action(function () {
		return setter(cell.valueOf());
	}, null, sticky).linkName(cell, ":setter");
};

function is(a, b, isEqual) {
	return Object.is(a, b) || b && typeof b.isEqualTo == "function" && b.isEqualTo(a) || a && typeof a.isEqualTo == "function" && a.isEqualTo(b) || typeof isEqual == "function" && isEqual(a, b);
}

var This = (function () {
	function This() {
		_classCallCheck(this, This);
	}

	_createClass(This, [{
		key: "_defineThatProperty",
		value: function _defineThatProperty(key, that) {
			Object.defineProperty(this, key, {
				configurable: true,
				enumerable: true,
				get: function get() {
					return that[key];
				},
				set: function set(value) {
					that[key] = value;
				}
			});
		}
	}], [{
		key: "create",
		value: function create(parent, that) {
			var ret = null;
			if (!parent) ret = new This();else ret = Object.create(parent);
			ret.valueOf = function () {
				return that.valueOf();
			};
			ret.toString = function () {
				return that.toString();
			};
			ret.toJSON = function () {
				return that.toJSON();
			};
			ret.assign = function (value) {
				return that.assign(value);
			};
			ret["throw"] = function (value) {
				return that["throw"](value);
			};
			Object.defineProperty(ret, "live", { get: function get() {
					return that.live;
				} });
			return ret;
		}
	}]);

	return This;
})();

var Cell = (function (_ImmutableInterface2) {
	function Cell(sticky) {
		var _this = this;

		_classCallCheck(this, Cell);

		_get(Object.getPrototypeOf(Cell.prototype), "constructor", this).call(this);
		this._id = UID();
		this._that = null;
		this._value = null;
		this._error = null;
		this._isValueEqual = is;
		this._initialized = false;
		this._frozen = false;
		this._closed = false;
		this._dirty = false;
		this._live = null;
		this._liveArray = null;
		this._actionsArr = [];
		this._parent = null;
		this._onchange = [];
		this.$name = { toString: function toString() {
				return _this.getName();
			} };
		this._notifyWritten();
		this._sticky = !!sticky;
	}

	_inherits(Cell, _ImmutableInterface2);

	_createClass(Cell, [{
		key: "valueOf",
		value: function valueOf() {
			return this._read();
		}
	}, {
		key: "assign",
		value: function assign(value) {
			return this._write(value, false, null);
		}
	}, {
		key: "update",
		value: function update(diff) {
			return this.assign(lu.applyDiff(this.noTouch(), diff));
		}
	}, {
		key: "throw",
		value: function _throw(value) {
			return this._write(null, false, value);
		}
	}, {
		key: "touch",
		value: function touch() {
			this._fire();
		}
	}, {
		key: "noTouch",
		value: function noTouch() {
			if (this._dirty) this._updateSelf();
			if (this._error) throw this._error;
			return this._value;
		}
	}, {
		key: "then",
		value: function then(proc) {
			this._onchange.push(proc);
		}
	}, {
		key: "close",
		value: function close() {
			if (this._closed) return;
			this._closed = true;
			this._fire();
			if (this._parent) this._parent.close();
			if (this._liveArray) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this._liveArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var p = _step.value;

						p.close();
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator["return"]) {
							_iterator["return"]();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				this._liveArray = null;
			}
			this._value = null;
			this._error = null;
			this._actionsArr = null;
			this._parent = null;
		}
	}, {
		key: "freeze",
		value: function freeze() {
			if (this._closed || this._frozen) return;
			this._frozen = true;
			this._fire(); // TODO для выдаленьня спасылак абысьціся без _fire і адпаведна без лішняга прагону
			if (this._parent) this._parent.freeze();
			if (this._liveArray) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = this._liveArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var p = _step2.value;

						p.freeze();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		}
	}, {
		key: "getReadOnly",
		value: function getReadOnly() {
			return this._readOnly || (this._readOnly = new ReadOnlyCell(this));
		}
	}, {
		key: "toString",
		value: function toString() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			var v = this._read();
			return v == null || !v.toString ? "" + v : v.toString.apply(v, args);
		}
	}, {
		key: "toJSON",
		value: function toJSON() {
			for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}

			var v = this._read();
			return v == null || !v.toJSON ? v : v.toJSON.apply(v, args);
		}
	}, {
		key: "with",
		value: function _with(cb) {
			return cb.call(this._getThat());
		}
	}, {
		key: "setName",
		value: function setName(name) {
			this._name = name;
			return this;
		}
	}, {
		key: "getName",
		value: function getName() {
			var ret = this._name || this._key;
			var p = this._parent;
			while (p) {
				ret = (p._name || p._key) + "." + ret;
				p = p._parent;
			}
			return ret;
		}
	}, {
		key: "_getThat",
		value: function _getThat() {
			if (!this._that) {
				this._that = This.create(this._parent && this._parent._getThat(), this);
				if (this._live) for (var i in this._live) {
					this._that._defineThatProperty(i, this);
				}
			}
			return this._that;
		}
	}, {
		key: "defineProperty",
		value: function defineProperty(key) {
			// pass key == `` to make Cell object, not value
			if (!this._live) {
				this._live = Object.create(null);
				this._liveArray = [];
			}
			if (!key) return;
			guardProp(key);
			var c = this._live[key];
			if (c) return c;
			c = new Cell(this._sticky);
			this._live[key] = c;
			this._liveArray.push(c);
			c._key = key;
			c._parent = this;
			c._level = (this._level || 0) + 1;
			Object.defineProperty(this, key, {
				enumerable: true,
				configurable: true,
				get: function get() {
					if (c._live) return c;else return c._read();
				},
				set: function set(value) {
					if (c._live) value = getValue(value);
					c._write(value, false);
				}
			});
			if (this._that) this._that._defineThatProperty(key, this);
			if (this._value != null) c._write(this._value[key], true);
			return c;
		}
	}, {
		key: "init",
		value: function init(value) {
			this._init(value, false, false);
		}
	}, {
		key: "setConst",
		value: function setConst(prop, value) {
			Object.defineProperty(this, prop, { enumerable: true, get: function get() {
					return value;
				} });
			return this;
		}
	}, {
		key: "setVar",
		value: function setVar(prop, value) {
			Object.defineProperty(this, prop, { enumerable: true, writable: true, value: value });
			return this;
		}
	}, {
		key: "_init",
		value: function _init(value, recursive, isGetter, isValueEqual) {
			var cell = this;
			if (!recursive && cell._initialized) throw new Error("already initialized");
			if (this._parent) this._parent._dirty = true;
			cell._initialized = true;
			if (isValueEqual) this._isValueEqual = isValueEqual;
			value = checkNull(value);
			if (typeof value == "function" && value.typeDescriptor) value = value(cell._key);
			if (value == null) // we are already null at the point of birth
				return;
			if (value[raValue]) // force just a value
				return cell._value = value;
			if (typeof value == "function") {
				if (isGetter || value.isGetter) // getter
					runGetter(cell, function () {
						return value.call(cell._parent && cell._parent._getThat());
					}, this._sticky);else // method
					cell._value = function () {
						return value.apply(cell._parent && cell._parent._getThat(), arguments);
					};
				return;
			}
			if (!isLiteral(value)) // just a value
				return cell._value = value;
			// subrecord description
			if (recursive) throw new Error("wrong parameters");
			cell.defineProperty();
			for (var key in value) {
				var descr = Object.getOwnPropertyDescriptor(value, key);
				if (!descr) continue;
				var get = descr.get;
				var subValue = descr.value;
				if (descr.set) throw new Error("wrong parameters");else if (get) subValue = get;
				if (key == "$") cell._init(subValue, true, !!get);else cell.defineProperty(key, true)._init(subValue, false, !!get);
			}
		}
	}, {
		key: "_read",
		value: function _read() {
			if (this._dirty) this._updateSelf();
			var action = co.global[actionKey];
			if (action) {
				if (this._closed) action.close();else if (!this._frozen) action.onread(this);
			}
			if (this._error) throw this._error;
			return this._value;
		}
	}, {
		key: "_write",
		value: function _write(newValue, down, newError) {
			if (newError == null) newError = null;
			if (this._frozen) throw new Error("Try to change a frozen value");
			this._initialized = true;
			this._dirty = false;
			newValue = checkNull(newValue);
			if (this._closed) {
				var action = co.global[actionKey];
				if (action) action.close();
			} else if (!this._isValueEqual(this._value, newValue) || this._error != newError) {
				// console.log(`>`+this.$name)//debugger
				this._value = newValue;
				this._error = newError;
				if (this._live) {
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = this._liveArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var _p = _step3.value;

							_p._write(newValue && newValue[_p._key], true);
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
								_iterator3["return"]();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}this._fire();
				if (!down) {
					var p = this._parent;
					while (p && !p._dirty) {
						p._dirty = true;
						p._fire();
						p = p._parent;
					}
				}
			}
			if (!down) this._notifyWritten();
			return newValue;
		}
	}, {
		key: "_updateSelf",
		value: function _updateSelf() {
			var cnt = 0;
			var ret = {};
			for (var key in this._value) {
				if (Object.prototype.hasOwnProperty.call(this._value, key)) {
					ret[key] = this._value[key];
					++cnt;
				}
			}var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = this._liveArray[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var p = _step4.value;

					if (p._dirty) p._updateSelf();
					if (p._error) {
						this._error = p._error;
						this._value = null;
						this._dirty = false;
						return;
					}
					var value = p._value;
					if (value == null) {
						if (Object.prototype.hasOwnProperty.call(ret, p._key)) {
							delete ret[p._key];
							--cnt;
						}
					} else {
						ret[p._key] = value;
						cnt = Infinity;
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
						_iterator4["return"]();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			if (cnt == 0) ret = null;

			this._value = ret;
			this._dirty = false;
		}
	}, {
		key: "debug",
		value: function debug(cb) {
			this._actionsArr.push({ action: { _fire: cb } });
		}
	}, {
		key: "debugger",
		value: function _debugger() {
			this.debug(function () {
				debugger;
			});
		}
	}, {
		key: "_fire",
		value: function _fire() {
			var a = undefined;
			a = this._actionsArr;
			if (a.length) {
				for (var i = 0; i < a.length; i++) {
					var c = a[i];
					if (c.action) c.action._fire();
					c.pushedC = false;
				}
				a.length = 0;
			}
			a = this._onchange;
			if (a.length) {
				for (var i = 0; i < a.length; i++) {
					updates.later(a[i]);
				}a.length = 0;
			}
		}
	}, {
		key: "_notifyWritten",
		value: function _notifyWritten() {
			var action = co.global[actionKey];
			if (action) action.onwritten(this);
		}
	}, {
		key: "live",
		get: function () {
			return this._live;
		}
	}, {
		key: raValue,
		get: function () {
			return true;
		}
	}]);

	return Cell;
})(ImmutableInterface);

var rethrow = function rethrow(error) {
	return setTimeout(function () {
		throw error;
	}, 1);
};

var Action = (function () {
	function Action(fun, dest, sticky) {
		var _this2 = this;

		_classCallCheck(this, Action);

		this._id = UID();
		this._fun = fun;
		this._dest = dest;
		this._cellSet = {};
		this._cellSetSize = 0;
		this._cellArr = [];
		this.$name = { toString: function toString() {
				return "<Action>";
			} };
		this._thread = co.gocall(this._loop, this).linkName(this).waitForInput();
		this._runCount = 0;
		var owner = undefined;
		if ((owner = co.global[actionKey]) && owner._children) owner._children.push(this);
		this._children = null;
		this._threads = null;
		this._onthread = null;
		this._generatorProxy = null;
		this._generator = null;
		if (sticky) {
			this._children = [];
			this._threads = [];
			this._onthread = function (thread) {
				return _this2._threads.push(thread);
			};
		}
	}

	_createClass(Action, [{
		key: "linkName",
		value: function linkName(value) {
			var suffix = arguments[1] === undefined ? ":action" : arguments[1];

			if (value.$name) value = value.$name;
			this.$name.toString = function () {
				return "" + value + suffix;
			};
			return this;
		}
	}, {
		key: "_initGeneratorProxy",
		value: function _initGeneratorProxy() {
			var _generatorProxy,
			    _this3 = this;

			var _value = undefined;
			var _next = function _next() {
				return _this3._generator.next(_value);
			};
			var _throw2 = function _throw2() {
				return _this3._generator["throw"](_value);
			};
			var _return2 = function _return2() {
				return _this3._generator["return"](_value);
			};
			this._generatorProxy = (_generatorProxy = {}, _defineProperty(_generatorProxy, Symbol.iterator, returnThis), _defineProperty(_generatorProxy, "next", function next(v) {
				_value = v;
				try {
					return co.catchThreads(_next, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _defineProperty(_generatorProxy, "throw", function _throw(v) {
				_value = v;
				try {
					return co.catchThreads(_throw2, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _defineProperty(_generatorProxy, "return", function _return(v) {
				_value = v;
				try {
					return co.catchThreads(_return2, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _generatorProxy);
		}
	}, {
		key: "_loop",
		value: regeneratorRuntime.mark(function _loop() {
			var next, errorCatched, ret;
			return regeneratorRuntime.wrap(function _loop$(context$2$0) {
				var _this4 = this;

				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						context$2$0.next = 2;
						return updates.later;

					case 2:
						next = { then: function then(next) {
								_this4._onchange = next;
							} };

						co.global[actionKey] = this;
						errorCatched = false;

					case 5:
						context$2$0.prev = 5;

					case 6:
						if (errorCatched) {
							context$2$0.next = 48;
							break;
						}

						if (!this.isClosed()) {
							context$2$0.next = 9;
							break;
						}

						return context$2$0.abrupt("break", 66);

					case 9:
						this._begin();
						errorCatched = true;
						ret = undefined;

						if (!this._children) {
							context$2$0.next = 34;
							break;
						}

						ret = co.catchThreads(this._fun, this._onthread);

						if (!(!ret || ret[raValue])) {
							context$2$0.next = 17;
							break;
						}

						context$2$0.next = 32;
						break;

					case 17:
						if (!(ret.next && ret["throw"])) {
							context$2$0.next = 28;
							break;
						}

						if (!this._generatorProxy) this._initGeneratorProxy();
						this._generator = ret;
						context$2$0.prev = 20;
						return context$2$0.delegateYield(this._generatorProxy, "t0", 22);

					case 22:
						ret = context$2$0.t0;

					case 23:
						context$2$0.prev = 23;
						this._generator = null;return context$2$0.finish(23);

					case 26:
						context$2$0.next = 32;
						break;

					case 28:
						if (!ret.then) {
							context$2$0.next = 32;
							break;
						}

						context$2$0.next = 31;
						return ret;

					case 31:
						ret = context$2$0.sent;

					case 32:
						context$2$0.next = 47;
						break;

					case 34:
						ret = (0, this._fun)();

						if (!(!ret || ret[raValue])) {
							context$2$0.next = 38;
							break;
						}

						context$2$0.next = 47;
						break;

					case 38:
						if (!(ret.next && ret["throw"])) {
							context$2$0.next = 43;
							break;
						}

						return context$2$0.delegateYield(ret, "t1", 40);

					case 40:
						ret = context$2$0.t1;
						context$2$0.next = 47;
						break;

					case 43:
						if (!ret.then) {
							context$2$0.next = 47;
							break;
						}

						context$2$0.next = 46;
						return ret;

					case 46:
						ret = context$2$0.sent;

					case 47:
						if (this._dest) this._dest.assign(ret);

					case 48:
						errorCatched = false;

						if (!this.isClosed()) {
							context$2$0.next = 51;
							break;
						}

						return context$2$0.abrupt("break", 66);

					case 51:
						context$2$0.t2 = this._end();
						context$2$0.next = context$2$0.t2 === false ? 54 : context$2$0.t2 === true ? 55 : 57;
						break;

					case 54:
						return context$2$0.abrupt("break", 66);

					case 55:
						context$2$0.next = 57;
						return next
						// case null:
						/* immediate recalculation */
						;

					case 57:
						context$2$0.next = 6;
						break;

					case 59:
						context$2$0.next = 64;
						break;

					case 61:
						context$2$0.prev = 61;
						context$2$0.t3 = context$2$0["catch"](5);

						if (errorCatched) this._dest["throw"](context$2$0.t3);else rethrow(context$2$0.t3);

					case 64:
						context$2$0.next = 5;
						break;

					case 66:
						co.global[actionKey] = null;
						this._finalize();

					case 68:
					case "end":
						return context$2$0.stop();
				}
			}, _loop, this, [[5, 61], [20,, 23, 26]]);
		})
	}, {
		key: "isClosed",
		value: function isClosed() {
			return !this._cellSet;
		}
	}, {
		key: "close",
		value: function close() {
			var thread = this._thread;
			this._fire();
			this._finalize();
			thread && thread.kill();
		}
	}, {
		key: "_closeChildren",
		value: function _closeChildren() {
			var c = undefined;
			if (c = this._children) {
				for (var i = 0, l = c.length; i < l; ++i) {
					c[i].close();
				}c.length = 0;
			}
			if (c = this._threads) {
				for (var i = 0, l = c.length; i < l; ++i) {
					c[i].kill();
				}c.length = 0;
			}
		}
	}, {
		key: "_finalize",
		value: function _finalize() {
			this._unsubscribe();
			this._cellSet = null;
			this._cellArr = null;
			this._fun = null;
			this._dest = null;
			this._thread = null;
		}
	}, {
		key: "_begin",
		value: function _begin() {
			this._unsubscribe();
			++this._runCount;
			if (Action.maxCount < this._runCount) {
				Action.maxCount = this._runCount;
			}
		}
	}, {
		key: "_unsubscribe",
		value: function _unsubscribe() {
			this._onchange = null;
			var a = this._cellArr;
			if (a) {
				for (var i = 0; i < a.length; ++i) {
					var c = a[i];
					c.cell = null;
					c.value = null;
					c.action = null;
					c.read = false;
					c.written = false;
					c.pushedA = false
					// do not change c.pushedC here!!
					;
				}
				if (this._cellSetSize > 32 && a.length < this._cellSetSize / 4) {
					this._cellSet = {};
					this._cellSetSize = 0;
				}
				a.length = 0;
			}
			this._closeChildren();
		}
	}, {
		key: "_end",
		value: function _end() {
			var ret = false;
			var a = this._cellArr;
			for (var i = 0; i < a.length; ++i) {
				var c = a[i];
				if (c.written) c.action = null;else {
					if (!c.pushedC) {
						c.cell._actionsArr.push(c);
						c.pushedC = true;
					}
					if (!is(c.value, c.cell._value) || c.error != c.cell._error) return null;
					c.action = this;
					ret = true;
				}
				c.value = null;
				c.cell = null;
			}
			return ret;
		}
	}, {
		key: "_linkCell",
		value: function _linkCell(cell) {
			var c = this._cellSet[cell._id];
			if (c == null) {
				c = this._cellSet[cell._id] = {
					cell: null,
					value: null,
					error: null,
					action: null,
					read: false,
					written: false,
					pushedA: false,
					pushedC: false
				};
				++this._cellSetSize;
			}
			if (!c.pushedA) {
				this._cellArr.push(c);
				c.cell = cell;
				c.pushedA = true;
			}
			return c;
		}
	}, {
		key: "onread",
		value: function onread(cell) {
			var c = this._linkCell(cell);
			c.read = true;
			c.value = cell._value;
			c.error = cell._error;
		}
	}, {
		key: "onwritten",
		value: function onwritten(cell) {
			this._linkCell(cell).written = true;
		}
	}, {
		key: "_fire",
		value: function _fire() {
			if (this._onchange) updates.later(this._onchange);
			this._unsubscribe();
		}
	}]);

	return Action;
})();

Action.maxCount = 0;

var newReactive = function newReactive(getter, handlers, sticky, isValueEqual) {
	var _iteratorNormalCompletion5 = true;
	var _didIteratorError5 = false;
	var _iteratorError5 = undefined;

	try {
		for (var _iterator5 = handlers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
			var h = _step5.value;

			if (h != null && typeof h != "function") throw new Error("wrong parameters");
		}
	} catch (err) {
		_didIteratorError5 = true;
		_iteratorError5 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
				_iterator5["return"]();
			}
		} finally {
			if (_didIteratorError5) {
				throw _iteratorError5;
			}
		}
	}

	var cell = new Cell(sticky);
	if (getter !== undefined) cell._init(getter, false, true, isValueEqual);
	var _iteratorNormalCompletion6 = true;
	var _didIteratorError6 = false;
	var _iteratorError6 = undefined;

	try {
		for (var _iterator6 = handlers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
			var h = _step6.value;

			h && (h.length ? runSetter : runGetter)(cell, h, sticky);
		}
	} catch (err) {
		_didIteratorError6 = true;
		_iteratorError6 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
				_iterator6["return"]();
			}
		} finally {
			if (_didIteratorError6) {
				throw _iteratorError6;
			}
		}
	}

	return cell;
};

var ra = function ra() {
	var name = undefined,
	    fun = undefined,
	    sticky = undefined,
	    isValueEqual = undefined,
	    index = 0;
	if (typeof arguments[index] == "string") name = arguments[index++];
	if (typeof arguments[index] == "boolean") sticky = arguments[index++];
	fun = arguments[index++];
	if (typeof arguments[index] == "function") isValueEqual = arguments[index++];
	return newReactive(fun, [], sticky, isValueEqual);
};

function ArrayIsEqualTo(a) {
	return this == a || Array.isArray(a) && this.length == a.length && this.every(function (e, i) {
		return is(e, a[i]);
	});
}

function JsonIsEqualTo(a) {
	return this == a || JSON.stringify(this) == JSON.stringify(a);
}

exports = module.exports = ra;

exports.ra = ra;

exports.is = is;

exports.Array = function (array) {
	array.isEqualTo = ArrayIsEqualTo;
	return array;
};

exports.JSON = function (obj) {
	obj.isEqualTo = JsonIsEqualTo;
	return obj;
};

exports.Value = function (obj) {
	obj && obj.defineProperty(raValue, { value: true, configurable: true, enumerable: false, writable: false });
	return obj;
};

exports.clean = function (getter) {
	for (var _len3 = arguments.length, handers = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		handers[_key3 - 1] = arguments[_key3];
	}

	return newReactive(getter, handers, false);
};

exports.detach = function (fun) {
	var old = undefined;
	if (old = co.global[actionKey]) {
		co.global[actionKey] = null;
		try {
			return fun();
		} finally {
			co.global[actionKey] = old;
		}
	} else return fun();
};

exports.detached = function (fun) {
	return function () {
		var old = undefined;
		if (old = co.global[actionKey]) {
			co.global[actionKey] = null;
			try {
				return fun.apply(this, arguments);
			} finally {
				co.global[actionKey] = old;
			}
		} else return fun.apply(this, arguments);
	};
};

exports.on = function (emitter, event, getter) {
	var ret = ra();
	var handler = function handler(data) {
		return ret.assign(getter(data));
	};
	if (event == "string") emitter.on(event, handler);else {
		var _iteratorNormalCompletion7 = true;
		var _didIteratorError7 = false;
		var _iteratorError7 = undefined;

		try {
			for (var _iterator7 = event[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
				var _e = _step7.value;

				emitter.on(_e, handler);
			}
		} catch (err) {
			_didIteratorError7 = true;
			_iteratorError7 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
					_iterator7["return"]();
				}
			} finally {
				if (_didIteratorError7) {
					throw _iteratorError7;
				}
			}
		}
	}handler();
	return ret;
};

exports.Cell = Cell;
exports.ImmutableInterface = ImmutableInterface;
exports.AbstractGuard = AbstractGuard;
exports.Getter = Getter;
exports.Type = Type;
exports.importFrom = function (observable) {
	return Type(function (name) {
		return Getter(function () {
			return observable.live[name].valueOf();
		});
	});
};
exports.forceCalculations = function () {
	return updates.runAll();
};

function createActual() {
	var ret = ra();
	ret.assign(ret);
	ra(function () {
		var value = ret.valueOf();
		ra.detach(function () {
			return ret.assign(value);
		});
	});
	return ret;
}

var _DBChunk_Getter = UID();

var DBChunk = (function () {
	function DBChunk(getter, save, initial, previous) {
		_classCallCheck(this, DBChunk);

		this._previous = previous;
		this._getter = getter;
		this._save = save;
		var chunk = this._chunk = ra();
		chunk.assign(initial);
		var actual = this._actual = createActual();
		actual[_DBChunk_Getter] = ra(function () {
			return lu.applyDiff(getter.valueOf(), chunk.valueOf());
		});
		this._summary = ra(function () {
			return actual.valueOf()[_DBChunk_Getter].valueOf();
		});
	}

	_createClass(DBChunk, [{
		key: "createNext",
		value: function createNext() {
			var initial = arguments[0] === undefined ? null : arguments[0];
			return new DBChunk(this._summary, this._save, initial, this._actual);
		}
	}, {
		key: "valueOf",
		value: function valueOf() {
			return this.chunk;
		}
	}, {
		key: "assign",
		value: function assign(value) {
			this.chunk = value;
		}
	}, {
		key: "save",
		value: function save() {
			return this._save(this.chunk);
		}
	}, {
		key: "update",
		value: function update(diff) {
			return this._chunk.update(diff);
		}
	}, {
		key: "set",
		value: function set(name, value) {
			return this._chunk.set(name, value);
		}
	}, {
		key: "get",
		value: function get(name) {
			return this._chunk.get(name);
		}
	}, {
		key: "close",
		value: function close() {
			this._chunk.assign(null);
			if (this._previous) {
				this._actual.assign(this._previous);
				this._previous = null;
			}
		}
	}, {
		key: "before",
		get: function () {
			return this._getter.valueOf();
		}
	}, {
		key: "summary",
		get: function () {
			return this._summary.valueOf();
		}
	}, {
		key: "chunk",
		get: function () {
			return this._chunk.valueOf();
		},
		set: function (value) {
			this._chunk.assign(value);
		}
	}]);

	return DBChunk;
})();

var DB = (function () {
	function DB(getter, save) {
		var _this5 = this;

		_classCallCheck(this, DB);

		this._head = ra();
		this._head.assign(new DBChunk(getter, save));
		this._value = ra(function () {
			return _this5._head.valueOf().summary;
		});
	}

	_createClass(DB, [{
		key: "valueOf",
		value: function valueOf() {
			return this._value.valueOf();
		}
	}, {
		key: "createRecord",
		value: function createRecord() {
			// not detached
			var ret = this._head.valueOf().createNext();
			this._head.assign(ret);
			return ret;
		}
	}, {
		key: "data",
		get: function () {
			return this.valueOf();
		}
	}]);

	return DB;
})();

exports.db = function (getter, save) {
	return new DB(getter, save);
};

function toKey(obj) {
	if (!toKey.Keys) toKey.Keys = typeof WeakMap != "undefined" ? new WeakMap() : (function () {
		var id = "_to_key_" + UID();
		return {
			set: function set(obj, value) {
				Object.defineProperty(obj, id, {
					enumerable: false,
					configurable: true,
					writable: false,
					value: value
				});
			},
			get: function get(obj) {
				return obj[id];
			},
			has: function has(obj) {
				return Object.prototype.hasOwnProperty.call(obj, id);
			}
		};
	})();
	if (obj && (typeof obj == "object" || typeof obj == "function")) {
		if (!toKey.Keys.has(obj)) toKey.Keys.set(obj, UID());
		return toKey.Keys.get(obj);
	}
	return typeof obj + obj;
}

exports.makeKey = function (obj, key) {
	return ra(function () {
		return obj.get(key);
	});
};

exports.map = function (array, mapper) {
	if (!(array instanceof Cell)) throw new Error("ra.map: first argument must be a cell");
	var cache = Object.create(null);
	var ret = ra();
	ra.detach(function () {
		return ra(function () {
			// TODO праверыць, што пры array.close() гэта функцыя адпрацоўвае і прыбівае ўсе cache[].index і cache[].proc
			var a = array.valueOf();
			ra.detach(function () {
				var retarr = [];
				var index = 0;
				lodash.forEach(cache, function (c) {
					return c.abandoned = true;
				});
				a && a.forEach(function (value) {
					var key = toKey(value);
					var c = undefined;
					if (!(c = cache[key])) c = cache[key] = {
						value: value,
						index: ra()
					};
					c.abandoned = false;
					c.index.assign(index++);
					if (!c.proc) c.proc = ra(function () {
						return mapper(value, c.index);
					});
					retarr.push(c.proc);
				});
				lodash.keys(cache).forEach(function (key) {
					var c = cache[key];
					if (c.abandoned) {
						delete cache[key];
						c.index.close();
						c.proc.close();
					}
				});
				ret.assign(ra.Array(retarr));
			});
		});
	});
	return ret;
};

exports.keymap = function (array, mapper) {
	var mapped = ra.map(array, mapper);
	return ra(function () {
		return lodash.zipObject(array.valueOf(), mapped.valueOf());
	});
}

// exports.slice = ( dest, source, keysVar ) => {
// 	throw new Error( "message" )
// 	// TODO: optimization
// 	if ( !( dest instanceof Cell ) )
// 		dest = ra.clean( dest )
// 	let cacheHolder = ra.clean()
// 	ra.clean( () => {
// 		let keys = getValue( keysVar )
// 		if ( keys )
// 			keys.sort()
// 		updates.later( () => {
// 			let c = ra.clean()
// 			let s = c.defineProperty( `source` )
// 			let d = c.defineProperty( `dest` )
// 			keys && keys.forEach( k => {
// 				let sk = s.defineProperty( k )
// 				let dk = d.defineProperty( k )
// 				ra.clean( () => dk.assign( sk.valueOf() ) )
// 			} )
// 			let t = cacheHolder.valueOf()
// 			cacheHolder.assign( c )
// 			t && t.close()
// 		} )
// 	} )
// 	ra.clean( () => {
// 		let c = cacheHolder.valueOf()
// 		c && c.source && c.source.assign( source.valueOf() )
// 	} )
// 	ra.clean( () => {
// 		let c = cacheHolder.valueOf()
// 		dest.assign( c && c.dest && c.dest.valueOf() )
// 	} )
// 	return dest
// }
; // noop
// noop
// delete( obj ) { delete obj[ id ] },

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ra.js","/src")

},{"LOG":119,"_process":99,"buffer":94,"co":125,"later":133,"lodash":116,"uid":155}],137:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var maxIndex = 32768;

var Scheduler = (function () {
	function Scheduler(options) {
		_classCallCheck(this, Scheduler);

		this.setImmediate = options && options.setImmediate || process.nextTick;
		this.maxTicks = options && options.maxTicks || Infinity;
		this._procs = [];
		this._index = 0;
		this._scheduled = false;
		this._processing = false;
		this._handler = this._handler.bind(this);
		this.push = this.then.bind(this);
	}

	_createClass(Scheduler, [{
		key: "then",
		value: function then(proc) {
			this._procs.push(proc);
			if (!this._processing) this._schedule();
		}
	}, {
		key: "_schedule",
		value: function _schedule() {
			if (!this._scheduled) {
				this.setImmediate(this._handler);
				this._scheduled = true;
			}
		}
	}, {
		key: "_handler",
		value: function _handler() {
			this._scheduled = false;
			while (this._procs.length) {
				try {
					this._handler1();
				} catch (error) {
					setTimeout(function () {
						throw error;
					}, 0);
				}
			}
		}
	}, {
		key: "_handler1",
		value: function _handler1() {
			this._processing = true;
			try {
				var t = 0;
				while (this._index < this._procs.length && ++t <= this.maxTicks) {
					var proc = this._procs[this._index];
					this._procs[this._index] = null;
					++this._index;
					if (this._index >= maxIndex && this._index * 3 > this._procs.length) {
						this._procs.splice(0, this._index);
						this._index = 0;
					}
					proc();
				}
			} finally {
				this._processing = false;
				if (this._procs.length && this._index >= this._procs.length) this._procs.length = this._index = 0;
				if (this._index) this._schedule();
			}
		}
	}]);

	return Scheduler;
})();

module.exports = Scheduler;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/scheduler.js","/src")

},{"_process":99,"buffer":94}],138:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function rethrow(error) {
	setTimeout(function () {
		throw error;
	});
}

function safeEach(array, cb) {
	for (var i = 0, l = array.length; i < l; ++i) {
		try {
			cb(array.shift());
		} catch (error) {
			rethrow(error);
		}
	}
}

module.exports = (function () {
	function SparseQueue() {
		_classCallCheck(this, SparseQueue);

		this._cbs = [];
	}

	_createClass(SparseQueue, [{
		key: "then",
		value: function then(cb) {
			if (this._closed) process.nextTick(function () {
				return cb(undefined);
			});else this._cbs.push(cb);
		}
	}, {
		key: "isClosed",
		value: function isClosed() {
			return this._closed;
		}
	}, {
		key: "close",
		value: function close() {
			this._closed = true;
			safeEach(this._cbs, function (handler) {
				return handler(undefined);
			});
		}
	}, {
		key: "push",
		value: function push(data) {
			if (this._closed) throw new Error("queue is aready closed");
			safeEach(this._cbs, function (handler) {
				return handler(data);
			});
		}
	}, {
		key: "pushcb",
		value: function pushcb(data) {
			if (this._closed) throw new Error("queue is aready closed");
			safeEach(this._cbs, function (handler) {
				return handler(data());
			});
		}
	}]);

	return SparseQueue;
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/sparsequeue.js","/src")

},{"_process":99,"buffer":94}],139:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
by design:
Не ствараем ніякіх буфераў для падзей (накшталт touchmove ці mousemove) - падзеі ўсё адно альбо апрацоўваюцца хутка, альбо толькі займаюць месца ў буферах і затарможваюць апрацоўку, калі апрацоўшчыкі ўсё ж прачнуцца.
*/

"use strict";

var sparsequeue = require("sparsequeue");

var tracks = Object.create(null);

setInterval(function () {
	for (var identifier in tracks) {
		var track = tracks[identifier];
		if (track.abandoned) {} else track.abandoned = true;
	}
}, 7000);

function pushEvent(track, event) {
	track.points.push(event);
	if (track.preventDefault && event.preventDefault) event.preventDefault();
}

function stopEvents(track) {
	track.points.close();
}

function startTrack(identifier, event) {
	var points = new sparsequeue();
	var detail = {
		cancelEvent: null,
		next: points
	};
	var track = {
		abandoned: false,
		closed: false,
		detail: detail,
		points: points,
		preventDefault: false
	};
	tracks[identifier] = track;
	var ret = new CustomEvent("touch", { detail: detail, bubbles: true, cancelable: true });
	ret.pageX = event.pageX;
	ret.pageY = event.pageY;
	ret.clientX = event.clientX;
	ret.clientY = event.clientY;
	ret.screenX = event.screenX;
	ret.screenY = event.screenY;
	ret.preventDefault = function () {
		event.preventDefault();
		track.preventDefault = true;
	};
	event.target.dispatchEvent(ret);
	pushEvent(track, event);
}

function onExistingTrack(fun) {
	return function (identifier, arg) {
		var track = tracks[identifier];
		if (!track) return;
		track.abandoned = false;
		fun(track, arg);
	};
}

var continueTrack = onExistingTrack(pushEvent);

var stopTrack = onExistingTrack(function (track, event) {
	pushEvent(track, event);
	stopEvents(track);
});

var removeTrack = onExistingTrack(stopEvents);

var cancelTrack = onExistingTrack(function (track, event) {
	track.detail.cancelEvent = event;
	stopEvents(track);
});

function forTouches(event, cb) {
	for (var i = 0; i < event.changedTouches.length; ++i) {
		var touch = event.changedTouches.item(i);
		cb(touch.identifier, {
			type: "touchmove",
			identifier: touch.identifier,
			target: touch.target,
			screenX: touch.screenX,
			screenY: touch.screenY,
			clientX: touch.clientX,
			clientY: touch.clientY,
			pageX: touch.pageX,
			pageY: touch.pageY,
			radiusX: touch.radiusX,
			radiusY: touch.radiusY,
			rotationAngle: touch.rotationAngle,
			force: touch.force,
			timeStamp: event.timeStamp,
			preventDefault: event.preventDefault.bind(event)
		});
	}
	var current = Object.create(null);
	for (var i = 0; i < event.touches.length; ++i) {
		current[event.touches.item(i).identifier] = true;
	}for (var identifier in tracks) {
		if (!(identifier in current)) removeTrack(identifier);else tracks[identifier].abandoned = false;
	}
}

var container = document;

container.addEventListener("mousedown", function (event) {
	if (event.button == 0) startTrack("mouse", event);else if (!(event.buttons & 1)) removeTrack("mouse");
});

container.addEventListener("mousemove", function (event) {
	if (event.buttons & 1) continueTrack("mouse", event);else removeTrack("mouse");
});

container.addEventListener("mouseup", function (event) {
	if (event.button == 0) stopTrack("mouse", event);else if (!(event.buttons & 1)) removeTrack("mouse");
});

container.addEventListener("touchstart", function (event) {
	forTouches(event, startTrack);
});

container.addEventListener("touchmove", function (event) {
	forTouches(event, continueTrack);
});

container.addEventListener("touchend", function (event) {
	forTouches(event, stopTrack);
});

container.addEventListener("touchcancel", function (event) {
	forTouches(event, cancelTrack);
});

// if ( track.handler.return )
// 	track.handler.return()
// delete tracks[ identifier ]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/track.js","/src")

},{"_process":99,"buffer":94,"sparsequeue":138}],140:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Command = app.load(require("ui/Command"));
	return function (attr) {
		return React.createElement(Command, {
			message: "commandAddExistingItem",
			onclick: function () {
				app.dialog = "SearchItems";
				app.searchAction = function (itemId) {
					app.linkItem(app.activeDeviceId, itemId);
					app.dialog = "";
				};
				app.searchFilter = null;
				if (app.deviceType == "group") app.searchFilter = function (itemId) {
					var device = app.getDevice(itemId);
					return device && device.type == "single";
				};
			},
			_: attr
		});
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AddExistingItem.js","/src/ui")

},{"_process":99,"buffer":94,"ui/Command":146}],141:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Command = app.load(require("ui/Command"));
	var AddExistingItem = app.load(require("ui/AddExistingItem"));
	return React.createElement(
		"div",
		null,
		React.createElement(AddExistingItem, null),
		React.createElement(Command, {
			message: "commandCreateNewGroup",
			onclick: function () {
				app.addGroup(app.activeDeviceId);
			}
		}),
		React.createElement(Command, {
			message: "commandAddNewDevice",
			onclick: function () {
				return app.addDevice(app.activeDeviceId);
			}
		}),
		React.createElement(Command, {
			message: "commandAddPlace",
			onclick: function () {
				app.addPlace(app.activeDeviceId);
			}
		})
	);
};

// app.dialog = `AddPlace`

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AddMenu.js","/src/ui")

},{"_process":99,"buffer":94,"ui/AddExistingItem":140,"ui/Command":146}],142:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// let httpClient = require( `httpClient` )
// let cookies = require( `cookies` )

"use strict";

module.exports = function (_ref) {
	var appid = _ref.appid;
	var IconTemplates = _ref.IconTemplates;

	var _require = require("app")(appid);

	var app = _require.app;
	var local = _require.local;

	app.pageStarting = true;

	window._app = app;
	window._local = local;
	window._devdb = require("devdb");

	if (navigator.standalone) {} else {
		ra(function () {
			if (local.activeDeviceId && local.activeDeviceId.valueOf()) {
				var title = "TITLE_" + local.activeDeviceId;
				var icon = "ICON_" + local.activeDeviceId;
				screenTitle.setAttribute("content", title);
				if (local.activeDeviceId && local.activeDeviceId != "main") history.replaceState(null, title, "?appicon=" + icon);else history.replaceState(null, title, "?");
			}
		});
	}

	var MainScreen = app.load(require("ui/MainScreen"));
	var StartupScreen = app.load(require("ui/StartupScreen"));
	var LoadingScreen = function LoadingScreen() {
		return React.createElement("div", { "class": "loadingScreen" });
	};

	var application = React.createElement(
		"div",
		{ "class": function () {
				return "\n\t\tapplication\n\t\t" + (app.pageStarting ? "pageStarting" : "pageRunning") + "\n\t\t" + (app.initialLoading ? "JSONloading" : "JSONloaded") + "\n\t\t" + (app.initialized ? "alreadyRun" : "firstRun") + "\n\t\t" + (app.connectedToServer ? "appConnected" : "appDisconnected") + "\n\t\t" + "" + "\n\t\t" + (app.templates ? "templatesLoaded" : "templatesLoading") + "\n\t\t" + (app.dialog && "dialog" + app.dialog) + "\n\t\t" + (app.dialog ? "dialogIsPresent" : "dialogIsAbsent") + "\n\t\tapp_labels_" + !!local.labels + "\n\t\tapp_editing_" + !!app.editing + "\n\t";
			} },
		React.createElement(MainScreen, null),
		React.createElement(StartupScreen, null),
		React.createElement(LoadingScreen, null)
	);

	app.icons = IconTemplates.reduce(function (icons, template) {
		icons[template.dataset.name] = template;
		return icons;
	}, Object.create(null));

	var Button = app.load(require("ui/Button"));

	var CloseError = function CloseError(attr, text) {
		return React.createElement(
			"p",
			{
				ontouch: function () {
					var error = app.error;
					app.dialog = "";
					app.error = null;
					attr.onclick && attr.onclick(error);
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			text
		);
	};

	var CloseDialog = function CloseDialog(attr, text) {
		return React.createElement(
			"p",
			{
				ontouch: function () {
					app.dialog = "";
					attr.onclick && attr.onclick();
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			text
		);
	};

	// dialogs
	var dialogTemplates = {

		ServiceDialog: function ServiceDialog() {
			return app.load(require("ui/ServiceDialog"));
		},
		ContextMenu: function ContextMenu() {
			return app.load(require("ui/ContextMenu"));
		},
		AddMenu: function AddMenu() {
			return app.load(require("ui/AddMenu"));
		},
		SearchItems: function SearchItems() {
			return app.load(require("ui/SearchItems"));
		},
		AskNewName: function AskNewName() {
			return app.load(require("ui/AskNewName"));
		},
		AskToLinkDevice: function AskToLinkDevice() {
			return app.load(require("ui/AskToLinkDevice"));
		},

		AskIfDeviceHasBeenLinked: function AskIfDeviceHasBeenLinked() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Устройство было успешно привязано?"
				),
				React.createElement(
					Button,
					{ onclick: "StopDeviceNotification" },
					"да"
				),
				React.createElement(
					Button,
					{ onclick: "AskToLinkDevice" },
					"нет"
				)
			);
		},

		StopDeviceNotification: function StopDeviceNotification() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Пожалуйста,",
					React.createElement("br", null),
					"переведите устройство в рабочий режим."
				),
				React.createElement(
					Button,
					null,
					"Закрыть"
				)
			);
		},

		ErrorNoCarrier: function ErrorNoCarrier() {
			return React.createElement(
				"div",
				{ "class": "errorDialog" },
				React.createElement(
					"p",
					null,
					"Ошибка"
				),
				React.createElement(
					"p",
					null,
					"Произошла ошибка при попытке связаться с модемом."
				),
				React.createElement(
					Button,
					null,
					"Закрыть"
				)
			);
		},

		ErrorUnlinkingDevice: function ErrorUnlinkingDevice() {
			return React.createElement(
				"div",
				{ "class": "errorDialog" },
				React.createElement(
					"p",
					null,
					"Ошибка"
				),
				React.createElement(
					"p",
					null,
					"Не удалось связаться с устройством и отвязать его."
				),
				React.createElement(
					"p",
					null,
					"Что следует сделать?"
				),
				React.createElement(
					"ul",
					null,
					React.createElement(
						CloseError,
						{ onclick: function (error) {
								return app.purgeItem(error.data.deviceId);
							}
						},
						React.createElement(
							"li",
							null,
							"Попытаться отвязать устройство ещё раз"
						)
					),
					React.createElement(
						CloseError,
						null,
						React.createElement(
							"li",
							null,
							"Отменить удаление"
						)
					),
					React.createElement(
						CloseError,
						{ onclick: function (error) {
								return app.purgeItem(error.data.deviceId, true);
							}
						},
						React.createElement(
							"li",
							null,
							"Забыть информацию об устройстве"
						)
					)
				)
			);
		},

		DeleteDevice: function DeleteDevice() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					({
						place: React.createElement(
							"span",
							null,
							"Помещение (место) \"",
							app.caption,
							"\" будет удалено из программы."
						),
						single: React.createElement(
							"span",
							null,
							"Устройство \"",
							app.caption,
							"\" будет удалено из программы."
						),
						group: React.createElement(
							"span",
							null,
							"Группа \"",
							app.caption,
							"\" будет удалена из программы."
						)
					})[app.deviceType]
				),
				React.createElement(
					"ul",
					null,
					React.createElement(
						CloseDialog,
						{ "class": "dangerousAction", onclick: function () {
								return app.purgeItem(app.activeDeviceId);
							}
						},
						React.createElement(
							"li",
							null,
							"Удалить"
						)
					),
					React.createElement(
						CloseDialog,
						null,
						React.createElement(
							"li",
							null,
							"Не удалять"
						)
					)
				)
			);
		},

		StateWait: function StateWait() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Подождите..."
				)
			);
		},

		AskToReset: function AskToReset() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Память контроллера будет очищена,",
					React.createElement("br", null),
					"но память устройств очищаться не будет."
				),
				React.createElement(
					Button,
					{ "class": "dangerousAction", onclick: app.reset },
					"Очистить",
					React.createElement("br", null),
					"память"
				)
			);
		}

	};

	ra(function () {
		var dialogName = app.dialog;
		if (!dialogName) return;

		if (!Object.prototype.hasOwnProperty.call(dialogTemplates, dialogName)) {
			alert("Error: Could not find dialog named\n\"" + dialogName + "\"");
			ra.detach(function () {
				return app.dialog = "";
			});
			return;
		}
		var Template = dialogTemplates[dialogName];
		if (!Template) return;
		dialogTemplates[dialogName] = null;

		var dialog = Template();
		dialog.classList.add(dialogName);
		dialog.classList.add("modalDialog");
		ra(Object.defineProperties({}, {
			isActive: {
				get: function () {
					return dialogName == app.dialog;
				},
				configurable: true,
				enumerable: true
			},
			updateClass: {
				get: function () {
					var event = undefined;
					if (this.isActive) {
						event = "dialogshow";
						dialog.classList.add("dialogShown");
						dialog.classList.remove("dialogHidden");
						var input = dialog.querySelector("*[ autofocus ]");
						if (input) app.focus(input);
					} else {
						event = "dialoghide";
						dialog.classList.remove("dialogShown");
						dialog.classList.add("dialogHidden");
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
							for (var _iterator = dialog.querySelectorAll("*:focus")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var elem = _step.value;

								elem.blur();
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator["return"]) {
									_iterator["return"]();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}

						dialog.blur();
					}
					dialog.dispatchEvent(new CustomEvent(event, { detail: null }));
				},
				configurable: true,
				enumerable: true
			}
		}));
		application.appendChild(dialog);
	});

	setTimeout(function () {
		return app.pageStarting = false;
	}, 1);

	return application;
};

// cookies.setItem( `standalone`, 1, Infinity ) -- усё адно не пасьпяваем паставіць куку перад першым зваротам да сервера
// httpClient.post( `/cookie?appicon=${ icon }`, `` )
// cookies.setItem( `appicon`, icon, Infinity )
// LOG( local.activeDeviceId.blue )
/* app.credentials == null ? `showLogin` : `hideLogin` */ // AddPlace,
// AddDevice,

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Application.js","/src/ui")

},{"_process":99,"app":123,"buffer":94,"devdb":127,"ui/AddMenu":141,"ui/AskNewName":143,"ui/AskToLinkDevice":144,"ui/Button":145,"ui/ContextMenu":147,"ui/MainScreen":149,"ui/SearchItems":152,"ui/ServiceDialog":153,"ui/StartupScreen":154}],143:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");

module.exports = function (app) {
	var $ = {};
	return React.createElement(
		"div",
		{ ondialogshow: function () {
				$.string.value = app.getMessage(app.getDevice(app.activeDeviceId));
				$.string.setSelectionRange(0, $.string.value.length);
			} },
		React.createElement(
			"p",
			null,
			"Название:"
		),
		React.createElement(
			"form",
			{ onsubmit: function (event) {
					event && event.preventDefault();
					var name = $.string.value.trim();
					app.dialog = "";
					if (name) app.renameItem(app.activeDeviceId, name);
				} },
			$.string = React.createElement("textarea", { name: "string", cols: "35", rows: "2", autofocus: "autofocus" }),
			React.createElement(
				"p",
				null,
				React.createElement(
					"a",
					{ "class": "button", href: "javascript:void(0)", target: "_self", ontouch: htmlutils.Submit },
					"Закрыть"
				)
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AskNewName.js","/src/ui")

},{"_process":99,"buffer":94,"htmlutils":130}],144:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Button = app.load(require("ui/Button"));
	return React.createElement(
		"div",
		null,
		React.createElement(
			"p",
			null,
			"Пожалуйста,",
			React.createElement("br", null),
			"переведите устройство в режим",
			React.createElement("br", null),
			"программирования и нажмите"
		),
		React.createElement(
			Button,
			{ onclick: function () {
					var placeId = app.linkingPlaceId || app.activeDeviceId;
					app.dialog = "StateWait";
					co.go(regeneratorRuntime.mark(function callee$2$0() {
						return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
							while (1) switch (context$3$0.prev = context$3$0.next) {
								case 0:
									context$3$0.next = 2;
									return app.command(placeId, "Link");

								case 2:
									app.dialog = "AskIfDeviceHasBeenLinked";
									app.linkingPlaceId = placeId;

								case 4:
								case "end":
									return context$3$0.stop();
							}
						}, callee$2$0, this);
					}))["catch"](function (error) {
						console.log(error);
						app.dialog = "ErrorNoCarrier";
					});
				}
			},
			"здесь"
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AskToLinkDevice.js","/src/ui")

},{"_process":99,"buffer":94,"ui/Button":145}],145:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function (attr, content) {
		return React.createElement(
			"a",
			{ "class": "button", href: "javascript:void(0)", target: "_self", ontouch: function (event) {
					event.preventDefault();
					if (typeof attr.onclick == "string") app.dialog = attr.onclick;else {
						app.dialog = "";
						attr.onclick && attr.onclick();
					}
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			content
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Button.js","/src/ui")

},{"_process":99,"buffer":94}],146:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function (_ref) {
		var onclick = _ref.onclick;
		var url = _ref.url;
		var visible = _ref.visible;
		var enabled = _ref.enabled;
		var message = _ref.message;

		var content = app.message(message);
		var isEnabled = function isEnabled() {
			return (url || onclick) && (!enabled || enabled());
		};
		if (typeof visible == "string") {
			(function () {
				var deviceType = visible;
				visible = function () {
					return app.deviceType == deviceType;
				};
			})();
		}
		var className = function className() {
			return "command " + message + " " + (isEnabled() ? "enabled" : "disabled") + " " + (visible == null || visible() ? "itemVisible" : "itemHidden");
		};
		if (url && !onclick) return React.createElement(
			"a",
			{ "class": className, href: url, rel: "external", target: "_blank" },
			content
		);else return React.createElement(
			"a",
			{ "class": className, href: "javascript:void(0)", target: "_self", ontouch: function (event) {
					event.preventDefault();
					if (onclick && isEnabled()) {
						if (typeof onclick == "string") app.dialog = onclick;else {
							app.dialog = "";
							onclick();
						}
					}
				} },
			content
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Command.js","/src/ui")

},{"_process":99,"buffer":94}],147:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app, local) {
	var Command = app.load(require("ui/Command"));
	var AddExistingItem = app.load(require("ui/AddExistingItem"));
	return React.createElement(
		"div",
		null,
		React.createElement(Command, {
			message: "commandSearchDevices",
			onclick: "SearchItems"
		}),
		React.createElement(Command, {
			message: "commandToFavourites",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.linkActiveToFavourites();
				app.notification("Добавлено в избранное");
			}
		}),
		React.createElement(Command, {
			message: "commandLinkDevice",
			visible: "device",
			onclick: "AskToLinkDevice"
		}),
		React.createElement(Command, {
			message: "commandAdd",
			visible: function () {
				return !app.editing && app.deviceType == "place";
			},
			onclick: "AddMenu"
		}),
		React.createElement(AddExistingItem, {
			message: "commandAdd",
			visible: function () {
				return !app.editing && app.deviceType == "group";
			}
		}),
		React.createElement(Command, {
			message: "commandMoveIcons",
			visible: function () {
				return !app.editing && app.deviceType != "single";
			},
			onclick: function () {
				return app.editing = true;
			}
		}),
		React.createElement(Command, {
			message: "commandRenameItem",
			visible: function () {
				return !app.editing;
			},
			onclick: "AskNewName"
		}),
		React.createElement(Command, {
			message: "commandPurgeItem",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.dialog = "DeleteDevice";
			}
		}),
		React.createElement(Command, {
			message: "commandShowLabels",
			visible: function () {
				return !local.labels && app.activeDeviceId == app.main;
			},
			onclick: function () {
				return local.labels = true;
			}
		}),
		React.createElement(Command, {
			message: "commandHideLabels",
			visible: function () {
				return local.labels && app.activeDeviceId == app.main;
			},
			onclick: function () {
				return local.labels = false;
			}
		}),
		React.createElement(Command, {
			message: "commandResetToFactorySettings",
			visible: function () {
				return app.activeDeviceId == app.main;
			},
			enabled: function () {
				return window.location.hostname != "test.sh.neroelectronics.by";
			},
			onclick: "AskToReset"
		})
	);
};
// app.purgeItem( app.activeDeviceId )

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/ContextMenu.js","/src/ui")

},{"_process":99,"buffer":94,"ui/AddExistingItem":140,"ui/Command":146}],148:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var htmlutils = require("htmlutils");

module.exports = function (app, local) {
	return function (_ref) {
		var placeId = _ref.placeId;
		var iconId = _ref.iconId;
		var iconDescr = _ref.iconDescr;
		var position = _ref.position;

		// TODO: refactoring: move to more JSX (?)
		// TODO: onTap, onPress, onClick handlers must remove themself when thread is being killed
		var icon = undefined,
		    off = undefined,
		    on = undefined,
		    absent = undefined,
		    image = undefined;
		var isMouse = false;

		var placeRect = htmlutils.tickCache(function () {
			var x = icon.parentNode;
			var r = undefined;
			while ((r = x.getBoundingClientRect(), !r.width || !r.height)) x = x.parentNode;
			return r;
		});

		var relPoint = function relPoint(p) {
			var r = placeRect();
			return {
				x: (p.x - r.left) / r.width * 100,
				y: (p.y - r.top) / r.height * 100
			};
		};

		var getPoint = function getPoint(data) {
			return relPoint({ x: data.pageX, y: data.pageY });
		};

		var getLeftTop = function getLeftTop(data) {
			var p = data.getBoundingClientRect();
			return relPoint({ x: p.left, y: p.top });
		};

		// let iconsCount = () => {
		// 	let place = app.getDevice( placeId )
		// 	return lodash.keys( place && place.content ).length
		// }

		var imageHeight = htmlutils.tickCache(function () {
			if (!isMouse) return icon.getBoundingClientRect().height;
			if (opts.iconData) {
				if (opts.iconData.deviceImageGetHeight) {
					var r = opts.iconData.deviceImageGetHeight();
					if (r) return r;
				}
				var h = opts.iconData.getElementsByClassName("device_image_height")[0];
				if (h != null && h.getBoundingClientRect) {
					var r = h.getBoundingClientRect().height;
					if (r) return r;
				}
				for (var i = 0; i < opts.iconData.childNodes.length; ++i) {
					var r = opts.iconData.childNodes.item(i);
					if (r.getBoundingClientRect) {
						r = r.getBoundingClientRect().height;
						if (r) return r;
					}
				}
			}
			return image.getBoundingClientRect().height;
		});

		var opts = ra(Object.defineProperties({
			iconData: null,

			iconCommand: function iconCommand(cmd, data) {
				return app.iconCommand(iconDescr, iconId, cmd, data);
			},

			isDimmering: false,
			moving: false,
			moved: false,
			x: null,
			y: null,

			state: 0,
			onning: false,
			offing: false,
			final: true,
			errorneous: false,

			setOpacity: function setOpacity(node, opacity) {
				if (opacity == null) {
					delete node.style.opacity;
				} else {
					node.style.opacity = opacity;
				}
			}
		}, {
			iconName: {
				get: function () {
					return iconDescr && iconDescr.valueOf() && iconDescr.valueOf().icon || null;
				},
				configurable: true,
				enumerable: true
			},
			iconTemplate: {
				get: function () {
					return this.iconName && app.icons && Object.prototype.hasOwnProperty.call(app.icons, this.iconName) && app.icons[this.iconName] || null;
				},
				configurable: true,
				enumerable: true
			},
			updateIconDataState: {
				get: function () {
					var data = this.iconData;
					if (data && data.deviceSetState) data.deviceSetState(this.state);
				},
				configurable: true,
				enumerable: true
			},
			dimmering: {
				get: function () {
					var i = iconDescr == null ? null : iconDescr.valueOf();
					var id = i == null ? null : i.dimmering == null ? null : !!i.dimmering;
					if (id != null) return id;
					if (i != null && i.type === "place") return false;
					return true;
				},
				configurable: true,
				enumerable: true
			},
			image_on: {
				get: function () {
					var i = iconDescr && iconDescr.valueOf();
					var file = "" || i && i.image_on || i && i.image;
					return file && "/images/" + file;
				},
				configurable: true,
				enumerable: true
			},
			update_image_on: {
				get: function () {
					if (opts.image_on) on.src = opts.image_on;
				},
				configurable: true,
				enumerable: true
			},
			image_off: {
				get: function () {
					var i = iconDescr && iconDescr.valueOf();
					var file = "" || i && i.image_off || i && i.image;
					return file && "/images/" + file;
				},
				configurable: true,
				enumerable: true
			},
			update_image_off: {
				get: function () {
					if (opts.image_off) off.src = opts.image_off;
				},
				configurable: true,
				enumerable: true
			},
			present: {
				get: function () {
					return !!(iconDescr.get("content") || iconDescr.get("group"));
				},
				configurable: true,
				enumerable: true
			},
			updateState: {
				get: function () {
					var d = iconDescr && iconDescr.valueOf();
					if (!d) return 0;
					if (d.newstate_timestamp && (!d.state_timestamp || d.newstate_timestamp > d.state_timestamp)) {
						var fonning = d.newstate >= d.state;
						this.onning = fonning;
						this.offing = !fonning;
						this.final = false;
						this.state = d.newstate;
					} else {
						this.onning = false;
						this.offing = false;
						this.final = true;
						this.state = d.state;
					}
					this.errorneous = !!d.errorneous;
				},
				configurable: true,
				enumerable: true
			},
			updateOpacity: {
				get: function () {
					if (this.iconTemplate) {
						on.style.visibility = "hidden";
						off.style.visibility = "hidden";
						absent.style.visibility = "hidden";
					} else if (!this.present) {
						this.setOpacity(on, 0);
						this.setOpacity(off, 0);
						this.setOpacity(absent, 0.7);
					} else {
						this.setOpacity(absent, 0);
						if (this.dimmering) {
							this.setOpacity(on, this.state);
							this.setOpacity(off, (1 - this.state) * 0.333);
						} else {
							this.setOpacity(on, +!!this.state);
							this.setOpacity(off, +!this.state);
						}
					}
				},
				configurable: true,
				enumerable: true
			}
		}));

		var MOVE_PAGE_DIST = 0.1;
		var MOVE_SIDE_DIST = 0.25;

		function compareIndex(a, b) {
			return a.index - b.index;
		}

		var move = regeneratorRuntime.mark(function move(start, next) {
			var changes, currentPosition, done, hover, _ret;

			return regeneratorRuntime.wrap(function move$(context$3$0) {
				var _this = this;

				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						if (opts.moving) opts.moving.kill("restarting by another finger");

						changes = app.localDevices.createRecord();
						currentPosition = position.valueOf();
						done = false;
						hover = ra(Object.defineProperties({
							savedId: null,
							cachedId: null,
							id: null,
							position: null,

							updateApp: function updateApp(value) {
								if (this.savedId) app.hover = lu.applyDiff(app.hover, _defineProperty({}, this.savedId, _defineProperty({}, placeId, _defineProperty({}, iconId, value))));
							}

						}, {
							updateCache: { // TODO: insert debounce mechanism just into ra

								get: function () {
									// debounce id changing
									this.cachedId = this.id;
								},
								configurable: true,
								enumerable: true
							},
							saveId: {
								get: function () {
									this.updateApp(null);
									this.savedId = this.cachedId;
									this.updateApp(true);
								},
								configurable: true,
								enumerable: true
							}
						}));
						context$3$0.prev = 5;
						return context$3$0.delegateYield(regeneratorRuntime.mark(function callee$3$0() {
							var self, p, r, fingerShift, _loop, pt, _ret2;

							return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
								while (1) switch (context$4$0.prev = context$4$0.next) {
									case 0:
										self = co.current;

										ra(function () {
											return !done && !app.editing && self.kill();
										});

										p = getPoint(start);
										r = getLeftTop(icon);

										opts.moving = co.current;
										opts.moved = false;
										fingerShift = {
											x: r.x - p.x,
											y: r.y - p.y
										};

										opts.x = r.x;
										opts.y = r.y;

										_loop = function (pt) {
											var finger = getPoint(pt);
											var corner = {
												x: finger.x + fingerShift.x,
												y: finger.y + fingerShift.y
											};
											if (opts.x != corner.x || opts.y != corner.y) opts.moved = true;
											opts.x = corner.x;
											opts.y = corner.y;

											var pageSize = {
												x: app.pageWidth,
												y: app.pageHeight
											};
											var cellSize = {
												x: 100 / pageSize.x,
												y: 100 / pageSize.y
											};
											var index = {
												x: Math.min(pageSize.x - 1, Math.max(0, Math.floor(finger.x / cellSize.x))),
												y: Math.min(pageSize.y - 1, Math.max(0, Math.floor(finger.y / cellSize.y)))
											};
											var inCell = {
												x: finger.x / cellSize.x - index.x,
												y: finger.y / cellSize.y - index.y
											};

											var placePosition = index.x + index.y * pageSize.x + (local.placesPages[placeId] || 0) * pageSize.x * pageSize.y;

											var isInCenter = inCell.x > MOVE_SIDE_DIST && inCell.x < 1 - MOVE_SIDE_DIST && inCell.y > MOVE_SIDE_DIST && inCell.y < 1 - MOVE_SIDE_DIST;

											if (!isInCenter || hover.position != placePosition) hover.id = null;
											hover.position = placePosition;

											if (pt.type != "stop") return "continue";

											hover.id = null;

											if (inCell > 1 - MOVE_PAGE_DIST && cellSize.x == pageSize.x - 1) {
												// TODO: scroll page right
												return "continue";
											}
											if (inCell < MOVE_PAGE_DIST && cellSize.x == pageSize.x - 1) {
												// TODO: scroll page left
												return "continue";
											}

											var place = lu.get(changes, "summary", "content", placeId, "content");
											if (!place || !place[iconId]) return {
													v: {
														v: undefined
													}
												};
											var keys = lodash.keys(place).map(function (key) {
												return { key: key, index: place[key].index };
											}).sort(compareIndex);

											var newIndex = undefined;

											if (placePosition < 0) {
												if (currentPosition <= 0) return "continue";
												newIndex = keys[0].index - 1;
											} else if (placePosition > keys.length - 1) {
												if (currentPosition >= keys.length - 1) return "continue";
												newIndex = keys[keys.length - 1].index + 1;
											} else {
												if (currentPosition == placePosition) return "continue";
												if (isInCenter) {
													// TODO
													hover.id = keys[placePosition].key;
													var srcType = iconDescr && iconDescr.valueOf() && iconDescr.valueOf().type;
													var dstDevice = app.getDevice(hover.id);
													var dstType = dstDevice && dstDevice.type;
													if (dstType == "place") return "continue";
													if (dstType == "group" && srcType == "single") return "continue";
													// TODO: allow dstType == `single` && srcType == `single`
													hover.id = null;
												}
												if (inCell.x > 0.5) {
													if (currentPosition == placePosition + 1) return "continue";
													if (index.x == pageSize.x - 1 && currentPosition > placePosition) return "continue";
													if (placePosition >= keys.length - 1) newIndex = keys[placePosition].index + 1;else newIndex = (keys[placePosition].index + keys[placePosition + 1].index) / 2;
												} else {
													if (currentPosition == placePosition - 1) return "continue";
													if (index.x == 0 && currentPosition < placePosition) return "continue";
													if (placePosition <= 0) newIndex = keys[placePosition].index - 1;else newIndex = (keys[placePosition].index + keys[placePosition - 1].index) / 2;
												}
											}

											var newPosition = keys.map(function (k) {
												return k.key != iconId ? k : { key: k.key, index: newIndex };
											}).sort(compareIndex).findIndex(function (k) {
												return k.key == iconId;
											});

											if (currentPosition == newPosition) return "continue";

											currentPosition = newPosition;
											changes.assign({ content: _defineProperty({}, placeId, { content: _defineProperty({}, iconId, { index: newIndex }) }) });
										};

										pt = undefined;

									case 11:
										context$4$0.next = 13;
										return next;

									case 13:
										if (!(pt = context$4$0.sent)) {
											context$4$0.next = 23;
											break;
										}

										_ret2 = _loop(pt);
										context$4$0.t0 = _ret2;
										context$4$0.next = context$4$0.t0 === "continue" ? 18 : 19;
										break;

									case 18:
										return context$4$0.abrupt("continue", 21);

									case 19:
										if (!(typeof _ret2 === "object")) {
											context$4$0.next = 21;
											break;
										}

										return context$4$0.abrupt("return", _ret2.v);

									case 21:
										context$4$0.next = 11;
										break;

									case 23:
										done = true;

										if (!hover.id) {
											context$4$0.next = 29;
											break;
										}

										changes.close();
										// TODO
										// let newPlace = app.getDevice( hover.id )
										// if ( newPlace && newPlace.type == `single` ) {
										// 	app.linkingDevices = [ hover.id, iconId ]
										// 	app.dialog = `CreatePlaceOrGroup`
										// }
										// else
										app.insertInto(hover.id, iconId, placeId);
										context$4$0.next = 32;
										break;

									case 29:
										context$4$0.next = 31;
										return co.sleep();

									case 31:
										lu.when(changes.save(), function () {
											return changes.close();
										});

									case 32:
									case "end":
										return context$4$0.stop();
								}
							}, callee$3$0, _this);
						})(), "t0", 7);

					case 7:
						_ret = context$3$0.t0;

						if (!(typeof _ret === "object")) {
							context$3$0.next = 10;
							break;
						}

						return context$3$0.abrupt("return", _ret.v);

					case 10:
						context$3$0.prev = 10;

						hover.id = null;
						if (!done) {
							done = true;
							changes.close();
						}
						if (opts.moving == co.current) {
							opts.moving = null;
							opts.moved = false;
						}
						return context$3$0.finish(10);

					case 15:
					case "end":
						return context$3$0.stop();
				}
			}, move, this, [[5,, 10, 15]]);
		});

		var dimm = regeneratorRuntime.mark(function dimm(next) {
			var changes, state, initialDimmeringState, pt, delta;
			return regeneratorRuntime.wrap(function dimm$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						changes = app.localDevices.createRecord();
						context$3$0.prev = 1;
						state = undefined;

						opts.isDimmering = true;
						initialDimmeringState = iconDescr && iconDescr.get("state");
						pt = undefined;

					case 6:
						context$3$0.next = 8;
						return next;

					case 8:
						if (!(pt = context$3$0.sent)) {
							context$3$0.next = 13;
							break;
						}

						if (pt.detail.type == "swipe") {
							if (data.detail.direction == "up") state = 1;else state = 0;
						} else {
							delta = -pt.deltaY / (imageHeight() * 1 /* move multiplyer */);

							state = Math.min(1, Math.max(0, initialDimmeringState + delta));
							if (state == 0 || state == 1) initialDimmeringState = state - delta;
						}
						changes.update({ content: _defineProperty({}, iconId, { state: state }) });

					case 11:
						context$3$0.next = 6;
						break;

					case 13:
						if (state != null) opts.iconCommand("Set", state);

					case 14:
						context$3$0.prev = 14;

						changes.close();
						opts.isDimmering = false;
						return context$3$0.finish(14);

					case 18:
					case "end":
						return context$3$0.stop();
				}
			}, dimm, this, [[1,, 14, 18]]);
		});

		var Picture = function Picture(attributes) {
			return React.createElement("img", {
				"class": "error",
				onerror: function () {
					this.classList.add("error");
				},
				onload: function () {
					this.classList.remove("error");
				},
				_: attributes
			});
		};

		return React.createElement(
			"div",
			{
				oncreate: function (e) {
					return icon = e.target;
				},
				onmousedown: function () {
					return isMouse = true;
				},
				onwheel: function (e) {
					return console.log(e.deltaY, e.deltaMode, e);
				},
				"class": function () {
					return "\n\t\t\ticon\n\t\t\t" + (opts.onning && "onning") + "\n\t\t\t" + (opts.offing && "offing") + "\n\t\t\t" + (opts.final && "final") + "\n\t\t\t" + (opts.errorneous && "errorneous") + "\n\t\t\t" + (opts.dimmering.valueOf() ? "dimmering" : "switching") + "\n\t\t\t" + iconId + "\n\t\t\ticon_moving_" + !!opts.moving + "\n\t\t\ticon_moved_" + (!!opts.moving && !!opts.moved) + "\n\t\t\ticon_destination_" + !!(app.hover && app.hover[iconId]) + "\n\t\t";
				},
				style: regeneratorRuntime.mark(function block() {
					var pt, i, ph, pw, ps, pi, p, w, h;
					return regeneratorRuntime.wrap(function block$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!app.editing) {
									context$3$0.next = 3;
									break;
								}

								context$3$0.next = 3;
								return co.sleep();

							case 3:
								if (block.run) {
									context$3$0.next = 7;
									break;
								}

								block.run = true;
								context$3$0.next = 9;
								break;

							case 7:
								context$3$0.next = 9;
								return co.requestAnimationFrame;

							case 9:
								pt = undefined;

								if (opts.moving) pt = { x: opts.x, y: opts.y };else {
									i = lu.valueOf(position);
									ph = app.pageHeight || 1;
									pw = app.pageWidth || 1;
									ps = pw * ph;
									pi = i % ps;
									p = (i - pi) / ps;
									w = pi % pw;
									h = (pi - w) / pw;

									w += pw * p;
									pt = { x: w * 100 / pw, y: h * 100 / ph };
								}
								return context$3$0.abrupt("return", {
									left: "" + pt.x + "%",
									top: "" + pt.y + "%"
								});

							case 12:
							case "end":
								return context$3$0.stop();
						}
					}, block, this);
				})
			},
			React.createElement(
				"div",
				{ "class": "iconControl",
					ontouch: htmlutils.preventDefault,
					ontap: function () {
						return !app.editing && opts.iconCommand("Short");
					},
					onpress: function () {
						return !app.editing && opts.iconCommand("Long");
					},
					onpan: regeneratorRuntime.mark(function callee$2$0(data) {
						var next, pt;
						return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
							while (1) switch (context$3$0.prev = context$3$0.next) {
								case 0:
									if (!app.editing) {
										context$3$0.next = 21;
										break;
									}

									next = data.detail.lock();
									context$3$0.prev = 2;
									pt = undefined;

								case 4:
									context$3$0.next = 6;
									return next;

								case 6:
									if (!(pt = context$3$0.sent)) {
										context$3$0.next = 16;
										break;
									}

									if (!(pt.detail.pressed === false)) {
										context$3$0.next = 9;
										break;
									}

									return context$3$0.abrupt("return");

								case 9:
									if (!(pt.detail.pressed == null)) {
										context$3$0.next = 11;
										break;
									}

									return context$3$0.abrupt("continue", 14);

								case 11:
									context$3$0.next = 13;
									return move(pt, next);

								case 13:
									return context$3$0.abrupt("break", 16);

								case 14:
									context$3$0.next = 4;
									break;

								case 16:
									context$3$0.prev = 16;

									data.detail.unlock(next);
									return context$3$0.finish(16);

								case 19:
									context$3$0.next = 25;
									break;

								case 21:
									if (!(data.detail.direction == "up" || data.detail.direction == "down")) {
										context$3$0.next = 25;
										break;
									}

									data.stopPropagation();
									context$3$0.next = 25;
									return dimm(data.detail.next);

								case 25:
								case "end":
									return context$3$0.stop();
							}
						}, callee$2$0, this, [[2,, 16, 19]]);
					})
				},
				React.createElement(
					"div",
					{ "class": "image", oncreate: function (e) {
							return image = e.target;
						} },
					React.createElement(Picture, { "class": "wait", src: "/images/wait.svg", style: {
							visibility: function visibility() {
								return undefined.final ? "hidden" : null;
							}
						} }),
					React.createElement(Picture, { "class": "off", src: "/images/room.svg", oncreate: function (e) {
							return off = e.target;
						} }),
					React.createElement(Picture, { "class": "on", src: "/images/room_on.svg", oncreate: function (e) {
							return on = e.target;
						} }),
					React.createElement(Picture, { "class": "absent", src: "/images/room_absent.svg", oncreate: function (e) {
							return absent = e.target;
						} }),
					React.createElement(
						"div",
						{ "class": function () {
								return "\n\t\t\t\t\tsvg\n\t\t\t\t\t" + ("state" + (!opts.present ? "Absent" : (Math.round(opts.state * 100) + 1000).toString().slice(1))) + "\n\t\t\t\t\t" + (!opts.isDimmering ? "smoothing" : "") + "\n\t\t\t\t";
							} },
						function () {
							return opts.iconData = opts.iconTemplate && htmlutils.importComponent(opts.iconTemplate) || null;
						}
					)
				),
				React.createElement(
					"span",
					{ "class": "iconLabel" },
					function () {
						return iconDescr.get(local.language) || iconDescr.get("ru") || iconDescr.get("en");
					}
				),
				React.createElement(
					"span",
					{ "class": "iconPercentage" },
					function () {
						return opts.present && opts.dimmering && "" + Math.round(opts.state * 100) + "%";
					}
				)
			),
			React.createElement("div", { "class": "deleteSign", ontouchstart: function () {
					return app.deleteItem(placeId, iconId);
				}, onmousedown: function () {
					return app.deleteItem(placeId, iconId);
				} })
		);
	};
};

// TODO: all ra structures must be linked to the current thread and must link all there tick procs to the current thread and so update all there ticks on subsequent yield and also update them all while finishing thread either normal or abnormal and then such ra structures must be destroyed to unlink from any external dependency. This must be done via implementing co.nextTick in terms like iojs.process.nextTick - nextTick callbacks must be processed before yielding subsequent result. So it is possible to let exceptions be raised in proper way. And it means that if possible nextTick callbacks will fire just after request for next yield.

// калі адразу прысвоіць left і top то чамусьці не працуе transition
// TODO: разабрацца, ці ёсьць які з гэтых двух радкоў лішні?

//

// moving

// dimmering

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Icon.js","/src/ui")

},{"_process":99,"buffer":94,"htmlutils":130,"lodash":116}],149:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");
var UID = require("uid");

module.exports = function (app, local) {

	var Place = app.load(require("ui/Place"));

	return function () {
		var marked2$0 = [pan].map(regeneratorRuntime.mark);

		var id = UID();

		function pan(next) {
			var lastDeltaX, page, size, deviceid, data, deltaX, rect, device, initialShift, shift;
			return regeneratorRuntime.wrap(function pan$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						lastDeltaX = undefined, page = undefined, size = undefined;
						deviceid = app.activeDeviceId;

						app.placesShifts.defineProperty(deviceid);
						local.placesPages.defineProperty(deviceid);
						context$3$0.prev = 4;
						data = undefined;

					case 6:
						context$3$0.next = 8;
						return next;

					case 8:
						if (!(data = context$3$0.sent)) {
							context$3$0.next = 25;
							break;
						}

						if (data.lastDeltaX) lastDeltaX = data.lastDeltaX;
						deltaX = data.deltaX;
						rect = app.menuElement.getBoundingClientRect();
						device = app.getDevice(deviceid);

						if (!(!device || !device.content)) {
							context$3$0.next = 15;
							break;
						}

						return context$3$0.abrupt("return");

					case 15:
						size = Math.ceil(Object.keys(device.content).length / (app.pageWidth * app.pageHeight));

						if (!(size == 0)) {
							context$3$0.next = 18;
							break;
						}

						return context$3$0.abrupt("continue", 23);

					case 18:
						page = local.placesPages[deviceid] || 0;
						initialShift = -page * rect.width;
						shift = data.deltaX;

						if (shift > 0 && page == 0 || shift < 0 && page == size - 1) shift /= 3;
						app.placesShifts[deviceid] = shift;

					case 23:
						context$3$0.next = 6;
						break;

					case 25:
						if (lastDeltaX) {
							if (lastDeltaX > 0 && page > 0) local.placesPages[deviceid] = page - 1;else if (lastDeltaX < 0 && page < size - 1) local.placesPages[deviceid] = page + 1;
						}

					case 26:
						context$3$0.prev = 26;

						app.placesShifts[deviceid] = 0;
						return context$3$0.finish(26);

					case 29:
					case "end":
						return context$3$0.stop();
				}
			}, marked2$0[0], this, [[4,, 26, 29]]);
		}

		return React.createElement(
			"div",
			null,
			React.createElement(
				"style",
				{ "class": "style" },
				function () {
					return "\n\t\t\t\t." + id + " .icon {\n\t\t\t\t\twidth: " + 100 / app.pageWidth + "%;\n\t\t\t\t\theight: " + 100 / app.pageHeight + "%;\n\t\t\t\t}\n\t\t\t";
				}
			),
			React.createElement(
				"div",
				{ "class": "top" },
				React.createElement(
					"span",
					{ "class": "top_self" },
					React.createElement(
						htmlutils.Centered,
						null,
						function () {
							return app.caption;
						}
					)
				)
			),
			React.createElement("div", { "class": function () {
					return "menu " + id + " " + app.activeDeviceId;
				},
				onpan: regeneratorRuntime.mark(function callee$2$0(data) {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!(data.detail.direction == "left" || data.detail.direction == "right")) {
									context$3$0.next = 3;
									break;
								}

								data.stopPropagation();
								return context$3$0.delegateYield(pan(event.detail.next), "t0", 3);

							case 3:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this);
				}),
				oncreate: function () {
					var _this = this;

					app.menuElement = this;
					var shown = Object.create(null);
					ra(function () {
						var id = app.activeDeviceId;
						if (!id || shown[id]) return;
						app.placesShifts.defineProperty(id);
						local.placesPages.defineProperty(id);
						shown[id] = true;

						_this.appendChild(React.createElement(Place, { placeId: id, placeDescr: ra(function () {
								return app.getDevice(id);
							}) }));
					});
				}
			}),
			React.createElement(
				"div",
				{ "class": "bottom" },
				React.createElement("div", { "class": "help",
					onpress: function () {
						return app.dialog = "ServiceDialog";
					}
				}),
				React.createElement("div", { "class": "logo",
					onpress: function () {
						return app.dialog = "ContextMenu";
					},
					ontap: function (event) {
						if (event.shiftKey || event.srcEvent && event.srcEvent.shiftKey) return app.dialog = "ContextMenu";
						if (event.ctrlKey || event.srcEvent && event.srcEvent.ctrlKey) return app.dialog = "SearchItems";
						app.editing = false;
						app.dialog = "";
						app.go(app.main);
					}
				}),
				React.createElement("div", { "class": "back",
					ontouch: function () {
						if (app.editing) app.editing = false;else if (app.dialog) app.dialog = "";else app.back();
					}
				})
			)
		);
	};
};

// TODO: no transition while panning
// TODO: remove <Place/> when such a place is actually removed from database

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/MainScreen.js","/src/ui")

},{"_process":99,"buffer":94,"htmlutils":130,"ui/Place":151,"uid":155}],150:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var Application = require("ui/Application");

module.exports = function (_ref) {
	var IconTemplates = _ref.IconTemplates;
	return React.createElement(
		"span",
		null,
		React.createElement(
			"style",
			null,
			" ",
			".application { position: fixed !important; } } ",
			" "
		),
		React.createElement(Application, { IconTemplates: IconTemplates })
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/OneApp.js","/src/ui")

},{"_process":99,"buffer":94,"ui/Application":142}],151:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app, local) {

	var Icon = app.load(require("ui/Icon"));

	return function (_ref) {
		var placeId = _ref.placeId;
		var placeDescr = _ref.placeDescr;

		var ids = ra(function () {
			var content = placeDescr.get("content");
			return ra.Array(lodash.keys(content).sort(function (a, b) {
				return lu.compare(content[a].index, content[b].index);
			}));
		});
		var content = ra.map(ids, function (iconId, position) {
			return React.createElement(Icon, {
				placeId: placeId,
				iconId: iconId,
				position: position,
				iconDescr: ra(function () {
					return app.getDevice(iconId);
				})
			});
		});
		return React.createElement(
			"div",
			null,
			React.createElement(
				"style",
				null,
				"\n\t\t\t\t." + placeId + " .place." + placeId + " {\n\t\t\t\t\tdisplay: initial;\n\t\t\t\t}\n\t\t\t"
			),
			React.createElement(
				"div",
				{ "class": "place " + placeId, style: {
						transform: function transform() {
							return "translateX( " + (-(local.placesPages[placeId] || 0) * app.menuElement.getBoundingClientRect().width + app.placesShifts[placeId] || 0) + "px )";
						}
					} },
				function () {
					return content;
				}
			)
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Place.js","/src/ui")

},{"_process":99,"buffer":94,"ui/Icon":148}],152:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var DL = require("DamerauLevenshtein");

var notAChar = function notAChar(char) {
	return char <= " " || char == "-";
};

var fuzzy = function fuzzy(mask, text) {
	return DL(mask.toUpperCase(), text.toUpperCase(), {
		replace: Infinity,
		"delete": function _delete(char) {
			return notAChar(char) ? 0.01 : Infinity;
		},
		insert: function insert(char) {
			return notAChar(char) ? 0.01 : 1;
		},
		transpose: 1
	});
};

function watch(data, cb) {
	var v = undefined;
	return function () {
		if (v == null) ra.detach(function () {
			v = ra(data);
			ra(function () {
				v.valueOf();
				cb();
			});
		});
		return v.valueOf();
	};
}

module.exports = function (app) {
	var opts = undefined,
	    $ = {};

	var SearchItem = function SearchItem(_ref) {
		var placeId = _ref.placeId;
		return React.createElement(
			"div",
			{ "class": "searchItem " + placeId, onscrolltap: function () {
					return opts.goto(placeId);
				} },
			React.createElement(
				"span",
				{ "class": "caption" },
				function () {
					return opts.placeInfos[placeId].caption;
				}
			),
			React.createElement(
				"span",
				{ "class": "places" },
				function () {
					return opts.placeInfos[placeId].ptext;
				}
			),
			React.createElement("span", { "class": "cmdDeleteFromProgram" }),
			React.createElement("span", { "class": "cmdAppend" })
		);
	};

	opts = ra(Object.defineProperties({
		goto: function goto(id) {
			if (!id) return;
			var placeInfo = opts.placeInfos[id];
			~(app.searchAction || app.go)(id, placeInfo && placeInfo.places);
		}
	}, {
		deviceIds: {
			get: function () {
				return ra.Array(app.deviceIds.filter(function (id) {
					return id != app.main;
				}));
			},
			configurable: true,
			enumerable: true
		},
		placeInfos: {
			get: function () {
				var cache = Object.create(null);
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this.deviceIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var id = _step.value;

						var info = app.getDevice(id);
						cache[id] = {
							info: info,
							caption: app.getMessage(info),
							places: []
						};
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator["return"]) {
							_iterator["return"]();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					var _loop = function () {
						var id = _step2.value;

						lodash.forEach(cache[id].info.content, function (_, key) {
							return cache[key] && cache[key].places.push(id);
						});
					};

					for (var _iterator2 = this.deviceIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						_loop();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}

				var ret = Object.create(null);
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = this.deviceIds[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var id = _step3.value;

						var c = cache[id];
						var ptext = c.places.map(function (id) {
							return cache[id].caption;
						}).join(", ");
						if (ptext) ptext = "(" + ptext + ")";
						ret[id] = { id: id, caption: c.caption || "<***>", places: c.places, ptext: ptext };
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
							_iterator3["return"]();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				return ra.JSON(ret);
			},
			configurable: true,
			enumerable: true
		},
		labels: {
			get: function () {
				return ra.keymap(opts.live.deviceIds, function (placeId) {
					return React.createElement(SearchItem, { placeId: placeId });
				});
			},
			configurable: true,
			enumerable: true
		},
		filtered: {
			get: function () {
				var value = $.mask.raValue;
				var arr = [];
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = this.deviceIds.filter(app.searchFilter || Boolean)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var id = _step4.value;

						var i = opts.placeInfos[id];
						var key = [];
						if (value) {
							key.push(fuzzy(value, i.caption),
							// ??? Math.max( ...i.places.map( id => fuzzy( value, opts.placeInfos[ id ].caption ) ) ),
							fuzzy(value, i.caption + " " + i.ptext));
							if (key.every(function (k) {
								return Math.abs(k) == Infinity;
							})) continue;
						}
						key.push(i.caption.toUpperCase());
						arr.push({ id: id, key: key });
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
							_iterator4["return"]();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				return ra.Array(arr.sort(function (a, b) {
					return lodash.zip(a.key, b.key).map(function (pair) {
						var _lu;

						return (_lu = lu).compare.apply(_lu, _toConsumableArray(pair));
					}).reduce(function (a, b) {
						return a || b;
					});
				}).map(function (a) {
					return a.id;
				}));
			},
			configurable: true,
			enumerable: true
		},
		items: {
			get: function () {
				var _this = this;

				return ra.Array(this.filtered.map(function (id) {
					return _this.labels.get(id);
				}));
			},
			configurable: true,
			enumerable: true
		}
	}));
	window._search = opts;
	return React.createElement(
		"div",
		{
			ondialogshow: function () {
				$.scroller && $.scroller.refresh();
				// TODO: разабрацца, а ці трэба заціраць пошук?
				$.mask.raValue = "";
			}
		},
		React.createElement(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					opts.goto(opts.filtered[0]);
				}
			},
			React.createElement("input", { name: "mask", type: "text", autofocus: "autofocus", oncreate: function (event) {
					return $.mask = event.target;
				} }),
			React.createElement(
				"div",
				{ "class": "scroll", oncreate: function (event) {
						return $.scroll = event.target;
					} },
				React.createElement(
					"div",
					null,
					React.createElement(
						"div",
						{ "class": "items" },
						watch(function () {
							return opts.items;
						}, function () {
							return setTimeout(function () {
								if (!$.scroller) $.scroller = new (require("iscroll"))($.scroll, {
									mouseWheel: true,
									scrollbars: true,
									tap: "scrolltap"
								});else $.scroller.refresh();
							}, 100);
						})
					),
					React.createElement("div", { "class": "scrollAreaBottomFiller" })
				)
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/SearchItems.js","/src/ui")

},{"DamerauLevenshtein":117,"_process":99,"buffer":94,"iscroll":132}],153:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");

module.exports = function (app) {
	var json = undefined;
	return React.createElement(
		"div",
		{ ondialogshow: function () {
				return json.value = JSON.stringify(app.getDevice(app.activeDeviceId), null, 3);
			} },
		React.createElement(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					var text = json.value.trim() || null;
					try {
						text = text && JSON.parse(text);
					} catch (error) {
						return alert(error);
					}
					debugger;
					if (text) app.saveDevice(app.activeDeviceId, text);
					app.dialog = "";
				}
			},
			React.createElement("textarea", {
				name: "json",
				autofocus: "autofocus",
				oncreate: function (event) {
					return json = event.target;
				},
				style: {
					position: "absolute",
					left: 0,
					right: 0,
					top: "10mm",
					bottom: "15mm",
					fontSize: "50%"
				}
			}),
			React.createElement(
				"a",
				{
					"class": "save",
					href: "javascript:void(0)",
					target: "_self",
					ontouch: htmlutils.Submit,
					style: {
						position: "absolute",
						display: "block",
						left: 0,
						right: 0,
						height: "10mm",
						bottom: "0"
					}
				},
				"Save"
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/ServiceDialog.js","/src/ui")

},{"_process":99,"buffer":94,"htmlutils":130}],154:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function () {
		return React.createElement(
			"div",
			{ "class": "startupScreen" },
			React.createElement(
				"p",
				null,
				"Добро пожаловать в Ваш",
				React.createElement("br", null),
				"Умный Дом!"
			),
			React.createElement(
				"div",
				{ "class": "templates" },
				React.createElement(
					"p",
					null,
					"Пожалуйста, выберите место, где используется этот пульт:"
				),
				React.createElement(
					"ul",
					{ "class": "houseTemplates" },
					function () {
						return (app.templates || []).concat([{
							menu: "начать с чистого листа",
							ru: "Мой дом",
							en: "Home",
							type: "place"
						}]).map(function (houseTemplate) {
							return React.createElement(
								"li",
								{ "class": "houseTemplate", ontouch: function () {
										return app.setTemplate(houseTemplate);
									} },
								houseTemplate.menu || app.getMessage(houseTemplate)
							);
						});
					}
				)
			),
			React.createElement("div", { "class": "loading" })
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/StartupScreen.js","/src/ui")

},{"_process":99,"buffer":94}],155:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var counter = 0;

module.exports = function uid(obj) {
	var i = (++counter).toString(36);
	var r = parseInt(Math.random().toString().slice(2, 17)).toString(36);
	var id = (r.length + 9).toString(36) + r + i;
	if (obj == null) return id;else {
		obj.uid = id;
		return obj;
	}
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/uid.js","/src")

},{"_process":99,"buffer":94}],156:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
post /devices {"P":1}
*/

"use strict";

function checkBrowserFunctions() {
	var ret = true && typeof HTMLTemplateElement != "undefined" && HTMLTemplateElement;
	return !!ret;
}

if (!checkBrowserFunctions()) {
	window.__UNSUPPORTED__();
	throw new Error("unsupported");
}

require("browser-nexttick");
require("platform");
require("htmlpolyfill");
require("track");
require("gesture");

global.lu = require("localUtils");
global.ra = require("ra");
global.co = require("co");
global.lodash = require("lodash");
require("colors");

function preventDefault(event) {
	if (event.target && event.target.getAttribute("rel") == "external") return;
	var _arr = [HTMLInputElement, HTMLTextAreaElement, HTMLOptionElement, HTMLButtonElement];
	for (var _i = 0; _i < _arr.length; _i++) {
		var C = _arr[_i];
		if (event.target instanceof C) return;
	} // attempt to use native scrolling - unsuccessfull
	// let C = event.target
	// while ( C && C.classList ) {
	// 	if ( C.classList.contains( `scroll` ) )
	// 		return
	// 	C = C.parentNode
	// }
	event.preventDefault();
}

var _arr2 = ["touchstart", "touchmove", "touchend", "touchcancel"];
for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	var type = _arr2[_i2];
	window.addEventListener(type, preventDefault);
}global.LOG = function (str) {
	// if ( String( str ) == `undefined` )
	// 	debugger
	console.log.apply(console, arguments);
	global._ALERT && global._ALERT(str);
	var xhr = new XMLHttpRequest();
	xhr.open("POST", "/log?" + encodeURIComponent(str));
	xhr.onerror = lodash.noop;
	xhr.send();
	return str;
};

window.addEventListener("error", function onError(e) {
	if (!e.message.match(404) && !onError.processing) {
		onError.processing = true;
		try {
			LOG("" + e.message.red + " at " + e.lineno + ":" + e.colno + " in " + e.filename);
		} finally {
			onError.processing = false;
		}
	}
});

var onerror = window.onerror;
window.onerror = function (message, url, line, column, error) {
	var ret = undefined;
	if (error) {
		LOG("stack: " + error.stack);
	}
	if (onerror) {
		try {
			window.onerror = onerror;
			ret = onerror.apply(this, arguments);
		} finally {
			onerror = window.onerror;
		}
	}
	return ret;
};

// require( `touchLog` )
// require( `touchShow` )
// require( `touches` )

global.React = require("components");

function script(text) {
	var script = document.createElement("script");
	script.appendChild(document.createTextNode(text));
	return script;
}

co.go(regeneratorRuntime.mark(function callee$0$0() {
	var html, data, tmp, children, i;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				html = cacheUrlResource("./main.html");
				context$1$0.next = 3;
				return html;

			case 3:
				html = context$1$0.sent;
				data = document.createDocumentFragment();
				tmp = document.createElement("div");

				tmp.innerHTML = html;
				tmp = tmp.children[0];
				children = [];

				for (i = 0; i < tmp.childNodes.length; ++i) {
					children.push(tmp.childNodes[i]);
				}children.forEach(function (c) {
					return tmp.removeChild(c);
				});
				children.forEach(function (c) {
					if (c instanceof HTMLScriptElement) c = script(c.innerHTML);
					data.appendChild(c);
				});

				document.body.appendChild(data);

			case 13:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
}));

// window.addEventListener( // TODO: выдаліць пасьля выставы. Надта страшна яно дзёргаецца пры перазагрузцы
// 	`message`,
// 	event => {
// 		if ( event && event.data && event.data.what == `urlResourceUpdated` )
// 			window.setTimeout(
// 				() => window.location.reload(),
// 				1000
// 			)
// 	},
// 	false
// )

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/webpage.js","/src")

},{"_process":99,"browser-nexttick":124,"buffer":94,"co":125,"colors":109,"components":126,"gesture":128,"htmlpolyfill":129,"localUtils":134,"lodash":116,"platform":135,"ra":136,"track":139}],157:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ra = require("ra");

var windowSize = ra.clean({
	width: 1,
	height: 1,
	ppmm: 1,
	widthmm: 1,
	heightmm: 1,
	pixelRatio: 1,
	orientation: 0,
	layout: "vertical",
	window: "browser"
}).setName("windowSize");

window.addEventListener("resize", updateSize);

// let orientations = {}

var cm = document.createElement("div");
cm.style.left = "0";
cm.style.top = "0";
cm.style.width = "10cm";
cm.style.height = "10cm";
cm.style.position = "fixed";
cm.style.zIndex = "-9999";
document.body.appendChild(cm);
var ppmm = cm.clientWidth / 100;
document.body.removeChild(cm);

updateSize();

function updateSize() {

	var width = window.innerWidth;
	var height = window.innerHeight;

	var orientation = (window.orientation || 0) % 360;
	if (orientation < 0) orientation += 360;

	windowSize.width = width;
	windowSize.height = height;
	windowSize.ppmm = ppmm;
	windowSize.widthmm = width / ppmm;
	windowSize.heightmm = height / ppmm;
	windowSize.pixelRatio = window.devicePixelRatio || 1;
	windowSize.orientation = orientation;
	windowSize.layout = width <= height ? "vertical" : "horizontal";
	windowSize.window = window.navigator.standalone ? "app" : "browser";
}

module.exports = windowSize;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/windowSize.js","/src")

},{"_process":99,"buffer":94,"ra":136}],158:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require( "webpage" )
require( "ui/OneApp" )
global.require = function r( name ) {
					global.require = null
					try {
						return require.apply( this, arguments )
					}
					finally {
						global.require = r
					}
				}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/tmp/index.js","/tmp")

},{"_process":99,"buffer":94,"ui/OneApp":150,"webpage":156}]},{},[93,158])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9saWIvYmFiZWwvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY3R4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmVudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZncuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZ2V0LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5taXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQub3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQucGFydGlhbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5yZWRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5yZXBsYWNlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zYW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnNldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc3RyaW5nLXBhZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdHJpbmctcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnRhc2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudGhyb3dzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnVpZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC51bnNjb3BlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLndrcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM1LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5zdGF0aWNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnN0YXRpY3MtYWNjZXB0LXByaW1pdGl2ZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVnZXhwLmVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmxwYWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucnBhZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvanMuYXJyYXkuc3RhdGljcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3IvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsaWZ5L3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL2NvbG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL2N1c3RvbS90cmFwLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvY3VzdG9tL3phbGdvLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvZXh0ZW5kU3RyaW5nUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9tYXBzL2FtZXJpY2EuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9tYXBzL3JhaW5ib3cuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9tYXBzL3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL21hcHMvemVicmEuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9zdHlsZXMuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9zeXN0ZW0vc3VwcG9ydHMtY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9kaXN0L2xvZGFzaC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9EYW1lcmF1TGV2ZW5zaHRlaW4uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvSlNPTmxvY2FsLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL0xPRy5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9QaW5nUG9uZ0pTT04uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvV2ViUXVldWUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvV2ViU29ja2V0VG9KU09OLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2FwcC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9icm93c2VyLW5leHR0aWNrLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvbXBvbmVudHMuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvZGV2ZGIuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvZ2VzdHVyZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9odG1scG9seWZpbGwuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvaHRtbHV0aWxzLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2h0dHBDbGllbnQuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvaXNjcm9sbC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9sYXRlci5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9sb2NhbFV0aWxzLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3BsYXRmb3JtLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3JhLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3NjaGVkdWxlci5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9zcGFyc2VxdWV1ZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy90cmFjay5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9BZGRFeGlzdGluZ0l0ZW0uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQWRkTWVudS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9BcHBsaWNhdGlvbi5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9Bc2tOZXdOYW1lLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL0Fza1RvTGlua0RldmljZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9CdXR0b24uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQ29tbWFuZC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9Db250ZXh0TWVudS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9JY29uLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL01haW5TY3JlZW4uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvT25lQXBwLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1BsYWNlLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1NlYXJjaEl0ZW1zLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1NlcnZpY2VEaWFsb2cuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvU3RhcnR1cFNjcmVlbi5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aWQuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvd2VicGFnZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy93aW5kb3dTaXplLmpzIiwidG1wL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNSQTtBQUNBO0FBQ0E7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWkE7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbENBO0FBQ0E7QUFDQTs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0pBO0FBQ0E7QUFDQTs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDSkE7QUFDQTs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25uQkE7QUFDQTs7Ozs7QUNEQTtBQUNBOzs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdDRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6bk5BLFNBQVMsT0FBTyxDQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRztBQUNuQyxLQUFJLElBQUksR0FBRyxPQUFPLEtBQUssWUFBWSxHQUFHLEtBQUssQ0FBRSxFQUFFLENBQUUsR0FBRyxLQUFLLENBQUE7QUFDekQsUUFBTyxPQUFPLElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUUsR0FBRyxJQUFJLENBQUE7Q0FDbEU7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFFLEVBQUUsRUFBRSxFQUFFLEVBQWlCO0tBQWYsS0FBSyxnQ0FBRyxDQUFDOztBQUNuQyxLQUFJLENBQUMsR0FBRyxFQUFFLENBQUE7QUFDVixNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFF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UUFBUSxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUE7QUFDbkMsV0FBVSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFBO0FBQ3BELFdBQVUsQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFBO0FBQ3BDLFdBQVUsQ0FBQyxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sNEJBQTRCLENBQUE7QUFDL0QsV0FBVSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsb0JBQW9CLENBQUE7Q0FDbkU7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFVLENBQUE7Ozs7OztBQ2xEM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3IvcnVudGltZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC9wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTsiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyICQgPSByZXF1aXJlKCcuLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSAkLnRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSAkLnRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAkLnRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59OyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciAkICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGN0eCA9IHJlcXVpcmUoJy4vJC5jdHgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IE9iamVjdCgkLmFzc2VydERlZmluZWQoJHRoaXMpKVxuICAgICAgLCBzZWxmICAgPSAkLkVTNU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gJC50b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBBcnJheShsZW5ndGgpIDogSVNfRklMVEVSID8gW10gOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnMSwgbXNnMil7XG4gIGlmKCFjb25kaXRpb24pdGhyb3cgVHlwZUVycm9yKG1zZzIgPyBtc2cxICsgbXNnMiA6IG1zZzEpO1xufVxuYXNzZXJ0LmRlZiA9ICQuYXNzZXJ0RGVmaW5lZDtcbmFzc2VydC5mbiA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoISQuaXNGdW5jdGlvbihpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbmFzc2VydC5vYmogPSBmdW5jdGlvbihpdCl7XG4gIGlmKCEkLmlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5hc3NlcnQuaW5zdCA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgVHlwZUVycm9yKG5hbWUgKyBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XG4gIHJldHVybiBpdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydDsiLCJ2YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGVudW1LZXlzID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2Upe1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICB2YXIgVCA9IE9iamVjdCgkLmFzc2VydERlZmluZWQodGFyZ2V0KSlcbiAgICAsIGwgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpID0gMTtcbiAgd2hpbGUobCA+IGkpe1xuICAgIHZhciBTICAgICAgPSAkLkVTNU9iamVjdChhcmd1bWVudHNbaSsrXSlcbiAgICAgICwga2V5cyAgID0gZW51bUtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailUW2tleSA9IGtleXNbaisrXV0gPSBTW2tleV07XG4gIH1cbiAgcmV0dXJuIFQ7XG59OyIsInZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgVEFHICAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLCB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuZnVuY3Rpb24gY29mKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn1cbmNvZi5jbGFzc29mID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVDtcbiAgcmV0dXJuIGl0ID09IHVuZGVmaW5lZCA/IGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6ICdOdWxsJ1xuICAgIDogdHlwZW9mIChUID0gKE8gPSBPYmplY3QoaXQpKVtUQUddKSA9PSAnc3RyaW5nJyA/IFQgOiBjb2YoTyk7XG59O1xuY29mLnNldCA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhJC5oYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpJC5oaWRlKGl0LCBUQUcsIHRhZyk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjb2Y7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjdHggICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIHNhZmUgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmVcbiAgLCBhc3NlcnQgICA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKVxuICAsIGZvck9mICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc3RlcCAgICAgPSByZXF1aXJlKCcuLyQuaXRlcicpLnN0ZXBcbiAgLCAkaGFzICAgICA9ICQuaGFzXG4gICwgc2V0ICAgICAgPSAkLnNldFxuICAsIGlzT2JqZWN0ID0gJC5pc09iamVjdFxuICAsIGhpZGUgICAgID0gJC5oaWRlXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBpc09iamVjdFxuICAsIElEICAgICAgID0gc2FmZSgnaWQnKVxuICAsIE8xICAgICAgID0gc2FmZSgnTzEnKVxuICAsIExBU1QgICAgID0gc2FmZSgnbGFzdCcpXG4gICwgRklSU1QgICAgPSBzYWZlKCdmaXJzdCcpXG4gICwgSVRFUiAgICAgPSBzYWZlKCdpdGVyJylcbiAgLCBTSVpFICAgICA9ICQuREVTQyA/IHNhZmUoJ3NpemUnKSA6ICdzaXplJ1xuICAsIGlkICAgICAgID0gMDtcblxuZnVuY3Rpb24gZmFzdEtleShpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCEkaGFzKGl0LCBJRCkpe1xuICAgIC8vIGNhbid0IHNldCBpZCB0byBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBpZFxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBvYmplY3QgaWRcbiAgICBoaWRlKGl0LCBJRCwgKytpZCk7XG4gIC8vIHJldHVybiBvYmplY3QgaWQgd2l0aCBwcmVmaXhcbiAgfSByZXR1cm4gJ08nICsgaXRbSURdO1xufVxuXG5mdW5jdGlvbiBnZXRFbnRyeSh0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdFtPMV1baW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdFtGSVJTVF07IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhc3NlcnQuaW5zdCh0aGF0LCBDLCBOQU1FKTtcbiAgICAgIHNldCh0aGF0LCBPMSwgJC5jcmVhdGUobnVsbCkpO1xuICAgICAgc2V0KHRoYXQsIFNJWkUsIDApO1xuICAgICAgc2V0KHRoYXQsIExBU1QsIHVuZGVmaW5lZCk7XG4gICAgICBzZXQodGhhdCwgRklSU1QsIHVuZGVmaW5lZCk7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlcXVpcmUoJy4vJC5taXgnKShDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpe1xuICAgICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdFtPMV0sIGVudHJ5ID0gdGhhdFtGSVJTVF07IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0W0ZJUlNUXSA9IHRoYXRbTEFTVF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYoZW50cnkpe1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkublxuICAgICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdFtPMV1bZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0W0ZJUlNUXSA9PSBlbnRyeSl0aGF0W0ZJUlNUXSA9IG5leHQ7XG4gICAgICAgICAgaWYodGhhdFtMQVNUXSA9PSBlbnRyeSl0aGF0W0xBU1RdID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXNbRklSU1RdKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKCQuREVTQykkLnNldERlc2MoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gYXNzZXJ0LmRlZih0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXRbTEFTVF0gPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0W0xBU1RdLCAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0W0ZJUlNUXSl0aGF0W0ZJUlNUXSA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0W08xXVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gIHNldEl0ZXI6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgcmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgazoga2luZH0pO1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXG4gICAgICAgICwga2luZCAgPSBpdGVyLmtcbiAgICAgICAgLCBlbnRyeSA9IGl0ZXIubDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIWl0ZXIubyB8fCAhKGl0ZXIubCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogaXRlci5vW0ZJUlNUXSkpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICBpdGVyLm8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgZm9yT2YgPSByZXF1aXJlKCcuLyQuZm9yLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICAkZGVmKCRkZWYuUCwgTkFNRSwge1xuICAgIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3JPZih0aGlzLCBmYWxzZSwgYXJyLnB1c2gsIGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHNhZmUgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlXG4gICwgYXNzZXJ0ICAgID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpXG4gICwgZm9yT2YgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgJGhhcyAgICAgID0gJC5oYXNcbiAgLCBpc09iamVjdCAgPSAkLmlzT2JqZWN0XG4gICwgaGlkZSAgICAgID0gJC5oaWRlXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBpc09iamVjdFxuICAsIGlkICAgICAgICA9IDBcbiAgLCBJRCAgICAgICAgPSBzYWZlKCdpZCcpXG4gICwgV0VBSyAgICAgID0gc2FmZSgnd2VhaycpXG4gICwgTEVBSyAgICAgID0gc2FmZSgnbGVhaycpXG4gICwgbWV0aG9kICAgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKVxuICAsIGZpbmQgICAgICA9IG1ldGhvZCg1KVxuICAsIGZpbmRJbmRleCA9IG1ldGhvZCg2KTtcbmZ1bmN0aW9uIGZpbmRGcm96ZW4oc3RvcmUsIGtleSl7XG4gIHJldHVybiBmaW5kKHN0b3JlLmFycmF5LCBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufVxuLy8gZmFsbGJhY2sgZm9yIGZyb3plbiBrZXlzXG5mdW5jdGlvbiBsZWFrU3RvcmUodGhhdCl7XG4gIHJldHVybiB0aGF0W0xFQUtdIHx8IGhpZGUodGhhdCwgTEVBSywge1xuICAgIGFycmF5OiBbXSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSl7XG4gICAgICB2YXIgZW50cnkgPSBmaW5kRnJvemVuKHRoaXMsIGtleSk7XG4gICAgICBpZihlbnRyeSlyZXR1cm4gZW50cnlbMV07XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSl7XG4gICAgICByZXR1cm4gISFmaW5kRnJvemVuKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgdmFyIGVudHJ5ID0gZmluZEZyb3plbih0aGlzLCBrZXkpO1xuICAgICAgaWYoZW50cnkpZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgIGVsc2UgdGhpcy5hcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSxcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleCh0aGlzLmFycmF5LCBmdW5jdGlvbihpdCl7XG4gICAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgICAgfSk7XG4gICAgICBpZih+aW5kZXgpdGhpcy5hcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuICEhfmluZGV4O1xuICAgIH1cbiAgfSlbTEVBS107XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgICQuc2V0KGFzc2VydC5pbnN0KHRoYXQsIEMsIE5BTUUpLCBJRCwgaWQrKyk7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlcXVpcmUoJy4vJC5taXgnKShDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKCFpc0V4dGVuc2libGUoa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gJGhhcyhrZXksIFdFQUspICYmICRoYXMoa2V5W1dFQUtdLCB0aGlzW0lEXSkgJiYgZGVsZXRlIGtleVtXRUFLXVt0aGlzW0lEXV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIWlzRXh0ZW5zaWJsZShrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiAkaGFzKGtleSwgV0VBSykgJiYgJGhhcyhrZXlbV0VBS10sIHRoaXNbSURdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICBpZighaXNFeHRlbnNpYmxlKGFzc2VydC5vYmooa2V5KSkpe1xuICAgICAgbGVha1N0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGhhcyhrZXksIFdFQUspIHx8IGhpZGUoa2V5LCBXRUFLLCB7fSk7XG4gICAgICBrZXlbV0VBS11bdGhhdFtJRF1dID0gdmFsdWU7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgbGVha1N0b3JlOiBsZWFrU3RvcmUsXG4gIFdFQUs6IFdFQUssXG4gIElEOiBJRFxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgQlVHR1kgPSByZXF1aXJlKCcuLyQuaXRlcicpLkJVR0dZXG4gICwgZm9yT2YgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBzcGVjaWVzID0gcmVxdWlyZSgnLi8kLnNwZWNpZXMnKVxuICAsIGFzc2VydEluc3RhbmNlID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLmluc3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSAkLmdbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIGZ1bmN0aW9uIGZpeE1ldGhvZChLRVkpe1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVxdWlyZSgnLi8kLnJlZGVmJykocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uKGEpeyByZXR1cm4gZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyB9XG4gICAgICA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKXsgcmV0dXJuIGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgfVxuICAgICAgOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSl7IHJldHVybiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IH1cbiAgICAgIDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKXsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH1cbiAgaWYoISQuaXNGdW5jdGlvbihDKSB8fCAhKElTX1dFQUsgfHwgIUJVR0dZICYmIHByb3RvLmZvckVhY2ggJiYgcHJvdG8uZW50cmllcykpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZXF1aXJlKCcuLyQubWl4JykoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0ICA9IG5ldyBDXG4gICAgICAsIGNoYWluID0gaW5zdFtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpXG4gICAgICAsIGJ1Z2d5WmVybztcbiAgICAvLyB3cmFwIGZvciBpbml0IGNvbGxlY3Rpb25zIGZyb20gaXRlcmFibGVcbiAgICBpZighcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IG5ldyBDKGl0ZXIpOyB9KSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgICAgYXNzZXJ0SW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBuZXcgQmFzZTtcbiAgICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIElTX1dFQUsgfHwgaW5zdC5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwga2V5KXtcbiAgICAgIGJ1Z2d5WmVybyA9IDEgLyBrZXkgPT09IC1JbmZpbml0eTtcbiAgICB9KTtcbiAgICAvLyBmaXggY29udmVydGluZyAtMCBrZXkgdG8gKzBcbiAgICBpZihidWdneVplcm8pe1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgLy8gKyBmaXggLmFkZCAmIC5zZXQgZm9yIGNoYWluaW5nXG4gICAgaWYoYnVnZ3laZXJvIHx8IGNoYWluICE9PSBpbnN0KWZpeE1ldGhvZChBRERFUik7XG4gIH1cblxuICByZXF1aXJlKCcuLyQuY29mJykuc2V0KEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZGVmKCRkZWYuRyArICRkZWYuVyArICRkZWYuRiAqIChDICE9IEJhc2UpLCBPKTtcbiAgc3BlY2llcyhDKTtcbiAgc3BlY2llcygkLmNvcmVbTkFNRV0pOyAvLyBmb3Igd3JhcHBlclxuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRJdGVyKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59OyIsIi8vIE9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFzc2VydEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLmZuO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4pO1xuICBpZih+bGVuZ3RoICYmIHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9IHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgIH07XG59OyIsInZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBnbG9iYWwgICAgID0gJC5nXG4gICwgY29yZSAgICAgICA9ICQuY29yZVxuICAsIGlzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb25cbiAgLCAkcmVkZWYgICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmJyk7XG5mdW5jdGlvbiBjdHgoZm4sIHRoYXQpe1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZGVmLkYgPSAxOyAgLy8gZm9yY2VkXG4kZGVmLkcgPSAyOyAgLy8gZ2xvYmFsXG4kZGVmLlMgPSA0OyAgLy8gc3RhdGljXG4kZGVmLlAgPSA4OyAgLy8gcHJvdG9cbiRkZWYuQiA9IDE2OyAvLyBiaW5kXG4kZGVmLlcgPSAzMjsgLy8gd3JhcFxuZnVuY3Rpb24gJGRlZih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwXG4gICAgLCBpc0dsb2JhbCA9IHR5cGUgJiAkZGVmLkdcbiAgICAsIGlzUHJvdG8gID0gdHlwZSAmICRkZWYuUFxuICAgICwgdGFyZ2V0ICAgPSBpc0dsb2JhbCA/IGdsb2JhbCA6IHR5cGUgJiAkZGVmLlNcbiAgICAgICAgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KS5wcm90b3R5cGVcbiAgICAsIGV4cG9ydHMgID0gaXNHbG9iYWwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgaWYoaXNHbG9iYWwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICEodHlwZSAmICRkZWYuRikgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgaWYodHlwZSAmICRkZWYuQiAmJiBvd24pZXhwID0gY3R4KG91dCwgZ2xvYmFsKTtcbiAgICBlbHNlIGV4cCA9IGlzUHJvdG8gJiYgaXNGdW5jdGlvbihvdXQpID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmKHRhcmdldCAmJiAhb3duKSRyZWRlZih0YXJnZXQsIGtleSwgb3V0KTtcbiAgICAvLyBleHBvcnRcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KSQuaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoaXNQcm90bykoZXhwb3J0cy5wcm90b3R5cGUgfHwgKGV4cG9ydHMucHJvdG90eXBlID0ge30pKVtrZXldID0gb3V0O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9ICRkZWY7IiwidmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBkb2N1bWVudCA9ICQuZy5kb2N1bWVudFxuICAsIGlzT2JqZWN0ID0gJC5pc09iamVjdFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxuICAgICwgZ2V0RGVzYyAgICA9ICQuZ2V0RGVzY1xuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgaWYoZ2V0U3ltYm9scykkLmVhY2guY2FsbChnZXRTeW1ib2xzKGl0KSwgZnVuY3Rpb24oa2V5KXtcbiAgICBpZihnZXREZXNjKGl0LCBrZXkpLmVudW1lcmFibGUpa2V5cy5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4ga2V5cztcbn07IiwidmFyIGN0eCAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBnZXQgID0gcmVxdWlyZSgnLi8kLml0ZXInKS5nZXRcbiAgLCBjYWxsID0gcmVxdWlyZSgnLi8kLml0ZXItY2FsbCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQpe1xuICB2YXIgaXRlcmF0b3IgPSBnZXQoaXRlcmFibGUpXG4gICAgLCBmICAgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgc3RlcDtcbiAgd2hpbGUoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKXtcbiAgICBpZihjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKSA9PT0gZmFsc2Upe1xuICAgICAgcmV0dXJuIGNhbGwuY2xvc2UoaXRlcmF0b3IpO1xuICAgIH1cbiAgfVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpe1xuICAkLkZXICAgPSB0cnVlO1xuICAkLnBhdGggPSAkLmc7XG4gIHJldHVybiAkO1xufTsiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XHJcbnZhciAkID0gcmVxdWlyZSgnLi8kJylcclxuICAsIHRvU3RyaW5nID0ge30udG9TdHJpbmdcclxuICAsIGdldE5hbWVzID0gJC5nZXROYW1lcztcclxuXHJcbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcclxuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcclxuXHJcbmZ1bmN0aW9uIGdldFdpbmRvd05hbWVzKGl0KXtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGdldE5hbWVzKGl0KTtcclxuICB9IGNhdGNoKGUpe1xyXG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcclxuICBpZih3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJylyZXR1cm4gZ2V0V2luZG93TmFtZXMoaXQpO1xyXG4gIHJldHVybiBnZXROYW1lcygkLnRvT2JqZWN0KGl0KSk7XHJcbn07IiwiLy8gRmFzdCBhcHBseVxuLy8gaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgIGNhc2UgNTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwidmFyIGFzc2VydE9iamVjdCA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKS5vYmo7XG5mdW5jdGlvbiBjbG9zZShpdGVyYXRvcil7XG4gIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFzc2VydE9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xufVxuZnVuY3Rpb24gY2FsbChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFzc2VydE9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgfSBjYXRjaChlKXtcbiAgICBjbG9zZShpdGVyYXRvcik7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuY2FsbC5jbG9zZSA9IGNsb3NlO1xubW9kdWxlLmV4cG9ydHMgPSBjYWxsOyIsInZhciAkZGVmICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcmVkZWYgICAgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWYnKVxuICAsICQgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY29mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGl0ZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIFNZTUJPTF9JVEVSQVRPUiA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEZGX0lURVJBVE9SICAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgICA9ICd2YWx1ZXMnXG4gICwgSXRlcmF0b3JzICAgICAgID0gJGl0ZXIuSXRlcmF0b3JzO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRSl7XG4gICRpdGVyLmNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZChraW5kKXtcbiAgICBmdW5jdGlvbiAkJCh0aGF0KXtcbiAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhhdCwga2luZCk7XG4gICAgfVxuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuICQkKHRoaXMpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICQkKHRoaXMpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuICQkKHRoaXMpOyB9O1xuICB9XG4gIHZhciBUQUcgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgcHJvdG8gICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgX25hdGl2ZSAgPSBwcm90b1tTWU1CT0xfSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCBfZGVmYXVsdCA9IF9uYXRpdmUgfHwgY3JlYXRlTWV0aG9kKERFRkFVTFQpXG4gICAgLCBtZXRob2RzLCBrZXk7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoX25hdGl2ZSl7XG4gICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gJC5nZXRQcm90byhfZGVmYXVsdC5jYWxsKG5ldyBCYXNlKSk7XG4gICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgIGNvZi5zZXQoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgLy8gRkYgZml4XG4gICAgaWYoJC5GVyAmJiAkLmhhcyhwcm90bywgRkZfSVRFUkFUT1IpKSRpdGVyLnNldChJdGVyYXRvclByb3RvdHlwZSwgJC50aGF0KTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoJC5GVyB8fCBGT1JDRSkkaXRlci5zZXQocHJvdG8sIF9kZWZhdWx0KTtcbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSBfZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gJC50aGF0O1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAga2V5czogICAgSVNfU0VUICAgICAgICAgICAgPyBfZGVmYXVsdCA6IGNyZWF0ZU1ldGhvZChLRVlTKSxcbiAgICAgIHZhbHVlczogIERFRkFVTFQgPT0gVkFMVUVTID8gX2RlZmF1bHQgOiBjcmVhdGVNZXRob2QoVkFMVUVTKSxcbiAgICAgIGVudHJpZXM6IERFRkFVTFQgIT0gVkFMVUVTID8gX2RlZmF1bHQgOiBjcmVhdGVNZXRob2QoJ2VudHJpZXMnKVxuICAgIH07XG4gICAgaWYoRk9SQ0UpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSkkcmVkZWYocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGRlZigkZGVmLlAgKyAkZGVmLkYgKiAkaXRlci5CVUdHWSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbn07IiwidmFyIFNZTUJPTF9JVEVSQVRPUiA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyAgICA9IGZhbHNlO1xudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW1NZTUJPTF9JVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICBpZighU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW1NZTUJPTF9JVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyBzYWZlID0gdHJ1ZTsgfTtcbiAgICBhcnJbU1lNQk9MX0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIGNsYXNzb2YgICAgICAgICAgID0gY29mLmNsYXNzb2ZcbiAgLCBhc3NlcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKVxuICAsIGFzc2VydE9iamVjdCAgICAgID0gYXNzZXJ0Lm9ialxuICAsIFNZTUJPTF9JVEVSQVRPUiAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgRkZfSVRFUkFUT1IgICAgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBJdGVyYXRvcnMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKSgnaXRlcmF0b3JzJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnNldEl0ZXJhdG9yKEl0ZXJhdG9yUHJvdG90eXBlLCAkLnRoYXQpO1xuZnVuY3Rpb24gc2V0SXRlcmF0b3IoTywgdmFsdWUpe1xuICAkLmhpZGUoTywgU1lNQk9MX0lURVJBVE9SLCB2YWx1ZSk7XG4gIC8vIEFkZCBpdGVyYXRvciBmb3IgRkYgaXRlcmF0b3IgcHJvdG9jb2xcbiAgaWYoRkZfSVRFUkFUT1IgaW4gW10pJC5oaWRlKE8sIEZGX0lURVJBVE9SLCB2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIEJVR0dZOiAna2V5cycgaW4gW10gJiYgISgnbmV4dCcgaW4gW10ua2V5cygpKSxcbiAgSXRlcmF0b3JzOiBJdGVyYXRvcnMsXG4gIHN0ZXA6IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbiAgfSxcbiAgaXM6IGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gT2JqZWN0KGl0KVxuICAgICAgLCBTeW1ib2wgPSAkLmcuU3ltYm9sO1xuICAgIHJldHVybiAoU3ltYm9sICYmIFN5bWJvbC5pdGVyYXRvciB8fCBGRl9JVEVSQVRPUikgaW4gT1xuICAgICAgfHwgU1lNQk9MX0lURVJBVE9SIGluIE9cbiAgICAgIHx8ICQuaGFzKEl0ZXJhdG9ycywgY2xhc3NvZihPKSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oaXQpe1xuICAgIHZhciBTeW1ib2wgPSAkLmcuU3ltYm9sXG4gICAgICAsIGdldEl0ZXI7XG4gICAgaWYoaXQgIT0gdW5kZWZpbmVkKXtcbiAgICAgIGdldEl0ZXIgPSBpdFtTeW1ib2wgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IEZGX0lURVJBVE9SXVxuICAgICAgICB8fCBpdFtTWU1CT0xfSVRFUkFUT1JdXG4gICAgICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG4gICAgfVxuICAgIGFzc2VydCgkLmlzRnVuY3Rpb24oZ2V0SXRlciksIGl0LCAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgICByZXR1cm4gYXNzZXJ0T2JqZWN0KGdldEl0ZXIuY2FsbChpdCkpO1xuICB9LFxuICBzZXQ6IHNldEl0ZXJhdG9yLFxuICBjcmVhdGU6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBwcm90byl7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gJC5jcmVhdGUocHJvdG8gfHwgSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiAkLmRlc2MoMSwgbmV4dCl9KTtcbiAgICBjb2Yuc2V0KENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpXG4gICwgY29yZSAgID0ge31cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHlcbiAgLCBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vclxuICAsIG1heCAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICA9IE1hdGgubWluO1xuLy8gVGhlIGVuZ2luZSB3b3JrcyBmaW5lIHdpdGggZGVzY3JpcHRvcnM/IFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHkuXG52YXIgREVTQyA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDI7IH19KS5hID09IDI7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn0oKTtcbnZhciBoaWRlID0gY3JlYXRlRGVmaW5lcigxKTtcbi8vIDcuMS40IFRvSW50ZWdlclxuZnVuY3Rpb24gdG9JbnRlZ2VyKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59XG5mdW5jdGlvbiBkZXNjKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHNpbXBsZVNldChvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmaW5lcihiaXRtYXApe1xuICByZXR1cm4gREVTQyA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuICQuc2V0RGVzYyhvYmplY3QsIGtleSwgZGVzYyhiaXRtYXAsIHZhbHVlKSk7XG4gIH0gOiBzaW1wbGVTZXQ7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGl0KXtcbiAgcmV0dXJuIGl0ICE9PSBudWxsICYmICh0eXBlb2YgaXQgPT0gJ29iamVjdCcgfHwgdHlwZW9mIGl0ID09ICdmdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGFzc2VydERlZmluZWQoaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59XG5cbnZhciAkID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZncnKSh7XG4gIGc6IGdsb2JhbCxcbiAgY29yZTogY29yZSxcbiAgaHRtbDogZ2xvYmFsLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vY29yZS1qcy1pc29iamVjdFxuICBpc09iamVjdDogICBpc09iamVjdCxcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgdGhhdDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gNy4xLjQgVG9JbnRlZ2VyXG4gIHRvSW50ZWdlcjogdG9JbnRlZ2VyLFxuICAvLyA3LjEuMTUgVG9MZW5ndGhcbiAgdG9MZW5ndGg6IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuICB9LFxuICB0b0luZGV4OiBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24oaXQsIGtleSl7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG4gIH0sXG4gIGNyZWF0ZTogICAgIE9iamVjdC5jcmVhdGUsXG4gIGdldFByb3RvOiAgIE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgREVTQzogICAgICAgREVTQyxcbiAgZGVzYzogICAgICAgZGVzYyxcbiAgZ2V0RGVzYzogICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgc2V0RGVzYzogICAgZGVmaW5lUHJvcGVydHksXG4gIHNldERlc2NzOiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuICBnZXRLZXlzOiAgICBPYmplY3Qua2V5cyxcbiAgZ2V0TmFtZXM6ICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gIGdldFN5bWJvbHM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gIGFzc2VydERlZmluZWQ6IGFzc2VydERlZmluZWQsXG4gIC8vIER1bW15LCBmaXggZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmcgaW4gZXM1IG1vZHVsZVxuICBFUzVPYmplY3Q6IE9iamVjdCxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gJC5FUzVPYmplY3QoYXNzZXJ0RGVmaW5lZChpdCkpO1xuICB9LFxuICBoaWRlOiBoaWRlLFxuICBkZWY6IGNyZWF0ZURlZmluZXIoMCksXG4gIHNldDogZ2xvYmFsLlN5bWJvbCA/IHNpbXBsZVNldCA6IGhpZGUsXG4gIGVhY2g6IFtdLmZvckVhY2hcbn0pO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbmlmKHR5cGVvZiBfX2UgIT0gJ3VuZGVmaW5lZCcpX19lID0gY29yZTtcbmlmKHR5cGVvZiBfX2cgIT0gJ3VuZGVmaW5lZCcpX19nID0gZ2xvYmFsOyIsInZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gJC50b09iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59OyIsInZhciAkcmVkZWYgPSByZXF1aXJlKCcuLyQucmVkZWYnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYyl7XHJcbiAgZm9yKHZhciBrZXkgaW4gc3JjKSRyZWRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn07IiwidmFyICQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgYXNzZXJ0T2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLm9iajtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb3duS2V5cyhpdCl7XG4gIGFzc2VydE9iamVjdChpdCk7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXROYW1lcyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSAkLmdldFN5bWJvbHM7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaW52b2tlID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgYXNzZXJ0RnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYXNzZXJ0JykuZm47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFzc2VydEZ1bmN0aW9uKHRoaXMpXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBwYXJncyAgPSBBcnJheShsZW5ndGgpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBfICAgICAgPSAkLnBhdGguX1xuICAgICwgaG9sZGVyID0gZmFsc2U7XG4gIHdoaWxlKGxlbmd0aCA+IGkpaWYoKHBhcmdzW2ldID0gYXJndW1lbnRzW2krK10pID09PSBfKWhvbGRlciA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgdGhhdCAgICA9IHRoaXNcbiAgICAgICwgX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaiA9IDAsIGsgPSAwLCBhcmdzO1xuICAgIGlmKCFob2xkZXIgJiYgIV9sZW5ndGgpcmV0dXJuIGludm9rZShmbiwgcGFyZ3MsIHRoYXQpO1xuICAgIGFyZ3MgPSBwYXJncy5zbGljZSgpO1xuICAgIGlmKGhvbGRlcilmb3IoO2xlbmd0aCA+IGo7IGorKylpZihhcmdzW2pdID09PSBfKWFyZ3Nbal0gPSBhcmd1bWVudHNbaysrXTtcbiAgICB3aGlsZShfbGVuZ3RoID4gaylhcmdzLnB1c2goYXJndW1lbnRzW2srK10pO1xuICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xufTsiLCJ2YXIgJCAgID0gcmVxdWlyZSgnLi8kJylcclxuICAsIHRwbCA9IFN0cmluZyh7fS5oYXNPd25Qcm9wZXJ0eSlcclxuICAsIFNSQyA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdzcmMnKVxyXG4gICwgX3RvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XHJcblxyXG5mdW5jdGlvbiAkcmVkZWYoTywga2V5LCB2YWwsIHNhZmUpe1xyXG4gIGlmKCQuaXNGdW5jdGlvbih2YWwpKXtcclxuICAgIHZhciBiYXNlID0gT1trZXldO1xyXG4gICAgJC5oaWRlKHZhbCwgU1JDLCBiYXNlID8gU3RyaW5nKGJhc2UpIDogdHBsLnJlcGxhY2UoL2hhc093blByb3BlcnR5LywgU3RyaW5nKGtleSkpKTtcclxuICAgIGlmKCEoJ25hbWUnIGluIHZhbCkpdmFsLm5hbWUgPSBrZXk7XHJcbiAgfVxyXG4gIGlmKE8gPT09ICQuZyl7XHJcbiAgICBPW2tleV0gPSB2YWw7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmKCFzYWZlKWRlbGV0ZSBPW2tleV07XHJcbiAgICAkLmhpZGUoTywga2V5LCB2YWwpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnNcclxuLy8gd2l0aCBtZXRob2RzIHNpbWlsYXIgdG8gTG9EYXNoIGlzTmF0aXZlXHJcbiRyZWRlZihGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XHJcbiAgcmV0dXJuICQuaGFzKHRoaXMsIFNSQykgPyB0aGlzW1NSQ10gOiBfdG9TdHJpbmcuY2FsbCh0aGlzKTtcclxufSk7XHJcblxyXG4kLmNvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uKGl0KXtcclxuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwoaXQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAkcmVkZWY7IiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdFeHAsIHJlcGxhY2UsIGlzU3RhdGljKXtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24ocGFydCl7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBTdHJpbmcoaXNTdGF0aWMgPyBpdCA6IHRoaXMpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpe1xyXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xyXG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciAkICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGFzc2VydCA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKTtcbmZ1bmN0aW9uIGNoZWNrKE8sIHByb3RvKXtcbiAgYXNzZXJ0Lm9iaihPKTtcbiAgYXNzZXJ0KHByb3RvID09PSBudWxsIHx8ICQuaXNPYmplY3QocHJvdG8pLCBwcm90bywgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgPyBmdW5jdGlvbihidWdneSwgc2V0KXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZXQgPSByZXF1aXJlKCcuLyQuY3R4JykoRnVuY3Rpb24uY2FsbCwgJC5nZXREZXNjKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICAgIHNldCh7fSwgW10pO1xuICAgICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgICAgcmV0dXJuIE87XG4gICAgICAgIH07XG4gICAgICB9KClcbiAgICA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCJ2YXIgJCAgICAgID0gcmVxdWlyZSgnLi8kJylcclxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXHJcbiAgLCBzdG9yZSAgPSAkLmdbU0hBUkVEXSB8fCAkLmhpZGUoJC5nLCBTSEFSRUQsIHt9KVtTSEFSRURdO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XHJcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XHJcbn07IiwidmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIFNQRUNJRVMgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQyl7XG4gIGlmKCQuREVTQyAmJiAhKFNQRUNJRVMgaW4gQykpJC5zZXREZXNjKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiAkLnRoYXRcbiAgfSk7XG59OyIsIi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZygkLmFzc2VydERlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSAkLnRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsXG4gICAgICB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsIi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOnN0cmluZ19wYWRkaW5nXG52YXIgJCAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCByZXBlYXQgPSByZXF1aXJlKCcuLyQuc3RyaW5nLXJlcGVhdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIG1pbkxlbmd0aCwgZmlsbENoYXIsIGxlZnQpe1xuICAvLyAxLiBMZXQgTyBiZSBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzIHZhbHVlKS5cbiAgLy8gMi4gTGV0IFMgYmUgVG9TdHJpbmcoTykuXG4gIHZhciBTID0gU3RyaW5nKCQuYXNzZXJ0RGVmaW5lZCh0aGF0KSk7XG4gIC8vIDQuIElmIGludE1pbkxlbmd0aCBpcyB1bmRlZmluZWQsIHJldHVybiBTLlxuICBpZihtaW5MZW5ndGggPT09IHVuZGVmaW5lZClyZXR1cm4gUztcbiAgLy8gNC4gTGV0IGludE1pbkxlbmd0aCBiZSBUb0ludGVnZXIobWluTGVuZ3RoKS5cbiAgdmFyIGludE1pbkxlbmd0aCA9ICQudG9JbnRlZ2VyKG1pbkxlbmd0aCk7XG4gIC8vIDUuIExldCBmaWxsTGVuIGJlIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBTIG1pbnVzIGludE1pbkxlbmd0aC5cbiAgdmFyIGZpbGxMZW4gPSBpbnRNaW5MZW5ndGggLSBTLmxlbmd0aDtcbiAgLy8gNi4gSWYgZmlsbExlbiA8IDAsIHRoZW4gdGhyb3cgYSBSYW5nZUVycm9yIGV4Y2VwdGlvbi5cbiAgLy8gNy4gSWYgZmlsbExlbiBpcyAr4oieLCB0aGVuIHRocm93IGEgUmFuZ2VFcnJvciBleGNlcHRpb24uXG4gIGlmKGZpbGxMZW4gPCAwIHx8IGZpbGxMZW4gPT09IEluZmluaXR5KXtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IHNhdGlzZnkgc3RyaW5nIGxlbmd0aCAnICsgbWluTGVuZ3RoICsgJyBmb3Igc3RyaW5nOiAnICsgUyk7XG4gIH1cbiAgLy8gOC4gTGV0IHNGaWxsU3RyIGJlIHRoZSBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgZmlsbFN0ci5cbiAgLy8gOS4gSWYgc0ZpbGxTdHIgaXMgdW5kZWZpbmVkLCBsZXQgc0ZpbGxTdHIgYmUgYSBzcGFjZSBjaGFyYWN0ZXIuXG4gIHZhciBzRmlsbFN0ciA9IGZpbGxDaGFyID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbENoYXIpO1xuICAvLyAxMC4gTGV0IHNGaWxsVmFsIGJlIGEgU3RyaW5nIG1hZGUgb2Ygc0ZpbGxTdHIsIHJlcGVhdGVkIHVudGlsIGZpbGxMZW4gaXMgbWV0LlxuICB2YXIgc0ZpbGxWYWwgPSByZXBlYXQuY2FsbChzRmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBzRmlsbFN0ci5sZW5ndGgpKTtcbiAgLy8gdHJ1bmNhdGUgaWYgd2Ugb3ZlcmZsb3dlZFxuICBpZihzRmlsbFZhbC5sZW5ndGggPiBmaWxsTGVuKXNGaWxsVmFsID0gbGVmdFxuICAgID8gc0ZpbGxWYWwuc2xpY2Uoc0ZpbGxWYWwubGVuZ3RoIC0gZmlsbExlbilcbiAgICA6IHNGaWxsVmFsLnNsaWNlKDAsIGZpbGxMZW4pO1xuICAvLyAxMS4gUmV0dXJuIGEgc3RyaW5nIG1hZGUgZnJvbSBzRmlsbFZhbCwgZm9sbG93ZWQgYnkgUy5cbiAgLy8gMTEuIFJldHVybiBhIFN0cmluZyBtYWRlIGZyb20gUywgZm9sbG93ZWQgYnkgc0ZpbGxWYWwuXG4gIHJldHVybiBsZWZ0ID8gc0ZpbGxWYWwuY29uY2F0KFMpIDogUy5jb25jYXQoc0ZpbGxWYWwpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCl7XG4gIHZhciBzdHIgPSBTdHJpbmcoJC5hc3NlcnREZWZpbmVkKHRoaXMpKVxuICAgICwgcmVzID0gJydcbiAgICAsIG4gICA9ICQudG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYobiA8IDAgfHwgbiA9PSBJbmZpbml0eSl0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvcig7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKWlmKG4gJiAxKXJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGN0eCAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIGNvZiAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIGludm9rZSA9IHJlcXVpcmUoJy4vJC5pbnZva2UnKVxuICAsIGNlbCAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSAkLmdcbiAgLCBpc0Z1bmN0aW9uICAgICAgICAgPSAkLmlzRnVuY3Rpb25cbiAgLCBodG1sICAgICAgICAgICAgICAgPSAkLmh0bWxcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBwb3N0TWVzc2FnZSAgICAgICAgPSBnbG9iYWwucG9zdE1lc3NhZ2VcbiAgLCBhZGRFdmVudExpc3RlbmVyICAgPSBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lclxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5mdW5jdGlvbiBydW4oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKCQuaGFzKHF1ZXVlLCBpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RuZXIoZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn1cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFpc0Z1bmN0aW9uKHNldFRhc2spIHx8ICFpc0Z1bmN0aW9uKGNsZWFyVGFzaykpe1xuICBzZXRUYXNrID0gZnVuY3Rpb24oZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UoaXNGdW5jdGlvbihmbikgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24oaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihjb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBNb2Rlcm4gYnJvd3NlcnMsIHNraXAgaW1wbGVtZW50YXRpb24gZm9yIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgb2JqZWN0XG4gIH0gZWxzZSBpZihhZGRFdmVudExpc3RlbmVyICYmIGlzRnVuY3Rpb24ocG9zdE1lc3NhZ2UpICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwb3N0TWVzc2FnZShpZCwgJyonKTtcbiAgICB9O1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0bmVyLCBmYWxzZSk7XG4gIC8vIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKGlzRnVuY3Rpb24oTWVzc2FnZUNoYW5uZWwpKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdG5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwidmFyIHNpZCA9IDA7XG5mdW5jdGlvbiB1aWQoa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsrc2lkICsgTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpKTtcbn1cbnVpZC5zYWZlID0gcmVxdWlyZSgnLi8kJykuZy5TeW1ib2wgfHwgdWlkO1xubW9kdWxlLmV4cG9ydHMgPSB1aWQ7IiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi8kLndrcycpKCd1bnNjb3BhYmxlcycpO1xuaWYoIShVTlNDT1BBQkxFUyBpbiBbXSkpcmVxdWlyZSgnLi8kJykuaGlkZShBcnJheS5wcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIFtdW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vJCcpLmdcbiAgLCBzdG9yZSAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJykoJ3drcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgZ2xvYmFsLlN5bWJvbCAmJiBnbG9iYWwuU3ltYm9sW25hbWVdIHx8IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07IiwidmFyICQgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNlbCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZG9tLWNyZWF0ZScpXG4gICwgY29mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRkZWYgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpbnZva2UgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgYXJyYXlNZXRob2QgICAgICA9IHJlcXVpcmUoJy4vJC5hcnJheS1tZXRob2RzJylcbiAgLCBJRV9QUk9UTyAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ19fcHJvdG9fXycpXG4gICwgYXNzZXJ0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKVxuICAsIGFzc2VydE9iamVjdCAgICAgPSBhc3NlcnQub2JqXG4gICwgT2JqZWN0UHJvdG8gICAgICA9IE9iamVjdC5wcm90b3R5cGVcbiAgLCBodG1sICAgICAgICAgICAgID0gJC5odG1sXG4gICwgQSAgICAgICAgICAgICAgICA9IFtdXG4gICwgX3NsaWNlICAgICAgICAgICA9IEEuc2xpY2VcbiAgLCBfam9pbiAgICAgICAgICAgID0gQS5qb2luXG4gICwgY2xhc3NvZiAgICAgICAgICA9IGNvZi5jbGFzc29mXG4gICwgaGFzICAgICAgICAgICAgICA9ICQuaGFzXG4gICwgZGVmaW5lUHJvcGVydHkgICA9ICQuc2V0RGVzY1xuICAsIGdldE93bkRlc2NyaXB0b3IgPSAkLmdldERlc2NcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gJC5zZXREZXNjc1xuICAsIGlzRnVuY3Rpb24gICAgICAgPSAkLmlzRnVuY3Rpb25cbiAgLCBpc09iamVjdCAgICAgICAgID0gJC5pc09iamVjdFxuICAsIHRvT2JqZWN0ICAgICAgICAgPSAkLnRvT2JqZWN0XG4gICwgdG9MZW5ndGggICAgICAgICA9ICQudG9MZW5ndGhcbiAgLCB0b0luZGV4ICAgICAgICAgID0gJC50b0luZGV4XG4gICwgSUU4X0RPTV9ERUZJTkUgICA9IGZhbHNlXG4gICwgJGluZGV4T2YgICAgICAgICA9IHJlcXVpcmUoJy4vJC5hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsICRmb3JFYWNoICAgICAgICAgPSBhcnJheU1ldGhvZCgwKVxuICAsICRtYXAgICAgICAgICAgICAgPSBhcnJheU1ldGhvZCgxKVxuICAsICRmaWx0ZXIgICAgICAgICAgPSBhcnJheU1ldGhvZCgyKVxuICAsICRzb21lICAgICAgICAgICAgPSBhcnJheU1ldGhvZCgzKVxuICAsICRldmVyeSAgICAgICAgICAgPSBhcnJheU1ldGhvZCg0KTtcblxuaWYoISQuREVTQyl7XG4gIHRyeSB7XG4gICAgSUU4X0RPTV9ERUZJTkUgPSBkZWZpbmVQcm9wZXJ0eShjZWwoJ2RpdicpLCAneCcsXG4gICAgICB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gODsgfX1cbiAgICApLnggPT0gODtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICAkLnNldERlc2MgPSBmdW5jdGlvbihPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICAgIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpYXNzZXJ0T2JqZWN0KE8pW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICByZXR1cm4gTztcbiAgfTtcbiAgJC5nZXREZXNjID0gZnVuY3Rpb24oTywgUCl7XG4gICAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICAgIHJldHVybiBnZXRPd25EZXNjcmlwdG9yKE8sIFApO1xuICAgIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgICBpZihoYXMoTywgUCkpcmV0dXJuICQuZGVzYyghT2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChPLCBQKSwgT1tQXSk7XG4gIH07XG4gICQuc2V0RGVzY3MgPSBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oTywgUHJvcGVydGllcyl7XG4gICAgYXNzZXJ0T2JqZWN0KE8pO1xuICAgIHZhciBrZXlzICAgPSAkLmdldEtleXMoUHJvcGVydGllcylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSA9IDBcbiAgICAgICwgUDtcbiAgICB3aGlsZShsZW5ndGggPiBpKSQuc2V0RGVzYyhPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgICByZXR1cm4gTztcbiAgfTtcbn1cbiRkZWYoJGRlZi5TICsgJGRlZi5GICogISQuREVTQywgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjYgLyAxNS4yLjMuMyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJC5nZXREZXNjLFxuICAvLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJC5zZXREZXNjLFxuICAvLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6IGRlZmluZVByb3BlcnRpZXNcbn0pO1xuXG4gIC8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBrZXlzMSA9ICgnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSwnICtcbiAgICAgICAgICAgICd0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJykuc3BsaXQoJywnKVxuICAvLyBBZGRpdGlvbmFsIGtleXMgZm9yIGdldE93blByb3BlcnR5TmFtZXNcbiAgLCBrZXlzMiA9IGtleXMxLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpXG4gICwga2V5c0xlbjEgPSBrZXlzMS5sZW5ndGg7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBjZWwoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBrZXlzTGVuMVxuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzxzY3JpcHQ+ZG9jdW1lbnQuRj1PYmplY3Q8L3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3QucHJvdG90eXBlW2tleXMxW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVHZXRLZXlzKG5hbWVzLCBsZW5ndGgpe1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxuICAgICAgLCBpICAgICAgPSAwXG4gICAgICAsIHJlc3VsdCA9IFtdXG4gICAgICAsIGtleTtcbiAgICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICAgIH4kaW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEVtcHR5KCl7fVxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG4gIGdldFByb3RvdHlwZU9mOiAkLmdldFByb3RvID0gJC5nZXRQcm90byB8fCBmdW5jdGlvbihPKXtcbiAgICBPID0gT2JqZWN0KGFzc2VydC5kZWYoTykpO1xuICAgIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICAgIGlmKGlzRnVuY3Rpb24oTy5jb25zdHJ1Y3RvcikgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG4gIH0sXG4gIC8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJC5nZXROYW1lcyA9ICQuZ2V0TmFtZXMgfHwgY3JlYXRlR2V0S2V5cyhrZXlzMiwga2V5czIubGVuZ3RoLCB0cnVlKSxcbiAgLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJC5jcmVhdGUgPSAkLmNyZWF0ZSB8fCBmdW5jdGlvbihPLCAvKj8qL1Byb3BlcnRpZXMpe1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYoTyAhPT0gbnVsbCl7XG4gICAgICBFbXB0eS5wcm90b3R5cGUgPSBhc3NlcnRPYmplY3QoTyk7XG4gICAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHNoaW1cbiAgICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICAgIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gICAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbiAgfSxcbiAgLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG4gIGtleXM6ICQuZ2V0S2V5cyA9ICQuZ2V0S2V5cyB8fCBjcmVhdGVHZXRLZXlzKGtleXMxLCBrZXlzTGVuMSwgZmFsc2UpLFxuICAvLyAxOS4xLjIuMTcgLyAxNS4yLjMuOCBPYmplY3Quc2VhbChPKVxuICBzZWFsOiBmdW5jdGlvbiBzZWFsKGl0KXtcbiAgICByZXR1cm4gaXQ7IC8vIDwtIGNhcFxuICB9LFxuICAvLyAxOS4xLjIuNSAvIDE1LjIuMy45IE9iamVjdC5mcmVlemUoTylcbiAgZnJlZXplOiBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiBpdDsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi4xNSAvIDE1LjIuMy4xMCBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gaXQ7IC8vIDwtIGNhcFxuICB9LFxuICAvLyAxOS4xLjIuMTMgLyAxNS4yLjMuMTEgT2JqZWN0LmlzU2VhbGVkKE8pXG4gIGlzU2VhbGVkOiBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuICFpc09iamVjdChpdCk7IC8vIDwtIGNhcFxuICB9LFxuICAvLyAxOS4xLjIuMTIgLyAxNS4yLjMuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG4gIGlzRnJvemVuOiBmdW5jdGlvbiBpc0Zyb3plbihpdCl7XG4gICAgcmV0dXJuICFpc09iamVjdChpdCk7IC8vIDwtIGNhcFxuICB9LFxuICAvLyAxOS4xLjIuMTEgLyAxNS4yLjMuMTMgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KTsgLy8gPC0gY2FwXG4gIH1cbn0pO1xuXG4vLyAxOS4yLjMuMiAvIDE1LjMuNC41IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKHRoaXNBcmcsIGFyZ3MuLi4pXG4kZGVmKCRkZWYuUCwgJ0Z1bmN0aW9uJywge1xuICBiaW5kOiBmdW5jdGlvbih0aGF0IC8qLCBhcmdzLi4uICovKXtcbiAgICB2YXIgZm4gICAgICAgPSBhc3NlcnQuZm4odGhpcylcbiAgICAgICwgcGFydEFyZ3MgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGZ1bmN0aW9uIGJvdW5kKC8qIGFyZ3MuLi4gKi8pe1xuICAgICAgdmFyIGFyZ3MgICA9IHBhcnRBcmdzLmNvbmNhdChfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAsIGNvbnN0ciA9IHRoaXMgaW5zdGFuY2VvZiBib3VuZFxuICAgICAgICAsIGN0eCAgICA9IGNvbnN0ciA/ICQuY3JlYXRlKGZuLnByb3RvdHlwZSkgOiB0aGF0XG4gICAgICAgICwgcmVzdWx0ID0gaW52b2tlKGZuLCBhcmdzLCBjdHgpO1xuICAgICAgcmV0dXJuIGNvbnN0ciA/IGN0eCA6IHJlc3VsdDtcbiAgICB9XG4gICAgaWYoZm4ucHJvdG90eXBlKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH1cbn0pO1xuXG4vLyBGaXggZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmcgYW5kIERPTSBvYmplY3RzXG5pZighKDAgaW4gT2JqZWN0KCd6JykgJiYgJ3onWzBdID09ICd6Jykpe1xuICAkLkVTNU9iamVjdCA9IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG4gIH07XG59XG5cbnZhciBidWdneVNsaWNlID0gdHJ1ZTtcbnRyeSB7XG4gIGlmKGh0bWwpX3NsaWNlLmNhbGwoaHRtbCk7XG4gIGJ1Z2d5U2xpY2UgPSBmYWxzZTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBidWdneVNsaWNlLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKXtcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcbiAgICAgICwga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gX3NsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ICA9IHRvSW5kZXgoYmVnaW4sIGxlbilcbiAgICAgICwgdXBUbyAgID0gdG9JbmRleChlbmQsIGxlbilcbiAgICAgICwgc2l6ZSAgID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KVxuICAgICAgLCBjbG9uZWQgPSBBcnJheShzaXplKVxuICAgICAgLCBpICAgICAgPSAwO1xuICAgIGZvcig7IGkgPCBzaXplOyBpKyspY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZydcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxuICAgICAgOiB0aGlzW3N0YXJ0ICsgaV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7XG5cbiRkZWYoJGRlZi5QICsgJGRlZi5GICogKCQuRVM1T2JqZWN0ICE9IE9iamVjdCksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbigpe1xuICAgIHJldHVybiBfam9pbi5hcHBseSgkLkVTNU9iamVjdCh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfVxufSk7XG5cbi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG4kZGVmKCRkZWYuUywgJ0FycmF5Jywge1xuICBpc0FycmF5OiBmdW5jdGlvbihhcmcpe1xuICAgIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xuICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5UmVkdWNlKGlzUmlnaHQpe1xuICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2tmbiwgbWVtbyl7XG4gICAgYXNzZXJ0LmZuKGNhbGxiYWNrZm4pO1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDIpZm9yKDs7KXtcbiAgICAgIGlmKGluZGV4IGluIE8pe1xuICAgICAgICBtZW1vID0gT1tpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGFzc2VydChpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4LCAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgICBmb3IoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpaWYoaW5kZXggaW4gTyl7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBPW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn1cbiRkZWYoJGRlZi5QLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiAkLmVhY2ggPSAkLmVhY2ggfHwgZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9LFxuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9LFxuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9LFxuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9LFxuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogY3JlYXRlQXJyYXlSZWR1Y2UoZmFsc2UpLFxuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGNyZWF0ZUFycmF5UmVkdWNlKHRydWUpLFxuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKGVsIC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gJGluZGV4T2YodGhpcywgZWwsIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24oZWwsIGZyb21JbmRleCAvKiA9IEBbKi0xXSAqLyl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBsZW5ndGggLSAxO1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKWluZGV4ID0gTWF0aC5taW4oaW5kZXgsICQudG9JbnRlZ2VyKGZyb21JbmRleCkpO1xuICAgIGlmKGluZGV4IDwgMClpbmRleCA9IHRvTGVuZ3RoKGxlbmd0aCArIGluZGV4KTtcbiAgICBmb3IoO2luZGV4ID49IDA7IGluZGV4LS0paWYoaW5kZXggaW4gTylpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIGluZGV4O1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG5cbi8vIDIxLjEuMy4yNSAvIDE1LjUuNC4yMCBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7dHJpbTogcmVxdWlyZSgnLi8kLnJlcGxhY2VyJykoL15cXHMqKFtcXHNcXFNdKlxcUyk/XFxzKiQvLCAnJDEnKX0pO1xuXG4vLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbiRkZWYoJGRlZi5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7XG4gIHJldHVybiArbmV3IERhdGU7XG59fSk7XG5cbmZ1bmN0aW9uIGx6KG51bSl7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufVxuXG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxuLy8gUGhhbnRvbUpTIGFuZCBvbGQgd2Via2l0IGhhZCBhIGJyb2tlbiBEYXRlIGltcGxlbWVudGF0aW9uLlxudmFyIGRhdGUgICAgICAgPSBuZXcgRGF0ZSgtNWUxMyAtIDEpXG4gICwgYnJva2VuRGF0ZSA9ICEoZGF0ZS50b0lTT1N0cmluZyAmJiBkYXRlLnRvSVNPU3RyaW5nKCkgPT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5WidcbiAgICAgICYmIHJlcXVpcmUoJy4vJC50aHJvd3MnKShmdW5jdGlvbigpeyBuZXcgRGF0ZShOYU4pLnRvSVNPU3RyaW5nKCk7IH0pKTtcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogYnJva2VuRGF0ZSwgJ0RhdGUnLCB7dG9JU09TdHJpbmc6IGZ1bmN0aW9uKCl7XG4gIGlmKCFpc0Zpbml0ZSh0aGlzKSl0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgdmFyIGQgPSB0aGlzXG4gICAgLCB5ID0gZC5nZXRVVENGdWxsWWVhcigpXG4gICAgLCBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICwgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbn19KTtcblxuaWYoY2xhc3NvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdPYmplY3QnKWNvZi5jbGFzc29mID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGFnID0gY2xhc3NvZihpdCk7XG4gIHJldHVybiB0YWcgPT0gJ09iamVjdCcgJiYgaXNGdW5jdGlvbihpdC5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiB0YWc7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgdG9JbmRleCA9ICQudG9JbmRleDtcbiRkZWYoJGRlZi5QLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgTyAgICAgPSBPYmplY3QoJC5hc3NlcnREZWZpbmVkKHRoaXMpKVxuICAgICAgLCBsZW4gICA9ICQudG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIHRvICAgID0gdG9JbmRleCh0YXJnZXQsIGxlbilcbiAgICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgICAsIGVuZCAgID0gYXJndW1lbnRzWzJdXG4gICAgICAsIGZpbiAgID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBjb3VudCA9IE1hdGgubWluKGZpbiAtIGZyb20sIGxlbiAtIHRvKVxuICAgICAgLCBpbmMgICA9IDE7XG4gICAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcbiAgICAgIGluYyAgPSAtMTtcbiAgICAgIGZyb20gPSBmcm9tICsgY291bnQgLSAxO1xuICAgICAgdG8gICA9IHRvICAgKyBjb3VudCAtIDE7XG4gICAgfVxuICAgIHdoaWxlKGNvdW50LS0gPiAwKXtcbiAgICAgIGlmKGZyb20gaW4gTylPW3RvXSA9IE9bZnJvbV07XG4gICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIHRvICAgKz0gaW5jO1xuICAgICAgZnJvbSArPSBpbmM7XG4gICAgfSByZXR1cm4gTztcbiAgfVxufSk7XG5yZXF1aXJlKCcuLyQudW5zY29wZScpKCdjb3B5V2l0aGluJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCB0b0luZGV4ID0gJC50b0luZGV4O1xuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4gIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gICAgdmFyIE8gICAgICA9IE9iamVjdCgkLmFzc2VydERlZmluZWQodGhpcykpXG4gICAgICAsIGxlbmd0aCA9ICQudG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoYXJndW1lbnRzWzFdLCBsZW5ndGgpXG4gICAgICAsIGVuZCAgICA9IGFyZ3VtZW50c1syXVxuICAgICAgLCBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpO1xuICAgIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcbiAgICByZXR1cm4gTztcbiAgfVxufSk7XG5yZXF1aXJlKCcuLyQudW5zY29wZScpKCdmaWxsJyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgS0VZICAgID0gJ2ZpbmRJbmRleCdcbiAgLCAkZGVmICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBmb3JjZWQgPSB0cnVlXG4gICwgJGZpbmQgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKSg2KTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgS0VZICAgID0gJ2ZpbmQnXG4gICwgJGRlZiAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgZm9yY2VkID0gdHJ1ZVxuICAsICRmaW5kICA9IHJlcXVpcmUoJy4vJC5hcnJheS1tZXRob2RzJykoNSk7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoS0VZKTsiLCJ2YXIgJCAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGN0eCAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkaXRlciA9IHJlcXVpcmUoJy4vJC5pdGVyJylcbiAgLCBjYWxsICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKTtcbiRkZWYoJGRlZi5TICsgJGRlZi5GICogIXJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZChhcnJheUxpa2UpKVxuICAgICAgLCBtYXBmbiAgID0gYXJndW1lbnRzWzFdXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGYgICAgICAgPSBtYXBwaW5nID8gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpIDogdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZigkaXRlci5pcyhPKSl7XG4gICAgICBpdGVyYXRvciA9ICRpdGVyLmdldChPKTtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgcXVpcmtzIG1vZGUgYnVnIC0+IHVzZSB0eXBlb2YgaW5zdGVhZCBvZiBpc0Z1bmN0aW9uXG4gICAgICByZXN1bHQgICA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSk7XG4gICAgICBmb3IoOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIGYsIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RyYW5nZSBJRSBxdWlya3MgbW9kZSBidWcgLT4gdXNlIHR5cGVvZiBpbnN0ZWFkIG9mIGlzRnVuY3Rpb25cbiAgICAgIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkobGVuZ3RoID0gJC50b0xlbmd0aChPLmxlbmd0aCkpO1xuICAgICAgZm9yKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGYoT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwidmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHNldFVuc2NvcGUgPSByZXF1aXJlKCcuLyQudW5zY29wZScpXG4gICwgSVRFUiAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdpdGVyJylcbiAgLCAkaXRlciAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIHN0ZXAgICAgICAgPSAkaXRlci5zdGVwXG4gICwgSXRlcmF0b3JzICA9ICRpdGVyLkl0ZXJhdG9ycztcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgJC5zZXQodGhpcywgSVRFUiwge286ICQudG9PYmplY3QoaXRlcmF0ZWQpLCBpOiAwLCBrOiBraW5kfSk7XG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cbiAgICAsIE8gICAgID0gaXRlci5vXG4gICAgLCBraW5kICA9IGl0ZXIua1xuICAgICwgaW5kZXggPSBpdGVyLmkrKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIGl0ZXIubyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuc2V0VW5zY29wZSgna2V5cycpO1xuc2V0VW5zY29wZSgndmFsdWVzJyk7XG5zZXRVbnNjb3BlKCdlbnRyaWVzJyk7IiwidmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAvLyBzdHJhbmdlIElFIHF1aXJrcyBtb2RlIGJ1ZyAtPiB1c2UgdHlwZW9mIGluc3RlYWQgb2YgaXNGdW5jdGlvblxuICAgICAgLCByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsInJlcXVpcmUoJy4vJC5zcGVjaWVzJykoQXJyYXkpOyIsInZhciAkICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBIQVNfSU5TVEFOQ0UgID0gcmVxdWlyZSgnLi8kLndrcycpKCdoYXNJbnN0YW5jZScpXG4gICwgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpJC5zZXREZXNjKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwge3ZhbHVlOiBmdW5jdGlvbihPKXtcbiAgaWYoISQuaXNGdW5jdGlvbih0aGlzKSB8fCAhJC5pc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCEkLmlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSlyZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlKE8gPSAkLmdldFByb3RvKE8pKWlmKHRoaXMucHJvdG90eXBlID09PSBPKXJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59fSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIE5BTUUgPSAnbmFtZSdcbiAgLCBzZXREZXNjID0gJC5zZXREZXNjXG4gICwgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRnVuY3Rpb25Qcm90byB8fCAkLkZXICYmICQuREVTQyAmJiBzZXREZXNjKEZ1bmN0aW9uUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG1hdGNoID0gU3RyaW5nKHRoaXMpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLylcbiAgICAgICwgbmFtZSAgPSBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XG4gICAgJC5oYXModGhpcywgTkFNRSkgfHwgc2V0RGVzYyh0aGlzLCBOQU1FLCAkLmRlc2MoNSwgbmFtZSkpO1xuICAgIHJldHVybiBuYW1lO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAkLmhhcyh0aGlzLCBOQU1FKSB8fCBzZXREZXNjKHRoaXMsIE5BTUUsICQuZGVzYygwLCB2YWx1ZSkpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHNbMF0pOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCJ2YXIgSW5maW5pdHkgPSAxIC8gMFxuICAsICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgRSAgICAgPSBNYXRoLkVcbiAgLCBwb3cgICA9IE1hdGgucG93XG4gICwgYWJzICAgPSBNYXRoLmFic1xuICAsIGV4cCAgID0gTWF0aC5leHBcbiAgLCBsb2cgICA9IE1hdGgubG9nXG4gICwgc3FydCAgPSBNYXRoLnNxcnRcbiAgLCBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vclxuICAsIEVQU0lMT04gICA9IHBvdygyLCAtNTIpXG4gICwgRVBTSUxPTjMyID0gcG93KDIsIC0yMylcbiAgLCBNQVgzMiAgICAgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKVxuICAsIE1JTjMyICAgICA9IHBvdygyLCAtMTI2KTtcbmZ1bmN0aW9uIHJvdW5kVGllc1RvRXZlbihuKXtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufVxuXG4vLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5mdW5jdGlvbiBzaWduKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59XG4vLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG5mdW5jdGlvbiBhc2luaCh4KXtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBsb2coeCArIHNxcnQoeCAqIHggKyAxKSk7XG59XG4vLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxuZnVuY3Rpb24gZXhwbTEoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBleHAoeCkgLSAxO1xufVxuXG4kZGVmKCRkZWYuUywgJ01hdGgnLCB7XG4gIC8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiBpc0Zpbml0ZSh4KSA/IGxvZyh4IC8gRSArIHNxcnQoeCArIDEpICogc3FydCh4IC0gMSkgLyBFKSArIDEgOiB4O1xuICB9LFxuICAvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG4gIGFzaW5oOiBhc2luaCxcbiAgLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogbG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH0sXG4gIC8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpe1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBwb3coYWJzKHgpLCAxIC8gMyk7XG4gIH0sXG4gIC8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KXtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gZmxvb3IobG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfSxcbiAgLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpe1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH0sXG4gIC8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG4gIGV4cG0xOiBleHBtMSxcbiAgLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG4gIGZyb3VuZDogZnVuY3Rpb24gZnJvdW5kKHgpe1xuICAgIHZhciAkYWJzICA9IGFicyh4KVxuICAgICAgLCAkc2lnbiA9IHNpZ24oeClcbiAgICAgICwgYSwgcmVzdWx0O1xuICAgIGlmKCRhYnMgPCBNSU4zMilyZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICAgIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgICBpZihyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KXJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICAgIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbiAgfSxcbiAgLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtICA9IDBcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgbGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbGFyZyA9IDBcbiAgICAgICwgYXJnLCBkaXY7XG4gICAgd2hpbGUoaSA8IGxlbil7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYobGFyZyA8IGFyZyl7XG4gICAgICAgIGRpdiAgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZihhcmcgPiAwKXtcbiAgICAgICAgZGl2ICA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogc3FydChzdW0pO1xuICB9LFxuICAvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSl7XG4gICAgdmFyIFVJbnQxNiA9IDB4ZmZmZlxuICAgICAgLCB4biA9ICt4XG4gICAgICAsIHluID0gK3lcbiAgICAgICwgeGwgPSBVSW50MTYgJiB4blxuICAgICAgLCB5bCA9IFVJbnQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUludDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUludDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH0sXG4gIC8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG4gIGxvZzFwOiBmdW5jdGlvbiBsb2cxcCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBsb2coMSArIHgpO1xuICB9LFxuICAvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCl7XG4gICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4xMDtcbiAgfSxcbiAgLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpe1xuICAgIHJldHVybiBsb2coeCkgLyBNYXRoLkxOMjtcbiAgfSxcbiAgLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxuICBzaWduOiBzaWduLFxuICAvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIGFicyh4ID0gK3gpIDwgMSA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoRSAvIDIpO1xuICB9LFxuICAvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCl7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpXG4gICAgICAsIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfSxcbiAgLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KXtcbiAgICByZXR1cm4gKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaXNPYmplY3QgICA9ICQuaXNPYmplY3RcbiAgLCBpc0Z1bmN0aW9uID0gJC5pc0Z1bmN0aW9uXG4gICwgTlVNQkVSICAgICA9ICdOdW1iZXInXG4gICwgJE51bWJlciAgICA9ICQuZ1tOVU1CRVJdXG4gICwgQmFzZSAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgID0gJE51bWJlci5wcm90b3R5cGU7XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZShpdCl7XG4gIHZhciBmbiwgdmFsO1xuICBpZihpc0Z1bmN0aW9uKGZuID0gaXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZihpc0Z1bmN0aW9uKGZuID0gaXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gbnVtYmVyXCIpO1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoaXQpe1xuICBpZihpc09iamVjdChpdCkpaXQgPSB0b1ByaW1pdGl2ZShpdCk7XG4gIGlmKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyICYmIGl0LmNoYXJDb2RlQXQoMCkgPT0gNDgpe1xuICAgIHZhciBiaW5hcnkgPSBmYWxzZTtcbiAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XG4gICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiBiaW5hcnkgPSB0cnVlO1xuICAgICAgY2FzZSA3OSA6IGNhc2UgMTExIDogcmV0dXJuIHBhcnNlSW50KGl0LnNsaWNlKDIpLCBiaW5hcnkgPyAyIDogOCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59XG5pZigkLkZXICYmICEoJE51bWJlcignMG8xJykgJiYgJE51bWJlcignMGIxJykpKXtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcihpdCl7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiAkTnVtYmVyID8gbmV3IEJhc2UodG9OdW1iZXIoaXQpKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgJC5lYWNoLmNhbGwoJC5ERVNDID8gJC5nZXROYW1lcyhCYXNlKSA6IChcbiAgICAgIC8vIEVTMzpcbiAgICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICAgICkuc3BsaXQoJywnKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgIGlmKCQuaGFzKEJhc2UsIGtleSkgJiYgISQuaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgICAkLnNldERlc2MoJE51bWJlciwga2V5LCAkLmdldERlc2MoQmFzZSwga2V5KSk7XG4gICAgICB9XG4gICAgfVxuICApO1xuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vJC5yZWRlZicpKCQuZywgTlVNQkVSLCAkTnVtYmVyKTtcbn0iLCJ2YXIgJCAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgYWJzICAgPSBNYXRoLmFic1xuICAsIGZsb29yID0gTWF0aC5mbG9vclxuICAsIF9pc0Zpbml0ZSA9ICQuZy5pc0Zpbml0ZVxuICAsIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxO1xuZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KXtcbiAgcmV0dXJuICEkLmlzT2JqZWN0KGl0KSAmJiBfaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59XG4kZGVmKCRkZWYuUywgJ051bWJlcicsIHtcbiAgLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbiAgRVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKSxcbiAgLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KXtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH0sXG4gIC8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxuICBpc0ludGVnZXI6IGlzSW50ZWdlcixcbiAgLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH0sXG4gIC8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpe1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICB9LFxuICAvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICBNQVhfU0FGRV9JTlRFR0VSOiBNQVhfU0FGRV9JTlRFR0VSLFxuICAvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbiAgTUlOX1NBRkVfSU5URUdFUjogLU1BWF9TQUZFX0lOVEVHRVIsXG4gIC8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4gIHBhcnNlRmxvYXQ6IHBhcnNlRmxvYXQsXG4gIC8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiAgcGFyc2VJbnQ6IHBhcnNlSW50XG59KTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vJC5hc3NpZ24nKX0pOyIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbiRkZWYoJGRlZi5TLCAnT2JqZWN0Jywge1xuICBpczogcmVxdWlyZSgnLi8kLnNhbWUnKVxufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXR9KTsiLCJ2YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgaXNPYmplY3QgPSAkLmlzT2JqZWN0XG4gICwgdG9PYmplY3QgPSAkLnRvT2JqZWN0O1xuJC5lYWNoLmNhbGwoKCdmcmVlemUsc2VhbCxwcmV2ZW50RXh0ZW5zaW9ucyxpc0Zyb3plbixpc1NlYWxlZCxpc0V4dGVuc2libGUsJyArXG4gICdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsZ2V0UHJvdG90eXBlT2Ysa2V5cyxnZXRPd25Qcm9wZXJ0eU5hbWVzJykuc3BsaXQoJywnKVxuLCBmdW5jdGlvbihLRVksIElEKXtcbiAgdmFyIGZuICAgICA9ICgkLmNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBmb3JjZWQgPSAwXG4gICAgLCBtZXRob2QgPSB7fTtcbiAgbWV0aG9kW0tFWV0gPSBJRCA9PSAwID8gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogaXQ7XG4gIH0gOiBJRCA9PSAxID8gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGl0O1xuICB9IDogSUQgPT0gMiA/IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogaXQ7XG4gIH0gOiBJRCA9PSAzID8gZnVuY3Rpb24gaXNGcm96ZW4oaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiB0cnVlO1xuICB9IDogSUQgPT0gNCA/IGZ1bmN0aW9uIGlzU2VhbGVkKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogdHJ1ZTtcbiAgfSA6IElEID09IDUgPyBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBmYWxzZTtcbiAgfSA6IElEID09IDYgPyBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSwga2V5KTtcbiAgfSA6IElEID09IDcgPyBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuIGZuKE9iamVjdCgkLmFzc2VydERlZmluZWQoaXQpKSk7XG4gIH0gOiBJRCA9PSA4ID8gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSk7XG4gIH0gOiByZXF1aXJlKCcuLyQuZ2V0LW5hbWVzJykuZ2V0O1xuICB0cnkge1xuICAgIGZuKCd6Jyk7XG4gIH0gY2F0Y2goZSl7XG4gICAgZm9yY2VkID0gMTtcbiAgfVxuICAkZGVmKCRkZWYuUyArICRkZWYuRiAqIGZvcmNlZCwgJ09iamVjdCcsIG1ldGhvZCk7XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCB0bXAgPSB7fTtcbnRtcFtyZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYocmVxdWlyZSgnLi8kJykuRlcgJiYgY29mKHRtcCkgIT0gJ3onKXtcbiAgcmVxdWlyZSgnLi8kLnJlZGVmJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNvZi5jbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn0iLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGN0eCAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY29mICAgICAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCAkZGVmICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGFzc2VydCAgID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpXG4gICwgZm9yT2YgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBzZXRQcm90byA9IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXRcbiAgLCBzYW1lICAgICA9IHJlcXVpcmUoJy4vJC5zYW1lJylcbiAgLCBzcGVjaWVzICA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzJylcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpXG4gICwgUkVDT1JEICAgPSByZXF1aXJlKCcuLyQudWlkJykuc2FmZSgncmVjb3JkJylcbiAgLCBQUk9NSVNFICA9ICdQcm9taXNlJ1xuICAsIGdsb2JhbCAgID0gJC5nXG4gICwgcHJvY2VzcyAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGFzYXAgICAgID0gcHJvY2VzcyAmJiBwcm9jZXNzLm5leHRUaWNrIHx8IHJlcXVpcmUoJy4vJC50YXNrJykuc2V0XG4gICwgUCAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBpc0Z1bmN0aW9uICAgICA9ICQuaXNGdW5jdGlvblxuICAsIGlzT2JqZWN0ICAgICAgID0gJC5pc09iamVjdFxuICAsIGFzc2VydEZ1bmN0aW9uID0gYXNzZXJ0LmZuXG4gICwgYXNzZXJ0T2JqZWN0ICAgPSBhc3NlcnQub2JqXG4gICwgV3JhcHBlcjtcblxuZnVuY3Rpb24gdGVzdFJlc29sdmUoc3ViKXtcbiAgdmFyIHRlc3QgPSBuZXcgUChmdW5jdGlvbigpe30pO1xuICBpZihzdWIpdGVzdC5jb25zdHJ1Y3RvciA9IE9iamVjdDtcbiAgcmV0dXJuIFAucmVzb2x2ZSh0ZXN0KSA9PT0gdGVzdDtcbn1cblxudmFyIHVzZU5hdGl2ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciB3b3JrcyA9IGZhbHNlO1xuICBmdW5jdGlvbiBQMih4KXtcbiAgICB2YXIgc2VsZiA9IG5ldyBQKHgpO1xuICAgIHNldFByb3RvKHNlbGYsIFAyLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdHJ5IHtcbiAgICB3b3JrcyA9IGlzRnVuY3Rpb24oUCkgJiYgaXNGdW5jdGlvbihQLnJlc29sdmUpICYmIHRlc3RSZXNvbHZlKCk7XG4gICAgc2V0UHJvdG8oUDIsIFApO1xuICAgIFAyLnByb3RvdHlwZSA9ICQuY3JlYXRlKFAucHJvdG90eXBlLCB7Y29uc3RydWN0b3I6IHt2YWx1ZTogUDJ9fSk7XG4gICAgLy8gYWN0dWFsIEZpcmVmb3ggaGFzIGJyb2tlbiBzdWJjbGFzcyBzdXBwb3J0LCB0ZXN0IHRoYXRcbiAgICBpZighKFAyLnJlc29sdmUoNSkudGhlbihmdW5jdGlvbigpe30pIGluc3RhbmNlb2YgUDIpKXtcbiAgICAgIHdvcmtzID0gZmFsc2U7XG4gICAgfVxuICB9IGNhdGNoKGUpeyB3b3JrcyA9IGZhbHNlOyB9XG4gIHJldHVybiB3b3Jrcztcbn0oKTtcblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gaXNQcm9taXNlKGl0KXtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAodXNlTmF0aXZlID8gY29mLmNsYXNzb2YoaXQpID09ICdQcm9taXNlJyA6IFJFQ09SRCBpbiBpdCk7XG59XG5mdW5jdGlvbiBzYW1lQ29uc3RydWN0b3IoYSwgYil7XG4gIC8vIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgaWYoISQuRlcgJiYgYSA9PT0gUCAmJiBiID09PSBXcmFwcGVyKXJldHVybiB0cnVlO1xuICByZXR1cm4gc2FtZShhLCBiKTtcbn1cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yKEMpe1xuICB2YXIgUyA9IGFzc2VydE9iamVjdChDKVtTUEVDSUVTXTtcbiAgcmV0dXJuIFMgIT0gdW5kZWZpbmVkID8gUyA6IEM7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKGl0KXtcbiAgdmFyIHRoZW47XG4gIGlmKGlzT2JqZWN0KGl0KSl0aGVuID0gaXQudGhlbjtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odGhlbikgPyB0aGVuIDogZmFsc2U7XG59XG5mdW5jdGlvbiBub3RpZnkocmVjb3JkKXtcbiAgdmFyIGNoYWluID0gcmVjb3JkLmM7XG4gIGlmKGNoYWluLmxlbmd0aClhc2FwKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcmVjb3JkLnZcbiAgICAgICwgb2sgICAgPSByZWNvcmQucyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICBmdW5jdGlvbiBydW4ocmVhY3Qpe1xuICAgICAgdmFyIGNiID0gb2sgPyByZWFjdC5vayA6IHJlYWN0LmZhaWxcbiAgICAgICAgLCByZXQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihjYil7XG4gICAgICAgICAgaWYoIW9rKXJlY29yZC5oID0gdHJ1ZTtcbiAgICAgICAgICByZXQgPSBjYiA9PT0gdHJ1ZSA/IHZhbHVlIDogY2IodmFsdWUpO1xuICAgICAgICAgIGlmKHJldCA9PT0gcmVhY3QuUCl7XG4gICAgICAgICAgICByZWFjdC5yZWooVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXQpKXtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXQsIHJlYWN0LnJlcywgcmVhY3QucmVqKTtcbiAgICAgICAgICB9IGVsc2UgcmVhY3QucmVzKHJldCk7XG4gICAgICAgIH0gZWxzZSByZWFjdC5yZWoodmFsdWUpO1xuICAgICAgfSBjYXRjaChlcnIpe1xuICAgICAgICByZWFjdC5yZWooZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgY2hhaW4ubGVuZ3RoID0gMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1VuaGFuZGxlZChwcm9taXNlKXtcbiAgdmFyIHJlY29yZCA9IHByb21pc2VbUkVDT1JEXVxuICAgICwgY2hhaW4gID0gcmVjb3JkLmEgfHwgcmVjb3JkLmNcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlYWN0O1xuICBpZihyZWNvcmQuaClyZXR1cm4gZmFsc2U7XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0ID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdC5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdC5QKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkcmVqZWN0KHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXNcbiAgICAsIHByb21pc2U7XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICByZWNvcmQudiA9IHZhbHVlO1xuICByZWNvcmQucyA9IDI7XG4gIHJlY29yZC5hID0gcmVjb3JkLmMuc2xpY2UoKTtcbiAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgIGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UgPSByZWNvcmQucCkpe1xuICAgICAgICBpZihjb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGdsb2JhbC5jb25zb2xlICYmIGlzRnVuY3Rpb24oY29uc29sZS5lcnJvcikpe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb3JkLmEgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH0sIDEpO1xuICBub3RpZnkocmVjb3JkKTtcbn1cbmZ1bmN0aW9uICRyZXNvbHZlKHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXNcbiAgICAsIHRoZW4sIHdyYXBwZXI7XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICB3cmFwcGVyID0ge3I6IHJlY29yZCwgZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZC52ID0gdmFsdWU7XG4gICAgICByZWNvcmQucyA9IDE7XG4gICAgICBub3RpZnkocmVjb3JkKTtcbiAgICB9XG4gIH0gY2F0Y2goZXJyKXtcbiAgICAkcmVqZWN0LmNhbGwod3JhcHBlciB8fCB7cjogcmVjb3JkLCBkOiBmYWxzZX0sIGVycik7IC8vIHdyYXBcbiAgfVxufVxuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYoIXVzZU5hdGl2ZSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gIFAgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhc3NlcnRGdW5jdGlvbihleGVjdXRvcik7XG4gICAgdmFyIHJlY29yZCA9IHtcbiAgICAgIHA6IGFzc2VydC5pbnN0KHRoaXMsIFAsIFBST01JU0UpLCAgICAgICAvLyA8LSBwcm9taXNlXG4gICAgICBjOiBbXSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgICBhOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICAgIHM6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgICAgZDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICAgIHY6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgaDogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGhhbmRsZWQgcmVqZWN0aW9uXG4gICAgfTtcbiAgICAkLmhpZGUodGhpcywgUkVDT1JELCByZWNvcmQpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHJlY29yZCwgMSksIGN0eCgkcmVqZWN0LCByZWNvcmQsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwocmVjb3JkLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgcmVxdWlyZSgnLi8kLm1peCcpKFAucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciBTID0gYXNzZXJ0T2JqZWN0KGFzc2VydE9iamVjdCh0aGlzKS5jb25zdHJ1Y3RvcilbU1BFQ0lFU107XG4gICAgICB2YXIgcmVhY3QgPSB7XG4gICAgICAgIG9rOiAgIGlzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiB0cnVlLFxuICAgICAgICBmYWlsOiBpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpICA/IG9uUmVqZWN0ZWQgIDogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgcHJvbWlzZSA9IHJlYWN0LlAgPSBuZXcgKFMgIT0gdW5kZWZpbmVkID8gUyA6IFApKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgICAgcmVhY3QucmVzID0gYXNzZXJ0RnVuY3Rpb24ocmVzKTtcbiAgICAgICAgcmVhY3QucmVqID0gYXNzZXJ0RnVuY3Rpb24ocmVqKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlY29yZCA9IHRoaXNbUkVDT1JEXTtcbiAgICAgIHJlY29yZC5jLnB1c2gocmVhY3QpO1xuICAgICAgaWYocmVjb3JkLmEpcmVjb3JkLmEucHVzaChyZWFjdCk7XG4gICAgICBpZihyZWNvcmQucylub3RpZnkocmVjb3JkKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBleHBvcnRcbiRkZWYoJGRlZi5HICsgJGRlZi5XICsgJGRlZi5GICogIXVzZU5hdGl2ZSwge1Byb21pc2U6IFB9KTtcbmNvZi5zZXQoUCwgUFJPTUlTRSk7XG5zcGVjaWVzKFApO1xuc3BlY2llcyhXcmFwcGVyID0gJC5jb3JlW1BST01JU0VdKTtcblxuLy8gc3RhdGljc1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHJldHVybiBuZXcgKGdldENvbnN0cnVjdG9yKHRoaXMpKShmdW5jdGlvbihyZXMsIHJlail7IHJlaihyKTsgfSk7XG4gIH1cbn0pO1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAoIXVzZU5hdGl2ZSB8fCB0ZXN0UmVzb2x2ZSh0cnVlKSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgcmV0dXJuIGlzUHJvbWlzZSh4KSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcylcbiAgICAgID8geCA6IG5ldyB0aGlzKGZ1bmN0aW9uKHJlcyl7IHJlcyh4KTsgfSk7XG4gIH1cbn0pO1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhKHVzZU5hdGl2ZSAmJiByZXF1aXJlKCcuLyQuaXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXtcbiAgUC5hbGwoaXRlcilbJ2NhdGNoJ10oZnVuY3Rpb24oKXt9KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxuICAgICAgLCB2YWx1ZXMgPSBbXTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCB2YWx1ZXMucHVzaCwgdmFsdWVzKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoXG4gICAgICAgICwgcmVzdWx0cyAgID0gQXJyYXkocmVtYWluaW5nKTtcbiAgICAgIGlmKHJlbWFpbmluZykkLmVhY2guY2FsbCh2YWx1ZXMsIGZ1bmN0aW9uKHByb21pc2UsIGluZGV4KXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzKHJlc3VsdHMpO1xuICAgICAgICB9LCByZWopO1xuICAgICAgfSk7XG4gICAgICBlbHNlIHJlcyhyZXN1bHRzKTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyA9IGdldENvbnN0cnVjdG9yKHRoaXMpO1xuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihyZXMsIHJlail7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihyZXMsIHJlaik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7IiwidmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgc2V0UHJvdG8gID0gcmVxdWlyZSgnLi8kLnNldC1wcm90bycpXG4gICwgJGl0ZXIgICAgID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIElURVIgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdpdGVyJylcbiAgLCBzdGVwICAgICAgPSAkaXRlci5zdGVwXG4gICwgYXNzZXJ0ICAgID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpXG4gICwgaXNPYmplY3QgID0gJC5pc09iamVjdFxuICAsIGdldFByb3RvICA9ICQuZ2V0UHJvdG9cbiAgLCAkUmVmbGVjdCAgPSAkLmcuUmVmbGVjdFxuICAsIF9hcHBseSAgICA9IEZ1bmN0aW9uLmFwcGx5XG4gICwgYXNzZXJ0T2JqZWN0ID0gYXNzZXJ0Lm9ialxuICAsIF9pc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGlzT2JqZWN0XG4gICwgX3ByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zXG4gIC8vIElFIFRQIGhhcyBicm9rZW4gUmVmbGVjdC5lbnVtZXJhdGVcbiAgLCBidWdneUVudW1lcmF0ZSA9ICEoJFJlZmxlY3QgJiYgJFJlZmxlY3QuZW51bWVyYXRlICYmIElURVJBVE9SIGluICRSZWZsZWN0LmVudW1lcmF0ZSh7fSkpO1xuXG5mdW5jdGlvbiBFbnVtZXJhdGUoaXRlcmF0ZWQpe1xuICAkLnNldCh0aGlzLCBJVEVSLCB7bzogaXRlcmF0ZWQsIGs6IHVuZGVmaW5lZCwgaTogMH0pO1xufVxuJGl0ZXIuY3JlYXRlKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uKCl7XG4gIHZhciBpdGVyID0gdGhpc1tJVEVSXVxuICAgICwga2V5cyA9IGl0ZXIua1xuICAgICwga2V5O1xuICBpZihrZXlzID09IHVuZGVmaW5lZCl7XG4gICAgaXRlci5rID0ga2V5cyA9IFtdO1xuICAgIGZvcihrZXkgaW4gaXRlci5vKWtleXMucHVzaChrZXkpO1xuICB9XG4gIGRvIHtcbiAgICBpZihpdGVyLmkgPj0ga2V5cy5sZW5ndGgpcmV0dXJuIHN0ZXAoMSk7XG4gIH0gd2hpbGUoISgoa2V5ID0ga2V5c1tpdGVyLmkrK10pIGluIGl0ZXIubykpO1xuICByZXR1cm4gc3RlcCgwLCBrZXkpO1xufSk7XG5cbnZhciByZWZsZWN0ID0ge1xuICAvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KXtcbiAgICByZXR1cm4gX2FwcGx5LmNhbGwodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpO1xuICB9LFxuICAvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCAvKiwgbmV3VGFyZ2V0Ki8pe1xuICAgIHZhciBwcm90byAgICA9IGFzc2VydC5mbihhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXSkucHJvdG90eXBlXG4gICAgICAsIGluc3RhbmNlID0gJC5jcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKVxuICAgICAgLCByZXN1bHQgICA9IF9hcHBseS5jYWxsKHRhcmdldCwgaW5zdGFuY2UsIGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH0sXG4gIC8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKXtcbiAgICBhc3NlcnRPYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgJC5zZXREZXNjKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIC8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICB2YXIgZGVzYyA9ICQuZ2V0RGVzYyhhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH0sXG4gIC8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleS8qLCByZWNlaXZlciovKXtcbiAgICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXVxuICAgICAgLCBkZXNjID0gJC5nZXREZXNjKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSksIHByb3RvO1xuICAgIGlmKGRlc2MpcmV0dXJuICQuaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICA/IGRlc2MudmFsdWVcbiAgICAgIDogZGVzYy5nZXQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgIHJldHVybiBpc09iamVjdChwcm90byA9IGdldFByb3RvKHRhcmdldCkpXG4gICAgICA/IGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIC8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gJC5nZXREZXNjKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH0sXG4gIC8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCl7XG4gICAgcmV0dXJuIGdldFByb3RvKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcbiAgfSxcbiAgLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH0sXG4gIC8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpe1xuICAgIHJldHVybiBfaXNFeHRlbnNpYmxlKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcbiAgfSxcbiAgLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuICBvd25LZXlzOiByZXF1aXJlKCcuLyQub3duLWtleXMnKSxcbiAgLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCl7XG4gICAgYXNzZXJ0T2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKF9wcmV2ZW50RXh0ZW5zaW9ucylfcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICAvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxuICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWLyosIHJlY2VpdmVyKi8pe1xuICAgIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdXG4gICAgICAsIG93bkRlc2MgID0gJC5nZXREZXNjKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSlcbiAgICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgICBpZighb3duRGVzYyl7XG4gICAgICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvKHRhcmdldCkpKXtcbiAgICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICAgIG93bkRlc2MgPSAkLmRlc2MoMCk7XG4gICAgfVxuICAgIGlmKCQuaGFzKG93bkRlc2MsICd2YWx1ZScpKXtcbiAgICAgIGlmKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpcmV0dXJuIGZhbHNlO1xuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gJC5nZXREZXNjKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgJC5kZXNjKDApO1xuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICAgICQuc2V0RGVzYyhyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG4gIH1cbn07XG4vLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbmlmKHNldFByb3RvKXJlZmxlY3Quc2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKXtcbiAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gIHRyeSB7XG4gICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuJGRlZigkZGVmLkcsIHtSZWZsZWN0OiB7fX0pO1xuXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqIGJ1Z2d5RW51bWVyYXRlLCAnUmVmbGVjdCcsIHtcbiAgLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KXtcbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZShhc3NlcnRPYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuXG4kZGVmKCRkZWYuUywgJ1JlZmxlY3QnLCByZWZsZWN0KTsiLCJ2YXIgJCAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY29mICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRSZWdFeHAgPSAkLmcuUmVnRXhwXG4gICwgQmFzZSAgICA9ICRSZWdFeHBcbiAgLCBwcm90byAgID0gJFJlZ0V4cC5wcm90b3R5cGVcbiAgLCByZSAgICAgID0gL2EvZ1xuICAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0XG4gICwgQ09SUkVDVF9ORVcgPSBuZXcgJFJlZ0V4cChyZSkgIT09IHJlXG4gIC8vIFJlZ0V4cCBhbGxvd3MgYSByZWdleCB3aXRoIGZsYWdzIGFzIHRoZSBwYXR0ZXJuXG4gICwgQUxMT1dTX1JFX1dJVEhfRkxBR1MgPSBmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gJFJlZ0V4cChyZSwgJ2knKSA9PSAnL2EvaSc7XG4gICAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICB9KCk7XG5pZigkLkZXICYmICQuREVTQyl7XG4gIGlmKCFDT1JSRUNUX05FVyB8fCAhQUxMT1dTX1JFX1dJVEhfRkxBR1Mpe1xuICAgICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocGF0dGVybiwgZmxhZ3Mpe1xuICAgICAgdmFyIHBhdHRlcm5Jc1JlZ0V4cCAgPSBjb2YocGF0dGVybikgPT0gJ1JlZ0V4cCdcbiAgICAgICAgLCBmbGFnc0lzVW5kZWZpbmVkID0gZmxhZ3MgPT09IHVuZGVmaW5lZDtcbiAgICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mICRSZWdFeHApICYmIHBhdHRlcm5Jc1JlZ0V4cCAmJiBmbGFnc0lzVW5kZWZpbmVkKXJldHVybiBwYXR0ZXJuO1xuICAgICAgcmV0dXJuIENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGF0dGVybklzUmVnRXhwICYmICFmbGFnc0lzVW5kZWZpbmVkID8gcGF0dGVybi5zb3VyY2UgOiBwYXR0ZXJuLCBmbGFncylcbiAgICAgICAgOiBuZXcgQmFzZShwYXR0ZXJuSXNSZWdFeHAgPyBwYXR0ZXJuLnNvdXJjZSA6IHBhdHRlcm5cbiAgICAgICAgICAsIHBhdHRlcm5Jc1JlZ0V4cCAmJiBmbGFnc0lzVW5kZWZpbmVkID8gcGF0dGVybi5mbGFncyA6IGZsYWdzKTtcbiAgICB9O1xuICAgICQuZWFjaC5jYWxsKCQuZ2V0TmFtZXMoQmFzZSksIGZ1bmN0aW9uKGtleSl7XG4gICAgICBrZXkgaW4gJFJlZ0V4cCB8fCAkLnNldERlc2MoJFJlZ0V4cCwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGl0KXsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHJlcXVpcmUoJy4vJC5yZWRlZicpKCQuZywgJ1JlZ0V4cCcsICRSZWdFeHApO1xuICB9XG4gIC8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbiAgaWYoLy4vZy5mbGFncyAhPSAnZycpJC5zZXREZXNjKHByb3RvLCAnZmxhZ3MnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogcmVxdWlyZSgnLi8kLnJlcGxhY2VyJykoL14uKlxcLyhcXHcqKSQvLCAnJDEnKVxuICB9KTtcbn1cbnJlcXVpcmUoJy4vJC5zcGVjaWVzJykoJFJlZ0V4cCk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5yZXF1aXJlKCcuLyQuY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzWzBdKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKGZhbHNlKTtcbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY29mICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCB0b0xlbmd0aCA9ICQudG9MZW5ndGg7XG5cbi8vIHNob3VsZCB0aHJvdyBlcnJvciBvbiByZWdleFxuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiAhcmVxdWlyZSgnLi8kLnRocm93cycpKGZ1bmN0aW9uKCl7ICdxJy5lbmRzV2l0aCgvLi8pOyB9KSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xuICAgIGlmKGNvZihzZWFyY2hTdHJpbmcpID09ICdSZWdFeHAnKXRocm93IFR5cGVFcnJvcigpO1xuICAgIHZhciB0aGF0ID0gU3RyaW5nKCQuYXNzZXJ0RGVmaW5lZCh0aGlzKSlcbiAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHNbMV1cbiAgICAgICwgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpXG4gICAgICAsIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgc2VhcmNoU3RyaW5nICs9ICcnO1xuICAgIHJldHVybiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaFN0cmluZy5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaFN0cmluZztcbiAgfVxufSk7IiwidmFyICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCB0b0luZGV4ID0gcmVxdWlyZSgnLi8kJykudG9JbmRleFxuICAsIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgLCAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgPSBbXVxuICAgICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGkgICA9IDBcbiAgICAgICwgY29kZTtcbiAgICB3aGlsZShsZW4gPiBpKXtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY29mICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIGlmKGNvZihzZWFyY2hTdHJpbmcpID09ICdSZWdFeHAnKXRocm93IFR5cGVFcnJvcigpO1xuICAgIHJldHVybiAhIX5TdHJpbmcoJC5hc3NlcnREZWZpbmVkKHRoaXMpKS5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwidmFyIHNldCAgID0gcmVxdWlyZSgnLi8kJykuc2V0XG4gICwgJGF0ICAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykodHJ1ZSlcbiAgLCBJVEVSICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdpdGVyJylcbiAgLCAkaXRlciA9IHJlcXVpcmUoJy4vJC5pdGVyJylcbiAgLCBzdGVwICA9ICRpdGVyLnN0ZXA7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgc2V0KHRoaXMsIElURVIsIHtvOiBTdHJpbmcoaXRlcmF0ZWQpLCBpOiAwfSk7XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXG4gICAgLCBPICAgICA9IGl0ZXIub1xuICAgICwgaW5kZXggPSBpdGVyLmlcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4gc3RlcCgxKTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICBpdGVyLmkgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4gc3RlcCgwLCBwb2ludCk7XG59KTsiLCJ2YXIgJCAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsID0gJC50b09iamVjdChjYWxsU2l0ZS5yYXcpXG4gICAgICAsIGxlbiA9ICQudG9MZW5ndGgodHBsLmxlbmd0aClcbiAgICAgICwgc2xuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgPSBbXVxuICAgICAgLCBpICAgPSAwO1xuICAgIHdoaWxlKGxlbiA+IGkpe1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZihpIDwgc2xuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsInZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vJC5zdHJpbmctcmVwZWF0Jylcbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuLy8gc2hvdWxkIHRocm93IGVycm9yIG9uIHJlZ2V4XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqICFyZXF1aXJlKCcuLyQudGhyb3dzJykoZnVuY3Rpb24oKXsgJ3EnLnN0YXJ0c1dpdGgoLy4vKTsgfSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIGlmKGNvZihzZWFyY2hTdHJpbmcpID09ICdSZWdFeHAnKXRocm93IFR5cGVFcnJvcigpO1xuICAgIHZhciB0aGF0ICA9IFN0cmluZygkLmFzc2VydERlZmluZWQodGhpcykpXG4gICAgICAsIGluZGV4ID0gJC50b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHNbMV0sIHRoYXQubGVuZ3RoKSk7XG4gICAgc2VhcmNoU3RyaW5nICs9ICcnO1xuICAgIHJldHVybiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgc2V0VGFnICAgPSByZXF1aXJlKCcuLyQuY29mJykuc2V0XG4gICwgdWlkICAgICAgPSByZXF1aXJlKCcuLyQudWlkJylcbiAgLCBzaGFyZWQgICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKVxuICAsICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHJlZGVmICAgPSByZXF1aXJlKCcuLyQucmVkZWYnKVxuICAsIGtleU9mICAgID0gcmVxdWlyZSgnLi8kLmtleW9mJylcbiAgLCBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vJC5lbnVtLWtleXMnKVxuICAsIGFzc2VydE9iamVjdCA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKS5vYmpcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGVcbiAgLCBERVNDICAgICA9ICQuREVTQ1xuICAsIGhhcyAgICAgID0gJC5oYXNcbiAgLCAkY3JlYXRlICA9ICQuY3JlYXRlXG4gICwgZ2V0RGVzYyAgPSAkLmdldERlc2NcbiAgLCBzZXREZXNjICA9ICQuc2V0RGVzY1xuICAsIGRlc2MgICAgID0gJC5kZXNjXG4gICwgJG5hbWVzICAgPSByZXF1aXJlKCcuLyQuZ2V0LW5hbWVzJylcbiAgLCBnZXROYW1lcyA9ICRuYW1lcy5nZXRcbiAgLCB0b09iamVjdCA9ICQudG9PYmplY3RcbiAgLCAkU3ltYm9sICA9ICQuZy5TeW1ib2xcbiAgLCBzZXR0ZXIgICA9IGZhbHNlXG4gICwgVEFHICAgICAgPSB1aWQoJ3RhZycpXG4gICwgSElEREVOICAgPSB1aWQoJ2hpZGRlbicpXG4gICwgX3Byb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCB1c2VOYXRpdmUgPSAkLmlzRnVuY3Rpb24oJFN5bWJvbCk7XG5cbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQyA/IGZ1bmN0aW9uKCl7IC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZFxuICB0cnkge1xuICAgIHJldHVybiAkY3JlYXRlKHNldERlc2Moe30sIEhJRERFTiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc2V0RGVzYyh0aGlzLCBISURERU4sIHt2YWx1ZTogZmFsc2V9KVtISURERU5dO1xuICAgICAgfVxuICAgIH0pKVtISURERU5dIHx8IHNldERlc2M7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICAgICAgdmFyIHByb3RvRGVzYyA9IGdldERlc2MoT2JqZWN0UHJvdG8sIGtleSk7XG4gICAgICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gICAgICBzZXREZXNjKGl0LCBrZXksIEQpO1xuICAgICAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylzZXREZXNjKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG4gICAgfTtcbiAgfVxufSgpIDogc2V0RGVzYztcblxuZnVuY3Rpb24gd3JhcCh0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gJC5zZXQoJGNyZWF0ZSgkU3ltYm9sLnByb3RvdHlwZSksIFRBRywgdGFnKTtcbiAgREVTQyAmJiBzZXR0ZXIgJiYgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGRlc2MoMSwgdmFsdWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3ltO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKXNldERlc2MoaXQsIEhJRERFTiwgZGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSAkY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBkZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIHNldERlc2MoaXQsIGtleSwgRCk7XG59XG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYXNzZXJ0T2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9PYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKWRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyAkY3JlYXRlKGl0KSA6IGRlZmluZVByb3BlcnRpZXMoJGNyZWF0ZShpdCksIFApO1xufVxuZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBfcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0aGlzLCBrZXkpO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldXG4gICAgPyBFIDogdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgdmFyIEQgPSBnZXREZXNjKGl0ID0gdG9PYmplY3QoaXQpLCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59XG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOKXJlc3VsdC5wdXNoKGtleSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighdXNlTmF0aXZlKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgcmV0dXJuIHdyYXAodWlkKGFyZ3VtZW50c1swXSkpO1xuICB9O1xuICAkcmVkZWYoJFN5bWJvbC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXNbVEFHXTtcbiAgfSk7XG5cbiAgJC5jcmVhdGUgICAgID0gY3JlYXRlO1xuICAkLnNldERlc2MgICAgPSBkZWZpbmVQcm9wZXJ0eTtcbiAgJC5nZXREZXNjICAgID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkLnNldERlc2NzICAgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuICAkLmdldE5hbWVzICAgPSAkbmFtZXMuZ2V0ID0gZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgJC5nZXRTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKCQuREVTQyAmJiAkLkZXKSRyZWRlZihPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xufVxuXG52YXIgc3ltYm9sU3RhdGljcyA9IHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufTtcbi8vIDE5LjQuMi4yIFN5bWJvbC5oYXNJbnN0YW5jZVxuLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxuLy8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXG4vLyAxOS40LjIuNiBTeW1ib2wubWF0Y2hcbi8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXG4vLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXG4vLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcbi8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcbi8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcbi8vIDE5LjQuMi4xMyBTeW1ib2wudG9TdHJpbmdUYWdcbi8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcbiQuZWFjaC5jYWxsKChcbiAgICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLCcgK1xuICAgICdzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuICApLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgc3ltID0gcmVxdWlyZSgnLi8kLndrcycpKGl0KTtcbiAgICBzeW1ib2xTdGF0aWNzW2l0XSA9IHVzZU5hdGl2ZSA/IHN5bSA6IHdyYXAoc3ltKTtcbiAgfVxuKTtcblxuc2V0dGVyID0gdHJ1ZTtcblxuJGRlZigkZGVmLkcgKyAkZGVmLlcsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuJGRlZigkZGVmLlMsICdTeW1ib2wnLCBzeW1ib2xTdGF0aWNzKTtcblxuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6IGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiBkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRhZygkLmcuSlNPTiwgJ0pTT04nLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB3ZWFrICAgICAgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi13ZWFrJylcbiAgLCBsZWFrU3RvcmUgPSB3ZWFrLmxlYWtTdG9yZVxuICAsIElEICAgICAgICA9IHdlYWsuSURcbiAgLCBXRUFLICAgICAgPSB3ZWFrLldFQUtcbiAgLCBoYXMgICAgICAgPSAkLmhhc1xuICAsIGlzT2JqZWN0ICA9ICQuaXNPYmplY3RcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGlzT2JqZWN0XG4gICwgdG1wICAgICAgID0ge307XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbicpKCdXZWFrTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHNbMF0pOyB9O1xufSwge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIGlmKGlzT2JqZWN0KGtleSkpe1xuICAgICAgaWYoIWlzRXh0ZW5zaWJsZShrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuZ2V0KGtleSk7XG4gICAgICBpZihoYXMoa2V5LCBXRUFLKSlyZXR1cm4ga2V5W1dFQUtdW3RoaXNbSURdXTtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZihuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3KXtcbiAgJC5lYWNoLmNhbGwoWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgcHJvdG8gID0gJFdlYWtNYXAucHJvdG90eXBlXG4gICAgICAsIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVxdWlyZSgnLi8kLnJlZGVmJykocHJvdG8sIGtleSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBsZWFreSBtYXBcbiAgICAgIGlmKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpe1xuICAgICAgICB2YXIgcmVzdWx0ID0gbGVha1N0b3JlKHRoaXMpW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi13ZWFrJyk7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuLyQuY29sbGVjdGlvbicpKCdXZWFrU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHNbMF0pOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vJC5hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvbWVuaWMvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuLyQudW5zY29wZScpKCdpbmNsdWRlcycpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJyk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi85MzUzNzgxXG52YXIgJCAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIG93bktleXMgPSByZXF1aXJlKCcuLyQub3duLWtleXMnKTtcblxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KXtcbiAgICB2YXIgTyAgICAgID0gJC50b09iamVjdChvYmplY3QpXG4gICAgICAsIHJlc3VsdCA9IHt9O1xuICAgICQuZWFjaC5jYWxsKG93bktleXMoTyksIGZ1bmN0aW9uKGtleSl7XG4gICAgICAkLnNldERlc2MocmVzdWx0LCBrZXksICQuZGVzYygwLCAkLmdldERlc2MoTywga2V5KSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsIi8vIGh0dHA6Ly9nb28uZ2wvWGtCcmpEXG52YXIgJCAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFRvQXJyYXkoaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgdmFyIE8gICAgICA9ICQudG9PYmplY3Qob2JqZWN0KVxuICAgICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBBcnJheShsZW5ndGgpXG4gICAgICAsIGtleTtcbiAgICBpZihpc0VudHJpZXMpd2hpbGUobGVuZ3RoID4gaSlyZXN1bHRbaV0gPSBba2V5ID0ga2V5c1tpKytdLCBPW2tleV1dO1xuICAgIGVsc2Ugd2hpbGUobGVuZ3RoID4gaSlyZXN1bHRbaV0gPSBPW2tleXNbaSsrXV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbiRkZWYoJGRlZi5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6ICBjcmVhdGVPYmplY3RUb0FycmF5KGZhbHNlKSxcbiAgZW50cmllczogY3JlYXRlT2JqZWN0VG9BcnJheSh0cnVlKVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20va2FuZ2F4Lzk2OTgxMDBcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuJGRlZigkZGVmLlMsICdSZWdFeHAnLCB7XG4gIGVzY2FwZTogcmVxdWlyZSgnLi8kLnJlcGxhY2VyJykoLyhbXFxcXFxcLVtcXF17fSgpKis/LixeJHxdKS9nLCAnXFxcXCQxJywgdHJ1ZSlcbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKHRydWUpO1xuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcGFkID0gcmVxdWlyZSgnLi8kLnN0cmluZy1wYWQnKTtcbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICBscGFkOiBmdW5jdGlvbiBscGFkKG4pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG4sIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHBhZCA9IHJlcXVpcmUoJy4vJC5zdHJpbmctcGFkJyk7XG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgcnBhZDogZnVuY3Rpb24gcnBhZChuKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBuLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7IiwiLy8gSmF2YVNjcmlwdCAxLjYgLyBTdHJhd21hbiBhcnJheSBzdGF0aWNzIHNoaW1cbnZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJEFycmF5ICA9ICQuY29yZS5BcnJheSB8fCBBcnJheVxuICAsIHN0YXRpY3MgPSB7fTtcbmZ1bmN0aW9uIHNldFN0YXRpY3Moa2V5cywgbGVuZ3RoKXtcbiAgJC5lYWNoLmNhbGwoa2V5cy5zcGxpdCgnLCcpLCBmdW5jdGlvbihrZXkpe1xuICAgIGlmKGxlbmd0aCA9PSB1bmRlZmluZWQgJiYga2V5IGluICRBcnJheSlzdGF0aWNzW2tleV0gPSAkQXJyYXlba2V5XTtcbiAgICBlbHNlIGlmKGtleSBpbiBbXSlzdGF0aWNzW2tleV0gPSByZXF1aXJlKCcuLyQuY3R4JykoRnVuY3Rpb24uY2FsbCwgW11ba2V5XSwgbGVuZ3RoKTtcbiAgfSk7XG59XG5zZXRTdGF0aWNzKCdwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzJywgMSk7XG5zZXRTdGF0aWNzKCdpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzJywgMyk7XG5zZXRTdGF0aWNzKCdqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YsJyArXG4gICAgICAgICAgICdyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsLHR1cm4nKTtcbiRkZWYoJGRlZi5TLCAnQXJyYXknLCBzdGF0aWNzKTsiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyICQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBJdGVyYXRvcnMgICA9IHJlcXVpcmUoJy4vJC5pdGVyJykuSXRlcmF0b3JzXG4gICwgSVRFUkFUT1IgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheVxuICAsIE5MICAgICAgICAgID0gJC5nLk5vZGVMaXN0XG4gICwgSFRDICAgICAgICAgPSAkLmcuSFRNTENvbGxlY3Rpb25cbiAgLCBOTFByb3RvICAgICA9IE5MICYmIE5MLnByb3RvdHlwZVxuICAsIEhUQ1Byb3RvICAgID0gSFRDICYmIEhUQy5wcm90b3R5cGU7XG5pZigkLkZXKXtcbiAgaWYoTkwgJiYgIShJVEVSQVRPUiBpbiBOTFByb3RvKSkkLmhpZGUoTkxQcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgaWYoSFRDICYmICEoSVRFUkFUT1IgaW4gSFRDUHJvdG8pKSQuaGlkZShIVENQcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbn1cbkl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9ycy5IVE1MQ29sbGVjdGlvbiA9IEFycmF5VmFsdWVzOyIsInZhciAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICR0YXNrID0gcmVxdWlyZSgnLi8kLnRhc2snKTtcbiRkZWYoJGRlZi5HICsgJGRlZi5CLCB7XG4gIHNldEltbWVkaWF0ZTogICAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7IiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgaW52b2tlICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgcGFydGlhbCAgID0gcmVxdWlyZSgnLi8kLnBhcnRpYWwnKVxuICAsIG5hdmlnYXRvciA9ICQuZy5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG5mdW5jdGlvbiB3cmFwKHNldCl7XG4gIHJldHVybiBNU0lFID8gZnVuY3Rpb24oZm4sIHRpbWUgLyosIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBzZXQoaW52b2tlKFxuICAgICAgcGFydGlhbCxcbiAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICQuaXNGdW5jdGlvbihmbikgPyBmbiA6IEZ1bmN0aW9uKGZuKVxuICAgICksIHRpbWUpO1xuICB9IDogc2V0O1xufVxuJGRlZigkZGVmLkcgKyAkZGVmLkIgKyAkZGVmLkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKCQuZy5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoJC5nLnNldEludGVydmFsKVxufSk7IiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc3RhdGljcy1hY2NlcHQtcHJpbWl0aXZlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnN0YXRpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5scGFkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5ycGFkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZ2V4cC5lc2NhcGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnRvLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvanMuYXJyYXkuc3RhdGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvJCcpLmNvcmU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9XG4gICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcblxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChcbiAgICAgIGlubmVyRm4sIHNlbGYgfHwgbnVsbCxcbiAgICAgIG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKVxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIC8vIFRoaXMgaW52b2tlIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gaW4gYSBzdHlsZSB0aGF0IGFzc3VtZXMgc29tZVxuICAgIC8vIGNhbGxpbmcgZnVuY3Rpb24gKG9yIFByb21pc2UpIHdpbGwgaGFuZGxlIGV4Y2VwdGlvbnMuXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2VuZXJhdG9yW21ldGhvZF0oYXJnKTtcbiAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGludm9rZU5leHQsIGludm9rZVRocm93KVxuICAgICAgICA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgaW52b2tlTmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIHZhciBpbnZva2VUaHJvdyA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJ0aHJvd1wiKTtcbiAgICB2YXIgaW52b2tlUmV0dXJuID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInJldHVyblwiKTtcbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgdmFyIGVucXVldWVSZXN1bHQgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICAgIH0pIDogbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoaW52b2tlKG1ldGhvZCwgYXJnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBlbnF1ZXVlUmVzdWx0IGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5XG4gICAgICAvLyBsYXRlciBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IsIGFuZCBjYWxsIGdlbmVyYXRvci5yZXR1cm4oKSB0b1xuICAgICAgLy8gYWxsb3cgdGhlIGdlbmVyYXRvciBhIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgIHByZXZpb3VzUHJvbWlzZSA9IGVucXVldWVSZXN1bHQuY2F0Y2goaW52b2tlUmV0dXJuKTtcblxuICAgICAgcmV0dXJuIGVucXVldWVSZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQuc2VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIC8vIFByZS1pbml0aWFsaXplIGF0IGxlYXN0IDIwIHRlbXBvcmFyeSB2YXJpYWJsZXMgdG8gZW5hYmxlIGhpZGRlblxuICAgICAgLy8gY2xhc3Mgb3B0aW1pemF0aW9ucyBmb3Igc2ltcGxlIGdlbmVyYXRvcnMuXG4gICAgICBmb3IgKHZhciB0ZW1wSW5kZXggPSAwLCB0ZW1wTmFtZTtcbiAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgdGVtcE5hbWUgPSBcInRcIiArIHRlbXBJbmRleCkgfHwgdGVtcEluZGV4IDwgMjA7XG4gICAgICAgICAgICsrdGVtcEluZGV4KSB7XG4gICAgICAgIHRoaXNbdGVtcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL2JhYmVsL3BvbHlmaWxsXCIpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtY29yZS9wb2x5ZmlsbFwiKTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIga01heExlbmd0aCA9IDB4M2ZmZmZmZmZcbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAtIEltcGxlbWVudGF0aW9uIG11c3Qgc3VwcG9ydCBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcy5cbiAqICAgRmlyZWZveCA0LTI5IGxhY2tlZCBzdXBwb3J0LCBmaXhlZCBpbiBGaXJlZm94IDMwKy5cbiAqICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cbiAqXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleSB3aWxsXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCB3aWxsIHdvcmsgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBuZXcgVWludDhBcnJheSgxKS5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpXG5cbiAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGggKiAyXG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoID4+PiAxXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XFwtXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cbiAgdmFyIGkgPSAwXG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgIGNvZGVQb2ludCA9IGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDAgfCAweDEwMDAwXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcblxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MjAwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuIiwiLypcblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbk9yaWdpbmFsIExpYnJhcnkgXG4gIC0gQ29weXJpZ2h0IChjKSBNYXJhayBTcXVpcmVzXG5cbkFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eVxuIC0gQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgY29sb3JzID0ge307XG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGNvbG9ycztcblxuY29sb3JzLnRoZW1lcyA9IHt9O1xuXG52YXIgYW5zaVN0eWxlcyA9IGNvbG9ycy5zdHlsZXMgPSByZXF1aXJlKCcuL3N0eWxlcycpO1xudmFyIGRlZmluZVByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG5cbmNvbG9ycy5zdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnLi9zeXN0ZW0vc3VwcG9ydHMtY29sb3JzJyk7XG5cbmlmICh0eXBlb2YgY29sb3JzLmVuYWJsZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgY29sb3JzLmVuYWJsZWQgPSBjb2xvcnMuc3VwcG9ydHNDb2xvcjtcbn1cblxuY29sb3JzLnN0cmlwQ29sb3JzID0gY29sb3JzLnN0cmlwID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIChcIlwiICsgc3RyKS5yZXBsYWNlKC9cXHgxQlxcW1xcZCttL2csICcnKTtcbn07XG5cblxudmFyIHN0eWxpemUgPSBjb2xvcnMuc3R5bGl6ZSA9IGZ1bmN0aW9uIHN0eWxpemUgKHN0ciwgc3R5bGUpIHtcbiAgaWYgKCFjb2xvcnMuZW5hYmxlZCkge1xuICAgIHJldHVybiBzdHIrJyc7XG4gIH1cblxuICByZXR1cm4gYW5zaVN0eWxlc1tzdHlsZV0ub3BlbiArIHN0ciArIGFuc2lTdHlsZXNbc3R5bGVdLmNsb3NlO1xufVxuXG52YXIgbWF0Y2hPcGVyYXRvcnNSZSA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZztcbnZhciBlc2NhcGVTdHJpbmdSZWdleHAgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkKF9zdHlsZXMpIHtcbiAgdmFyIGJ1aWxkZXIgPSBmdW5jdGlvbiBidWlsZGVyKCkge1xuICAgIHJldHVybiBhcHBseVN0eWxlLmFwcGx5KGJ1aWxkZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGJ1aWxkZXIuX3N0eWxlcyA9IF9zdHlsZXM7XG4gIC8vIF9fcHJvdG9fXyBpcyB1c2VkIGJlY2F1c2Ugd2UgbXVzdCByZXR1cm4gYSBmdW5jdGlvbiwgYnV0IHRoZXJlIGlzXG4gIC8vIG5vIHdheSB0byBjcmVhdGUgYSBmdW5jdGlvbiB3aXRoIGEgZGlmZmVyZW50IHByb3RvdHlwZS5cbiAgYnVpbGRlci5fX3Byb3RvX18gPSBwcm90bztcbiAgcmV0dXJuIGJ1aWxkZXI7XG59XG5cbnZhciBzdHlsZXMgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmV0ID0ge307XG4gIGFuc2lTdHlsZXMuZ3JleSA9IGFuc2lTdHlsZXMuZ3JheTtcbiAgT2JqZWN0LmtleXMoYW5zaVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgYW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzW2tleV0uY2xvc2UpLCAnZycpO1xuICAgIHJldFtrZXldID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBidWlsZCh0aGlzLl9zdHlsZXMuY29uY2F0KGtleSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufSkoKTtcblxudmFyIHByb3RvID0gZGVmaW5lUHJvcHMoZnVuY3Rpb24gY29sb3JzKCkge30sIHN0eWxlcyk7XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gYXJnc0xlbiAhPT0gMCAmJiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGFyZ3NMZW4gPiAxKSB7XG4gICAgZm9yICh2YXIgYSA9IDE7IGEgPCBhcmdzTGVuOyBhKyspIHtcbiAgICAgIHN0ciArPSAnICcgKyBhcmdzW2FdO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29sb3JzLmVuYWJsZWQgfHwgIXN0cikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgbmVzdGVkU3R5bGVzID0gdGhpcy5fc3R5bGVzO1xuXG4gIHZhciBpID0gbmVzdGVkU3R5bGVzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBjb2RlID0gYW5zaVN0eWxlc1tuZXN0ZWRTdHlsZXNbaV1dO1xuICAgIHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBhcHBseVRoZW1lICh0aGVtZSkge1xuICBmb3IgKHZhciBzdHlsZSBpbiB0aGVtZSkge1xuICAgIChmdW5jdGlvbihzdHlsZSl7XG4gICAgICBjb2xvcnNbc3R5bGVdID0gZnVuY3Rpb24oc3RyKXtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVtZVtzdHlsZV0gPT09ICdvYmplY3QnKXtcbiAgICAgICAgICB2YXIgb3V0ID0gc3RyO1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhlbWVbc3R5bGVdKXtcbiAgICAgICAgICAgIG91dCA9IGNvbG9yc1t0aGVtZVtzdHlsZV1baV1dKG91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yc1t0aGVtZVtzdHlsZV1dKHN0cik7XG4gICAgICB9O1xuICAgIH0pKHN0eWxlKVxuICB9XG59XG5cbmNvbG9ycy5zZXRUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSkge1xuICBpZiAodHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBjb2xvcnMudGhlbWVzW3RoZW1lXSA9IHJlcXVpcmUodGhlbWUpO1xuICAgICAgYXBwbHlUaGVtZShjb2xvcnMudGhlbWVzW3RoZW1lXSk7XG4gICAgICByZXR1cm4gY29sb3JzLnRoZW1lc1t0aGVtZV07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXBwbHlUaGVtZSh0aGVtZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0W25hbWVdID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBidWlsZChbbmFtZV0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG52YXIgc2VxdWVuY2VyID0gZnVuY3Rpb24gc2VxdWVuY2VyIChtYXAsIHN0cikge1xuICB2YXIgZXhwbG9kZWQgPSBzdHIuc3BsaXQoXCJcIiksIGkgPSAwO1xuICBleHBsb2RlZCA9IGV4cGxvZGVkLm1hcChtYXApO1xuICByZXR1cm4gZXhwbG9kZWQuam9pbihcIlwiKTtcbn07XG5cbi8vIGN1c3RvbSBmb3JtYXR0ZXIgbWV0aG9kc1xuY29sb3JzLnRyYXAgPSByZXF1aXJlKCcuL2N1c3RvbS90cmFwJyk7XG5jb2xvcnMuemFsZ28gPSByZXF1aXJlKCcuL2N1c3RvbS96YWxnbycpO1xuXG4vLyBtYXBzXG5jb2xvcnMubWFwcyA9IHt9O1xuY29sb3JzLm1hcHMuYW1lcmljYSA9IHJlcXVpcmUoJy4vbWFwcy9hbWVyaWNhJyk7XG5jb2xvcnMubWFwcy56ZWJyYSA9IHJlcXVpcmUoJy4vbWFwcy96ZWJyYScpO1xuY29sb3JzLm1hcHMucmFpbmJvdyA9IHJlcXVpcmUoJy4vbWFwcy9yYWluYm93Jyk7XG5jb2xvcnMubWFwcy5yYW5kb20gPSByZXF1aXJlKCcuL21hcHMvcmFuZG9tJylcblxuZm9yICh2YXIgbWFwIGluIGNvbG9ycy5tYXBzKSB7XG4gIChmdW5jdGlvbihtYXApe1xuICAgIGNvbG9yc1ttYXBdID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlcihjb2xvcnMubWFwc1ttYXBdLCBzdHIpO1xuICAgIH1cbiAgfSkobWFwKVxufVxuXG5kZWZpbmVQcm9wcyhjb2xvcnMsIGluaXQoKSk7IiwibW9kdWxlWydleHBvcnRzJ10gPSBmdW5jdGlvbiBydW5UaGVUcmFwICh0ZXh0LCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSBcIlwiO1xuICB0ZXh0ID0gdGV4dCB8fCBcIlJ1biB0aGUgdHJhcCwgZHJvcCB0aGUgYmFzc1wiO1xuICB0ZXh0ID0gdGV4dC5zcGxpdCgnJyk7XG4gIHZhciB0cmFwID0ge1xuICAgIGE6IFtcIlxcdTAwNDBcIiwgXCJcXHUwMTA0XCIsIFwiXFx1MDIzYVwiLCBcIlxcdTAyNDVcIiwgXCJcXHUwMzk0XCIsIFwiXFx1MDM5YlwiLCBcIlxcdTA0MTRcIl0sXG4gICAgYjogW1wiXFx1MDBkZlwiLCBcIlxcdTAxODFcIiwgXCJcXHUwMjQzXCIsIFwiXFx1MDI2ZVwiLCBcIlxcdTAzYjJcIiwgXCJcXHUwZTNmXCJdLFxuICAgIGM6IFtcIlxcdTAwYTlcIiwgXCJcXHUwMjNiXCIsIFwiXFx1MDNmZVwiXSxcbiAgICBkOiBbXCJcXHUwMGQwXCIsIFwiXFx1MDE4YVwiLCBcIlxcdTA1MDBcIiAsIFwiXFx1MDUwMVwiICxcIlxcdTA1MDJcIiwgXCJcXHUwNTAzXCJdLFxuICAgIGU6IFtcIlxcdTAwY2JcIiwgXCJcXHUwMTE1XCIsIFwiXFx1MDE4ZVwiLCBcIlxcdTAyNThcIiwgXCJcXHUwM2EzXCIsIFwiXFx1MDNiZVwiLCBcIlxcdTA0YmNcIiwgXCJcXHUwYTZjXCJdLFxuICAgIGY6IFtcIlxcdTA0ZmFcIl0sXG4gICAgZzogW1wiXFx1MDI2MlwiXSxcbiAgICBoOiBbXCJcXHUwMTI2XCIsIFwiXFx1MDE5NVwiLCBcIlxcdTA0YTJcIiwgXCJcXHUwNGJhXCIsIFwiXFx1MDRjN1wiLCBcIlxcdTA1MGFcIl0sXG4gICAgaTogW1wiXFx1MGYwZlwiXSxcbiAgICBqOiBbXCJcXHUwMTM0XCJdLFxuICAgIGs6IFtcIlxcdTAxMzhcIiwgXCJcXHUwNGEwXCIsIFwiXFx1MDRjM1wiLCBcIlxcdTA1MWVcIl0sXG4gICAgbDogW1wiXFx1MDEzOVwiXSxcbiAgICBtOiBbXCJcXHUwMjhkXCIsIFwiXFx1MDRjZFwiLCBcIlxcdTA0Y2VcIiwgXCJcXHUwNTIwXCIsIFwiXFx1MDUyMVwiLCBcIlxcdTBkNjlcIl0sXG4gICAgbjogW1wiXFx1MDBkMVwiLCBcIlxcdTAxNGJcIiwgXCJcXHUwMTlkXCIsIFwiXFx1MDM3NlwiLCBcIlxcdTAzYTBcIiwgXCJcXHUwNDhhXCJdLFxuICAgIG86IFtcIlxcdTAwZDhcIiwgXCJcXHUwMGY1XCIsIFwiXFx1MDBmOFwiLCBcIlxcdTAxZmVcIiwgXCJcXHUwMjk4XCIsIFwiXFx1MDQ3YVwiLCBcIlxcdTA1ZGRcIiwgXCJcXHUwNmRkXCIsIFwiXFx1MGU0ZlwiXSxcbiAgICBwOiBbXCJcXHUwMWY3XCIsIFwiXFx1MDQ4ZVwiXSxcbiAgICBxOiBbXCJcXHUwOWNkXCJdLFxuICAgIHI6IFtcIlxcdTAwYWVcIiwgXCJcXHUwMWE2XCIsIFwiXFx1MDIxMFwiLCBcIlxcdTAyNGNcIiwgXCJcXHUwMjgwXCIsIFwiXFx1MDQyZlwiXSxcbiAgICBzOiBbXCJcXHUwMGE3XCIsIFwiXFx1MDNkZVwiLCBcIlxcdTAzZGZcIiwgXCJcXHUwM2U4XCJdLFxuICAgIHQ6IFtcIlxcdTAxNDFcIiwgXCJcXHUwMTY2XCIsIFwiXFx1MDM3M1wiXSxcbiAgICB1OiBbXCJcXHUwMWIxXCIsIFwiXFx1MDU0ZFwiXSxcbiAgICB2OiBbXCJcXHUwNWQ4XCJdLFxuICAgIHc6IFtcIlxcdTA0MjhcIiwgXCJcXHUwNDYwXCIsIFwiXFx1MDQ3Y1wiLCBcIlxcdTBkNzBcIl0sXG4gICAgeDogW1wiXFx1MDRiMlwiLCBcIlxcdTA0ZmVcIiwgXCJcXHUwNGZjXCIsIFwiXFx1MDRmZFwiXSxcbiAgICB5OiBbXCJcXHUwMGE1XCIsIFwiXFx1MDRiMFwiLCBcIlxcdTA0Y2JcIl0sXG4gICAgejogW1wiXFx1MDFiNVwiLCBcIlxcdTAyNDBcIl1cbiAgfVxuICB0ZXh0LmZvckVhY2goZnVuY3Rpb24oYyl7XG4gICAgYyA9IGMudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY2hhcnMgPSB0cmFwW2NdIHx8IFtcIiBcIl07XG4gICAgdmFyIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpO1xuICAgIGlmICh0eXBlb2YgdHJhcFtjXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmVzdWx0ICs9IHRyYXBbY11bcmFuZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBjO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG5cbn1cbiIsIi8vIHBsZWFzZSBub1xubW9kdWxlWydleHBvcnRzJ10gPSBmdW5jdGlvbiB6YWxnbyh0ZXh0LCBvcHRpb25zKSB7XG4gIHRleHQgPSB0ZXh0IHx8IFwiICAgaGUgaXMgaGVyZSAgIFwiO1xuICB2YXIgc291bCA9IHtcbiAgICBcInVwXCIgOiBbXG4gICAgICAnzI0nLCAnzI4nLCAnzIQnLCAnzIUnLFxuICAgICAgJ8y/JywgJ8yRJywgJ8yGJywgJ8yQJyxcbiAgICAgICfNkicsICfNlycsICfNkScsICfMhycsXG4gICAgICAnzIgnLCAnzIonLCAnzYInLCAnzJMnLFxuICAgICAgJ8yIJywgJ82KJywgJ82LJywgJ82MJyxcbiAgICAgICfMgycsICfMgicsICfMjCcsICfNkCcsXG4gICAgICAnzIAnLCAnzIEnLCAnzIsnLCAnzI8nLFxuICAgICAgJ8ySJywgJ8yTJywgJ8yUJywgJ8y9JyxcbiAgICAgICfMiScsICfNoycsICfNpCcsICfNpScsXG4gICAgICAnzaYnLCAnzacnLCAnzagnLCAnzaknLFxuICAgICAgJ82qJywgJ82rJywgJ82sJywgJ82tJyxcbiAgICAgICfNricsICfNrycsICfMvicsICfNmycsXG4gICAgICAnzYYnLCAnzJonXG4gICAgXSxcbiAgICBcImRvd25cIiA6IFtcbiAgICAgICfMlicsICfMlycsICfMmCcsICfMmScsXG4gICAgICAnzJwnLCAnzJ0nLCAnzJ4nLCAnzJ8nLFxuICAgICAgJ8ygJywgJ8ykJywgJ8ylJywgJ8ymJyxcbiAgICAgICfMqScsICfMqicsICfMqycsICfMrCcsXG4gICAgICAnzK0nLCAnzK4nLCAnzK8nLCAnzLAnLFxuICAgICAgJ8yxJywgJ8yyJywgJ8yzJywgJ8y5JyxcbiAgICAgICfMuicsICfMuycsICfMvCcsICfNhScsXG4gICAgICAnzYcnLCAnzYgnLCAnzYknLCAnzY0nLFxuICAgICAgJ82OJywgJ82TJywgJ82UJywgJ82VJyxcbiAgICAgICfNlicsICfNmScsICfNmicsICfMoydcbiAgICBdLFxuICAgIFwibWlkXCIgOiBbXG4gICAgICAnzJUnLCAnzJsnLCAnzIAnLCAnzIEnLFxuICAgICAgJ82YJywgJ8yhJywgJ8yiJywgJ8ynJyxcbiAgICAgICfMqCcsICfMtCcsICfMtScsICfMticsXG4gICAgICAnzZwnLCAnzZ0nLCAnzZ4nLFxuICAgICAgJ82fJywgJ82gJywgJ82iJywgJ8y4JyxcbiAgICAgICfMtycsICfNoScsICcg0oknXG4gICAgXVxuICB9LFxuICBhbGwgPSBbXS5jb25jYXQoc291bC51cCwgc291bC5kb3duLCBzb3VsLm1pZCksXG4gIHphbGdvID0ge307XG5cbiAgZnVuY3Rpb24gcmFuZG9tTnVtYmVyKHJhbmdlKSB7XG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZSk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBmdW5jdGlvbiBpc19jaGFyKGNoYXJhY3Rlcikge1xuICAgIHZhciBib29sID0gZmFsc2U7XG4gICAgYWxsLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgYm9vbCA9IChpID09PSBjaGFyYWN0ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBib29sO1xuICB9XG4gIFxuXG4gIGZ1bmN0aW9uIGhlQ29tZXModGV4dCwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSAnJywgY291bnRzLCBsO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnNbXCJ1cFwiXSA9ICAgdHlwZW9mIG9wdGlvbnNbXCJ1cFwiXSAgICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnNbXCJ1cFwiXSAgIDogdHJ1ZTtcbiAgICBvcHRpb25zW1wibWlkXCJdID0gIHR5cGVvZiBvcHRpb25zW1wibWlkXCJdICAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zW1wibWlkXCJdICA6IHRydWU7XG4gICAgb3B0aW9uc1tcImRvd25cIl0gPSB0eXBlb2Ygb3B0aW9uc1tcImRvd25cIl0gIT09ICd1bmRlZmluZWQnID8gb3B0aW9uc1tcImRvd25cIl0gOiB0cnVlO1xuICAgIG9wdGlvbnNbXCJzaXplXCJdID0gdHlwZW9mIG9wdGlvbnNbXCJzaXplXCJdICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnNbXCJzaXplXCJdIDogXCJtYXhpXCI7XG4gICAgdGV4dCA9IHRleHQuc3BsaXQoJycpO1xuICAgIGZvciAobCBpbiB0ZXh0KSB7XG4gICAgICBpZiAoaXNfY2hhcihsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHRleHRbbF07XG4gICAgICBjb3VudHMgPSB7XCJ1cFwiIDogMCwgXCJkb3duXCIgOiAwLCBcIm1pZFwiIDogMH07XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuc2l6ZSkge1xuICAgICAgY2FzZSAnbWluaSc6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcig4KTtcbiAgICAgICAgY291bnRzLm1pZCA9IHJhbmRvbU51bWJlcigyKTtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoOCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWF4aSc6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcigxNikgKyAzO1xuICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDQpICsgMTtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoNjQpICsgMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudHMudXAgPSByYW5kb21OdW1iZXIoOCkgKyAxO1xuICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDYpIC8gMjtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoOCkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGFyciA9IFtcInVwXCIsIFwibWlkXCIsIFwiZG93blwiXTtcbiAgICAgIGZvciAodmFyIGQgaW4gYXJyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFycltkXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDw9IGNvdW50c1tpbmRleF07IGkrKykge1xuICAgICAgICAgIGlmIChvcHRpb25zW2luZGV4XSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgc291bFtpbmRleF1bcmFuZG9tTnVtYmVyKHNvdWxbaW5kZXhdLmxlbmd0aCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIGRvbid0IHN1bW1vbiBoaW1cbiAgcmV0dXJuIGhlQ29tZXModGV4dCwgb3B0aW9ucyk7XG59XG4iLCJ2YXIgY29sb3JzID0gcmVxdWlyZSgnLi9jb2xvcnMnKTtcblxubW9kdWxlWydleHBvcnRzJ10gPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy9cbiAgLy8gRXh0ZW5kcyBwcm90b3R5cGUgb2YgbmF0aXZlIHN0cmluZyBvYmplY3QgdG8gYWxsb3cgZm9yIFwiZm9vXCIucmVkIHN5bnRheFxuICAvL1xuICB2YXIgYWRkUHJvcGVydHkgPSBmdW5jdGlvbiAoY29sb3IsIGZ1bmMpIHtcbiAgICBTdHJpbmcucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oY29sb3IsIGZ1bmMpO1xuICB9O1xuXG4gIHZhciBzZXF1ZW5jZXIgPSBmdW5jdGlvbiBzZXF1ZW5jZXIgKG1hcCwgc3RyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXhwbG9kZWQgPSB0aGlzLnNwbGl0KFwiXCIpLCBpID0gMDtcbiAgICAgICAgZXhwbG9kZWQgPSBleHBsb2RlZC5tYXAobWFwKTtcbiAgICAgICAgcmV0dXJuIGV4cGxvZGVkLmpvaW4oXCJcIik7XG4gICAgICB9XG4gIH07XG5cbiAgYWRkUHJvcGVydHkoJ3N0cmlwJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2xvcnMuc3RyaXAodGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KCdzdHJpcENvbG9ycycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29sb3JzLnN0cmlwKHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcInRyYXBcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLnRyYXAodGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwiemFsZ29cIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLnphbGdvKHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcInplYnJhXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGNvbG9ycy56ZWJyYSh0aGlzKTtcbiAgfSk7XG5cbiAgYWRkUHJvcGVydHkoXCJyYWluYm93XCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGNvbG9ycy5yYWluYm93KHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcInJhbmRvbVwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBjb2xvcnMucmFuZG9tKHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcImFtZXJpY2FcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLmFtZXJpY2EodGhpcyk7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZGVmYXVsdCBzdHlsZXMgYW5kIGNvbG9yc1xuICAvL1xuICB2YXIgeCA9IE9iamVjdC5rZXlzKGNvbG9ycy5zdHlsZXMpO1xuICB4LmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgYWRkUHJvcGVydHkoc3R5bGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb2xvcnMuc3R5bGl6ZSh0aGlzLCBzdHlsZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFwcGx5VGhlbWUodGhlbWUpIHtcbiAgICAvL1xuICAgIC8vIFJlbWFyazogVGhpcyBpcyBhIGxpc3Qgb2YgbWV0aG9kcyB0aGF0IGV4aXN0XG4gICAgLy8gb24gU3RyaW5nIHRoYXQgeW91IHNob3VsZCBub3Qgb3ZlcndyaXRlLlxuICAgIC8vXG4gICAgdmFyIHN0cmluZ1Byb3RvdHlwZUJsYWNrbGlzdCA9IFtcbiAgICAgICdfX2RlZmluZUdldHRlcl9fJywgJ19fZGVmaW5lU2V0dGVyX18nLCAnX19sb29rdXBHZXR0ZXJfXycsICdfX2xvb2t1cFNldHRlcl9fJywgJ2NoYXJBdCcsICdjb25zdHJ1Y3RvcicsXG4gICAgICAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJywgJ2NoYXJDb2RlQXQnLFxuICAgICAgJ2luZGV4T2YnLCAnbGFzdEluZGV4b2YnLCAnbGVuZ3RoJywgJ2xvY2FsZUNvbXBhcmUnLCAnbWF0Y2gnLCAncmVwbGFjZScsICdzZWFyY2gnLCAnc2xpY2UnLCAnc3BsaXQnLCAnc3Vic3RyaW5nJyxcbiAgICAgICd0b0xvY2FsZUxvd2VyQ2FzZScsICd0b0xvY2FsZVVwcGVyQ2FzZScsICd0b0xvd2VyQ2FzZScsICd0b1VwcGVyQ2FzZScsICd0cmltJywgJ3RyaW1MZWZ0JywgJ3RyaW1SaWdodCdcbiAgICBdO1xuXG4gICAgT2JqZWN0LmtleXModGhlbWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGlmIChzdHJpbmdQcm90b3R5cGVCbGFja2xpc3QuaW5kZXhPZihwcm9wKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3dhcm46ICcucmVkICsgKCdTdHJpbmcucHJvdG90eXBlJyArIHByb3ApLm1hZ2VudGEgKyAnIGlzIHByb2JhYmx5IHNvbWV0aGluZyB5b3UgZG9uXFwndCB3YW50IHRvIG92ZXJyaWRlLiBJZ25vcmluZyBzdHlsZSBuYW1lJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZih0aGVtZVtwcm9wXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29sb3JzW3Byb3BdID0gY29sb3JzW3RoZW1lW3Byb3BdXTtcbiAgICAgICAgICBhZGRQcm9wZXJ0eShwcm9wLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3JzW3RoZW1lW3Byb3BdXSh0aGlzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhZGRQcm9wZXJ0eShwcm9wLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGhlbWVbcHJvcF0ubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgcmV0ID0gZXhwb3J0c1t0aGVtZVtwcm9wXVt0XV0ocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbG9ycy5zZXRUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSkge1xuICAgIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb2xvcnMudGhlbWVzW3RoZW1lXSA9IHJlcXVpcmUodGhlbWUpO1xuICAgICAgICBhcHBseVRoZW1lKGNvbG9ycy50aGVtZXNbdGhlbWVdKTtcbiAgICAgICAgcmV0dXJuIGNvbG9ycy50aGVtZXNbdGhlbWVdO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5VGhlbWUodGhlbWUpO1xuICAgIH1cbiAgfTtcblxufTsiLCJ2YXIgY29sb3JzID0gcmVxdWlyZSgnLi9jb2xvcnMnKTtcbm1vZHVsZVsnZXhwb3J0cyddID0gY29sb3JzO1xuXG4vLyBSZW1hcms6IEJ5IGRlZmF1bHQsIGNvbG9ycyB3aWxsIGFkZCBzdHlsZSBwcm9wZXJ0aWVzIHRvIFN0cmluZy5wcm90b3R5cGVcbi8vXG4vLyBJZiB5b3UgZG9uJ3Qgd2lzaCB0byBleHRlbmQgU3RyaW5nLnByb3RvdHlwZSB5b3UgY2FuIGRvIHRoaXMgaW5zdGVhZCBhbmQgbmF0aXZlIFN0cmluZyB3aWxsIG5vdCBiZSB0b3VjaGVkXG4vL1xuLy8gICB2YXIgY29sb3JzID0gcmVxdWlyZSgnY29sb3JzL3NhZmUpO1xuLy8gICBjb2xvcnMucmVkKFwiZm9vXCIpXG4vL1xuLy9cbnJlcXVpcmUoJy4vZXh0ZW5kU3RyaW5nUHJvdG90eXBlJykoKTsiLCJ2YXIgY29sb3JzID0gcmVxdWlyZSgnLi4vY29sb3JzJyk7XG5cbm1vZHVsZVsnZXhwb3J0cyddID0gKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGxldHRlciwgaSwgZXhwbG9kZWQpIHtcbiAgICBpZihsZXR0ZXIgPT09IFwiIFwiKSByZXR1cm4gbGV0dGVyO1xuICAgIHN3aXRjaChpJTMpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGNvbG9ycy5yZWQobGV0dGVyKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGNvbG9ycy53aGl0ZShsZXR0ZXIpXG4gICAgICBjYXNlIDI6IHJldHVybiBjb2xvcnMuYmx1ZShsZXR0ZXIpXG4gICAgfVxuICB9XG59KSgpOyIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuLi9jb2xvcnMnKTtcblxubW9kdWxlWydleHBvcnRzJ10gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmFpbmJvd0NvbG9ycyA9IFsncmVkJywgJ3llbGxvdycsICdncmVlbicsICdibHVlJywgJ21hZ2VudGEnXTsgLy9Sb1kgRyBCaVZcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gICAgaWYgKGxldHRlciA9PT0gXCIgXCIpIHtcbiAgICAgIHJldHVybiBsZXR0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb2xvcnNbcmFpbmJvd0NvbG9yc1tpKysgJSByYWluYm93Q29sb3JzLmxlbmd0aF1dKGxldHRlcik7XG4gICAgfVxuICB9O1xufSkoKTtcblxuIiwidmFyIGNvbG9ycyA9IHJlcXVpcmUoJy4uL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhdmFpbGFibGUgPSBbJ3VuZGVybGluZScsICdpbnZlcnNlJywgJ2dyZXknLCAneWVsbG93JywgJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3doaXRlJywgJ2N5YW4nLCAnbWFnZW50YSddO1xuICByZXR1cm4gZnVuY3Rpb24obGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICAgIHJldHVybiBsZXR0ZXIgPT09IFwiIFwiID8gbGV0dGVyIDogY29sb3JzW2F2YWlsYWJsZVtNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAoYXZhaWxhYmxlLmxlbmd0aCAtIDEpKV1dKGxldHRlcik7XG4gIH07XG59KSgpOyIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuLi9jb2xvcnMnKTtcblxubW9kdWxlWydleHBvcnRzJ10gPSBmdW5jdGlvbiAobGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICByZXR1cm4gaSAlIDIgPT09IDAgPyBsZXR0ZXIgOiBjb2xvcnMuaW52ZXJzZShsZXR0ZXIpO1xufTsiLCIvKlxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgU2luZHJlIFNvcmh1cyA8c2luZHJlc29yaHVzQGdtYWlsLmNvbT4gKHNpbmRyZXNvcmh1cy5jb20pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuKi9cblxudmFyIHN0eWxlcyA9IHt9O1xubW9kdWxlWydleHBvcnRzJ10gPSBzdHlsZXM7XG5cbnZhciBjb2RlcyA9IHtcbiAgcmVzZXQ6IFswLCAwXSxcblxuICBib2xkOiBbMSwgMjJdLFxuICBkaW06IFsyLCAyMl0sXG4gIGl0YWxpYzogWzMsIDIzXSxcbiAgdW5kZXJsaW5lOiBbNCwgMjRdLFxuICBpbnZlcnNlOiBbNywgMjddLFxuICBoaWRkZW46IFs4LCAyOF0sXG4gIHN0cmlrZXRocm91Z2g6IFs5LCAyOV0sXG5cbiAgYmxhY2s6IFszMCwgMzldLFxuICByZWQ6IFszMSwgMzldLFxuICBncmVlbjogWzMyLCAzOV0sXG4gIHllbGxvdzogWzMzLCAzOV0sXG4gIGJsdWU6IFszNCwgMzldLFxuICBtYWdlbnRhOiBbMzUsIDM5XSxcbiAgY3lhbjogWzM2LCAzOV0sXG4gIHdoaXRlOiBbMzcsIDM5XSxcbiAgZ3JheTogWzkwLCAzOV0sXG4gIGdyZXk6IFs5MCwgMzldLFxuXG4gIGJnQmxhY2s6IFs0MCwgNDldLFxuICBiZ1JlZDogWzQxLCA0OV0sXG4gIGJnR3JlZW46IFs0MiwgNDldLFxuICBiZ1llbGxvdzogWzQzLCA0OV0sXG4gIGJnQmx1ZTogWzQ0LCA0OV0sXG4gIGJnTWFnZW50YTogWzQ1LCA0OV0sXG4gIGJnQ3lhbjogWzQ2LCA0OV0sXG4gIGJnV2hpdGU6IFs0NywgNDldLFxuXG4gIC8vIGxlZ2FjeSBzdHlsZXMgZm9yIGNvbG9ycyBwcmUgdjEuMC4wXG4gIGJsYWNrQkc6IFs0MCwgNDldLFxuICByZWRCRzogWzQxLCA0OV0sXG4gIGdyZWVuQkc6IFs0MiwgNDldLFxuICB5ZWxsb3dCRzogWzQzLCA0OV0sXG4gIGJsdWVCRzogWzQ0LCA0OV0sXG4gIG1hZ2VudGFCRzogWzQ1LCA0OV0sXG4gIGN5YW5CRzogWzQ2LCA0OV0sXG4gIHdoaXRlQkc6IFs0NywgNDldXG5cbn07XG5cbk9iamVjdC5rZXlzKGNvZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHZhbCA9IGNvZGVzW2tleV07XG4gIHZhciBzdHlsZSA9IHN0eWxlc1trZXldID0gW107XG4gIHN0eWxlLm9wZW4gPSAnXFx1MDAxYlsnICsgdmFsWzBdICsgJ20nO1xuICBzdHlsZS5jbG9zZSA9ICdcXHUwMDFiWycgKyB2YWxbMV0gKyAnbSc7XG59KTsiLCIvKlxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgU2luZHJlIFNvcmh1cyA8c2luZHJlc29yaHVzQGdtYWlsLmNvbT4gKHNpbmRyZXNvcmh1cy5jb20pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuKi9cblxudmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3Y7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3YuaW5kZXhPZignLS1uby1jb2xvcicpICE9PSAtMSB8fFxuICAgIGFyZ3YuaW5kZXhPZignLS1jb2xvcj1mYWxzZScpICE9PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcmd2LmluZGV4T2YoJy0tY29sb3InKSAhPT0gLTEgfHxcbiAgICBhcmd2LmluZGV4T2YoJy0tY29sb3I9dHJ1ZScpICE9PSAtMSB8fFxuICAgIGFyZ3YuaW5kZXhPZignLS1jb2xvcj1hbHdheXMnKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnN0ZG91dCAmJiAhcHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCdDT0xPUlRFUk0nIGluIHByb2Nlc3MuZW52KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuVEVSTSA9PT0gJ2R1bWInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8Y29sb3J8YW5zaXxjeWd3aW58bGludXgvaS50ZXN0KHByb2Nlc3MuZW52LlRFUk0pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59KSgpOyIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvLURhc2ggMi40LjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLW8gLi9kaXN0L2xvZGFzaC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUgRVM1IGVudmlyb25tZW50cyAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIHRvIHBvb2wgYXJyYXlzIGFuZCBvYmplY3RzIHVzZWQgaW50ZXJuYWxseSAqL1xuICB2YXIgYXJyYXlQb29sID0gW10sXG4gICAgICBvYmplY3RQb29sID0gW107XG5cbiAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAvKiogVXNlZCB0byBwcmVmaXgga2V5cyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBgX19wcm90b19fYCBhbmQgcHJvcGVydGllcyBvbiBgT2JqZWN0LnByb3RvdHlwZWAgKi9cbiAgdmFyIGtleVByZWZpeCA9ICtuZXcgRGF0ZSArICcnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHdoZW4gb3B0aW1pemF0aW9ucyBhcmUgZW5hYmxlZCBmb3IgbGFyZ2UgYXJyYXlzICovXG4gIHZhciBsYXJnZUFycmF5U2l6ZSA9IDc1O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXggc2l6ZSBvZiB0aGUgYGFycmF5UG9vbGAgYW5kIGBvYmplY3RQb29sYCAqL1xuICB2YXIgbWF4UG9vbFNpemUgPSA0MDtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYW5kIHRlc3Qgd2hpdGVzcGFjZSAqL1xuICB2YXIgd2hpdGVzcGFjZSA9IChcbiAgICAvLyB3aGl0ZXNwYWNlXG4gICAgJyBcXHRcXHgwQlxcZlxceEEwXFx1ZmVmZicgK1xuXG4gICAgLy8gbGluZSB0ZXJtaW5hdG9yc1xuICAgICdcXG5cXHJcXHUyMDI4XFx1MjAyOScgK1xuXG4gICAgLy8gdW5pY29kZSBjYXRlZ29yeSBcIlpzXCIgc3BhY2Ugc2VwYXJhdG9yc1xuICAgICdcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwJ1xuICApO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UgKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBFUzYgdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgKiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1saXRlcmFscy1zdHJpbmctbGl0ZXJhbHNcbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcmVnZXhwIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3RlZCBuYW1lZCBmdW5jdGlvbnMgKi9cbiAgdmFyIHJlRnVuY05hbWUgPSAvXlxccypmdW5jdGlvblsgXFxuXFxyXFx0XStcXHcvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFwiaW50ZXJwb2xhdGVcIiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlIGFuZCB6ZXJvcyB0byBiZSByZW1vdmVkICovXG4gIHZhciByZUxlYWRpbmdTcGFjZXNBbmRaZXJvcyA9IFJlZ0V4cCgnXlsnICsgd2hpdGVzcGFjZSArICddKjArKD89LiQpJyk7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZSAqL1xuICB2YXIgcmVUaGlzID0gL1xcYnRoaXNcXGIvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHRcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdGdW5jdGlvbicsICdNYXRoJywgJ051bWJlcicsICdPYmplY3QnLFxuICAgICdSZWdFeHAnLCAnU3RyaW5nJywgJ18nLCAnYXR0YWNoRXZlbnQnLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ2lzTmFOJyxcbiAgICAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5ICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAwO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgc2hvcnRjdXRzICovXG4gIHZhciBhcmdzQ2xhc3MgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5Q2xhc3MgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbENsYXNzID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgb2JqZWN0IGNsYXNzaWZpY2F0aW9ucyB0aGF0IGBfLmNsb25lYCBzdXBwb3J0cyAqL1xuICB2YXIgY2xvbmVhYmxlQ2xhc3NlcyA9IHt9O1xuICBjbG9uZWFibGVDbGFzc2VzW2Z1bmNDbGFzc10gPSBmYWxzZTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1thcmdzQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1thcnJheUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbYm9vbENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbZGF0ZUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbbnVtYmVyQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tvYmplY3RDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW3JlZ2V4cENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbc3RyaW5nQ2xhc3NdID0gdHJ1ZTtcblxuICAvKiogVXNlZCBhcyBhbiBpbnRlcm5hbCBgXy5kZWJvdW5jZWAgb3B0aW9ucyBvYmplY3QgKi9cbiAgdmFyIGRlYm91bmNlT3B0aW9ucyA9IHtcbiAgICAnbGVhZGluZyc6IGZhbHNlLFxuICAgICdtYXhXYWl0JzogMCxcbiAgICAndHJhaWxpbmcnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBgX19iaW5kRGF0YV9fYCAqL1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAnY29uZmlndXJhYmxlJzogZmFsc2UsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBudWxsLFxuICAgICd3cml0YWJsZSc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgT2JqZWN0ICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHQnOiAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AgKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YCAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzXG4gICAqIG9yIGBmcm9tSW5kZXhgIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgYF8uY29udGFpbnNgIGZvciBjYWNoZSBvYmplY3RzIHRoYXQgbWltaWNzIHRoZSByZXR1cm5cbiAgICogc2lnbmF0dXJlIG9mIGBfLmluZGV4T2ZgIGJ5IHJldHVybmluZyBgMGAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjYWNoZSA9IGNhY2hlLmNhY2hlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZVt2YWx1ZV0gPyAwIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlO1xuICAgIGNhY2hlID0gKGNhY2hlID0gY2FjaGVbdHlwZV0pICYmIGNhY2hlW2tleV07XG5cbiAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0J1xuICAgICAgPyAoY2FjaGUgJiYgYmFzZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA+IC0xID8gMCA6IC0xKVxuICAgICAgOiAoY2FjaGUgPyAwIDogLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBnaXZlbiB2YWx1ZSB0byB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIGNhY2hlW3ZhbHVlXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlLFxuICAgICAgICAgIHR5cGVDYWNoZSA9IGNhY2hlW3R5cGVdIHx8IChjYWNoZVt0eXBlXSA9IHt9KTtcblxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHR5cGVDYWNoZVtrZXldIHx8ICh0eXBlQ2FjaGVba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlQ2FjaGVba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ubWF4YCBhbmQgYF8ubWluYCBhcyB0aGUgZGVmYXVsdCBjYWxsYmFjayB3aGVuIGEgZ2l2ZW5cbiAgICogY29sbGVjdGlvbiBpcyBhIHN0cmluZyB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBjaGFyYWN0ZXIgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29kZSB1bml0IG9mIGdpdmVuIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJBdENhbGxiYWNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGBjb2xsZWN0aW9uYCBlbGVtZW50cywgc3RhYmxlIHNvcnRpbmdcbiAgICogdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYWAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIG9mIGAxYCBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhhLCBiKSB7XG4gICAgdmFyIGFjID0gYS5jcml0ZXJpYSxcbiAgICAgICAgYmMgPSBiLmNyaXRlcmlhLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhYy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYWNbaW5kZXhdLFxuICAgICAgICAgIG90aGVyID0gYmNbaW5kZXhdO1xuXG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IG90aGVyIHx8IHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IG90aGVyIHx8IHR5cGVvZiBvdGhlciA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBhYCBhbmQgYGJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vXG4gICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAvLyBTZWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTBcbiAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0IG9yIGBudWxsYCBpZiBjYWNoaW5nIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgZmlyc3QgPSBhcnJheVswXSxcbiAgICAgICAgbWlkID0gYXJyYXlbKGxlbmd0aCAvIDIpIHwgMF0sXG4gICAgICAgIGxhc3QgPSBhcnJheVtsZW5ndGggLSAxXTtcblxuICAgIGlmIChmaXJzdCAmJiB0eXBlb2YgZmlyc3QgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgbWlkICYmIHR5cGVvZiBtaWQgPT0gJ29iamVjdCcgJiYgbGFzdCAmJiB0eXBlb2YgbGFzdCA9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FjaGUgPSBnZXRPYmplY3QoKTtcbiAgICBjYWNoZVsnZmFsc2UnXSA9IGNhY2hlWydudWxsJ10gPSBjYWNoZVsndHJ1ZSddID0gY2FjaGVbJ3VuZGVmaW5lZCddID0gZmFsc2U7XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0T2JqZWN0KCk7XG4gICAgcmVzdWx0LmFycmF5ID0gYXJyYXk7XG4gICAgcmVzdWx0LmNhY2hlID0gY2FjaGU7XG4gICAgcmVzdWx0LnB1c2ggPSBjYWNoZVB1c2g7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGB0ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZFxuICAgKiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIobWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1ttYXRjaF07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhcnJheSBmcm9tIHRoZSBhcnJheSBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIGFycmF5UG9vbC5wb3AoKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBmcm9tIHRoZSBvYmplY3QgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T2JqZWN0KCkge1xuICAgIHJldHVybiBvYmplY3RQb29sLnBvcCgpIHx8IHtcbiAgICAgICdhcnJheSc6IG51bGwsXG4gICAgICAnY2FjaGUnOiBudWxsLFxuICAgICAgJ2NyaXRlcmlhJzogbnVsbCxcbiAgICAgICdmYWxzZSc6IGZhbHNlLFxuICAgICAgJ2luZGV4JzogMCxcbiAgICAgICdudWxsJzogZmFsc2UsXG4gICAgICAnbnVtYmVyJzogbnVsbCxcbiAgICAgICdvYmplY3QnOiBudWxsLFxuICAgICAgJ3B1c2gnOiBudWxsLFxuICAgICAgJ3N0cmluZyc6IG51bGwsXG4gICAgICAndHJ1ZSc6IGZhbHNlLFxuICAgICAgJ3VuZGVmaW5lZCc6IGZhbHNlLFxuICAgICAgJ3ZhbHVlJzogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIGFycmF5IGJhY2sgdG8gdGhlIGFycmF5IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlQXJyYXkoYXJyYXkpIHtcbiAgICBhcnJheS5sZW5ndGggPSAwO1xuICAgIGlmIChhcnJheVBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIGFycmF5UG9vbC5wdXNoKGFycmF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIG9iamVjdCBiYWNrIHRvIHRoZSBvYmplY3QgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VPYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGNhY2hlID0gb2JqZWN0LmNhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgcmVsZWFzZU9iamVjdChjYWNoZSk7XG4gICAgfVxuICAgIG9iamVjdC5hcnJheSA9IG9iamVjdC5jYWNoZSA9IG9iamVjdC5jcml0ZXJpYSA9IG9iamVjdC5vYmplY3QgPSBvYmplY3QubnVtYmVyID0gb2JqZWN0LnN0cmluZyA9IG9iamVjdC52YWx1ZSA9IG51bGw7XG4gICAgaWYgKG9iamVjdFBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIG9iamVjdFBvb2wucHVzaChvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljZXMgdGhlIGBjb2xsZWN0aW9uYCBmcm9tIHRoZSBgc3RhcnRgIGluZGV4IHVwIHRvLCBidXQgbm90IGluY2x1ZGluZyxcbiAgICogdGhlIGBlbmRgIGluZGV4LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiBgQXJyYXkjc2xpY2VgIHRvIHN1cHBvcnQgbm9kZSBsaXN0c1xuICAgKiBpbiBJRSA8IDkgYW5kIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICAgIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCB8fCAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgZ2l2ZW4gY29udGV4dCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAvLyBBdm9pZCBpc3N1ZXMgd2l0aCBzb21lIEVTMyBlbnZpcm9ubWVudHMgdGhhdCBhdHRlbXB0IHRvIHVzZSB2YWx1ZXMsIG5hbWVkXG4gICAgLy8gYWZ0ZXIgYnVpbHQtaW4gY29uc3RydWN0b3JzIGxpa2UgYE9iamVjdGAsIGZvciB0aGUgY3JlYXRpb24gb2YgbGl0ZXJhbHMuXG4gICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG4gICAgLy8gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTEuMS41LlxuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIE5hdGl2ZSBjb25zdHJ1Y3RvciByZWZlcmVuY2VzICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgQm9vbGVhbiA9IGNvbnRleHQuQm9vbGVhbixcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBOdW1iZXIgPSBjb250ZXh0Lk51bWJlcixcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBgQXJyYXlgIG1ldGhvZCByZWZlcmVuY2VzLlxuICAgICAqXG4gICAgICogTm9ybWFsbHkgYEFycmF5LnByb3RvdHlwZWAgd291bGQgc3VmZmljZSwgaG93ZXZlciwgdXNpbmcgYW4gYXJyYXkgbGl0ZXJhbFxuICAgICAqIGF2b2lkcyBpc3N1ZXMgaW4gTmFyd2hhbC5cbiAgICAgKi9cbiAgICB2YXIgYXJyYXlSZWYgPSBbXTtcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgbm9Db25mbGljdGAgKi9cbiAgICB2YXIgb2xkRGFzaCA9IGNvbnRleHQuXztcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGludGVybmFsIFtbQ2xhc3NdXSBvZiB2YWx1ZXMgKi9cbiAgICB2YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUgKi9cbiAgICB2YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIFN0cmluZyh0b1N0cmluZylcbiAgICAgICAgLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJylcbiAgICAgICAgLnJlcGxhY2UoL3RvU3RyaW5nfCBmb3IgW15cXF1dKy9nLCAnLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzICovXG4gICAgdmFyIGNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIGNsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIGdldFByb3RvdHlwZU9mID0gaXNOYXRpdmUoZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YpICYmIGdldFByb3RvdHlwZU9mLFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5LFxuICAgICAgICBwdXNoID0gYXJyYXlSZWYucHVzaCxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlSZWYuc3BsaWNlLFxuICAgICAgICB1bnNoaWZ0ID0gYXJyYXlSZWYudW5zaGlmdDtcblxuICAgIC8qKiBVc2VkIHRvIHNldCBtZXRhIGRhdGEgb24gZnVuY3Rpb25zICovXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSUUgOCBvbmx5IGFjY2VwdHMgRE9NIGVsZW1lbnRzXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbyA9IHt9LFxuICAgICAgICAgICAgZnVuYyA9IGlzTmF0aXZlKGZ1bmMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIGZ1bmMsXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKG8sIG8sIG8pICYmIGZ1bmM7XG4gICAgICB9IGNhdGNoKGUpIHsgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KCkpO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgZm9yIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMgKi9cbiAgICB2YXIgbmF0aXZlQ3JlYXRlID0gaXNOYXRpdmUobmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSkgJiYgbmF0aXZlQ3JlYXRlLFxuICAgICAgICBuYXRpdmVJc0FycmF5ID0gaXNOYXRpdmUobmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkpICYmIG5hdGl2ZUlzQXJyYXksXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSXNOYU4gPSBjb250ZXh0LmlzTmFOLFxuICAgICAgICBuYXRpdmVLZXlzID0gaXNOYXRpdmUobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgYSBidWlsdC1pbiBjb25zdHJ1Y3RvciBieSBbW0NsYXNzXV0gKi9cbiAgICB2YXIgY3RvckJ5Q2xhc3MgPSB7fTtcbiAgICBjdG9yQnlDbGFzc1thcnJheUNsYXNzXSA9IEFycmF5O1xuICAgIGN0b3JCeUNsYXNzW2Jvb2xDbGFzc10gPSBCb29sZWFuO1xuICAgIGN0b3JCeUNsYXNzW2RhdGVDbGFzc10gPSBEYXRlO1xuICAgIGN0b3JCeUNsYXNzW2Z1bmNDbGFzc10gPSBGdW5jdGlvbjtcbiAgICBjdG9yQnlDbGFzc1tvYmplY3RDbGFzc10gPSBPYmplY3Q7XG4gICAgY3RvckJ5Q2xhc3NbbnVtYmVyQ2xhc3NdID0gTnVtYmVyO1xuICAgIGN0b3JCeUNsYXNzW3JlZ2V4cENsYXNzXSA9IFJlZ0V4cDtcbiAgICBjdG9yQnlDbGFzc1tzdHJpbmdDbGFzc10gPSBTdHJpbmc7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHRvIGVuYWJsZSBpbnR1aXRpdmVcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBMby1EYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGFsc28gaGF2ZSB0aGUgZm9sbG93aW5nIGBBcnJheWAgbWV0aG9kczpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCwgYHNwbGljZWAsXG4gICAgICogYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYHZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFzc2lnbmAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjaGFpbmAsIGBjb21wYWN0YCxcbiAgICAgKiBgY29tcG9zZWAsIGBjb25jYXRgLCBgY291bnRCeWAsIGBjcmVhdGVgLCBgY3JlYXRlQ2FsbGJhY2tgLCBgY3VycnlgLFxuICAgICAqIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZlcmAsIGBkZWxheWAsIGBkaWZmZXJlbmNlYCwgYGZpbHRlcmAsIGBmbGF0dGVuYCxcbiAgICAgKiBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLFxuICAgICAqIGBmdW5jdGlvbnNgLCBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsXG4gICAgICogYGludm9rZWAsIGBrZXlzYCwgYG1hcGAsIGBtYXhgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtaW5gLCBgb2JqZWN0YCwgYG9taXRgLFxuICAgICAqIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBpY2tgLCBgcGx1Y2tgLCBgcHVsbGAsIGBwdXNoYCxcbiAgICAgKiBgcmFuZ2VgLCBgcmVqZWN0YCwgYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2h1ZmZsZWAsIGBzbGljZWAsIGBzb3J0YCxcbiAgICAgKiBgc29ydEJ5YCwgYHNwbGljZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0cmFuc2Zvcm1gLFxuICAgICAqIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdmFsdWVzYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsXG4gICAgICogYW5kIGB6aXBgXG4gICAgICpcbiAgICAgKiBUaGUgbm9uLWNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGNsb25lYCwgYGNsb25lRGVlcGAsIGBjb250YWluc2AsIGBlc2NhcGVgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLFxuICAgICAqIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgaGFzYCwgYGlkZW50aXR5YCxcbiAgICAgKiBgaW5kZXhPZmAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICAgKiBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNOYU5gLCBgaXNOdWxsYCwgYGlzTnVtYmVyYCxcbiAgICAgKiBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBqb2luYCxcbiAgICAgKiBgbGFzdEluZGV4T2ZgLCBgbWl4aW5gLCBgbm9Db25mbGljdGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG4gICAgICogYHJlZHVjZVJpZ2h0YCwgYHJlc3VsdGAsIGBzaGlmdGAsIGBzaXplYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgcnVuSW5Db250ZXh0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBhbmQgYHZhbHVlYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgZnVuY3Rpb25zIGBmaXJzdGAgYW5kIGBsYXN0YCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBgbmAgaXNcbiAgICAgKiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRoZXkgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbmluZyBjYW4gYmUgZW5hYmxlZCBieSB1c2luZyB0aGUgYF8uY2hhaW5gIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAqIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgLy8gZG9uJ3Qgd3JhcCBpZiBhbHJlYWR5IHdyYXBwZWQsIGV2ZW4gaWYgd3JhcHBlZCBieSBhIGRpZmZlcmVudCBgbG9kYXNoYCBjb25zdHJ1Y3RvclxuICAgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKVxuICAgICAgID8gdmFsdWVcbiAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZhc3QgcGF0aCBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGFpbkFsbCBBIGZsYWcgdG8gZW5hYmxlIGNoYWluaW5nIGZvciBhbGwgbWV0aG9kc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYG5ldyBsb2Rhc2hXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgbG9kYXNoYFxuICAgIGxvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gbG9kYXNoLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGZsYWcgZW52aXJvbm1lbnRzIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAgICogKGFsbCBidXQgUFMzIGFuZCBvbGRlciBPcGVyYSBtb2JpbGUgYnJvd3NlcnMgJiBhdm9pZGVkIGluIFdpbmRvd3MgOCBhcHBzKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jRGVjb21wID0gIWlzTmF0aXZlKGNvbnRleHQuV2luUlRFcnJvcikgJiYgcmVUaGlzLnRlc3QocnVuSW5Db250ZXh0KTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgRnVuY3Rpb24jbmFtZWAgaXMgc3VwcG9ydGVkIChhbGwgYnV0IElFKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jTmFtZXMgPSB0eXBlb2YgRnVuY3Rpb24ubmFtZSA9PSAnc3RyaW5nJztcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgTG8tRGFzaCBhcmUgc2ltaWxhciB0byB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZVxuICAgICAqIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IC88JS0oW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYmluZGAgdGhhdCBjcmVhdGVzIHRoZSBib3VuZCBmdW5jdGlvbiBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUJpbmQoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgcGFydGlhbEFyZ3MgPSBiaW5kRGF0YVsyXSxcbiAgICAgICAgICB0aGlzQXJnID0gYmluZERhdGFbNF07XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAvLyBgRnVuY3Rpb24jYmluZGAgc3BlY1xuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC41XG4gICAgICAgIGlmIChwYXJ0aWFsQXJncykge1xuICAgICAgICAgIC8vIGF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCBkZW9wdGltaXphdGlvbnMgYnkgdXNpbmcgYHNsaWNlYCBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgYEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsYCBhbmQgbm90IGFzc2lnbmluZyBgYXJndW1lbnRzYCB0byBhXG4gICAgICAgICAgLy8gdmFyaWFibGUgYXMgYSB0ZXJuYXJ5IGV4cHJlc3Npb25cbiAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlKHBhcnRpYWxBcmdzKTtcbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3JcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMy4yLjJcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgIC8vIGVuc3VyZSBgbmV3IGJvdW5kYCBpcyBhbiBpbnN0YW5jZSBvZiBgZnVuY2BcbiAgICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXA9ZmFsc2VdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGluc3BlY3QgW1tDbGFzc11dXG4gICAgICB2YXIgaXNPYmogPSBpc09iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICBpZiAoIWNsb25lYWJsZUNsYXNzZXNbY2xhc3NOYW1lXSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3RvciA9IGN0b3JCeUNsYXNzW2NsYXNzTmFtZV07XG4gICAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IoK3ZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3Rvcih2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICAgICAgcmVzdWx0ID0gY3Rvcih2YWx1ZS5zb3VyY2UsIHJlRmxhZ3MuZXhlYyh2YWx1ZSkpO1xuICAgICAgICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHZhbHVlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGNvcnJlc3BvbmRpbmcgY2xvbmVcbiAgICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBnZXRBcnJheSgpKTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGlzQXJyID8gY3Rvcih2YWx1ZS5sZW5ndGgpIDoge307XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBzbGljZSh2YWx1ZSkgOiBhc3NpZ24oe30sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2BcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2luZGV4JykpIHtcbiAgICAgICAgICByZXN1bHQuaW5kZXggPSB2YWx1ZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2lucHV0JykpIHtcbiAgICAgICAgICByZXN1bHQuaW5wdXQgPSB2YWx1ZS5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXhpdCBmb3Igc2hhbGxvdyBjbG9uZVxuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgLy8gYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZVxuICAgICAgc3RhY2tBLnB1c2godmFsdWUpO1xuICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgICAgLy8gcmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgKGlzQXJyID8gZm9yRWFjaCA6IGZvck93bikodmFsdWUsIGZ1bmN0aW9uKG9ialZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlQ2xvbmUob2JqVmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvdHlwZSkgPyBuYXRpdmVDcmVhdGUocHJvdG90eXBlKSA6IHt9O1xuICAgIH1cbiAgICAvLyBmYWxsYmFjayBmb3IgYnJvd3NlcnMgd2l0aG91dCBgT2JqZWN0LmNyZWF0ZWBcbiAgICBpZiAoIW5hdGl2ZUNyZWF0ZSkge1xuICAgICAgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gT2JqZWN0KCkge31cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICAgIGlmIChpc09iamVjdChwcm90b3R5cGUpKSB7XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3Q7XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBjb250ZXh0Lk9iamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgfSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVDYWxsYmFja2Agd2l0aG91dCBzdXBwb3J0IGZvciBjcmVhdGluZ1xuICAgICAqIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBubyBgdGhpc0FyZ2Agb3IgYWxyZWFkeSBib3VuZCBieSBgRnVuY3Rpb24jYmluZGBcbiAgICAgIGlmICh0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyB8fCAhKCdwcm90b3R5cGUnIGluIGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgdmFyIGJpbmREYXRhID0gZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAodHlwZW9mIGJpbmREYXRhID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgIGJpbmREYXRhID0gIWZ1bmMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kRGF0YSA9IGJpbmREYXRhIHx8ICFzdXBwb3J0LmZ1bmNEZWNvbXA7XG4gICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gZm5Ub1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICAgIGlmICghc3VwcG9ydC5mdW5jTmFtZXMpIHtcbiAgICAgICAgICAgIGJpbmREYXRhID0gIXJlRnVuY05hbWUudGVzdChzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWJpbmREYXRhKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgaWYgYGZ1bmNgIHJlZmVyZW5jZXMgdGhlIGB0aGlzYCBrZXl3b3JkIGFuZCBzdG9yZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgYmluZERhdGEgPSByZVRoaXMudGVzdChzb3VyY2UpO1xuICAgICAgICAgICAgc2V0QmluZERhdGEoZnVuYywgYmluZERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gYHRoaXNgIHJlZmVyZW5jZXMgb3IgYGZ1bmNgIGlzIGJvdW5kXG4gICAgICBpZiAoYmluZERhdGEgPT09IGZhbHNlIHx8IChiaW5kRGF0YSAhPT0gdHJ1ZSAmJiBiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhLCBiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5kKGZ1bmMsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBjcmVhdGVXcmFwcGVyYCB0aGF0IGNyZWF0ZXMgdGhlIHdyYXBwZXIgYW5kXG4gICAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGVXcmFwcGVyKGJpbmREYXRhKSB7XG4gICAgICB2YXIgZnVuYyA9IGJpbmREYXRhWzBdLFxuICAgICAgICAgIGJpdG1hc2sgPSBiaW5kRGF0YVsxXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHBhcnRpYWxSaWdodEFyZ3MgPSBiaW5kRGF0YVszXSxcbiAgICAgICAgICB0aGlzQXJnID0gYmluZERhdGFbNF0sXG4gICAgICAgICAgYXJpdHkgPSBiaW5kRGF0YVs1XTtcblxuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBrZXkgPSBmdW5jO1xuXG4gICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXM7XG4gICAgICAgIGlmIChwYXJ0aWFsQXJncykge1xuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbFJpZ2h0QXJncyB8fCBpc0N1cnJ5KSB7XG4gICAgICAgICAgYXJncyB8fCAoYXJncyA9IHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzKSB7XG4gICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDdXJyeSAmJiBhcmdzLmxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICBiaXRtYXNrIHw9IDE2ICYgfjMyO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVXcmFwcGVyKFtmdW5jLCAoaXNDdXJyeUJvdW5kID8gYml0bWFzayA6IGJpdG1hc2sgJiB+MyksIGFyZ3MsIG51bGwsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoaXNCaW5kS2V5KSB7XG4gICAgICAgICAgZnVuYyA9IHRoaXNCaW5kaW5nW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kaWZmZXJlbmNlYCB0aGF0IGFjY2VwdHMgYSBzaW5nbGUgYXJyYXlcbiAgICAgKiBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5IG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgaXNMYXJnZSA9IGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUodmFsdWVzKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlT2JqZWN0KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NoYWxsb3c9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMgYW5kIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBpc1N0cmljdCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcidcbiAgICAgICAgICAgICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VGbGF0dGVuKHZhbHVlLCBpc1NoYWxsb3csIGlzU3RyaWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbEluZGV4ID0gLTEsXG4gICAgICAgICAgICAgIHZhbExlbmd0aCA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgcmVzSW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgICAgcmVzdWx0Lmxlbmd0aCArPSB2YWxMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsrdmFsSW5kZXggPCB2YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlW3ZhbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgLCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzQXJnYCBiaW5kaW5nLFxuICAgICAqIHRoYXQgYWxsb3dzIHBhcnRpYWwgXCJfLndoZXJlXCIgc3R5bGUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2lzV2hlcmU9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgYWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBiYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAvLyB1c2VkIHRvIGluZGljYXRlIHRoYXQgd2hlbiBjb21wYXJpbmcgb2JqZWN0cywgYGFgIGhhcyBhdCBsZWFzdCB0aGUgcHJvcGVydGllcyBvZiBgYmBcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soYSwgYik7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzXG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAvLyB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgICByZXR1cm4gYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYSxcbiAgICAgICAgICBvdGhlclR5cGUgPSB0eXBlb2YgYjtcblxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgdW5saWtlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBhICYmXG4gICAgICAgICAgIShhICYmIG9iamVjdFR5cGVzW3R5cGVdKSAmJlxuICAgICAgICAgICEoYiAmJiBvYmplY3RUeXBlc1tvdGhlclR5cGVdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGF2b2lkaW5nIEVTMydzIEZ1bmN0aW9uI2NhbGwgYmVoYXZpb3JcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjRcbiAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgfVxuICAgICAgLy8gY29tcGFyZSBbW0NsYXNzXV0gbmFtZXNcbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpLFxuICAgICAgICAgIG90aGVyQ2xhc3MgPSB0b1N0cmluZy5jYWxsKGIpO1xuXG4gICAgICBpZiAoY2xhc3NOYW1lID09IGFyZ3NDbGFzcykge1xuICAgICAgICBjbGFzc05hbWUgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlckNsYXNzID09IGFyZ3NDbGFzcykge1xuICAgICAgICBvdGhlckNsYXNzID0gb2JqZWN0Q2xhc3M7XG4gICAgICB9XG4gICAgICBpZiAoY2xhc3NOYW1lICE9IG90aGVyQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbFxuICAgICAgICAgIHJldHVybiArYSA9PSArYjtcblxuICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICAgIC8vIHRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbFxuICAgICAgICAgIHJldHVybiAoYSAhPSArYSlcbiAgICAgICAgICAgID8gYiAhPSArYlxuICAgICAgICAgICAgLy8gYnV0IHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgICA6IChhID09IDAgPyAoMSAvIGEgPT0gMSAvIGIpIDogYSA9PSArYik7XG5cbiAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICAvLyBjb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNClcbiAgICAgICAgICAvLyB0cmVhdCBzdHJpbmcgcHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3QgaW5zdGFuY2VzIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gY2xhc3NOYW1lID09IGFycmF5Q2xhc3M7XG4gICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgIC8vIHVud3JhcCBhbnkgYGxvZGFzaGAgd3JhcHBlZCB2YWx1ZXNcbiAgICAgICAgdmFyIGFXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIGJXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChiLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAoYVdyYXBwZWQgfHwgYldyYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYVdyYXBwZWQgPyBhLl9fd3JhcHBlZF9fIDogYSwgYldyYXBwZWQgPyBiLl9fd3JhcHBlZF9fIDogYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleGl0IGZvciBmdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9IG9iamVjdENsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIE9wZXJhLCBgYXJndW1lbnRzYCBvYmplY3RzIGhhdmUgYEFycmF5YCBjb25zdHJ1Y3RvcnNcbiAgICAgICAgdmFyIGN0b3JBID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIGN0b3JCID0gYi5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBub24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbFxuICAgICAgICBpZiAoY3RvckEgIT0gY3RvckIgJiZcbiAgICAgICAgICAgICAgIShpc0Z1bmN0aW9uKGN0b3JBKSAmJiBjdG9yQSBpbnN0YW5jZW9mIGN0b3JBICYmIGlzRnVuY3Rpb24oY3RvckIpICYmIGN0b3JCIGluc3RhbmNlb2YgY3RvckIpICYmXG4gICAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhc3N1bWUgY3ljbGljIHN0cnVjdHVyZXMgYXJlIGVxdWFsXG4gICAgICAvLyB0aGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMVxuICAgICAgLy8gc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYCAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMi4zKVxuICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gYSkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAvLyBhZGQgYGFgIGFuZCBgYmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICBzdGFja0EucHVzaChhKTtcbiAgICAgIHN0YWNrQi5wdXNoKGIpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgLy8gY29tcGFyZSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnlcbiAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIHNpemUgPSBiLmxlbmd0aDtcbiAgICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBsZW5ndGg7XG5cbiAgICAgICAgaWYgKHJlc3VsdCB8fCBpc1doZXJlKSB7XG4gICAgICAgICAgLy8gZGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllc1xuICAgICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJbc2l6ZV07XG5cbiAgICAgICAgICAgIGlmIChpc1doZXJlKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgPSBiYXNlSXNFcXVhbChhW2luZGV4XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShyZXN1bHQgPSBiYXNlSXNFcXVhbChhW3NpemVdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gZGVlcCBjb21wYXJlIG9iamVjdHMgdXNpbmcgYGZvckluYCwgaW5zdGVhZCBvZiBgZm9yT3duYCwgdG8gYXZvaWQgYE9iamVjdC5rZXlzYFxuICAgICAgICAvLyB3aGljaCwgaW4gdGhpcyBjYXNlLCBpcyBtb3JlIGNvc3RseVxuICAgICAgICBmb3JJbihiLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBiKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSkge1xuICAgICAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgLy8gZGVlcCBjb21wYXJlIGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSAmJiBiYXNlSXNFcXVhbChhW2tleV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgYm90aCBvYmplY3RzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcbiAgICAgICAgICBmb3JJbihhLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBhKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIGBzaXplYCB3aWxsIGJlIGAtMWAgaWYgYGFgIGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBgYmBcbiAgICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAtLXNpemUgPiAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrQS5wb3AoKTtcbiAgICAgIHN0YWNrQi5wb3AoKTtcblxuICAgICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgYXJndW1lbnQganVnZ2xpbmcgb3Igc3VwcG9ydFxuICAgICAqIGZvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgKGlzQXJyYXkoc291cmNlKSA/IGZvckVhY2ggOiBmb3JPd24pKHNvdXJjZSwgZnVuY3Rpb24oc291cmNlLCBrZXkpIHtcbiAgICAgICAgdmFyIGZvdW5kLFxuICAgICAgICAgICAgaXNBcnIsXG4gICAgICAgICAgICByZXN1bHQgPSBzb3VyY2UsXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmIChzb3VyY2UgJiYgKChpc0FyciA9IGlzQXJyYXkoc291cmNlKSkgfHwgaXNQbGFpbk9iamVjdChzb3VyY2UpKSkge1xuICAgICAgICAgIC8vIGF2b2lkIG1lcmdpbmcgcHJldmlvdXNseSBtZXJnZWQgY3ljbGljIHNvdXJjZXNcbiAgICAgICAgICB2YXIgc3RhY2tMZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdGFja0xlbmd0aC0tKSB7XG4gICAgICAgICAgICBpZiAoKGZvdW5kID0gc3RhY2tBW3N0YWNrTGVuZ3RoXSA9PSBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc3RhY2tCW3N0YWNrTGVuZ3RoXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHZhciBpc1NoYWxsb3c7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgICAgICAgIGlmICgoaXNTaGFsbG93ID0gdHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBpc0FyclxuICAgICAgICAgICAgICAgID8gKGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSlcbiAgICAgICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGBzb3VyY2VgIGFuZCBhc3NvY2lhdGVkIGB2YWx1ZWAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAgICAgICBzdGFja0EucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgc3RhY2tCLnB1c2godmFsdWUpO1xuXG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgICAgYmFzZU1lcmdlKHZhbHVlLCBzb3VyY2UsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIHJldHVybmluZyBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArIGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB2YXIgaXNMYXJnZSA9ICFpc1NvcnRlZCAmJiBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgc2VlbiA9IChjYWxsYmFjayB8fCBpc0xhcmdlKSA/IGdldEFycmF5KCkgOiByZXN1bHQ7XG5cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNyZWF0ZUNhY2hlKHNlZW4pO1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBzZWVuID0gY2FjaGU7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNTb3J0ZWRcbiAgICAgICAgICAgICAgPyAhaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSBjb21wdXRlZFxuICAgICAgICAgICAgICA6IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQpIDwgMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHNlZW4uYXJyYXkpO1xuICAgICAgICByZWxlYXNlT2JqZWN0KHNlZW4pO1xuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYSBjb2xsZWN0aW9uLCBjcmVhdGluZyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogdGhyb3VnaCBhIGNhbGxiYWNrLiBUaGUgZ2l2ZW4gYHNldHRlcmAgZnVuY3Rpb24gc2V0cyB0aGUga2V5cyBhbmQgdmFsdWVzXG4gICAgICogb2YgdGhlIGNvbXBvc2VkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBzZXR0ZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYFxuICAgICAqIHdpdGggYW4gb3B0aW9uYWwgYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBtZXRob2QgZmxhZ3MgdG8gY29tcG9zZS5cbiAgICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAgICogIDEgLSBgXy5iaW5kYFxuICAgICAqICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgNCAtIGBfLmN1cnJ5YFxuICAgICAqICA4IC0gYF8uY3VycnlgIChib3VuZClcbiAgICAgKiAgMTYgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAzMiAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlXG4gICAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxSaWdodEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCBwYXJ0aWFsQXJncywgcGFydGlhbFJpZ2h0QXJncywgdGhpc0FyZywgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgMixcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIDQsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgICAgaXNQYXJ0aWFsID0gYml0bWFzayAmIDE2LFxuICAgICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gYml0bWFzayAmIDMyO1xuXG4gICAgICBpZiAoIWlzQmluZEtleSAmJiAhaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbCAmJiAhcGFydGlhbEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjE2O1xuICAgICAgICBpc1BhcnRpYWwgPSBwYXJ0aWFsQXJncyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0ICYmICFwYXJ0aWFsUmlnaHRBcmdzLmxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4zMjtcbiAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHRBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jICYmIGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgICAgaWYgKGJpbmREYXRhICYmIGJpbmREYXRhICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIGNsb25lIGBiaW5kRGF0YWBcbiAgICAgICAgYmluZERhdGEgPSBzbGljZShiaW5kRGF0YSk7XG4gICAgICAgIGlmIChiaW5kRGF0YVsyXSkge1xuICAgICAgICAgIGJpbmREYXRhWzJdID0gc2xpY2UoYmluZERhdGFbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5kRGF0YVszXSkge1xuICAgICAgICAgIGJpbmREYXRhWzNdID0gc2xpY2UoYmluZERhdGFbM10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBgdGhpc0JpbmRpbmdgIGlzIG5vdCBwcmV2aW91c2x5IGJvdW5kXG4gICAgICAgIGlmIChpc0JpbmQgJiYgIShiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICAgICAgYmluZERhdGFbNF0gPSB0aGlzQXJnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBpZiBwcmV2aW91c2x5IGJvdW5kIGJ1dCBub3QgY3VycmVudGx5IChzdWJzZXF1ZW50IGN1cnJpZWQgZnVuY3Rpb25zKVxuICAgICAgICBpZiAoIWlzQmluZCAmJiBiaW5kRGF0YVsxXSAmIDEpIHtcbiAgICAgICAgICBiaXRtYXNrIHw9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGN1cnJpZWQgYXJpdHkgaWYgbm90IHlldCBzZXRcbiAgICAgICAgaWYgKGlzQ3VycnkgJiYgIShiaW5kRGF0YVsxXSAmIDQpKSB7XG4gICAgICAgICAgYmluZERhdGFbNV0gPSBhcml0eTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgcGFydGlhbCBsZWZ0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgcHVzaC5hcHBseShiaW5kRGF0YVsyXSB8fCAoYmluZERhdGFbMl0gPSBbXSksIHBhcnRpYWxBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgcGFydGlhbCByaWdodCBhcmd1bWVudHNcbiAgICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0KSB7XG4gICAgICAgICAgdW5zaGlmdC5hcHBseShiaW5kRGF0YVszXSB8fCAoYmluZERhdGFbM10gPSBbXSksIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGZsYWdzXG4gICAgICAgIGJpbmREYXRhWzFdIHw9IGJpdG1hc2s7XG4gICAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyLmFwcGx5KG51bGwsIGJpbmREYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIGZhc3QgcGF0aCBmb3IgYF8uYmluZGBcbiAgICAgIHZhciBjcmVhdGVyID0gKGJpdG1hc2sgPT0gMSB8fCBiaXRtYXNrID09PSAxNykgPyBiYXNlQmluZCA6IGJhc2VDcmVhdGVXcmFwcGVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZXIoW2Z1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYGVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gaHRtbEVzY2FwZXNbbWF0Y2hdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uaW5kZXhPZmAgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VJbmRleE9mYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBcImluZGV4T2ZcIiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9mKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IChyZXN1bHQgPSBsb2Rhc2guaW5kZXhPZikgPT09IGluZGV4T2YgPyBiYXNlSW5kZXhPZiA6IHJlc3VsdDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgcmVOYXRpdmUudGVzdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgdGhpc2AgYmluZGluZyBkYXRhIG9uIGEgZ2l2ZW4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNldCBkYXRhIG9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIFRoZSBkYXRhIGFycmF5IHRvIHNldC5cbiAgICAgKi9cbiAgICB2YXIgc2V0QmluZERhdGEgPSAhZGVmaW5lUHJvcGVydHkgPyBub29wIDogZnVuY3Rpb24oZnVuYywgdmFsdWUpIHtcbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGRlZmluZVByb3BlcnR5KGZ1bmMsICdfX2JpbmREYXRhX18nLCBkZXNjcmlwdG9yKTtcbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBpc1BsYWluT2JqZWN0YCB3aGljaCBjaGVja3MgaWYgYSBnaXZlbiB2YWx1ZVxuICAgICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciwgYXNzdW1pbmcgb2JqZWN0cyBjcmVhdGVkXG4gICAgICogYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhhdFxuICAgICAqIHRoZXJlIGFyZSBubyBgT2JqZWN0LnByb3RvdHlwZWAgZXh0ZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIGN0b3IsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAvLyBhdm9pZCBub24gT2JqZWN0IG9iamVjdHMsIGBhcmd1bWVudHNgIG9iamVjdHMsIGFuZCBET00gZWxlbWVudHNcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSB8fFxuICAgICAgICAgIChjdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIGlzRnVuY3Rpb24oY3RvcikgJiYgIShjdG9yIGluc3RhbmNlb2YgY3RvcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sVW5lc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBwcm9kdWNlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgdmFyIHNoaW1LZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtleXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWydvbmUnLCAndHdvJywgJ3RocmVlJ10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllczpcbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgYD5gIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlIGA+YCBhbmQgYC9gXG4gICAgICogZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZyB1bmxlc3MgdGhleSdyZSBwYXJ0XG4gICAgICogb2YgYSB0YWcgb3IgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKVxuICAgICAqL1xuICAgIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiMzOTsnXG4gICAgfTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzICovXG4gICAgdmFyIGh0bWxVbmVzY2FwZXMgPSBpbnZlcnQoaHRtbEVzY2FwZXMpO1xuXG4gICAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzICovXG4gICAgdmFyIHJlRXNjYXBlZEh0bWwgPSBSZWdFeHAoJygnICsga2V5cyhodG1sVW5lc2NhcGVzKS5qb2luKCd8JykgKyAnKScsICdnJyksXG4gICAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cCgnWycgKyBrZXlzKGh0bWxFc2NhcGVzKS5qb2luKCcnKSArICddJywgJ2cnKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICAgKiBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiBhc3NpZ25lZCB2YWx1ZXMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ25hbWUnOiAnZnJlZCcgfSwgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgYSA9PSAndW5kZWZpbmVkJyA/IGIgOiBhO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIGRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIGlmIChhcmdzTGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWFyZ3NMZW5ndGggLSAxXSwgYXJnc1thcmdzTGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tYXJnc0xlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayA/IGNhbGxiYWNrKHJlc3VsdFtpbmRleF0sIGl0ZXJhYmxlW2luZGV4XSkgOiBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIHdpbGwgYWxzb1xuICAgICAqIGJlIGNsb25lZCwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBiZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKGNoYXJhY3RlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKGNoYXJhY3RlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oe1xuICAgICAqICAgJ2Nsb25lJzogXy5wYXJ0aWFsUmlnaHQoXy5jbG9uZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICogICB9KVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZShkb2N1bWVudC5ib2R5KTtcbiAgICAgKiBjbG9uZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgXG4gICAgICAvLyBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50cyBmb3IgYGlzRGVlcGAgYW5kIGBjYWxsYmFja2BcbiAgICAgIGlmICh0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0RlZXAgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlXG4gICAgICogZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIHN0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtLiBGdW5jdGlvbnNcbiAgICAgKiBhbmQgRE9NIG5vZGVzIGFyZSAqKm5vdCoqIGNsb25lZC4gVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZFxuICAgICAqIG9iamVjdHMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAoY2hhcmFjdGVycyk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnbm9kZSc6IGVsZW1lbnRcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZURlZXAodmlldywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjbG9uZS5ub2RlID09IHZpZXcubm9kZTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwgeyAnY29uc3RydWN0b3InOiBDaXJjbGUgfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgZGVmYXVsdHMgb2YgdGhlIHNhbWUgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgd2l0aG91dCB1c2luZyBpdHNcbiAgICAgKiAgYGtleWAgYW5kIGBvYmplY3RgIGFyZ3VtZW50cyBhcyBzb3VyY2VzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIF8uZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2luZGV4XSA9PSAndW5kZWZpbmVkJykgcmVzdWx0W2luZGV4XSA9IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zIGBwZWJibGVzYCwgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyBgYmFybmV5YFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duUmlnaHQob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LFxuICAgICAqIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ21vdmUnLCAneScsIGFuZCAneCcgYXNzdW1pbmcgYF8uZm9ySW4gYCBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcblxuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHBhaXJzLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2socGFpcnNbbGVuZ3RoLS1dLCBwYWlyc1tsZW5ndGhdLCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQoeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbGVuZ3RoJywgJzEnLCBhbmQgJzAnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUgZXhpc3RzIGFzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLFxuICAgICAqIGluc3RlYWQgb2YgYW4gaW5oZXJpdGVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYga2V5IGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGFzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCAnYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZlcnQoeyAnZmlyc3QnOiAnZnJlZCcsICdzZWNvbmQnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogJ2ZpcnN0JywgJ2Jhcm5leSc6ICdzZWNvbmQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtvYmplY3Rba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZGF0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBcnJheXMsIHN0cmluZ3MsIG9yIGBhcmd1bWVudHNgIG9iamVjdHMgd2l0aCBhXG4gICAgICogbGVuZ3RoIG9mIGAwYCBhbmQgb2JqZWN0cyB3aXRoIG5vIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvbnNpZGVyZWRcbiAgICAgKiBcImVtcHR5XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgnJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgaWYgKChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcyB8fCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IGFyZ3NDbGFzcyApIHx8XG4gICAgICAgICAgKGNsYXNzTmFtZSA9PSBvYmplY3RDbGFzcyAmJiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3JPd24odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudCB0byBlYWNoIG90aGVyLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiB0byBjb21wYXJlIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAoYSwgYikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgY29weSA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBjb3B5O1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBjb3B5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgd29yZHMgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXJXb3JkcyA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKHdvcmRzLCBvdGhlcldvcmRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICB2YXIgcmVHcmVldCA9IC9eKD86aGVsbG98aGkpJC9pLFxuICAgICAqICAgICAgIGFHcmVldCA9IF8uaXNTdHJpbmcoYSkgJiYgcmVHcmVldC50ZXN0KGEpLFxuICAgICAqICAgICAgIGJHcmVldCA9IF8uaXNTdHJpbmcoYikgJiYgcmVHcmVldC50ZXN0KGIpO1xuICAgICAqXG4gICAgICogICByZXR1cm4gKGFHcmVldCB8fCBiR3JlZXQpID8gKGFHcmVldCA9PSBiR3JlZXQpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYSwgYiwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMsIG9yIGNhbiBiZSBjb2VyY2VkIHRvLCBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzRmluaXRlYCB3aGljaCB3aWxsIHJldHVybiB0cnVlIGZvclxuICAgICAqIGJvb2xlYW5zIGFuZCBlbXB0eSBzdHJpbmdzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGZpbml0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKC0xMDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSkgJiYgIW5hdGl2ZUlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3QuXG4gICAgICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDhcbiAgICAgIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MVxuICAgICAgcmV0dXJuICEhKHZhbHVlICYmIG9iamVjdFR5cGVzW3R5cGVvZiB2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc05hTmAgd2hpY2ggd2lsbCByZXR1cm4gYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBgTmFOYCBhcyBhIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGZcbiAgICAgIC8vIChwZXJmb3JtIHRoZSBbW0NsYXNzXV0gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUpXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogYE5hTmAgaXMgY29uc2lkZXJlZCBhIG51bWJlci4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OC41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQgKiA1KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlckNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IFNoYXBlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gICAgICByZXR1cm4gb2JqUHJvdG9cbiAgICAgICAgPyAodmFsdWUgPT0gb2JqUHJvdG8gfHwgZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvKVxuICAgICAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9mcmVkLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdmFsdWVzIG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogM30gLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXBWYWx1ZXMoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uXG4gICAgICogYW5kIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbmFtZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdiYXJuZXknIH0sXG4gICAgICogICAgIHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYWdlcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICdhZ2UnOiAzNiB9LFxuICAgICAqICAgICB7ICdhZ2UnOiA0MCB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UobmFtZXMsIGFnZXMpO1xuICAgICAqIC8vID0+IHsgJ2NoYXJhY3RlcnMnOiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAgICAgKlxuICAgICAqIHZhciBmb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYXBwbGUnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyRm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UoZm9vZCwgb3RoZXJGb29kLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gXy5pc0FycmF5KGEpID8gYS5jb25jYXQoYikgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90XSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2Uob2JqZWN0KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSAyO1xuXG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSAhPSAnbnVtYmVyJykge1xuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1sZW5ndGggLSAxXSwgYXJnc1tsZW5ndGgtLV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHZhciBzb3VyY2VzID0gc2xpY2UoYXJndW1lbnRzLCAxLCBsZW5ndGgpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgc3RhY2tBID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBzdGFja0IgPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2VzW2luZGV4XSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGV4Y2x1ZGluZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgb21pdHRpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIHByb3BlcnRpZXMgdG8gb21pdCBvciB0aGVcbiAgICAgKiAgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aG91dCB0aGUgb21pdHRlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ub21pdCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcic7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHByb3BzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzID0gYmFzZURpZmZlcmVuY2UocHJvcHMsIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIGFuIG9iamVjdCdzIGtleS12YWx1ZSBwYWlycyxcbiAgICAgKiBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhaXJzKHsgJ2Jhcm5leSc6IDM2LCAnZnJlZCc6IDQwIH0pO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBjb21wb3NlZCBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgcGlja2luZyB0aGUgcHJvcGVydGllcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleVxuICAgICAqIGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLnN0cmluZ3xzdHJpbmdbXX0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCAnbmFtZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5LmNoYXJBdCgwKSAhPSAnXyc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgICAgbGVuZ3RoID0gaXNPYmplY3Qob2JqZWN0KSA/IHByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWAgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgdGhyb3VnaCBhIGNhbGxiYWNrLCB3aXRoIGVhY2ggY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzcXVhcmVzID0gXy50cmFuc2Zvcm0oWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXSwgZnVuY3Rpb24ocmVzdWx0LCBudW0pIHtcbiAgICAgKiAgIG51bSAqPSBudW07XG4gICAgICogICBpZiAobnVtICUgMikge1xuICAgICAqICAgICByZXR1cm4gcmVzdWx0LnB1c2gobnVtKSA8IDM7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDksIDI1XVxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICBwcm90byA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGJhc2VDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXhlcywgb3Iga2V5cywgb2YgdGhlXG4gICAgICogYGNvbGxlY3Rpb25gLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgaW5kZXhlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtpbmRleF0gVGhlIGluZGV4ZXMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogICB0byByZXRyaWV2ZSwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiAgcHJvdmlkZWQgaW5kZXhlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddLCBbMCwgMiwgNF0pO1xuICAgICAqIC8vID0+IFsnYScsICdjJywgJ2UnXVxuICAgICAqXG4gICAgICogXy5hdChbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXSwgMCwgMik7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF0KGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmdzLCB0cnVlLCBmYWxzZSwgMSksXG4gICAgICAgICAgbGVuZ3RoID0gKGFyZ3NbMl0gJiYgYXJnc1syXVthcmdzWzFdXSA9PT0gY29sbGVjdGlvbikgPyAxIDogcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNvbGxlY3Rpb25bcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgcHJlc2VudCBpbiBhIGNvbGxlY3Rpb24gdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHRhcmdldGAgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoJ3BlYmJsZXMnLCAnZWInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCkgfHwgMDtcbiAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpID4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ID0gKGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbi5pbmRleE9mKHRhcmdldCwgZnJvbUluZGV4KSA6IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCsraW5kZXggPj0gZnJvbUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gIShyZXN1bHQgPSB2YWx1ZSA9PT0gdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgdmFsdWUgZm9yICoqYWxsKiogZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gISFjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAhIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0XG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdCwgZmluZFdoZXJlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoXG4gICAgICogZWxlbWVudC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogTm90ZTogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgYGxlbmd0aGAgcHJvcGVydHlcbiAgICAgKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAgICAgKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoKGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyAnMSwyLDMnXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2hSaWdodChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zICczLDIsMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2xlbmd0aF0sIGxlbmd0aCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBrZXkgPSBwcm9wcyA/IHByb3BzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGEgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSA6IHJlc3VsdFtrZXldID0gW10pLnB1c2godmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGdpdmVuIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBrZXlzID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4QnkoY2hhcmFjdGVycywgZnVuY3Rpb24oa2V5KSB7IHRoaXMuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBuYW1lZCBieSBgbWV0aG9kTmFtZWAgb24gZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmBcbiAgICAgKiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0XG4gICAgICogd2lsbCBiZSBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2UoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZShjb2xsZWN0aW9uLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IChpc0Z1bmMgPyBtZXRob2ROYW1lIDogdmFsdWVbbWV0aG9kTmFtZV0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbGxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYC1JbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50ID4gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGBJbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50IDwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBhbGwgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICB2YXIgcGx1Y2sgPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGEgY29sbGVjdGlvbiB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjaywgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogY2FsbGJhY2sgZXhlY3V0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGV4ZWN1dGlvbi4gSWZcbiAgICAgKiBgYWNjdW11bGF0b3JgIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB3aWxsIGJlXG4gICAgICogdXNlZCBhcyB0aGUgaW5pdGlhbCBgYWNjdW11bGF0b3JgIHZhbHVlLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3VtID0gXy5yZWR1Y2UoWzEsIDIsIDNdLCBmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uKSByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG5vYWNjdW0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNvbGxlY3Rpb25bKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxpc3QgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICogdmFyIGZsYXQgPSBfLnJlZHVjZVJpZ2h0KGxpc3QsIGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBhXG4gICAgICogY29sbGVjdGlvbiB0aGF0IHRoZSBjYWxsYmFjayBkb2VzICoqbm90KiogcmV0dXJuIHRydWV5IGZvci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGZhaWxlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvZGRzID0gXy5yZWplY3QoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgXG4gICAgICogIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YCBhcmd1bWVudHMgYXMgYG5gLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCAhPSAnbnVtYmVyJykge1xuICAgICAgICBjb2xsZWN0aW9uID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBjb2xsZWN0aW9uLmxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzaHVmZmxlKGNvbGxlY3Rpb24pO1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXNcbiAgICAgKiBzaHVmZmxlLiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBzaHVmZmxlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgNiwgMywgNSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCArK2luZGV4KTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBgY29sbGVjdGlvbi5sZW5ndGhgIGZvciBhcnJheXNcbiAgICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnVleSB2YWx1ZSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmRcbiAgICAgKiBkb2VzIG5vdCBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFueVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKChyZXN1bHQgPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgd2lsbCBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc29ydCBvcmRlclxuICAgICAqIG9mIGVxdWFsIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjb2xsZWN0aW9uXG4gICAgICogd2lsbCBiZSBzb3J0ZWQgYnkgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzb3J0ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLnNpbihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLnNpbihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAyNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDMwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgJ2FnZScpLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMjZdLCBbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICpcbiAgICAgKiAvLyBzb3J0aW5nIGJ5IG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCBbJ25hbWUnLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPSA+IFtbJ2Jhcm5leScsIDI2XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGNhbGxiYWNrKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFsrK2luZGV4XSA9IGdldE9iamVjdCgpO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBvYmplY3QuY3JpdGVyaWEgPSBtYXAoY2FsbGJhY2ssIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKG9iamVjdC5jcml0ZXJpYSA9IGdldEFycmF5KCkpWzBdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICByZXN1bHQuc29ydChjb21wYXJlQXNjZW5kaW5nKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gb2JqZWN0LnZhbHVlO1xuICAgICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgICAgcmVsZWFzZUFycmF5KG9iamVjdC5jcml0ZXJpYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWFzZU9iamVjdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYGNvbGxlY3Rpb25gIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTsgfSkoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBvZiBlYWNoIGVsZW1lbnQgaW4gYSBgY29sbGVjdGlvbmAgdG8gdGhlIGdpdmVuXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3BldHMnOiBbJ2hvcHB5J10gfV1cbiAgICAgKlxuICAgICAqIF8ud2hlcmUoY2hhcmFjdGVycywgeyAncGV0cyc6IFsnZGlubyddIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1dXG4gICAgICovXG4gICAgdmFyIHdoZXJlID0gZmlsdGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGFsbCBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzEsIDIsIDMsIDQsIDVdLCBbNSwgMiwgMTBdKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDIwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA+IDMwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb3IgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmdcbiAgICAgKiBhcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBoZWFkLCB0YWtlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maXJzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpcnN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkgKHRoZSBuZXN0aW5nIGNhbiBiZSB0byBhbnkgZGVwdGgpLiBJZiBgaXNTaGFsbG93YFxuICAgICAqIGlzIHRydWV5LCB0aGUgYXJyYXkgd2lsbCBvbmx5IGJlIGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZVxuICAgICAqIGZsYXR0ZW5pbmcuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgW1s0XV1dO1xuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzMCwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmxhdHRlbihjaGFyYWN0ZXJzLCAncGV0cycpO1xuICAgICAqIC8vID0+IFsnaG9wcHknLCAnYmFieSBwdXNzJywgJ2Rpbm8nXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTaGFsbG93ICE9ICdib29sZWFuJyAmJiBpc1NoYWxsb3cgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTaGFsbG93XSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU2hhbGxvdztcbiAgICAgICAgaXNTaGFsbG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBhcnJheSA9IG1hcChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgYWxyZWFkeSBzb3J0ZWRcbiAgICAgKiBwcm92aWRpbmcgYHRydWVgIGZvciBgZnJvbUluZGV4YCB3aWxsIHJ1biBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAxLCAyLCAyLCAzLCAzXSwgMiwgdHJ1ZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdID09PSB2YWx1ZSA/IGluZGV4IDogLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhXG4gICAgICogY2FsbGJhY2sgaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIGV4Y2x1ZGVkIGZyb21cbiAgICAgKiB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uaW5pdGlhbChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uaW5pdGlhbChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogY2FsbGJhY2sgfHwgbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHByZXNlbnQgaW4gYWxsIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIHRydXN0SW5kZXhPZiA9IGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHNlZW4gPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBjYWNoZXMucHVzaCh0cnVzdEluZGV4T2YgJiYgdmFsdWUubGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmXG4gICAgICAgICAgICBjcmVhdGVDYWNoZShhcmdzSW5kZXggPyBhcmdzW2FyZ3NJbmRleF0gOiBzZWVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IGFyZ3NbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzWzBdO1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKHNlZW4sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgYXJnc0luZGV4ID0gYXJnc0xlbmd0aDtcbiAgICAgICAgICAoY2FjaGUgfHwgc2VlbikucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzSW5kZXhdO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcmdzW2FyZ3NJbmRleF0sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0xlbmd0aF07XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoY2FjaGVzKTtcbiAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmxhc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmxhc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZFxuICAgICAqIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgaW5kZXggKyBmcm9tSW5kZXgpIDogbmF0aXZlTWluKGZyb21JbmRleCwgaW5kZXggLSAxKSkgKyAxO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgMSwgMiwgM107XG4gICAgICogXy5wdWxsKGFycmF5LCAyLCAzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbChhcnJheSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYC4gSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYHN0b3BgIGFcbiAgICAgKiB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyByYW5nZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHR5cGVvZiBzdGVwID09ICdudW1iZXInID8gc3RlcCA6ICgrc3RlcCB8fCAxKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICAvLyB1c2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlc1xuICAgICAgLy8gaHR0cDovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoMCwgY2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgdGhhdCB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmluaXRpYWxgIHRoaXMgbWV0aG9kIGdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvclxuICAgICAqIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZCBlbGVtZW50c1xuICAgICAqIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRyb3AsIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogbmF0aXZlTWF4KDAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCBhIHZhbHVlXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYSBnaXZlbiBzb3J0ZWQgYXJyYXkgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIHNvcnRcbiAgICAgKiBvcmRlciBvZiB0aGUgYXJyYXkuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzIwLCAzMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDIwIH0sIHsgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBkaWN0ID0ge1xuICAgICAqICAgJ3dvcmRUb051bWJlcic6IHsgJ3R3ZW50eSc6IDIwLCAndGhpcnR5JzogMzAsICdmb3VydHknOiA0MCwgJ2ZpZnR5JzogNTAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIGRpY3Qud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSwgZGljdCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgLy8gZXhwbGljaXRseSByZWZlcmVuY2UgYGlkZW50aXR5YCBmb3IgYmV0dGVyIGlubGluaW5nIGluIEZpcmVmb3hcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpIDogaWRlbnRpdHk7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgICAgKGNhbGxiYWNrKGFycmF5W21pZF0pIDwgdmFsdWUpXG4gICAgICAgICAgPyBsb3cgPSBtaWQgKyAxXG4gICAgICAgICAgOiBoaWdoID0gbWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA1LCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIHNvcnRlZCwgcHJvdmlkaW5nXG4gICAgICogYHRydWVgIGZvciBgaXNTb3J0ZWRgIHdpbGwgdXNlIGEgZmFzdGVyIGFsZ29yaXRobS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZFxuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmUgdW5pcXVlbmVzc1xuICAgICAqIGlzIGNvbXB1dGVkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbJ0EnLCAnYicsICdDJywgJ2EnLCAnQicsICdjJ10sIGZ1bmN0aW9uKGxldHRlcikgeyByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAqIC8vID0+IFsnQScsICdiJywgJ0MnXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDMsIDEuNSwgMiwgMy41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjUsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicgJiYgaXNTb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NvcnRlZCAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NvcnRlZF0gPT09IGFycmF5KSA/IG51bGwgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gICAgICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0pO1xuICAgICAqIC8vID0+IFszLCA1LCA0XVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDVdLCBbMiwgMywgNV0sIFszLCA0LCA1XSk7XG4gICAgICogLy8gPT4gWzEsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24geG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgID8gYmFzZVVuaXEoYmFzZURpZmZlcmVuY2UocmVzdWx0LCBhcnJheSkuY29uY2F0KGJhc2VEaWZmZXJlbmNlKGFycmF5LCByZXN1bHQpKSlcbiAgICAgICAgICAgIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuemlwXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gQXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXAoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50cyA6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gbWF4KHBsdWNrKGFycmF5LCAnbGVuZ3RoJykpIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBmcm9tIGFycmF5cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLiBQcm92aWRlXG4gICAgICogZWl0aGVyIGEgc2luZ2xlIHR3byBkaW1lbnNpb25hbCBhcnJheSwgaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gXG4gICAgICogb3IgdHdvIGFycmF5cywgb25lIG9mIGBrZXlzYCBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgb2JqZWN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgVGhlIGFycmF5IG9mIGtleXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgZ2l2ZW4ga2V5cyBhbmRcbiAgICAgKiAgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzID8ga2V5cy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBpZiAoIXZhbHVlcyAmJiBsZW5ndGggJiYgIWlzQXJyYXkoa2V5c1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyBgZnVuY2AsIHdpdGggIHRoZSBgdGhpc2AgYmluZGluZyBhbmRcbiAgICAgKiBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIG9ubHkgYWZ0ZXIgYmVpbmcgY2FsbGVkIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmVcbiAgICAgKiAgYGZ1bmNgIGlzIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnRG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdEb25lIHNhdmluZyEnLCBhZnRlciBhbGwgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMgPSBfLmJpbmQoZnVuYywgeyAnbmFtZSc6ICdmcmVkJyB9LCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGZ1bmMsIDE3LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCB0aGlzQXJnKVxuICAgICAgICA6IGNyZWF0ZVdyYXBwZXIoZnVuYywgMSwgbnVsbCwgbnVsbCwgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCB0aGUgZnVuY3Rpb24gcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgIHdpbGwgYmUgYm91bmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gW21ldGhvZE5hbWVdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvXG4gICAgICogIGJpbmQsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpOyB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3KTtcbiAgICAgKiBqUXVlcnkoJyNkb2NzJykub24oJ2NsaWNrJywgdmlldy5vbkNsaWNrKTtcbiAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnLCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRBbGwob2JqZWN0KSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpIDogZnVuY3Rpb25zKG9iamVjdCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBmdW5jc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgMSwgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZEtleWAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBib3VuZFxuICAgICAqIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvXG4gICAgICogcmVmZXJlbmNlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIGh0dHA6Ly9taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnbmFtZSc6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLm5hbWUgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kS2V5KG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGtleSwgMTksIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIG9iamVjdClcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGtleSwgMywgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiB3aGVyZSBlYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgICAgKiBGb3IgZXhhbXBsZSwgY29tcG9zaW5nIHRoZSBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgcHJvZHVjZXMgYGYoZyhoKCkpKWAuXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNdIEZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhbE5hbWVNYXAgPSB7XG4gICAgICogICAncGViYmxlcyc6ICdwZW5lbG9wZSdcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgKiAgIG5hbWUgPSByZWFsTmFtZU1hcFtuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWU7XG4gICAgICogICByZXR1cm4gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICogICByZXR1cm4gJ0hpeWEgJyArIGZvcm1hdHRlZCArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHdlbGNvbWUgPSBfLmNvbXBvc2UoZ3JlZXQsIGZvcm1hdCk7XG4gICAgICogd2VsY29tZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdIaXlhIFBlbmVsb3BlISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jc1tsZW5ndGhdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJncyA9IFtmdW5jc1tsZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgb25lIG9yIG1vcmUgYXJndW1lbnRzIG9mIGBmdW5jYCB0aGF0IHdoZW5cbiAgICAgKiBpbnZva2VkIGVpdGhlciBleGVjdXRlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgY2FuIGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgY29uc29sZS5sb2coYSArIGIgKyBjKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSkge1xuICAgICAgYXJpdHkgPSB0eXBlb2YgYXJpdHkgPT0gJ251bWJlcicgPyBhcml0eSA6ICgrYXJpdHkgfHwgZnVuYy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgNCwgbnVsbCwgbnVsbCwgbnVsbCwgYXJpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiBvZiBgZnVuY2AgdW50aWwgYWZ0ZXJcbiAgICAgKiBgd2FpdGAgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuICAgICAqIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb25cbiAgICAgKiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogdmFyIGxhenlMYXlvdXQgPSBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgbGF6eUxheW91dCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBleGVjdXRlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSwgZmFsc2UpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0KSB8fCAwO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKG5hdGl2ZU1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGV4ZWN1dGluZyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuXG4gICAgICogQWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7IGNvbnNvbGUubG9nKHRleHQpOyB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyBsb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG9yIG1vcmUgbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gbG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWxheShmdW5jLCB3YWl0KSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHRcbiAgICAgKiBiYXNlZCBvbiB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBUaGUgcmVzdWx0IGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIEEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmlib25hY2NpID0gXy5tZW1vaXplKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMiA/IG4gOiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZpYm9uYWNjaSg5KVxuICAgICAqIC8vID0+IDM0XG4gICAgICpcbiAgICAgKiB2YXIgZGF0YSA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gbW9kaWZ5aW5nIHRoZSByZXN1bHQgY2FjaGVcbiAgICAgKiB2YXIgZ2V0ID0gXy5tZW1vaXplKGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGRhdGFbbmFtZV07IH0sIF8uaWRlbnRpdHkpO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKlxuICAgICAqIGdldC5jYWNoZS5wZWJibGVzLm5hbWUgPSAncGVuZWxvcGUnO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGVuZWxvcGUnLCAnYWdlJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGUsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXlQcmVmaXggKyBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSlcbiAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICA6IChjYWNoZVtrZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVkLmNhY2hlID0ge307XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBleGVjdXRlIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHMgdG9cbiAgICAgKiB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gYGluaXRpYWxpemVgIGV4ZWN1dGVzIGBjcmVhdGVBcHBsaWNhdGlvbmAgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgdmFyIHJhbixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmFuKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGBmdW5jYCB2YXJpYWJsZSBzbyB0aGUgZnVuY3Rpb24gbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggYW55IGFkZGl0aW9uYWxcbiAgICAgKiBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzXG4gICAgICogbWV0aG9kIGlzIHNpbWlsYXIgdG8gYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHsgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTsgfTtcbiAgICAgKiB2YXIgaGkgPSBfLnBhcnRpYWwoZ3JlZXQsICdoaScpO1xuICAgICAqIGhpKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAxNiwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBgcGFydGlhbGAgYXJndW1lbnRzIGFyZVxuICAgICAqIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzRGVlcCA9IF8ucGFydGlhbFJpZ2h0KF8ubWVyZ2UsIF8uZGVmYXVsdHMpO1xuICAgICAqXG4gICAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAndmFyaWFibGUnOiAnZGF0YScsXG4gICAgICogICAnaW1wb3J0cyc6IHsgJ2pxJzogJCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzRGVlcChvcHRpb25zLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuICAgICAqXG4gICAgICogb3B0aW9ucy52YXJpYWJsZVxuICAgICAqIC8vID0+ICdkYXRhJ1xuICAgICAqXG4gICAgICogb3B0aW9ucy5pbXBvcnRzXG4gICAgICogLy8gPT4geyAnXyc6IF8sICdqcSc6ICQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxSaWdodChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAzMiwgbnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHdpbGwgb25seSBjYWxsIHRoZSBgZnVuY2AgZnVuY3Rpb25cbiAgICAgKiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG9cbiAgICAgKiBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZVxuICAgICAqIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIHRocm90dGxlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBleGVjdXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgZGVib3VuY2VPcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgZGVib3VuY2VPcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCBkZWJvdW5jZU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gYXMgaXRzXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgZXhlY3V0ZWQgd2l0aFxuICAgICAqIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5GcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIod3JhcHBlciwgMTYsIFt2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY2FsbGJhY2sgYm91bmQgdG8gYW4gb3B0aW9uYWwgYHRoaXNBcmdgLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eVxuICAgICAqIG5hbWUgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogSWYgYGZ1bmNgIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzXG4gICAgICogdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3cmFwIHRvIGNyZWF0ZSBjdXN0b20gY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8uY3JlYXRlQ2FsbGJhY2sgPSBfLndyYXAoXy5jcmVhdGVDYWxsYmFjaywgZnVuY3Rpb24oZnVuYywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhjYWxsYmFjayk7XG4gICAgICogICByZXR1cm4gIW1hdGNoID8gZnVuYyhjYWxsYmFjaywgdGhpc0FyZykgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCcgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM10gOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2FnZV9fZ3QzOCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmIChmdW5jID09IG51bGwgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIFwiXy5wbHVja1wiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmICh0eXBlICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eShmdW5jKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGtleXMoZnVuYyksXG4gICAgICAgICAga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgICAgYSA9IGZ1bmNba2V5XTtcblxuICAgICAgLy8gaGFuZGxlIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMSAmJiBhID09PSBhICYmICFpc09iamVjdChhKSkge1xuICAgICAgICAvLyBmYXN0IHBhdGggdGhlIGNvbW1vbiBjYXNlIG9mIHByb3ZpZGluZyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZVxuICAgICAgICAvLyBwcm9wZXJ0eSBjb250YWluaW5nIGEgcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICB2YXIgYiA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIHJldHVybiBhID09PSBiICYmIChhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYikpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwob2JqZWN0W3Byb3BzW2xlbmd0aF1dLCBmdW5jW3Byb3BzW2xlbmd0aF1dLCBudWxsLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBgJmAsIGA8YCwgYD5gLCBgXCJgLCBhbmQgYCdgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIFdpbG1hLCAmYW1wOyBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIG1ldGhvZHMgd2lsbCBiZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciB0aGUgZnVuY3Rpb25zIGFkZGVkIGFyZSBjaGFpbmFibGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9KTtcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gc291cmNlICYmIGZ1bmN0aW9ucyhzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZSB8fCAoIW9wdGlvbnMgJiYgIW1ldGhvZE5hbWVzLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY3RvciA9IGxvZGFzaFdyYXBwZXI7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gbG9kYXNoO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGZ1bmN0aW9ucyhzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IG9iamVjdCxcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGN0b3IpO1xuXG4gICAgICBmb3JFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gb2JqZWN0W21ldGhvZE5hbWVdID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgY3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgICAgICBhcmdzID0gW3ZhbHVlXTtcblxuICAgICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHJlc3VsdCAmJiBpc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGN0b3IocmVzdWx0KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSAnXycgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgY29udGV4dC5fID0gb2xkRGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBubyBvcGVyYXRpb24gcGVyZm9ybWVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICAgICAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3RhbXAgPSBfLm5vdygpO1xuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqL1xuICAgIHZhciBub3cgPSBpc05hdGl2ZShub3cgPSBEYXRlLm5vdykgJiYgbm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAgICogSWYgYHJhZGl4YCBpcyBgdW5kZWZpbmVkYCBvciBgMGAgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgdGhlXG4gICAgICogYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBhdm9pZHMgZGlmZmVyZW5jZXMgaW4gbmF0aXZlIEVTMyBhbmQgRVM1IGBwYXJzZUludGBcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jRS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXhdIFRoZSByYWRpeCB1c2VkIHRvIGludGVycHJldCB0aGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbmV3IGludGVnZXIgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqL1xuICAgIHZhciBwYXJzZUludCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSA9PSA4ID8gbmF0aXZlUGFyc2VJbnQgOiBmdW5jdGlvbih2YWx1ZSwgcmFkaXgpIHtcbiAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgdGhlIEVTMyBzcGVjaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgYHBhcnNlSW50YFxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UocmVMZWFkaW5nU3BhY2VzQW5kWmVyb3MsICcnKSA6IHZhbHVlLCByYWRpeCB8fCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFwiXy5wbHVja1wiIHN0eWxlIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIHRoZSBga2V5YCB2YWx1ZSBvZiBhXG4gICAgICogZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBnZXROYW1lID0gXy5wcm9wZXJ0eSgnbmFtZScpO1xuICAgICAqXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIHRydWV5IG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzIGFcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXIgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmc9ZmFsc2VdIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgZmxvYXRpbmcpIHtcbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWluID09ICdib29sZWFuJyAmJiBub01heCkge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5vTWF4ICYmIHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBga2V5YCBvbiBgb2JqZWN0YC4gSWYgYGtleWAgaXMgYSBmdW5jdGlvblxuICAgICAqIGl0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgb2JqZWN0YCBhbmQgaXRzIHJlc3VsdCByZXR1cm5lZCxcbiAgICAgKiBlbHNlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXR1cm5lZC4gSWYgYG9iamVjdGAgaXMgZmFsc2V5IHRoZW4gYHVuZGVmaW5lZGBcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdjaGVlc2UnOiAnY3J1bXBldHMnLFxuICAgICAqICAgJ3N0dWZmJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHJldHVybiAnbm9uc2Vuc2UnO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdjaGVlc2UnKTtcbiAgICAgKiAvLyA9PiAnY3J1bXBldHMnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdzdHVmZicpO1xuICAgICAqIC8vID0+ICdub25zZW5zZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSA/IG9iamVjdFtrZXldKCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1pY3JvLXRlbXBsYXRpbmcgbWV0aG9kIHRoYXQgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzXG4gICAgICogd2hpdGVzcGFjZSwgYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQsIGBfLnRlbXBsYXRlYCB1dGlsaXplcyBzb3VyY2VVUkxzIGZvciBlYXNpZXJcbiAgICAgKiBkZWJ1Z2dpbmcuIFNlZSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZTpcbiAgICAgKiBodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkc1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlOlxuICAgICAqIGh0dHA6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9zdGFibGUvZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbC5odG1sXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2JqZWN0IHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZV0gVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHNdIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgbG9jYWwgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZV0gVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFyaWFibGVdIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxzdHJpbmd9IFJldHVybnMgYSBjb21waWxlZCBmdW5jdGlvbiB3aGVuIG5vIGBkYXRhYCBvYmplY3RcbiAgICAgKiAgaXMgZ2l2ZW4sIGVsc2UgaXQgcmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHRleHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IG5hbWUgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICduYW1lJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBIVE1MIGluIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicsIHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZ2VuZXJhdGUgSFRNTFxuICAgICAqIHZhciBsaXN0ID0gJzwlIF8uZm9yRWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCUtIG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVM2IGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG4gICAgICogXy50ZW1wbGF0ZSgnaGVsbG8gJHsgbmFtZSB9JywgeyAnbmFtZSc6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIG5hbWUpOyAlPiEnLCB7ICduYW1lJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgICAqICAgJ2ludGVycG9sYXRlJzogL3t7KFtcXHNcXFNdKz8pfX0vZ1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyB7eyBuYW1lIH19IScsIHsgJ25hbWUnOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgalF1ZXJ5XG4gICAgICogdmFyIGxpc3QgPSAnPCUganEuZWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCUtIG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicsIG51bGwsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS5uYW1lICU+IScsIG51bGwsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogICB2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGU7XG4gICAgICogICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS5uYW1lICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogICByZXR1cm4gX19wO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oY3dkLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIC8vIGJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcbiAgICAgIHRleHQgPSBTdHJpbmcodGV4dCB8fCAnJyk7XG5cbiAgICAgIC8vIGF2b2lkIG1pc3NpbmcgZGVwZW5kZW5jaWVzIHdoZW4gYGl0ZXJhdG9yVGVtcGxhdGVgIGlzIG5vdCBkZWZpbmVkXG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldHRpbmdzKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IHZhbHVlcyhpbXBvcnRzKTtcblxuICAgICAgdmFyIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIGNvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlclxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgdGV4dC5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBlc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHNcbiAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gcmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHNcbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyByZXF1aXJlcyByZXR1cm5pbmcgdGhlIGBtYXRjaGBcbiAgICAgICAgLy8gc3RyaW5nIGluIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWVcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIGlmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCwgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGUsXG4gICAgICAgICAgaGFzVmFyaWFibGUgPSB2YXJpYWJsZTtcblxuICAgICAgaWYgKCFoYXNWYXJpYWJsZSkge1xuICAgICAgICB2YXJpYWJsZSA9ICdvYmonO1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAoJyArIHZhcmlhYmxlICsgJykge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBjbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3NcbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gZnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keVxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICtcbiAgICAgICAgKGhhc1ZhcmlhYmxlID8gJycgOiB2YXJpYWJsZSArICcgfHwgKCcgKyB2YXJpYWJsZSArICcgPSB7fSk7XFxuJykgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZVwiICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnXFxuLypcXG4vLyMgc291cmNlVVJMPScgKyAob3B0aW9ucy5zb3VyY2VVUkwgfHwgJy9sb2Rhc2gvdGVtcGxhdGUvc291cmNlWycgKyAodGVtcGxhdGVDb3VudGVyKyspICsgJ10nKSArICdcXG4qLyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbihpbXBvcnRzS2V5cywgJ3JldHVybiAnICsgc291cmNlICsgc291cmNlVVJMKS5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCwgaW5cbiAgICAgIC8vIHN1cHBvcnRlZCBlbnZpcm9ubWVudHMsIG9yIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgICAgLy8gaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBjYWxsYmFjayBleGVjdXRpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2KSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgbWFnZS5jYXN0U3BlbGwobik7IH0pO1xuICAgICAqIC8vID0+IGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMsIHBhc3NpbmcgYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgIHJlc3BlY3RpdmVseVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IHRoaXMuY2FzdChuKTsgfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIG4gPSAobiA9ICtuKSA+IC0xID8gbiA6IDA7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWAgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdGcmVkLCBCYXJuZXkgJmFtcDsgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBCYXJuZXkgJiBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgcHJvdmlkZWQgdGhlIElEIHdpbGwgYmUgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gU3RyaW5nKHByZWZpeCA9PSBudWxsID8gJycgOiBwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHRoYXQgd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHdpdGggZXhwbGljaXRcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbihjaGFyYWN0ZXJzKVxuICAgICAqICAgICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgICAubWFwKGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLm5hbWUgKyAnIGlzICcgKyBjaHIuYWdlOyB9KVxuICAgICAqICAgICAuZmlyc3QoKVxuICAgICAqICAgICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICAgIHZhbHVlLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgaW50ZXJjZXB0b3JgIHdpdGggdGhlIGB2YWx1ZWAgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGVuXG4gICAgICogcmV0dXJucyBgdmFsdWVgLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2RcbiAgICAgKiBjaGFpbiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluXG4gICAgICogdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgMywgNF0pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHsgYXJyYXkucG9wKCk7IH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZXhwbGljaXQgbWV0aG9kIGNoYWluaW5nIG9uIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8oY2hhcmFjdGVycykuZmlyc3QoKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ2FnZScpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgdGhlIGB0b1N0cmluZ2AgcmVzdWx0IG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZyByZXN1bHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMuX193cmFwcGVkX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVPZlxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHZhbHVlXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZU9mKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlT2YoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3dyYXBwZWRfXztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb21wb3NlID0gY29tcG9zZTtcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3JlYXRlQ2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjaztcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gucGFpcnMgPSBwYWlycztcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gud2hlcmUgPSB3aGVyZTtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgICBsb2Rhc2guZHJvcCA9IHJlc3Q7XG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbjtcbiAgICBsb2Rhc2gubWV0aG9kcyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2gub2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC5zZWxlY3QgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLnRhaWwgPSByZXN0O1xuICAgIGxvZGFzaC51bmlxdWUgPSB1bmlxO1xuICAgIGxvZGFzaC51bnppcCA9IHppcDtcblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgXG4gICAgbWl4aW4obG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jb250YWlucyA9IGNvbnRhaW5zO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLmFsbCA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5hbnkgPSBzb21lO1xuICAgIGxvZGFzaC5kZXRlY3QgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kO1xuICAgIGxvZGFzaC5mb2xkbCA9IHJlZHVjZTtcbiAgICBsb2Rhc2guZm9sZHIgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2guaW5jbHVkZSA9IGNvbnRhaW5zO1xuICAgIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG5cbiAgICBtaXhpbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fVxuICAgICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpLCBmYWxzZSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgY2FwYWJsZSBvZiByZXR1cm5pbmcgd3JhcHBlZCBhbmQgdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmZpcnN0ID0gZmlyc3Q7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC50YWtlID0gZmlyc3Q7XG4gICAgbG9kYXNoLmhlYWQgPSBmaXJzdDtcblxuICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjYWxsYmFja2FibGUgPSBtZXRob2ROYW1lICE9PSAnc2FtcGxlJztcbiAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdPSBmdW5jdGlvbihuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKHRoaXMuX193cmFwcGVkX18sIG4sIGd1YXJkKTtcblxuICAgICAgICAgIHJldHVybiAhY2hhaW5BbGwgJiYgKG4gPT0gbnVsbCB8fCAoZ3VhcmQgJiYgIShjYWxsYmFja2FibGUgJiYgdHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykpKVxuICAgICAgICAgICAgPyByZXN1bHRcbiAgICAgICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gJzIuNC4yJztcblxuICAgIC8vIGFkZCBcIkNoYWluaW5nXCIgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWVPZjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSB3cmFwcGVyVmFsdWVPZjtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzXG4gICAgZm9yRWFjaChbJ2pvaW4nLCAncG9wJywgJ3NoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiBjaGFpbkFsbFxuICAgICAgICAgID8gbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbClcbiAgICAgICAgICA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdGhlIGV4aXN0aW5nIHdyYXBwZWQgdmFsdWVcbiAgICBmb3JFYWNoKFsncHVzaCcsICdyZXZlcnNlJywgJ3NvcnQnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBuZXcgd3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnY29uY2F0JywgJ3NsaWNlJywgJ3NwbGljZSddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGxvZGFzaFdyYXBwZXIoZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIGV4cG9zZSBMby1EYXNoXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gc29tZSBBTUQgYnVpbGQgb3B0aW1pemVycyBsaWtlIHIuanMgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMby1EYXNoIHRvIHRoZSBnbG9iYWwgb2JqZWN0IGV2ZW4gd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgaW5cbiAgICAvLyBjYXNlIExvLURhc2ggaXMgbG9hZGVkIHdpdGggYSBSZXF1aXJlSlMgc2hpbSBjb25maWcuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWwjY29uZmlnLXNoaW1cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gZGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlNcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIH1cbiAgICAvLyBpbiBOYXJ3aGFsIG9yIFJoaW5vIC1yZXF1aXJlXG4gICAgZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gaW4gYSBicm93c2VyIG9yIFJoaW5vXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIi8qXG5cdGNvc3RzOiB7XG5cdFx0ZGVsZXRlOiBudW1iZXIgfCBmdW5jdGlvbiAoIGNoYXIgKVxuXHRcdGluc2VydDogbnVtYmVyIHwgZnVuY3Rpb24gKCBjaGFyIClcblx0XHRyZXBsYWNlOiBudW1iZXIgfCBmdW5jdGlvbiAoIHdoYXQsIGJ5IClcblx0XHR0cmFuc3Bvc2U6IG51bWJlciB8IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQgKVxuXHR9XG4qL1xuXG5mdW5jdGlvbiBnZXRDb3N0KCBjb3N0cywgb3AsIGEsIGIgKSB7XG5cdGxldCBjb3N0ID0gdHlwZW9mIGNvc3RzID09IGBvYmplY3RgID8gY29zdHNbIG9wIF0gOiBjb3N0c1xuXHRyZXR1cm4gdHlwZW9mIGNvc3QgPT0gYGZ1bmN0aW9uYCA/IGNvc3QuY2FsbCggY29zdHMsIGEsIGIgKSA6IGNvc3Rcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIHMxLCBzMiwgY29zdHMgPSAxICkgPT4ge1xuXHRsZXQgZCA9IFtdXG5cdGZvciAoIGxldCBpID0gMDsgaSA8PSBzMS5sZW5ndGg7ICsraSApIHtcblx0XHRkWyBpIF0gPSBpIDwgMyA/IFtdIDogZFsgaSAtIDMgXSAvLyBzb21lIG9wdGltaXphdGlvblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSBzMi5sZW5ndGg7ICsraiApXG5cdFx0XHRkWyBpIF1bIGogXSA9XG5cdFx0XHRcdGkgPT0gMCAmJiBqID09IDAgP1xuXHRcdFx0XHRcdDBcblx0XHRcdFx0OiBpID09IDAgP1xuXHRcdFx0XHRcdGRbIGkgXVsgaiAtIDEgXSArIGdldENvc3QoIGNvc3RzLCBgaW5zZXJ0YCwgczJbIGogLSAxIF0gKVxuXHRcdFx0XHQ6IGogPT0gMCA/XG5cdFx0XHRcdFx0ZFsgaSAtIDEgXVsgaiBdICsgZ2V0Q29zdCggY29zdHMsIGBkZWxldGVgLCBzMVsgaSAtIDEgXSApXG5cdFx0XHRcdDogTWF0aC5taW4oXG5cdFx0XHRcdFx0ZFsgaSAtIDEgXVsgaiBdICsgZ2V0Q29zdCggY29zdHMsIGBkZWxldGVgLCBzMVsgaSAtIDEgXSApLFxuXHRcdFx0XHRcdGRbIGkgXVsgaiAtIDEgXSArIGdldENvc3QoIGNvc3RzLCBgaW5zZXJ0YCwgczJbIGogLSAxIF0gKSxcblx0XHRcdFx0XHRkWyBpIC0gMSBdWyBqIC0gMSBdICsgKCBzMVsgaSAtIDEgXSA9PSBzMlsgaiAtIDEgXSA/IDAgOiBnZXRDb3N0KCBjb3N0cywgYHJlcGxhY2VgLCBzMVsgaSAtIDEgXSwgczJbIGogLSAxIF0gKSApLFxuXHRcdFx0XHRcdCggaSA+IDEgJiYgaiA+IDEgJiYgczFbIGkgLSAxIF0gPT0gczJbIGogLSAyIF0gJiYgczFbIGkgLSAyIF0gPT0gczJbIGogLSAxIF0gKVxuXHRcdFx0XHRcdFx0PyBkWyBpIC0gMiBdWyBqIC0gMiBdICsgZ2V0Q29zdCggY29zdHMsIGB0cmFuc3Bvc2VgLCBzMVsgaSAtIDIgXSwgczFbIGkgLSAxIF0gKSA6IEluZmluaXR5XG5cdFx0XHRcdClcblx0fVxuXHRyZXR1cm4gZFsgczEubGVuZ3RoIF1bIHMyLmxlbmd0aCBdXG59XG4iLCJsZXQgcmEgPSByZXF1aXJlKCBgcmFgIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIGtleSwgZGVmYXVsdHMgPSBudWxsICkge1xuXHRsZXQgcmV0ID0gcmEuY2xlYW4oIGRlZmF1bHRzIClcblx0LnNldENvbnN0KCBcInJlc2V0XCIsICgpID0+IHtcblx0XHRcdGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCBrZXkgKVxuXHRcdFx0cmV0LmFzc2lnbiggZGVmYXVsdHMgKVxuXHRcdFx0Ly8gcmV0LmxvYWRlZCA9IHRydWVcblx0XHR9XG5cdClcblx0LnNldE5hbWUoIFwibG9jYWxTdG9yYWdlLlwiICsga2V5IClcblx0bGV0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCBrZXkgKVxuXHRpZiAoIHN0b3JlZCAhPSBudWxsIClcblx0XHRyZXQuYXNzaWduKCBKU09OLnBhcnNlKCBzdG9yZWQgKSApXG5cdHJhLmNsZWFuKCAoKSA9PiB7XG5cdFx0aWYgKCByZXQudmFsdWVPZigpICE9IGRlZmF1bHRzIClcblx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKCBrZXksIEpTT04uc3RyaW5naWZ5KCByZXQgKSApXG5cdH0gKVxuXHRyZXR1cm4gcmV0XG59XG4iLCJyZXF1aXJlKCBgY29sb3JzYCApXG5cbmxldCBMT0cgPSAoIG1zZywgLi4uZGF0YSApID0+IGNvbnNvbGUubG9nKCBgJHsgKCBuZXcgRGF0ZSApLnRvSVNPU3RyaW5nKCkucmVwbGFjZSggYFRgLCBgPWAgKS5yZXBsYWNlKCBgWmAsIGBgICkgfSAkeyBtc2cgfWAsIC4uLmRhdGEgKVxuTE9HLkxPRyA9IExPR1xuTE9HLklORk8gPSBMT0dcbkxPRy5UUkFDRSA9IExPR1xuTE9HLkVSUk9SID0gTE9HXG5MT0cuV0FSTklORyA9IExPR1xuXG5tb2R1bGUuZXhwb3J0cyA9IExPR1xuIiwibGV0IGxvZGFzaCA9IHJlcXVpcmUoIGBsb2Rhc2hgIClcblxuY2xhc3MgUG9uZ0pTT04gZXh0ZW5kcyByZXF1aXJlKCBgV2ViUXVldWVgICkge1xuXHRjb25zdHJ1Y3RvciggcSApIHtcblx0XHRzdXBlcigpXG5cdFx0dGhpcy5fcSA9IHFcblx0XHR0aGlzLnBpcGVGcm9tKCBxIClcblx0XHRxLm9ubWVzc2FnZSA9IG1lc3NhZ2UgPT4gdGhpcy5fbWVzc2FnZSggbWVzc2FnZSApXG5cdH1cblx0dW53aXNlKCkge1xuXHRcdGxldCBxID0gdGhpcy5fcVxuXHRcdHRoaXMuX3EgPSBudWxsXG5cdFx0cS5vbm9wZW4gPSBudWxsXG5cdFx0cS5vbmNsb3NlID0gbnVsbFxuXHRcdHEub25lcnJvciA9IG51bGxcblx0XHRxLm9ubWVzc2FnZSA9IG51bGxcblx0XHRyZXR1cm4gcS51bndpc2UgPyBxLnVud2lzZSgpIDogcVxuXHR9XG5cdF9tZXNzYWdlKCBtZXNzYWdlICkge1xuXHRcdGlmICggbWVzc2FnZS53aGF0ID09IGBwaW5nYCApXG5cdFx0XHR0aGlzLl9xLnNlbmQoIHsgd2hhdDogYHBvbmdgLCBwb25nOiBtZXNzYWdlLnBpbmcgfSApXG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5kb21lc3NhZ2UoIG1lc3NhZ2UgKVxuXHR9XG5cdF9zZW5kKCBtZXNzYWdlICkge1xuXHRcdHRoaXMuX3Euc2VuZCggbWVzc2FnZSApXG5cdH1cblx0X2Nsb3NlKCkge1xuXHRcdHRoaXMuX3Eub25jbG9zZSA9IG51bGxcblx0XHR0aGlzLl9xLmNsb3NlKClcblx0fVxufVxuXG5jbGFzcyBQaW5nUG9uZ0pTT04gZXh0ZW5kcyBQb25nSlNPTiB7XG5cdGNvbnN0cnVjdG9yKCBxLCB7IGludGVydmFsID0gNjAwMDAsIHRpbWVvdXQgPSAxNTAwMCwgbWF4cGluZ3MgPSAxMDAwIH0gPSB7fSApIHtcblx0XHRzdXBlciggcSApXG5cdFx0dGhpcy5fcGluZ3MgPSB7fVxuXHRcdHRoaXMuX2NvdW50ID0gMFxuXHRcdHRoaXMuX3BpbnRlcnZhbCA9IGludGVydmFsID09IEluZmluaXR5ID8gbnVsbCA6IHNldEludGVydmFsKCAoKSA9PiB0aGlzLnBpbmcoKSwgaW50ZXJ2YWwgKVxuXHRcdHRoaXMuX3RpbWVvdXQgPSB0aW1lb3V0XG5cdFx0dGhpcy5fbWF4cGluZ3MgPSBtYXhwaW5nc1xuXHR9XG5cdF9tZXNzYWdlKCBtZXNzYWdlICkge1xuXHRcdGlmICggbWVzc2FnZS53aGF0ID09IGBwb25nYCApIHtcblx0XHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB0aGlzLl9waW5ncywgbWVzc2FnZS5wb25nICkgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5fcGluZ3NbIG1lc3NhZ2UucG9uZyBdIClcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3BpbmdzWyBtZXNzYWdlLnBvbmcgXVxuXHRcdFx0XHQtLXRoaXMuX2NvdW50XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHN1cGVyLl9tZXNzYWdlKCBtZXNzYWdlIClcblx0fVxuXHRfc2VuZCggbWVzc2FnZSApIHtcblx0XHRzdXBlci5fc2VuZCggbWVzc2FnZSApXG5cdFx0dGhpcy5waW5nKClcblx0fVxuXHRfY2xvc2UoKSB7XG5cdFx0Y2xlYXJJbnRlcnZhbCggdGhpcy5fcGludGVydmFsIClcblx0XHR0aGlzLl9waW50ZXJ2YWwgPSBudWxsXG5cdFx0bG9kYXNoLmZvckVhY2goIHRoaXMuX3BpbmdzLCB0ID0+IGNsZWFyVGltZW91dCggdCApIClcblx0XHR0aGlzLl9waW5ncyA9IG51bGxcblx0XHRzdXBlci5fY2xvc2UoKVxuXHR9XG5cdHBpbmcoKSB7XG5cdFx0aWYgKCAhdGhpcy5fcSApXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoIHRoaXMuX2NvdW50ID4gdGhpcy5fbWF4cGluZ3MgKVxuXHRcdFx0cmV0dXJuIHRoaXMuX29udGltZW91dCgpXG5cdFx0bGV0IGlkID0gYCR7IE1hdGgucmFuZG9tKCkgfWBcblx0XHR0aGlzLl9xLnNlbmQoIHsgd2hhdDogYHBpbmdgLCBwaW5nOiBpZCB9IClcblx0XHR0aGlzLl9waW5nc1sgaWQgXSA9IHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKCBpZC5yZWQgKVxuXHRcdFx0dGhpcy5fb250aW1lb3V0KClcblx0XHR9LCB0aGlzLl90aW1lb3V0IClcblx0XHQrK3RoaXMuX2NvdW50XG5cdH1cblx0X29udGltZW91dCgpIHtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy5kb2Vycm9yKCBuZXcgRXJyb3IoIGB0aW1lb3V0YCApIClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLmNsb3NlKClcblx0XHR9XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIHEsIG9wdGlvbnMgKSA9PiBuZXcgUGluZ1BvbmdKU09OKCBxLCBvcHRpb25zIClcbm1vZHVsZS5leHBvcnRzLnNpbGVudCA9IHEgPT4gbmV3IFBvbmdKU09OKCBxIClcbiIsImNsYXNzIFdlYlF1ZXVlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5vbm9wZW4gPSBudWxsXG5cdFx0dGhpcy5vbmNsb3NlID0gbnVsbFxuXHRcdHRoaXMub25tZXNzYWdlID0gbnVsbFxuXHRcdHRoaXMub25lcnJvciA9IG51bGxcblx0XHR0aGlzLl9jbG9zZWQgPSBmYWxzZVxuXHRcdHRoaXMuX29wZW5lZCA9IGZhbHNlXG5cdH1cblx0ZG9vcGVuKCkge1xuXHRcdGlmICggIXRoaXMuX2Nsb3NlZCAmJiB0aGlzLm9ub3BlbiAmJiAhdGhpcy5fb3BlbmVkICkge1xuXHRcdFx0dGhpcy5fb3BlbmVkID0gdHJ1ZVxuXHRcdFx0dGhpcy5vbm9wZW4oKVxuXHRcdH1cblx0fVxuXHRkb2Nsb3NlKCkge1xuXHRcdGlmKCB0aGlzLm9uY2xvc2UgKVxuXHRcdFx0dGhpcy5vbmNsb3NlKClcblx0fVxuXHRkb21lc3NhZ2UoIG1lc3NhZ2UgKSB7XG5cdFx0aWYgKCAhdGhpcy5fY2xvc2VkICYmIHRoaXMub25tZXNzYWdlICkge1xuXHRcdFx0aWYgKCAhdGhpcy5fb3BlbmVkIClcblx0XHRcdFx0dGhpcy5kb29wZW4oKVxuXHRcdFx0dGhpcy5vbm1lc3NhZ2UoIG1lc3NhZ2UgKVxuXHRcdH1cblx0fVxuXHRkb2Vycm9yKCBlcnJvciApIHtcblx0XHRpZiAoIHRoaXMub25lcnJvciApXG5cdFx0XHR0aGlzLm9uZXJyb3IoIGVycm9yIClcblx0XHRlbHNlXG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKCAoKSA9PiB7IHRocm93IGVycm9yIH0gKVxuXHR9XG5cdF9zZW5kKCkge31cblx0c2VuZCggbWVzc2FnZSApIHtcblx0XHRpZiAoICF0aGlzLl9jbG9zZWQgKVxuXHRcdFx0dGhpcy5fc2VuZCggbWVzc2FnZSApXG5cdH1cblx0X2Nsb3NlKCkge31cblx0Y2xvc2UoKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0cmV0dXJuXG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuX2Nsb3NlKClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlXG5cdFx0XHR0aGlzLmRvY2xvc2UoKVxuXHRcdH1cblx0fVxuXHRwaXBlRnJvbSggcSApIHtcblx0XHRxLm9ub3BlbiA9ICgpID0+IHRoaXMuZG9vcGVuKClcblx0XHRxLm9uY2xvc2UgPSAoKSA9PiB0aGlzLmNsb3NlKClcblx0XHRxLm9uZXJyb3IgPSBlcnJvciA9PiB0aGlzLmRvZXJyb3IoIGVycm9yIClcblx0XHRxLm9ubWVzc2FnZSA9IG1lc3NhZ2UgPT4gdGhpcy5kb21lc3NhZ2UoIG1lc3NhZ2UgKVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViUXVldWVcbiIsImNsYXNzIFdlYlNvY2tldFRvSlNPTiBleHRlbmRzIHJlcXVpcmUoIGBXZWJRdWV1ZWAgKSB7XG5cdGNvbnN0cnVjdG9yKCB3cyApIHtcblx0XHRzdXBlcigpXG5cdFx0dGhpcy5fd3MgPSB3c1xuXHRcdHRoaXMucGlwZUZyb20oIHdzIClcblx0XHR3cy5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG5cdFx0XHRsZXQgbWVzc2FnZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bWVzc2FnZSA9IEpTT04ucGFyc2UoIFN0cmluZyggZXZlbnQuZGF0YSApIClcblx0XHRcdH1cblx0XHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRvZXJyb3IoIGVycm9yIClcblx0XHRcdH1cblx0XHRcdHRoaXMuZG9tZXNzYWdlKCBtZXNzYWdlIClcblx0XHR9XG5cdH1cblx0dW53aXNlKCkge1xuXHRcdGxldCB3cyA9IHRoaXMuX3dzXG5cdFx0dGhpcy5fd3MgPSBudWxsXG5cdFx0d3Mub25vcGVuID0gbnVsbFxuXHRcdHdzLm9uY2xvc2UgPSBudWxsXG5cdFx0d3Mub25lcnJvciA9IG51bGxcblx0XHR3cy5vbm1lc3NhZ2UgPSBudWxsXG5cdFx0cmV0dXJuIHdzXG5cdH1cblx0X3NlbmQoIG1lc3NhZ2UgKSB7IHRoaXMuX3dzLnNlbmQoIEpTT04uc3RyaW5naWZ5KCBtZXNzYWdlICkgKSB9XG5cdF9jbG9zZSgpIHtcblx0XHR0aGlzLl93cy5vbmNsb3NlID0gbnVsbFxuXHRcdHRoaXMuX3dzLmNsb3NlKClcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdzID0+IG5ldyBXZWJTb2NrZXRUb0pTT04oIHdzIClcbiIsIi8qXG5cblRPRE8gMjAxNS4wMy4yNSDQoyDQotCXINC90LUg0LHRi9C70L46INCg0Y3QtNCw0LPQsNCy0LDQvdGM0L3QtSDQvNC10YHRhtCw0Z4g0LzQsNCz0YfRi9C80LAg0L/QsNGC0YDRjdCx0L3QsNC1INGC0L7Qu9GM0LrRliDQu9Cw0LrQsNC70YzQvdCwINC3INCw0YHQvtCx0L3Ri9C80ZYg0LrQsNC80LDQvdC00LDQvNGWINC80LXQvdGOIFwi0LfQsNGF0LDQstCw0YbRjCDQtNC70Y8g0LfQvNC+0Z7Rh9Cw0L3QsNCz0LBcIiDRliBcItC30LDQs9GA0YPQt9GW0YbRjCDQvdCwINGe0YHQtSDQv9GA0YvQu9Cw0LTRi1wiLlxuXG4qL1xubGV0IEpTT05sb2NhbCA9IHJlcXVpcmUoIGBKU09ObG9jYWxgIClcbmxldCBsdSA9IHJlcXVpcmUoIGBsb2NhbFV0aWxzYCApXG5sZXQgcmEgPSByZXF1aXJlKCBgcmFgIClcbmxldCBsb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5sZXQgVUlEID0gcmVxdWlyZSggYHVpZGAgKVxubGV0IGh0dHBDbGllbnQgPSByZXF1aXJlKCBgaHR0cENsaWVudGAgKVxubGV0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoIGBldmVudHNgICkuRXZlbnRFbWl0dGVyIHx8IHJlcXVpcmUoIGBldmVudHNgIClcbi8vIGxldCBkZXZpY2VBY3Rpb25zID0gcmVxdWlyZSggYG5ldHJvL2RldmljZUFjdGlvbnNgIClcbmxldCBXZWJTb2NrZXRUb0pTT04gPSByZXF1aXJlKCBgV2ViU29ja2V0VG9KU09OYCApXG5sZXQgUGluZ1BvbmdKU09OID0gcmVxdWlyZSggYFBpbmdQb25nSlNPTmAgKVxubGV0IGRldmRiID0gcmVxdWlyZSggYGRldmRiYCApXG5cbmxldCBXZWJTb2NrZXRSZXRyeSA9IDEwMDBcbmxldCBzYXZlUGxhY2VzVGltZW91dCA9IDMwMDBcblxuY2xhc3MgUGVyc2lzdGVudFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cblx0Y29uc3RydWN0b3IgKCB1cmwgKSB7XG5cdFx0c3VwZXIoKVxuXHRcdHRoaXMuY29ubmVjdGVkID0gZmFsc2Vcblx0XHR0aGlzLmNsb3NlZCA9IGZhbHNlXG5cdFx0dGhpcy5fd3MgPSBudWxsXG5cdFx0dGhpcy5fc2hlZHVsZWRDcmVhdGluZyA9IG51bGxcblx0XHR0aGlzLl9maXJzdCA9IHRydWVcblx0XHR0aGlzLl9sYXN0Q2xvc2UgPSAtSW5maW5pdHlcblx0XHR0aGlzLnVybCA9IHVybFxuXHRcdHRoaXMudXNlciA9IHVuZGVmaW5lZFxuXHRcdHRoaXMua2V5ID0gdW5kZWZpbmVkXG5cdFx0Ly8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIGBfYXBwbGljYXRpb25fcmVzdW1lZGAgKVxuXHR9XG5cblx0Z2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuX3VybCB9XG5cdHNldCB1cmwoIHVybCApIHtcblx0XHR0aGlzLl91cmwgPSB1cmxcblx0XHR0aGlzLl9jcmVhdGVIYW5kbGUoKVxuXHR9XG5cblx0X3NldENvbm5lY3RlZCggdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSAhIXZhbHVlXG5cdFx0aWYgKCB0aGlzLmNvbm5lY3RlZCAhPSB2YWx1ZSApIHtcblx0XHRcdHRoaXMuY29ubmVjdGVkID0gdmFsdWVcblx0XHRcdHRoaXMuZW1pdCggYGNoYW5nZWRgLCB2YWx1ZSApXG5cdFx0fVxuXHR9XG5cblx0X2NsZWFySGFuZGxlKCkge1xuXHRcdGlmICggdGhpcy5fd3MgKSB7XG5cdFx0XHR0aGlzLl93cy5vbmNsb3NlID0gbnVsbFxuXHRcdFx0dGhpcy5fd3MuY2xvc2UoKVxuXHRcdFx0dGhpcy5fd3MgPSBudWxsXG5cdFx0XHR0aGlzLl9zZXRDb25uZWN0ZWQoIGZhbHNlIClcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9zaGVkdWxlZENyZWF0aW5nICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLl9zaGVkdWxlZENyZWF0aW5nIClcblx0XHRcdHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgPSBudWxsXG5cdFx0fVxuXHR9XG5cblx0X2Vuc3VyZUhhbmRsZSgpIHtcblx0XHRpZiAoICF0aGlzLl93cyApXG5cdFx0XHR0aGlzLl9jcmVhdGVIYW5kbGUoKVxuXHR9XG5cblx0X2NyZWF0ZUhhbmRsZSgpIHtcblx0XHR0aGlzLl9jbGVhckhhbmRsZSgpXG5cdFx0aWYgKCAhdGhpcy5fdXJsIClcblx0XHRcdHJldHVyblxuXHRcdHRoaXMuX3dzID0gUGluZ1BvbmdKU09OKCBXZWJTb2NrZXRUb0pTT04oIG5ldyBXZWJTb2NrZXQoIHRoaXMuX3VybCApICkgKVxuXHRcdHRoaXMuX3dzLm9uY2xvc2UgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl93cyA9IG51bGxcblx0XHRcdHRoaXMuX3NldENvbm5lY3RlZCggZmFsc2UgKVxuXHRcdFx0dGhpcy5lbWl0KCBgcGF1c2VgIClcblx0XHRcdGlmICggIXRoaXMuY2xvc2VkICkge1xuXHRcdFx0XHRsZXQgdCA9IHRoaXMuX2xhc3RDbG9zZVxuXHRcdFx0XHR0aGlzLl9sYXN0Q2xvc2UgPSBEYXRlLm5vdygpXG5cdFx0XHRcdHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgPSBzZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5fY3JlYXRlSGFuZGxlKClcblx0XHRcdFx0fSwgTWF0aC5tYXgoIDAsIFdlYlNvY2tldFJldHJ5IC0gKCB0aGlzLl9sYXN0Q2xvc2UgLSB0ICkgKSApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3dzLm9uZXJyb3IgPSBlcnJvciA9PiB7XG5cdFx0XHR0aGlzLmVtaXQoIGBlcnJvcmAsIGVycm9yIClcblx0XHR9XG5cdFx0dGhpcy5fd3Mub25vcGVuID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5fc2V0Q29ubmVjdGVkKCB0cnVlIClcblx0XHRcdGlmICggdGhpcy5fZmlyc3QgKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0ID0gZmFsc2Vcblx0XHRcdFx0dGhpcy5lbWl0KCBgb3BlbmAgKVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbWl0KCBgcmVzdW1lYCApXG5cdFx0fVxuXHRcdHRoaXMuX3dzLm9ubWVzc2FnZSA9IG1lc3NhZ2UgPT4ge1xuXHRcdFx0dGhpcy5lbWl0KCBgbWVzc2FnZWAsIG1lc3NhZ2UgKVxuXHRcdH1cblx0fVxuXG5cdHJlaW5pdCgpIHtcblx0XHR0aGlzLl93cyAmJiB0aGlzLl93cy5jbG9zZSgpXG5cdH1cblxuXHRzZW5kKCBkYXRhICkge1xuXHRcdHRoaXMuX2Vuc3VyZUhhbmRsZSgpXG5cdFx0aWYgKCAhKCB0aGlzLl93cyAmJiB0aGlzLmNvbm5lY3RlZCAmJiAhdGhpcy5jbG9zZWQgKSApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBzb2NrZXQgaXMgbm90IG9wZW5gIClcblx0XHR0aGlzLl93cy5zZW5kKCBkYXRhIClcblx0fVxuXG5cdGRlbGV0ZSgpIHtcblx0XHR0aGlzLmNsb3NlKClcblx0fVxuXG5cdGNsb3NlKCkge1xuXHRcdHRoaXMuY2xvc2VkID0gdHJ1ZVxuXHRcdHRoaXMuX2NsZWFySGFuZGxlKClcblx0XHR0aGlzLmVtaXQoIGBjbG9zZWAgKVxuXHR9XG5cblx0YXNrKCBxdWVzdGlvbiApIHsgcmV0dXJuIGNvLmdvY2FsbCggZnVuY3Rpb24qICgpIHtcblx0XHRsZXQgaWQgPSBVSUQoKVxuXHRcdHRoaXMuc2VuZCggeyBpZCwgcXVlc3Rpb24gfSApXG5cdFx0bGV0IG1lc3NhZ2UgPSB5aWVsZCB0aGlzLmdldCggaWQgKVxuXHRcdGlmICggbWVzc2FnZS5lcnJvciApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1lc3NhZ2UuZXJyb3IgKVxuXHRcdHJldHVybiBtZXNzYWdlLmFuc3dlclxuXHR9LCB0aGlzICkgfVxuXG5cdGdldCggcHJlZGljYXRlLCB0aW1lb3V0ICkgeyByZXR1cm4gY28uZ29jYWxsKCBmdW5jdGlvbiogKCkge1xuXHRcdGlmICggdHlwZW9mIHByZWRpY2F0ZSA9PSBgc3RyaW5nYCB8fCB0eXBlb2YgcHJlZGljYXRlID09IGBudW1iZXJgICkge1xuXHRcdFx0bGV0IGlkID0gcHJlZGljYXRlXG5cdFx0XHRwcmVkaWNhdGUgPSBtc2cgPT4gbXNnLmlkID09IGlkXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhKCB0eXBlb2YgcHJlZGljYXRlID09IGBmdW5jdGlvbmAgKSApIHtcblx0XHRcdGxldCBwID0gcHJlZGljYXRlXG5cdFx0XHRwcmVkaWNhdGUgPSBtc2cgPT4gbG9kYXNoLmV2ZXJ5KCBwLCAoIHZhbHVlLCBrZXkgKSA9PiBtc2dbIGtleSBdID09IHZhbHVlIClcblx0XHR9XG5cdFx0bGV0IHsgZXZlbnQsIGRhdGEgfSA9IHlpZWxkIGNvLnJlY2VpdmUoIHRoaXMsIHsgY2xvc2U6IHRydWUsIG1lc3NhZ2U6IHByZWRpY2F0ZSwgdGltZW91dDogdGltZW91dCB9IClcblx0XHRpZiAoIGV2ZW50ID09IGBtZXNzYWdlYCApXG5cdFx0XHRyZXR1cm4gZGF0YVxuXHRcdHRocm93IG5ldyBFcnJvciggXCJ0aW1lb3V0XCIgKVxuXHR9LCB0aGlzICkgfVxufVxuXG5mdW5jdGlvbiB3c0NsaWVudCggYXBwLCB1cmwgKSB7XG5cdGxldCB3cyA9IG5ldyBQZXJzaXN0ZW50V2ViU29ja2V0KClcblx0cmEoICgpID0+IHdzLnVybCA9IGFwcC5sb2NhbE1vZGVtICYmICggYXBwLmxvY2FsTW9kZW0gKyB1cmwgKSApXG5cdHdzLmFjdGl2ZSA9IHJhLm9uKCB3cywgWyBgcGF1c2VgLCBgcmVzdW1lYCBdLCAoKSA9PiB3cy5jb25uZWN0ZWQgKVxuXHRyZXR1cm4gd3Ncbn1cblxuZnVuY3Rpb24gd3NKU09OY2xpZW50KCBhcHAsIHVybCApIHtcblxuXHRsZXQganNvbiA9IEpTT05sb2NhbCggdXJsLCB7IHVpZDogbnVsbCB9IClcblx0bGV0IHdzID0gd3NDbGllbnQoIGFwcCwgdXJsIClcblx0bGV0IGluaXQgPSAoKSA9PiB3cy5zZW5kKCB7IHdoYXQ6IGBpbml0YCwgaWQ6IGpzb24udWlkIH0gKVxuXHRsZXQgcmVzb2x2ZXJzID0ge31cblxuXHRsZXQgZG9FcnJvciA9ICggbWVzc2FnZSwgZGF0YSApID0+IHsgdGhyb3cgbmV3IEVycm9yKCBgd3NKU09OY2xpZW50OiAkeyBtZXNzYWdlIH06ICR7IEpTT04uc3RyaW5naWZ5KCBkYXRhICkgfWAgKSB9XG5cblx0bHUub24oIHdzLCB7XG5cdFx0cmVzdW1lOiBpbml0LFxuXHRcdG1lc3NhZ2UoIG1lc3NhZ2UgKSB7IHN3aXRjaCAoIG1lc3NhZ2Uud2hhdCApIHtcblx0XHRcdGNhc2UgYGVycm9yYDpcblx0XHRcdFx0ZG9FcnJvciggYGVycm9yIGZyb20gc2VydmVyYCwgbWVzc2FnZSApXG5cdFx0XHRjYXNlIGBzYXZlZGA6IHtcblx0XHRcdFx0bGV0IHJlc29sdmUgPSByZXNvbHZlcnNbIG1lc3NhZ2UubWVzc2FnZUlkIF1cblx0XHRcdFx0ZGVsZXRlIHJlc29sdmVyc1sgbWVzc2FnZS5tZXNzYWdlSWQgXVxuXHRcdFx0XHRyZXNvbHZlICYmIHJlc29sdmUoKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGNhc2UgYGRhdGFgOiB7XG5cdFx0XHRcdGlmICggbWVzc2FnZS5wYXJ0aWFsICYmIG1lc3NhZ2UucHJldmlvdXMgIT0ganNvbi51aWQgKVxuXHRcdFx0XHRcdGluaXQoKVxuXHRcdFx0XHRlbHNlIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBtZXNzYWdlLCBgZGF0YWAgKSApXG5cdFx0XHRcdFx0anNvbi5hc3NpZ24oIGx1LmFwcGx5RGlmZigganNvbi52YWx1ZU9mKCksIG1lc3NhZ2UuZGF0YSwgbWVzc2FnZS5wYXJ0aWFsICkgKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGRvRXJyb3IoIGB1bmtub3duIG1lc3NhZ2UgZnJvbSBzZXJ2ZXJgLCBtZXNzYWdlIClcblx0XHR9IH0sXG5cdFx0ZXJyb3IoKSB7XG5cdFx0XHRhcHAub25DcmVkZW50aWFscygpXG5cdFx0fSxcblx0fSApXG5cblx0ZnVuY3Rpb24gZG9SZWplY3QoIG1lc3NhZ2VJZCwgcmVqZWN0ICkge1xuXHRcdGRlbGV0ZSByZXNvbHZlcnNbIG1lc3NhZ2VJZCBdXG5cdFx0cmVqZWN0KClcblx0fVxuXG5cdGxldCBzYXZlID0gKCBwYXJ0aWFsLCBkYXRhICkgPT4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdGxldCBtZXNzYWdlSWQgPSBVSUQoKVxuXHRcdHJlc29sdmVyc1sgbWVzc2FnZUlkIF0gPSByZXNvbHZlXG5cdFx0d3Muc2VuZCggeyB3aGF0OiBgc2F2ZWAsIGRhdGE6IHBhcnRpYWwgPyBkYXRhIDogT2JqZWN0LmFzc2lnbiggeyBfX3BhcnRpYWxfXzogZmFsc2UgfSwgZGF0YSB8fCB7fSApLCBtZXNzYWdlSWQgfSApXG5cdFx0c2V0VGltZW91dCggZG9SZWplY3QsIHNhdmVQbGFjZXNUaW1lb3V0LCBtZXNzYWdlSWQsIHJlamVjdCApXG5cdH0gKVxuXG5cdHJldHVybiB7XG5cdFx0ZGF0YToganNvbi5nZXRSZWFkT25seSgpLFxuXHRcdGFjdGl2ZTogd3MuYWN0aXZlLFxuXHRcdHNlbmQoIGRhdGEgKSB7IHJldHVybiBzYXZlKCBmYWxzZSwgZGF0YSApIH0sXG5cdFx0dXBkYXRlKCBkYXRhICkgeyByZXR1cm4gc2F2ZSggdHJ1ZSwgZGF0YSApIH0sXG5cdFx0ZGVsZXRlKCkgeyB3cy5jbG9zZSgpIH0sXG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBpZCA9PiB7XG5cbmxldCBsb2NhbERlZmF1bHRzID0ge1xuXHRhY3RpdmVEZXZpY2VJZDogYGAsXG5cdGxhbmd1YWdlOiBgcnVgLFxuXHRpY29uU2l6ZTogNDAsIC8vIG1pbGxpbWV0ZXJzXG5cdGxhYmVsczogdHJ1ZSxcblx0cGxhY2VzUGFnZXM6IHtcblx0fSxcbn1cblxubGV0IGxvY2FsID0gSlNPTmxvY2FsKCBhcHBpZCwgbG9jYWxEZWZhdWx0cyApXG5cbmxldCBhcHAgPSByYS5jbGVhbigge1xuXG5cdGdldE1lc3NhZ2UoIGRhdGEgKSB7XG5cdFx0bGV0IGxhbmd1YWdlID0gbG9jYWwubGFuZ3VhZ2UgfHwgYHJ1YFxuXHRcdHJldHVybiBbIGxhbmd1YWdlLCBgcnVgLCBgZW5gLCBgYnlgIF1cblx0XHRcdC5maWx0ZXIoIGwgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkYXRhLCBsICkgKVxuXHRcdFx0Lm1hcCggbCA9PiBkYXRhWyBsIF0gKVxuXHRcdFx0WyAwIF1cblx0fSxcblxuXHRwYWdlV2lkdGg6IDIsXG5cdHBhZ2VIZWlnaHQ6IDMsXG5cdHBhZ2VTdGFydGluZzogZmFsc2UsXG5cdGRpYWxvZzogYGAsXG5cdGVkaXRpbmc6IGZhbHNlLFxuXHRtb3Zpbmc6IDAsXG5cdGhpc3Rvcnk6IFtdLFxuXHRtZW51RWxlbWVudDogbnVsbCwgLy8gZGl2XG5cblx0bG9nZ2VkaW46IGZhbHNlLFxuXHQvLyBjcmVkZW50aWFsczogMSxcblx0b25DcmVkZW50aWFscygpIHtcblx0XHR0aGlzLmxvZ2dlZGluID0gZmFsc2Vcblx0fSxcblxuXHRnbyggdG8sIHBhdGggKSB7XG5cdFx0aWYgKCAhdG8gKVxuXHRcdFx0cmV0dXJuXG5cdFx0bGV0IGggPSB0aGlzLmhpc3Rvcnlcblx0XHRsZXQgYSA9IGxvY2FsLmFjdGl2ZURldmljZUlkXG5cdFx0bGV0IGxcblx0XHR3aGlsZSAoIGgubGVuZ3RoICYmICggbCA9IGhbIGgubGVuZ3RoIC0gMSBdLCBsID09IHRvIHx8IGwgPT0gYSB8fCBwYXRoICYmIHBhdGguaW5kZXhPZiggbCApID49IDAgKSApXG5cdFx0XHRoLnBvcCgpXG5cdFx0aWYgKCBhICE9IHRvIClcblx0XHRcdGgucHVzaCggYSApXG5cdFx0cGF0aCAmJiBoLnB1c2goIC4uLnBhdGguZmlsdGVyKCBpZCA9PiBpZCAhPSB0aGlzLm1haW4gKS5yZXZlcnNlKCkgKVxuXHRcdGxvY2FsLmFjdGl2ZURldmljZUlkID0gdG9cblx0XHR0aGlzLmRpYWxvZyA9IGBgXG5cdH0sXG5cblx0YmFjaygpIHtcblx0XHR3aGlsZSAoIHRoaXMuaGlzdG9yeS5sZW5ndGggKSB7XG5cdFx0XHRsZXQgZGV2aWNlID0gdGhpcy5oaXN0b3J5LnBvcCgpXG5cdFx0XHRpZiAoIHRoaXMuZ2V0RGV2aWNlKCBkZXZpY2UgKSApXG5cdFx0XHRcdHJldHVybiBsb2NhbC5hY3RpdmVEZXZpY2VJZCA9IGRldmljZVxuXHRcdH1cblx0XHRsb2NhbC5hY3RpdmVEZXZpY2VJZCA9IHRoaXMubWFpblxuXHR9LFxuXG5cdHdpbmRvd1NpemU6IHJlcXVpcmUoIGB3aW5kb3dTaXplYCApLmdldFJlYWRPbmx5KCksXG5cblx0cGxhY2VzU2hpZnRzOiB7XG5cdH0sXG5cblx0Ly8gVE9ETyDQsNCx0L3QsNGe0LvRj9GG0YwhISDRltC90YLRjdGA0YTQtdC50YHRiyDRj9C6INGC0L7Qu9GM0LrRliDRj9C90Ysg0Z4g0LzQsNC00Y3QvNCwINCw0LHQvdCw0Z7Qu9GP0Y7RhtGG0LAhIVxuXHRnZXQgbW9kZW1Mb2NhdGlvbnMoKSB7IHJldHVybiBodHRwQ2xpZW50LmdldCggYC9tb2RlbV9sb2NhdGlvbnNgICkgfSxcblxuXHRnZXQgbG9jYWxNb2RlbSgpIHsgcmV0dXJuIHRoaXMubW9kZW1Mb2NhdGlvbnMgPyB0aGlzLm1vZGVtTG9jYXRpb25zWyAwIF0udXJsLnJlcGxhY2UoIC9eaHR0cCg/PXM/XFw6XFwvXFwvKS8sIGB3c2AgKSA6IGBgIH0sXG5cblx0Z2V0IGRvTG9naW4oKSB7IHJldHVybiBmdW5jdGlvbiogKCkge1xuXHRcdHdoaWxlICggIXRoaXMubG9nZ2VkaW4gJiYgdGhpcy5tb2RlbUxvY2F0aW9ucyApIHtcblx0XHRcdGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgc2NyaXB0YCApXG5cdFx0XHRzY3JpcHQuc3JjID0gYCR7IHRoaXMubW9kZW1Mb2NhdGlvbnNbIDAgXS51cmwgfS9sb2dpbj8keyBVSUQoKSB9YFxuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggc2NyaXB0IClcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHlpZWxkIHNjcmlwdFxuXHRcdFx0XHQvLyB5aWVsZCBQcm9taXNlLnJhY2UoIFsgY28ucHJvbWlzZSggc2NyaXB0ICksIGNvLnRpbWVvdXQoIDE1MDAwICkgXSApXG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0XHRMT0coIGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gbG9naW46ICR7IGVycm9yICYmIGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IgfWAgKVxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApXG5cdFx0XHRcdHlpZWxkIGNvLnNsZWVwKCAzMDAgKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIHNjcmlwdCApXG5cdFx0XHR9XG5cdFx0XHRMT0coIGBsb2dnZWQgaW5gIClcblx0XHRcdHJhLmRldGFjaCggKCkgPT4gdGhpcy5sb2dnZWRpbiA9IHRydWUgKVxuXHRcdFx0Ly8gVE9ETzogdGhpcyBjb2RlIHdpdGggYW4gWE1MSHR0cFJlcXVlc3QgZG9lcyBub3Qgd29yayBvbiBpUGhvbmUgOigoKFxuXHRcdFx0Ly8gbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdFxuXHRcdFx0Ly8geGhyLm9wZW4oIGBQT1NUYCwgdGhpcy5tb2RlbUxvY2F0aW9uc1sgMCBdLnVybCArIGAvbG9naW5gLCB0cnVlLCBgbmVyb2AsIGAxMjNgIClcblx0XHRcdC8vIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG5cdFx0XHQvLyB0cnkge1xuXHRcdFx0Ly8gXHR4aHIuc2VuZCgpXG5cdFx0XHQvLyBcdHlpZWxkIHhoclxuXHRcdFx0Ly8gXHQvLyBhbGVydCggeGhyLnN0YXR1cyApXG5cdFx0XHQvLyBcdExPRyggKCBgYCArIHhoci5zdGF0dXMgKS5ibHVlIClcblx0XHRcdC8vIFx0aWYgKCB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDw9IDI5OSApXG5cdFx0XHQvLyBcdFx0cmV0dXJuIHJhLmRldGFjaCggKCkgPT4gdGhpcy5sb2dnZWRpbiA9IHRydWUgKVxuXHRcdFx0Ly8gfVxuXHRcdFx0Ly8gY2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdC8vIFx0Ly8gYWxlcnQoIGBFUlJgIClcblx0XHRcdC8vIFx0Y29uc29sZS5sb2coIGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gbG9naW5gLCBlcnJvciApXG5cdFx0XHQvLyB9XG5cdFx0XHQvLyB5aWVsZCBjby5zbGVlcCggMzAwIClcblx0XHR9XG5cdH0uY2FsbCggdGhpcyApIH0sXG5cblx0bG9naW4oIG5hbWUsIHB3ZCApIHt9LFxuXG5cdGdldCBzZXJ2ZXJEZXZpY2VzKCkgeyByZXR1cm4gd3NKU09OY2xpZW50KCB0aGlzLCBgL2RhdGFiYXNlYCApIH0sXG5cdGdldCBsb2NhbERldmljZXMoKSB7IHJldHVybiByYS5kYiggdGhpcy5zZXJ2ZXJEZXZpY2VzLmRhdGEsIGRhdGEgPT4gdGhpcy5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggZGF0YSApICkgfSxcblx0Z2V0IGRldmljZXMoKSB7IHJldHVybiB0aGlzLmxvY2FsRGV2aWNlcy52YWx1ZU9mKCkgfHwge30gfSxcblxuXHRnZXQgY29tbWFuZHMoKSB7IHJldHVybiB3c0NsaWVudCggdGhpcywgYC9jb21tYW5kc2AgKSB9LFxuXHRnZXQgY29ubmVjdGVkVG9TZXJ2ZXIoKSB7IHJldHVybiB0cnVlXG5cdFx0JiYgdGhpcy5zZXJ2ZXJEZXZpY2VzLmFjdGl2ZS52YWx1ZU9mKClcblx0XHQmJiB0aGlzLmNvbW1hbmRzLmFjdGl2ZS52YWx1ZU9mKClcblx0fSxcblxuXHRnZXQgbWFpbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kZXZpY2VzLm1haW5cblx0fSxcblxuXHRnZXREZXZpY2UoIGRldmljZUlkICkge1xuXHRcdHJldHVybiB0aGlzLmRldmljZXMuY29udGVudCAmJiB0aGlzLmRldmljZXMuY29udGVudFsgbHUudmFsdWVPZiggZGV2aWNlSWQgKSBdXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZURldmljZUlkKCkge1xuXHRcdHJldHVybiBsb2NhbC5hY3RpdmVEZXZpY2VJZCB8fCB0aGlzLm1haW5cblx0fSxcblxuXHRnZXQgYWN0aXZlRGV2aWNlKCkge1xuXHRcdHJldHVybiB0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZUNvbnRlbnRJZHMoKSB7XG5cdFx0bGV0IGRldmljZSA9IHRoaXMuYWN0aXZlRGV2aWNlXG5cdFx0cmV0dXJuIHJhLkFycmF5KCBsb2Rhc2gua2V5cyggZGV2aWNlICYmIGRldmljZS5jb250ZW50ICkuc29ydCggKCBhLCBiICkgPT4gZGV2aWNlLmNvbnRlbnRbIGEgXS5pbmRleCAtIGRldmljZS5jb250ZW50WyBiIF0uaW5kZXggKSApXG5cdH0sXG5cblx0Z2V0IGFjdGl2ZUNvbnRlbnQoKSB7XG5cdFx0cmV0dXJuIHJhLkFycmF5KCB0aGlzLmFjdGl2ZUNvbnRlbnRJZHMubWFwKCB0aGlzLmdldERldmljZSApIClcblx0fSxcblxuXHRsaW5raW5nUGxhY2VJZDogbnVsbCxcblx0Z2V0IGNsZWFyTGlua2luZ1BsYWNlSWQoKSB7XG5cdFx0aWYgKCB0aGlzLmRpYWxvZyAhPSBgQXNrVG9MaW5rRGV2aWNlYCAmJiB0aGlzLmRpYWxvZyAhPSBgQXNrSWZEZXZpY2VIYXNCZWVuTGlua2VkYCApXG5cdFx0XHR0aGlzLmxpbmtpbmdQbGFjZUlkID0gbnVsbFxuXHR9LFxuXG5cdGdldCBjaGVja0lmVGltZVRvR29CYWNrKCkge1xuXHRcdC8vIGx1LnZhbHVlT2YoIHRoaXMucGxhY2VzIClcblx0XHRpZiAoICF0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApIClcblx0XHRcdHRoaXMuYmFjaygpXG5cdH0sXG5cblx0Z2V0IGNhcHRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWVzc2FnZSggdGhpcy5nZXREZXZpY2UoIHRoaXMuYWN0aXZlRGV2aWNlSWQgKSApIHx8IHRoaXMubWVzc2FnZSggYGZhdm9yaXRlc2AgKVxuXHR9LFxuXG5cdGdldCBkZXZpY2VUeXBlKCkge1xuXHRcdGxldCByZXQgPSB0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApXG5cdFx0aWYgKCAhcmV0IClcblx0XHRcdHJldCA9IHRoaXMuZ2V0RGV2aWNlKCB0aGlzLm1haW4gKVxuXHRcdHJldHVybiAoIHJldCAmJiByZXQudHlwZSApIHx8IGBwbGFjZWBcblx0fSxcblxuXHRnZXQgZGV2aWNlSWRzKCkge1xuXHRcdHJldHVybiByYS5BcnJheSggbG9kYXNoLmtleXMoIHRoaXMuZGV2aWNlcy5jb250ZW50ICkuc29ydCgpIClcblx0fSxcblxuXHRnZXQgaW5pdGlhbExvYWRpbmcoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRldmljZXMudWlkXG5cdH0sXG5cblx0Z2V0IGluaXRpYWxpemVkKCkge1xuXHRcdHJldHVybiAhdGhpcy5pbml0aWFsTG9hZGluZyAmJiAhIXRoaXMuZGV2aWNlcy5tYWluXG5cdH0sXG5cblx0c2V0RGF0YWJhc2UoIGRldmljZXMgKSB7XG5cdFx0dGhpcy5zZXJ2ZXJEZXZpY2VzLnNlbmQoIGRldmljZXMgKVxuXHR9LFxuXG5cdHJlc2V0KCkge1xuXHRcdGxvY2FsLnJlc2V0KClcblx0XHR0aGlzLnNldERhdGFiYXNlKCB7IHVpZDogVUlEKCkgfSApXG5cdFx0dGhpcy5kaWFsb2cgPSBgYFxuXHRcdHRoaXMuZWRpdGluZyA9IGZhbHNlXG5cdFx0dGhpcy5oaXN0b3J5Lmxlbmd0aCA9IDBcblx0fSxcblxuXHRzZXRUZW1wbGF0ZSggdGVtcGxhdGUgKSB7XG5cdFx0Y29uc29sZS5sb2coIHRlbXBsYXRlIClcblx0XHRsZXQgZGV2aWNlcyA9IHtcblx0XHRcdHVpZDogVUlEKCksXG5cdFx0XHRjb250ZW50OiB7fSxcblx0XHR9XG5cdFx0ZnVuY3Rpb24gY29weSggdGVtcGxhdGUsIGRldmljZSApIHtcblx0XHRcdE9iamVjdC5rZXlzKCB0ZW1wbGF0ZSApLmZvckVhY2goIGtleSA9PlxuXHRcdFx0XHRrZXkgIT0gYGltYWdlYCAmJiAvLyBUT0RPOiAhISEhISEhIVxuXHRcdFx0XHRrZXkgIT0gYGNvbnRlbnRgICYmXG5cdFx0XHRcdGtleSAhPSBgdHlwZWAgJiZcblx0XHRcdFx0KCBkZXZpY2VbIGtleSBdID0gdGVtcGxhdGVbIGtleSBdIClcblx0XHRcdClcblx0XHRcdHJldHVybiBkZXZpY2Vcblx0XHR9XG5cdFx0ZnVuY3Rpb24gd2FsayggdGVtcGxhdGUsIGlkICkge1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5jb250ZW50IHx8IHRlbXBsYXRlLnR5cGUgPT0gYHBsYWNlYCApIHtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSB7fVxuXHRcdFx0XHRkZXZpY2VzLmNvbnRlbnRbIGlkIF0gPSBjb3B5KCB0ZW1wbGF0ZSwgeyB0eXBlOiBgcGxhY2VgLCBjb250ZW50OiBjb250ZW50IH0gKVxuXHRcdFx0XHRsZXQgaW5kZXggPSAwXG5cdFx0XHRcdHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5mb3JFYWNoKCBwID0+XG5cdFx0XHRcdFx0Y29udGVudFsgd2FsayggcCwgVUlEKCkgKSBdID0geyBpbmRleDogaW5kZXgrKyB9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkZXZpY2VzLmNvbnRlbnRbIGlkIF0gPSBjb3B5KCB0ZW1wbGF0ZSwgeyB0eXBlOiBgc2luZ2xlYCB9IClcblx0XHRcdH1cblx0XHRcdHJldHVybiBpZFxuXHRcdH1cblx0XHRkZXZpY2VzLm1haW4gPSB3YWxrKCB0ZW1wbGF0ZSwgVUlEKCkgKVxuXHRcdHRoaXMuc2V0RGF0YWJhc2UoIGRldmljZXMgKVxuXHR9LFxuXG5cdGdldCB0ZW1wbGF0ZXMoKSB7IHJldHVybiBmdW5jdGlvbiogKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4geWllbGQgaHR0cENsaWVudC5nZXQoIGAvdGVtcGxhdGVzYCApXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gZXJyb3Jcblx0XHR9XG5cdH0uY2FsbCggdGhpcyApIH0sXG5cblx0Z2V0IGFsbE1lc3NhZ2VzKCkgeyByZXR1cm4gZnVuY3Rpb24qICgpIHtcblx0XHRyZXR1cm4geWllbGQgaHR0cENsaWVudC5nZXQoIGAvbWVzc2FnZXNgIClcblx0fS5jYWxsKCB0aGlzICkgfSxcblxuXHRnZXQgbWVzc2FnZXMoKSB7XG5cdFx0bGV0IGFsbE1lc3NhZ2VzID0gdGhpcy5hbGxNZXNzYWdlc1xuXHRcdGlmICggYWxsTWVzc2FnZXMgPT0gbnVsbCApXG5cdFx0XHRyZXR1cm5cblx0XHRsZXQgcmV0ID0ge31cblx0XHRsZXQgbGFuZ3VhZ2UgPSBsb2NhbC5sYW5ndWFnZSB8fCBgcnVgXG5cdFx0bG9kYXNoLmZvck93biggYWxsTWVzc2FnZXMsICggdmFsdWUsIGtleSApID0+XG5cdFx0XHRyZXRbIGtleSBdID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB2YWx1ZSwgbGFuZ3VhZ2UgKSA/IHZhbHVlWyBsYW5ndWFnZSBdIDoga2V5IClcblx0XHRyZXR1cm4gcmV0XG5cdH0sXG5cblx0bWVzc2FnZSggaWQgKSB7XG5cdFx0bGV0IHJldCA9IHRoaXMubWVzc2FnZXMgJiYgdGhpcy5tZXNzYWdlc1sgaWQgXVxuXHRcdGlmICggcmV0ID09IG51bGwgKVxuXHRcdFx0cmV0ID0gaWRcblx0XHRyZXR1cm4gcmV0XG5cdH0sXG5cblx0bm90aWZpY2F0aW9uKCBtZXNzYWdlICkge1xuXHRcdC8vIGFsZXJ0KCBtZXNzYWdlIClcblx0fSxcblxuXHRzYXZlRGV2aWNlKCBkZXZpY2VJZCwgZGV2aWNlICkge1xuXHRcdGxldCBkaWZmID0gbHUubWFrZURpZmYoIHRoaXMuZ2V0RGV2aWNlKCBkZXZpY2VJZCApLCBkZXZpY2UgKVxuXHRcdHJldHVybiBkaWZmID09IG51bGwgPyBQcm9taXNlLnJlc29sdmUoKSA6IHRoaXMuc2VydmVyRGV2aWNlcy51cGRhdGUoIHsgY29udGVudDogeyBbIGRldmljZUlkIF06IGRpZmYgfSB9IClcblx0fSxcblxuXHRuZXdJbmRleCggaWNvbklkICkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyggdGhpcy5nZXREZXZpY2UoIGljb25JZCApLmNvbnRlbnQgfHwge30gKS5sZW5ndGggKyAxXG5cdH0sXG5cblx0bGlua0l0ZW0oIGljb25JZCwgaXRlbUlkLCBleHRyYSApIHsgcmV0dXJuIGNvLmdvY2FsbCggZnVuY3Rpb24qICgpIHtcblx0XHRpZiAoIGljb25JZCA9PSBpdGVtSWQgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbm5vdCBsaW5rIHBsYWNlIHRvIGl0c2VsZlwiIClcblx0XHRsZXQgcGxhY2UgPSB0aGlzLmdldERldmljZSggaWNvbklkIClcblx0XHRsZXQgZGV2aWNlID0gdGhpcy5nZXREZXZpY2UoIGl0ZW1JZCApXG5cdFx0aWYgKCBwbGFjZS50eXBlID09IGBncm91cGAgKSB7XG5cdFx0XHRpZiAoICFwbGFjZS5ncm91cCApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYGludGVybmFsIGVycm9yOiBubyBHUk9VUCBudW1iZXIgZm91bmRgIClcblx0XHRcdGlmICggIWRldmljZS5ncm91cCApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYGNhbm5vdCBhZGQgdW5saW5rZWQgZGV2aWNlIHRvIGEgZ3JvdXBgIClcblx0XHR9XG5cdFx0bGV0IHJlYyA9IHRoaXMubG9jYWxEZXZpY2VzLmNyZWF0ZVJlY29yZCgpXG5cdFx0dHJ5IHtcblx0XHRcdGxldCBwYWNrZXQgPSB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXTogeyBjb250ZW50OiB7IFsgaXRlbUlkIF06IHsgaW5kZXg6IHRoaXMubmV3SW5kZXgoIGljb25JZCApIH0gfSB9IH0gfVxuXHRcdFx0bGV0IHJlc3VsdCA9ICFleHRyYSA/IHBhY2tldCA6IGx1Lm1lcmdlRGlmZnMoIGV4dHJhLCBwYWNrZXQgKVxuXHRcdFx0cmVjLmFzc2lnbiggcmVzdWx0IClcblx0XHRcdGlmICggcGxhY2UudHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdFx0eWllbGQgdGhpcy5jb21tYW5kKCBpdGVtSWQsIGBBcHBlbmRUb2AsIHBsYWNlLmdyb3VwIClcblx0XHRcdHlpZWxkIHJlYy5zYXZlKClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRyZWMuY2xvc2UoKVxuXHRcdH1cblx0fSwgdGhpcyApIH0sXG5cblx0bGlua1RvRmF2b3VyaXRlcyggaXRlbUlkICkge1xuXHRcdHJldHVybiB0aGlzLmxpbmtJdGVtKCB0aGlzLm1haW4sIGl0ZW1JZCApXG5cdH0sXG5cblx0bGlua0FjdGl2ZVRvRmF2b3VyaXRlcyggaXRlbUlkICkge1xuXHRcdHJldHVybiB0aGlzLmxpbmtUb0Zhdm91cml0ZXMoIHRoaXMuYWN0aXZlRGV2aWNlSWQgKVxuXHR9LFxuXG5cdGFkZEl0ZW0oIGljb25JZCwgaXRlbSwgaWQgPSBVSUQoKSwgaW5kZXggPSBudWxsICkge1xuXHRcdHJldHVybiB0aGlzLnNlcnZlckRldmljZXMudXBkYXRlKCB7IGNvbnRlbnQ6IHtcblx0XHRcdFsgaWNvbklkIF06IHsgY29udGVudDogeyBbIGlkIF06IHsgaW5kZXg6IGluZGV4ICE9IG51bGwgPyBpbmRleCA6IHRoaXMubmV3SW5kZXgoIGljb25JZCApIH0gfSB9LFxuXHRcdFx0WyBpZCBdOiBpdGVtLFxuXHRcdH0gfSApXG5cdH0sXG5cblx0YWRkUGxhY2UoIGljb25JZCApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRJdGVtKCBpY29uSWQsIHtcblx0XHRcdHR5cGU6IGBwbGFjZWAsXG5cdFx0XHRydTogYNCf0L7QvNC10YnQtdC90LjQtWAsXG5cdFx0XHRlbjogYFJvb21gLFxuXHRcdH0gKVxuXHR9LFxuXG5cdGFkZERldmljZSggaWNvbklkICkge1xuXHRcdHJldHVybiB0aGlzLmFkZEl0ZW0oIGljb25JZCwge1xuXHRcdFx0dHlwZTogYHNpbmdsZWAsXG5cdFx0XHRydTogYNCj0YHRgtGA0L7QudGB0YLQstC+YCxcblx0XHRcdGVuOiBgRGV2aWNlYCxcblx0XHR9IClcblx0fSxcblxuXHRhZGRHcm91cCggaWNvbklkLCBpZCApIHsgcmV0dXJuIGNvLmdvY2FsbCggZnVuY3Rpb24qICgpIHtcblx0XHRpZiAoICFpZCApXG5cdFx0XHRpZCA9IFVJRCgpXG5cdFx0eWllbGQgdGhpcy5hZGRJdGVtKCBpY29uSWQsIHtcblx0XHRcdHR5cGU6IGBncm91cGAsXG5cdFx0XHRydTogYNCT0YDRg9C/0L/QsGAsXG5cdFx0XHRlbjogYEdyb3VwYCxcblx0XHR9LCBpZCApXG5cdFx0eWllbGQgdGhpcy5jb21tYW5kKCBpZCwgYFJlc2VydmVgIClcblx0XHRyZXR1cm4gaWRcblx0fSwgdGhpcyApIH0sXG5cblx0ZGVsZXRlSXRlbSggaWNvbklkLCBpdGVtSWQgKSB7IHJldHVybiBjby5nb2NhbGwoIGZ1bmN0aW9uKiAoKSB7XG5cdFx0bGV0IHBsYWNlID0gdGhpcy5nZXREZXZpY2UoIGljb25JZCApXG5cdFx0bGV0IHJlYyA9IHRoaXMubG9jYWxEZXZpY2VzLmNyZWF0ZVJlY29yZCgpXG5cdFx0dHJ5IHtcblx0XHRcdHJlYy5hc3NpZ24oIHsgY29udGVudDogeyBbIGljb25JZCBdOiB7IGNvbnRlbnQ6IHsgWyBpdGVtSWQgXTogbnVsbCB9IH0gfSB9IClcblx0XHRcdGlmICggcGxhY2UudHlwZSA9PSBgZ3JvdXBgICYmIHBsYWNlLmdyb3VwIClcblx0XHRcdFx0eWllbGQgdGhpcy5jb21tYW5kKCBpdGVtSWQsIGBSZW1vdmVGcm9tYCwgcGxhY2UuZ3JvdXAgKVxuXHRcdFx0eWllbGQgcmVjLnNhdmUoKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHJlYy5jbG9zZSgpXG5cdFx0fVxuXHR9LCB0aGlzICkgfSxcblxuXHRpbnNlcnRJbnRvKCBpY29uSWQsIGl0ZW1JZCwgZnJvbUlkICkge1xuXHRcdHJldHVybiB0aGlzLmxpbmtJdGVtKCBpY29uSWQsIGl0ZW1JZCwgeyBjb250ZW50OiB7IFsgZnJvbUlkIF06IHsgY29udGVudDogeyBbIGl0ZW1JZCBdOiBudWxsIH0gfSB9IH0gKVxuXHR9LFxuXG5cdGVycm9yczogbnVsbCxcblx0dGhyb3coIGRpYWxvZywgZGF0YSwgcmV0cnkgKSB7XG5cdFx0aWYgKCAhZGlhbG9nIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYGFuIGVycm9yIGhhcyB0byBoYXZlIGl0cyBvd24gZGlhbG9nYCApXG5cdFx0dGhpcy5lcnJvcnMgPSAoIHRoaXMuZXJyb3JzIHx8IFtdICkuY29uY2F0KCBbIHtcblx0XHRcdGRpYWxvZyxcblx0XHRcdGRhdGEsXG5cdFx0XHRyZXRyeSxcblx0XHR9IF0gKVxuXHR9LFxuXHRjbGVhckVycm9yKCkgeyByYS5kZXRhY2goICgpID0+IHtcblx0XHRpZiAoIHRoaXMuZXJyb3IgKSB7XG5cdFx0XHR0aGlzLmRpYWxvZyA9IGBgXG5cdFx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzICYmIHRoaXMuZXJyb3JzLnNsaWNlKCAxIClcblx0XHR9XG5cdH0gKSB9LFxuXHRnZXQgY2hlY2tFcnJvcigpIHtcblx0XHRpZiAoICF0aGlzLmRpYWxvZyApXG5cdFx0XHRpZiAoIHRoaXMuZXJyb3JzICYmIHRoaXMuZXJyb3JzLmxlbmd0aCApIHJhLmRldGFjaCggKCkgPT4ge1xuXHRcdFx0XHRsZXQgZXJyb3IgPSB0aGlzLmVycm9yc1sgMCBdXG5cdFx0XHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMgJiYgdGhpcy5lcnJvcnMuc2xpY2UoIDEgKVxuXHRcdFx0XHR0aGlzLmRpYWxvZyA9IGVycm9yLmRpYWxvZ1xuXHRcdFx0XHR0aGlzLmVycm9yID0gZXJyb3Jcblx0XHRcdH0gKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLmVycm9yID0gbnVsbFxuXHR9LFxuXHRlcnJvcjogbnVsbCxcblxuXHRwdXJnZUl0ZW0oIGRldmljZUlkLCBmb3JjZSApIHsgcmV0dXJuIGNvLmdvY2FsbCggZnVuY3Rpb24qICgpIHtcblx0XHQvLyBkZWJ1Z2dlclxuXHRcdGxldCBkZXZpY2UgPSB0aGlzLmdldERldmljZSggZGV2aWNlSWQgKVxuXHRcdGxldCByZWMgPSB0aGlzLmxvY2FsRGV2aWNlcy5jcmVhdGVSZWNvcmQoKVxuXHRcdHRyeSB7XG5cdFx0XHRyZWMuYXNzaWduKCBkZXZkYi5DbGVhciggdGhpcy5kZXZpY2VzLCBkZXZpY2VJZCApIClcblx0XHRcdGxldCBjbWRcblx0XHRcdGlmICggZGV2aWNlICYmIGRldmljZS5ncm91cCAhPSBudWxsIClcblx0XHRcdFx0aWYgKCBkZXZpY2UudHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdFx0XHRjbWQgPSBgQ2xlYXJgXG5cdFx0XHRcdGVsc2UgaWYgKCBkZXZpY2UudHlwZSA9PSBgc2luZ2xlYCApXG5cdFx0XHRcdFx0Y21kID0gYFVubGlua2Bcblx0XHRcdGlmICggY21kIClcblx0XHRcdFx0eWllbGQgdGhpcy5jb21tYW5kKCBkZXZpY2VJZCwgY21kIClcblx0XHRcdGVsc2Vcblx0XHRcdFx0eWllbGQgcmVjLnNhdmUoKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdGlmICggZm9yY2UgKVxuXHRcdFx0XHR5aWVsZCByZWMuc2F2ZSgpXG5cdFx0XHRyZWMuY2xvc2UoKVxuXHRcdFx0Ly8gc2VydmVyIE1VU1Qgc2VuZCB1cyBhY3R1YWwgc3RhdGUgQkVGT1JFIHJldHVybmluZyByZXN1bHQgb2YgY29tbWFuZCBleGVjdXRpb25cblx0XHRcdGlmICggKCBsdS52YWx1ZU9mKCB0aGlzLnNlcnZlckRldmljZXMuZGF0YSApIHx8IDEgKVsgZGV2aWNlSWQgXSApXG5cdFx0XHRcdHRoaXMudGhyb3coIGBFcnJvclVubGlua2luZ0RldmljZWAsIHsgZGV2aWNlSWQgfSwgKVxuXHRcdH1cblx0fSwgdGhpcyApIH0sXG5cblx0cmVuYW1lSXRlbSggaWNvbklkLCBuYW1lICkge1xuXHRcdGxldCByZXQgPSBsb2Rhc2gucmVkdWNlKCB0aGlzLmdldERldmljZSggaWNvbklkICksICggcmV0LCBfLCBrZXkgKSA9PiB7XG5cdFx0XHRpZiAoIGtleS5sZW5ndGggPT0gMiApXG5cdFx0XHRcdHJldFsga2V5IF0gPSBudWxsXG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fSwge30gKVxuXHRcdHJldFsgbG9jYWxEZWZhdWx0cy5sYW5ndWFnZSB8fCBgcnVgIF0gPSBuYW1lXG5cdFx0cmV0dXJuIHRoaXMuc2VydmVyRGV2aWNlcy51cGRhdGUoIHsgY29udGVudDogeyBbIGljb25JZCBdOiByZXQgfSB9IClcblx0fSxcblxuXHRjb21tYW5kKCBkZXZpY2VJZCwgY21kLCBkYXRhICkge1xuXG5cdFx0Ly8gZGVidWdnZXJcblxuXHRcdC8vIFRPRE86XG5cdFx0Ly8gbGV0IG5ld3N0YXRlID0gZGV2aWNlQWN0aW9ucy5nZXROZXdTdGF0ZSggdGhpcy5nZXREZXZpY2UoIGRldmljZUlkICksIGNtZCApXG5cdFx0Ly8gaWYgKCBuZXdzdGF0ZSAhPSBudWxsICkge1xuXHRcdC8vIH1cblxuXHRcdHJldHVybiB0aGlzLmNvbW1hbmRzLmFzayggeyBkZXZpY2U6IGRldmljZUlkLCBjb21tYW5kOiBjbWQsIGRhdGE6IGRhdGEgfSApXG5cdH0sXG5cblx0aWNvbkNvbW1hbmQoIGljb24sIGljb25JZCwgY21kLCBkYXRhICkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCBpY29uLCBpY29uSWQsIGNtZCApXG5cdFx0aWNvbiA9IGx1LnZhbHVlT2YoIGljb24gKVxuXHRcdGlmICggaWNvbi50eXBlID09IGBwbGFjZWAgPyBjbWQgPT0gYFNob3J0YCA6IGNtZCA9PSBgTG9uZ2AgKVxuXHRcdFx0cmV0dXJuIHRoaXMuZ28oIGljb25JZCApXG5cdFx0aWYgKCBpY29uLnR5cGUgIT0gYHBsYWNlYCAmJiAhaWNvbi5ncm91cCApIHtcblx0XHRcdHRoaXMuZGlhbG9nID0gYEFza1RvTGlua0RldmljZWBcblx0XHRcdHRoaXMubGlua2luZ1BsYWNlSWQgPSBpY29uSWRcblx0XHRcdC8vIHJldHVybiBQcm9taXNlLnJlamVjdCggbmV3IEVycm9yKCBgZGV2aWNlIG5vdCBjb25maWd1cmVkYCApIClcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdH1cblx0XHRpZiAoIGNtZCA9PSBgU2hvcnRgIHx8IGNtZCA9PSBgTG9uZ2AgKSB7XG5cdFx0XHRpZiAoIGljb24gJiYgaWNvbi5zdGF0ZSApIHtcblx0XHRcdFx0Y21kID0gYFNldGBcblx0XHRcdFx0ZGF0YSA9IDBcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjbWQgPSBgU2V0YFxuXHRcdFx0XHRkYXRhID0gMVxuXHRcdFx0fVxuXHRcdFx0Ly8gY21kID0gYENvbWZvcnRfMWBcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuY29tbWFuZCggaWNvbklkLCBjbWQsIGRhdGEgKVxuXHR9LFxuXG5cdGZvY3VzKCBub2RlICkge1xuXHRcdC8vIG1hZ2ljIGFjdGlvbnMgdG8gZm9yY2UgYWxsb3cgdG8gc2hvdyBrZXlib2FyZCBieSBpbnB1dC5mb2N1cygpIG9uIGlPUyAoIHNvIGZhciBjaGVja2VkIGlPUyA4IClcblx0XHRzZXRUaW1lb3V0KCAoKSA9PiBub2RlLmZvY3VzKCksIDQwMCApXG5cdH0sXG5cblx0c2VhcmNoQWN0aW9uOiBudWxsLFxuXHRzZWFyY2hGaWx0ZXI6IG51bGwsXG5cdGdldCBjaGVja1NlYXJjaERpYWxvZygpIHtcblx0XHRpZiAoIHRoaXMuZGlhbG9nICE9IGBTZWFyY2hJdGVtc2AgKSB7XG5cdFx0XHR0aGlzLnNlYXJjaEFjdGlvbiA9IG51bGxcblx0XHRcdHRoaXMuc2VhcmNoRmlsdGVyID0gbnVsbFxuXHRcdH1cblx0fSxcblxuXHRpY29uczogbnVsbCxcblxuXHRtb2R1bGVzOiBuZXcgV2Vha01hcCxcblx0bG9hZCggbW9kdWxlICkge1xuXHRcdGxldCByZXQgPSB0aGlzLm1vZHVsZXMuZ2V0KCBtb2R1bGUgKVxuXHRcdGlmICggcmV0ID09IG51bGwgKSB7XG5cdFx0XHRyZXQgPSBtb2R1bGUoIGFwcCwgbG9jYWwgKVxuXHRcdFx0dGhpcy5tb2R1bGVzLnNldCggbW9kdWxlLCByZXQgKVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH0sXG5cblx0aG92ZXI6IG51bGwsXG5cblx0ZGVidWdnZXIoKSB7IGRlYnVnZ2VyIH0sXG5cbn0gKS5zZXROYW1lKCBgYXBwYCApXG5cbnJldHVybiB7IGFwcCwgbG9jYWwgfVxuXG59XG4iLCJsZXQgTUFYX1RJQ0tTID0gMTAwMDAwXG5cbmxldCBzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXRcbi8vIGxldCBzZXRJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbFxuXG5wcm9jZXNzLm5leHRUaWNrID0gbmV4dFRpY2tcblxubGV0IHF1ZXVlID0gW11cbmxldCB0aW1lciA9IG51bGxcbmxldCBwcm9jZXNzaW5nID0gZmFsc2VcbmxldCBzZWNyZXQgPSBgcHJvY2Vzcy10aWNrLWAgKyBNYXRoLnJhbmRvbSgpXG5cbmxldCBpbnN0YWxsVGltZXIgPSBmdW5jdGlvbiAoKSB7IHRpbWVyID0gc2V0VGltZW91dCggb25UaW1lciwgMSApIH1cblxuaWYgKCB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBgbWVzc2FnZWAsIGZ1bmN0aW9uICggZXYgKSB7XG5cdFx0bGV0IHNvdXJjZSA9IGV2LnNvdXJjZTtcblx0XHRpZiAoICggc291cmNlID09IHdpbmRvdyB8fCBzb3VyY2UgPT0gbnVsbCApICYmIGV2LmRhdGEgPT0gc2VjcmV0ICkge1xuXHRcdFx0ZXYuc3RvcFByb3BhZ2F0aW9uKClcblx0XHRcdG9uVGltZXIoKVxuXHRcdH1cblx0fSApXG5cdGxldCBwb3N0TWVzc2FnZSA9IHdpbmRvdy5wb3N0TWVzc2FnZVxuXHRpbnN0YWxsVGltZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cG9zdE1lc3NhZ2UoIHNlY3JldCwgYCpgIClcblx0XHR0aW1lciA9IHRydWVcblx0fVxufVxuXG4hWyBgc2V0VGltZW91dGAsIGBzZXRJbnRlcnZhbGAsIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIF0uZm9yRWFjaCggbmFtZSA9PiB7XG5cdGxldCBwcm9jID0gaG9va01ldGhvZCggd2luZG93LCBuYW1lLCBmdW5jdGlvbiAoIGhhbmRsZXIsIHRpbWUgKSB7XG5cdFx0aWYgKCB0eXBlb2YgYXJndW1lbnRzWyAwIF0gPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRhcmd1bWVudHNbIDAgXSA9IGdldFByb3h5KCBhcmd1bWVudHNbIDAgXSApXG5cdFx0cmV0dXJuIHByb2MuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdH0gKVxufSApXG5cbiFbIHdpbmRvdywgZG9jdW1lbnQgXS5mb3JFYWNoKCBob29rRXZlbnRMaXN0ZW5lciApXG5cbmZ1bmN0aW9uIG9uVGltZXIoKSB7XG5cdHRpbWVyID0gbnVsbFxuXHRwcm9jZXNzUXVldWUoKVxufVxuXG5mdW5jdGlvbiBlbnN1cmVUaW1lcigpIHtcblx0aWYgKCAhdGltZXIgJiYgIXByb2Nlc3NpbmcgKVxuXHRcdGluc3RhbGxUaW1lcigpXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKCBmdW4gKSB7XG5cdHF1ZXVlLnB1c2goIGZ1biApXG5cdGVuc3VyZVRpbWVyKClcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuXHRpZiAoIHByb2Nlc3NpbmcgfHwgIXF1ZXVlLmxlbmd0aCApXG5cdFx0cmV0dXJuXG5cdGxldCBpbmRleCA9IDBcblx0cHJvY2Vzc2luZyA9IHRydWVcblx0dHJ5IHtcblx0XHR3aGlsZSAoIGluZGV4IDwgTUFYX1RJQ0tTICYmIGluZGV4IDwgcXVldWUubGVuZ3RoIClcblx0XHRcdHF1ZXVlWyBpbmRleCsrIF0oKVxuXHR9XG5cdGZpbmFsbHkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCBgdGlja3M6IGAgKyBpbmRleCApXG5cdFx0cHJvY2Vzc2luZyA9IGZhbHNlXG5cdFx0cXVldWUuc3BsaWNlKCAwLCBpbmRleCApXG5cdFx0aWYgKCBxdWV1ZS5sZW5ndGggKVxuXHRcdFx0ZW5zdXJlVGltZXIoKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGdldFByb3h5KCBoYW5kbGVyICkge1xuXHRmdW5jdGlvbiBwcm94eSgpIHtcblx0XHRsZXQgcmV0ID0gaGFuZGxlci5oYW5kbGVFdmVudCA/IGhhbmRsZXIuaGFuZGxlRXZlbnQuYXBwbHkoIGhhbmRsZXIsIGFyZ3VtZW50cyApIDogaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRwcm9jZXNzUXVldWUoKVxuXHRcdHJldHVybiByZXRcblx0fVxuXHRsZXQgcmV0XG5cdGlmICggKCByZXQgPSBoYW5kbGVyWyBzZWNyZXQgXSApICE9IG51bGwgKVxuXHRcdHJldHVybiByZXRcblx0ZWxzZSB7XG5cdFx0YXNzaWduUHJvcGVydHkoIHByb3h5LCBzZWNyZXQsIHByb3h5IClcblx0XHRyZXR1cm4gYXNzaWduUHJvcGVydHkoIGhhbmRsZXIsIHNlY3JldCwgcHJveHkgKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGhvb2tFdmVudExpc3RlbmVyKCBvYmogKSB7XG5cdGlmICggb2JqLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0bGV0IGFkZEV2ZW50TGlzdGVuZXIgPSBob29rTWV0aG9kKCBvYmosIGBhZGRFdmVudExpc3RlbmVyYCxcblx0XHRcdGZ1bmN0aW9uICggZXZlbnQsIGhhbmRsZXIgKSB7XG5cdFx0XHRcdGFyZ3VtZW50c1sgMSBdID0gZ2V0UHJveHkoIGFyZ3VtZW50c1sgMSBdIClcblx0XHRcdFx0cmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0XHR9IClcblx0XHRsZXQgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGhvb2tNZXRob2QoIG9iaiwgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLFxuXHRcdFx0ZnVuY3Rpb24gKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHNbIDEgXVsgc2VjcmV0IF0gKVxuXHRcdFx0XHRcdGFyZ3VtZW50c1sgMSBdID0gYXJndW1lbnRzWyAxIF1bIHNlY3JldCBdXG5cdFx0XHRcdHJldHVybiByZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHRcdFx0fSApXG5cdH1cbn1cblxuZnVuY3Rpb24gaG9va01ldGhvZCggb2JqLCBuYW1lLCBwcm94eSApIHtcblx0bGV0IHJldCA9IG9ialsgbmFtZSBdXG5cdGlmICggcmV0ICkge1xuXHRcdGFzc2lnblByb3BlcnR5KCBwcm94eSwgYHRvU3RyaW5nYCwgKCkgPT4gcmV0LnRvU3RyaW5nKCkgKVxuXHRcdG9ialsgbmFtZSBdID0gcHJveHlcblx0fVxuXHRyZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb3BlcnR5KCBvYmosIG5hbWUsIHZhbHVlICkge1xuXHRpZiAoIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSApXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIG5hbWUsIHsgdmFsdWUgfSApXG5cdGVsc2Vcblx0XHRvYmpbIG5hbWUgXSA9IHZhbHVlXG5cdHJldHVybiB2YWx1ZVxufVxuIiwibGV0IGxhdGVyID0gcmVxdWlyZSggYGxhdGVyYCApXG5sZXQgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSggYGV2ZW50c2AgKS5FdmVudEVtaXR0ZXJcblxubGV0IGNvID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlclxuXG5sZXQgdGhyZWFkQ2F0Y2hlciA9IG51bGxcblxuZXhwb3J0cy5jYiA9IG51bGxcbmV4cG9ydHMuZ2xvYmFsID0gbnVsbFxuXG5leHBvcnRzLmdvID0gKCBmdW4sIC4uLmFyZ3MgKSA9PiB7XG5cdGlmICggdHlwZW9mIGZ1biA9PSBgZnVuY3Rpb25gIClcblx0XHRmdW4gPSBmdW4uYXBwbHkoIG51bGwsIGFyZ3MgKVxuXHRpZiAoICFmdW4ubmV4dCApIHtcblx0XHRsZXQgdmFsdWUgPSBmdW5cblx0XHRmdW4gPSB7XG5cdFx0XHRuZXh0KCkge1xuXHRcdFx0XHRsZXQgcmV0ID0geyB2YWx1ZSwgZG9uZTogIXZhbHVlIH1cblx0XHRcdFx0dmFsdWUgPSBudWxsXG5cdFx0XHRcdHJldHVybiByZXRcblx0XHRcdH0sXG5cdFx0fVxuXHR9XG5cdHJldHVybiBuZXcgVGhyZWFkKCBmdW4gKVxufVxuXG5leHBvcnRzLmdvY2FsbCA9ICggZnVuLCBjb250ZXh0LCAuLi5hcmdzICkgPT5cblx0bmV3IFRocmVhZCggZnVuLmFwcGx5KCBjb250ZXh0LCBhcmdzICkgKVxuXG5leHBvcnRzLmZ1bmMgPSBmdW5jdGlvbiAoIGZ1biApIHtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID49IDIgKVxuXHRcdGZ1biA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodC5jYWxsKCBhcmd1bWVudHMsICggZywgZiApID0+IGYoIGcgKSApXG5cdHJldHVybiBmdW5jdGlvbiBwcm9jKCkge1xuXHRcdHJldHVybiBuZXcgVGhyZWFkKCBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIClcblx0fVxufVxuXG5leHBvcnRzLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICggZnVuICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gcHJvYygpIHtcblx0XHRsZXQgcmV0ID0gbmV3IFRocmVhZCggZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApXG5cdFx0cmV0LndhaXRGb3JJbnB1dCgpXG5cdFx0cmV0dXJuIHJldFxuXHR9XG59XG5cbi8vIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBlcnJvciwgdGhlIHNlY29uZCBvbmUgaXMgYSByZXN1bHRcbmV4cG9ydHMuY2JmdW5jID0gZnVuV2l0aENCID0+IGZ1bmN0aW9uICggLi4uYXJncyApIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+XG5cdFx0ZnVuV2l0aENCLmNhbGwoIHRoaXMsIC4uLmFyZ3MsICggZXJyb3IsIHZhbHVlICkgPT4ge1xuXHRcdFx0aWYgKCBlcnJvciAhPSBudWxsIClcblx0XHRcdFx0cmVqZWN0KCBlcnJvciApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlc29sdmUoIHZhbHVlIClcblx0XHR9IClcblx0KVxufVxuXG5leHBvcnRzLmNhdGNoVGhyZWFkcyA9ICggY2IsIG9uVGhyZWFkICkgPT4ge1xuXHRsZXQgb2xkQ2F0Y2hlciA9IHRocmVhZENhdGNoZXJcblx0dGhyZWFkQ2F0Y2hlciA9IG9uVGhyZWFkXG5cdHRyeSB7XG5cdFx0cmV0dXJuIGNiKClcblx0fVxuXHRmaW5hbGx5IHtcblx0XHR0aHJlYWRDYXRjaGVyID0gb2xkQ2F0Y2hlclxuXHR9XG59XG5cbmV4cG9ydHMucmVjZWl2ZSA9ICggZW1pdHRlciwgZXZlbnRzICkgPT4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRsZXQgaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0bGV0IHRpbWVyXG5cdGxldCByZWplY3RlciA9IGNvLmRlZmVyKCAoKSA9PiB7XG5cdFx0Y2xlYXIoKVxuXHRcdHJlamVjdCgpXG5cdH0gKVxuXHRmb3IgKCBsZXQgZXZlbnQgaW4gZXZlbnRzICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGV2ZW50cywgZXZlbnQgKSApIHtcblx0XHRsZXQgcHJlZGljYXRlID0gZXZlbnRzWyBldmVudCBdXG5cdFx0aWYgKCBwcmVkaWNhdGUgPT0gbnVsbCApXG5cdFx0XHQvL1xuXHRcdFx0Ly8gYWxsb3cgc2ltcGxlciBldmVudHMgZGVmaW5pbmcgbGlrZVxuXHRcdFx0Ly9cblx0XHRcdC8vIHlpZWxkIGNvLnJlY2VpdmUoIG9iaiwgeyBkYXRhOiB0cnVlLCB0aW1lb3V0OiBnZXRUaW1lb3V0KCAuLi4gKSB9IClcblx0XHRcdC8vXG5cdFx0XHQvLyBpbnN0ZWFkIG9mXG5cdFx0XHQvL1xuXHRcdFx0Ly8gbGV0IGV2ZW50cyA9IHsgZGF0YTogdHJ1ZSB9XG5cdFx0XHQvLyBpZiAoIGdldFRpbWVvdXQoIC4uLiApICE9IG51bGwgKSBldmVudHMudGltZW91dCA9IGdldFRpbWVvdXQoIC4uLiApXG5cdFx0XHQvLyB5aWVsZCBjby5yZWNlaXZlKCBvYmosIGV2ZW50cyApXG5cdFx0XHQvL1xuXHRcdFx0Y29udGludWVcblx0XHRpZiAoIGV2ZW50ID09IGB0aW1lb3V0YCApXG5cdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoICgpID0+IGRvbmUoIGB0aW1lb3V0YCwgbnVsbCApLCBwcmVkaWNhdGUgKVxuXHRcdGVsc2Vcblx0XHRcdGVtaXR0ZXIuYWRkTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyc1sgZXZlbnQgXSA9IGRhdGEgPT4ge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBwcmVkaWNhdGUgIT0gYGZ1bmN0aW9uYCB8fCBwcmVkaWNhdGUoIGRhdGEgKSApXG5cdFx0XHRcdFx0ZG9uZSggZXZlbnQsIGRhdGEgKVxuXHRcdFx0fSApXG5cdH1cblx0ZnVuY3Rpb24gY2xlYXIoKSB7XG5cdFx0aWYgKCAhaGFuZGxlcnMgKVxuXHRcdFx0cmV0dXJuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aW1lciApXG5cdFx0Zm9yICggbGV0IGV2ZW50IGluIGhhbmRsZXJzIClcblx0XHRcdGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyc1sgZXZlbnQgXSApXG5cdFx0cmVqZWN0ZXIuY2xvc2UoKVxuXHRcdGhhbmRsZXJzID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGRvbmUoIGV2ZW50LCBkYXRhICkge1xuXHRcdGNsZWFyKClcblx0XHRyZXNvbHZlKCB7IGV2ZW50LCBkYXRhIH0gKVxuXHR9XG59IClcblxubGV0IG5vb3B0aGVuID0geyB0aGVuKCkge30gfVxuZXhwb3J0cy53YWl0ID0gKCkgPT4gbm9vcHRoZW5cblxuZXhwb3J0cy5zbGVlcCA9IG1pbGxpc2Vjb25kcyA9PiAoIHsgdGhlbjogcmVzb2x2ZSA9PiB7XG5cdGxldCB0aW1lciA9IHNldFRpbWVvdXQoIHJlc29sdmUsIG1pbGxpc2Vjb25kcyApXG5cdHJldHVybiB7IGtpbGwoKSB7IGNsZWFyVGltb3V0KCB0aW1lciApIH0gfVxufSB9IClcblxuZXhwb3J0cy50aWNrID0gZXhwb3J0cy5zbGVlcCggMSApXG5cbmV4cG9ydHMudGltZW91dCA9IG1pbGxpc2Vjb25kcyA9PiAoIHsgdGhlbjogKCBfLCByZWplY3QgKSA9PiB7XG5cdGxldCB0aW1lciA9IHNldFRpbWVvdXQoIHJlamVjdCwgbWlsbGlzZWNvbmRzIClcblx0cmV0dXJuIHsga2lsbCgpIHsgY2xlYXJUaW1vdXQoIHRpbWVyICkgfSB9XG59IH0gKVxuXG5leHBvcnRzLnByb21pc2UgPSB2YWx1ZSA9PiBQcm9taXNlLmFsbCggWyBjby5nbyggZnVuY3Rpb24qICgpIHtcblx0eWllbGQgdmFsdWVcbn0gKSBdIClcblxuZXhwb3J0cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB7IHRoZW46IHJlc29sdmUgPT4ge1xuXHRpZiAoIHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PSBgZnVuY3Rpb25gICkge1xuXHRcdGxldCBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggcmVzb2x2ZSApXG5cdFx0cmV0dXJuIHsga2lsbCgpIHsgY2FuY2VsQW5pbWF0aW9uRnJhbWUoIGZyYW1lICkgfSB9XG5cdH1cblx0ZWxzZVxuXHRcdHJldHVybiBleHBvcnRzLnNsZWVwKCAxICkudGhlbiggcmVzb2x2ZSApXG59IH1cblxubGV0IHJldGhyb3cgPSBlID0+IHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZSB9LCAxIClcblxuZnVuY3Rpb24gaXRlcmF0b3JGYWlsZWQoIGVycm9yICkge1xuXHRyZXR1cm4geyBkb25lOiB0cnVlLCBpdGVyYXRvckZhaWxlZDogdHJ1ZSwgdmFsdWU6IGVycm9yIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JOZXh0KCBpdGVyYXRvciwgcmVzdWx0ICkge1xuXHR0cnkge1xuXHRcdHJldHVybiBpdGVyYXRvci5uZXh0KCByZXN1bHQgKVxuXHR9XG5cdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0cmV0dXJuIGl0ZXJhdG9yRmFpbGVkKCBlcnJvciApXG5cdH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JUaHJvdyggaXRlcmF0b3IsIHJlc3VsdCApIHtcblx0aWYgKCAhaXRlcmF0b3IudGhyb3cgKVxuXHRcdHJldHVybiBpdGVyYXRvckZhaWxlZCggcmVzdWx0IClcblx0dHJ5IHtcblx0XHRyZXR1cm4gaXRlcmF0b3IudGhyb3coIHJlc3VsdCApXG5cdH1cblx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRyZXR1cm4gaXRlcmF0b3JGYWlsZWQoIGVycm9yIClcblx0fVxufVxuXG5jb25zdCBET05FID0geyBkb25lOiB0cnVlIH1cblxuY2xhc3MgRUtpbGwgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKCBtZXNzYWdlID0gYGtpbGxgICkge1xuXHRcdHN1cGVyKCBtZXNzYWdlIClcblx0fVxufVxuZXhwb3J0cy5FS2lsbCA9IEVLaWxsXG5cbmZ1bmN0aW9uIGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciApIHtcblx0aWYgKCBpdGVyYXRvci5yZXR1cm4gKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGl0ZXJhdG9yLnJldHVybigpXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gaXRlcmF0b3JGYWlsZWQoIGVycm9yIClcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIGl0ZXJhdG9yLnRocm93ICkge1xuXHRcdGxldCBlID0gbmV3IEVLaWxsXG5cdFx0bGV0IHYgPSBpdGVyYXRvclRocm93KCBpdGVyYXRvciwgZSApXG5cdFx0aWYgKCAhdi5kb25lIHx8ICF2Lml0ZXJhdG9yRmFpbGVkIClcblx0XHRcdHJldGhyb3coIG5ldyBFcnJvciggYHRocmVhZCBoYXMgZWF0ZW4gRUtpbGxgICkgKVxuXHRcdGVsc2UgaWYgKCB2LnZhbHVlICE9IGUgKVxuXHRcdFx0cmV0dXJuIHZcblx0fVxuXHRyZXR1cm4gRE9ORVxufVxuXG5mdW5jdGlvbiBpdGVyYXRvckNoZWNrKCByZXQgKSB7XG5cdGlmICggcmV0ICYmIHJldC5kb25lICYmIHJldC5pdGVyYXRvckZhaWxlZCApXG5cdFx0dGhyb3cgcmV0LnZhbHVlXG5cdGVsc2Vcblx0XHRyZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGtpbGxJdGVyYXRvciggaXRlcmF0b3IgKSB7XG5cdGlmICggaXRlcmF0b3IgKSB7XG5cdFx0bGV0IHJlcyA9IGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciApXG5cdFx0aWYgKCByZXMuZG9uZSAmJiByZXMuaXRlcmF0b3JGYWlsZWQgKVxuXHRcdFx0cmV0aHJvdyggcmVzLnZhbHVlIClcblx0fVxufVxuXG4vLyBUaHJlYWRcblxubGV0IGNhdGNoRGVmZXIgPSBmdW5jID0+IHtcblx0Ly8gb3B0aW1pemF0aW9uIC0tIHVzaW5nIHRyeS9jYXRjaCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uLlxuXHR0cnkge1xuXHRcdHJldHVybiBmdW5jKClcblx0fVxuXHRjYXRjaCAoIGVycm9yICkge1xuXHRcdHJldHVybiB7IG5leHQ6ICgpID0+IGl0ZXJhdG9yRmFpbGVkKCBlcnJvciApIH1cblx0fVxufVxuXG5sZXQgZHVtbXlJdGVyYXRvciA9IHtcblx0bmV4dDogKCkgPT4gRE9ORSxcblx0dGhyb3c6IGVycm9yID0+IHsgdGhyb3cgZXJyb3IgfSxcblx0cmV0dXJuOiB2YWx1ZSA9PiAoIHsgdmFsdWUsIGRvbmU6IHRydWUgfSApLFxufVxuXG5leHBvcnRzLmRlZmVyID0gcHJvYyA9PiB7XG5cdGlmICggdHlwZW9mIHByb2MgIT0gYGZ1bmN0aW9uYCApXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgb25seSBmdW5jdGlvbnMgY2FuIGJlIGRlZmVycmVkYCApXG5cdGxldCB0aHJlYWQgPSBleHBvcnRzLmN1cnJlbnRcblx0aWYgKCAhdGhyZWFkIClcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGBub3QgaW4gYSB0aHJlYWRgIClcblx0aWYgKCAhdGhyZWFkLl9zdGFjayApXG5cdFx0dGhyZWFkLl9zdGFjayA9IFtdXG5cdGxldCBpdGVyYXRvclxuXHRmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcigpIHtcblx0XHRpdGVyYXRvciA9IHByb2MoKVxuXHRcdGlmICggIWl0ZXJhdG9yIHx8IHR5cGVvZiBpdGVyYXRvci5uZXh0ICE9IGBmdW5jdGlvbmAgKVxuXHRcdFx0aXRlcmF0b3IgPSBkdW1teUl0ZXJhdG9yXG5cdFx0cmV0dXJuIGl0ZXJhdG9yXG5cdH1cblx0bGV0IHJlYyA9IHtcblx0XHRuZXh0OiB2YWx1ZSA9PiAoIGl0ZXJhdG9yIHx8IGNyZWF0ZUl0ZXJhdG9yKCkgKS5uZXh0KCB2YWx1ZSApLFxuXHRcdHRocm93OiBlcnJvciA9PiB7XG5cdFx0XHRpdGVyYXRvciB8fCBjcmVhdGVJdGVyYXRvcigpXG5cdFx0XHRyZXR1cm4gKCBpdGVyYXRvci50aHJvdyA/IGl0ZXJhdG9yIDogZHVtbXlJdGVyYXRvciApLnRocm93KCBlcnJvciApXG5cdFx0fSxcblx0XHRyZXR1cm46IHZhbHVlID0+IHtcblx0XHRcdC8vIGxldCBkZWZmZXJlZCBpdGVyYXRvciBkbyBvbmUgc3RlcFxuXHRcdFx0aXRlcmF0b3IgfHwgY3JlYXRlSXRlcmF0b3IoKS5uZXh0KCB1bmRlZmluZWQgKVxuXHRcdFx0aWYgKCBpdGVyYXRvci5yZXR1cm4gKVxuXHRcdFx0XHRyZXR1cm4gaXRlcmF0b3IucmV0dXJuKCB2YWx1ZSApXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCBpdGVyYXRvci50aHJvdyApICFmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dHJ5IHsgaXRlcmF0b3IudGhyb3coIG5ldyBFS2lsbCggYHJldHVybmAgKSApIH0gY2F0Y2ggKCBfICkge31cblx0XHRcdFx0fSgpXG5cdFx0XHRcdHJldHVybiBkdW1teUl0ZXJhdG9yLnJldHVybiggdmFsdWUgKVxuXHRcdFx0fVxuXHRcdH0sXG5cdH1cblx0dGhyZWFkLl9zdGFjay5wdXNoKCByZWMgKVxuXHRyZXR1cm4geyBjbG9zZSgpIHtcblx0XHRpZiAoICFyZWMgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCB0aHJlYWQuX3N0YWNrICkge1xuXHRcdFx0bGV0IGkgPSB0aHJlYWQuX3N0YWNrLmluZGV4T2YoIHJlYyApXG5cdFx0XHRpZiAoIGkgPj0gMCApXG5cdFx0XHRcdHRocmVhZC5fc3RhY2suc3BsaWNlKCBpLCAxIClcblx0XHR9XG5cdFx0cmVjID0gbnVsbFxuXHR9IH1cbn1cblxuXG5jbGFzcyBUaHJlYWQge1xuXG5cdGNvbnN0cnVjdG9yKCBpdGVyYXRvciApIHtcblx0XHR0aGlzLl9hdHRhY2hlZFRvU3RhY2sgPSB0cnVlXG5cdFx0dGhpcy5faXRlcmF0b3IgPSBpdGVyYXRvclxuXHRcdHRoaXMuX3N0b3BDb3VudCA9IDBcblx0XHR0aGlzLl9zdGFjayA9IG51bGxcblx0XHR0aGlzLmdsb2JhbCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbnVsbFxuXHRcdHRoaXMuX3J1bm5pbmcgPSBmYWxzZVxuXHRcdHRoaXMuX2tpbGxpbmcgPSBudWxsXG5cdFx0dGhpcy5fY2IgPSAoIGVycm9yLCBkYXRhICkgPT4ge1xuXHRcdFx0aWYgKCB0aGlzLl9zdGVwIClcblx0XHRcdFx0aWYgKCBlcnJvciApXG5cdFx0XHRcdFx0dGhpcy5fc3RlcC5mYWlsKCBlcnJvciApXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0aGlzLl9zdGVwLm5leHQoIGRhdGEgKVxuXHRcdH1cblx0XHR0aGlzLiRuYW1lID0geyB0b1N0cmluZzogKCkgPT4gYDxUaHJlYWQ+YCB9XG5cblx0XHR0aGlzLl9uZXdTdGVwKClcblx0XHR0aGlzLl9zdGFydCA9ICgpID0+IHtcblx0XHRcdGlmICggdGhpcy5fc3RhcnQgJiYgdGhpcy5fc3RlcCAmJiB0aGlzLl9zdGVwLm5leHQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5fc3RvcENvdW50ID4gMCApXG5cdFx0XHRcdFx0dGhpcy5fc3RlcC5yZXN1bWUgPSB0aGlzLl9zdGFydFxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydCA9IG51bGxcblx0XHRcdFx0XHR0aGlzLl9zdGVwLm5leHQoKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcblx0XHRcdHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlXG5cdFx0XHR0aGlzLl9yZWplY3QgPSByZWplY3Rcblx0XHR9IClcblx0XHRpZiAoICF0aGlzLl9yZXNvbHZlIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYGFzc2VydGlvbiBmYWlsdXJlOiB3cm9uZyBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlYCApXG5cblx0XHRsYXRlci50aGVuKCB0aGlzLl9zdGFydCApXG5cdFx0aWYgKCB0aHJlYWRDYXRjaGVyIClcblx0XHRcdHRocmVhZENhdGNoZXIoIHRoaXMgKVxuXG5cdFx0ZXhwb3J0cy5lbWl0KCBgc3RhcnRgLCB0aGlzIClcblx0fVxuXG5cdGxpbmtOYW1lKCB2YWx1ZSwgc3VmZml4ID0gYDp0aHJlYWRgICkge1xuXHRcdGlmICggdmFsdWUuJG5hbWUgKVxuXHRcdFx0dmFsdWUgPSB2YWx1ZS4kbmFtZVxuXHRcdHRoaXMuJG5hbWUudG9TdHJpbmcgPSAoKSA9PiBgYCArIHZhbHVlICsgc3VmZml4XG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdHdhaXRGb3JJbnB1dCgpIHtcblx0XHR0aGlzLl9jaGVja0ZpbmlzaGVkKClcblx0XHRpZiAoIHRoaXMuX3N0b3BDb3VudCA+IDAgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgdGhyZWFkIGlzIHBhdXNlZGAgKVxuXHRcdGlmICggdGhpcy5fc3RhcnQgKVxuXHRcdFx0dGhpcy5fc3RhcnQoKVxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRfYXR0YWNoUHJvbWlzZSggcHJvbWlzZSApIHtcblx0XHRwcm9taXNlLmtpbGwgPSB0aGlzLmtpbGwuYmluZCggdGhpcyApXG5cdFx0cmV0dXJuIHByb21pc2Vcblx0fVxuXG5cdHRoZW4oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkICkge1xuXHRcdHRoaXMuX2F0dGFjaGVkVG9TdGFjayA9IGZhbHNlXG5cdFx0cmV0dXJuIHRoaXMuX2F0dGFjaFByb21pc2UoIHRoaXMuX3Byb21pc2UudGhlbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQgKSApXG5cdH1cblxuXHRjYXRjaCggb25SZWplY3RlZCApIHtcblx0XHR0aGlzLl9hdHRhY2hlZFRvU3RhY2sgPSBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9hdHRhY2hQcm9taXNlKCB0aGlzLl9wcm9taXNlLmNhdGNoKCBvblJlamVjdGVkICkgKVxuXHR9XG5cblx0aXNGaW5pc2hlZCgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX3N0ZXAgfHwgdGhpcy5fa2lsbGluZ1xuXHR9XG5cblx0aXNQYXVzZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0b3BDb3VudCA+IDBcblx0fVxuXG5cdHRocm93KCBleGNlcHRpb24gKSB7XG5cdFx0aWYgKCB0aGlzLmdsb2JhbCA9PSBleHBvcnRzLmdsb2JhbCApXG5cdFx0XHR0aHJvdyBleGNlcHRpb25cblx0XHR0aGlzLl9jaGVja0ZpbmlzaGVkKClcblx0XHR0aGlzLl9uZXdTdGVwKClcblx0XHRpZiAoIHRoaXMuX3N0b3BDb3VudCA+IDAgKVxuXHRcdFx0dGhpcy5fc3RlcC5yZXN1bWUgPSB0aGlzLl9zdGVwLmZhaWwuYmluZCggdGhpcy5fc3RlcCwgZXhjZXB0aW9uIClcblx0XHRlbHNlXG5cdFx0XHR0aGlzLl9zdGVwLmZhaWwoIGV4Y2VwdGlvbiApXG5cdH1cblxuXHRhdHRhY2hUb1N0YWNrKCkge1xuXHRcdHRoaXMuX2F0dGFjaGVkVG9TdGFjayA9IHRydWVcblx0fVxuXG5cdGtpbGwoIHJlYXNvbiApIHtcblx0XHRpZiAoIHRoaXMuaXNGaW5pc2hlZCgpIClcblx0XHRcdHJldHVyblxuXHRcdHRoaXMuX3JlamVjdCggcmVhc29uIClcblx0XHRpZiAoIHRoaXMuX3J1bm5pbmcgKSB7XG5cdFx0XHR0aGlzLl9raWxsaW5nID0geyByZWFzb24gfVxuXHRcdFx0dGhyb3cgbmV3IEVLaWxsXG5cdFx0fVxuXHRcdGxldCBwcmV2aW91c1RocmVhZCA9IGV4cG9ydHMuY3VycmVudFxuXHRcdGxldCBwcmV2aW9zQ0IgPSBleHBvcnRzLmNiXG5cdFx0bGV0IHByZXZpb3NHbG9iYWwgPSBleHBvcnRzLmdsb2JhbFxuXHRcdGV4cG9ydHMuY2IgPSB0aGlzLl9jYlxuXHRcdGV4cG9ydHMuZ2xvYmFsID0gdGhpcy5nbG9iYWxcblx0XHRleHBvcnRzLmN1cnJlbnQgPSB0aGlzXG5cdFx0a2lsbEl0ZXJhdG9yKCB0aGlzLl9pdGVyYXRvciApXG5cdFx0aWYgKCB0aGlzLl9zdGFjayApIGZvciAoIGxldCBhID0gdGhpcy5fc3RhY2ssIGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pIClcblx0XHRcdGtpbGxJdGVyYXRvciggYVsgaSBdIClcblx0XHRleHBvcnRzLmNiID0gcHJldmlvc0NCXG5cdFx0ZXhwb3J0cy5nbG9iYWwgPSBwcmV2aW9zR2xvYmFsXG5cdFx0ZXhwb3J0cy5jdXJyZW50ID0gcHJldmlvdXNUaHJlYWRcblx0XHRpZiAoIHRoaXMuX2N1cnJlbnRQcm9taXNlICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fY3VycmVudFByb21pc2Uua2lsbCggcmVhc29uIClcblx0XHRcdH1cblx0XHRcdGNhdGNoICggZSApIHtcblx0XHRcdFx0cmV0aHJvdyggZSApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2RvbmUoKVxuXHR9XG5cblx0cGF1c2UoKSB7XG5cdFx0dGhpcy5fY2hlY2tGaW5pc2hlZCgpXG5cdFx0Kyt0aGlzLl9zdG9wQ291bnRcblx0fVxuXG5cdHJlc3VtZSgpIHtcblx0XHRpZiAoIHRoaXMuX3N0b3BDb3VudCA9PSAwIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHRocmVhZCBub3QgcGF1c2VkYCApXG5cdFx0aWYgKCAwID09IC0tdGhpcy5fc3RvcENvdW50ICYmIHRoaXMuX3N0ZXAgJiYgdGhpcy5fc3RlcC5yZXN1bWUgKSB7XG5cdFx0XHRsYXRlci50aGVuKCB0aGlzLl9zdGVwLnJlc3VtZSApXG5cdFx0XHR0aGlzLl9zdGVwLnJlc3VtZSA9IG51bGxcblx0XHR9XG5cdH1cblxuXHRfdGljayggc3RlcCwgaW1ldGhvZCwgcmVzdWx0ICkge1xuXHRcdGlmICggdGhpcy5kZWJ1Z2dlciB8fCBzdGVwLmRlYnVnZ2VyIClcblx0XHRcdGRlYnVnZ2VyXG5cdFx0aWYgKCB0aGlzLl9ydW5uaW5nIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJGQVRBTDogcmVlbnRlcmluZyB0aHJlYWQgdGlja1wiIClcblx0XHRpZiAoIHN0ZXAgIT09IHRoaXMuX3N0ZXAgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCB0aGlzLl9zdG9wQ291bnQgPiAwICkge1xuXHRcdFx0c3RlcC5yZXN1bWUgPSB0aGlzLl90aWNrLmJpbmQoIHRoaXMsIHN0ZXAsIGltZXRob2QsIHJlc3VsdCApXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0dGhpcy5fY3VycmVudFByb21pc2UgPSBudWxsXG5cdFx0XHR0aGlzLl9ydW5uaW5nID0gdHJ1ZVxuXHRcdFx0bGV0IHByZXZpb3VzVGhyZWFkID0gZXhwb3J0cy5jdXJyZW50XG5cdFx0XHRsZXQgcHJldmlvc0NCID0gZXhwb3J0cy5jYlxuXHRcdFx0bGV0IHByZXZpb3NHbG9iYWwgPSBleHBvcnRzLmdsb2JhbFxuXHRcdFx0ZXhwb3J0cy5jYiA9IHRoaXMuX2NiXG5cdFx0XHRleHBvcnRzLmdsb2JhbCA9IHRoaXMuZ2xvYmFsXG5cdFx0XHRleHBvcnRzLmN1cnJlbnQgPSB0aGlzXG5cdFx0XHRsZXQgdiA9IGltZXRob2QoIHRoaXMuX2l0ZXJhdG9yLCByZXN1bHQgKVxuXHRcdFx0ZXhwb3J0cy5jYiA9IHByZXZpb3NDQlxuXHRcdFx0ZXhwb3J0cy5nbG9iYWwgPSBwcmV2aW9zR2xvYmFsXG5cdFx0XHRleHBvcnRzLmN1cnJlbnQgPSBwcmV2aW91c1RocmVhZFxuXHRcdFx0dGhpcy5fcnVubmluZyA9IGZhbHNlXG5cdFx0XHRpZiAoIHRoaXMuZGVidWdnZXIgfHwgc3RlcC5kZWJ1Z2dlciApXG5cdFx0XHRcdGRlYnVnZ2VyXG5cdFx0XHRpZiAoIHRoaXMuX2tpbGxpbmcgKSB7XG5cdFx0XHRcdGxldCByZWFzb24gPSB0aGlzLl9raWxsaW5nLnJlYXNvblxuXHRcdFx0XHR0aGlzLl9raWxsaW5nID0gbnVsbFxuXHRcdFx0XHR0aGlzLmtpbGwoIHJlYXNvbiApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKCB2LmRvbmUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5pc0ZpbmlzaGVkKCkgKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRpZiAoIHRoaXMuX2l0ZXJhdG9yID0gdGhpcy5fc3RhY2sgJiYgdGhpcy5fc3RhY2sucG9wKCkgKSB7XG5cdFx0XHRcdFx0aW1ldGhvZCA9IHYuaXRlcmF0b3JGYWlsZWQgPyBpdGVyYXRvclRocm93IDogaXRlcmF0b3JOZXh0XG5cdFx0XHRcdFx0cmVzdWx0ID0gdi52YWx1ZVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IHIgPSB2Lml0ZXJhdG9yRmFpbGVkID8gdGhpcy5fcmVqZWN0IDogdGhpcy5fcmVzb2x2ZVxuXHRcdFx0XHR0aGlzLl9kb25lKClcblx0XHRcdFx0aWYgKCB2Lml0ZXJhdG9yRmFpbGVkICYmIHRoaXMuX2F0dGFjaGVkVG9TdGFjayApXG5cdFx0XHRcdFx0cmV0aHJvdyggdi52YWx1ZSApXG5cdFx0XHRcdHIoIHYudmFsdWUgKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICF2LnZhbHVlICkgLy8gYW55IGZhbHN5IHZhbHVlXG5cdFx0XHRcdGV4cG9ydHMudGljay50aGVuKCBzdGVwLm5leHQgKVxuXHRcdFx0ZWxzZSBpZiAoIHYudmFsdWUudGhlbiApIHtcblx0XHRcdFx0bGV0IHAgPSB2LnZhbHVlLnRoZW4oIHN0ZXAubmV4dCwgc3RlcC5mYWlsIClcblx0XHRcdFx0aWYgKCBwICYmIHAua2lsbCApXG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudFByb21pc2UgPSBwXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdi52YWx1ZS5uZXh0ICkge1xuXHRcdFx0XHR0aGlzLl9zdGFjayA/IHRoaXMuX3N0YWNrLnB1c2goIHRoaXMuX2l0ZXJhdG9yICkgOiAoIHRoaXMuX3N0YWNrID0gWyB0aGlzLl9pdGVyYXRvciBdIClcblx0XHRcdFx0dGhpcy5faXRlcmF0b3IgPSB2LnZhbHVlXG5cdFx0XHRcdGltZXRob2QgPSBpdGVyYXRvck5leHRcblx0XHRcdFx0cmVzdWx0ID0gdW5kZWZpbmVkXG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggYG9ubG9hZGAgaW4gdi52YWx1ZSAmJiAhdi52YWx1ZS5vbmxvYWQgJiYgYG9uZXJyb3JgIGluIHYudmFsdWUgJiYgIXYudmFsdWUub25lcnJvciApIHtcblx0XHRcdFx0di52YWx1ZS5vbmxvYWQgPSBzdGVwLm5leHRcblx0XHRcdFx0di52YWx1ZS5vbmVycm9yID0gc3RlcC5mYWlsXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggYG9uc3VjY2Vzc2AgaW4gdi52YWx1ZSAmJiAhdi52YWx1ZS5vbmxvYWQgJiYgYG9uZXJyb3JgIGluIHYudmFsdWUgJiYgIXYudmFsdWUub25lcnJvciApIHtcblx0XHRcdFx0aWYgKCAhc3RlcC5zdWNjZXNzX2Vycm9yIClcblx0XHRcdFx0XHRzdGVwLnN1Y2Nlc3NfZXJyb3IgPSB7XG5cdFx0XHRcdFx0XHRvbnN1Y2Nlc3MoIGV2ZW50ICkgeyBzdGVwLm5leHQoIGV2ZW50LnRhcmdldC5yZXN1bHQgKSB9LFxuXHRcdFx0XHRcdFx0b25lcnJvciggZXZlbnQgKSB7IHN0ZXAuZmFpbCggZXZlbnQudGFyZ2V0LmVycm9yIHx8IGV2ZW50ICkgfSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdHYudmFsdWUub25zdWNjZXNzID0gc3RlcC5zdWNjZXNzX2Vycm9yLm9uc3VjY2Vzc1xuXHRcdFx0XHR2LnZhbHVlLm9uZXJyb3IgPSBzdGVwLnN1Y2Nlc3NfZXJyb3Iub25lcnJvclxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGB0aHJlYWQgdHlwZSBlcnJvcmAgKVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblxuXHRfZG9uZSgpIHtcblx0XHR0aGlzLl9zdGVwID0gbnVsbFxuXHRcdHRoaXMuX2l0ZXJhdG9yID0gbnVsbFxuXHRcdHRoaXMuX3N0YWNrID0gbnVsbFxuXHRcdHRoaXMuX3Jlc29sdmUgPSBudWxsXG5cdFx0dGhpcy5fcmVqZWN0ID0gbnVsbFxuXHRcdHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbnVsbFxuXHRcdHRoaXMuX2tpbGxpbmcgPSBudWxsXG5cdH1cblxuXHRfbmV3U3RlcCgpIHtcblx0XHRsZXQgc3RlcCA9IHRoaXMuX3N0ZXAgPSB7IHJlc3VtZTogbnVsbCB9XG5cdFx0c3RlcC5uZXh0ID0gdGhpcy5fdGljay5iaW5kKCB0aGlzLCBzdGVwLCBpdGVyYXRvck5leHQgKVxuXHRcdHN0ZXAuZmFpbCA9IHRoaXMuX3RpY2suYmluZCggdGhpcywgc3RlcCwgaXRlcmF0b3JUaHJvdyApXG5cdFx0bGV0ICRuYW1lID0gdGhpcy4kbmFtZVxuXHRcdHN0ZXAubmV4dC4kbmFtZSA9IHsgdG9TdHJpbmc6ICgpID0+ICRuYW1lICsgYDpuZXh0YCB9XG5cdFx0c3RlcC5mYWlsLiRuYW1lID0geyB0b1N0cmluZzogKCkgPT4gJG5hbWUgKyBgOmZhaWxgIH1cblx0fVxuXG5cdF9vblByb21pc2UoIHJlc29sdmUsIHJlamVjdCApIHtcblx0XHR0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZVxuXHRcdHRoaXMuX3JlamVjdCA9IHJlamVjdFxuXHRcdHRoaXMucmVzdW1lKClcblx0fVxuXG5cdF9jaGVja0ZpbmlzaGVkKCkge1xuXHRcdGlmICggdGhpcy5pc0ZpbmlzaGVkKCkgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgdGhyZWFkIGlzIGFscmVhZHkgZmluaXNoZWRgIClcblx0fVxuXG59XG5leHBvcnRzLlRocmVhZCA9IFRocmVhZFxuXG57XG5cdGxldCBub3RFbnVtZXJhYmxlID0geyBlbnVtZXJhYmxlOiBmYWxzZSB9XG5cdE9iamVjdC5rZXlzKCBUaHJlYWQucHJvdG90eXBlICkuZm9yRWFjaCggayA9PiBrLm1hdGNoKCAvXl8vICkgJiZcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIFRocmVhZC5wcm90b3R5cGUsIGssIG5vdEVudW1lcmFibGUgKSApXG5cblx0bGV0IG1haW5UaHJlYWQgPSAoIG5ldyBUaHJlYWQoIHsgbmV4dCgpIHsgcmV0dXJuIHsgdmFsdWU6IHsgdGhlbigpIHt9IH0gfSB9IH0gKSApLndhaXRGb3JJbnB1dCgpXG5cdGV4cG9ydHMuY3VycmVudCA9IG51bGxcblx0ZXhwb3J0cy5nbG9iYWwgPSBtYWluVGhyZWFkLmdsb2JhbFxuXHRleHBvcnRzLmNiID0gbnVsbFxufVxuIiwibGV0IGNvID0gcmVxdWlyZSggYGNvYCApXG5sZXQgcmEgPSByZXF1aXJlKCBgcmFgIClcbmxldCBsb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5cbmZ1bmN0aW9uIHRvTm9kZSggY2hpbGQsIG5vZGUgKSB7XG5cdHJlc3RhcnQ6IGZvciAoOzspIHtcblx0XHRjaGlsZCA9IGNoaWxkICYmIHR5cGVvZiBjaGlsZC52YWx1ZU9mID09IGBmdW5jdGlvbmAgPyBjaGlsZC52YWx1ZU9mKCkgOiBjaGlsZFxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggY2hpbGQgKSApIHtcblx0XHRcdGlmICggY2hpbGQubGVuZ3RoID09IDAgKVxuXHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0aWYgKCBjaGlsZC5sZW5ndGggPT0gMSApIHtcblx0XHRcdFx0Y2hpbGQgPSBjaGlsZFsgMCBdXG5cdFx0XHRcdGNvbnRpbnVlIHJlc3RhcnRcblx0XHRcdH1cblx0XHRcdGlmICggIW5vZGUgKVxuXHRcdFx0XHRub2RlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRjaGlsZC5mb3JFYWNoKCBjaGlsZCA9PiB0b05vZGUoIGNoaWxkLCBub2RlICkgKVxuXHRcdFx0Y2hpbGQgPSBub2RlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKCB0eXBlb2YgY2hpbGQgPT0gYHN0cmluZ2AgKVxuXHRcdFx0XHRjaGlsZCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBjaGlsZCApXG5cdFx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoIGNoaWxkIClcblx0XHRcdFx0Y2hpbGQgPSBub2RlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjaGlsZFxuXHR9XG59XG5cbmZ1bmN0aW9uIGZjYWxjKCBmLCBjYiApIHtcblx0aWYgKCB0eXBlb2YgZiAhPSBgZnVuY3Rpb25gIClcblx0XHRjYiggZiApXG5cdGVsc2Uge1xuXHRcdGxldCBmaXJzdCA9IHRydWVcblx0XHRyYSggZmFsc2UsIGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHRpZiAoIGZpcnN0IClcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR5aWVsZCBjby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHRcdGxldCByZXQgPSBmKClcblx0XHRcdGlmICggcmV0ICYmIHJldC5uZXh0ICYmIHJldC50aHJvdyApXG5cdFx0XHRcdHJldCA9IHlpZWxkIHJldFxuXHRcdFx0Y2IoIHJldCApXG5cdFx0fSApXG5cdH1cbn1cblxuZnVuY3Rpb24gY2hlY2tET01Db250cm9sKCBjb250cm9sICkge1xuXHRsZXQgcSA9IFtcblx0XHRjb250cm9sLm93bmVyRG9jdW1lbnQgJiYgY29udHJvbC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0Y29udHJvbC5vd25lckRvY3VtZW50ICYmIGNvbnRyb2wub3duZXJEb2N1bWVudC5ib2R5LFxuXHRcdGRvY3VtZW50LmJvZHksXG5cdF0uZmlsdGVyKCBCb29sZWFuIClcblx0bGV0IHAgPSBjb250cm9sXG5cdHdoaWxlICggcCApIHtcblx0XHRpZiAoIHEuaW5kZXhPZiggcCApID49IDAgKSB7XG5cdFx0XHRyYS5mb3JjZUNhbGN1bGF0aW9ucygpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0cCA9IHAucGFyZW50Tm9kZVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldENvbnRlbnQoIGNvbnRyb2wsIGNvbnRlbnQsIGNiID0gbnVsbCApIHsgZmNhbGMoIGNvbnRlbnQsIGNvbnRlbnQgPT4ge1xuXHRjaGVja0RPTUNvbnRyb2woIGNvbnRyb2wgKVxuXHRsZXQgYyA9IHRvTm9kZSggY29udGVudCApXG5cdGlmICggYyApIHtcblx0XHRjaGVja0RPTUNvbnRyb2woIGNvbnRyb2wgKVxuXHRcdGNvbnRyb2wuaW5uZXJIVE1MID0gYGBcblx0XHRjb250cm9sLmFwcGVuZENoaWxkKCBjIClcblx0fVxuXHRlbHNlXG5cdFx0Y29udHJvbC5pbm5lckhUTUwgPSBgYFxuXHRjYiAmJiBjYigpXG59ICkgfVxuXG5mdW5jdGlvbiB0b0F0dHJTdHJpbmcoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKVxuXHRcdHJldHVybiB2YWx1ZS5tYXAoIHRvQXR0clN0cmluZyApLmpvaW4oIGAgYCApXG5cdGVsc2UgaWYgKCB2YWx1ZSApXG5cdFx0cmV0dXJuIGAkeyB2YWx1ZSB9YFxuXHRlbHNlXG5cdFx0cmV0dXJuIGBgXG59XG5cbmZ1bmN0aW9uIGFwcGVuZENvbnRlbnQoIGNvbnRlbnQsIGYgKSB7XG5cdGlmICggIWYgKVxuXHRcdGYgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0Zm9yICggbGV0IGMgb2YgY29udGVudCApIHtcblx0XHRpZiAoIHR5cGVvZiBjID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRsZXQgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGBzcGFuYCApXG5cdFx0XHRzZXRDb250ZW50KCBwLCBjIClcblx0XHRcdGYuYXBwZW5kQ2hpbGQoIHAgKVxuXHRcdH1cblx0XHRlbHNlIGlmICggYyBpbnN0YW5jZW9mIE5vZGUgKVxuXHRcdFx0Zi5hcHBlbmRDaGlsZCggYyApXG5cdFx0ZWxzZSBpZiAoIGMgIT0gbnVsbCAmJiB0eXBlb2YgYyAhPSBgc3RyaW5nYCAmJiBjWyBTeW1ib2wuaXRlcmF0b3IgXSApXG5cdFx0XHRmb3IgKCBsZXQgY2Mgb2YgYyApXG5cdFx0XHRcdGFwcGVuZENvbnRlbnQoIGNjLCBmIClcblx0XHRlbHNlXG5cdFx0XHRmLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggYyApIClcblx0fVxuXHRyZXR1cm4gZlxufVxuXG5sZXQgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIGZ1bmN0aW9uKiAoKSB7fSApXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGVFbGVtZW50KCBuYW1lLCBhdHRyaWJ1dGVzLCAuLi5jb250ZW50ICkge1xuXHRcdGlmICggdHlwZW9mIG5hbWUgPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRyZXR1cm4gbmFtZSggYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLl8gPyBPYmplY3QuYXNzaWduKCB7fSwgYXR0cmlidXRlcywgYXR0cmlidXRlcy5fLCB7IF86IG51bGwgfSApIDogKCBhdHRyaWJ1dGVzIHx8IDAgKSwgYXBwZW5kQ29udGVudCggY29udGVudCApIClcblx0XHRsZXQgb25DcmVhdGVcblx0XHRsZXQgcmV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggbmFtZSApXG5cdFx0bGV0IGNsYXNzZXMgPSBbXVxuXHRcdGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyggYXR0cmlidXRlcyApIHtcblx0XHRcdGlmICggYXR0cmlidXRlcyA9PSBudWxsIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRsb2Rhc2guZm9yRWFjaCggYXR0cmlidXRlcywgKCB2YWx1ZSwgbmFtZSApID0+IHtcblx0XHRcdFx0aWYgKCBuYW1lID09IGBfYCApIHsgLy8gbm9vcFxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBuYW1lID09IGBjbGFzc2AgKVxuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCggdmFsdWUgKVxuXHRcdFx0XHRlbHNlIGlmICggbmFtZSA9PSBgc3R5bGVgIClcblx0XHRcdFx0XHQvLyBUT0RPOiBzbXRoIGxpa2UgdG8gXCJjbGFzc1wiIGF0dHJpYnV0ZSAtIHBhcnNlIHBhcmVudCBzdHlsZSBhbmQgdXBkYXRlIGl0XG5cdFx0XHRcdFx0ZmNhbGMoIHZhbHVlLCB2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PSBgc3RyaW5nYCApXG5cdFx0XHRcdFx0XHRcdHJldC5zZXRBdHRyaWJ1dGUoIGBzdHlsZWAsIHZhbHVlIClcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0bG9kYXNoLmZvckVhY2goIHZhbHVlLCAoIHZhbHVlLCBuYW1lICkgPT4gZmNhbGMoIHZhbHVlLCB2YWx1ZSA9PiByZXQuc3R5bGVbIG5hbWUgXSA9IHZhbHVlICkgKVxuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRlbHNlIGlmICggbmFtZSA9PSBgb25jcmVhdGVgIClcblx0XHRcdFx0XHRvbkNyZWF0ZSA9IHZhbHVlXG5cdFx0XHRcdGVsc2UgaWYgKCBuYW1lLm1hdGNoKCAvXm9uLyApICkge1xuXHRcdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09IGBmdW5jdGlvbmAgKVxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IFsgdmFsdWUgXVxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGhhbmRsZXIgb2YgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggT2JqZWN0LmdldFByb3RvdHlwZU9mKCBoYW5kbGVyICkgPT0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUgKVxuXHRcdFx0XHRcdFx0XHRcdGhhbmRsZXIgPSBjby5ldmVudEhhbmRsZXIoIGhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHRcdHJldC5hZGRFdmVudExpc3RlbmVyKCBuYW1lLnNsaWNlKCBgb25gLmxlbmd0aCApLCBoYW5kbGVyIClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGZjYWxjKCB2YWx1ZSwgdmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB0b0F0dHJTdHJpbmcoIHZhbHVlIClcblx0XHRcdFx0XHRcdGlmICggcmV0LmdldEF0dHJpYnV0ZSggbmFtZSApICE9IHZhbHVlIClcblx0XHRcdFx0XHRcdFx0cmV0LnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKVxuXHRcdFx0XHRcdH0gKVxuXHRcdFx0fSApXG5cdFx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggYXR0cmlidXRlcywgYF9gICkgKVxuXHRcdFx0XHRhcHBseUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMuXyApXG5cdFx0fVxuXHRcdGFwcGx5QXR0cmlidXRlcyggYXR0cmlidXRlcyApXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdGxldCBjb3B5ID0gY2xhc3Nlcy5tYXAoICgpID0+IG51bGwgKVxuXHRcdFx0Y2xhc3Nlcy5mb3JFYWNoKCAoIGMsIGkgKSA9PiBmY2FsYyggYywgYyA9PiB7XG5cdFx0XHRcdGNvcHlbIGkgXSA9IGNcblx0XHRcdFx0bGV0IGNsYXNzTmFtZSA9IHRvQXR0clN0cmluZyggY29weSApXG5cdFx0XHRcdFx0LnJlcGxhY2UoIC8oXnxcXHN8XFxyfFxcbikobnVsbHx1bmRlZmluZWR8ZmFsc2V8MHxcXC0wfE5hTikoPz0kfFxcc3xcXHJ8XFxuKS9nLCBgYCApXG5cdFx0XHRcdGlmICggcmV0LmNsYXNzTmFtZSAhPSBjbGFzc05hbWUgKVxuXHRcdFx0XHRcdHJldC5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHRcdH0gKSApXG5cdFx0fVxuXHRcdHN3aXRjaCAoIGNvbnRlbnQubGVuZ3RoICkge1xuXHRcdGNhc2UgMDpcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAxOlxuXHRcdFx0c2V0Q29udGVudCggcmV0LCBjb250ZW50WyAwIF0gKVxuXHRcdFx0YnJlYWtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0LmFwcGVuZENoaWxkKCBhcHBlbmRDb250ZW50KCBjb250ZW50ICkgKVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2Ygb25DcmVhdGUgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdG9uQ3JlYXRlLmNhbGwoIHJldCwge1xuXHRcdFx0XHR0eXBlOiBgY3JlYXRlYCxcblx0XHRcdFx0dGFyZ2V0OiByZXQsXG5cdFx0XHRcdHNyY0VsZW1lbnQ6IHJldCxcblx0XHRcdFx0Y3VycmVudFRhcmdldDogcmV0LFxuXHRcdFx0fSApXG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fSxcbn1cblxubGV0IHVwZGF0ZUlucHV0VmFsdWUgPSBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoICgpID0+IHRoaXMuX3JhVmFsdWUuYXNzaWduKCB0aGlzLnZhbHVlICkgKSB9XG5sZXQgcmFWYWx1ZSA9IHtcblx0Z2V0KCkge1xuXHRcdGlmICggIXRoaXMuX3JhVmFsdWUgKSByYS5kZXRhY2goICgpID0+IHtcblx0XHRcdHRoaXMuX3JhVmFsdWUgPSByYSgpXG5cdFx0XHR0aGlzLl9yYVZhbHVlLmFzc2lnbiggdGhpcy52YWx1ZSApXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGBjaGFuZ2VgLCB1cGRhdGVJbnB1dFZhbHVlIClcblx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggYGtleXByZXNzYCwgdXBkYXRlSW5wdXRWYWx1ZSApXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGBrZXlkb3duYCwgdXBkYXRlSW5wdXRWYWx1ZSApXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGBrZXl1cGAsIHVwZGF0ZUlucHV0VmFsdWUgKVxuXHRcdH0gKVxuXHRcdHJldHVybiB0aGlzLl9yYVZhbHVlLnZhbHVlT2YoKVxuXHR9LFxuXHRzZXQoIHZhbHVlICkge1xuXHRcdGlmICggdGhpcy52YWx1ZSAhPSB2YWx1ZSApIHtcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZVxuXHRcdFx0aWYgKCB0aGlzLl9yYVZhbHVlIClcblx0XHRcdFx0dGhpcy5fcmFWYWx1ZS5hc3NpZ24oIHRoaXMudmFsdWUgKVxuXHRcdH1cblx0fSxcbn1cblxuZm9yICggbGV0IEMgb2YgWyBIVE1MSW5wdXRFbGVtZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50IF0gKVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEMucHJvdG90eXBlLCBgcmFWYWx1ZWAsIHJhVmFsdWUgKVxuIiwibGV0IGxvZGFzaCA9IHJlcXVpcmUoIGBsb2Rhc2hgIClcbmxldCBVSUQgPSByZXF1aXJlKCBgdWlkYCApXG5sZXQgbHUgPSByZXF1aXJlKCBgbG9jYWxVdGlsc2AgKVxuXG5leHBvcnRzLkNsZWFyID0gZXhwb3J0cy5VbmxpbmsgPSAoIGRldmljZXMsIGRldmljZUlkICkgPT4gbG9kYXNoLnJlZHVjZSggZGV2aWNlcy5jb250ZW50LCAoIHJldCwgcSwgaW5kZXggKSA9PiB7XG5cdGlmICggcSApXG5cdFx0aWYgKCBpbmRleCA9PSBkZXZpY2VJZCApXG5cdFx0XHRyZXQuY29udGVudFsgaW5kZXggXSA9IG51bGxcblx0XHRlbHNlIGlmICggcS5jb250ZW50ICYmIHEuY29udGVudFsgZGV2aWNlSWQgXSApXG5cdFx0XHRyZXQuY29udGVudFsgaW5kZXggXSA9IHsgY29udGVudDogeyBbIGRldmljZUlkIF06IG51bGwgfSB9XG5cdHJldHVybiByZXRcbn0sIHsgY29udGVudDoge30gfSApXG5cbmV4cG9ydHMuU2V0ID0gKCBkZXZpY2VzLCBkZXZpY2VJZCwgZGF0YSApID0+IHtcblx0bGV0IGRldmljZSA9IGRldmljZXMuY29udGVudFsgZGV2aWNlSWQgXVxuXHRpZiAoICFkZXZpY2UgfHwgIWRldmljZS5ncm91cCApXG5cdFx0cmV0dXJuXG5cdGxldCByZXQgPSB7IGNvbnRlbnQ6IHsgWyBkZXZpY2VJZCBdOiBkYXRhIH0gfVxuXHRpZiAoIGRldmljZS50eXBlID09IGBncm91cGAgKVxuXHRcdHJldCA9IGxvZGFzaC5yZWR1Y2UoIGRldmljZS5jb250ZW50LCAoIHJldCwgcSwgaW5kZXggKSA9PiB7XG5cdFx0XHRpZiAoIHEgKVxuXHRcdFx0XHRyZXQuY29udGVudFsgaW5kZXggXSA9IGRhdGFcblx0XHRcdHJldHVybiByZXRcblx0XHR9LCByZXQgKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydHMuZmluZEZyZWVHcm91cCA9IGRldmljZXMgPT4ge1xuXHRsZXQgZ3JvdXBzID0gW11cblx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IDEwMjI7ICsraSApXG5cdFx0Z3JvdXBzWyBpIF0gPSBpXG5cdGxvZGFzaC5mb3JFYWNoKCBkZXZpY2VzLmNvbnRlbnQsIGRldmljZSA9PiBkZXZpY2UgJiYgTnVtYmVyLmlzRmluaXRlKCBkZXZpY2UuZ3JvdXAgKSAmJiAoIGdyb3Vwc1sgZGV2aWNlLmdyb3VwIF0gPSBmYWxzZSApIClcblx0Z3JvdXBzID0gZ3JvdXBzLmZpbHRlciggQm9vbGVhbiApXG5cdHJldHVybiAhZ3JvdXBzLmxlbmd0aCA/IG51bGwgOiBncm91cHNbIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiBncm91cHMubGVuZ3RoICkgJSBncm91cHMubGVuZ3RoIF1cbn1cblxuZXhwb3J0cy5jbGVhbkRhdGFiYXNlID0gZGV2aWNlcyA9PiB7XG5cdGxldCByZXQgPSBkZXZpY2VzIHx8IHt9XG5cdGZ1bmN0aW9uIF9zYXZlKCBkaWZmICkge1xuXHRcdHJldCA9IGx1LmFwcGx5RGlmZiggcmV0LCBkaWZmIClcblx0fVxuXHRmdW5jdGlvbiBfY2hhbmdlKCBwYXRoLCB2YWx1ZSApIHtcblx0XHRfc2F2ZSggcGF0aC5yZWR1Y2VSaWdodCggKCByZXQsIGtleSApID0+ICggeyBbIGtleSBdOiByZXQgfSApLCB2YWx1ZSApIClcblx0fVxuXHRmdW5jdGlvbiBhc3NpZ24oIC4uLnBhdGggKSB7XG5cdFx0X2NoYW5nZSggcGF0aCwgcGF0aC5wb3AoKSApXG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlKCAuLi5wYXRoICkge1xuXHRcdF9jaGFuZ2UoIHBhdGgsIG51bGwgKVxuXHR9XG5cblx0Ly8gbW92ZSByb290IGl0ZW1zIHRvIGNvbnRlbnRcblx0aWYgKCAhcmV0LmNvbnRlbnQgKVxuXHRcdGxvZGFzaC5mb3JFYWNoKCByZXQsICggcGxhY2UsIHBsYWNlSWQgKSA9PiB7XG5cdFx0XHRpZiAoIHBsYWNlICE9IG51bGwgJiYgdHlwZW9mIHBsYWNlICE9IGBvYmplY3RgIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRyZW1vdmUoIHBsYWNlSWQgKVxuXHRcdFx0YXNzaWduKCBgY29udGVudGAsIHBsYWNlSWQsIHBsYWNlIClcblx0XHR9IClcblx0ZWxzZSAvLyBUT0RPIGRlbGV0ZSBsYXRlclxuXHRcdGxvZGFzaC5mb3JFYWNoKCByZXQsICggcGxhY2UsIHBsYWNlSWQgKSA9PiB7XG5cdFx0XHRpZiAoIHBsYWNlICE9IG51bGwgJiYgdHlwZW9mIHBsYWNlICE9IGBvYmplY3RgIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRpZiAoIHBsYWNlSWQgPT0gYGNvbnRlbnRgIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRyZW1vdmUoIHBsYWNlSWQgKVxuXHRcdH0gKVxuXG5cdC8vIHJlbW92ZSBpdGVtcyB3aXRoIHdyb25nIHR5cGUgJiByZW1vdmUgZ3JvdXAgZnJvbSBwbGFjZXNcblx0bG9kYXNoLmZvckVhY2goIHJldC5jb250ZW50LCAoIHBsYWNlLCBwbGFjZUlkICkgPT4ge1xuXHRcdGlmICggcGxhY2UgPT0gbnVsbCB8fCB0eXBlb2YgcGxhY2UgIT0gYG9iamVjdGAgKVxuXHRcdFx0cmV0dXJuIHJlbW92ZSggYGNvbnRlbnRgLCBwbGFjZUlkICApXG5cdFx0aWYgKCBwbGFjZS50eXBlID09IGBkZXZpY2VgICkgLy8gVE9ETzogcmVtb3ZlIGxhdGVyXG5cdFx0XHRhc3NpZ24oIGBjb250ZW50YCwgcGxhY2VJZCwgYHR5cGVgLCBgc2luZ2xlYCApXG5cdFx0aWYgKCBwbGFjZS5kZXZpY2UgPT0gcGxhY2VJZCApXG5cdFx0XHRyZW1vdmUoIGBjb250ZW50YCwgcGxhY2VJZCwgYGRldmljZWAgKVxuXHRcdGVsc2UgaWYgKCAhKCBwbGFjZS50eXBlIHx8IGBgICkubWF0Y2goIC9eKHBsYWNlfGdyb3VwfHNpbmdsZSkkLyApIClcblx0XHRcdHJldHVybiByZW1vdmUoIGBjb250ZW50YCwgcGxhY2VJZCApXG5cdFx0aWYgKCBwbGFjZS5ncm91cCAhPSBudWxsICYmICggIU51bWJlci5pc0Zpbml0ZSggcGxhY2UuZ3JvdXAgKSB8fCBwbGFjZS50eXBlID09IGBwbGFjZWAgKSApXG5cdFx0XHRyZW1vdmUoIGBjb250ZW50YCwgcGxhY2VJZCwgYGdyb3VwYCApXG5cdH0gKVxuXG5cdC8vIGNyZWF0ZSBtYWluXG5cdGlmICggcmV0ICYmIHR5cGVvZiByZXQubWFpbiAhPSBgc3RyaW5nYCApIHtcblx0XHRsZXQgbWFpbiA9IFVJRCgpXG5cdFx0bGV0IGkgPSAwXG5cdFx0bG9kYXNoLmZvckVhY2goIHJldC5jb250ZW50LCAoIHBsYWNlLCBrZXkgKSA9PiBhc3NpZ24oIGBjb250ZW50YCwgbWFpbiwgYGNvbnRlbnRgLCBrZXksICsraSApIClcblx0XHRpZiAoIHJldC5jb250ZW50ICYmIHJldC5jb250ZW50WyBtYWluIF0gKVxuXHRcdFx0YXNzaWduKCBgbWFpbmAsIG1haW4gKVxuXHR9XG5cblx0Ly8gcmVtb3ZlIGl0ZW1zIHdpdGggZHVwbGljYXRlIGdyb3VwXG5cdGxldCByZWFjaGFibGVcblx0ZnVuY3Rpb24gZ3JvdXBJbmRleCgga2V5ICkge1xuXHRcdGlmICggIXJlYWNoYWJsZSApIHtcblx0XHRcdHJlYWNoYWJsZSA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0bGV0IHJlYWNoYWJsZUtleXMgPSBbXVxuXHRcdFx0ZnVuY3Rpb24gcHVzaCgga2V5ICkge1xuXHRcdFx0XHRpZiAoICEoIGtleSBpbiByZWFjaGFibGUgKSAmJiByZXQuY29udGVudC5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0cmVhY2hhYmxlWyBrZXkgXSA9IHRydWVcblx0XHRcdFx0XHRyZWFjaGFibGVLZXlzLnB1c2goIGtleSApXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGtleVxuXHRcdFx0fVxuXHRcdFx0cHVzaCggcmV0Lm1haW4gKVxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcmVhY2hhYmxlS2V5cy5sZW5ndGg7ICsraSApIHtcblx0XHRcdFx0bGV0IHBsYWNlID0gcmV0LmNvbnRlbnRbIHJlYWNoYWJsZUtleXNbIGkgXSBdXG5cdFx0XHRcdGlmICggcGxhY2UgJiYgcGxhY2UuY29udGVudCApXG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoIHBsYWNlLmNvbnRlbnQgKS5mb3JFYWNoKCBwdXNoIClcblx0XHRcdH1cblx0XHR9XG5cdFx0bGV0IGkgPSAwXG5cdFx0aWYgKCByZXQuY29udGVudFsga2V5IF0udHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdGkgKz0gMlxuXHRcdGlmICgga2V5IGluIHJlYWNoYWJsZSApXG5cdFx0XHRpICs9IDFcblx0fVxuXG5cdGxldCBncm91cHMgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0bG9kYXNoLmZvckVhY2goIHJldC5jb250ZW50LCAoIHBsYWNlLCBrZXkgKSA9PiB7XG5cdFx0aWYgKCAhcGxhY2UgfHwgcGxhY2UuZ3JvdXAgPT0gbnVsbCApXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoICFncm91cHNbIHBsYWNlLmdyb3VwIF0gKVxuXHRcdFx0Z3JvdXBzWyBwbGFjZS5ncm91cCBdID0ga2V5XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoIGdyb3VwSW5kZXgoIGdyb3Vwc1sgcGxhY2UuZ3JvdXAgXSApIDwgZ3JvdXBJbmRleCgga2V5ICkgKSB7XG5cdFx0XHRcdHJlbW92ZSggYGNvbnRlbnRgLCBncm91cHNbIHBsYWNlLmdyb3VwIF0gKVxuXHRcdFx0XHRncm91cHNbIHBsYWNlLmdyb3VwIF0gPSBrZXlcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0cmVtb3ZlKCBgY29udGVudGAsIGtleSApXG5cdFx0fVxuXHR9IClcblxuXHQvLyBjaGVjayBjb250ZW50XG5cdGxvZGFzaC5mb3JFYWNoKCByZXQuY29udGVudCwgKCBwbGFjZSwga2V5ICkgPT4ge1xuXHRcdGlmICggIXBsYWNlIHx8IHBsYWNlLmNvbnRlbnQgPT0gbnVsbCApXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoIHR5cGVvZiBwbGFjZS5jb250ZW50ICE9IGBvYmplY3RgIClcblx0XHRcdHJldHVybiByZW1vdmUoIGBjb250ZW50YCwga2V5LCBgY29udGVudGAgKVxuXHRcdGxvZGFzaC5mb3JFYWNoKCBwbGFjZS5jb250ZW50LCAoIF8sIGNrZXkgKSA9PiB7XG5cdFx0XHRpZiAoICFyZXQuY29udGVudFsgY2tleSBdIHx8IHR5cGVvZiByZXQuY29udGVudFsgY2tleSBdICE9IGBvYmplY3RgIClcblx0XHRcdFx0cmVtb3ZlKCBgY29udGVudGAsIGtleSwgYGNvbnRlbnRgLCBja2V5IClcblx0XHR9IClcblx0XHRwbGFjZSA9IHJldC5jb250ZW50WyBrZXkgXSAvLyByZWFzc2lnbiBwbGFjZSBjYXVzZSBpdCBjb3VsZCBjaGFuZ2UgaW4gcHJldmlvdXMgZm9yRWFjaFxuXHRcdGxvZGFzaC5rZXlzKCBwbGFjZS5jb250ZW50IClcblx0XHQuc29ydCggKCBhLCBiICkgPT4gKCBwbGFjZS5jb250ZW50WyBhIF0uaW5kZXggfHwgMCApIC0gKCBwbGFjZS5jb250ZW50WyBiIF0uaW5kZXggfHwgMCApIClcblx0XHQuZm9yRWFjaCggKCBja2V5LCBpbmRleCApID0+IHtcblx0XHRcdGlmICggcGxhY2UuY29udGVudFsgY2tleSBdLmluZGV4ICE9IGluZGV4IClcblx0XHRcdFx0YXNzaWduKCBgY29udGVudGAsIGtleSwgYGNvbnRlbnRgLCBja2V5LCBgaW5kZXhgLCBpbmRleCApXG5cdFx0fSApXG5cdH0gKVxuXG5cdHJldHVybiBsdS5tYWtlRGlmZiggZGV2aWNlcywgcmV0IClcbn1cbiIsIi8qXG5cbjIwMTQuMDkuMjJcblxuaXQgc2hvdWxkIGJlIGJldHRlciB0byB1c2UgaGFtbWVyLmpzLCBidXQgaSBjYW5ub3QgdXNlIGl0IHdpdGhvdXQgcHJvYmxlbXMgLVxuaGFtbWVyLmpzIG9mdGVuIGRyb3BzIGV2ZW50cywgd2hpbGUgZGlyZWN0IGFkZEV2ZW50TGlzdGVuZXIgZG9lcyBub3QuXG5cbiovXG5cbmxldCBjbyA9IHJlcXVpcmUoIGBjb2AgKVxubGV0IHNwYXJzZXF1ZXVlID0gcmVxdWlyZSggYHNwYXJzZXF1ZXVlYCApXG5cbmxldCBUUkFDRVxuLy8gbGV0IFRDID0gMFxuLy8gVFJBQ0UgPSAoIC4uLmluZm8gKSA9PiBMT0coIGAkeyArK1RDIH0gZyAkeyBKU09OLnN0cmluZ2lmeSggaW5mbyApLnNsaWNlKCAwLCAxMDAgKSB9YC5ncmVlbiApXG5cbmxldCBTV0lQRV9USU1FT1VUID0gNDAwIC8vIG1zXG5sZXQgUFJFU1NfVElNRU9VVCA9IDUwMCAvLyBtc1xubGV0IFBSRVNTX01PVkVfT1VUID0gMiAvKiB+bW0gKi8gKiAoIDk2IC8gMjUuNCApXG5cbmZ1bmN0aW9uIHNxdWFyZURpc3RhbmNlKCBwMSwgcDIgKSB7XG5cdHJldHVybiAoIHAxLnBhZ2VYIC0gcDIucGFnZVggKSAqICggcDEucGFnZVggLSBwMi5wYWdlWCApICsgKCBwMS5wYWdlWSAtIHAyLnBhZ2VZICkgKiAoIHAxLnBhZ2VZIC0gcDIucGFnZVkgKVxufVxuXG5mdW5jdGlvbiBnZXRYKCBwICkgeyByZXR1cm4gcC5wYWdlWCB9XG5mdW5jdGlvbiBnZXRZKCBwICkgeyByZXR1cm4gcC5wYWdlWSB9XG5mdW5jdGlvbiBpbmNyZWFzaW5nKCB2LCBpLCBwICkgeyByZXR1cm4gaSA9PSAwIHx8IHYgPj0gcFsgaSAtIDEgXSB9XG5mdW5jdGlvbiBkZWNyZWFzaW5nKCB2LCBpLCBwICkgeyByZXR1cm4gaSA9PSAwIHx8IHYgPD0gcFsgaSAtIDEgXSB9XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIGB0b3VjaGAsIGNvLmV2ZW50SGFuZGxlciggZnVuY3Rpb24qICggZXZlbnQgKSB7XG5cblx0bGV0IGFsbFxuXHRsZXQgdHJhY2UgPSBbIGV2ZW50IF1cblx0bGV0IGxhc3QgPSBldmVudFxuXHRsZXQgcHJlc3NlZCA9IG51bGxcblx0bGV0IHN3aXBlZCA9IGZhbHNlXG5cblx0bGV0IHBhbiA9IG51bGxcblx0bGV0IHBhbmxvY2sgPSBudWxsXG5cdGxldCBzZW50ID0gZXZlbnRcblxuXHRjby5kZWZlciggKCkgPT4ge1xuXHRcdHBhbmxvY2sgJiYgcGFubG9jay5mb3JFYWNoKCBsb2NrID0+IGxvY2sucXVldWUuY2xvc2UoKSApXG5cdFx0cGFuICYmIHBhbi5xdWV1ZS5jbG9zZSgpXG5cdH0gKVxuXG5cdGZ1bmN0aW9uIHNlbmQoIHR5cGUsIGRpcmVjdGlvbiwgcHQsIGRldGFpbCwgdHlwZURpcmVjdGlvbiApIHtcblx0XHRUUkFDRSAmJiBUUkFDRSggdHlwZSwgYWxsIClcblx0XHRpZiAoIHR5cGVEaXJlY3Rpb24gPT0gbnVsbCApXG5cdFx0XHR0eXBlRGlyZWN0aW9uID0gZGlyZWN0aW9uXG5cdFx0aWYgKCAhZGV0YWlsIClcblx0XHRcdGRldGFpbCA9IHt9XG5cdFx0ZGV0YWlsLmRpcmVjdGlvbiA9IGRpcmVjdGlvblxuXHRcdGRldGFpbC5wcmVzc2VkID0gcHJlc3NlZFxuXHRcdGRldGFpbC50eXBlID0gdHlwZVxuXHRcdGRldGFpbC5zdGFydCA9IGV2ZW50XG5cdFx0ZGV0YWlsLm9yaWdpbmFsID0gcHQgfHwgZXZlbnRcblx0XHRsZXQgcmV0ID0gbmV3IEN1c3RvbUV2ZW50KCB0eXBlICsgKCB0eXBlRGlyZWN0aW9uIHx8IGBgICksIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgZGV0YWlsIH0gKVxuXHRcdHJldC5wYWdlWCA9IGxhc3QucGFnZVhcblx0XHRyZXQucGFnZVkgPSBsYXN0LnBhZ2VZXG5cdFx0cmV0LmNsaWVudFggPSBsYXN0LmNsaWVudFhcblx0XHRyZXQuY2xpZW50WSA9IGxhc3QuY2xpZW50WVxuXHRcdHJldC5zY3JlZW5YID0gbGFzdC5zY3JlZW5YXG5cdFx0cmV0LnNjcmVlblkgPSBsYXN0LnNjcmVlbllcblx0XHRyZXQuZGVsdGFYID0gbGFzdC5wYWdlWCAtIGV2ZW50LnBhZ2VYXG5cdFx0cmV0LmRlbHRhWSA9IGxhc3QucGFnZVkgLSBldmVudC5wYWdlWVxuXHRcdHJldC5sYXN0RGVsdGFYID0gbGFzdC5wYWdlWCAtIHNlbnQucGFnZVhcblx0XHRyZXQubGFzdERlbHRhWSA9IGxhc3QucGFnZVkgLSBzZW50LnBhZ2VZXG5cdFx0c2VudCA9IGxhc3Rcblx0XHRyZXQucHJldmVudERlZmF1bHQgPSAoKSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0ZXZlbnQudGFyZ2V0LmRpc3BhdGNoRXZlbnQoIHJldCApXG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cblx0ZnVuY3Rpb24gZW5zdXJlcGFuKCBkaXJlY3Rpb24gKSB7XG5cdFx0aWYgKCBwYW4gKVxuXHRcdFx0cmV0dXJuXG5cdFx0cGFuID0geyBxdWV1ZTogbmV3IHNwYXJzZXF1ZXVlIH1cblx0XHRzZW5kKCBgcGFuYCwgZGlyZWN0aW9uLCBsYXN0LCB7XG5cdFx0XHRuZXh0OiBwYW4ucXVldWUsXG5cdFx0XHRsb2NrKCkge1xuXHRcdFx0XHRpZiAoICFwYW5sb2NrIClcblx0XHRcdFx0XHRwYW5sb2NrID0gW11cblx0XHRcdFx0bGV0IHJldCA9IHsgcXVldWU6IG5ldyBzcGFyc2VxdWV1ZSB9XG5cdFx0XHRcdHBhbmxvY2sucHVzaCggcmV0IClcblx0XHRcdFx0cmV0dXJuIHJldC5xdWV1ZVxuXHRcdFx0fSxcblx0XHRcdHVubG9jayggbG9jayApIHtcblx0XHRcdFx0cGFubG9jayA9IHBhbmxvY2suZmlsdGVyKCBsID0+IGwgIT0gbG9jayApXG5cdFx0XHRcdGxldCBwID0gcGFubG9ja1sgMCBdIHx8IHBhblxuXHRcdFx0XHRpZiAoIHAuZGlydHkgKSB7XG5cdFx0XHRcdFx0cC5kaXJ0eSA9IGZhbHNlXG5cdFx0XHRcdFx0c2VuZHBhbiggYHBhbmAsIGB1bmxvY2tlZGAgKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0sIGBgIClcblx0fVxuXG5cdGZ1bmN0aW9uIHNlbmRwYW4oIHR5cGUsIGRpcmVjdGlvbiwgcHQsIGRldGFpbCApIHtcblx0XHRsZXQgZGF0YSA9IHNlbmQoIHR5cGUsIGRpcmVjdGlvbiwgcHQsIGRldGFpbCApXG5cdFx0aWYgKCBwYW4gKSB7XG5cdFx0XHRpZiAoIHBhbmxvY2sgJiYgcGFubG9jay5sZW5ndGggKSB7XG5cdFx0XHRcdHBhbmxvY2tbIDAgXS5xdWV1ZS5wdXNoKCBkYXRhIClcblx0XHRcdFx0cGFubG9jay5mb3JFYWNoKCAoIHAsIGkgKSA9PiBpID4gMCAmJiAoIHAuZGlydHkgPSB0cnVlICkgKVxuXHRcdFx0XHRwYW4uZGlydHkgPSB0cnVlXG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHBhbi5xdWV1ZS5wdXNoKCBkYXRhIClcblx0XHR9XG5cdH1cblxuXHRsZXQgcHJlc3NUaW1lb3V0XG5cdGxldCBzdG9wcGVkVGltZW91dFxuXHRjby5kZWZlciggKCkgPT4ge1xuXHRcdGNsZWFyVGltZW91dCggcHJlc3NUaW1lb3V0IClcblx0XHRjbGVhclRpbWVvdXQoIHN0b3BwZWRUaW1lb3V0IClcblx0fSApXG5cblx0cHJlc3NUaW1lb3V0ID0gc2V0VGltZW91dCggKCkgPT4ge1xuXHRcdHByZXNzZWQgPSB0cnVlXG5cdFx0c2VuZCggYHByZXNzYCApXG5cdH0sIFBSRVNTX1RJTUVPVVQgKVxuXG5cdGZ1bmN0aW9uIHN0YXJ0U3RvcHBlZFRpbWVvdXQoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCBzdG9wcGVkVGltZW91dCApXG5cdFx0c3RvcHBlZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRlbnN1cmVwYW4oKVxuXHRcdFx0c2VuZHBhbiggYHN0b3BgIClcblx0XHRcdHN0YXJ0U3RvcHBlZFRpbWVvdXQoKVxuXHRcdH0sIFBSRVNTX1RJTUVPVVQgKVxuXHR9XG5cblx0c3RhcnRTdG9wcGVkVGltZW91dCgpXG5cblx0VFJBQ0UgJiYgVFJBQ0UoIGBlbnRlcmAsIHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZLCB0OiBldmVudC50aW1lU3RhbXAgfSApXG5cblx0bGV0IHN0b3BQb2ludCA9IGV2ZW50XG5cblx0Zm9yICggbGV0IHB0OyBwdCA9IHlpZWxkIGV2ZW50LmRldGFpbC5uZXh0OyApIHtcblx0XHRpZiAoIFRSQUNFICkge1xuXHRcdFx0KCBhbGwgfHwgKCBhbGwgPSBbXSApICkucHVzaCggeyB4OiBwdC5wYWdlWCwgeTogcHQucGFnZVksIHQ6IHB0LnRpbWVTdGFtcCAtIGV2ZW50LnRpbWVTdGFtcCB9IClcblx0XHRcdFRSQUNFKCBgbmV4dGAsIGFsbCApXG5cdFx0fVxuXHRcdGlmICggbGFzdC50aW1lU3RhbXAgLSBldmVudC50aW1lU3RhbXAgPiBTV0lQRV9USU1FT1VUIClcblx0XHRcdHRyYWNlID0gbnVsbFxuXG5cdFx0bGV0IGxvbmdtb3ZlID0gc3F1YXJlRGlzdGFuY2UoIHB0LCBzdG9wUG9pbnQgKSA+IFBSRVNTX01PVkVfT1VUICogUFJFU1NfTU9WRV9PVVRcblx0XHRpZiAoIGxvbmdtb3ZlICkge1xuXHRcdFx0c3RvcFBvaW50ID0gcHRcblx0XHRcdHN0YXJ0U3RvcHBlZFRpbWVvdXQoKVxuXHRcdH1cblxuXHRcdGlmICggbG9uZ21vdmUgfHwgIXRyYWNlIHx8IHRyYWNlLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRpZiAoIHByZXNzZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0cHJlc3NlZCA9IGZhbHNlXG5cdFx0XHRcdGNsZWFyVGltZW91dCggcHJlc3NUaW1lb3V0IClcblx0XHRcdH1cblx0XHRcdGxldCBkeCA9IHB0LnBhZ2VYIC0gbGFzdC5wYWdlWFxuXHRcdFx0bGV0IGR5ID0gcHQucGFnZVkgLSBsYXN0LnBhZ2VZXG5cdFx0XHRpZiAoIGR4IHx8IGR5ICkge1xuXHRcdFx0XHRsZXQgc2l6ZXggPSBNYXRoLmFicyggZHggKVxuXHRcdFx0XHRsZXQgc2l6ZXkgPSBNYXRoLmFicyggZHkgKVxuXHRcdFx0XHRsZXQgcHJldiA9IGxhc3Rcblx0XHRcdFx0aWYgKCB0cmFjZSApXG5cdFx0XHRcdFx0dHJhY2UucHVzaCggbGFzdCApXG5cdFx0XHRcdGxhc3QgPSBwdFxuXHRcdFx0XHRsZXQgZGlyZWN0aW9uID0gYGBcblx0XHRcdFx0aWYgKCBzaXpleCA+PSBzaXpleSAmJiBkeCA+IDAgKVxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9IGByaWdodGBcblx0XHRcdFx0ZWxzZSBpZiAoIHNpemV4ID49IHNpemV5ICYmIGR4IDwgMCApXG5cdFx0XHRcdFx0ZGlyZWN0aW9uID0gYGxlZnRgXG5cdFx0XHRcdGVsc2UgaWYgKCBzaXpleCA8IHNpemV5ICYmIGR5ID4gMCApXG5cdFx0XHRcdFx0ZGlyZWN0aW9uID0gYGRvd25gXG5cdFx0XHRcdGVsc2UgaWYgKCBzaXpleCA8IHNpemV5ICYmIGR5IDwgMCApXG5cdFx0XHRcdFx0ZGlyZWN0aW9uID0gYHVwYFxuXHRcdFx0XHRlbnN1cmVwYW4oIGRpcmVjdGlvbiApXG5cdFx0XHRcdHNlbmRwYW4oIGBwYW5gLCBkaXJlY3Rpb24sIGxhc3QgKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjbGVhclRpbWVvdXQoIHByZXNzVGltZW91dCApXG5cdGlmICggbGFzdC50aW1lU3RhbXAgLSBldmVudC50aW1lU3RhbXAgPCBTV0lQRV9USU1FT1VUICYmIHRyYWNlICYmIHRyYWNlLmxlbmd0aCA+IDIgKSB7XG5cdFx0Ly8gcmVtb3ZlIGZpcnN0IHBvaW50IHRvIGVsaW1pbmF0ZSB0b3VjaCBib3VuY2luZyBlZmZlY3Rcblx0XHR0cmFjZS5zaGlmdCgpXG5cdFx0bGV0IHRyYWNlWCA9IHRyYWNlLm1hcCggZ2V0WCApXG5cdFx0bGV0IHRyYWNlWSA9IHRyYWNlLm1hcCggZ2V0WSApXG5cdFx0bGV0IGJvdW5kcyA9IHtcblx0XHRcdHg6IE1hdGgubWF4KCAuLi50cmFjZVggKSAtIE1hdGgubWluKCAuLi50cmFjZVggKSxcblx0XHRcdHk6IE1hdGgubWF4KCAuLi50cmFjZVkgKSAtIE1hdGgubWluKCAuLi50cmFjZVkgKSxcblx0XHR9XG5cdFx0bGV0IGRpcmVjdGlvbiA9IGBgXG5cdFx0aWYgKCBib3VuZHMueCA+IGJvdW5kcy55ICYmIHRyYWNlWC5ldmVyeSggaW5jcmVhc2luZyApIClcblx0XHRcdGRpcmVjdGlvbiA9IGByaWdodGBcblx0XHRlbHNlIGlmICggYm91bmRzLnggPiBib3VuZHMueSAmJiB0cmFjZVguZXZlcnkoIGRlY3JlYXNpbmcgKSApXG5cdFx0XHRkaXJlY3Rpb24gPSBgbGVmdGBcblx0XHRlbHNlIGlmICggYm91bmRzLnggPCBib3VuZHMueSAmJiB0cmFjZVkuZXZlcnkoIGluY3JlYXNpbmcgKSApXG5cdFx0XHRkaXJlY3Rpb24gPSBgZG93bmBcblx0XHRlbHNlIGlmICggYm91bmRzLnggPCBib3VuZHMueSAmJiB0cmFjZVkuZXZlcnkoIGRlY3JlYXNpbmcgKSApXG5cdFx0XHRkaXJlY3Rpb24gPSBgdXBgXG5cdFx0aWYgKCBkaXJlY3Rpb24gKSB7XG5cdFx0XHRzd2lwZWQgPSB0cnVlXG5cdFx0XHRzZW5kcGFuKCBgc3dpcGVgLCBkaXJlY3Rpb24sIGxhc3QgKVxuXHRcdH1cblx0fVxuXHRpZiAoICFwcmVzc2VkICYmICFzd2lwZWQgJiYgIXBhbiApXG5cdFx0c2VuZHBhbiggYHRhcGAgKVxuXHRUUkFDRSAmJiBUUkFDRSggYGRvbmVgLCBhbGwgKVxufSApIClcbiIsImxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGBkaXZgICkuc3R5bGVcbmlmICggISggYHRyYW5zZm9ybWAgaW4gc3R5bGUgKSAmJiAoIGB3ZWJraXRUcmFuc2Zvcm1gIGluIHN0eWxlICkgKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUsIGB0cmFuc2Zvcm1gLCB7XG5cdFx0Z2V0KCkgeyByZXR1cm4gdGhpcy53ZWJraXRUcmFuc2Zvcm0gfSxcblx0XHRzZXQoIHZhbHVlICkgeyB0aGlzLndlYmtpdFRyYW5zZm9ybSA9IHZhbHVlIH0sXG5cdH0gKVxufVxuXG4vLyBsZXQgc2xpY2UgPSBbXS5zbGljZVxuXG5pZiAoICFOb2RlTGlzdC5wcm90b3R5cGVbIFN5bWJvbC5pdGVyYXRvciBdIClcblx0Tm9kZUxpc3QucHJvdG90eXBlWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGZ1bmN0aW9uKiAoKSB7XG5cdFx0Ly8gcmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKVsgU3ltYm9sLml0ZXJhdG9yIF1cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7ICsraSApXG5cdFx0XHR5aWVsZCB0aGlzLml0ZW0oIGkgKVxuXHR9XG5cbiIsImV4cG9ydHMucHJldmVudERlZmF1bHQgPSBldmVudCA9PiBldmVudCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbmV4cG9ydHMuU3VibWl0ID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0ZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRsZXQgYyA9IHRoaXNcblx0d2hpbGUgKCBjICYmICEoIGMgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQgKSApXG5cdFx0YyA9IGMucGFyZW50Tm9kZVxuXHRpZiAoIGMgKVxuXHRcdGMuZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KCBgc3VibWl0YCwgbnVsbCApIClcblx0cmV0dXJuIGZhbHNlXG59XG5cbmxldCBjZW50ZXJlZCA9IGBcblx0d2lkdGg6IDEwMCU7XG5cdGhlaWdodDogMTAwJTtcblx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0dGV4dC1hbGlnbjogY2VudGVyO1xuYFxuXG5leHBvcnRzLkNlbnRlcmVkID0gKCBfLCBjb250ZW50ICkgPT5cblx0PHRhYmxlIHN0eWxlID0geyBjZW50ZXJlZCB9ID5cblx0XHQ8dHIgc3R5bGUgPSB7IGNlbnRlcmVkIH0gPlxuXHRcdFx0PHRkIHN0eWxlID0geyBjZW50ZXJlZCB9ID57XG5cdFx0XHRcdGNvbnRlbnRcblx0XHRcdH08L3RkPlxuXHRcdDwvdHI+XG5cdDwvdGFibGU+XG5cbmV4cG9ydHMuaXNFbXB0eU5vZGUgPSBub2RlID0+XG5cdG5vZGUgaW5zdGFuY2VvZiBDb21tZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gfHwgbm9kZSBpbnN0YW5jZW9mIFRleHQgJiYgIW5vZGUubm9kZVZhbHVlLnRyaW0oKVxuXG5leHBvcnRzLmltcG9ydFRlbXBsYXRlID0gdGVtcGxhdGUgPT4gZG9jdW1lbnQuaW1wb3J0Tm9kZSggdGVtcGxhdGUuY29udGVudCwgdHJ1ZSApXG5cbmV4cG9ydHMuaW1wb3J0RWxlbWVudCA9IHRlbXBsYXRlID0+IHtcblx0bGV0IHJldCA9IGV4cG9ydHMuaW1wb3J0VGVtcGxhdGUoIHRlbXBsYXRlIClcblx0aWYgKCAhcmV0IClcblx0XHRyZXR1cm4gbnVsbFxuXHR3aGlsZSAoIHJldC5sYXN0Q2hpbGQgJiYgZXhwb3J0cy5pc0VtcHR5Tm9kZSggcmV0Lmxhc3RDaGlsZCApIClcblx0XHRyZXQucmVtb3ZlQ2hpbGQoIHJldC5sYXN0Q2hpbGQgKVxuXHR3aGlsZSAoIHJldC5maXJzdENoaWxkICYmIGV4cG9ydHMuaXNFbXB0eU5vZGUoIHJldC5maXJzdENoaWxkICkgKVxuXHRcdHJldC5yZW1vdmVDaGlsZCggcmV0LmZpcnN0Q2hpbGQgKVxuXHRpZiAoICFyZXQuZmlyc3RDaGlsZCApXG5cdFx0cmV0dXJuIG51bGxcblx0aWYgKCByZXQuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSApXG5cdFx0cmV0dXJuIHJldC5jaGlsZE5vZGVzLml0ZW0oIDAgKVxuXHRsZXQgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGBzcGFuYCApXG5cdHJvb3QuYXBwZW5kQ2hpbGQoIHJldCApXG5cdHJldHVybiByb290XG59XG5cbmV4cG9ydHMuaW1wb3J0Q29tcG9uZW50ID0gdGVtcGxhdGUgPT4ge1xuXHRsZXQgZGF0YSA9IGV4cG9ydHMuaW1wb3J0RWxlbWVudCggdGVtcGxhdGUgKVxuXHRpZiAoIGRhdGEgKSB7XG5cdFx0bGV0IGluaXQgPSBkYXRhLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGBpbml0YCApWyAwIF1cblx0XHRpZiAoIGluaXQgJiYgaW5pdC50eXBlID09IGBpbml0YCApIHtcblx0XHRcdGxldCBmaW5pdCA9IG5ldyBGdW5jdGlvbiggYGNvbXBvbmVudGAsIFtdLnNsaWNlLmNhbGwoIGluaXQuY2hpbGROb2RlcyApLm1hcCggeCA9PiB4LmRhdGEgfHwgYGAgKS5qb2luKCBgYCApIClcblx0XHRcdGZpbml0KCBkYXRhIClcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0cy50aWNrQ2FjaGUgPSBmdW4gPT4ge1xuXHRsZXQgY2FjaGVkUmVzdWx0XG5cdGxldCBjYWNoZWQgPSBmYWxzZVxuXG5cdGxldCBjbGVhckNhY2hlID0gKCkgPT4ge1xuXHRcdGNhY2hlZFJlc3VsdCA9IG51bGxcblx0XHRjYWNoZWQgPSBmYWxzZVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0XHRjYWNoZWRSZXN1bHQgPSBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0XHRjYWNoZWQgPSB0cnVlXG5cdFx0XHRzZXRJbW1lZGlhdGUoIGNsZWFyQ2FjaGUgKVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGVkUmVzdWx0XG5cdH1cbn1cblxuZXhwb3J0cy5jcmVhdGVFdmVudCA9ICggdHlwZSwgZGV0YWlsLCBvbiApID0+IHtcblx0bGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCB0eXBlLCB7IGRldGFpbCwgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9IClcblx0aWYgKCBvbiApIHtcblx0XHRldmVudC5wYWdlWCA9IG9uLnBhZ2VYXG5cdFx0ZXZlbnQucGFnZVkgPSBvbi5wYWdlWVxuXHRcdGV2ZW50LmNsaWVudFggPSBvbi5jbGllbnRYXG5cdFx0ZXZlbnQuY2xpZW50WSA9IG9uLmNsaWVudFlcblx0XHRldmVudC5zY3JlZW5YID0gb24uc2NyZWVuWFxuXHRcdGV2ZW50LnNjcmVlblkgPSBvbi5zY3JlZW5ZXG5cdH1cblx0cmV0dXJuIGV2ZW50XG59XG5cbmV4cG9ydHMuc2VuZEV2ZW50ID0gKCB0eXBlLCBkZXRhaWwsIG9uICkgPT4gb24udGFyZ2V0LmRpc3BhdGNoRXZlbnQoIGV4cG9ydHMuY3JlYXRlRXZlbnQoIHR5cGUsIGRldGFpbCwgb24gKSApXG4iLCJsZXQgaHR0cENsaWVudCA9IHtcblx0Z2V0KCB1cmwsIGVuY29kaW5nICkge1xuXHRcdHJldHVybiBodHRwQ2xpZW50LnhociggeyBtZXRob2Q6IGBHRVRgLCB1cmwsIGVuY29kaW5nIH0gKVxuXHR9LFxuXG5cdHBvc3QoIHVybCwgZGF0YSwgZW5jb2RpbmcgKSB7XG5cdFx0cmV0dXJuIGh0dHBDbGllbnQueGhyKCB7IG1ldGhvZDogYFBPU1RgLCB1cmwsIGRhdGEsIGVuY29kaW5nIH0gKVxuXHR9LFxuXG5cdHhociggb3B0aW9ucyApIHtcblx0XHRsZXQgeyBtZXRob2QsIHVybCwgZW5jb2RpbmcsIGRhdGEgfSA9IG9wdGlvbnNcblx0XHRsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblx0XHRpZiAoIGVuY29kaW5nID09IGBiaW5hcnlgIClcblx0XHRcdHhoci5yZXNwb25zZVR5cGUgPSBgYXJyYXlidWZmZXJgXG5cdFx0ZWxzZVxuXHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9IGB0ZXh0YFxuXHRcdGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdFx0bGV0IG9uZXJyb3IgPSBlcnJvciA9PiB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGVycm9yID09IGBzdHJpbmdgICkge1xuXHRcdFx0XHRcdGVycm9yID0gbmV3IEVycm9yKCBlcnJvciApXG5cdFx0XHRcdFx0ZXJyb3IubWV0aG9kID0gbWV0aG9kXG5cdFx0XHRcdFx0ZXJyb3IudXJsID0gdXJsXG5cdFx0XHRcdH1cblx0XHRcdFx0Z2xvYmFsLl9BTEVSVCAmJiBnbG9iYWwuX0FMRVJUKCBgdHJ5IGAgKyBlcnJvciArIHVybCApXG5cdFx0XHRcdHJlamVjdCggZXJyb3IgKVxuXHRcdFx0fVxuXHRcdFx0eGhyLm9udGltZW91dCA9ICgpID0+IG9uZXJyb3IoIG5ldyBFcnJvciggYFRJTUVPVVQgJHsgdXJsIH1gICkgKVxuXHRcdFx0eGhyLm9uZXJyb3IgPSBlID0+IG9uZXJyb3IoIGUgfHwgYEVSUk9SYCApXG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuXHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09IHhoci5ET05FICYmIHhoci5zdGF0dXMgPT0gMCApXG5cdFx0XHRcdFx0eGhyLm9udGltZW91dCgpXG5cdFx0XHR9XG5cdFx0XHR4aHIub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0XHQvLyBhbGVydCggeGhyLnN0YXR1cyApXG5cdFx0XHRcdGlmICggeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8PSAyOTkgKVxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlKCB4aHIucmVzcG9uc2UgPT0gbnVsbCA/IG51bGwgOiB4aHIucmVzcG9uc2UgKVxuXHRcdFx0XHRpZiAoIHhoci5zdGF0dXMgPT0gNDAxICkge1xuXHRcdFx0XHRcdC8vIGFwcGVuZCBzb21lIHRoaW5nIHRvIHRoZSBwYWdlIHRvIGZvcmNlIHN0YW5kYWxvbmUgYnJvd3NlciB0byBzaG93IGxvZ2luIGRpYWxvZ1xuXHRcdFx0XHRcdGxldCBzdXJsID0gcmVxdWlyZSggYHVybGAgKS5wYXJzZSggdXJsIClcblx0XHRcdFx0XHRpZiAoIHN1cmwuaG9zdCApIHtcblx0XHRcdFx0XHRcdHN1cmwgPSBgJHsgc3VybC5wcm90b2NvbCB9Ly8keyBzdXJsLmhvc3QgfS9kdW1teS4keyBNYXRoLnJhbmRvbSgpIH0uanNgXG5cdFx0XHRcdFx0XHRsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYHNjcmlwdGAgKVxuXHRcdFx0XHRcdFx0c2NyaXB0LnNyYyA9IHN1cmxcblx0XHRcdFx0XHRcdC8vIGFsZXJ0KCBzdXJsIClcblx0XHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIHNjcmlwdCApXG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KCAoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKCBzY3JpcHQgKSwgMTAwMCApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG9uZXJyb3IoIGAkeyB4aHIuc3RhdHVzIH0gJHsgeGhyLnN0YXR1c1RleHQgfWAgKVxuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdHN3aXRjaCAoIGVuY29kaW5nICkge1xuXHRcdGNhc2UgYGltbXV0YWJsZWA6XG5cdFx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKCBkYXRhID0+IEltbXV0YWJsZS5mcm9tSlMoIEpTT04ucGFyc2UoIGRhdGEgKSApIClcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSBgYmluYXJ5YDpcblx0XHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oIGRhdGEgPT4gbmV3IFVpbnQ4QXJyYXkoIGRhdGEgKSApXG5cdFx0XHRicmVha1xuXHRcdGNhc2UgYHRleHRgOlxuXHRcdFx0YnJlYWtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHJvbWlzZSA9IHByb21pc2UudGhlbiggZGF0YSA9PiB7XG5cdFx0XHRcdGxldCBhY3R1YWxFbmNvZGluZyA9IGVuY29kaW5nXG5cdFx0XHRcdGlmICggIWFjdHVhbEVuY29kaW5nICkge1xuXHRcdFx0XHRcdGxldCBjdCA9IHhoci5nZXRSZXNwb25zZUhlYWRlciggYGNvbnRlbnQtdHlwZWAgKSB8fCBgYFxuXHRcdFx0XHRcdGlmICggY3QubWF0Y2goIC9eYXBwbGljYXRpb25cXC9qc29uLyApIClcblx0XHRcdFx0XHRcdGFjdHVhbEVuY29kaW5nID0gYGpzb25gXG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoICggYWN0dWFsRW5jb2RpbmcgKSB7XG5cdFx0XHRcdGNhc2UgYGpzb25gOlxuXHRcdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhIClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGF0YVxuXHRcdFx0fSApXG5cdFx0fVxuXHRcdHhoci5vcGVuKCBtZXRob2QgfHwgYEdFVGAsIHVybCApXG5cdFx0eGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcblx0XHR4aHIuc2VuZCggZGF0YSApXG5cdFx0eGhyLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZCggcHJvbWlzZSApXG5cdFx0eGhyLmNhdGNoID0gcHJvbWlzZS5jYXRjaC5iaW5kKCBwcm9taXNlIClcblx0XHRyZXR1cm4geGhyXG5cdH0sXG5cblx0dXJsKCB1cmwsIHBhcmFtcyApIHtcblx0XHRwYXJhbXMgJiYgT2JqZWN0LmtleXMoIHBhcmFtcyApLmZvckVhY2goICggaywgaSApID0+IHVybCA9IHVybFxuXHRcdFx0KyAoIGkgPiAwID8gYCZgIDogYD9gIClcblx0XHRcdCsgZW5jb2RlVVJJQ29tcG9uZW50KCBrIClcblx0XHRcdCsgYD1gXG5cdFx0XHQrIGVuY29kZVVSSUNvbXBvbmVudCggcGFyYW1zWyBrIF0gKVxuXHRcdClcblx0XHRyZXR1cm4gdXJsXG5cdH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHR0cENsaWVudFxuIiwiLypcblxudmFkemltIHppZW5rYVxuXG4yMDE1LjA1LjExXG5hZGRlZCB0aGlzLnN0b3BwZWRUcmFuc2l0aW9uIHRvIG5vdCB0byBmaXJlIHRhcCB3aGVuIHNjcm9sbGluZyBpcyBzdG9wcGVkIGJ5IHRoYXQgdGFwLlxuXG4gKi9cblxuLyohIGlTY3JvbGwgdjUuMS4zIH4gKGMpIDIwMDgtMjAxNCBNYXR0ZW8gU3BpbmVsbGkgfiBodHRwOi8vY3ViaXEub3JnL2xpY2Vuc2UgKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgTWF0aCkge1xudmFyIHJBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdGZ1bmN0aW9uIChjYWxsYmFjaykgeyB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTsgfTtcblxudmFyIHV0aWxzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG1lID0ge307XG5cblx0dmFyIF9lbGVtZW50U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblx0dmFyIF92ZW5kb3IgPSAoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ZW5kb3JzID0gWyd0JywgJ3dlYmtpdFQnLCAnTW96VCcsICdtc1QnLCAnT1QnXSxcblx0XHRcdHRyYW5zZm9ybSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHZlbmRvcnMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dHJhbnNmb3JtID0gdmVuZG9yc1tpXSArICdyYW5zZm9ybSc7XG5cdFx0XHRpZiAoIHRyYW5zZm9ybSBpbiBfZWxlbWVudFN0eWxlICkgcmV0dXJuIHZlbmRvcnNbaV0uc3Vic3RyKDAsIHZlbmRvcnNbaV0ubGVuZ3RoLTEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBfcHJlZml4U3R5bGUgKHN0eWxlKSB7XG5cdFx0aWYgKCBfdmVuZG9yID09PSBmYWxzZSApIHJldHVybiBmYWxzZTtcblx0XHRpZiAoIF92ZW5kb3IgPT09ICcnICkgcmV0dXJuIHN0eWxlO1xuXHRcdHJldHVybiBfdmVuZG9yICsgc3R5bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHlsZS5zdWJzdHIoMSk7XG5cdH1cblxuXHRtZS5nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gZ2V0VGltZSAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuXHRtZS5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYmopIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBvYmogKSB7XG5cdFx0XHR0YXJnZXRbaV0gPSBvYmpbaV07XG5cdFx0fVxuXHR9O1xuXG5cdG1lLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuXHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sICEhY2FwdHVyZSk7XG5cdH07XG5cblx0bWUucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKSB7XG5cdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgISFjYXB0dXJlKTtcblx0fTtcblxuXHRtZS5wcmVmaXhQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAocG9pbnRlckV2ZW50KSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5NU1BvaW50ZXJFdmVudCA/IFxuXHRcdFx0J01TUG9pbnRlcicgKyBwb2ludGVyRXZlbnQuY2hhckF0KDkpLnRvVXBwZXJDYXNlKCkgKyBwb2ludGVyRXZlbnQuc3Vic3RyKDEwKTpcblx0XHRcdHBvaW50ZXJFdmVudDtcblx0fTtcblxuXHRtZS5tb21lbnR1bSA9IGZ1bmN0aW9uIChjdXJyZW50LCBzdGFydCwgdGltZSwgbG93ZXJNYXJnaW4sIHdyYXBwZXJTaXplLCBkZWNlbGVyYXRpb24pIHtcblx0XHR2YXIgZGlzdGFuY2UgPSBjdXJyZW50IC0gc3RhcnQsXG5cdFx0XHRzcGVlZCA9IE1hdGguYWJzKGRpc3RhbmNlKSAvIHRpbWUsXG5cdFx0XHRkZXN0aW5hdGlvbixcblx0XHRcdGR1cmF0aW9uO1xuXG5cdFx0ZGVjZWxlcmF0aW9uID0gZGVjZWxlcmF0aW9uID09PSB1bmRlZmluZWQgPyAwLjAwMDYgOiBkZWNlbGVyYXRpb247XG5cblx0XHRkZXN0aW5hdGlvbiA9IGN1cnJlbnQgKyAoIHNwZWVkICogc3BlZWQgKSAvICggMiAqIGRlY2VsZXJhdGlvbiApICogKCBkaXN0YW5jZSA8IDAgPyAtMSA6IDEgKTtcblx0XHRkdXJhdGlvbiA9IHNwZWVkIC8gZGVjZWxlcmF0aW9uO1xuXG5cdFx0aWYgKCBkZXN0aW5hdGlvbiA8IGxvd2VyTWFyZ2luICkge1xuXHRcdFx0ZGVzdGluYXRpb24gPSB3cmFwcGVyU2l6ZSA/IGxvd2VyTWFyZ2luIC0gKCB3cmFwcGVyU2l6ZSAvIDIuNSAqICggc3BlZWQgLyA4ICkgKSA6IGxvd2VyTWFyZ2luO1xuXHRcdFx0ZGlzdGFuY2UgPSBNYXRoLmFicyhkZXN0aW5hdGlvbiAtIGN1cnJlbnQpO1xuXHRcdFx0ZHVyYXRpb24gPSBkaXN0YW5jZSAvIHNwZWVkO1xuXHRcdH0gZWxzZSBpZiAoIGRlc3RpbmF0aW9uID4gMCApIHtcblx0XHRcdGRlc3RpbmF0aW9uID0gd3JhcHBlclNpemUgPyB3cmFwcGVyU2l6ZSAvIDIuNSAqICggc3BlZWQgLyA4ICkgOiAwO1xuXHRcdFx0ZGlzdGFuY2UgPSBNYXRoLmFicyhjdXJyZW50KSArIGRlc3RpbmF0aW9uO1xuXHRcdFx0ZHVyYXRpb24gPSBkaXN0YW5jZSAvIHNwZWVkO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRkZXN0aW5hdGlvbjogTWF0aC5yb3VuZChkZXN0aW5hdGlvbiksXG5cdFx0XHRkdXJhdGlvbjogZHVyYXRpb25cblx0XHR9O1xuXHR9O1xuXG5cdHZhciBfdHJhbnNmb3JtID0gX3ByZWZpeFN0eWxlKCd0cmFuc2Zvcm0nKTtcblxuXHRtZS5leHRlbmQobWUsIHtcblx0XHRoYXNUcmFuc2Zvcm06IF90cmFuc2Zvcm0gIT09IGZhbHNlLFxuXHRcdGhhc1BlcnNwZWN0aXZlOiBfcHJlZml4U3R5bGUoJ3BlcnNwZWN0aXZlJykgaW4gX2VsZW1lbnRTdHlsZSxcblx0XHRoYXNUb3VjaDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93LFxuXHRcdGhhc1BvaW50ZXI6IHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgd2luZG93Lk1TUG9pbnRlckV2ZW50LCAvLyBJRTEwIGlzIHByZWZpeGVkXG5cdFx0aGFzVHJhbnNpdGlvbjogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uJykgaW4gX2VsZW1lbnRTdHlsZVxuXHR9KTtcblxuXHQvLyBUaGlzIHNob3VsZCBmaW5kIGFsbCBBbmRyb2lkIGJyb3dzZXJzIGxvd2VyIHRoYW4gYnVpbGQgNTM1LjE5IChib3RoIHN0b2NrIGJyb3dzZXIgYW5kIHdlYnZpZXcpXG5cdG1lLmlzQmFkQW5kcm9pZCA9IC9BbmRyb2lkIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24pICYmICEoL0Nocm9tZVxcL1xcZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24pKTtcblxuXHRtZS5leHRlbmQobWUuc3R5bGUgPSB7fSwge1xuXHRcdHRyYW5zZm9ybTogX3RyYW5zZm9ybSxcblx0XHR0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJyksXG5cdFx0dHJhbnNpdGlvbkR1cmF0aW9uOiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25EdXJhdGlvbicpLFxuXHRcdHRyYW5zaXRpb25EZWxheTogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uRGVsYXknKSxcblx0XHR0cmFuc2Zvcm1PcmlnaW46IF9wcmVmaXhTdHlsZSgndHJhbnNmb3JtT3JpZ2luJylcblx0fSk7XG5cblx0bWUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGMgKyBcIihcXFxcc3wkKVwiKTtcblx0XHRyZXR1cm4gcmUudGVzdChlLmNsYXNzTmFtZSk7XG5cdH07XG5cblx0bWUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdGlmICggbWUuaGFzQ2xhc3MoZSwgYykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG5ld2NsYXNzID0gZS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcblx0XHRuZXdjbGFzcy5wdXNoKGMpO1xuXHRcdGUuY2xhc3NOYW1lID0gbmV3Y2xhc3Muam9pbignICcpO1xuXHR9O1xuXG5cdG1lLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGUsIGMpIHtcblx0XHRpZiAoICFtZS5oYXNDbGFzcyhlLCBjKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjICsgXCIoXFxcXHN8JClcIiwgJ2cnKTtcblx0XHRlLmNsYXNzTmFtZSA9IGUuY2xhc3NOYW1lLnJlcGxhY2UocmUsICcgJyk7XG5cdH07XG5cblx0bWUub2Zmc2V0ID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0dmFyIGxlZnQgPSAtZWwub2Zmc2V0TGVmdCxcblx0XHRcdHRvcCA9IC1lbC5vZmZzZXRUb3A7XG5cblx0XHQvLyBqc2hpbnQgLVcwODRcblx0XHR3aGlsZSAoZWwgPSBlbC5vZmZzZXRQYXJlbnQpIHtcblx0XHRcdGxlZnQgLT0gZWwub2Zmc2V0TGVmdDtcblx0XHRcdHRvcCAtPSBlbC5vZmZzZXRUb3A7XG5cdFx0fVxuXHRcdC8vIGpzaGludCArVzA4NFxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IGxlZnQsXG5cdFx0XHR0b3A6IHRvcFxuXHRcdH07XG5cdH07XG5cblx0bWUucHJldmVudERlZmF1bHRFeGNlcHRpb24gPSBmdW5jdGlvbiAoZWwsIGV4Y2VwdGlvbnMpIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBleGNlcHRpb25zICkge1xuXHRcdFx0aWYgKCBleGNlcHRpb25zW2ldLnRlc3QoZWxbaV0pICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0bWUuZXh0ZW5kKG1lLmV2ZW50VHlwZSA9IHt9LCB7XG5cdFx0dG91Y2hzdGFydDogMSxcblx0XHR0b3VjaG1vdmU6IDEsXG5cdFx0dG91Y2hlbmQ6IDEsXG5cblx0XHRtb3VzZWRvd246IDIsXG5cdFx0bW91c2Vtb3ZlOiAyLFxuXHRcdG1vdXNldXA6IDIsXG5cblx0XHRwb2ludGVyZG93bjogMyxcblx0XHRwb2ludGVybW92ZTogMyxcblx0XHRwb2ludGVydXA6IDMsXG5cblx0XHRNU1BvaW50ZXJEb3duOiAzLFxuXHRcdE1TUG9pbnRlck1vdmU6IDMsXG5cdFx0TVNQb2ludGVyVXA6IDNcblx0fSk7XG5cblx0bWUuZXh0ZW5kKG1lLmVhc2UgPSB7fSwge1xuXHRcdHF1YWRyYXRpYzoge1xuXHRcdFx0c3R5bGU6ICdjdWJpYy1iZXppZXIoMC4yNSwgMC40NiwgMC40NSwgMC45NCknLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHJldHVybiBrICogKCAyIC0gayApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2lyY3VsYXI6IHtcblx0XHRcdHN0eWxlOiAnY3ViaWMtYmV6aWVyKDAuMSwgMC41NywgMC4xLCAxKScsXHQvLyBOb3QgcHJvcGVybHkgXCJjaXJjdWxhclwiIGJ1dCB0aGlzIGxvb2tzIGJldHRlciwgaXQgc2hvdWxkIGJlICgwLjA3NSwgMC44MiwgMC4xNjUsIDEpXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCggMSAtICggLS1rICogayApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRiYWNrOiB7XG5cdFx0XHRzdHlsZTogJ2N1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIsIDEuMjc1KScsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0dmFyIGIgPSA0O1xuXHRcdFx0XHRyZXR1cm4gKCBrID0gayAtIDEgKSAqIGsgKiAoICggYiArIDEgKSAqIGsgKyBiICkgKyAxO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ym91bmNlOiB7XG5cdFx0XHRzdHlsZTogJycsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0aWYgKCAoIGsgLz0gMSApIDwgKCAxIC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiBrICogaztcblx0XHRcdFx0fSBlbHNlIGlmICggayA8ICggMiAvIDIuNzUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMS41IC8gMi43NSApICkgKiBrICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmICggayA8ICggMi41IC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjI1IC8gMi43NSApICkgKiBrICsgMC45Mzc1O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjYyNSAvIDIuNzUgKSApICogayArIDAuOTg0Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbGFzdGljOiB7XG5cdFx0XHRzdHlsZTogJycsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0dmFyIGYgPSAwLjIyLFxuXHRcdFx0XHRcdGUgPSAwLjQ7XG5cblx0XHRcdFx0aWYgKCBrID09PSAwICkgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHRpZiAoIGsgPT0gMSApIHsgcmV0dXJuIDE7IH1cblxuXHRcdFx0XHRyZXR1cm4gKCBlICogTWF0aC5wb3coIDIsIC0gMTAgKiBrICkgKiBNYXRoLnNpbiggKCBrIC0gZiAvIDQgKSAqICggMiAqIE1hdGguUEkgKSAvIGYgKSArIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdG1lLnRhcCA9IGZ1bmN0aW9uIChlLCBldmVudE5hbWUpIHtcblx0XHR2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblx0XHRldi5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKTtcblx0XHRldi5wYWdlWCA9IGUucGFnZVg7XG5cdFx0ZXYucGFnZVkgPSBlLnBhZ2VZO1xuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuXHR9O1xuXG5cdG1lLmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQsXG5cdFx0XHRldjtcblxuXHRcdGlmICggISgvKFNFTEVDVHxJTlBVVHxURVhUQVJFQSkvaSkudGVzdCh0YXJnZXQudGFnTmFtZSkgKSB7XG5cdFx0XHRldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdFx0ZXYuaW5pdE1vdXNlRXZlbnQoJ2NsaWNrJywgdHJ1ZSwgdHJ1ZSwgZS52aWV3LCAxLFxuXHRcdFx0XHR0YXJnZXQuc2NyZWVuWCwgdGFyZ2V0LnNjcmVlblksIHRhcmdldC5jbGllbnRYLCB0YXJnZXQuY2xpZW50WSxcblx0XHRcdFx0ZS5jdHJsS2V5LCBlLmFsdEtleSwgZS5zaGlmdEtleSwgZS5tZXRhS2V5LFxuXHRcdFx0XHQwLCBudWxsKTtcblxuXHRcdFx0ZXYuX2NvbnN0cnVjdGVkID0gdHJ1ZTtcblx0XHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG1lO1xufSkoKTtcblxuZnVuY3Rpb24gSVNjcm9sbCAoZWwsIG9wdGlvbnMpIHtcblx0dGhpcy53cmFwcGVyID0gdHlwZW9mIGVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcblx0dGhpcy5zY3JvbGxlciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5zY3JvbGxlclN0eWxlID0gdGhpcy5zY3JvbGxlci5zdHlsZTtcdFx0Ly8gY2FjaGUgc3R5bGUgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXG5cdHRoaXMub3B0aW9ucyA9IHtcblxuXHRcdHJlc2l6ZVNjcm9sbGJhcnM6IHRydWUsXG5cblx0XHRtb3VzZVdoZWVsU3BlZWQ6IDIwLFxuXG5cdFx0c25hcFRocmVzaG9sZDogMC4zMzQsXG5cbi8vIElOU0VSVCBQT0lOVDogT1BUSU9OUyBcblxuXHRcdHN0YXJ0WDogMCxcblx0XHRzdGFydFk6IDAsXG5cdFx0c2Nyb2xsWTogdHJ1ZSxcblx0XHRkaXJlY3Rpb25Mb2NrVGhyZXNob2xkOiA1LFxuXHRcdG1vbWVudHVtOiB0cnVlLFxuXG5cdFx0Ym91bmNlOiB0cnVlLFxuXHRcdGJvdW5jZVRpbWU6IDYwMCxcblx0XHRib3VuY2VFYXNpbmc6ICcnLFxuXG5cdFx0cHJldmVudERlZmF1bHQ6IHRydWUsXG5cdFx0cHJldmVudERlZmF1bHRFeGNlcHRpb246IHsgdGFnTmFtZTogL14oSU5QVVR8VEVYVEFSRUF8QlVUVE9OfFNFTEVDVCkkLyB9LFxuXG5cdFx0SFdDb21wb3NpdGluZzogdHJ1ZSxcblx0XHR1c2VUcmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVzZVRyYW5zZm9ybTogdHJ1ZVxuXHR9O1xuXG5cdGZvciAoIHZhciBpIGluIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHRpb25zXG5cdHRoaXMudHJhbnNsYXRlWiA9IHRoaXMub3B0aW9ucy5IV0NvbXBvc2l0aW5nICYmIHV0aWxzLmhhc1BlcnNwZWN0aXZlID8gJyB0cmFuc2xhdGVaKDApJyA6ICcnO1xuXG5cdHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uID0gdXRpbHMuaGFzVHJhbnNpdGlvbiAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbjtcblx0dGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSA9IHV0aWxzLmhhc1RyYW5zZm9ybSAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtO1xuXG5cdHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT09IHRydWUgPyAndmVydGljYWwnIDogdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9ICF0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCAmJiB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ7XG5cblx0Ly8gSWYgeW91IHdhbnQgZXZlbnRQYXNzdGhyb3VnaCBJIGhhdmUgdG8gbG9jayBvbmUgb2YgdGhlIGF4ZXNcblx0dGhpcy5vcHRpb25zLnNjcm9sbFkgPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2Nyb2xsWTtcblx0dGhpcy5vcHRpb25zLnNjcm9sbFggPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgPyBmYWxzZSA6IHRoaXMub3B0aW9ucy5zY3JvbGxYO1xuXG5cdC8vIFdpdGggZXZlbnRQYXNzdGhyb3VnaCB3ZSBhbHNvIG5lZWQgbG9ja0RpcmVjdGlvbiBtZWNoYW5pc21cblx0dGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgPSB0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCAmJiAhdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPyAwIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQ7XG5cblx0dGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nID09ICdzdHJpbmcnID8gdXRpbHMuZWFzZVt0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nXSB8fCB1dGlscy5lYXNlLmNpcmN1bGFyIDogdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblxuXHR0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyA9IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nID09PSB1bmRlZmluZWQgPyA2MCA6IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nO1xuXG5cdGlmICggdGhpcy5vcHRpb25zLnRhcCA9PT0gdHJ1ZSApIHtcblx0XHR0aGlzLm9wdGlvbnMudGFwID0gJ3RhcCc7XG5cdH1cblxuXHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzID09ICdzY2FsZScgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gPSBmYWxzZTtcblx0fVxuXG5cdHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA/IC0xIDogMTtcblxuXHRpZiAoIHRoaXMub3B0aW9ucy5wcm9iZVR5cGUgPT0gMyApIHtcblx0XHR0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiA9IGZhbHNlO1x0fVxuXG4vLyBJTlNFUlQgUE9JTlQ6IE5PUk1BTElaQVRJT05cblxuXHQvLyBTb21lIGRlZmF1bHRzXHRcblx0dGhpcy54ID0gMDtcblx0dGhpcy55ID0gMDtcblx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0dGhpcy5fZXZlbnRzID0ge307XG5cbi8vIElOU0VSVCBQT0lOVDogREVGQVVMVFNcblxuXHR0aGlzLl9pbml0KCk7XG5cdHRoaXMucmVmcmVzaCgpO1xuXG5cdHRoaXMuc2Nyb2xsVG8odGhpcy5vcHRpb25zLnN0YXJ0WCwgdGhpcy5vcHRpb25zLnN0YXJ0WSk7XG5cdHRoaXMuZW5hYmxlKCk7XG59XG5cbklTY3JvbGwucHJvdG90eXBlID0ge1xuXHR2ZXJzaW9uOiAnNS4xLjMnLFxuXG5cdF9pbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyB8fCB0aGlzLm9wdGlvbnMuaW5kaWNhdG9ycyApIHtcblx0XHRcdHRoaXMuX2luaXRJbmRpY2F0b3JzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubW91c2VXaGVlbCApIHtcblx0XHRcdHRoaXMuX2luaXRXaGVlbCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgKSB7XG5cdFx0XHR0aGlzLl9pbml0U25hcCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzICkge1xuXHRcdFx0dGhpcy5faW5pdEtleXMoKTtcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX2luaXRcblxuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdkZXN0cm95Jyk7XG5cdH0sXG5cblx0X3RyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCBlLnRhcmdldCAhPSB0aGlzLnNjcm9sbGVyIHx8ICF0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKCk7XG5cdFx0aWYgKCAhdGhpcy5yZXNldFBvc2l0aW9uKHRoaXMub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBSZWFjdCB0byBsZWZ0IG1vdXNlIGJ1dHRvbiBvbmx5XG5cdFx0aWYgKCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPSAxICkge1xuXHRcdFx0aWYgKCBlLmJ1dHRvbiAhPT0gMCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCAodGhpcy5pbml0aWF0ZWQgJiYgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAmJiAhdXRpbHMuaXNCYWRBbmRyb2lkICYmICF1dGlscy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbihlLnRhcmdldCwgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0cG9zO1xuXG5cdFx0dGhpcy5pbml0aWF0ZWRcdD0gdXRpbHMuZXZlbnRUeXBlW2UudHlwZV07XG5cdFx0dGhpcy5tb3ZlZFx0XHQ9IGZhbHNlO1xuXHRcdHRoaXMuZGlzdFhcdFx0PSAwO1xuXHRcdHRoaXMuZGlzdFlcdFx0PSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9IDA7XG5cblx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSgpO1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHR0aGlzLnN0b3BwZWRUcmFuc2l0aW9uID0gZmFsc2Vcblx0XHRpZiAoIHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRoaXMuaXNJblRyYW5zaXRpb24gKSB7XG5cdFx0XHR0aGlzLnN0b3BwZWRUcmFuc2l0aW9uID0gdHJ1ZVxuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IGZhbHNlO1xuXHRcdFx0cG9zID0gdGhpcy5nZXRDb21wdXRlZFBvc2l0aW9uKCk7XG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoTWF0aC5yb3VuZChwb3MueCksIE1hdGgucm91bmQocG9zLnkpKTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fSBlbHNlIGlmICggIXRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRoaXMuaXNBbmltYXRpbmcgKSB7XG5cdFx0XHR0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RhcnRYICAgID0gdGhpcy54O1xuXHRcdHRoaXMuc3RhcnRZICAgID0gdGhpcy55O1xuXHRcdHRoaXMuYWJzU3RhcnRYID0gdGhpcy54O1xuXHRcdHRoaXMuYWJzU3RhcnRZID0gdGhpcy55O1xuXHRcdHRoaXMucG9pbnRYICAgID0gcG9pbnQucGFnZVg7XG5cdFx0dGhpcy5wb2ludFkgICAgPSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuX2V4ZWNFdmVudCgnYmVmb3JlU2Nyb2xsU3RhcnQnKTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ICkge1x0Ly8gaW5jcmVhc2VzIHBlcmZvcm1hbmNlIG9uIEFuZHJvaWQ/IFRPRE86IGNoZWNrIVxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHZhciBwb2ludFx0XHQ9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG5cdFx0XHRkZWx0YVhcdFx0PSBwb2ludC5wYWdlWCAtIHRoaXMucG9pbnRYLFxuXHRcdFx0ZGVsdGFZXHRcdD0gcG9pbnQucGFnZVkgLSB0aGlzLnBvaW50WSxcblx0XHRcdHRpbWVzdGFtcFx0PSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0YWJzRGlzdFgsIGFic0Rpc3RZO1xuXG5cdFx0dGhpcy5wb2ludFhcdFx0PSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLnBvaW50WVx0XHQ9IHBvaW50LnBhZ2VZO1xuXG5cdFx0dGhpcy5kaXN0WFx0XHQrPSBkZWx0YVg7XG5cdFx0dGhpcy5kaXN0WVx0XHQrPSBkZWx0YVk7XG5cdFx0YWJzRGlzdFhcdFx0PSBNYXRoLmFicyh0aGlzLmRpc3RYKTtcblx0XHRhYnNEaXN0WVx0XHQ9IE1hdGguYWJzKHRoaXMuZGlzdFkpO1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBtb3ZlIGF0IGxlYXN0IDEwIHBpeGVscyBmb3IgdGhlIHNjcm9sbGluZyB0byBpbml0aWF0ZVxuXHRcdGlmICggdGltZXN0YW1wIC0gdGhpcy5lbmRUaW1lID4gMzAwICYmIChhYnNEaXN0WCA8IDEwICYmIGFic0Rpc3RZIDwgMTApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHlvdSBhcmUgc2Nyb2xsaW5nIGluIG9uZSBkaXJlY3Rpb24gbG9jayB0aGUgb3RoZXJcblx0XHRpZiAoICF0aGlzLmRpcmVjdGlvbkxvY2tlZCAmJiAhdGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgKSB7XG5cdFx0XHRpZiAoIGFic0Rpc3RYID4gYWJzRGlzdFkgKyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZCApIHtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAnaCc7XHRcdC8vIGxvY2sgaG9yaXpvbnRhbGx5XG5cdFx0XHR9IGVsc2UgaWYgKCBhYnNEaXN0WSA+PSBhYnNEaXN0WCArIHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkICkge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICd2JztcdFx0Ly8gbG9jayB2ZXJ0aWNhbGx5XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICduJztcdFx0Ly8gbm8gbG9ja1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kaXJlY3Rpb25Mb2NrZWQgPT0gJ2gnICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgKSB7XG5cdFx0XHRcdHRoaXMuaW5pdGlhdGVkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGFZID0gMDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmRpcmVjdGlvbkxvY2tlZCA9PSAndicgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICdob3Jpem9udGFsJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ3ZlcnRpY2FsJyApIHtcblx0XHRcdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YVggPSAwO1xuXHRcdH1cblxuXHRcdGRlbHRhWCA9IHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IGRlbHRhWCA6IDA7XG5cdFx0ZGVsdGFZID0gdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCA/IGRlbHRhWSA6IDA7XG5cblx0XHRuZXdYID0gdGhpcy54ICsgZGVsdGFYO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBkZWx0YVk7XG5cblx0XHQvLyBTbG93IGRvd24gaWYgb3V0c2lkZSBvZiB0aGUgYm91bmRhcmllc1xuXHRcdGlmICggbmV3WCA+IDAgfHwgbmV3WCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdG5ld1ggPSB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy54ICsgZGVsdGFYIC8gMyA6IG5ld1ggPiAwID8gMCA6IHRoaXMubWF4U2Nyb2xsWDtcblx0XHR9XG5cdFx0aWYgKCBuZXdZID4gMCB8fCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLnkgKyBkZWx0YVkgLyAzIDogbmV3WSA+IDAgPyAwIDogdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IGRlbHRhWCA+IDAgPyAtMSA6IGRlbHRhWCA8IDAgPyAxIDogMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSBkZWx0YVkgPiAwID8gLTEgOiBkZWx0YVkgPCAwID8gMSA6IDA7XG5cblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxTdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubW92ZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy5fdHJhbnNsYXRlKG5ld1gsIG5ld1kpO1xuXG4vKiBSRVBMQUNFIFNUQVJUOiBfbW92ZSAqL1xuXHRcdGlmICggdGltZXN0YW1wIC0gdGhpcy5zdGFydFRpbWUgPiAzMDAgKSB7XG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcblx0XHRcdHRoaXMuc3RhcnRYID0gdGhpcy54O1xuXHRcdFx0dGhpcy5zdGFydFkgPSB0aGlzLnk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnByb2JlVHlwZSA9PSAxICkge1xuXHRcdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnByb2JlVHlwZSA+IDEgKSB7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdH1cbi8qIFJFUExBQ0UgRU5EOiBfbW92ZSAqL1xuXG5cdH0sXG5cblx0X2VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ICYmICF1dGlscy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbihlLnRhcmdldCwgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnQgPSBlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGUsXG5cdFx0XHRtb21lbnR1bVgsXG5cdFx0XHRtb21lbnR1bVksXG5cdFx0XHRkdXJhdGlvbiA9IHV0aWxzLmdldFRpbWUoKSAtIHRoaXMuc3RhcnRUaW1lLFxuXHRcdFx0bmV3WCA9IE1hdGgucm91bmQodGhpcy54KSxcblx0XHRcdG5ld1kgPSBNYXRoLnJvdW5kKHRoaXMueSksXG5cdFx0XHRkaXN0YW5jZVggPSBNYXRoLmFicyhuZXdYIC0gdGhpcy5zdGFydFgpLFxuXHRcdFx0ZGlzdGFuY2VZID0gTWF0aC5hYnMobmV3WSAtIHRoaXMuc3RhcnRZKSxcblx0XHRcdHRpbWUgPSAwLFxuXHRcdFx0ZWFzaW5nID0gJyc7XG5cblx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gMDtcblx0XHR0aGlzLmluaXRpYXRlZCA9IDA7XG5cdFx0dGhpcy5lbmRUaW1lID0gdXRpbHMuZ2V0VGltZSgpO1xuXG5cdFx0Ly8gcmVzZXQgaWYgd2UgYXJlIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJpZXNcblx0XHRpZiAoIHRoaXMucmVzZXRQb3NpdGlvbih0aGlzLm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxUbyhuZXdYLCBuZXdZKTtcdC8vIGVuc3VyZXMgdGhhdCB0aGUgbGFzdCBwb3NpdGlvbiBpcyByb3VuZGVkXG5cblx0XHQvLyB3ZSBzY3JvbGxlZCBsZXNzIHRoYW4gMTAgcGl4ZWxzXG5cdFx0aWYgKCAhdGhpcy5tb3ZlZCApIHtcblx0XHRcdGlmICggIXRoaXMuc3RvcHBlZFRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnRhcCApIHtcblx0XHRcdFx0XHR1dGlscy50YXAoZSwgdGhpcy5vcHRpb25zLnRhcCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5jbGljayApIHtcblx0XHRcdFx0XHR1dGlscy5jbGljayhlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbENhbmNlbCcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fZXZlbnRzLmZsaWNrICYmIGR1cmF0aW9uIDwgMjAwICYmIGRpc3RhbmNlWCA8IDEwMCAmJiBkaXN0YW5jZVkgPCAxMDAgKSB7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ2ZsaWNrJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gc3RhcnQgbW9tZW50dW0gYW5pbWF0aW9uIGlmIG5lZWRlZFxuXHRcdGlmICggdGhpcy5vcHRpb25zLm1vbWVudHVtICYmIGR1cmF0aW9uIDwgMzAwICkge1xuXHRcdFx0bW9tZW50dW1YID0gdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsID8gdXRpbHMubW9tZW50dW0odGhpcy54LCB0aGlzLnN0YXJ0WCwgZHVyYXRpb24sIHRoaXMubWF4U2Nyb2xsWCwgdGhpcy5vcHRpb25zLmJvdW5jZSA/IHRoaXMud3JhcHBlcldpZHRoIDogMCwgdGhpcy5vcHRpb25zLmRlY2VsZXJhdGlvbikgOiB7IGRlc3RpbmF0aW9uOiBuZXdYLCBkdXJhdGlvbjogMCB9O1xuXHRcdFx0bW9tZW50dW1ZID0gdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCA/IHV0aWxzLm1vbWVudHVtKHRoaXMueSwgdGhpcy5zdGFydFksIGR1cmF0aW9uLCB0aGlzLm1heFNjcm9sbFksIHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLndyYXBwZXJIZWlnaHQgOiAwLCB0aGlzLm9wdGlvbnMuZGVjZWxlcmF0aW9uKSA6IHsgZGVzdGluYXRpb246IG5ld1ksIGR1cmF0aW9uOiAwIH07XG5cdFx0XHRuZXdYID0gbW9tZW50dW1YLmRlc3RpbmF0aW9uO1xuXHRcdFx0bmV3WSA9IG1vbWVudHVtWS5kZXN0aW5hdGlvbjtcblx0XHRcdHRpbWUgPSBNYXRoLm1heChtb21lbnR1bVguZHVyYXRpb24sIG1vbWVudHVtWS5kdXJhdGlvbik7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gMTtcblx0XHR9XG5cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgKSB7XG5cdFx0XHR2YXIgc25hcCA9IHRoaXMuX25lYXJlc3RTbmFwKG5ld1gsIG5ld1kpO1xuXHRcdFx0dGhpcy5jdXJyZW50UGFnZSA9IHNuYXA7XG5cdFx0XHR0aW1lID0gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdFx0XHRNYXRoLm1heChcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKG5ld1ggLSBzbmFwLngpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKG5ld1kgLSBzbmFwLnkpLCAxMDAwKVxuXHRcdFx0XHRcdCksIDMwMCk7XG5cdFx0XHRuZXdYID0gc25hcC54O1xuXHRcdFx0bmV3WSA9IHNuYXAueTtcblxuXHRcdFx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0XHRcdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cdFx0XHRlYXNpbmcgPSB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nO1xuXHRcdH1cblxuLy8gSU5TRVJUIFBPSU5UOiBfZW5kXG5cblx0XHRpZiAoIG5ld1ggIT0gdGhpcy54IHx8IG5ld1kgIT0gdGhpcy55ICkge1xuXHRcdFx0Ly8gY2hhbmdlIGVhc2luZyBmdW5jdGlvbiB3aGVuIHNjcm9sbGVyIGdvZXMgb3V0IG9mIHRoZSBib3VuZGFyaWVzXG5cdFx0XHRpZiAoIG5ld1ggPiAwIHx8IG5ld1ggPCB0aGlzLm1heFNjcm9sbFggfHwgbmV3WSA+IDAgfHwgbmV3WSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdFx0ZWFzaW5nID0gdXRpbHMuZWFzZS5xdWFkcmF0aWM7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2Nyb2xsVG8obmV3WCwgbmV3WSwgdGltZSwgZWFzaW5nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHR9LFxuXG5cdF9yZXNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcblxuXHRcdHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5yZWZyZXNoKCk7XG5cdFx0fSwgdGhpcy5vcHRpb25zLnJlc2l6ZVBvbGxpbmcpO1xuXHR9LFxuXG5cdHJlc2V0UG9zaXRpb246IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0dmFyIHggPSB0aGlzLngsXG5cdFx0XHR5ID0gdGhpcy55O1xuXG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblxuXHRcdGlmICggIXRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCB8fCB0aGlzLnggPiAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy54IDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0eCA9IHRoaXMubWF4U2Nyb2xsWDtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsIHx8IHRoaXMueSA+IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnkgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHR5ID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdGlmICggeCA9PSB0aGlzLnggJiYgeSA9PSB0aGlzLnkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxUbyh4LCB5LCB0aW1lLCB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmYgPSB0aGlzLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1x0XHQvLyBGb3JjZSByZWZsb3dcblxuXHRcdHRoaXMud3JhcHBlcldpZHRoXHQ9IHRoaXMud3JhcHBlci5jbGllbnRXaWR0aDtcblx0XHR0aGlzLndyYXBwZXJIZWlnaHRcdD0gdGhpcy53cmFwcGVyLmNsaWVudEhlaWdodDtcblxuLyogUkVQTEFDRSBTVEFSVDogcmVmcmVzaCAqL1xuXG5cdFx0dGhpcy5zY3JvbGxlcldpZHRoXHQ9IHRoaXMuc2Nyb2xsZXIub2Zmc2V0V2lkdGg7XG5cdFx0dGhpcy5zY3JvbGxlckhlaWdodFx0PSB0aGlzLnNjcm9sbGVyLm9mZnNldEhlaWdodDtcblxuXHRcdHRoaXMubWF4U2Nyb2xsWFx0XHQ9IHRoaXMud3JhcHBlcldpZHRoIC0gdGhpcy5zY3JvbGxlcldpZHRoO1xuXHRcdHRoaXMubWF4U2Nyb2xsWVx0XHQ9IHRoaXMud3JhcHBlckhlaWdodCAtIHRoaXMuc2Nyb2xsZXJIZWlnaHQ7XG5cbi8qIFJFUExBQ0UgRU5EOiByZWZyZXNoICovXG5cblx0XHR0aGlzLmhhc0hvcml6b250YWxTY3JvbGxcdD0gdGhpcy5vcHRpb25zLnNjcm9sbFggJiYgdGhpcy5tYXhTY3JvbGxYIDwgMDtcblx0XHR0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsXHRcdD0gdGhpcy5vcHRpb25zLnNjcm9sbFkgJiYgdGhpcy5tYXhTY3JvbGxZIDwgMDtcblxuXHRcdGlmICggIXRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCApIHtcblx0XHRcdHRoaXMubWF4U2Nyb2xsWCA9IDA7XG5cdFx0XHR0aGlzLnNjcm9sbGVyV2lkdGggPSB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0dGhpcy5tYXhTY3JvbGxZID0gMDtcblx0XHRcdHRoaXMuc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLndyYXBwZXJIZWlnaHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbmRUaW1lID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cblx0XHR0aGlzLndyYXBwZXJPZmZzZXQgPSB1dGlscy5vZmZzZXQodGhpcy53cmFwcGVyKTtcblxuXHRcdHRoaXMuX2V4ZWNFdmVudCgncmVmcmVzaCcpO1xuXG5cdFx0dGhpcy5yZXNldFBvc2l0aW9uKCk7XG5cbi8vIElOU0VSVCBQT0lOVDogX3JlZnJlc2hcblxuXHR9LFxuXG5cdG9uOiBmdW5jdGlvbiAodHlwZSwgZm4pIHtcblx0XHRpZiAoICF0aGlzLl9ldmVudHNbdHlwZV0gKSB7XG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcblx0XHR9XG5cblx0XHR0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChmbik7XG5cdH0sXG5cblx0b2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4pIHtcblx0XHRpZiAoICF0aGlzLl9ldmVudHNbdHlwZV0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fZXZlbnRzW3R5cGVdLmluZGV4T2YoZm4pO1xuXG5cdFx0aWYgKCBpbmRleCA+IC0xICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9leGVjRXZlbnQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpID0gMCxcblx0XHRcdGwgPSB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuXG5cdFx0aWYgKCAhbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV1baV0uYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHR9XG5cdH0sXG5cblx0c2Nyb2xsQnk6IGZ1bmN0aW9uICh4LCB5LCB0aW1lLCBlYXNpbmcpIHtcblx0XHR4ID0gdGhpcy54ICsgeDtcblx0XHR5ID0gdGhpcy55ICsgeTtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXG5cdFx0dGhpcy5zY3JvbGxUbyh4LCB5LCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdHNjcm9sbFRvOiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0ZWFzaW5nID0gZWFzaW5nIHx8IHV0aWxzLmVhc2UuY2lyY3VsYXI7XG5cblx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGltZSA+IDA7XG5cblx0XHRpZiAoICF0aW1lIHx8ICh0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiBlYXNpbmcuc3R5bGUpICkge1xuXHRcdFx0dGhpcy5fdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKGVhc2luZy5zdHlsZSk7XG5cdFx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSh0aW1lKTtcblx0XHRcdHRoaXMuX3RyYW5zbGF0ZSh4LCB5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYW5pbWF0ZSh4LCB5LCB0aW1lLCBlYXNpbmcuZm4pO1xuXHRcdH1cblx0fSxcblxuXHRzY3JvbGxUb0VsZW1lbnQ6IGZ1bmN0aW9uIChlbCwgdGltZSwgb2Zmc2V0WCwgb2Zmc2V0WSwgZWFzaW5nKSB7XG5cdFx0ZWwgPSBlbC5ub2RlVHlwZSA/IGVsIDogdGhpcy5zY3JvbGxlci5xdWVyeVNlbGVjdG9yKGVsKTtcblxuXHRcdGlmICggIWVsICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwb3MgPSB1dGlscy5vZmZzZXQoZWwpO1xuXG5cdFx0cG9zLmxlZnQgLT0gdGhpcy53cmFwcGVyT2Zmc2V0LmxlZnQ7XG5cdFx0cG9zLnRvcCAgLT0gdGhpcy53cmFwcGVyT2Zmc2V0LnRvcDtcblxuXHRcdC8vIGlmIG9mZnNldFgvWSBhcmUgdHJ1ZSB3ZSBjZW50ZXIgdGhlIGVsZW1lbnQgdG8gdGhlIHNjcmVlblxuXHRcdGlmICggb2Zmc2V0WCA9PT0gdHJ1ZSApIHtcblx0XHRcdG9mZnNldFggPSBNYXRoLnJvdW5kKGVsLm9mZnNldFdpZHRoIC8gMiAtIHRoaXMud3JhcHBlci5vZmZzZXRXaWR0aCAvIDIpO1xuXHRcdH1cblx0XHRpZiAoIG9mZnNldFkgPT09IHRydWUgKSB7XG5cdFx0XHRvZmZzZXRZID0gTWF0aC5yb3VuZChlbC5vZmZzZXRIZWlnaHQgLyAyIC0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodCAvIDIpO1xuXHRcdH1cblxuXHRcdHBvcy5sZWZ0IC09IG9mZnNldFggfHwgMDtcblx0XHRwb3MudG9wICAtPSBvZmZzZXRZIHx8IDA7XG5cblx0XHRwb3MubGVmdCA9IHBvcy5sZWZ0ID4gMCA/IDAgOiBwb3MubGVmdCA8IHRoaXMubWF4U2Nyb2xsWCA/IHRoaXMubWF4U2Nyb2xsWCA6IHBvcy5sZWZ0O1xuXHRcdHBvcy50b3AgID0gcG9zLnRvcCAgPiAwID8gMCA6IHBvcy50b3AgIDwgdGhpcy5tYXhTY3JvbGxZID8gdGhpcy5tYXhTY3JvbGxZIDogcG9zLnRvcDtcblxuXHRcdHRpbWUgPSB0aW1lID09PSB1bmRlZmluZWQgfHwgdGltZSA9PT0gbnVsbCB8fCB0aW1lID09PSAnYXV0bycgPyBNYXRoLm1heChNYXRoLmFicyh0aGlzLngtcG9zLmxlZnQpLCBNYXRoLmFicyh0aGlzLnktcG9zLnRvcCkpIDogdGltZTtcblxuXHRcdHRoaXMuc2Nyb2xsVG8ocG9zLmxlZnQsIHBvcy50b3AsIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0X3RyYW5zaXRpb25UaW1lOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9IHRpbWUgKyAnbXMnO1xuXG5cdFx0aWYgKCAhdGltZSAmJiB1dGlscy5pc0JhZEFuZHJvaWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9ICcwLjAwMXMnO1xuXHRcdH1cblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltZSh0aW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWVcblxuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uIChlYXNpbmcpIHtcblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZztcblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24oZWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXG5cblx0fSxcblxuXHRfdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblxuLyogUkVQTEFDRSBTVEFSVDogX3RyYW5zbGF0ZSAqL1xuXG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyArIHRoaXMudHJhbnNsYXRlWjtcblxuLyogUkVQTEFDRSBFTkQ6IF90cmFuc2xhdGUgKi9cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gTWF0aC5yb3VuZCh4KTtcblx0XHRcdHkgPSBNYXRoLnJvdW5kKHkpO1xuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuc2Nyb2xsZXJTdHlsZS50b3AgPSB5ICsgJ3B4Jztcblx0XHR9XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblxuXHRpZiAoIHRoaXMuaW5kaWNhdG9ycyApIHtcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udXBkYXRlUG9zaXRpb24oKTtcblx0XHR9XG5cdH1cblxuXG4vLyBJTlNFUlQgUE9JTlQ6IF90cmFuc2xhdGVcblxuXHR9LFxuXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0dmFyIGV2ZW50VHlwZSA9IHJlbW92ZSA/IHV0aWxzLnJlbW92ZUV2ZW50IDogdXRpbHMuYWRkRXZlbnQsXG5cdFx0XHR0YXJnZXQgPSB0aGlzLm9wdGlvbnMuYmluZFRvV3JhcHBlciA/IHRoaXMud3JhcHBlciA6IHdpbmRvdztcblxuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdyZXNpemUnLCB0aGlzKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNrICkge1xuXHRcdFx0ZXZlbnRUeXBlKHRoaXMud3JhcHBlciwgJ2NsaWNrJywgdGhpcywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVNb3VzZSApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICdtb3VzZWRvd24nLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZW1vdmUnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZWNhbmNlbCcsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoIHV0aWxzLmhhc1BvaW50ZXIgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlUG9pbnRlciApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyY2FuY2VsJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCB1dGlscy5oYXNUb3VjaCAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVUb3VjaCApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2hjYW5jZWwnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ01TVHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHR9LFxuXG5cdGdldENvbXB1dGVkUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWF0cml4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxlciwgbnVsbCksXG5cdFx0XHR4LCB5O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4W3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0uc3BsaXQoJyknKVswXS5zcGxpdCgnLCAnKTtcblx0XHRcdHggPSArKG1hdHJpeFsxMl0gfHwgbWF0cml4WzRdKTtcblx0XHRcdHkgPSArKG1hdHJpeFsxM10gfHwgbWF0cml4WzVdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9ICttYXRyaXgubGVmdC5yZXBsYWNlKC9bXi1cXGQuXS9nLCAnJyk7XG5cdFx0XHR5ID0gK21hdHJpeC50b3AucmVwbGFjZSgvW14tXFxkLl0vZywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblx0fSxcblxuXHRfaW5pdEluZGljYXRvcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaW50ZXJhY3RpdmUgPSB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmVTY3JvbGxiYXJzLFxuXHRcdFx0Y3VzdG9tU3R5bGUgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMgIT0gJ3N0cmluZycsXG5cdFx0XHRpbmRpY2F0b3JzID0gW10sXG5cdFx0XHRpbmRpY2F0b3I7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmluZGljYXRvcnMgPSBbXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMgKSB7XG5cdFx0XHQvLyBWZXJ0aWNhbCBzY3JvbGxiYXJcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbFkgKSB7XG5cdFx0XHRcdGluZGljYXRvciA9IHtcblx0XHRcdFx0XHRlbDogY3JlYXRlRGVmYXVsdFNjcm9sbGJhcigndicsIGludGVyYWN0aXZlLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyksXG5cdFx0XHRcdFx0aW50ZXJhY3RpdmU6IGludGVyYWN0aXZlLFxuXHRcdFx0XHRcdGRlZmF1bHRTY3JvbGxiYXJzOiB0cnVlLFxuXHRcdFx0XHRcdGN1c3RvbVN0eWxlOiBjdXN0b21TdHlsZSxcblx0XHRcdFx0XHRyZXNpemU6IHRoaXMub3B0aW9ucy5yZXNpemVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdHNocmluazogdGhpcy5vcHRpb25zLnNocmlua1Njcm9sbGJhcnMsXG5cdFx0XHRcdFx0ZmFkZTogdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGxpc3Rlblg6IGZhbHNlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvci5lbCk7XG5cdFx0XHRcdGluZGljYXRvcnMucHVzaChpbmRpY2F0b3IpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb3Jpem9udGFsIHNjcm9sbGJhclxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2Nyb2xsWCApIHtcblx0XHRcdFx0aW5kaWNhdG9yID0ge1xuXHRcdFx0XHRcdGVsOiBjcmVhdGVEZWZhdWx0U2Nyb2xsYmFyKCdoJywgaW50ZXJhY3RpdmUsIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzKSxcblx0XHRcdFx0XHRpbnRlcmFjdGl2ZTogaW50ZXJhY3RpdmUsXG5cdFx0XHRcdFx0ZGVmYXVsdFNjcm9sbGJhcnM6IHRydWUsXG5cdFx0XHRcdFx0Y3VzdG9tU3R5bGU6IGN1c3RvbVN0eWxlLFxuXHRcdFx0XHRcdHJlc2l6ZTogdGhpcy5vcHRpb25zLnJlc2l6ZVNjcm9sbGJhcnMsXG5cdFx0XHRcdFx0c2hyaW5rOiB0aGlzLm9wdGlvbnMuc2hyaW5rU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRmYWRlOiB0aGlzLm9wdGlvbnMuZmFkZVNjcm9sbGJhcnMsXG5cdFx0XHRcdFx0bGlzdGVuWTogZmFsc2Vcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yLmVsKTtcblx0XHRcdFx0aW5kaWNhdG9ycy5wdXNoKGluZGljYXRvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaW5kaWNhdG9ycyApIHtcblx0XHRcdC8vIFRPRE86IGNoZWNrIGNvbmNhdCBjb21wYXRpYmlsaXR5XG5cdFx0XHRpbmRpY2F0b3JzID0gaW5kaWNhdG9ycy5jb25jYXQodGhpcy5vcHRpb25zLmluZGljYXRvcnMpO1xuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvcnMucHVzaCggbmV3IEluZGljYXRvcih0aGlzLCBpbmRpY2F0b3JzW2ldKSApO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IGNoZWNrIGlmIHdlIGNhbiB1c2UgYXJyYXkubWFwICh3aWRlIGNvbXBhdGliaWxpdHkgYW5kIHBlcmZvcm1hbmNlIGlzc3Vlcylcblx0XHRmdW5jdGlvbiBfaW5kaWNhdG9yc01hcCAoZm4pIHtcblx0XHRcdGZvciAoIHZhciBpID0gdGhhdC5pbmRpY2F0b3JzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGF0LmluZGljYXRvcnNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzICkge1xuXHRcdFx0dGhpcy5vbignc2Nyb2xsRW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMub24oJ3Njcm9sbENhbmNlbCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLm9uKCdzY3JvbGxTdGFydCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgxKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbignYmVmb3JlU2Nyb2xsU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoMSwgdHJ1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cblx0XHR0aGlzLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZGVsZXRlIHRoaXMuaW5kaWNhdG9ycztcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFdoZWVsOiBmdW5jdGlvbiAoKSB7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnd2hlZWwnLCB0aGlzKTtcblx0XHR1dGlscy5hZGRFdmVudCh0aGlzLndyYXBwZXIsICdtb3VzZXdoZWVsJywgdGhpcyk7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnRE9NTW91c2VTY3JvbGwnLCB0aGlzKTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICd3aGVlbCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy53cmFwcGVyLCAnbW91c2V3aGVlbCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy53cmFwcGVyLCAnRE9NTW91c2VTY3JvbGwnLCB0aGlzKTtcblx0XHR9KTtcblx0fSxcblxuXHRfd2hlZWw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dmFyIHdoZWVsRGVsdGFYLCB3aGVlbERlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGlmICggdGhpcy53aGVlbFRpbWVvdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBFeGVjdXRlIHRoZSBzY3JvbGxFbmQgZXZlbnQgYWZ0ZXIgNDAwbXMgdGhlIHdoZWVsIHN0b3BwZWQgc2Nyb2xsaW5nXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2hlZWxUaW1lb3V0KTtcblx0XHR0aGlzLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHRcdHRoYXQud2hlZWxUaW1lb3V0ID0gdW5kZWZpbmVkO1xuXHRcdH0sIDQwMCk7XG5cblx0XHRpZiAoICdkZWx0YVgnIGluIGUgKSB7XG5cdFx0XHRpZiAoZS5kZWx0YU1vZGUgPT09IDEpIHtcblx0XHRcdFx0d2hlZWxEZWx0YVggPSAtZS5kZWx0YVggKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdFx0XHR3aGVlbERlbHRhWSA9IC1lLmRlbHRhWSAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGVlbERlbHRhWCA9IC1lLmRlbHRhWDtcblx0XHRcdFx0d2hlZWxEZWx0YVkgPSAtZS5kZWx0YVk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggJ3doZWVsRGVsdGFYJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSBlLndoZWVsRGVsdGFYIC8gMTIwICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHRcdHdoZWVsRGVsdGFZID0gZS53aGVlbERlbHRhWSAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0fSBlbHNlIGlmICggJ3doZWVsRGVsdGEnIGluIGUgKSB7XG5cdFx0XHR3aGVlbERlbHRhWCA9IHdoZWVsRGVsdGFZID0gZS53aGVlbERlbHRhIC8gMTIwICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHR9IGVsc2UgaWYgKCAnZGV0YWlsJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWSA9IC1lLmRldGFpbCAvIDMgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0d2hlZWxEZWx0YVggKj0gdGhpcy5vcHRpb25zLmludmVydFdoZWVsRGlyZWN0aW9uO1xuXHRcdHdoZWVsRGVsdGFZICo9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbjtcblxuXHRcdGlmICggIXRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR3aGVlbERlbHRhWCA9IHdoZWVsRGVsdGFZO1xuXHRcdFx0d2hlZWxEZWx0YVkgPSAwO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWDtcblx0XHRcdG5ld1kgPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZO1xuXG5cdFx0XHRpZiAoIHdoZWVsRGVsdGFYID4gMCApIHtcblx0XHRcdFx0bmV3WC0tO1xuXHRcdFx0fSBlbHNlIGlmICggd2hlZWxEZWx0YVggPCAwICkge1xuXHRcdFx0XHRuZXdYKys7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2hlZWxEZWx0YVkgPiAwICkge1xuXHRcdFx0XHRuZXdZLS07XG5cdFx0XHR9IGVsc2UgaWYgKCB3aGVlbERlbHRhWSA8IDAgKSB7XG5cdFx0XHRcdG5ld1krKztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5nb1RvUGFnZShuZXdYLCBuZXdZKTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5ld1ggPSB0aGlzLnggKyBNYXRoLnJvdW5kKHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IHdoZWVsRGVsdGFYIDogMCk7XG5cdFx0bmV3WSA9IHRoaXMueSArIE1hdGgucm91bmQodGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCA/IHdoZWVsRGVsdGFZIDogMCk7XG5cblx0XHRpZiAoIG5ld1ggPiAwICkge1xuXHRcdFx0bmV3WCA9IDA7XG5cdFx0fSBlbHNlIGlmICggbmV3WCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdG5ld1ggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdZID4gMCApIHtcblx0XHRcdG5ld1kgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRuZXdZID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8obmV3WCwgbmV3WSwgMCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcm9iZVR5cGUgPiAxICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX3doZWVsXG5cdH0sXG5cblx0X2luaXRTbmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jdXJyZW50UGFnZSA9IHt9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLnNuYXAgPT0gJ3N0cmluZycgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc25hcCA9IHRoaXMuc2Nyb2xsZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc25hcCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBpID0gMCwgbCxcblx0XHRcdFx0bSA9IDAsIG4sXG5cdFx0XHRcdGN4LCBjeSxcblx0XHRcdFx0eCA9IDAsIHksXG5cdFx0XHRcdHN0ZXBYID0gdGhpcy5vcHRpb25zLnNuYXBTdGVwWCB8fCB0aGlzLndyYXBwZXJXaWR0aCxcblx0XHRcdFx0c3RlcFkgPSB0aGlzLm9wdGlvbnMuc25hcFN0ZXBZIHx8IHRoaXMud3JhcHBlckhlaWdodCxcblx0XHRcdFx0ZWw7XG5cblx0XHRcdHRoaXMucGFnZXMgPSBbXTtcblxuXHRcdFx0aWYgKCAhdGhpcy53cmFwcGVyV2lkdGggfHwgIXRoaXMud3JhcHBlckhlaWdodCB8fCAhdGhpcy5zY3JvbGxlcldpZHRoIHx8ICF0aGlzLnNjcm9sbGVySGVpZ2h0ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgPT09IHRydWUgKSB7XG5cdFx0XHRcdGN4ID0gTWF0aC5yb3VuZCggc3RlcFggLyAyICk7XG5cdFx0XHRcdGN5ID0gTWF0aC5yb3VuZCggc3RlcFkgLyAyICk7XG5cblx0XHRcdFx0d2hpbGUgKCB4ID4gLXRoaXMuc2Nyb2xsZXJXaWR0aCApIHtcblx0XHRcdFx0XHR0aGlzLnBhZ2VzW2ldID0gW107XG5cdFx0XHRcdFx0bCA9IDA7XG5cdFx0XHRcdFx0eSA9IDA7XG5cblx0XHRcdFx0XHR3aGlsZSAoIHkgPiAtdGhpcy5zY3JvbGxlckhlaWdodCApIHtcblx0XHRcdFx0XHRcdHRoaXMucGFnZXNbaV1bbF0gPSB7XG5cdFx0XHRcdFx0XHRcdHg6IE1hdGgubWF4KHgsIHRoaXMubWF4U2Nyb2xsWCksXG5cdFx0XHRcdFx0XHRcdHk6IE1hdGgubWF4KHksIHRoaXMubWF4U2Nyb2xsWSksXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBzdGVwWCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBzdGVwWSxcblx0XHRcdFx0XHRcdFx0Y3g6IHggLSBjeCxcblx0XHRcdFx0XHRcdFx0Y3k6IHkgLSBjeVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0eSAtPSBzdGVwWTtcblx0XHRcdFx0XHRcdGwrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR4IC09IHN0ZXBYO1xuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwgPSB0aGlzLm9wdGlvbnMuc25hcDtcblx0XHRcdFx0bCA9IGVsLmxlbmd0aDtcblx0XHRcdFx0biA9IC0xO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGkgPT09IDAgfHwgZWxbaV0ub2Zmc2V0TGVmdCA8PSBlbFtpLTFdLm9mZnNldExlZnQgKSB7XG5cdFx0XHRcdFx0XHRtID0gMDtcblx0XHRcdFx0XHRcdG4rKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICF0aGlzLnBhZ2VzW21dICkge1xuXHRcdFx0XHRcdFx0dGhpcy5wYWdlc1ttXSA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHggPSBNYXRoLm1heCgtZWxbaV0ub2Zmc2V0TGVmdCwgdGhpcy5tYXhTY3JvbGxYKTtcblx0XHRcdFx0XHR5ID0gTWF0aC5tYXgoLWVsW2ldLm9mZnNldFRvcCwgdGhpcy5tYXhTY3JvbGxZKTtcblx0XHRcdFx0XHRjeCA9IHggLSBNYXRoLnJvdW5kKGVsW2ldLm9mZnNldFdpZHRoIC8gMik7XG5cdFx0XHRcdFx0Y3kgPSB5IC0gTWF0aC5yb3VuZChlbFtpXS5vZmZzZXRIZWlnaHQgLyAyKTtcblxuXHRcdFx0XHRcdHRoaXMucGFnZXNbbV1bbl0gPSB7XG5cdFx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdFx0eTogeSxcblx0XHRcdFx0XHRcdHdpZHRoOiBlbFtpXS5vZmZzZXRXaWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogZWxbaV0ub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHRcdFx0Y3g6IGN4LFxuXHRcdFx0XHRcdFx0Y3k6IGN5XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmICggeCA+IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdFx0XHRcdG0rKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5nb1RvUGFnZSh0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYIHx8IDAsIHRoaXMuY3VycmVudFBhZ2UucGFnZVkgfHwgMCwgMCk7XG5cblx0XHRcdC8vIFVwZGF0ZSBzbmFwIHRocmVzaG9sZCBpZiBuZWVkZWRcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQgJSAxID09PSAwICkge1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRYID0gdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQ7XG5cdFx0XHRcdHRoaXMuc25hcFRocmVzaG9sZFkgPSB0aGlzLm9wdGlvbnMuc25hcFRocmVzaG9sZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc25hcFRocmVzaG9sZFggPSBNYXRoLnJvdW5kKHRoaXMucGFnZXNbdGhpcy5jdXJyZW50UGFnZS5wYWdlWF1bdGhpcy5jdXJyZW50UGFnZS5wYWdlWV0ud2lkdGggKiB0aGlzLm9wdGlvbnMuc25hcFRocmVzaG9sZCk7XG5cdFx0XHRcdHRoaXMuc25hcFRocmVzaG9sZFkgPSBNYXRoLnJvdW5kKHRoaXMucGFnZXNbdGhpcy5jdXJyZW50UGFnZS5wYWdlWF1bdGhpcy5jdXJyZW50UGFnZS5wYWdlWV0uaGVpZ2h0ICogdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5vbignZmxpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnggLSB0aGlzLnN0YXJ0WCksIDEwMDApLFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy55IC0gdGhpcy5zdGFydFkpLCAxMDAwKVxuXHRcdFx0XHRcdCksIDMwMCk7XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UoXG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UucGFnZVggKyB0aGlzLmRpcmVjdGlvblgsXG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UucGFnZVkgKyB0aGlzLmRpcmVjdGlvblksXG5cdFx0XHRcdHRpbWVcblx0XHRcdCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X25lYXJlc3RTbmFwOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggIXRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgeDogMCwgeTogMCwgcGFnZVg6IDAsIHBhZ2VZOiAwIH07XG5cdFx0fVxuXG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMucGFnZXMubGVuZ3RoLFxuXHRcdFx0bSA9IDA7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSBleGNlZWRlZCB0aGUgc25hcCB0aHJlc2hvbGRcblx0XHRpZiAoIE1hdGguYWJzKHggLSB0aGlzLmFic1N0YXJ0WCkgPCB0aGlzLnNuYXBUaHJlc2hvbGRYICYmXG5cdFx0XHRNYXRoLmFicyh5IC0gdGhpcy5hYnNTdGFydFkpIDwgdGhpcy5zbmFwVGhyZXNob2xkWSApIHtcblx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRQYWdlO1xuXHRcdH1cblxuXHRcdGlmICggeCA+IDAgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB4IDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0eCA9IHRoaXMubWF4U2Nyb2xsWDtcblx0XHR9XG5cblx0XHRpZiAoIHkgPiAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggeSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdHkgPSB0aGlzLm1heFNjcm9sbFk7XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0aWYgKCB4ID49IHRoaXMucGFnZXNbaV1bMF0uY3ggKSB7XG5cdFx0XHRcdHggPSB0aGlzLnBhZ2VzW2ldWzBdLng7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGwgPSB0aGlzLnBhZ2VzW2ldLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgbSA8IGw7IG0rKyApIHtcblx0XHRcdGlmICggeSA+PSB0aGlzLnBhZ2VzWzBdW21dLmN5ICkge1xuXHRcdFx0XHR5ID0gdGhpcy5wYWdlc1swXVttXS55O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGkgPT0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCApIHtcblx0XHRcdGkgKz0gdGhpcy5kaXJlY3Rpb25YO1xuXG5cdFx0XHRpZiAoIGkgPCAwICkge1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdH0gZWxzZSBpZiAoIGkgPj0gdGhpcy5wYWdlcy5sZW5ndGggKSB7XG5cdFx0XHRcdGkgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XG5cdFx0XHR9XG5cblx0XHRcdHggPSB0aGlzLnBhZ2VzW2ldWzBdLng7XG5cdFx0fVxuXG5cdFx0aWYgKCBtID09IHRoaXMuY3VycmVudFBhZ2UucGFnZVkgKSB7XG5cdFx0XHRtICs9IHRoaXMuZGlyZWN0aW9uWTtcblxuXHRcdFx0aWYgKCBtIDwgMCApIHtcblx0XHRcdFx0bSA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCBtID49IHRoaXMucGFnZXNbMF0ubGVuZ3RoICkge1xuXHRcdFx0XHRtID0gdGhpcy5wYWdlc1swXS5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXG5cdFx0XHR5ID0gdGhpcy5wYWdlc1swXVttXS55O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeSxcblx0XHRcdHBhZ2VYOiBpLFxuXHRcdFx0cGFnZVk6IG1cblx0XHR9O1xuXHR9LFxuXG5cdGdvVG9QYWdlOiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0ZWFzaW5nID0gZWFzaW5nIHx8IHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmc7XG5cblx0XHRpZiAoIHggPj0gdGhpcy5wYWdlcy5sZW5ndGggKSB7XG5cdFx0XHR4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSBpZiAoIHggPCAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCB5ID49IHRoaXMucGFnZXNbeF0ubGVuZ3RoICkge1xuXHRcdFx0eSA9IHRoaXMucGFnZXNbeF0ubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKCB5IDwgMCApIHtcblx0XHRcdHkgPSAwO1xuXHRcdH1cblxuXHRcdHZhciBwb3NYID0gdGhpcy5wYWdlc1t4XVt5XS54LFxuXHRcdFx0cG9zWSA9IHRoaXMucGFnZXNbeF1beV0ueTtcblxuXHRcdHRpbWUgPSB0aW1lID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHBvc1ggLSB0aGlzLngpLCAxMDAwKSxcblx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnMocG9zWSAtIHRoaXMueSksIDEwMDApXG5cdFx0XHQpLCAzMDApIDogdGltZTtcblxuXHRcdHRoaXMuY3VycmVudFBhZ2UgPSB7XG5cdFx0XHR4OiBwb3NYLFxuXHRcdFx0eTogcG9zWSxcblx0XHRcdHBhZ2VYOiB4LFxuXHRcdFx0cGFnZVk6IHlcblx0XHR9O1xuXG5cdFx0dGhpcy5zY3JvbGxUbyhwb3NYLCBwb3NZLCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdG5leHQ6IGZ1bmN0aW9uICh0aW1lLCBlYXNpbmcpIHtcblx0XHR2YXIgeCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVgsXG5cdFx0XHR5ID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdHgrKztcblxuXHRcdGlmICggeCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCAmJiB0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0XHR5Kys7XG5cdFx0fVxuXG5cdFx0dGhpcy5nb1RvUGFnZSh4LCB5LCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdHByZXY6IGZ1bmN0aW9uICh0aW1lLCBlYXNpbmcpIHtcblx0XHR2YXIgeCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVgsXG5cdFx0XHR5ID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdHgtLTtcblxuXHRcdGlmICggeCA8IDAgJiYgdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eS0tO1xuXHRcdH1cblxuXHRcdHRoaXMuZ29Ub1BhZ2UoeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRfaW5pdEtleXM6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gZGVmYXVsdCBrZXkgYmluZGluZ3Ncblx0XHR2YXIga2V5cyA9IHtcblx0XHRcdHBhZ2VVcDogMzMsXG5cdFx0XHRwYWdlRG93bjogMzQsXG5cdFx0XHRlbmQ6IDM1LFxuXHRcdFx0aG9tZTogMzYsXG5cdFx0XHRsZWZ0OiAzNyxcblx0XHRcdHVwOiAzOCxcblx0XHRcdHJpZ2h0OiAzOSxcblx0XHRcdGRvd246IDQwXG5cdFx0fTtcblx0XHR2YXIgaTtcblxuXHRcdC8vIGlmIHlvdSBnaXZlIG1lIGNoYXJhY3RlcnMgSSBnaXZlIHlvdSBrZXljb2RlXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzID09ICdvYmplY3QnICkge1xuXHRcdFx0Zm9yICggaSBpbiB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5nc1tpXSA9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyA9IHt9O1xuXHRcdH1cblxuXHRcdGZvciAoIGkgaW4ga2V5cyApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5rZXlCaW5kaW5nc1tpXSA9IHRoaXMub3B0aW9ucy5rZXlCaW5kaW5nc1tpXSB8fCBrZXlzW2ldO1xuXHRcdH1cblxuXHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgJ2tleWRvd24nLCB0aGlzKTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICdrZXlkb3duJywgdGhpcyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2tleTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNuYXAgPSB0aGlzLm9wdGlvbnMuc25hcCxcdC8vIHdlIGFyZSB1c2luZyB0aGlzIGFsb3QsIGJldHRlciB0byBjYWNoZSBpdFxuXHRcdFx0bmV3WCA9IHNuYXAgPyB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYIDogdGhpcy54LFxuXHRcdFx0bmV3WSA9IHNuYXAgPyB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZIDogdGhpcy55LFxuXHRcdFx0bm93ID0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0cHJldlRpbWUgPSB0aGlzLmtleVRpbWUgfHwgMCxcblx0XHRcdGFjY2VsZXJhdGlvbiA9IDAuMjUwLFxuXHRcdFx0cG9zO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiB0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0cG9zID0gdGhpcy5nZXRDb21wdXRlZFBvc2l0aW9uKCk7XG5cblx0XHRcdHRoaXMuX3RyYW5zbGF0ZShNYXRoLnJvdW5kKHBvcy54KSwgTWF0aC5yb3VuZChwb3MueSkpO1xuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gbm93IC0gcHJldlRpbWUgPCAyMDAgPyBNYXRoLm1pbih0aGlzLmtleUFjY2VsZXJhdGlvbiArIGFjY2VsZXJhdGlvbiwgNTApIDogMDtcblxuXHRcdHN3aXRjaCAoIGUua2V5Q29kZSApIHtcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLnBhZ2VVcDpcblx0XHRcdFx0aWYgKCB0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgJiYgIXRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHRcdFx0bmV3WCArPSBzbmFwID8gMSA6IHRoaXMud3JhcHBlcldpZHRoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1kgKz0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5wYWdlRG93bjpcblx0XHRcdFx0aWYgKCB0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgJiYgIXRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHRcdFx0bmV3WCAtPSBzbmFwID8gMSA6IHRoaXMud3JhcHBlcldpZHRoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1kgLT0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5lbmQ6XG5cdFx0XHRcdG5ld1ggPSBzbmFwID8gdGhpcy5wYWdlcy5sZW5ndGgtMSA6IHRoaXMubWF4U2Nyb2xsWDtcblx0XHRcdFx0bmV3WSA9IHNuYXAgPyB0aGlzLnBhZ2VzWzBdLmxlbmd0aC0xIDogdGhpcy5tYXhTY3JvbGxZO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmhvbWU6XG5cdFx0XHRcdG5ld1ggPSAwO1xuXHRcdFx0XHRuZXdZID0gMDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5sZWZ0OlxuXHRcdFx0XHRuZXdYICs9IHNuYXAgPyAtMSA6IDUgKyB0aGlzLmtleUFjY2VsZXJhdGlvbj4+MDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy51cDpcblx0XHRcdFx0bmV3WSArPSBzbmFwID8gMSA6IDUgKyB0aGlzLmtleUFjY2VsZXJhdGlvbj4+MDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5yaWdodDpcblx0XHRcdFx0bmV3WCAtPSBzbmFwID8gLTEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MuZG93bjpcblx0XHRcdFx0bmV3WSAtPSBzbmFwID8gMSA6IDUgKyB0aGlzLmtleUFjY2VsZXJhdGlvbj4+MDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBzbmFwICkge1xuXHRcdFx0dGhpcy5nb1RvUGFnZShuZXdYLCBuZXdZKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5ld1ggPiAwICkge1xuXHRcdFx0bmV3WCA9IDA7XG5cdFx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IDA7XG5cdFx0fSBlbHNlIGlmICggbmV3WCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdG5ld1ggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdZID4gMCApIHtcblx0XHRcdG5ld1kgPSAwO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRuZXdZID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8obmV3WCwgbmV3WSwgMCk7XG5cblx0XHR0aGlzLmtleVRpbWUgPSBub3c7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uIChkZXN0WCwgZGVzdFksIGR1cmF0aW9uLCBlYXNpbmdGbikge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHN0YXJ0WCA9IHRoaXMueCxcblx0XHRcdHN0YXJ0WSA9IHRoaXMueSxcblx0XHRcdHN0YXJ0VGltZSA9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdGRlc3RUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG5cblx0XHRmdW5jdGlvbiBzdGVwICgpIHtcblx0XHRcdHZhciBub3cgPSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHRcdGVhc2luZztcblxuXHRcdFx0aWYgKCBub3cgPj0gZGVzdFRpbWUgKSB7XG5cdFx0XHRcdHRoYXQuaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0dGhhdC5fdHJhbnNsYXRlKGRlc3RYLCBkZXN0WSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoICF0aGF0LnJlc2V0UG9zaXRpb24odGhhdC5vcHRpb25zLmJvdW5jZVRpbWUpICkge1xuXHRcdFx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG5vdyA9ICggbm93IC0gc3RhcnRUaW1lICkgLyBkdXJhdGlvbjtcblx0XHRcdGVhc2luZyA9IGVhc2luZ0ZuKG5vdyk7XG5cdFx0XHRuZXdYID0gKCBkZXN0WCAtIHN0YXJ0WCApICogZWFzaW5nICsgc3RhcnRYO1xuXHRcdFx0bmV3WSA9ICggZGVzdFkgLSBzdGFydFkgKSAqIGVhc2luZyArIHN0YXJ0WTtcblx0XHRcdHRoYXQuX3RyYW5zbGF0ZShuZXdYLCBuZXdZKTtcblxuXHRcdFx0aWYgKCB0aGF0LmlzQW5pbWF0aW5nICkge1xuXHRcdFx0XHRyQUYoc3RlcCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhhdC5vcHRpb25zLnByb2JlVHlwZSA9PSAzICkge1xuXHRcdFx0XHR0aGF0Ll9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuXHRcdHN0ZXAoKTtcblx0fSxcblxuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRzd2l0Y2ggKCBlLnR5cGUgKSB7XG5cdFx0XHRjYXNlICd0b3VjaHN0YXJ0Jzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJkb3duJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckRvd24nOlxuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0dGhpcy5fc3RhcnQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJtb3ZlJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlck1vdmUnOlxuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0dGhpcy5fbW92ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRjYXNlICdwb2ludGVydXAnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyVXAnOlxuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRjYXNlICd0b3VjaGNhbmNlbCc6XG5cdFx0XHRjYXNlICdwb2ludGVyY2FuY2VsJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckNhbmNlbCc6XG5cdFx0XHRjYXNlICdtb3VzZWNhbmNlbCc6XG5cdFx0XHRcdHRoaXMuX2VuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdvcmllbnRhdGlvbmNoYW5nZSc6XG5cdFx0XHRjYXNlICdyZXNpemUnOlxuXHRcdFx0XHR0aGlzLl9yZXNpemUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0cmFuc2l0aW9uZW5kJzpcblx0XHRcdGNhc2UgJ3dlYmtpdFRyYW5zaXRpb25FbmQnOlxuXHRcdFx0Y2FzZSAnb1RyYW5zaXRpb25FbmQnOlxuXHRcdFx0Y2FzZSAnTVNUcmFuc2l0aW9uRW5kJzpcblx0XHRcdFx0dGhpcy5fdHJhbnNpdGlvbkVuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd3aGVlbCc6XG5cdFx0XHRjYXNlICdET01Nb3VzZVNjcm9sbCc6XG5cdFx0XHRjYXNlICdtb3VzZXdoZWVsJzpcblx0XHRcdFx0dGhpcy5fd2hlZWwoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAna2V5ZG93bic6XG5cdFx0XHRcdHRoaXMuX2tleShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjbGljayc6XG5cdFx0XHRcdGlmICggIWUuX2NvbnN0cnVjdGVkICkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxufTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIgKGRpcmVjdGlvbiwgaW50ZXJhY3RpdmUsIHR5cGUpIHtcblx0dmFyIHNjcm9sbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5cdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTknO1xuXHRcdGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gJy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMC41KTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC45KTtib3JkZXItcmFkaXVzOjNweCc7XG5cdH1cblxuXHRpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2lTY3JvbGxJbmRpY2F0b3InO1xuXG5cdGlmICggZGlyZWN0aW9uID09ICdoJyApIHtcblx0XHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO2hlaWdodDo3cHg7bGVmdDoycHg7cmlnaHQ6MnB4O2JvdHRvbTowJztcblx0XHRcdGluZGljYXRvci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdFx0fVxuXHRcdHNjcm9sbGJhci5jbGFzc05hbWUgPSAnaVNjcm9sbEhvcml6b250YWxTY3JvbGxiYXInO1xuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRcdHNjcm9sbGJhci5zdHlsZS5jc3NUZXh0ICs9ICc7d2lkdGg6N3B4O2JvdHRvbToycHg7dG9wOjJweDtyaWdodDoxcHgnO1xuXHRcdFx0aW5kaWNhdG9yLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XHRzY3JvbGxiYXIuY2xhc3NOYW1lID0gJ2lTY3JvbGxWZXJ0aWNhbFNjcm9sbGJhcic7XG5cdH1cblxuXHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO292ZXJmbG93OmhpZGRlbic7XG5cblx0aWYgKCAhaW50ZXJhY3RpdmUgKSB7XG5cdFx0c2Nyb2xsYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cdH1cblxuXHRzY3JvbGxiYXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcblxuXHRyZXR1cm4gc2Nyb2xsYmFyO1xufVxuXG5mdW5jdGlvbiBJbmRpY2F0b3IgKHNjcm9sbGVyLCBvcHRpb25zKSB7XG5cdHRoaXMud3JhcHBlciA9IHR5cGVvZiBvcHRpb25zLmVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmVsKSA6IG9wdGlvbnMuZWw7XG5cdHRoaXMud3JhcHBlclN0eWxlID0gdGhpcy53cmFwcGVyLnN0eWxlO1xuXHR0aGlzLmluZGljYXRvciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5pbmRpY2F0b3JTdHlsZSA9IHRoaXMuaW5kaWNhdG9yLnN0eWxlO1xuXHR0aGlzLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG5cblx0dGhpcy5vcHRpb25zID0ge1xuXHRcdGxpc3Rlblg6IHRydWUsXG5cdFx0bGlzdGVuWTogdHJ1ZSxcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cdFx0cmVzaXplOiB0cnVlLFxuXHRcdGRlZmF1bHRTY3JvbGxiYXJzOiBmYWxzZSxcblx0XHRzaHJpbms6IGZhbHNlLFxuXHRcdGZhZGU6IGZhbHNlLFxuXHRcdHNwZWVkUmF0aW9YOiAwLFxuXHRcdHNwZWVkUmF0aW9ZOiAwXG5cdH07XG5cblx0Zm9yICggdmFyIGkgaW4gb3B0aW9ucyApIHtcblx0XHR0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xuXHR9XG5cblx0dGhpcy5zaXplUmF0aW9YID0gMTtcblx0dGhpcy5zaXplUmF0aW9ZID0gMTtcblx0dGhpcy5tYXhQb3NYID0gMDtcblx0dGhpcy5tYXhQb3NZID0gMDtcblxuXHRpZiAoIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSApIHtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVRvdWNoICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBvaW50ZXIgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlTW91c2UgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgJ21vdXNlZG93bicsIHRoaXMpO1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGlmICggdGhpcy5vcHRpb25zLmZhZGUgKSB7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9IHRoaXMuc2Nyb2xsZXIudHJhbnNsYXRlWjtcblx0XHR0aGlzLndyYXBwZXJTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dID0gdXRpbHMuaXNCYWRBbmRyb2lkID8gJzAuMDAxcycgOiAnMG1zJztcblx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gJzAnO1xuXHR9XG59XG5cbkluZGljYXRvci5wcm90b3R5cGUgPSB7XG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHN3aXRjaCAoIGUudHlwZSApIHtcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmRvd24nOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyRG93bic6XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHR0aGlzLl9zdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcm1vdmUnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyTW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJ1cCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJVcCc6XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGNhc2UgJ3RvdWNoY2FuY2VsJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyQ2FuY2VsJzpcblx0XHRcdGNhc2UgJ21vdXNlY2FuY2VsJzpcblx0XHRcdFx0dGhpcy5fZW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmludGVyYWN0aXZlICkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMuaW5kaWNhdG9yLCAnbW91c2Vkb3duJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNoZW5kJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICkge1xuXHRcdFx0dGhpcy53cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHRoaXMudHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdHRoaXMuaW5pdGlhdGVkID0gdHJ1ZTtcblx0XHR0aGlzLm1vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5sYXN0UG9pbnRYXHQ9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMubGFzdFBvaW50WVx0PSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuc3RhcnRUaW1lXHQ9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlVG91Y2ggKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVQb2ludGVyICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZU1vdXNlICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdiZWZvcmVTY3JvbGxTdGFydCcpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG5cdFx0XHRkZWx0YVgsIGRlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aW1lc3RhbXAgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdzY3JvbGxTdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubW92ZWQgPSB0cnVlO1xuXG5cdFx0ZGVsdGFYID0gcG9pbnQucGFnZVggLSB0aGlzLmxhc3RQb2ludFg7XG5cdFx0dGhpcy5sYXN0UG9pbnRYID0gcG9pbnQucGFnZVg7XG5cblx0XHRkZWx0YVkgPSBwb2ludC5wYWdlWSAtIHRoaXMubGFzdFBvaW50WTtcblx0XHR0aGlzLmxhc3RQb2ludFkgPSBwb2ludC5wYWdlWTtcblxuXHRcdG5ld1ggPSB0aGlzLnggKyBkZWx0YVg7XG5cdFx0bmV3WSA9IHRoaXMueSArIGRlbHRhWTtcblxuXHRcdHRoaXMuX3BvcyhuZXdYLCBuZXdZKTtcblxuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMucHJvYmVUeXBlID09IDEgJiYgdGltZXN0YW1wIC0gdGhpcy5zdGFydFRpbWUgPiAzMDAgKSB7XG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnc2Nyb2xsJyk7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5zY3JvbGxlci5vcHRpb25zLnByb2JlVHlwZSA+IDEgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdH1cblxuXG4vLyBJTlNFUlQgUE9JTlQ6IGluZGljYXRvci5fbW92ZVxuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0sXG5cblx0X2VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmluaXRpYXRlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmluaXRpYXRlZCA9IGZhbHNlO1xuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcm1vdmUnKSwgdGhpcyk7XG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cblx0XHRpZiAoIHRoaXMuc2Nyb2xsZXIub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dmFyIHNuYXAgPSB0aGlzLnNjcm9sbGVyLl9uZWFyZXN0U25hcCh0aGlzLnNjcm9sbGVyLngsIHRoaXMuc2Nyb2xsZXIueSk7XG5cblx0XHRcdHZhciB0aW1lID0gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdFx0XHRNYXRoLm1heChcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMuc2Nyb2xsZXIueCAtIHNuYXAueCksIDEwMDApLFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy5zY3JvbGxlci55IC0gc25hcC55KSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2Nyb2xsZXIueCAhPSBzbmFwLnggfHwgdGhpcy5zY3JvbGxlci55ICE9IHNuYXAueSApIHtcblx0XHRcdFx0dGhpcy5zY3JvbGxlci5kaXJlY3Rpb25YID0gMDtcblx0XHRcdFx0dGhpcy5zY3JvbGxlci5kaXJlY3Rpb25ZID0gMDtcblx0XHRcdFx0dGhpcy5zY3JvbGxlci5jdXJyZW50UGFnZSA9IHNuYXA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuc2Nyb2xsVG8oc25hcC54LCBzbmFwLnksIHRpbWUsIHRoaXMuc2Nyb2xsZXIub3B0aW9ucy5ib3VuY2VFYXNpbmcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tb3ZlZCApIHtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyYW5zaXRpb25UaW1lOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dID0gdGltZSArICdtcyc7XG5cblx0XHRpZiAoICF0aW1lICYmIHV0aWxzLmlzQmFkQW5kcm9pZCApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9ICcwLjAwMXMnO1xuXHRcdH1cblx0fSxcblxuXHR0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uIChlYXNpbmcpIHtcblx0XHR0aGlzLmluZGljYXRvclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbl0gPSBlYXNpbmc7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMudHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggJiYgIXRoaXMub3B0aW9ucy5saXN0ZW5ZICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5kaXNwbGF5ID0gdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWSAmJiAhdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc1ZlcnRpY2FsU2Nyb2xsID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5kaXNwbGF5ID0gdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsIHx8IHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsICYmIHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR1dGlscy5hZGRDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsQm90aFNjcm9sbGJhcnMnKTtcblx0XHRcdHV0aWxzLnJlbW92ZUNsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxMb25lU2Nyb2xsYmFyJyk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICYmIHRoaXMub3B0aW9ucy5jdXN0b21TdHlsZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUucmlnaHQgPSAnOHB4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUuYm90dG9tID0gJzhweCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dXRpbHMucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbEJvdGhTY3JvbGxiYXJzJyk7XG5cdFx0XHR1dGlscy5hZGRDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsTG9uZVNjcm9sbGJhcicpO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5kZWZhdWx0U2Nyb2xsYmFycyAmJiB0aGlzLm9wdGlvbnMuY3VzdG9tU3R5bGUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLnJpZ2h0ID0gJzJweCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLmJvdHRvbSA9ICcycHgnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHIgPSB0aGlzLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1x0Ly8gZm9yY2UgcmVmcmVzaFxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdHRoaXMud3JhcHBlcldpZHRoID0gdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMucmVzaXplICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcldpZHRoID0gTWF0aC5tYXgoTWF0aC5yb3VuZCh0aGlzLndyYXBwZXJXaWR0aCAqIHRoaXMud3JhcHBlcldpZHRoIC8gKHRoaXMuc2Nyb2xsZXIuc2Nyb2xsZXJXaWR0aCB8fCB0aGlzLndyYXBwZXJXaWR0aCB8fCAxKSksIDgpO1xuXHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLndpZHRoID0gdGhpcy5pbmRpY2F0b3JXaWR0aCArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcldpZHRoID0gdGhpcy5pbmRpY2F0b3IuY2xpZW50V2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWCA9IHRoaXMud3JhcHBlcldpZHRoIC0gdGhpcy5pbmRpY2F0b3JXaWR0aDtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdjbGlwJyApIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVggPSAtdGhpcy5pbmRpY2F0b3JXaWR0aCArIDg7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlYID0gdGhpcy53cmFwcGVyV2lkdGggLSA4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVggPSAwO1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WCA9IHRoaXMubWF4UG9zWDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zaXplUmF0aW9YID0gdGhpcy5vcHRpb25zLnNwZWVkUmF0aW9YIHx8ICh0aGlzLnNjcm9sbGVyLm1heFNjcm9sbFggJiYgKHRoaXMubWF4UG9zWCAvIHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWCkpO1x0XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWSApIHtcblx0XHRcdHRoaXMud3JhcHBlckhlaWdodCA9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9ySGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5yb3VuZCh0aGlzLndyYXBwZXJIZWlnaHQgKiB0aGlzLndyYXBwZXJIZWlnaHQgLyAodGhpcy5zY3JvbGxlci5zY3JvbGxlckhlaWdodCB8fCB0aGlzLndyYXBwZXJIZWlnaHQgfHwgMSkpLCA4KTtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodCArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvckhlaWdodCA9IHRoaXMuaW5kaWNhdG9yLmNsaWVudEhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnY2xpcCcgKSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlZID0gLXRoaXMuaW5kaWNhdG9ySGVpZ2h0ICsgODtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVkgPSB0aGlzLndyYXBwZXJIZWlnaHQgLSA4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVkgPSAwO1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WSA9IHRoaXMubWF4UG9zWTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cdFx0XHR0aGlzLnNpemVSYXRpb1kgPSB0aGlzLm9wdGlvbnMuc3BlZWRSYXRpb1kgfHwgKHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWSAmJiAodGhpcy5tYXhQb3NZIC8gdGhpcy5zY3JvbGxlci5tYXhTY3JvbGxZKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHR9LFxuXG5cdHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHggPSB0aGlzLm9wdGlvbnMubGlzdGVuWCAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWCAqIHRoaXMuc2Nyb2xsZXIueCkgfHwgMCxcblx0XHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWSAqIHRoaXMuc2Nyb2xsZXIueSkgfHwgMDtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5pZ25vcmVCb3VuZGFyaWVzICkge1xuXHRcdFx0aWYgKCB4IDwgdGhpcy5taW5Cb3VuZGFyeVggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLmluZGljYXRvcldpZHRoICsgeCwgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHggPSB0aGlzLm1pbkJvdW5kYXJ5WDtcblx0XHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heEJvdW5kYXJ5WCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMuaW5kaWNhdG9yV2lkdGggLSAoeCAtIHRoaXMubWF4UG9zWCksIDgpO1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHR4ID0gdGhpcy5tYXhQb3NYICsgdGhpcy5pbmRpY2F0b3JXaWR0aCAtIHRoaXMud2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHRoaXMubWF4Qm91bmRhcnlYO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgJiYgdGhpcy53aWR0aCAhPSB0aGlzLmluZGljYXRvcldpZHRoICkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5pbmRpY2F0b3JXaWR0aDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHkgPCB0aGlzLm1pbkJvdW5kYXJ5WSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmluZGljYXRvckhlaWdodCArIHkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR5ID0gdGhpcy5taW5Cb3VuZGFyeVk7XG5cdFx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhCb3VuZGFyeVkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JIZWlnaHQgLSAoeSAtIHRoaXMubWF4UG9zWSkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhQb3NZICsgdGhpcy5pbmRpY2F0b3JIZWlnaHQgLSB0aGlzLmhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhCb3VuZGFyeVk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyAmJiB0aGlzLmhlaWdodCAhPSB0aGlzLmluZGljYXRvckhlaWdodCApIHtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2Zvcm1dID0gJ3RyYW5zbGF0ZSgnICsgeCArICdweCwnICsgeSArICdweCknICsgdGhpcy5zY3JvbGxlci50cmFuc2xhdGVaO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUudG9wID0geSArICdweCc7XG5cdFx0fVxuXHR9LFxuXG5cdF9wb3M6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0aWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heFBvc1ggKSB7XG5cdFx0XHR4ID0gdGhpcy5tYXhQb3NYO1xuXHRcdH1cblxuXHRcdGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhQb3NZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4UG9zWTtcblx0XHR9XG5cblx0XHR4ID0gdGhpcy5vcHRpb25zLmxpc3RlblggPyBNYXRoLnJvdW5kKHggLyB0aGlzLnNpemVSYXRpb1gpIDogdGhpcy5zY3JvbGxlci54O1xuXHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSA/IE1hdGgucm91bmQoeSAvIHRoaXMuc2l6ZVJhdGlvWSkgOiB0aGlzLnNjcm9sbGVyLnk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHgsIHkpO1xuXHR9LFxuXG5cdGZhZGU6IGZ1bmN0aW9uICh2YWwsIGhvbGQpIHtcblx0XHRpZiAoIGhvbGQgJiYgIXRoaXMudmlzaWJsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5mYWRlVGltZW91dCk7XG5cdFx0dGhpcy5mYWRlVGltZW91dCA9IG51bGw7XG5cblx0XHR2YXIgdGltZSA9IHZhbCA/IDI1MCA6IDUwMCxcblx0XHRcdGRlbGF5ID0gdmFsID8gMCA6IDMwMDtcblxuXHRcdHZhbCA9IHZhbCA/ICcxJyA6ICcwJztcblxuXHRcdHRoaXMud3JhcHBlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSB0aW1lICsgJ21zJztcblxuXHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gdmFsO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gK3ZhbDtcblx0XHR9KS5iaW5kKHRoaXMsIHZhbCksIGRlbGF5KTtcblx0fVxufTtcblxuSVNjcm9sbC51dGlscyA9IHV0aWxzO1xuXG5pZiAoIHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gSVNjcm9sbDtcbn0gZWxzZSB7XG5cdHdpbmRvdy5JU2Nyb2xsID0gSVNjcm9sbDtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgTWF0aCk7IiwibW9kdWxlLmV4cG9ydHMgPSBuZXcgKCByZXF1aXJlKCBcInNjaGVkdWxlclwiICkgKSgpXG4iLCJsZXQgbG9kYXNoID0gcmVxdWlyZSggYGxvZGFzaGAgKVxubGV0IGNvID0gcmVxdWlyZSggYGNvYCApXG5cbmxldCBOT05fUEFSVElBTCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuTk9OX1BBUlRJQUwuX19wYXJ0aWFsX18gPSBmYWxzZVxuXG5sZXQgUEFSVElBTCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXG5mdW5jdGlvbiBhc3NlcnQoIHZhbHVlLCBtZXNzYWdlICkge1xuXHRpZiAoICF2YWx1ZSApXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgYCArIG1lc3NhZ2UgKVxufVxuXG5sZXQgTGl0ZXJhbFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZigge30gKVxuXG5sZXQgbHUgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblxuXHRkdW1wUHJvbWlzZTogcCA9PiBwLnRoZW4oXG5cdFx0cmVzdWx0ID0+IGx1LmxvZyggYHJlc3VsdDpgLCByZXN1bHQgKSxcblx0XHRlcnJvciA9PiBsdS5lcnJvciggYGVycm9yOmAsIGVycm9yIClcblx0KSxcblxuXHRkdW1wKCBtc2csIHZhbHVlICkge1xuXHRcdGNvbnNvbGUubG9nKCBtc2csIHZhbHVlIClcblx0XHRyZXR1cm4gdmFsdWVcblx0fSxcblxuXHRsb2c6IGNvbnNvbGUubG9nLmJpbmQoIGNvbnNvbGUgKSxcblx0aW5mbzogKCBjb25zb2xlLmluZm8gfHwgY29uc29sZS5sb2cgKS5iaW5kKCBjb25zb2xlICksXG5cdHdhcm46ICggY29uc29sZS53YXJuIHx8IGNvbnNvbGUubG9nICkuYmluZCggY29uc29sZSApLFxuXHRlcnJvcjogKCBjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nICkuYmluZCggY29uc29sZSApLFxuXHR0cmFjZTogKCBjb25zb2xlLnRyYWNlIHx8IGNvbnNvbGUubG9nICkuYmluZCggY29uc29sZSApLFxuXG5cdG1hcE9iaiggb2JqLCBwcm9wcyApIHtcblx0XHRsZXQgcmV0ID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0LmdldFByb3RvdHlwZU9mKCBvYmogKSApLCBvYmogKVxuXHRcdGxvZGFzaC5mb3JFYWNoKCBwcm9wcywgKCBmdW4sIGtleSApID0+IHJldFsga2V5IF0gPSB0eXBlb2YgZnVuID09IGBmdW5jdGlvbmAgPyBmdW4oIG9ialsga2V5IF0gKSA6IGZ1biApXG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdHJlc3RzKCBudW0sIC4uLnJlc3RzICkge1xuXHRcdGxldCByZXQgPSBbXVxuXHRcdGZvciAoIGxldCByIG9mIHJlc3RzICkge1xuXHRcdFx0bGV0IG4gPSBudW0gJSByXG5cdFx0XHRudW0gPSAoIG51bSAtIG4gKSAvIHJcblx0XHRcdHJldC5wdXNoKCBuIClcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdHBhZCggcywgbiwgcCApIHtcblx0XHRzID0gU3RyaW5nKCBzIClcblx0XHRsZXQgeCA9IGBgXG5cdFx0biAtPSBzLmxlbmd0aFxuXHRcdHdoaWxlICggbiA+IDAgKSB7XG5cdFx0XHR4ICs9IHBcblx0XHRcdC0tblxuXHRcdH1cblx0XHRyZXR1cm4geCArIHNcblx0fSxcblxuXHR0aW1lKCkge1xuXHRcdGxldCBkID0gbmV3IERhdGUoKVxuXHRcdHJldHVybiBgJHsgZC5nZXRIb3VycygpIH06JHsgbHUucGFkKCBkLmdldE1pbnV0ZXMoKSwgMiwgMCApIH06JHsgbHUucGFkKCBkLmdldFNlY29uZHMoKSwgMiwgMCApIH0uJHsgbHUucGFkKCBkLmdldE1pbGxpc2Vjb25kcygpLCAzLCAwICkgfWBcblx0fSxcblxuXHRzdGFjazogKCkgPT4gKCBuZXcgRXJyb3IgKS5zdGFjayxcblxuXHRvcHRpb25zKCBvcHRpb25zLCBkZWYgKSB7XG5cdFx0bGV0IHJldCA9IHt9XG5cdFx0Zm9yICggbGV0IGkgaW4gZGVmICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRlZiwgaSApIClcblx0XHRcdGlmICggb3B0aW9ucyA9PSBudWxsIClcblx0XHRcdFx0cmV0WyBpIF0gPSBkZWZbIGkgXVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBvcCA9IG9wdGlvbnNbIGkgXVxuXHRcdFx0XHRpZiAoIG9wID09IG51bGwgKVxuXHRcdFx0XHRcdG9wID0gZGVmWyBpIF1cblx0XHRcdFx0cmV0WyBpIF0gPSBvcFxuXHRcdFx0fVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRzdHI6ICggb2JqLCBkZXB0aCApID0+IHtcblx0XHRpZiAoIGRlcHRoID09IG51bGwgKVxuXHRcdFx0ZGVwdGggPSAxXG5cdFx0aWYgKCAhb2JqIHx8ICFkZXB0aCB8fCBkZXB0aCA8IDEgKVxuXHRcdFx0cmV0dXJuIGBgICsgb2JqXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApXG5cdFx0XHRyZXR1cm4gKCBgWyBgICsgb2JqLm1hcCggeCA9PiBsdS5zdHIoIHgsIGRlcHRoIC0gMSApICkuam9pbiggYCBgICkgKyBgIF1gIClcblx0XHRpZiAoICFvYmouY29uc3RydWN0b3IgfHwgb2JqLmNvbnN0cnVjdG9yID09IE9iamVjdCApXG5cdFx0XHRyZXR1cm4gKCBgeyBgICsgT2JqZWN0LmtleXMoIG9iaiApLm1hcCggeCA9PiB4ICsgYD1gICsgbHUuc3RyKCBvYmpbIHggXSwgZGVwdGggLSAxICkgKS5qb2luKCBgIGAgKSArIGAgfWAgKVxuXHRcdHJldHVybiBTdHJpbmcoIG9iaiApXG5cdH0sXG5cblx0dG9PbmVMaW5lKCBvYmogKSB7XG5cdFx0bGV0IHJldCA9IEpTT04uc3RyaW5naWZ5KCBvYmogKVxuXHRcdHJldCArPSBcIlxcblwiXG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdGJ5TGluZXMoIGNhbGxiYWNrICkge1xuXHRcdGxldCBidWZmZXIgPSBgYFxuXHRcdHJldHVybiBjaHVuayA9PiB7XG5cdFx0XHRidWZmZXIgKz0gU3RyaW5nKCBjaHVuayApXG5cdFx0XHRsZXQgcmV0ID0gYnVmZmVyLnNwbGl0KCBgXFxuYCApXG5cdFx0XHRidWZmZXIgPSByZXQucG9wKClcblx0XHRcdHJldC5mb3JFYWNoKCBjYWxsYmFjayApXG5cdFx0fVxuXHR9LFxuXG5cdGJ5SlNPTiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGJ5TGluZXMoIGxpbmUgPT4gY2FsbGJhY2soIEpTT04ucGFyc2UoIGxpbmUudHJpbSgpICkgKSApXG5cdH0sXG5cblx0dmFsdWVPZjogdmFsID0+IHZhbCA9PSBudWxsID8gbnVsbCA6IHZhbC52YWx1ZU9mID09IG51bGwgPyB2YWwgOiB2YWwudmFsdWVPZigpLFxuXG5cdHJldHVyblRoaXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMgfSxcblx0cmV0dXJuTnVsbDogKCkgPT4gbnVsbCxcblx0cmV0dXJuVHJ1ZTogKCkgPT4gdHJ1ZSxcblx0cmV0dXJuRmFsc2U6ICgpID0+IGZhbHNlLFxuXHRyZXR1cm5aZXJvOiAoKSA9PiAwLFxuXHRyZXR1cm5PbmU6ICgpID0+IDEsXG5cblx0cHJvbWlzZVN1Y2NlZWRlZDogUHJvbWlzZS5yZXNvbHZlKCksXG5cdHByb21pc2VOdWxsOiBQcm9taXNlLnJlc29sdmUoIG51bGwgKSxcblx0cHJvbWlzZVRydWU6IFByb21pc2UucmVzb2x2ZSggdHJ1ZSApLFxuXHRwcm9taXNlRmFsc2U6IFByb21pc2UucmVzb2x2ZSggZmFsc2UgKSxcblx0cHJvbWlzZVplcm86IFByb21pc2UucmVzb2x2ZSggMCApLFxuXHRwcm9taXNlT25lOiBQcm9taXNlLnJlc29sdmUoIDEgKSxcblxuXHRyZXR1cm5OdWxsUHJvbWlzZTogKCkgPT4gbHUucHJvbWlzZU51bGwsXG5cdHJldHVyblRydWVQcm9taXNlOiAoKSA9PiBsdS5wcm9taXNlVHJ1ZSxcblx0cmV0dXJuRmFsc2VQcm9taXNlOiAoKSA9PiBsdS5wcm9taXNlRmFsc2UsXG5cdHJldHVyblplcm9Qcm9taXNlOiAoKSA9PiBsdS5wcm9taXNlWmVybyxcblx0cmV0dXJuT25lUHJvbWlzZTogKCkgPT4gbHUucHJvbWlzZU9uZSxcblxuXHR3aGVuKCBwcm9taXNlLCBjYiApIHtcblx0XHRpZiAoIHByb21pc2UgIT0gbnVsbCApXG5cdFx0XHRwcm9taXNlLnRoZW4oIGNiLCBjYiApXG5cdFx0ZWxzZVxuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayggY2IgKVxuXHRcdHJldHVybiBwcm9taXNlXG5cdH0sXG5cblx0d2FpdEZvciggdGltZW91dCwgaW50ZXJ2YWwsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIHRpbWVvdXQgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdGludGVydmFsID0gdGltZW91dFxuXHRcdFx0dGltZW91dCA9IDUwMDBcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgaW50ZXJ2YWwgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdGNhbGxiYWNrID0gaW50ZXJ2YWxcblx0XHRcdGludGVydmFsID0gMjAwXG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cdFx0XHRsZXQgc3RhcnQgPSBEYXRlLm5vdygpXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiBjaGVjaygpIHtcblx0XHRcdFx0bGV0IHJldFxuXHRcdFx0XHRpZiAoIHJldCA9IGNhbGxiYWNrKCkgKVxuXHRcdFx0XHRcdHJlc29sdmUoIHJldCApXG5cdFx0XHRcdGVsc2UgaWYgKCBEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0IClcblx0XHRcdFx0XHRyZWplY3QoIG5ldyBFcnJvciggYHRpbWVvdXRgICkgKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0c2V0VGltZW91dCggY2hlY2ssIGludGVydmFsIClcblx0XHRcdH0sIGludGVydmFsIClcblx0XHR9IClcblx0fSxcblxuXHRlbXB0eTogT2JqZWN0LmZyZWV6ZSggT2JqZWN0LmNyZWF0ZSggbnVsbCApICksXG5cblx0SlNPTkVxdWFsKCBhLCBiICkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggYSApID09IEpTT04uc3RyaW5naWZ5KCBiIClcblx0fSxcblxuXHRuZXcoIC4uLmRlc2NlZGVudHMgKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oIHt9LCAuLi5kZXNjZWRlbnRzIClcblx0fSxcblxuXHRjYWxsKCBmdW4sIC4uLmFyZ3MgKSB7XG5cdFx0cmV0dXJuIGZ1biggLi4uYXJncyApXG5cdH0sXG5cblx0cmV0aHJvdyggZSApIHsgc2V0VGltZW91dCggKCkgPT4geyB0aHJvdyBlIH0sIDEgKSB9LFxuXG5cdC8vIG9wdGltaXphdGlvbiAtLSB1c2luZyB0cnkvY2F0Y2ggaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cblx0Y2F0Y2goIGNiLCByZXQgKSB7IHRyeSB7IHJldHVybiBjYigpIH0gY2F0Y2ggKCBlICkgeyByZXR1cm4gcmV0KCBlICkgfSB9LFxuXG5cdGNhdGNoTWFwKCBjYiwgbWFwUmVzdWx0LCBtYXBFcnJvciApIHtcblx0XHRsZXQgcmVzdWx0XG5cdFx0dHJ5IHtcblx0XHRcdHJlc3VsdCA9IGNiKClcblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdHJldHVybiBtYXBFcnJvciggZXJyb3IgKVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwUmVzdWx0KCByZXN1bHQgKVxuXHR9LFxuXG5cdGNhdGNoQ2FsbCggY2IgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7IG9rOiB0cnVlLCByZXN1bHQ6IGNiKCkgfVxuXHRcdH1cblx0XHRjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0cmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogZXJyb3IgfVxuXHRcdH1cblx0fSxcblxuXHQqdHJ5KCBmdW4sIHN0YXJ0VGltZVRvV2FpdCA9IDEwMCwgbWF4VGltZVRvV2FpdCA9IDMwMDAsIG11bHRpcGx5ID0gMS41ICkge1xuXHRcdGxldCB0aW1lVG9XYWl0ID0gc3RhcnRUaW1lVG9XYWl0XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIHlpZWxkIGZ1bigpXG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdGx1LnJldGhyb3coIGUgKVxuXHRcdFx0XHR5aWVsZCBjby5zbGVlcCggdGltZVRvV2FpdCApXG5cdFx0XHRcdHRpbWVUb1dhaXQgPSBNYXRoLm1pbiggdGltZVRvV2FpdCAqIG11bHRpcGx5LCBtYXhUaW1lVG9XYWl0IClcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0dW5pcXVlKCB2YWx1ZSwgaW5kZXgsIGFycmF5ICkge1xuXHRcdHJldHVybiBpbmRleCA9PSAwIHx8IHZhbHVlICE9IGFycmF5WyBpbmRleCAtIDEgXVxuXHR9LFxuXG5cdGpvaW5EYXRhKCBhcnJheSApIHtcblx0XHRyZXR1cm4gYXJyYXkubGVuZ3RoID09IDAgP1xuXHRcdFx0YGBcblx0XHQ6IHR5cGVvZiBhcnJheVsgMCBdID09IGBzdHJpbmdgID9cblx0XHRcdGFycmF5LmpvaW4oIGBgIClcblx0XHQ6IEJ1ZmZlci5pc0J1ZmZlciggYXJyYXlbIDAgXSApID9cblx0XHRcdEJ1ZmZlci5jb25jYXQoIGFycmF5IClcblx0XHQ6XG5cdFx0XHRhcnJheS5qb2luKCBgYCApXG5cdH0sXG5cblx0b24oIGVtaXR0ZXIsIGV2ZW50cyApIHtcblx0XHRsb2Rhc2guZm9yRWFjaCggZXZlbnRzLCAoIGhhbmRsZXIsIGV2ZW50ICkgPT4gZW1pdHRlci5vbiggZXZlbnQsIGhhbmRsZXIgKSApXG5cdH0sXG5cblx0b2ZmKCBlbWl0dGVyLCBldmVudHMgKSB7XG5cdFx0bG9kYXNoLmZvckVhY2goIGV2ZW50cywgKCBoYW5kbGVyLCBldmVudCApID0+IGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyICkgKVxuXHR9LFxuXG5cdCpyZWFkU3RyZWFtKCBzdHJlYW0gKSB7XG5cdFx0cmV0dXJuIHlpZWxkIHsgdGhlbiggcmVzb2x2ZSwgcmVqZWN0ICkge1xuXHRcdFx0bGV0IGNvbnRlbnQgPSBbXVxuXHRcdFx0c3RyZWFtLm9uKCBgZGF0YWAsIGNodW5rID0+IGNvbnRlbnQucHVzaCggY2h1bmsgKSApXG5cdFx0XHRzdHJlYW0ub24oIGBlbmRgLCAoKSA9PiByZXNvbHZlKCBsdS5qb2luRGF0YSggY29udGVudCApICkgKVxuXHRcdFx0c3RyZWFtLm9uKCBgZXJyb3JgLCByZWplY3QgKVxuXHRcdH0gfVxuXHR9LFxuXG5cdCpyZWFkSlNPTiggc3RyZWFtICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCB5aWVsZCBsdS5yZWFkU3RyZWFtKCBzdHJlYW0gKSApXG5cdH0sXG5cblx0KnJlYWRDaHVuayggc3RyZWFtICkge1xuXHRcdHJldHVybiB5aWVsZCB7IHRoZW4oIHJlc29sdmUsIHJlamVjdCApIHtcblx0XHRcdHN0cmVhbS5vbiggYGRhdGFgLCBvbkRhdGEgKVxuXHRcdFx0c3RyZWFtLm9uKCBgZW5kYCwgb25FbmQgKVxuXHRcdFx0c3RyZWFtLm9uKCBgZXJyb3JgLCBvbkVycm9yIClcblx0XHRcdGZ1bmN0aW9uIGRvbmUoKSB7XG5cdFx0XHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lciggYGRhdGFgLCBvbkRhdGEgKVxuXHRcdFx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoIGBlbmRgLCBvbkVuZCApXG5cdFx0XHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lciggYGVycm9yYCwgb25FcnJvciApXG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBvbkRhdGEoIGNodW5rICkge1xuXHRcdFx0XHRkb25lKClcblx0XHRcdFx0cmVzb2x2ZSggY2h1bmsgKVxuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gb25FbmQoKSB7XG5cdFx0XHRcdGRvbmUoKVxuXHRcdFx0XHRyZXNvbHZlKCBudWxsIClcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIG9uRXJyb3IoIGVycm9yICkge1xuXHRcdFx0XHRkb25lKClcblx0XHRcdFx0cmVqZWN0KCBlcnJvciApXG5cdFx0XHR9XG5cdFx0fSB9XG5cdH0sXG5cblx0c3RhdGljKCBmdW4gKSB7XG5cdFx0cmV0dXJuIGNvLmZ1bmMoIGZ1bmN0aW9uKiAoIHJlcXVlc3QsIHJlc3BvbnNlICkge1xuXHRcdFx0bGV0IGhlYWRXcml0dGVuID0gZmFsc2UsIHJlc3BvbnNlRW5kZWQgPSBmYWxzZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bGV0IGJvZHkgPSB5aWVsZCBmdW4oKVxuXHRcdFx0XHRyZXNwb25zZS53cml0ZUhlYWQoIDIwMCwgeyBbIGBDb250ZW50LVR5cGVgIF06IGB0ZXh0L2h0bWw7IGNoYXJzZXQ9VVRGLThgIH0gKVxuXHRcdFx0XHRoZWFkV3JpdHRlbiA9IHRydWVcblx0XHRcdFx0aWYgKCB0eXBlb2YgYm9keSAhPSBgc3RyaW5nYCApXG5cdFx0XHRcdFx0Ym9keSA9IFJlYWN0LnJlbmRlckNvbXBvbmVudFRvU3RyaW5nKCBib2R5IClcblx0XHRcdFx0cmVzcG9uc2UuZW5kKCBib2R5IClcblx0XHRcdFx0cmVzcG9uc2VFbmRlZCA9IHRydWVcblx0XHRcdH1cblx0XHRcdGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoICFoZWFkV3JpdHRlbiApXG5cdFx0XHRcdFx0cmVzcG9uc2Uud3JpdGVIZWFkKCA1MDAsIHsgWyBgQ29udGVudC1UeXBlYCBdOiBgdGV4dC9wbGFpbmAgfSApXG5cdFx0XHRcdGlmICggIXJlc3BvbnNlRW5kZWQgKVxuXHRcdFx0XHRcdHJlc3BvbnNlLmVuZCggYDw8PCBFUlJPUiA+Pj5gIClcblx0XHRcdH1cblx0XHR9IClcblx0fSxcblxuXHRwcm9wZXJ0eSggb2JqLCBuYW1lLCBkZWZhdWx0VmFsdWUgKSB7XG5cdFx0bGV0IHByaXZhdGVOYW1lID0gYF9gICsgbmFtZVxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDIgKVxuXHRcdFx0b2JqWyBwcml2YXRlTmFtZSBdID0gZGVmYXVsdFZhbHVlXG5cdFx0b2JqWyBuYW1lIF0gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09IDAgKVxuXHRcdFx0XHRyZXR1cm4gb2JqWyBwcml2YXRlTmFtZSBdXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0b2JqWyBwcml2YXRlTmFtZSBdID0gdmFsdWVcblx0XHRcdFx0cmV0dXJuIG9ialxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb2JqXG5cdH0sXG5cblx0cG9sbGluZyggc3RyZWFtICkge1xuXHRcdGxldCByZXQgPSB7XG5cdFx0XHRzdG9wKCkge1xuXHRcdFx0XHRpZiAoICFyZXQgKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRpZiAoIHJldC5fcG9sbGluZyAhPSBudWxsICkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCggcmV0Ll9wb2xsaW5nIClcblx0XHRcdFx0XHRyZXQuX3BvbGxpbmcgPSBudWxsXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0ID0gbnVsbFxuXHRcdFx0fSxcblx0XHRcdF9wb2xsaW5nOiBudWxsLFxuXHRcdFx0X3RyeVRvU2VuZENodW5rKCkge1xuXHRcdFx0XHRpZiAoICFyZXQgKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRyZXQuX3BvbGxpbmcgPSBudWxsXG5cdFx0XHRcdGlmICggIXN0cmVhbS53cml0ZSggcmV0Ll9jaHVuayApIClcblx0XHRcdFx0XHRzdHJlYW0ub25jZSggYGRyYWluYCwgcmV0Ll90cnlUb1NlbmRDaHVuayApXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHN0cmVhbS5mbHVzaCA9PSBgZnVuY3Rpb25gIClcblx0XHRcdFx0XHRcdHN0cmVhbS5mbHVzaCgpXG5cdFx0XHRcdFx0cmV0Ll9wb2xsaW5nID0gc2V0VGltZW91dCggcmV0Ll90cnlUb1NlbmRDaHVuaywgcmV0Ll9pbnRlcnZhbCApXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fVxuXG5cdFx0bHUucHJvcGVydHkoIHJldCwgYGNodW5rYCwgYFxcbmAgKVxuXHRcdGx1LnByb3BlcnR5KCByZXQsIGBpbnRlcnZhbGAsIDYwMDAwIClcblxuXHRcdC8vIFRPRE86IHRoaXMgZXZlbnQgbmV2ZXIgZmlyZXMhIHdoYXQncyB0aGUgc2hpdD8gY2hlY2sgaXQhIG1heSBiZSB0aGUgcmVhc29uIGlzIC51c2UoIHJlcXVpcmUoIGBjb21wcmVzc2lvbmAgKSggeyB0aHJlc2hvbGQ6IDAgfSApICk/XG5cdFx0c3RyZWFtLm9uY2UoIGBlbmRgLCByZXQuc3RvcCApXG5cdFx0Ly8gVE9ETzogdGhpcyBldmVudCBuZXZlciBmaXJlcyEgd2hhdCdzIHRoZSBzaGl0PyBjaGVjayBpdCEgbWF5IGJlIHRoZSByZWFzb24gaXMgLnVzZSggcmVxdWlyZSggYGNvbXByZXNzaW9uYCApKCB7IHRocmVzaG9sZDogMCB9ICkgKT9cblx0XHRzdHJlYW0ub25jZSggYGNsb3NlYCwgcmV0LnN0b3AgKVxuXHRcdC8vIFRPRE86IHRoaXMgZXZlbnQgbmV2ZXIgZmlyZXMhIHdoYXQncyB0aGUgc2hpdD8gY2hlY2sgaXQhIG1heSBiZSB0aGUgcmVhc29uIGlzIC51c2UoIHJlcXVpcmUoIGBjb21wcmVzc2lvbmAgKSggeyB0aHJlc2hvbGQ6IDAgfSApICk/XG5cdFx0c3RyZWFtLm9uY2UoIGBlcnJvcmAsIHJldC5zdG9wIClcblxuXHRcdHByb2Nlc3MubmV4dFRpY2soIHJldC5fdHJ5VG9TZW5kQ2h1bmsgKVxuXG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdHRlc3REaWZmKCkge1xuXHRcdGxldCBwID0geyBhOiAxLCB4OiB7IHU6IDkgfSB9XG5cdFx0bGV0IHEgPSB7IHg6IHsgYzogMiB9IH1cblx0XHRhc3NlcnQoIEpTT04uc3RyaW5naWZ5KCBxICkgPT0gSlNPTi5zdHJpbmdpZnkoIGx1LmFwcGx5RGlmZiggcCwgbHUubWFrZURpZmYoIHAsIHEgKSApICkgKVxuXHR9LFxuXG5cdGlzU2V0OiBvYmogPT4ge1xuXHRcdGlmICggb2JqID09IG51bGwgKVxuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0bGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBvYmogKVxuXHRcdHJldHVybiBwcm90byA9PT0gTGl0ZXJhbFByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbFxuXHR9LFxuXG5cdGFwcGx5RGlmZiggZGVzdCwgZGlmZiwgcGFydGlhbCApIHtcblx0XHRsZXQgcmV0ID0gZGVzdFxuXHRcdGxldCBjbnQgPSAwXG5cblx0XHRmdW5jdGlvbiBjb3B5RGVzdCgpIHtcblx0XHRcdHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0Zm9yICggbGV0IGtleSBpbiBkZXN0ICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRlc3QsIGtleSApICkge1xuXHRcdFx0XHRsZXQgdmFsdWUgPSBkZXN0WyBrZXkgXVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdHJldFsga2V5IF0gPSBkZXN0WyBrZXkgXVxuXHRcdFx0XHQrK2NudFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZGlmZiAmJiBkaWZmLl9fcGFydGlhbF9fID09PSBmYWxzZSApXG5cdFx0XHRwYXJ0aWFsID0gZmFsc2VcblxuXHRcdGZvciAoIGxldCBrZXkgaW4gZGlmZiApIGlmICgga2V5ICE9IGBfX3BhcnRpYWxfX2AgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkaWZmLCBrZXkgKSApIHtcblx0XHRcdGxldCB2YWx1ZSA9IGRpZmZbIGtleSBdXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBgb2JqZWN0YCApXG5cdFx0XHRcdHZhbHVlID0gbHUuYXBwbHlEaWZmKCByZXQgJiYgcmV0WyBrZXkgXSwgdmFsdWUsIHBhcnRpYWwgKVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsICkge1xuXHRcdFx0XHRpZiAoIHJldCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggcmV0LCBrZXkgKSApIHtcblx0XHRcdFx0XHRpZiAoIHJldCA9PT0gZGVzdCApXG5cdFx0XHRcdFx0XHRjb3B5RGVzdCgpXG5cdFx0XHRcdFx0ZGVsZXRlIHJldFsga2V5IF1cblx0XHRcdFx0XHQtLWNudFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCByZXQgPT0gbnVsbCB8fCByZXRbIGtleSBdICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHJldCA9PT0gZGVzdCApXG5cdFx0XHRcdFx0XHRjb3B5RGVzdCgpXG5cdFx0XHRcdFx0cmV0WyBrZXkgXSA9IHZhbHVlXG5cdFx0XHRcdH1cblx0XHRcdFx0Y250ID0gSW5maW5pdHlcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHBhcnRpYWwgPT09IGZhbHNlIClcblx0XHRcdGZvciAoIGxldCBrZXkgaW4gcmV0ICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHJldCwga2V5ICkgKSB7XG5cdFx0XHRcdGlmICggIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggZGlmZiwga2V5ICkgfHwgZGlmZlsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRpZiAoIHJldCA9PT0gZGVzdCApXG5cdFx0XHRcdFx0XHRjb3B5RGVzdCgpXG5cdFx0XHRcdFx0ZGVsZXRlIHJldFsga2V5IF1cblx0XHRcdFx0XHQtLWNudFxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRjbnQgPSBJbmZpbml0eVxuXHRcdFx0fVxuXG5cdFx0aWYgKCByZXQgIT09IGRlc3QgJiYgY250ID09IDAgKVxuXHRcdFx0cmV0ID0gbnVsbFxuXG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdG1lcmdlRGlmZnMoIGEsIGIgKSB7XG5cblx0XHRpZiAoIGEgPT0gbnVsbCApXG5cdFx0XHRhID0gTk9OX1BBUlRJQUxcblx0XHRpZiAoIGIgPT0gbnVsbCApXG5cdFx0XHRiID0gTk9OX1BBUlRJQUxcblxuXHRcdGlmICggYi5fX3BhcnRpYWxfXyA9PT0gZmFsc2UgKVxuXHRcdFx0cmV0dXJuIGJcblxuXHRcdGxldCByZXQgPSBhXG5cblx0XHRmdW5jdGlvbiBjb3B5RGVzdCgpIHtcblx0XHRcdHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0Zm9yICggbGV0IGtleSBpbiBhICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGEsIGtleSApICkge1xuXHRcdFx0XHRsZXQgdmFsdWUgPSBhWyBrZXkgXVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdHJldFsga2V5IF0gPSBhWyBrZXkgXVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBrZXkgaW4gYiApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBiLCBrZXkgKSApIHtcblx0XHRcdGxldCB2YWx1ZSA9IGJbIGtleSBdXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIClcblx0XHRcdFx0dmFsdWUgPSBOT05fUEFSVElBTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYG9iamVjdGAgKSB7XG5cdFx0XHRcdGxldCByID0gcmV0ID8gcmV0WyBrZXkgXSA6IHVuZGVmaW5lZFxuXHRcdFx0XHRpZiAoIHIgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRcdFx0ciA9IFBBUlRJQUxcblx0XHRcdFx0dmFsdWUgPSBsdS5tZXJnZURpZmZzKCByLCB2YWx1ZSApXG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJldCA9PSBudWxsIHx8IHJldFsga2V5IF0gIT09IHZhbHVlICkge1xuXHRcdFx0XHRpZiAoIHJldCA9PT0gYSApXG5cdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRyZXRbIGtleSBdID0gdmFsdWVcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHJldCAhPT0gYSAmJiB0eXBlb2YgYSAhPSBgb2JqZWN0YCApXG5cdFx0XHRyZXQuX19wYXJ0aWFsX18gPSBmYWxzZVxuXG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdG1ha2VEaWZmKCBwcmV2aW91cywgbmV4dCApIHtcblx0XHRpZiAoIHByZXZpb3VzID09PSBuZXh0IClcblx0XHRcdHJldHVybiB1bmRlZmluZWRcblx0XHRsZXQgcmV0ID0gdW5kZWZpbmVkXG5cdFx0ZnVuY3Rpb24gdG9BcnJheSggb2JqICkge1xuXHRcdFx0bGV0IHJldCA9IFtdXG5cdFx0XHRsb2Rhc2guZm9yRWFjaCggb2JqLCAoIHZhbHVlLCBrZXkgKSA9PiByZXQucHVzaCggeyB2YWx1ZSwga2V5IH0gKSApXG5cdFx0XHRyZXR1cm4gcmV0LnNvcnQoICggdjEsIHYyICkgPT5cblx0XHRcdFx0djEua2V5IDwgdjIua2V5ID8gLTEgOiB2MS5rZXkgPiB2Mi5rZXkgPyAxIDogMCApXG5cdFx0fVxuXHRcdGxldCBwYSA9IHRvQXJyYXkoIHByZXZpb3VzIClcblx0XHRsZXQgbmEgPSB0b0FycmF5KCBuZXh0IClcblx0XHRsZXQgcCA9IHBhLnBvcCgpXG5cdFx0bGV0IG4gPSBuYS5wb3AoKVxuXHRcdHdoaWxlICggcCB8fCBuICkge1xuXHRcdFx0aWYgKCAhbiB8fCBwICYmIHAua2V5ID4gbi5rZXkgKSB7XG5cdFx0XHRcdGlmICggIXJldCApXG5cdFx0XHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdHJldFsgcC5rZXkgXSA9IG51bGwgLy8gZGVsZXRpbmdcblx0XHRcdFx0cCA9IHBhLnBvcCgpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggIXAgfHwgcC5rZXkgPCBuLmtleSApIHtcblx0XHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdFx0cmV0WyBuLmtleSBdID0gbi52YWx1ZVxuXHRcdFx0XHRuID0gbmEucG9wKClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoIHAudmFsdWUgIT09IG4udmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBsdS5pc1NldCggcC52YWx1ZSApICYmIGx1LmlzU2V0KCBuLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHRsZXQgZGlmZiA9IGx1Lm1ha2VEaWZmKCBwLnZhbHVlLCBuLnZhbHVlIClcblx0XHRcdFx0XHRcdGlmICggZGlmZiApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0XHRcdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdFx0XHRcdFx0cmV0WyBuLmtleSBdID0gZGlmZlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmICggIXJldCApXG5cdFx0XHRcdFx0XHRcdHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHRcdFx0cmV0WyBuLmtleSBdID0gbi52YWx1ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwID0gcGEucG9wKClcblx0XHRcdFx0biA9IG5hLnBvcCgpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQgPyByZXQgOiB1bmRlZmluZWRcblx0fSxcblxuXHRjb25jYXRTdHJpbmc6IGFycmF5ID0+IHtcblx0XHRsZXQgcmV0ID0gYGBcblx0XHQhZnVuY3Rpb24gd2FsayggYXJyYXkgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBhcnJheSAhPSBgb2JqZWN0YCApXG5cdFx0XHRcdHJldCArPSBhcnJheVxuXHRcdFx0ZWxzZSBpZiAoIGFycmF5Lmxlbmd0aCAhPSBudWxsIClcblx0XHRcdFx0YXJyYXkuZm9yRWFjaCggd2FsayApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGZvciAoIGxldCBzIG9mIGFycmF5IClcblx0XHRcdFx0XHR3YWxrKCBzIClcblx0XHR9KCBhcnJheSApXG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdHNvcnRlZERpZmYoIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0bGV0IGZpID0gZmlyc3RbIFN5bWJvbC5pdGVyYXRvciBdKClcblx0XHRsZXQgc2kgPSBzZWNvbmRbIFN5bWJvbC5pdGVyYXRvciBdKClcblx0XHRsZXQgcmV0ID0ge1xuXHRcdFx0Y29tbW9uOiBbXSxcblx0XHRcdGZpcnN0OiBbXSxcblx0XHRcdHNlY29uZDogW10sXG5cdFx0fVxuXHRcdGxldCBmdiA9IGZpLm5leHQoKSwgc3YgPSBzaS5uZXh0KClcblx0XHR3aGlsZSAoICFmdi5kb25lIHx8ICFzdi5kb25lICkge1xuXHRcdFx0aWYgKCBzdi5kb25lIHx8IGZ2LnZhbHVlIDwgc3YudmFsdWUgKSB7XG5cdFx0XHRcdHJldC5maXJzdC5wdXNoKCBmdi52YWx1ZSApXG5cdFx0XHRcdGZ2ID0gZmkubmV4dCgpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggZnYuZG9uZSB8fCBmdi52YWx1ZSA+IHN2LnZhbHVlICkge1xuXHRcdFx0XHRyZXQuc2Vjb25kLnB1c2goIHN2LnZhbHVlIClcblx0XHRcdFx0c3YgPSBzaS5uZXh0KClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXQuY29tbW9uLnB1c2goIGZ2LnZhbHVlIClcblx0XHRcdFx0ZnYgPSBmaS5uZXh0KClcblx0XHRcdFx0c3YgPSBzaS5uZXh0KClcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdG1lYXN1cmUoIGZ1biApIHtcblx0XHRsZXQgbm93ID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IGdsb2JhbC5EYXRlXG5cdFx0bGV0IHQgPSBub3cubm93KClcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGZ1bigpXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0dCA9ICggbm93Lm5vdygpIC0gdCApIC8gMTAwMFxuXHRcdFx0aWYgKCB0ID4gMCApIHtcblx0XHRcdFx0bGV0IGkgPSAxXG5cdFx0XHRcdHdoaWxlICggdCA8IDEwMDAgKSB7XG5cdFx0XHRcdFx0aSAqPSAxMFxuXHRcdFx0XHRcdHQgKj0gMTBcblx0XHRcdFx0fVxuXHRcdFx0XHR0ID0gTWF0aC5yb3VuZCggdCApIC8gaVxuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coIHQgKVxuXHRcdH1cblx0fSxcblxuXHQqc2tpcCggYywgYnVmICkge1xuXHRcdGZvciAoIGxldCBiIG9mIGJ1ZiApIHtcblx0XHRcdGlmICggYyA+IDAgKVxuXHRcdFx0XHQtLWNcblx0XHRcdGVsc2Vcblx0XHRcdFx0eWllbGQgYlxuXHRcdH1cblx0fSxcblxuXHQqdGFrZSggYywgYnVmICkge1xuXHRcdGZvciAoIGxldCBiIG9mIGJ1ZiApIHtcblx0XHRcdGlmICggYyA+IDAgKSB7XG5cdFx0XHRcdC0tY1xuXHRcdFx0XHR5aWVsZCBiXG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9LFxuXG5cdGNvcHkoIGJ1ZiApIHtcblx0XHRsZXQgcmV0ID0gbHUuYXJyYXkoIGJ1ZiApXG5cdFx0aWYgKCByZXQgPT0gYnVmIClcblx0XHRcdHJldCA9IGJ1Zi5zbGljZSgpXG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdGFycmF5MSggdmFsdWUgKSB7XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApIClcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBbIHZhbHVlIF1cblx0fSxcblxuXHRhcnJheSggYnVmICkge1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggYnVmICkgKVxuXHRcdFx0cmV0dXJuIGJ1ZlxuXHRcdGxldCByZXQgPSBbXVxuXHRcdGlmICggIWJ1ZlsgU3ltYm9sLml0ZXJhdG9yIF0gKVxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpIClcblx0XHRcdFx0cmV0LnB1c2goIGJ1ZlsgaSBdIClcblx0XHRlbHNlXG5cdFx0XHRmb3IgKCBsZXQgYiBvZiBidWYgKVxuXHRcdFx0XHRyZXQucHVzaCggYiApXG5cdFx0cmV0dXJuIHJldFxuXHR9LFxuXG5cdGJ1ZmZlciggYnVmICkge1xuXHRcdGlmICggYnVmIGluc3RhbmNlb2YgQnVmZmVyIClcblx0XHRcdHJldHVybiBidWZcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlciggbHUuYXJyYXkoIGJ1ZiApIClcblx0fSxcblxuXHR2ZWN0b3IoIGJ1ZiApIHtcblx0XHRyZXR1cm4gYnVmIGluc3RhbmNlb2YgQnVmZmVyID8gYnVmIDogbHUuYXJyYXkoIGJ1ZiApXG5cdH0sXG5cblx0KmNvbmNhdCggbGlzdCApIHtcblx0XHRmb3IgKCBsZXQgbCBvZiBsaXN0ICkgZm9yICggbGV0IHggb2YgbCApIHlpZWxkIHhcblx0fSxcblxuXHR3b3JkKCB3ICkge1xuXHRcdHJldHVybiBbIHcgJiAweGZmLCAoIHcgPj4gOCApICYgMHhmZiBdXG5cdH0sXG5cblx0ZHdvcmQoIHcgKSB7XG5cdFx0cmV0dXJuIFsgdyAmIDB4ZmYsICggdyA+PiA4ICkgJiAweGZmLCAoIHcgPj4gMTYgKSAmIDB4ZmYsICggdyA+PiAyNCApICYgMHhmZiBdXG5cdH0sXG5cblx0bWFrZVdvcmQoIGxvLCBoaSApIHtcblx0XHRyZXR1cm4gKCBsbyAmIDB4ZmYgKSArICggaGkgJiAweGZmICkgPDwgOFxuXHR9LFxuXG5cdGFycmF5RXF1YWwoIGEsIGIgKSB7XG5cdFx0cmV0dXJuIGEgJiYgYiAmJiBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCAoIGFpLCBpICkgPT4gYWkgPT0gYlsgaSBdIClcblx0fSxcblxuXHRjb21wYXJlKCBhLCBiICkge1xuXHRcdGlmICggYSA9PSBiIClcblx0XHRcdHJldHVybiAwXG5cdFx0aWYgKCBhIDwgYiApXG5cdFx0XHRyZXR1cm4gLTFcblx0XHRyZXR1cm4gMVxuXHR9LFxuXG5cdGZvcm1hdG1zKCB2YWx1ZSApIHtcblx0XHRsZXQgcmV0ID0gYGBcblx0XHR2YWx1ZSA9IE1hdGgucm91bmQoIHZhbHVlIClcblx0XHRsZXQgbXMgPSB2YWx1ZSAlIDEwMDBcblx0XHR2YWx1ZSAtPSBtc1xuXHRcdHZhbHVlIC89IDEwMDBcblx0XHRsZXQgcyA9IHZhbHVlICUgNjBcblx0XHR2YWx1ZSAtPSBzXG5cdFx0dmFsdWUgLz0gNjBcblx0XHRsZXQgbSA9IHZhbHVlICUgNjBcblx0XHR2YWx1ZSAtPSBtXG5cdFx0dmFsdWUgLz0gNjBcblx0XHRsZXQgaCA9IHZhbHVlXG5cdFx0cmV0ICs9IGggPyBoIDogYGBcblx0XHRyZXQgKz0gcmV0ID8gYDpgICsgeiggbSwgMiApIDogbSA/IG0gOiBgYFxuXHRcdHJldCArPSByZXQgPyBgOmAgKyB6KCBzLCAyICkgOiBzXG5cdFx0cmV0ICs9IGAuYCArIHooIG1zLCAzIClcblx0XHRyZXR1cm4gcmV0XG5cdFx0ZnVuY3Rpb24geiggdmFsdWUsIGxlbiApIHtcblx0XHRcdGxldCBzdHIgPSBTdHJpbmcoIHZhbHVlIClcblx0XHRcdGxldCByZXQgPSBgYFxuXHRcdFx0Zm9yICggbGV0IGkgPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kgKVxuXHRcdFx0XHRyZXQgKz0gYDBgXG5cdFx0XHRyZXQgKz0gc3RyXG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fVxuXHR9LFxuXG5cdGdldCggb2JqLCAuLi5wYXRoICkge1xuXHRcdGZvciAoIGxldCBwIG9mIHBhdGggKVxuXHRcdFx0aWYgKCBvYmogPT0gbnVsbCApXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG9iaiA9IG9ialsgcCBdXG5cdFx0cmV0dXJuIG9ialxuXHR9LFxuXG5cdGxpbWl0Q2FsbHMoIGxpbWl0LCBwZXJpb2QsIG1lc3NhZ2UgKSB7XG5cdFx0bGV0IGNhbGxzID0gMFxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRpZiAoIGNhbGxzID49IGxpbWl0IClcblx0XHRcdFx0aWYgKCBtZXNzYWdlIClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IuY3JlYXRlKCBtZXNzYWdlIClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0KytjYWxsc1xuXHRcdFx0c2V0VGltZW91dCggKCkgPT4gLS1jYWxscywgcGVyaW9kIClcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHR9LFxuXG59XG4iLCJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSggT2JqZWN0LnByb3RvdHlwZSwgYF9MT0dfYCwgeyB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHRjb25zb2xlLmxvZyggdGhpcyApXG5cdHJldHVybiB0aGlzXG59LCBjb25maWd1cmFibGU6IHRydWUgfSApXG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PSBgZnVuY3Rpb25gICYmIFN5bWJvbC5pdGVyYXRvciApIHtcblx0bGV0IHggPSBudWxsXG5cdHRyeSB7XG5cdFx0eCA9IGV2YWwuY2FsbCggbnVsbCwgYChmdW5jdGlvbiooKXt9KCkuY29uc3RydWN0b3IucHJvdG90eXBlKWAgKVxuXHR9IGNhdGNoICggXyApIHt9XG5cdGlmICggeCAmJiAheFsgU3ltYm9sLml0ZXJhdG9yIF0gKVxuXHRcdHhbIFN5bWJvbC5pdGVyYXRvciBdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyB9XG59XG4iLCIvKlxuXG5UT0RPOlxuXG4qIFdhcm5pbmcgaWYgYSBsaXZlIHByb3BlcnR5IGhhcyBub3QgYmVlbiByZWFkIGR1cmluZyB0aGUgbGlmZSB0aW1lIG9mIG9ic2VydmFibGUgdmFsdWUgb3IgZHVyaW5nIHNvbWUgcGVyaW9kIG9mIHRpbWUgKGUuZy4gMS0zMCBtaW51dGVzKSBzaW5jZSBjcmVhdGluZyB0aGF0IG9ic2VydmFibGUgdmFsdWUuXG5cbiogY2hlY2sgZm9yIGNoYW5nZXMgZHVyaW5nIGV4ZWN1dGlvbiBvZiAoZnVuY3Rpb24qKSBhbmQgcmVzdGFydCBjYWxjdWx1cy5cblxuXG5UT0RPIEJVRzpcbmxldCBhcHAgPSByYS5jbGVhbigge1xuXHRtb3ZpbmcxOiB7XG5cdFx0YTogMSxcblx0XHRiOiAyLFxuXHRcdGM6IHtcblx0XHRcdGQ6IDMsXG5cdFx0fSxcblx0fSxcbn1cbl9hcHAubW92aW5nMS5hXG4xXG5fYXBwLm1vdmluZzEuYy5kXG4zXG5fYXBwLm1vdmluZzE9e2E6NH1cbk9iamVjdCB7YTogNH1cbl9hcHAubW92aW5nMS5jLmRcbjMgICAgICAgICAgICAgICAgICAgICAgIDwtLS0tLS0tLS0tLSAhISEgIE1VU1QgQkUgTlVMTCAhISEhXG5fYXBwLm1vdmluZzEuY1xuQ2VsbCB7X2lkOiBcImo4N3lxa29xcHB1dlwiLCBfdmFsdWU6IG51bGwsIF9lcnJvcjogbnVsbCwgX2lzVmFsdWVFcXVhbDogZnVuY3Rpb24sIF9pbml0aWFsaXplZDogdHJ1ZeKApn1cbl9hcHAubW92aW5nMS5jLnZhbHVlT2YoKVxubnVsbFxuXG5cbiovXG5cbmxldCBsYXRlciA9IHJlcXVpcmUoIGBsYXRlcmAgKS5wdXNoXG5sZXQgY28gPSByZXF1aXJlKCBgY29gIClcbmxldCBVSUQgPSByZXF1aXJlKCBgdWlkYCApXG5sZXQgbG9kYXNoID0gcmVxdWlyZSggYGxvZGFzaGAgKVxubGV0IHsgTE9HIH0gPSByZXF1aXJlKCBgTE9HYCApXG5cbmxldCBhY3Rpb25LZXkgPSBgX1JBX0FDVElPTl8keyBVSUQoKSB9YFxubGV0IHJhVmFsdWUgPSBgX1JBX1ZBTFVFXyR7IFVJRCgpIH1gXG5cbi8vIGxldCBkZWJ1Z0xvZyA9IGZhbHNlXG5cbmxldCB1cGRhdGVzID0ge31cbnVwZGF0ZXMuc2NoZWR1bGVkID0gZmFsc2VcbnVwZGF0ZXMucHJvY3MgPSBbXVxudXBkYXRlcy5pbmRleCA9IDBcbnVwZGF0ZXMubWF4SW5kZXggPSAzMjc2OFxudXBkYXRlcy5wcm9jZXNzaW5nID0gZmFsc2VcbnVwZGF0ZXMudG90YWxUaW1lID0gMFxudXBkYXRlcy5tYXhUaW1lID0gMFxudXBkYXRlcy5tYXhUaW1lMSA9IDBcbnVwZGF0ZXMubWluVGltZSA9IEluZmluaXR5XG51cGRhdGVzLnJ1bkNvdW50ID0gMFxudXBkYXRlcy5ydW5BbGxDb3VudCA9IDBcblxuZ2xvYmFsLnVwZGF0ZXMgPSB1cGRhdGVzIC8vIGRlYnVnZ2VyXG5cbmxldCBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCBnbG9iYWwuRGF0ZVxudXBkYXRlcy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cbnVwZGF0ZXMubG9nID0gKCkgPT4gY29uc29sZS5sb2coIGA6OiAkeyB1cGRhdGVzLnRvdGFsVGltZSAvIDEwMDAgfSAvICR7ICggcGVyZm9ybWFuY2Uubm93KCkgLSB1cGRhdGVzLnN0YXJ0ICkgLyAxMDAwIH0gKCR7IHVwZGF0ZXMubWF4VGltZSAvIDEwMDAgfSwgJHsgdXBkYXRlcy5tYXhUaW1lMSAvIDEwMDAgfSwgJHsgdXBkYXRlcy5taW5UaW1lIC8gMTAwMCB9LCAkeyBBY3Rpb24ubWF4Q291bnQgfSwgJHsgdXBkYXRlcy5ydW5Db3VudCB9LCAkeyB1cGRhdGVzLnJ1bkFsbENvdW50IH0pYCApXG5cbi8vIGNvLmdvKCBmdW5jdGlvbiogKCkgeyAvLyBkZWJ1Z2dlclxuLy8gXHRsZXQgc2xlZXA1MDAwID0gY28uc2xlZXAoIDUwMDAgKVxuLy8gXHRmb3IgKDs7KSB7XG4vLyBcdFx0bGV0IHRvdGFsVGltZSA9IHVwZGF0ZXMudG90YWxUaW1lXG4vLyBcdFx0eWllbGQgc2xlZXA1MDAwXG4vLyBcdFx0aWYgKCB0b3RhbFRpbWUgIT0gdXBkYXRlcy50b3RhbFRpbWUgKVxuLy8gXHRcdFx0dXBkYXRlcy5sb2coKVxuLy8gXHR9XG4vLyB9IClcblxudXBkYXRlcy5jaGVja1NjaGVkdWxlID0gKCkgPT4ge1xuXHRpZiAoICF1cGRhdGVzLnNjaGVkdWxlZCAmJiB1cGRhdGVzLnByb2NzLmxlbmd0aCA+IDAgKSB7XG5cdFx0dXBkYXRlcy5zY2hlZHVsZWQgPSB0cnVlXG5cdFx0bGF0ZXIoIHVwZGF0ZXMudGljayApXG5cdH1cbn1cblxudXBkYXRlcy50aWNrID0gKCkgPT4ge1xuXHR1cGRhdGVzLnNjaGVkdWxlZCA9IGZhbHNlXG5cdGZvciAoIGxldCBfdHJ5ID0gMDsgX3RyeSA8IDEwMDA7ICsrX3RyeSApIHtcblx0XHR0cnkge1xuXHRcdFx0dXBkYXRlcy5ydW5BbGwoKVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZXJyb3IgfSwgMSApXG5cdFx0fVxuXHR9XG5cdHVwZGF0ZXMuY2hlY2tTY2hlZHVsZSgpXG59XG5cbnVwZGF0ZXMucnVuQWxsID0gKCkgPT4ge1xuXHQvLyBpZiAoIHVwZGF0ZXMucHJvY2Vzc2luZyApXG5cdC8vIFx0cmV0dXJuXG5cblx0bGV0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcblx0bGV0IHN0MSA9IHN0YXJ0XG5cdGxldCBydW5Db3VudCA9IHVwZGF0ZXMucnVuQ291bnRcblxuXHRsZXQgcHJvY2Vzc2luZyA9IHVwZGF0ZXMucHJvY2Vzc2luZ1xuXHR1cGRhdGVzLnByb2Nlc3NpbmcgPSB0cnVlXG5cdGxldCBhY3Rpb24gPSBjby5nbG9iYWxbIGFjdGlvbktleSBdXG5cdGlmICggYWN0aW9uICE9IG51bGwgKVxuXHRcdGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBudWxsXG5cdHRyeSB7XG5cdFx0d2hpbGUgKCB1cGRhdGVzLmluZGV4IDwgdXBkYXRlcy5wcm9jcy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGdsb2JhbC5BUFBfVElNRU9VVCAmJiBnbG9iYWwuQVBQX1RJTUVPVVQgPCBEYXRlLm5vdyApIHtcblx0XHRcdFx0YWxlcnQoIGBBcHBsaWNhdGlvbiBpcyBydW5uaW5nIHRvbyBsb25nYCApXG5cdFx0XHR9XG5cdFx0XHRsZXQgcHJvYyA9IHVwZGF0ZXMucHJvY3NbIHVwZGF0ZXMuaW5kZXggXVxuXHRcdFx0Kyt1cGRhdGVzLmluZGV4XG5cdFx0XHQrK3VwZGF0ZXMucnVuQ291bnRcblx0XHRcdGlmICggdXBkYXRlcy5pbmRleCA+PSB1cGRhdGVzLm1heEluZGV4ICYmIHVwZGF0ZXMuaW5kZXggKiAzID4gdXBkYXRlcy5wcm9jcy5sZW5ndGggKSB7XG5cdFx0XHRcdHVwZGF0ZXMucHJvY3Muc3BsaWNlKCAwLCB1cGRhdGVzLmluZGV4IClcblx0XHRcdFx0dXBkYXRlcy5pbmRleCA9IDBcblx0XHRcdH1cblx0XHRcdHByb2MoKVxuXHRcdFx0bGV0IHQxID0gcGVyZm9ybWFuY2Uubm93KClcblx0XHRcdGlmICggdXBkYXRlcy5tYXhUaW1lMSA8IHQxIC0gc3QxIClcblx0XHRcdFx0dXBkYXRlcy5tYXhUaW1lMSA9IHQxIC0gc3QxXG5cdFx0XHQvLyBpZiAoIHQxIC0gc3QxID4gMTAgKVxuXHRcdFx0Ly8gXHRjb25zb2xlLmxvZyggdDEgLSBzdDEsIGBgICsgcHJvYy4kbmFtZSApIC8vIGRlYnVnZ2VyXG5cdFx0XHRzdDEgPSB0MVxuXHRcdH1cblx0XHR1cGRhdGVzLmluZGV4ID0gdXBkYXRlcy5wcm9jcy5sZW5ndGggPSAwXG5cdH1cblx0ZmluYWxseSB7XG5cdFx0aWYgKCBhY3Rpb24gIT0gbnVsbCApXG5cdFx0XHRjby5nbG9iYWxbIGFjdGlvbktleSBdID0gYWN0aW9uXG5cdFx0dXBkYXRlcy5wcm9jZXNzaW5nID0gcHJvY2Vzc2luZ1xuXHRcdGlmICggIXByb2Nlc3NpbmcgKSB7XG5cdFx0XHRsZXQgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRcblx0XHRcdHVwZGF0ZXMudG90YWxUaW1lICs9IHRpbWVcblx0XHRcdGlmICggdXBkYXRlcy5tYXhUaW1lIDwgdGltZSApXG5cdFx0XHRcdHVwZGF0ZXMubWF4VGltZSA9IHRpbWVcblx0XHRcdHJ1bkNvdW50ID0gdXBkYXRlcy5ydW5Db3VudCAtIHJ1bkNvdW50XG5cdFx0XHRpZiAoIHJ1bkNvdW50ICApIHtcblx0XHRcdFx0Kyt1cGRhdGVzLnJ1bkFsbENvdW50XG5cdFx0XHRcdGlmICggdXBkYXRlcy5taW5UaW1lID4gdGltZSApXG5cdFx0XHRcdFx0dXBkYXRlcy5taW5UaW1lID0gdGltZVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aW1lID4gMzAwIClcblx0XHRcdFx0TE9HKCBgdXBkYXRlcyBoYXZlIGJlZW4gcnVuIGZvciAkeyB0aW1lLnRvU3RyaW5nKCkucmVkIH0gbXNgIClcblx0XHR9XG5cdH1cbn1cblxudXBkYXRlcy5sYXRlciA9IHByb2MgPT4ge1xuXHR1cGRhdGVzLnByb2NzLnB1c2goIHByb2MgKVxuXHR1cGRhdGVzLmNoZWNrU2NoZWR1bGUoKVxufVxuXG51cGRhdGVzLmxhdGVyLnRoZW4gPSB1cGRhdGVzLmxhdGVyXG5cbmxldCBjaGVja051bGwgPSB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHZhbHVlXG5sZXQgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMgfVxuXG5sZXQgaXNMaXRlcmFsID0gdmFsdWUgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IGBvYmplY3RgICYmIHZhbHVlLmNvbnN0cnVjdG9yID09IE9iamVjdFxubGV0IGdldFZhbHVlID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZS52YWx1ZU9mID09IG51bGwgPyB2YWx1ZSA6IHZhbHVlLnZhbHVlT2YoKVxuXG5mdW5jdGlvbiBBYnN0cmFjdEd1YXJkKCkge31cblxubGV0IGludmFsaWRLZXlDYWxsID0gZnVuY3Rpb24gKCBrZXkgKSB7XG5cdHRocm93IG5ldyBFcnJvciggYGFjY2VzcyB0byBhbiB1bmRlY2xhcmVkIHByb3BlcnR5IFwiJHsgdGhpcy4kbmFtZSB9LiR7IGtleSB9XCJgIClcbn1cblxubGV0IHVzZWRQcm9wcyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxubGV0IHVzZWRQcm9wc1Byb3RvID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5sZXQgZ3VhcmRQcm9wID0ga2V5ID0+IHtcblx0aWYgKCAhdXNlZFByb3BzWyBrZXkgXSApIHtcblx0XHR1c2VkUHJvcHNbIGtleSBdID0gdHJ1ZVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdXNlZFByb3BzUHJvdG8sIGtleSwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHsgaW52YWxpZEtleUNhbGwuY2FsbCggdGhpcywga2V5ICkgfSxcblx0XHR9IClcblx0fVxufVxuQWJzdHJhY3RHdWFyZC5wcm90b3R5cGUgPSB1c2VkUHJvcHNQcm90b1xuXG4vLyDQndC1INC30YDQsNC30YPQvNC10LvQsCDRgtC+0LvQutCw0LwsINGP0Log0LPRjdGC0YsgUHJveHkg0L/RgNCw0YbRg9C1INGeINGP0LrQsNGB0YzRhtGWINC/0YDQsNGC0LDRgtGL0L/Rgy5cbi8vINCf0LDQutGD0LvRjCDRiNGC0L4sINC30LTQsNC10YbRhtCwLCDQv9Cw0LLQvtC00LfRltC90Ysg0L3QtSDQsNC00L/QsNCy0Y/QtNCw0Y7RhtGMINGB0YzQv9C10YbRi9GE0ZbQutCw0YbRi9GWICgyMDE0LjExLjI1KVxuXG4vLyBpZiAoIHR5cGVvZiBQcm94eSA9PSBcImZ1bmN0aW9uXCIgKSB7XG4vLyBcdEFic3RyYWN0R3VhcmQucHJvdG90eXBlID0gbmV3IFByb3h5KCBBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSwge1xuLy8gXHRcdGdldDogZnVuY3Rpb24gKCBfLCBrZXkgKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG4vLyBcdFx0c2V0OiBmdW5jdGlvbiAoIF8sIGtleSApIHsgaW52YWxpZEtleUNhbGwuY2FsbCggdGhpcywga2V5ICkgfSxcbi8vIFx0fSApXG4vLyB9XG5cbmlmICggZ2xvYmFsLkFQUF9ERUJVRyApIHtcblx0Ly9cblx0Ly8g0LDQsSfRj9Ge0LvQtdC90YzQvdC1INCw0LEn0LXQutGC0LAg0LcgfjcwMC04MDAg0YPQu9Cw0YHRjNGG0ZbQstCw0YHRjNGG0Y/RniDQtyDRhNGD0L3QutGG0YvRj9C80ZYg0YfRi9GC0LDQvdGM0L3Rjy/Qt9Cw0L/RltGB0YNcblx0Ly8g0LfQsNC50LzQsNC1INGeIEdvb2dsZSBDaHJvbWUn0LUg0LrQsNC70Y8g0YLRgNCw0YbRltC90Ysg0YHQtdC60YPQvdC00YsuXG5cdC8vINCf0YDQsNCy0LXRgNCw0L3Ri9GPINGB0L/QvtGB0LDQsdGLOlxuXHQvLyAtINC00LDQsdCw0Z7Qu9C10L3RjNC90LUg0L/QsCDQsNC00L3Ri9C8INC/0YDQsNC3IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuXHQvLyAtINC00LDQsdCw0Z7Qu9C10L3RjNC90LUg0LPRg9GA0YLQsNC8INC/0YDQsNC3IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG5cdC8vIC0g0LrQsNC80L/RltC70Y/RhtGL0Y8g0LfRi9GF0L7QtNC90ZbQutCwINC/0YDQsNC3INC70LDQutCw0LvRjNC90YsgZXZhbFxuXHQvLyAtINC60LDQvNC/0ZbQu9GP0YbRi9GPINC30YvRhdC+0LTQvdGW0LrQsCDQv9GA0LDQtyDQs9C70LDQsdCw0LvRjNC90YsgZXZhbFxuXHQvLyAtINC60LDQvNC/0ZbQu9GP0YbRi9GPINC30YvRhdC+0LTQvdGW0LrQsCDQv9GA0LDQtyDQtNCw0LHQsNGe0LvQtdC90YzQvdC1INGC0Y3Qs9GDIHNjcmlwdCDQtyDQt9GL0YXQvtC00L3RltC60LDQvFxuXHQvLyDQndC1INC/0YDQsNCy0LXRgNCw0L3Ri9GPINGB0L/QvtGB0LDQsdGLOlxuXHQvLyAtINC00LDQsdCw0Z7Qu9C10L3RjNC90LUg0YLRjdCz0YMgc2NyaXB0INC3INC/0LDQt9C90LDQutCw0Lkgc3JjXG5cdC8vINCf0LDQu9GP0L/RiNCw0LUg0YHRltGC0YPQsNGG0YvRjiAo0L3QsNC/0LDQu9C+0LLRgyk6XG5cdC8vIC0g0YHRgtCy0LDRgNGN0L3RjNC90LUg0LTQu9GPINC60L7QttC90LDQuSDRg9C70LDRgdGM0YbRltCy0LDRgdGM0YbRliDQvdC+0LLQsNCz0LAg0LDQsSfQtdC60YLQsCDRgdCwINGB0YLQsNGA0YvQvCDQsNCxJ9C10LrRgtCw0Lxcblx0Ly8g0YMg0Y/QutCw0YHRjNGG0ZYg0L/RgNCw0YLQsNGC0YvQv9GDLiDQn9GA0Ysg0LPRjdGC0YvQvCDQtNC+0YHRgtGD0L8g0LTQsCDQvdC10LDQsSfRj9Ge0LvQtdC90YvRhSDRg9C70LDRgdGM0YbRltCy0LDRgdGM0YbRj9GeINC80L7QttCwXG5cdC8vINGB0YLQsNGG0Ywg0LDQtNC90L7RgdC90LAg0LTQvtGe0LPRltC8INC/0LAg0YfQsNGB0LUsINCw0LvQtSDQtiDQs9GN0YLQsCDQvdGPINGC0LDQuiDQstCw0LbQvdCwLCDQsdC+INGeINCy0YvQvdGW0LrRgyDRntGB0ZEg0LDQtNC90L5cblx0Ly8g0LrRltC00LDQtdGG0YbQsCDQv9Cw0LzRi9C70LrQsC5cblx0Ly9cblx0Ly8g0JPQtdC90LXRgNCw0YbRi9GPINGC0Y3QutGB0YLRgyDQt9GL0YXQvtC00L3RltC60LAg0LDQtNCx0YvQstCw0LXRhtGG0LAg0ZbQvNCz0L3QtdC90L3QsC5cblx0Ly9cblx0Ly8g0JfRi9GF0L7QtNC30Y/Rh9GLINC3INCz0Y3RgtCw0LPQsCDRg9C70YPRh9Cw0YbRjCDRgdGC0YDQsNC20L3RltC60LDRniDQtNC+0YHRgtGD0L/RgyDQtNCwINC90LXQsNCxJ9GP0Z7Qu9C10L3Ri9GFINGD0LvQsNGB0YzRhtGW0LLQsNGB0YzRhtGP0Z5cblx0Ly8g0YLRgNGN0LHQsCDRgtC+0LvRjNC60ZYg0L/RgNGLINCw0LTQu9Cw0LTRhtGLLlxuXHQvL1xuXHRBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSA9XG5cdFx0KCBnbG9iYWwuX19Vc2VkU2NyaXB0SWRlbnRpZmllcnNfXyArIGBgIClcblx0XHQuc3BsaXQoIC9bXFxzLF0rLyApXG5cdFx0LnJlZHVjZSggKCBwcm90bywga2V5ICkgPT5cblx0XHRcdE9iamVjdC5jcmVhdGUoIHByb3RvLCB7IFsga2V5IF06IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gKCBfICkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuXHRcdFx0fSB9ICksXG5cdFx0XHRBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSApXG59XG5cbkFic3RyYWN0R3VhcmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQWJzdHJhY3RHdWFyZC5wcm90b3R5cGUsIHtcblx0dG9TdHJpbmc6IHsgdmFsdWU6IHt9LnRvU3RyaW5nIH0sXG5cdHZhbHVlT2Y6IHsgdmFsdWU6IHt9LnZhbHVlT2YgfSxcblx0dG9Mb2NhbGVTdHJpbmc6IHsgdmFsdWU6IHt9LnRvTG9jYWxlU3RyaW5nIH0sXG5cdGhhc093blByb3BlcnR5OiB7IHZhbHVlOiB7fS5oYXNPd25Qcm9wZXJ0eSB9LFxuXHRpc1Byb3RvdHlwZU9mOiB7IHZhbHVlOiB7fS5pc1Byb3RvdHlwZU9mIH0sXG5cdHByb3BlcnR5SXNFbnVtZXJhYmxlOiB7IHZhbHVlOiB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSB9LFxuXHQkbmFtZTogeyB2YWx1ZTogYDwuLi4+YCwgd3JpdGFibGU6IDEgfSxcbn0gKVxuXG5sZXQgRU1QVFlfQVJSQVkgPSBbXVxuT2JqZWN0LmZyZWV6ZSggRU1QVFlfQVJSQVkgKVxuXG5jbGFzcyBJbW11dGFibGVJbnRlcmZhY2UgZXh0ZW5kcyBBYnN0cmFjdEd1YXJkIHtcblxuXHQvLyBkZWJ1Z2dlclxuXHRnZXQgcHJvcHMoKSB7IHRocm93IG5ldyBFcnJvciggYGFjY2VzcyB0byBkZXByZWNhdGVkICdwcm9wcycgcHJvcGVydHkgZGV0ZWN0ZWRgICkgfVxuXG5cdGdldCBkZWNsYXJlZFByb3BlcnRpZXMoKSB7IHJldHVybiB0aGlzLmxpdmUgfVxuXG5cdGdldCBsZW5ndGgoKSB7IGxldCBtID0gdGhpcy52YWx1ZU9mKCk7IHJldHVybiBtID09IG51bGwgPyAwIDogT2JqZWN0LmtleXMoIG0gKS5sZW5ndGggfVxuXG5cdGdldCgga2V5ICkge1xuXHRcdGlmICgga2V5ICE9IG51bGwgKSB7XG5cdFx0XHRsZXQgbSA9IHRoaXMudmFsdWVPZigpXG5cdFx0XHRpZiAoIG0gIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIG0sIGtleSApIClcblx0XHRcdFx0cmV0dXJuIG1bIGtleSBdXG5cdFx0fVxuXHRcdHJldHVybiBudWxsXG5cdH1cblxuXHRtYXAoIGZ1biApIHtcblx0XHRsZXQgbSA9IHRoaXMudmFsdWVPZigpXG5cdFx0cmV0dXJuIG0gJiYgKCBBcnJheS5pc0FycmF5KCBtICkgPyBsb2Rhc2gubWFwKCBtLCBmdW4gKSA6IGxvZGFzaC5tYXBWYWx1ZXMoIG0sIGZ1biApIClcblx0fVxuXG5cdGtleXMoKSB7XG5cdFx0bGV0IG0gPSB0aGlzLnZhbHVlT2YoKVxuXHRcdHJldHVybiBtID09IG51bGwgPyBFTVBUWV9BUlJBWSA6IE9iamVjdC5rZXlzKCBtIClcblx0fVxufVxuXG5jbGFzcyBSZWFkT25seUNlbGwgZXh0ZW5kcyBJbW11dGFibGVJbnRlcmZhY2Uge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJlbnQgKSB7XG5cdFx0c3VwZXIoKVxuXHRcdHRoaXMuX3BhcmVudCA9IHBhcmVudFxuXHR9XG5cblx0Z2V0UmVhZE9ubHkoKSB7IHJldHVybiB0aGlzIH1cblx0Z2V0IGxpdmUoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQubGl2ZSB9XG5cdGdldCAkbmFtZSgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC4kbmFtZSB9XG5cblx0dmFsdWVPZigpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC52YWx1ZU9mLmFwcGx5KCB0aGlzLl9wYXJlbnQsIGFyZ3VtZW50cyApIH1cblx0bm9Ub3VjaCgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5ub1RvdWNoLmFwcGx5KCB0aGlzLl9wYXJlbnQsIGFyZ3VtZW50cyApIH1cblx0dG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQudG9TdHJpbmcuYXBwbHkoIHRoaXMuX3BhcmVudCwgYXJndW1lbnRzICkgfVxuXHR0b0pTT04oKSB7IHJldHVybiB0aGlzLl9wYXJlbnQudG9KU09OLmFwcGx5KCB0aGlzLl9wYXJlbnQsIGFyZ3VtZW50cyApIH1cblx0Z2V0TmFtZSgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5nZXROYW1lLmFwcGx5KCB0aGlzLl9wYXJlbnQsIGFyZ3VtZW50cyApIH1cblxufVxuXG5sZXQgR2V0dGVyID0gKCBmdW4sIGlzVmFsdWVFcXVhbCApID0+IHtcblx0bGV0IGxhc3Rcblx0bGV0IHJldCA9ICFpc1ZhbHVlRXF1YWwgP1xuXHRcdGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgfVxuXHQ6XG5cdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0bGV0IHJldCA9IGZ1bi5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRcdGlmICggIWlzKCBsYXN0LCByZXQsIGlzVmFsdWVFcXVhbCApIClcblx0XHRcdFx0bGFzdCA9IHJldFxuXHRcdFx0cmV0dXJuIGxhc3Rcblx0XHR9XG5cdHJldC5pc0dldHRlciA9IHRydWVcblx0cmV0dXJuIHJldFxufVxuXG5sZXQgVHlwZSA9ICggZiApID0+IHtcblx0Zy50eXBlRGVzY3JpcHRvciA9IHRydWVcblx0cmV0dXJuIGdcblx0ZnVuY3Rpb24gZygpIHsgcmV0dXJuIGYuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIH1cbn1cblxubGV0IHJ1bkdldHRlciA9ICggY2VsbCwgZ2V0dGVyLCBzdGlja3kgKSA9PiAoIG5ldyBBY3Rpb24oIGdldHRlciwgY2VsbCwgc3RpY2t5ICkgKS5saW5rTmFtZSggY2VsbCwgYDpnZXR0ZXJgIClcblxubGV0IHJ1blNldHRlciA9ICggY2VsbCwgc2V0dGVyLCBzdGlja3kgKSA9PiAoIG5ldyBBY3Rpb24oICgpID0+IHNldHRlciggY2VsbC52YWx1ZU9mKCkgKSwgbnVsbCwgc3RpY2t5ICkgKS5saW5rTmFtZSggY2VsbCwgYDpzZXR0ZXJgIClcblxuZnVuY3Rpb24gaXMoIGEsIGIsIGlzRXF1YWwgKSB7XG5cdHJldHVybiBPYmplY3QuaXMoIGEsIGIgKSB8fCBiICYmIHR5cGVvZiBiLmlzRXF1YWxUbyA9PSBgZnVuY3Rpb25gICYmIGIuaXNFcXVhbFRvKCBhICkgfHwgYSAmJiB0eXBlb2YgYS5pc0VxdWFsVG8gPT0gYGZ1bmN0aW9uYCAmJiBhLmlzRXF1YWxUbyggYiApIHx8IHR5cGVvZiBpc0VxdWFsID09IGBmdW5jdGlvbmAgJiYgaXNFcXVhbCggYSwgYiApXG59XG5cbmNsYXNzIFRoaXMge1xuXHRzdGF0aWMgY3JlYXRlKCBwYXJlbnQsIHRoYXQgKSB7XG5cdFx0bGV0IHJldCA9IG51bGxcblx0XHRpZiAoICFwYXJlbnQgKVxuXHRcdFx0cmV0ID0gbmV3IFRoaXNcblx0XHRlbHNlXG5cdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBwYXJlbnQgKVxuXHRcdHJldC52YWx1ZU9mID0gKCkgPT4gdGhhdC52YWx1ZU9mKClcblx0XHRyZXQudG9TdHJpbmcgPSAoKSA9PiB0aGF0LnRvU3RyaW5nKClcblx0XHRyZXQudG9KU09OID0gKCkgPT4gdGhhdC50b0pTT04oKVxuXHRcdHJldC5hc3NpZ24gPSB2YWx1ZSA9PiB0aGF0LmFzc2lnbiggdmFsdWUgKVxuXHRcdHJldC50aHJvdyA9IHZhbHVlID0+IHRoYXQudGhyb3coIHZhbHVlIClcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHJldCwgYGxpdmVgLCB7IGdldDogKCkgPT4gdGhhdC5saXZlIH0gKVxuXHRcdHJldHVybiByZXRcblx0fVxuXHRfZGVmaW5lVGhhdFByb3BlcnR5KCBrZXksIHRoYXQgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBrZXksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQoKSB7IHJldHVybiB0aGF0WyBrZXkgXSB9LFxuXHRcdFx0c2V0KCB2YWx1ZSApIHsgdGhhdFsga2V5IF0gPSB2YWx1ZSB9LFxuXHRcdH0gKVxuXHR9XG59XG5cbmNsYXNzIENlbGwgZXh0ZW5kcyBJbW11dGFibGVJbnRlcmZhY2Uge1xuXG5cdGNvbnN0cnVjdG9yKCBzdGlja3kgKSB7XG5cdFx0c3VwZXIoKVxuXHRcdHRoaXMuX2lkID0gVUlEKClcblx0XHR0aGlzLl90aGF0ID0gbnVsbFxuXHRcdHRoaXMuX3ZhbHVlID0gbnVsbFxuXHRcdHRoaXMuX2Vycm9yID0gbnVsbFxuXHRcdHRoaXMuX2lzVmFsdWVFcXVhbCA9IGlzXG5cdFx0dGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZVxuXHRcdHRoaXMuX2Zyb3plbiA9IGZhbHNlXG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2Vcblx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlXG5cdFx0dGhpcy5fbGl2ZSA9IG51bGxcblx0XHR0aGlzLl9saXZlQXJyYXkgPSBudWxsXG5cdFx0dGhpcy5fYWN0aW9uc0FyciA9IFtdXG5cdFx0dGhpcy5fcGFyZW50ID0gbnVsbFxuXHRcdHRoaXMuX29uY2hhbmdlID0gW11cblx0XHR0aGlzLiRuYW1lID0geyB0b1N0cmluZzogKCkgPT4gdGhpcy5nZXROYW1lKCkgfVxuXHRcdHRoaXMuX25vdGlmeVdyaXR0ZW4oKVxuXHRcdHRoaXMuX3N0aWNreSA9ICEhc3RpY2t5XG5cdH1cblxuXHR2YWx1ZU9mKCkgeyByZXR1cm4gdGhpcy5fcmVhZCgpIH1cblx0YXNzaWduKCB2YWx1ZSApIHsgcmV0dXJuIHRoaXMuX3dyaXRlKCB2YWx1ZSwgZmFsc2UsIG51bGwgKSB9XG5cdHVwZGF0ZSggZGlmZiApIHsgcmV0dXJuIHRoaXMuYXNzaWduKCBsdS5hcHBseURpZmYoIHRoaXMubm9Ub3VjaCgpLCBkaWZmICkgKSB9XG5cdHRocm93KCB2YWx1ZSApIHsgcmV0dXJuIHRoaXMuX3dyaXRlKCBudWxsLCBmYWxzZSwgdmFsdWUgKSB9XG5cdHRvdWNoKCkgeyB0aGlzLl9maXJlKCkgfVxuXG5cdG5vVG91Y2goKSB7XG5cdFx0aWYgKCB0aGlzLl9kaXJ0eSApXG5cdFx0XHR0aGlzLl91cGRhdGVTZWxmKClcblx0XHRpZiAoIHRoaXMuX2Vycm9yIClcblx0XHRcdHRocm93IHRoaXMuX2Vycm9yXG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlXG5cdH1cblxuXHR0aGVuKCBwcm9jICkge1xuXHRcdHRoaXMuX29uY2hhbmdlLnB1c2goIHByb2MgKVxuXHR9XG5cblx0Y2xvc2UoKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0cmV0dXJuXG5cdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZVxuXHRcdHRoaXMuX2ZpcmUoKVxuXHRcdGlmICggdGhpcy5fcGFyZW50IClcblx0XHRcdHRoaXMuX3BhcmVudC5jbG9zZSgpXG5cdFx0aWYgKCB0aGlzLl9saXZlQXJyYXkgKSB7XG5cdFx0XHRmb3IgKCBsZXQgcCBvZiB0aGlzLl9saXZlQXJyYXkgKVxuXHRcdFx0XHRwLmNsb3NlKClcblx0XHRcdHRoaXMuX2xpdmVBcnJheSA9IG51bGxcblx0XHR9XG5cdFx0dGhpcy5fdmFsdWUgPSBudWxsXG5cdFx0dGhpcy5fZXJyb3IgPSBudWxsXG5cdFx0dGhpcy5fYWN0aW9uc0FyciA9IG51bGxcblx0XHR0aGlzLl9wYXJlbnQgPSBudWxsXG5cdH1cblxuXHRmcmVlemUoKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgfHwgdGhpcy5fZnJvemVuIClcblx0XHRcdHJldHVyblxuXHRcdHRoaXMuX2Zyb3plbiA9IHRydWVcblx0XHR0aGlzLl9maXJlKCkgLy8gVE9ETyDQtNC70Y8g0LLRi9C00LDQu9C10L3RjNC90Y8g0YHQv9Cw0YHRi9C70LDQuiDQsNCx0YvRgdGM0YbRltGB0Y8g0LHQtdC3IF9maXJlINGWINCw0LTQv9Cw0LLQtdC00L3QsCDQsdC10Lcg0LvRltGI0L3Rj9Cz0LAg0L/RgNCw0LPQvtC90YNcblx0XHRpZiAoIHRoaXMuX3BhcmVudCApXG5cdFx0XHR0aGlzLl9wYXJlbnQuZnJlZXplKClcblx0XHRpZiAoIHRoaXMuX2xpdmVBcnJheSApIHtcblx0XHRcdGZvciAoIGxldCBwIG9mIHRoaXMuX2xpdmVBcnJheSApXG5cdFx0XHRcdHAuZnJlZXplKClcblx0XHR9XG5cdH1cblxuXHRnZXQgbGl2ZSgpIHsgcmV0dXJuIHRoaXMuX2xpdmUgfVxuXG5cdGdldFJlYWRPbmx5KCkge1xuXHRcdHJldHVybiB0aGlzLl9yZWFkT25seSB8fCAoIHRoaXMuX3JlYWRPbmx5ID0gbmV3IFJlYWRPbmx5Q2VsbCggdGhpcyApIClcblx0fVxuXG5cdHRvU3RyaW5nKCAuLi5hcmdzICkge1xuXHRcdGxldCB2ID0gdGhpcy5fcmVhZCgpXG5cdFx0cmV0dXJuICggdiA9PSBudWxsICkgfHwgIXYudG9TdHJpbmcgPyBgYCArIHYgOiB2LnRvU3RyaW5nKCAuLi5hcmdzIClcblx0fVxuXG5cdHRvSlNPTiggLi4uYXJncyApIHtcblx0XHRsZXQgdiA9IHRoaXMuX3JlYWQoKVxuXHRcdHJldHVybiAoIHYgPT0gbnVsbCApIHx8ICF2LnRvSlNPTiA/IHYgOiB2LnRvSlNPTiggLi4uYXJncyApXG5cdH1cblxuXHR3aXRoKCBjYiApIHsgcmV0dXJuIGNiLmNhbGwoIHRoaXMuX2dldFRoYXQoKSApIH1cblxuXHRzZXROYW1lKCBuYW1lICkge1xuXHRcdHRoaXMuX25hbWUgPSBuYW1lXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGdldE5hbWUoKSB7XG5cdFx0bGV0IHJldCA9IHRoaXMuX25hbWUgfHwgdGhpcy5fa2V5XG5cdFx0bGV0IHAgPSB0aGlzLl9wYXJlbnRcblx0XHR3aGlsZSAoIHAgKSB7XG5cdFx0XHRyZXQgPSAoIHAuX25hbWUgfHwgcC5fa2V5ICkgKyBgLmAgKyByZXRcblx0XHRcdHAgPSBwLl9wYXJlbnRcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cblx0X2dldFRoYXQoKSB7XG5cdFx0aWYgKCAhdGhpcy5fdGhhdCApIHtcblx0XHRcdHRoaXMuX3RoYXQgPSBUaGlzLmNyZWF0ZSggdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fZ2V0VGhhdCgpLCB0aGlzIClcblx0XHRcdGlmICggdGhpcy5fbGl2ZSApXG5cdFx0XHRcdGZvciAoIGxldCBpIGluIHRoaXMuX2xpdmUgKVxuXHRcdFx0XHRcdHRoaXMuX3RoYXQuX2RlZmluZVRoYXRQcm9wZXJ0eSggaSwgdGhpcyApXG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl90aGF0XG5cdH1cblxuXHRkZWZpbmVQcm9wZXJ0eSgga2V5ICkge1xuXHRcdC8vIHBhc3Mga2V5ID09IGBgIHRvIG1ha2UgQ2VsbCBvYmplY3QsIG5vdCB2YWx1ZVxuXHRcdGlmICggIXRoaXMuX2xpdmUgKSB7XG5cdFx0XHR0aGlzLl9saXZlID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHR0aGlzLl9saXZlQXJyYXkgPSBbXVxuXHRcdH1cblx0XHRpZiAoICFrZXkgKVxuXHRcdFx0cmV0dXJuXG5cdFx0Z3VhcmRQcm9wKCBrZXkgKVxuXHRcdGxldCBjID0gdGhpcy5fbGl2ZVsga2V5IF1cblx0XHRpZiAoIGMgKVxuXHRcdFx0cmV0dXJuIGNcblx0XHRjID0gbmV3IENlbGwoIHRoaXMuX3N0aWNreSApXG5cdFx0dGhpcy5fbGl2ZVsga2V5IF0gPSBjXG5cdFx0dGhpcy5fbGl2ZUFycmF5LnB1c2goIGMgKVxuXHRcdGMuX2tleSA9IGtleVxuXHRcdGMuX3BhcmVudCA9IHRoaXNcblx0XHRjLl9sZXZlbCA9ICggdGhpcy5fbGV2ZWwgfHwgMCApICsgMVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywga2V5LCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmICggYy5fbGl2ZSApXG5cdFx0XHRcdFx0cmV0dXJuIGNcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldHVybiBjLl9yZWFkKClcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHZhbHVlID0+IHtcblx0XHRcdFx0aWYgKCBjLl9saXZlIClcblx0XHRcdFx0XHR2YWx1ZSA9IGdldFZhbHVlKCB2YWx1ZSApXG5cdFx0XHRcdGMuX3dyaXRlKCB2YWx1ZSwgZmFsc2UgKVxuXHRcdFx0fSxcblx0XHR9IClcblx0XHRpZiAoIHRoaXMuX3RoYXQgKVxuXHRcdFx0dGhpcy5fdGhhdC5fZGVmaW5lVGhhdFByb3BlcnR5KCBrZXksIHRoaXMgKVxuXHRcdGlmICggdGhpcy5fdmFsdWUgIT0gbnVsbCApXG5cdFx0XHRjLl93cml0ZSggdGhpcy5fdmFsdWVbIGtleSBdLCB0cnVlIClcblx0XHRyZXR1cm4gY1xuXHR9XG5cblx0aW5pdCggdmFsdWUgKSB7XG5cdFx0dGhpcy5faW5pdCggdmFsdWUsIGZhbHNlLCBmYWxzZSApXG5cdH1cblxuXHRzZXRDb25zdCggcHJvcCwgdmFsdWUgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBwcm9wLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogKCkgPT4gdmFsdWUgfSApXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdHNldFZhciggcHJvcCwgdmFsdWUgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBwcm9wLCB7IGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9IClcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0Z2V0IFsgcmFWYWx1ZSBdKCkgeyByZXR1cm4gdHJ1ZSB9XG5cblx0X2luaXQoIHZhbHVlLCByZWN1cnNpdmUsIGlzR2V0dGVyLCBpc1ZhbHVlRXF1YWwgKSB7XG5cdFx0bGV0IGNlbGwgPSB0aGlzXG5cdFx0aWYgKCAhcmVjdXJzaXZlICYmIGNlbGwuX2luaXRpYWxpemVkIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYGFscmVhZHkgaW5pdGlhbGl6ZWRgIClcblx0XHRpZiAoIHRoaXMuX3BhcmVudCApXG5cdFx0XHR0aGlzLl9wYXJlbnQuX2RpcnR5ID0gdHJ1ZVxuXHRcdGNlbGwuX2luaXRpYWxpemVkID0gdHJ1ZVxuXHRcdGlmICggaXNWYWx1ZUVxdWFsIClcblx0XHRcdHRoaXMuX2lzVmFsdWVFcXVhbCA9IGlzVmFsdWVFcXVhbFxuXHRcdHZhbHVlID0gY2hlY2tOdWxsKCB2YWx1ZSApXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYGZ1bmN0aW9uYCAmJiB2YWx1ZS50eXBlRGVzY3JpcHRvciApXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKCBjZWxsLl9rZXkgKVxuXHRcdGlmICggdmFsdWUgPT0gbnVsbCApIC8vIHdlIGFyZSBhbHJlYWR5IG51bGwgYXQgdGhlIHBvaW50IG9mIGJpcnRoXG5cdFx0XHRyZXR1cm5cblx0XHRpZiAoIHZhbHVlWyByYVZhbHVlIF0gKSAvLyBmb3JjZSBqdXN0IGEgdmFsdWVcblx0XHRcdHJldHVybiBjZWxsLl92YWx1ZSA9IHZhbHVlXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYGZ1bmN0aW9uYCApIHtcblx0XHRcdGlmICggaXNHZXR0ZXIgfHwgdmFsdWUuaXNHZXR0ZXIgKSAvLyBnZXR0ZXJcblx0XHRcdFx0cnVuR2V0dGVyKCBjZWxsLCAoKSA9PiB2YWx1ZS5jYWxsKCBjZWxsLl9wYXJlbnQgJiYgY2VsbC5fcGFyZW50Ll9nZXRUaGF0KCkgKSwgdGhpcy5fc3RpY2t5IClcblx0XHRcdGVsc2UgLy8gbWV0aG9kXG5cdFx0XHRcdGNlbGwuX3ZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuYXBwbHkoIGNlbGwuX3BhcmVudCAmJiBjZWxsLl9wYXJlbnQuX2dldFRoYXQoKSwgYXJndW1lbnRzICkgfVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGlmICggIWlzTGl0ZXJhbCggdmFsdWUgKSApIC8vIGp1c3QgYSB2YWx1ZVxuXHRcdFx0cmV0dXJuIGNlbGwuX3ZhbHVlID0gdmFsdWVcblx0XHQvLyBzdWJyZWNvcmQgZGVzY3JpcHRpb25cblx0XHRpZiAoIHJlY3Vyc2l2ZSApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGB3cm9uZyBwYXJhbWV0ZXJzYCApXG5cdFx0Y2VsbC5kZWZpbmVQcm9wZXJ0eSgpXG5cdFx0Zm9yICggbGV0IGtleSBpbiB2YWx1ZSApIHtcblx0XHRcdGxldCBkZXNjciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHZhbHVlLCBrZXkgKVxuXHRcdFx0aWYgKCAhZGVzY3IgKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0bGV0IGdldCA9IGRlc2NyLmdldFxuXHRcdFx0bGV0IHN1YlZhbHVlID0gZGVzY3IudmFsdWVcblx0XHRcdGlmICggZGVzY3Iuc2V0IClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgd3JvbmcgcGFyYW1ldGVyc2AgKVxuXHRcdFx0ZWxzZSBpZiAoIGdldCApXG5cdFx0XHRcdHN1YlZhbHVlID0gZ2V0XG5cdFx0XHRpZiAoIGtleSA9PSBgJGAgKVxuXHRcdFx0XHRjZWxsLl9pbml0KCBzdWJWYWx1ZSwgdHJ1ZSwgISFnZXQgKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjZWxsLmRlZmluZVByb3BlcnR5KCBrZXksIHRydWUgKS5faW5pdCggc3ViVmFsdWUsIGZhbHNlLCAhIWdldCApXG5cdFx0fVxuXHR9XG5cblx0X3JlYWQoKSB7XG5cdFx0aWYgKCB0aGlzLl9kaXJ0eSApXG5cdFx0XHR0aGlzLl91cGRhdGVTZWxmKClcblx0XHRsZXQgYWN0aW9uID0gY28uZ2xvYmFsWyBhY3Rpb25LZXkgXVxuXHRcdGlmICggYWN0aW9uICkge1xuXHRcdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0XHRhY3Rpb24uY2xvc2UoKVxuXHRcdFx0ZWxzZSBpZiAoICF0aGlzLl9mcm96ZW4gKVxuXHRcdFx0XHRhY3Rpb24ub25yZWFkKCB0aGlzIClcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9lcnJvciApXG5cdFx0XHR0aHJvdyB0aGlzLl9lcnJvclxuXHRcdHJldHVybiB0aGlzLl92YWx1ZVxuXHR9XG5cblx0X3dyaXRlKCBuZXdWYWx1ZSwgZG93biwgbmV3RXJyb3IgKSB7XG5cdFx0aWYgKCBuZXdFcnJvciA9PSBudWxsIClcblx0XHRcdG5ld0Vycm9yID0gbnVsbFxuXHRcdGlmICggdGhpcy5fZnJvemVuIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJUcnkgdG8gY2hhbmdlIGEgZnJvemVuIHZhbHVlXCIgKVxuXHRcdHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZVxuXHRcdHRoaXMuX2RpcnR5ID0gZmFsc2Vcblx0XHRuZXdWYWx1ZSA9IGNoZWNrTnVsbCggbmV3VmFsdWUgKVxuXHRcdGlmICggdGhpcy5fY2xvc2VkICkge1xuXHRcdFx0bGV0IGFjdGlvbiA9IGNvLmdsb2JhbFsgYWN0aW9uS2V5IF1cblx0XHRcdGlmICggYWN0aW9uIClcblx0XHRcdFx0YWN0aW9uLmNsb3NlKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICF0aGlzLl9pc1ZhbHVlRXF1YWwoIHRoaXMuX3ZhbHVlLCBuZXdWYWx1ZSApIHx8IHRoaXMuX2Vycm9yICE9IG5ld0Vycm9yICkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coYD5gK3RoaXMuJG5hbWUpLy9kZWJ1Z2dlclxuXHRcdFx0dGhpcy5fdmFsdWUgPSBuZXdWYWx1ZVxuXHRcdFx0dGhpcy5fZXJyb3IgPSBuZXdFcnJvclxuXHRcdFx0aWYgKCB0aGlzLl9saXZlIClcblx0XHRcdFx0Zm9yICggbGV0IHAgb2YgdGhpcy5fbGl2ZUFycmF5IClcblx0XHRcdFx0XHRwLl93cml0ZSggbmV3VmFsdWUgJiYgbmV3VmFsdWVbIHAuX2tleSBdLCB0cnVlIClcblx0XHRcdHRoaXMuX2ZpcmUoKVxuXHRcdFx0aWYgKCAhZG93biApIHtcblx0XHRcdFx0bGV0IHAgPSB0aGlzLl9wYXJlbnRcblx0XHRcdFx0d2hpbGUgKCBwICYmICFwLl9kaXJ0eSApIHtcblx0XHRcdFx0XHRwLl9kaXJ0eSA9IHRydWVcblx0XHRcdFx0XHRwLl9maXJlKClcblx0XHRcdFx0XHRwID0gcC5fcGFyZW50XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAhZG93biApXG5cdFx0XHR0aGlzLl9ub3RpZnlXcml0dGVuKClcblx0XHRyZXR1cm4gbmV3VmFsdWVcblx0fVxuXG5cdF91cGRhdGVTZWxmKCkge1xuXHRcdGxldCBjbnQgPSAwXG5cdFx0bGV0IHJldCA9IHt9XG5cdFx0Zm9yICggbGV0IGtleSBpbiB0aGlzLl92YWx1ZSApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB0aGlzLl92YWx1ZSwga2V5ICkgKSB7XG5cdFx0XHRyZXRbIGtleSBdID0gdGhpcy5fdmFsdWVbIGtleSBdXG5cdFx0XHQrK2NudFxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBwIG9mIHRoaXMuX2xpdmVBcnJheSApIHtcblx0XHRcdGlmICggcC5fZGlydHkgKVxuXHRcdFx0XHRwLl91cGRhdGVTZWxmKClcblx0XHRcdGlmICggcC5fZXJyb3IgKSB7XG5cdFx0XHRcdHRoaXMuX2Vycm9yID0gcC5fZXJyb3Jcblx0XHRcdFx0dGhpcy5fdmFsdWUgPSBudWxsXG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2Vcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRsZXQgdmFsdWUgPSBwLl92YWx1ZVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsICkge1xuXHRcdFx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggcmV0LCBwLl9rZXkgKSApIHtcblx0XHRcdFx0XHRkZWxldGUgcmV0WyBwLl9rZXkgXVxuXHRcdFx0XHRcdC0tY250XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXRbIHAuX2tleSBdID0gdmFsdWVcblx0XHRcdFx0Y250ID0gSW5maW5pdHlcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGNudCA9PSAwIClcblx0XHRcdHJldCA9IG51bGxcblxuXHRcdHRoaXMuX3ZhbHVlID0gcmV0XG5cdFx0dGhpcy5fZGlydHkgPSBmYWxzZVxuXHR9XG5cblx0ZGVidWcoIGNiICkge1xuXHRcdHRoaXMuX2FjdGlvbnNBcnIucHVzaCggeyBhY3Rpb246IHsgX2ZpcmU6IGNiIH0gfSApXG5cdH1cblxuXHRkZWJ1Z2dlcigpIHtcblx0XHR0aGlzLmRlYnVnKCAoKSA9PiB7IGRlYnVnZ2VyIH0gKVxuXHR9XG5cblx0X2ZpcmUoKSB7XG5cdFx0bGV0IGFcblx0XHRhID0gdGhpcy5fYWN0aW9uc0FyclxuXHRcdGlmICggYS5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRsZXQgYyA9IGFbIGkgXVxuXHRcdFx0XHRpZiAoIGMuYWN0aW9uIClcblx0XHRcdFx0XHRjLmFjdGlvbi5fZmlyZSgpXG5cdFx0XHRcdGMucHVzaGVkQyA9IGZhbHNlXG5cdFx0XHR9XG5cdFx0XHRhLmxlbmd0aCA9IDBcblx0XHR9XG5cdFx0YSA9IHRoaXMuX29uY2hhbmdlXG5cdFx0aWYgKCBhLmxlbmd0aCApIHtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKysgKVxuXHRcdFx0XHR1cGRhdGVzLmxhdGVyKCBhWyBpIF0gKVxuXHRcdFx0YS5sZW5ndGggPSAwXG5cdFx0fVxuXHR9XG5cblx0X25vdGlmeVdyaXR0ZW4oKSB7XG5cdFx0bGV0IGFjdGlvbiA9IGNvLmdsb2JhbFsgYWN0aW9uS2V5IF1cblx0XHRpZiAoIGFjdGlvbiApXG5cdFx0XHRhY3Rpb24ub253cml0dGVuKCB0aGlzIClcblx0fVxuXG59XG5cbmxldCByZXRocm93ID0gZXJyb3IgPT4gc2V0VGltZW91dCggKCkgPT4geyB0aHJvdyBlcnJvciB9LCAxIClcblxuY2xhc3MgQWN0aW9uIHtcblxuXHRjb25zdHJ1Y3RvciggZnVuLCBkZXN0LCBzdGlja3kgKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQoKVxuXHRcdHRoaXMuX2Z1biA9IGZ1blxuXHRcdHRoaXMuX2Rlc3QgPSBkZXN0XG5cdFx0dGhpcy5fY2VsbFNldCA9IHt9XG5cdFx0dGhpcy5fY2VsbFNldFNpemUgPSAwXG5cdFx0dGhpcy5fY2VsbEFyciA9IFtdXG5cdFx0dGhpcy4kbmFtZSA9IHsgdG9TdHJpbmc6ICgpID0+IGA8QWN0aW9uPmAgfVxuXHRcdHRoaXMuX3RocmVhZCA9IGNvLmdvY2FsbCggdGhpcy5fbG9vcCwgdGhpcyApLmxpbmtOYW1lKCB0aGlzICkud2FpdEZvcklucHV0KClcblx0XHR0aGlzLl9ydW5Db3VudCA9IDBcblx0XHRsZXQgb3duZXJcblx0XHRpZiAoICggb3duZXIgPSBjby5nbG9iYWxbIGFjdGlvbktleSBdICkgJiYgb3duZXIuX2NoaWxkcmVuIClcblx0XHRcdG93bmVyLl9jaGlsZHJlbi5wdXNoKCB0aGlzIClcblx0XHR0aGlzLl9jaGlsZHJlbiA9IG51bGxcblx0XHR0aGlzLl90aHJlYWRzID0gbnVsbFxuXHRcdHRoaXMuX29udGhyZWFkID0gbnVsbFxuXHRcdHRoaXMuX2dlbmVyYXRvclByb3h5ID0gbnVsbFxuXHRcdHRoaXMuX2dlbmVyYXRvciA9IG51bGxcblx0XHRpZiAoIHN0aWNreSApIHtcblx0XHRcdHRoaXMuX2NoaWxkcmVuID0gW11cblx0XHRcdHRoaXMuX3RocmVhZHMgPSBbXVxuXHRcdFx0dGhpcy5fb250aHJlYWQgPSB0aHJlYWQgPT4gdGhpcy5fdGhyZWFkcy5wdXNoKCB0aHJlYWQgKVxuXHRcdH1cblx0fVxuXG5cdGxpbmtOYW1lKCB2YWx1ZSwgc3VmZml4ID0gYDphY3Rpb25gICkge1xuXHRcdGlmICggdmFsdWUuJG5hbWUgKVxuXHRcdFx0dmFsdWUgPSB2YWx1ZS4kbmFtZVxuXHRcdHRoaXMuJG5hbWUudG9TdHJpbmcgPSAoKSA9PiBgYCArIHZhbHVlICsgc3VmZml4XG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdF9pbml0R2VuZXJhdG9yUHJveHkoKSB7XG5cdFx0bGV0IF92YWx1ZVxuXHRcdGxldCBfbmV4dCA9ICgpID0+IHRoaXMuX2dlbmVyYXRvci5uZXh0KCBfdmFsdWUgKVxuXHRcdGxldCBfdGhyb3cgPSAoKSA9PiB0aGlzLl9nZW5lcmF0b3IudGhyb3coIF92YWx1ZSApXG5cdFx0bGV0IF9yZXR1cm4gPSAoKSA9PiB0aGlzLl9nZW5lcmF0b3IucmV0dXJuKCBfdmFsdWUgKVxuXHRcdHRoaXMuX2dlbmVyYXRvclByb3h5ID0ge1xuXHRcdFx0WyBTeW1ib2wuaXRlcmF0b3IgXTogcmV0dXJuVGhpcyxcblx0XHRcdG5leHQ6IHYgPT4ge1xuXHRcdFx0XHRfdmFsdWUgPSB2XG5cdFx0XHRcdHRyeSB7IHJldHVybiBjby5jYXRjaFRocmVhZHMoIF9uZXh0LCB0aGlzLl9vbnRocmVhZCApIH1cblx0XHRcdFx0ZmluYWxseSB7IF92YWx1ZSA9IG51bGwgfVxuXHRcdFx0fSxcblx0XHRcdHRocm93OiB2ID0+IHtcblx0XHRcdFx0X3ZhbHVlID0gdlxuXHRcdFx0XHR0cnkgeyByZXR1cm4gY28uY2F0Y2hUaHJlYWRzKCBfdGhyb3csIHRoaXMuX29udGhyZWFkICkgfVxuXHRcdFx0XHRmaW5hbGx5IHsgX3ZhbHVlID0gbnVsbCB9XG5cdFx0XHR9LFxuXHRcdFx0cmV0dXJuOiB2ID0+IHtcblx0XHRcdFx0X3ZhbHVlID0gdlxuXHRcdFx0XHR0cnkgeyByZXR1cm4gY28uY2F0Y2hUaHJlYWRzKCBfcmV0dXJuLCB0aGlzLl9vbnRocmVhZCApIH1cblx0XHRcdFx0ZmluYWxseSB7IF92YWx1ZSA9IG51bGwgfVxuXHRcdFx0fSxcblx0XHR9XG5cdH1cblxuXHQqX2xvb3AoKSB7XG5cdFx0eWllbGQgdXBkYXRlcy5sYXRlclxuXHRcdGxldCBuZXh0ID0geyB0aGVuOiBuZXh0ID0+IHsgdGhpcy5fb25jaGFuZ2UgPSBuZXh0IH0gfVxuXHRcdGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSB0aGlzXG5cdFx0bGV0IGVycm9yQ2F0Y2hlZCA9IGZhbHNlXG5cdFx0ZXh0ZXJuYWw6IGZvciAoOzspIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAoOzspIHtcblx0XHRcdFx0XHRpZiAoICFlcnJvckNhdGNoZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuaXNDbG9zZWQoKSApXG5cdFx0XHRcdFx0XHRcdGJyZWFrIGV4dGVybmFsXG5cdFx0XHRcdFx0XHR0aGlzLl9iZWdpbigpXG5cdFx0XHRcdFx0XHRlcnJvckNhdGNoZWQgPSB0cnVlXG5cdFx0XHRcdFx0XHRsZXQgcmV0XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuX2NoaWxkcmVuICkge1xuXHRcdFx0XHRcdFx0XHRyZXQgPSBjby5jYXRjaFRocmVhZHMoIHRoaXMuX2Z1biwgdGhpcy5fb250aHJlYWQgKVxuXHRcdFx0XHRcdFx0XHRpZiAoICFyZXQgfHwgcmV0WyByYVZhbHVlIF0gKSB7IC8vIG5vb3Bcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmICggcmV0Lm5leHQgJiYgcmV0LnRocm93ICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIXRoaXMuX2dlbmVyYXRvclByb3h5IClcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2luaXRHZW5lcmF0b3JQcm94eSgpXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZ2VuZXJhdG9yID0gcmV0XG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHsgcmV0ID0geWllbGQqIHRoaXMuX2dlbmVyYXRvclByb3h5IH1cblx0XHRcdFx0XHRcdFx0XHRmaW5hbGx5IHsgdGhpcy5fZ2VuZXJhdG9yID0gbnVsbCB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoIHJldC50aGVuIClcblx0XHRcdFx0XHRcdFx0XHRyZXQgPSB5aWVsZCByZXRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXQgPSAoIDAsIHRoaXMuX2Z1biApKClcblx0XHRcdFx0XHRcdFx0aWYgKCAhcmV0IHx8IHJldFsgcmFWYWx1ZSBdICkgeyAvLyBub29wXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoIHJldC5uZXh0ICYmIHJldC50aHJvdyApXG5cdFx0XHRcdFx0XHRcdFx0cmV0ID0geWllbGQqIHJldFxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmICggcmV0LnRoZW4gKVxuXHRcdFx0XHRcdFx0XHRcdHJldCA9IHlpZWxkIHJldFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLl9kZXN0IClcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVzdC5hc3NpZ24oIHJldCApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVycm9yQ2F0Y2hlZCA9IGZhbHNlXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmlzQ2xvc2VkKCkgKVxuXHRcdFx0XHRcdFx0YnJlYWsgZXh0ZXJuYWxcblx0XHRcdFx0XHRzd2l0Y2ggKCB0aGlzLl9lbmQoKSApIHtcblx0XHRcdFx0XHRjYXNlIGZhbHNlOlxuXHRcdFx0XHRcdFx0YnJlYWsgZXh0ZXJuYWxcblx0XHRcdFx0XHRjYXNlIHRydWU6XG5cdFx0XHRcdFx0XHR5aWVsZCBuZXh0XG5cdFx0XHRcdFx0Ly8gY2FzZSBudWxsOlxuXHRcdFx0XHRcdFx0LyogaW1tZWRpYXRlIHJlY2FsY3VsYXRpb24gKi9cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdGlmICggZXJyb3JDYXRjaGVkIClcblx0XHRcdFx0XHR0aGlzLl9kZXN0LnRocm93KCBlcnJvciApXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXRocm93KCBlcnJvciApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBudWxsXG5cdFx0dGhpcy5fZmluYWxpemUoKVxuXHR9XG5cblx0aXNDbG9zZWQoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jZWxsU2V0XG5cdH1cblxuXHRjbG9zZSgpIHtcblx0XHRsZXQgdGhyZWFkID0gdGhpcy5fdGhyZWFkXG5cdFx0dGhpcy5fZmlyZSgpXG5cdFx0dGhpcy5fZmluYWxpemUoKVxuXHRcdHRocmVhZCAmJiB0aHJlYWQua2lsbCgpXG5cdH1cblxuXHRfY2xvc2VDaGlsZHJlbigpIHtcblx0XHRsZXQgY1xuXHRcdGlmICggYyA9IHRoaXMuX2NoaWxkcmVuICkge1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYy5sZW5ndGg7IGkgPCBsOyArK2kgKVxuXHRcdFx0XHRjWyBpIF0uY2xvc2UoKVxuXHRcdFx0Yy5sZW5ndGggPSAwXG5cdFx0fVxuXHRcdGlmICggYyA9IHRoaXMuX3RocmVhZHMgKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjLmxlbmd0aDsgaSA8IGw7ICsraSApXG5cdFx0XHRcdGNbIGkgXS5raWxsKClcblx0XHRcdGMubGVuZ3RoID0gMFxuXHRcdH1cblx0fVxuXG5cdF9maW5hbGl6ZSgpIHtcblx0XHR0aGlzLl91bnN1YnNjcmliZSgpXG5cdFx0dGhpcy5fY2VsbFNldCA9IG51bGxcblx0XHR0aGlzLl9jZWxsQXJyID0gbnVsbFxuXHRcdHRoaXMuX2Z1biA9IG51bGxcblx0XHR0aGlzLl9kZXN0ID0gbnVsbFxuXHRcdHRoaXMuX3RocmVhZCA9IG51bGxcblx0fVxuXG5cdF9iZWdpbigpIHtcblx0XHR0aGlzLl91bnN1YnNjcmliZSgpXG5cdFx0Kyt0aGlzLl9ydW5Db3VudFxuXHRcdGlmICggQWN0aW9uLm1heENvdW50IDwgdGhpcy5fcnVuQ291bnQgKSB7XG5cdFx0XHRBY3Rpb24ubWF4Q291bnQgPSB0aGlzLl9ydW5Db3VudFxuXHRcdH1cblx0fVxuXG5cdF91bnN1YnNjcmliZSgpIHtcblx0XHR0aGlzLl9vbmNoYW5nZSA9IG51bGxcblx0XHRsZXQgYSA9IHRoaXMuX2NlbGxBcnJcblx0XHRpZiAoIGEgKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpICkge1xuXHRcdFx0XHRsZXQgYyA9IGFbIGkgXVxuXHRcdFx0XHRjLmNlbGwgPSBudWxsXG5cdFx0XHRcdGMudmFsdWUgPSBudWxsXG5cdFx0XHRcdGMuYWN0aW9uID0gbnVsbFxuXHRcdFx0XHRjLnJlYWQgPSBmYWxzZVxuXHRcdFx0XHRjLndyaXR0ZW4gPSBmYWxzZVxuXHRcdFx0XHRjLnB1c2hlZEEgPSBmYWxzZVxuXHRcdFx0XHQvLyBkbyBub3QgY2hhbmdlIGMucHVzaGVkQyBoZXJlISFcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5fY2VsbFNldFNpemUgPiAzMiAmJiBhLmxlbmd0aCA8IHRoaXMuX2NlbGxTZXRTaXplIC8gNCApIHtcblx0XHRcdFx0dGhpcy5fY2VsbFNldCA9IHt9XG5cdFx0XHRcdHRoaXMuX2NlbGxTZXRTaXplID0gMFxuXHRcdFx0fVxuXHRcdFx0YS5sZW5ndGggPSAwXG5cdFx0fVxuXHRcdHRoaXMuX2Nsb3NlQ2hpbGRyZW4oKVxuXHR9XG5cblx0X2VuZCgpIHtcblx0XHRsZXQgcmV0ID0gZmFsc2Vcblx0XHRsZXQgYSA9IHRoaXMuX2NlbGxBcnJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpICkge1xuXHRcdFx0bGV0IGMgPSBhWyBpIF1cblx0XHRcdGlmICggYy53cml0dGVuIClcblx0XHRcdFx0Yy5hY3Rpb24gPSBudWxsXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCAhYy5wdXNoZWRDICkge1xuXHRcdFx0XHRcdGMuY2VsbC5fYWN0aW9uc0Fyci5wdXNoKCBjIClcblx0XHRcdFx0XHRjLnB1c2hlZEMgPSB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXMoIGMudmFsdWUsIGMuY2VsbC5fdmFsdWUgKSB8fCBjLmVycm9yICE9IGMuY2VsbC5fZXJyb3IgKVxuXHRcdFx0XHRcdHJldHVybiBudWxsXG5cdFx0XHRcdGMuYWN0aW9uID0gdGhpc1xuXHRcdFx0XHRyZXQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0XHRjLnZhbHVlID0gbnVsbFxuXHRcdFx0Yy5jZWxsID0gbnVsbFxuXHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH1cblxuXHRfbGlua0NlbGwoIGNlbGwgKSB7XG5cdFx0bGV0IGMgPSB0aGlzLl9jZWxsU2V0WyBjZWxsLl9pZCBdXG5cdFx0aWYgKCBjID09IG51bGwgKSB7XG5cdFx0XHRjID0gdGhpcy5fY2VsbFNldFsgY2VsbC5faWQgXSA9IHtcblx0XHRcdFx0Y2VsbDogbnVsbCxcblx0XHRcdFx0dmFsdWU6IG51bGwsXG5cdFx0XHRcdGVycm9yOiBudWxsLFxuXHRcdFx0XHRhY3Rpb246IG51bGwsXG5cdFx0XHRcdHJlYWQ6IGZhbHNlLFxuXHRcdFx0XHR3cml0dGVuOiBmYWxzZSxcblx0XHRcdFx0cHVzaGVkQTogZmFsc2UsXG5cdFx0XHRcdHB1c2hlZEM6IGZhbHNlLFxuXHRcdFx0fVxuXHRcdFx0Kyt0aGlzLl9jZWxsU2V0U2l6ZVxuXHRcdH1cblx0XHRpZiAoICFjLnB1c2hlZEEgKSB7XG5cdFx0XHR0aGlzLl9jZWxsQXJyLnB1c2goIGMgKVxuXHRcdFx0Yy5jZWxsID0gY2VsbFxuXHRcdFx0Yy5wdXNoZWRBID0gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gY1xuXHR9XG5cblx0b25yZWFkKCBjZWxsICkge1xuXHRcdGxldCBjID0gdGhpcy5fbGlua0NlbGwoIGNlbGwgKVxuXHRcdGMucmVhZCA9IHRydWVcblx0XHRjLnZhbHVlID0gY2VsbC5fdmFsdWVcblx0XHRjLmVycm9yID0gY2VsbC5fZXJyb3Jcblx0fVxuXG5cdG9ud3JpdHRlbiggY2VsbCApIHtcblx0XHR0aGlzLl9saW5rQ2VsbCggY2VsbCApLndyaXR0ZW4gPSB0cnVlXG5cdH1cblxuXHRfZmlyZSgpIHtcblx0XHRpZiAoIHRoaXMuX29uY2hhbmdlIClcblx0XHRcdHVwZGF0ZXMubGF0ZXIoIHRoaXMuX29uY2hhbmdlIClcblx0XHR0aGlzLl91bnN1YnNjcmliZSgpXG5cdH1cblxufVxuXG5BY3Rpb24ubWF4Q291bnQgPSAwXG5cbmxldCBuZXdSZWFjdGl2ZSA9ICggZ2V0dGVyLCBoYW5kbGVycywgc3RpY2t5LCBpc1ZhbHVlRXF1YWwgKSA9PiB7XG5cdGZvciAoIGxldCBoIG9mIGhhbmRsZXJzIClcblx0XHRpZiAoIGggIT0gbnVsbCAmJiB0eXBlb2YgaCAhPSBgZnVuY3Rpb25gIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHdyb25nIHBhcmFtZXRlcnNgIClcblx0bGV0IGNlbGwgPSBuZXcgQ2VsbCggc3RpY2t5IClcblx0aWYgKCBnZXR0ZXIgIT09IHVuZGVmaW5lZCApXG5cdFx0Y2VsbC5faW5pdCggZ2V0dGVyLCBmYWxzZSwgdHJ1ZSwgaXNWYWx1ZUVxdWFsIClcblx0Zm9yICggbGV0IGggb2YgaGFuZGxlcnMgKVxuXHRcdGggJiYgKCBoLmxlbmd0aCA/IHJ1blNldHRlciA6IHJ1bkdldHRlciApKCBjZWxsLCBoLCBzdGlja3kgKVxuXHRyZXR1cm4gY2VsbFxufVxuXG5sZXQgcmEgPSBmdW5jdGlvbiAoKSB7XG5cdGxldCBuYW1lLCBmdW4sIHN0aWNreSwgaXNWYWx1ZUVxdWFsLCBpbmRleCA9IDBcblx0aWYgKCB0eXBlb2YgYXJndW1lbnRzWyBpbmRleCBdID09IFwic3RyaW5nXCIgKVxuXHRcdG5hbWUgPSBhcmd1bWVudHNbIGluZGV4KysgXVxuXHRpZiAoIHR5cGVvZiBhcmd1bWVudHNbIGluZGV4IF0gPT0gXCJib29sZWFuXCIgKVxuXHRcdHN0aWNreSA9IGFyZ3VtZW50c1sgaW5kZXgrKyBdXG5cdGZ1biA9IGFyZ3VtZW50c1sgaW5kZXgrKyBdXG5cdGlmICggdHlwZW9mIGFyZ3VtZW50c1sgaW5kZXggXSA9PSBcImZ1bmN0aW9uXCIgKVxuXHRcdGlzVmFsdWVFcXVhbCA9IGFyZ3VtZW50c1sgaW5kZXgrKyBdXG5cdHJldHVybiBuZXdSZWFjdGl2ZSggZnVuLCBbXSwgc3RpY2t5LCBpc1ZhbHVlRXF1YWwgKVxufVxuXG5mdW5jdGlvbiBBcnJheUlzRXF1YWxUbyggYSApIHtcblx0cmV0dXJuICggdGhpcyA9PSBhICkgfHwgQXJyYXkuaXNBcnJheSggYSApICYmIHRoaXMubGVuZ3RoID09IGEubGVuZ3RoICYmIHRoaXMuZXZlcnkoICggZSwgaSApID0+IGlzKCBlLCBhWyBpIF0gKSApXG59XG5cbmZ1bmN0aW9uIEpzb25Jc0VxdWFsVG8oIGEgKSB7XG5cdHJldHVybiAoIHRoaXMgPT0gYSApIHx8IEpTT04uc3RyaW5naWZ5KCB0aGlzICkgPT0gSlNPTi5zdHJpbmdpZnkoIGEgKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByYVxuXG5leHBvcnRzLnJhID0gcmFcblxuZXhwb3J0cy5pcyA9IGlzXG5cbmV4cG9ydHMuQXJyYXkgPSBhcnJheSA9PiB7XG5cdGFycmF5LmlzRXF1YWxUbyA9IEFycmF5SXNFcXVhbFRvXG5cdHJldHVybiBhcnJheVxufVxuXG5leHBvcnRzLkpTT04gPSBvYmogPT4ge1xuXHRvYmouaXNFcXVhbFRvID0gSnNvbklzRXF1YWxUb1xuXHRyZXR1cm4gb2JqXG59XG5cbmV4cG9ydHMuVmFsdWUgPSBvYmogPT4ge1xuXHRvYmogJiYgb2JqLmRlZmluZVByb3BlcnR5KCByYVZhbHVlLCB7IHZhbHVlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UgfSApXG5cdHJldHVybiBvYmpcbn1cblxuZXhwb3J0cy5jbGVhbiA9ICggZ2V0dGVyLCAuLi5oYW5kZXJzICkgPT4gbmV3UmVhY3RpdmUoIGdldHRlciwgaGFuZGVycywgZmFsc2UgKVxuXG5leHBvcnRzLmRldGFjaCA9IGZ1biA9PiB7XG5cdGxldCBvbGRcblx0aWYgKCBvbGQgPSBjby5nbG9iYWxbIGFjdGlvbktleSBdICkge1xuXHRcdGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBudWxsXG5cdFx0dHJ5IHsgcmV0dXJuIGZ1bigpIH0gZmluYWxseSB7IGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBvbGQgfVxuXHR9XG5cdGVsc2Vcblx0XHRyZXR1cm4gZnVuKClcbn1cblxuZXhwb3J0cy5kZXRhY2hlZCA9IGZ1biA9PiBmdW5jdGlvbiAoKSB7XG5cdGxldCBvbGRcblx0aWYgKCBvbGQgPSBjby5nbG9iYWxbIGFjdGlvbktleSBdICkge1xuXHRcdGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBudWxsXG5cdFx0dHJ5IHsgcmV0dXJuIGZ1bi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgfSBmaW5hbGx5IHsgY28uZ2xvYmFsWyBhY3Rpb25LZXkgXSA9IG9sZCB9XG5cdH1cblx0ZWxzZVxuXHRcdHJldHVybiBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG59XG5cbmV4cG9ydHMub24gPSAoIGVtaXR0ZXIsIGV2ZW50LCBnZXR0ZXIgKSA9PiB7XG5cdGxldCByZXQgPSByYSgpXG5cdGxldCBoYW5kbGVyID0gZGF0YSA9PiByZXQuYXNzaWduKCBnZXR0ZXIoIGRhdGEgKSApXG5cdGlmICggZXZlbnQgPT0gYHN0cmluZ2AgKVxuXHRcdGVtaXR0ZXIub24oIGV2ZW50LCBoYW5kbGVyIClcblx0ZWxzZSBmb3IgKCBsZXQgZSBvZiBldmVudCApXG5cdFx0ZW1pdHRlci5vbiggZSwgaGFuZGxlciApXG5cdGhhbmRsZXIoKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydHMuQ2VsbCA9IENlbGxcbmV4cG9ydHMuSW1tdXRhYmxlSW50ZXJmYWNlID0gSW1tdXRhYmxlSW50ZXJmYWNlXG5leHBvcnRzLkFic3RyYWN0R3VhcmQgPSBBYnN0cmFjdEd1YXJkXG5leHBvcnRzLkdldHRlciA9IEdldHRlclxuZXhwb3J0cy5UeXBlID0gVHlwZVxuZXhwb3J0cy5pbXBvcnRGcm9tID0gb2JzZXJ2YWJsZSA9PiBUeXBlKCBuYW1lID0+IEdldHRlciggKCkgPT4gb2JzZXJ2YWJsZS5saXZlWyBuYW1lIF0udmFsdWVPZigpICkgKVxuZXhwb3J0cy5mb3JjZUNhbGN1bGF0aW9ucyA9ICgpID0+IHVwZGF0ZXMucnVuQWxsKClcblxuZnVuY3Rpb24gY3JlYXRlQWN0dWFsKCkge1xuXHRsZXQgcmV0ID0gcmEoKVxuXHRyZXQuYXNzaWduKCByZXQgKVxuXHRyYSggKCkgPT4ge1xuXHRcdGxldCB2YWx1ZSA9IHJldC52YWx1ZU9mKClcblx0XHRyYS5kZXRhY2goICgpID0+IHJldC5hc3NpZ24oIHZhbHVlICkgKVxuXHR9IClcblx0cmV0dXJuIHJldFxufVxuXG5sZXQgX0RCQ2h1bmtfR2V0dGVyID0gVUlEKClcblxuY2xhc3MgREJDaHVuayB7XG5cdGNvbnN0cnVjdG9yKCBnZXR0ZXIsIHNhdmUsIGluaXRpYWwsIHByZXZpb3VzICkge1xuXHRcdHRoaXMuX3ByZXZpb3VzID0gcHJldmlvdXNcblx0XHR0aGlzLl9nZXR0ZXIgPSBnZXR0ZXJcblx0XHR0aGlzLl9zYXZlID0gc2F2ZVxuXHRcdGxldCBjaHVuayA9IHRoaXMuX2NodW5rID0gcmEoKVxuXHRcdGNodW5rLmFzc2lnbiggaW5pdGlhbCApXG5cdFx0bGV0IGFjdHVhbCA9IHRoaXMuX2FjdHVhbCA9IGNyZWF0ZUFjdHVhbCgpXG5cdFx0YWN0dWFsWyBfREJDaHVua19HZXR0ZXIgXSA9IHJhKCAoKSA9PiBsdS5hcHBseURpZmYoIGdldHRlci52YWx1ZU9mKCksIGNodW5rLnZhbHVlT2YoKSApIClcblx0XHR0aGlzLl9zdW1tYXJ5ID0gcmEoICgpID0+IGFjdHVhbC52YWx1ZU9mKClbIF9EQkNodW5rX0dldHRlciBdLnZhbHVlT2YoKSApXG5cdH1cblx0Y3JlYXRlTmV4dCggaW5pdGlhbCA9IG51bGwgKSB7IHJldHVybiBuZXcgREJDaHVuayggdGhpcy5fc3VtbWFyeSwgdGhpcy5fc2F2ZSwgaW5pdGlhbCwgdGhpcy5fYWN0dWFsICkgfVxuXHRnZXQgYmVmb3JlKCkgeyByZXR1cm4gdGhpcy5fZ2V0dGVyLnZhbHVlT2YoKSB9XG5cdGdldCBzdW1tYXJ5KCkgeyByZXR1cm4gdGhpcy5fc3VtbWFyeS52YWx1ZU9mKCkgfVxuXHRnZXQgY2h1bmsoKSB7IHJldHVybiB0aGlzLl9jaHVuay52YWx1ZU9mKCkgfVxuXHRzZXQgY2h1bmsoIHZhbHVlICkgeyB0aGlzLl9jaHVuay5hc3NpZ24oIHZhbHVlICkgfVxuXHR2YWx1ZU9mKCkgeyByZXR1cm4gdGhpcy5jaHVuayB9XG5cdGFzc2lnbiggdmFsdWUgKSB7IHRoaXMuY2h1bmsgPSB2YWx1ZSB9XG5cdHNhdmUoKSB7IHJldHVybiB0aGlzLl9zYXZlKCB0aGlzLmNodW5rICkgfVxuXHR1cGRhdGUoIGRpZmYgKSB7IHJldHVybiB0aGlzLl9jaHVuay51cGRhdGUoIGRpZmYgKSB9XG5cdHNldCggbmFtZSwgdmFsdWUgKSB7IHJldHVybiB0aGlzLl9jaHVuay5zZXQoIG5hbWUsIHZhbHVlICkgfVxuXHRnZXQoIG5hbWUgKSB7IHJldHVybiB0aGlzLl9jaHVuay5nZXQoIG5hbWUgKSB9XG5cdGNsb3NlKCkge1xuXHRcdHRoaXMuX2NodW5rLmFzc2lnbiggbnVsbCApXG5cdFx0aWYgKCB0aGlzLl9wcmV2aW91cyApIHtcblx0XHRcdHRoaXMuX2FjdHVhbC5hc3NpZ24oIHRoaXMuX3ByZXZpb3VzIClcblx0XHRcdHRoaXMuX3ByZXZpb3VzID0gbnVsbFxuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBEQiB7XG5cdGNvbnN0cnVjdG9yKCBnZXR0ZXIsIHNhdmUgKSB7XG5cdFx0dGhpcy5faGVhZCA9IHJhKClcblx0XHR0aGlzLl9oZWFkLmFzc2lnbiggbmV3IERCQ2h1bmsoIGdldHRlciwgc2F2ZSApIClcblx0XHR0aGlzLl92YWx1ZSA9IHJhKCAoKSA9PiB0aGlzLl9oZWFkLnZhbHVlT2YoKS5zdW1tYXJ5IClcblx0fVxuXHRnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMudmFsdWVPZigpIH1cblx0dmFsdWVPZigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUudmFsdWVPZigpXG5cdH1cblx0Y3JlYXRlUmVjb3JkKCkgeyAvLyBub3QgZGV0YWNoZWRcblx0XHRsZXQgcmV0ID0gdGhpcy5faGVhZC52YWx1ZU9mKCkuY3JlYXRlTmV4dCgpXG5cdFx0dGhpcy5faGVhZC5hc3NpZ24oIHJldCApXG5cdFx0cmV0dXJuIHJldFxuXHR9XG59XG5cbmV4cG9ydHMuZGIgPSAoIGdldHRlciwgc2F2ZSApID0+IG5ldyBEQiggZ2V0dGVyLCBzYXZlIClcblxuZnVuY3Rpb24gdG9LZXkoIG9iaiApIHtcblx0aWYgKCAhdG9LZXkuS2V5cyApXG5cdFx0dG9LZXkuS2V5cyA9IHR5cGVvZiBXZWFrTWFwICE9IGB1bmRlZmluZWRgID8gbmV3IFdlYWtNYXAgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRsZXQgaWQgPSBgX3RvX2tleV8keyBVSUQoKSB9YFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2V0KCBvYmosIHZhbHVlICkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iaiwgaWQsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0fSApIH0sXG5cdFx0XHRcdGdldCggb2JqICkgeyByZXR1cm4gb2JqWyBpZCBdIH0sXG5cdFx0XHRcdGhhcyggb2JqICkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBvYmosIGlkICkgfSxcblx0XHRcdFx0Ly8gZGVsZXRlKCBvYmogKSB7IGRlbGV0ZSBvYmpbIGlkIF0gfSxcblx0XHRcdH1cblx0XHR9KClcblx0aWYgKCBvYmogJiYgKCB0eXBlb2Ygb2JqID09IGBvYmplY3RgIHx8IHR5cGVvZiBvYmogPT0gYGZ1bmN0aW9uYCApICkge1xuXHRcdGlmICggIXRvS2V5LktleXMuaGFzKCBvYmogKSApXG5cdFx0XHR0b0tleS5LZXlzLnNldCggb2JqLCBVSUQoKSApXG5cdFx0cmV0dXJuIHRvS2V5LktleXMuZ2V0KCBvYmogKVxuXHR9XG5cdHJldHVybiB0eXBlb2Ygb2JqICsgb2JqXG59XG5cbmV4cG9ydHMubWFrZUtleSA9ICggb2JqLCBrZXkgKSA9PiByYSggKCkgPT4gb2JqLmdldCgga2V5ICkgKVxuXG5leHBvcnRzLm1hcCA9ICggYXJyYXksIG1hcHBlciApID0+IHtcblx0aWYgKCAhKCBhcnJheSBpbnN0YW5jZW9mIENlbGwgKSApXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcInJhLm1hcDogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNlbGxcIiApXG5cdGxldCBjYWNoZSA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRsZXQgcmV0ID0gcmEoKVxuXHRyYS5kZXRhY2goICgpID0+IHJhKCAoKSA9PiB7XG5cdFx0Ly8gVE9ETyDQv9GA0LDQstC10YDRi9GG0YwsINGI0YLQviDQv9GA0YsgYXJyYXkuY2xvc2UoKSDQs9GN0YLQsCDRhNGD0L3QutGG0YvRjyDQsNC00L/RgNCw0YbQvtGe0LLQsNC1INGWINC/0YDRi9Cx0ZbQstCw0LUg0Z7RgdC1IGNhY2hlW10uaW5kZXgg0ZYgY2FjaGVbXS5wcm9jXG5cdFx0bGV0IGEgPSBhcnJheS52YWx1ZU9mKClcblx0XHRyYS5kZXRhY2goICgpID0+IHtcblx0XHRcdGxldCByZXRhcnIgPSBbXVxuXHRcdFx0bGV0IGluZGV4ID0gMFxuXHRcdFx0bG9kYXNoLmZvckVhY2goIGNhY2hlLCBjID0+IGMuYWJhbmRvbmVkID0gdHJ1ZSApXG5cdFx0XHRhICYmIGEuZm9yRWFjaCggdmFsdWUgPT4ge1xuXHRcdFx0XHRsZXQga2V5ID0gdG9LZXkoIHZhbHVlIClcblx0XHRcdFx0bGV0IGNcblx0XHRcdFx0aWYgKCAhKCBjID0gY2FjaGVbIGtleSBdICkgKVxuXHRcdFx0XHRcdGMgPSBjYWNoZVsga2V5IF0gPSB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRpbmRleDogcmEoKSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGMuYWJhbmRvbmVkID0gZmFsc2Vcblx0XHRcdFx0Yy5pbmRleC5hc3NpZ24oIGluZGV4KysgKVxuXHRcdFx0XHRpZiAoICFjLnByb2MgKVxuXHRcdFx0XHRcdGMucHJvYyA9IHJhKCAoKSA9PiBtYXBwZXIoIHZhbHVlLCBjLmluZGV4ICkgKVxuXHRcdFx0XHRyZXRhcnIucHVzaCggYy5wcm9jIClcblx0XHRcdH0gKVxuXHRcdFx0bG9kYXNoLmtleXMoIGNhY2hlICkuZm9yRWFjaCgga2V5ID0+IHtcblx0XHRcdFx0bGV0IGMgPSBjYWNoZVsga2V5IF1cblx0XHRcdFx0aWYgKCBjLmFiYW5kb25lZCApIHtcblx0XHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleSBdXG5cdFx0XHRcdFx0Yy5pbmRleC5jbG9zZSgpXG5cdFx0XHRcdFx0Yy5wcm9jLmNsb3NlKClcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0XHRyZXQuYXNzaWduKCByYS5BcnJheSggcmV0YXJyICkgKVxuXHRcdH0gKVxuXHR9ICkgKVxuXHRyZXR1cm4gcmV0XG59XG5cbmV4cG9ydHMua2V5bWFwID0gKCBhcnJheSwgbWFwcGVyICkgPT4ge1xuXHRsZXQgbWFwcGVkID0gcmEubWFwKCBhcnJheSwgbWFwcGVyIClcblx0cmV0dXJuIHJhKCAoKSA9PiBsb2Rhc2guemlwT2JqZWN0KCBhcnJheS52YWx1ZU9mKCksIG1hcHBlZC52YWx1ZU9mKCkgKSApXG59XG5cbi8vIGV4cG9ydHMuc2xpY2UgPSAoIGRlc3QsIHNvdXJjZSwga2V5c1ZhciApID0+IHtcbi8vIFx0dGhyb3cgbmV3IEVycm9yKCBcIm1lc3NhZ2VcIiApXG4vLyBcdC8vIFRPRE86IG9wdGltaXphdGlvblxuLy8gXHRpZiAoICEoIGRlc3QgaW5zdGFuY2VvZiBDZWxsICkgKVxuLy8gXHRcdGRlc3QgPSByYS5jbGVhbiggZGVzdCApXG4vLyBcdGxldCBjYWNoZUhvbGRlciA9IHJhLmNsZWFuKClcbi8vIFx0cmEuY2xlYW4oICgpID0+IHtcbi8vIFx0XHRsZXQga2V5cyA9IGdldFZhbHVlKCBrZXlzVmFyIClcbi8vIFx0XHRpZiAoIGtleXMgKVxuLy8gXHRcdFx0a2V5cy5zb3J0KClcbi8vIFx0XHR1cGRhdGVzLmxhdGVyKCAoKSA9PiB7XG4vLyBcdFx0XHRsZXQgYyA9IHJhLmNsZWFuKClcbi8vIFx0XHRcdGxldCBzID0gYy5kZWZpbmVQcm9wZXJ0eSggYHNvdXJjZWAgKVxuLy8gXHRcdFx0bGV0IGQgPSBjLmRlZmluZVByb3BlcnR5KCBgZGVzdGAgKVxuLy8gXHRcdFx0a2V5cyAmJiBrZXlzLmZvckVhY2goIGsgPT4ge1xuLy8gXHRcdFx0XHRsZXQgc2sgPSBzLmRlZmluZVByb3BlcnR5KCBrIClcbi8vIFx0XHRcdFx0bGV0IGRrID0gZC5kZWZpbmVQcm9wZXJ0eSggayApXG4vLyBcdFx0XHRcdHJhLmNsZWFuKCAoKSA9PiBkay5hc3NpZ24oIHNrLnZhbHVlT2YoKSApIClcbi8vIFx0XHRcdH0gKVxuLy8gXHRcdFx0bGV0IHQgPSBjYWNoZUhvbGRlci52YWx1ZU9mKClcbi8vIFx0XHRcdGNhY2hlSG9sZGVyLmFzc2lnbiggYyApXG4vLyBcdFx0XHR0ICYmIHQuY2xvc2UoKVxuLy8gXHRcdH0gKVxuLy8gXHR9IClcbi8vIFx0cmEuY2xlYW4oICgpID0+IHtcbi8vIFx0XHRsZXQgYyA9IGNhY2hlSG9sZGVyLnZhbHVlT2YoKVxuLy8gXHRcdGMgJiYgYy5zb3VyY2UgJiYgYy5zb3VyY2UuYXNzaWduKCBzb3VyY2UudmFsdWVPZigpIClcbi8vIFx0fSApXG4vLyBcdHJhLmNsZWFuKCAoKSA9PiB7XG4vLyBcdFx0bGV0IGMgPSBjYWNoZUhvbGRlci52YWx1ZU9mKClcbi8vIFx0XHRkZXN0LmFzc2lnbiggYyAmJiBjLmRlc3QgJiYgYy5kZXN0LnZhbHVlT2YoKSApXG4vLyBcdH0gKVxuLy8gXHRyZXR1cm4gZGVzdFxuLy8gfVxuIiwiY29uc3QgbWF4SW5kZXggPSAzMjc2OFxuXG5jbGFzcyBTY2hlZHVsZXIge1xuXHRjb25zdHJ1Y3Rvciggb3B0aW9ucyApIHtcblx0XHR0aGlzLnNldEltbWVkaWF0ZSA9ICggb3B0aW9ucyAmJiBvcHRpb25zLnNldEltbWVkaWF0ZSApIHx8IHByb2Nlc3MubmV4dFRpY2tcblx0XHR0aGlzLm1heFRpY2tzID0gKCBvcHRpb25zICYmIG9wdGlvbnMubWF4VGlja3MgKSB8fCBJbmZpbml0eVxuXHRcdHRoaXMuX3Byb2NzID0gW11cblx0XHR0aGlzLl9pbmRleCA9IDBcblx0XHR0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZVxuXHRcdHRoaXMuX3Byb2Nlc3NpbmcgPSBmYWxzZVxuXHRcdHRoaXMuX2hhbmRsZXIgPSB0aGlzLl9oYW5kbGVyLmJpbmQoIHRoaXMgKVxuXHRcdHRoaXMucHVzaCA9IHRoaXMudGhlbi5iaW5kKCB0aGlzIClcblx0fVxuXG5cdHRoZW4oIHByb2MgKSB7XG5cdFx0dGhpcy5fcHJvY3MucHVzaCggcHJvYyApXG5cdFx0aWYgKCAhdGhpcy5fcHJvY2Vzc2luZyApXG5cdFx0XHR0aGlzLl9zY2hlZHVsZSgpXG5cdH1cblxuXHRfc2NoZWR1bGUoKSB7XG5cdFx0aWYgKCAhdGhpcy5fc2NoZWR1bGVkICkge1xuXHRcdFx0dGhpcy5zZXRJbW1lZGlhdGUoIHRoaXMuX2hhbmRsZXIgKVxuXHRcdFx0dGhpcy5fc2NoZWR1bGVkID0gdHJ1ZVxuXHRcdH1cblx0fVxuXG5cdF9oYW5kbGVyKCkge1xuXHRcdHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlXG5cdFx0d2hpbGUgKCB0aGlzLl9wcm9jcy5sZW5ndGggKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVyMSgpXG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCAoKSA9PiB7IHRocm93IGVycm9yIH0sIDAgKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdF9oYW5kbGVyMSgpIHtcblx0XHR0aGlzLl9wcm9jZXNzaW5nID0gdHJ1ZVxuXHRcdHRyeSB7XG5cdFx0XHRsZXQgdCA9IDBcblx0XHRcdHdoaWxlICggdGhpcy5faW5kZXggPCB0aGlzLl9wcm9jcy5sZW5ndGggJiYgKCArK3QgPD0gdGhpcy5tYXhUaWNrcyApICkge1xuXHRcdFx0XHRsZXQgcHJvYyA9IHRoaXMuX3Byb2NzWyB0aGlzLl9pbmRleCBdXG5cdFx0XHRcdHRoaXMuX3Byb2NzWyB0aGlzLl9pbmRleCBdID0gbnVsbFxuXHRcdFx0XHQrK3RoaXMuX2luZGV4XG5cdFx0XHRcdGlmICggdGhpcy5faW5kZXggPj0gbWF4SW5kZXggJiYgdGhpcy5faW5kZXggKiAzID4gdGhpcy5fcHJvY3MubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMuX3Byb2NzLnNwbGljZSggMCwgdGhpcy5faW5kZXggKVxuXHRcdFx0XHRcdHRoaXMuX2luZGV4ID0gMFxuXHRcdFx0XHR9XG5cdFx0XHRcdHByb2MoKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuX3Byb2Nlc3NpbmcgPSBmYWxzZVxuXHRcdFx0aWYgKCB0aGlzLl9wcm9jcy5sZW5ndGggJiYgdGhpcy5faW5kZXggPj0gdGhpcy5fcHJvY3MubGVuZ3RoIClcblx0XHRcdFx0dGhpcy5fcHJvY3MubGVuZ3RoID0gdGhpcy5faW5kZXggPSAwXG5cdFx0XHRpZiAoIHRoaXMuX2luZGV4IClcblx0XHRcdFx0dGhpcy5fc2NoZWR1bGUoKVxuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVkdWxlclxuIiwiZnVuY3Rpb24gcmV0aHJvdyggZXJyb3IgKSB7XG5cdHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZXJyb3IgfSApXG59XG5cbmZ1bmN0aW9uIHNhZmVFYWNoKCBhcnJheSwgY2IgKSB7XG5cdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsraSApIHtcblx0XHR0cnkge1xuXHRcdFx0Y2IoIGFycmF5LnNoaWZ0KCkgKVxuXHRcdH1cblx0XHRjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0cmV0aHJvdyggZXJyb3IgKVxuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNwYXJzZVF1ZXVlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fY2JzID0gW11cblx0fVxuXHR0aGVuKCBjYiApIHtcblx0XHRpZiAoIHRoaXMuX2Nsb3NlZCApXG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKCAoKSA9PiBjYiggdW5kZWZpbmVkICkgKVxuXHRcdGVsc2Vcblx0XHRcdHRoaXMuX2Nicy5wdXNoKCBjYiApXG5cdH1cblx0aXNDbG9zZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZFxuXHR9XG5cdGNsb3NlKCkge1xuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWVcblx0XHRzYWZlRWFjaCggdGhpcy5fY2JzLCBoYW5kbGVyID0+IGhhbmRsZXIoIHVuZGVmaW5lZCApIClcblx0fVxuXHRwdXNoKCBkYXRhICkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHF1ZXVlIGlzIGFyZWFkeSBjbG9zZWRgIClcblx0XHRzYWZlRWFjaCggdGhpcy5fY2JzLCBoYW5kbGVyID0+IGhhbmRsZXIoIGRhdGEgKSApXG5cdH1cblx0cHVzaGNiKCBkYXRhICkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHF1ZXVlIGlzIGFyZWFkeSBjbG9zZWRgIClcblx0XHRzYWZlRWFjaCggdGhpcy5fY2JzLCBoYW5kbGVyID0+IGhhbmRsZXIoIGRhdGEoKSApIClcblx0fVxufVxuIiwiLypcbmJ5IGRlc2lnbjpcbtCd0LUg0YHRgtCy0LDRgNCw0LXQvCDQvdGW0Y/QutGW0YUg0LHRg9GE0LXRgNCw0Z4g0LTQu9GPINC/0LDQtNC30LXQuSAo0L3QsNC60YjRgtCw0LvRgiB0b3VjaG1vdmUg0YbRliBtb3VzZW1vdmUpIC0g0L/QsNC00LfQtdGWINGe0YHRkSDQsNC00L3QviDQsNC70YzQsdC+INCw0L/RgNCw0YbQvtGe0LLQsNGO0YbRhtCwINGF0YPRgtC60LAsINCw0LvRjNCx0L4g0YLQvtC70YzQutGWINC30LDQudC80LDRjtGG0Ywg0LzQtdGB0YbQsCDRniDQsdGD0YTQtdGA0LDRhSDRliDQt9Cw0YLQsNGA0LzQvtC20LLQsNGO0YbRjCDQsNC/0YDQsNGG0L7RntC60YMsINC60LDQu9GWINCw0L/RgNCw0YbQvtGe0YjRh9GL0LrRliDRntGB0ZEg0LYg0L/RgNCw0YfQvdGD0YbRhtCwLlxuKi9cblxubGV0IHNwYXJzZXF1ZXVlID0gcmVxdWlyZSggYHNwYXJzZXF1ZXVlYCApXG5cbmxldCB0cmFja3MgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblxuc2V0SW50ZXJ2YWwoICgpID0+IHtcblx0Zm9yICggbGV0IGlkZW50aWZpZXIgaW4gdHJhY2tzICkge1xuXHRcdGxldCB0cmFjayA9IHRyYWNrc1sgaWRlbnRpZmllciBdXG5cdFx0aWYgKCB0cmFjay5hYmFuZG9uZWQgKSB7XG5cdFx0XHQvLyBpZiAoIHRyYWNrLmhhbmRsZXIucmV0dXJuIClcblx0XHRcdC8vIFx0dHJhY2suaGFuZGxlci5yZXR1cm4oKVxuXHRcdFx0Ly8gZGVsZXRlIHRyYWNrc1sgaWRlbnRpZmllciBdXG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHRyYWNrLmFiYW5kb25lZCA9IHRydWVcblx0fVxufSwgNzAwMCApXG5cbmZ1bmN0aW9uIHB1c2hFdmVudCggdHJhY2ssIGV2ZW50ICkge1xuXHR0cmFjay5wb2ludHMucHVzaCggZXZlbnQgKVxuXHRpZiAoIHRyYWNrLnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0IClcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG59XG5cbmZ1bmN0aW9uIHN0b3BFdmVudHMoIHRyYWNrICkge1xuXHR0cmFjay5wb2ludHMuY2xvc2UoKVxufVxuXG5mdW5jdGlvbiBzdGFydFRyYWNrKCBpZGVudGlmaWVyLCBldmVudCApIHtcblx0bGV0IHBvaW50cyA9IG5ldyBzcGFyc2VxdWV1ZSgpXG5cdGxldCBkZXRhaWwgPSB7XG5cdFx0Y2FuY2VsRXZlbnQ6IG51bGwsXG5cdFx0bmV4dDogcG9pbnRzLFxuXHR9XG5cdGxldCB0cmFjayA9IHtcblx0XHRhYmFuZG9uZWQ6IGZhbHNlLFxuXHRcdGNsb3NlZDogZmFsc2UsXG5cdFx0ZGV0YWlsLFxuXHRcdHBvaW50cyxcblx0XHRwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG5cdH1cblx0dHJhY2tzWyBpZGVudGlmaWVyIF0gPSB0cmFja1xuXHRsZXQgcmV0ID0gbmV3IEN1c3RvbUV2ZW50KCBgdG91Y2hgLCB7IGRldGFpbCwgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9IClcblx0cmV0LnBhZ2VYID0gZXZlbnQucGFnZVhcblx0cmV0LnBhZ2VZID0gZXZlbnQucGFnZVlcblx0cmV0LmNsaWVudFggPSBldmVudC5jbGllbnRYXG5cdHJldC5jbGllbnRZID0gZXZlbnQuY2xpZW50WVxuXHRyZXQuc2NyZWVuWCA9IGV2ZW50LnNjcmVlblhcblx0cmV0LnNjcmVlblkgPSBldmVudC5zY3JlZW5ZXG5cdHJldC5wcmV2ZW50RGVmYXVsdCA9ICgpID0+IHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0dHJhY2sucHJldmVudERlZmF1bHQgPSB0cnVlXG5cdH1cblx0ZXZlbnQudGFyZ2V0LmRpc3BhdGNoRXZlbnQoIHJldCApXG5cdHB1c2hFdmVudCggdHJhY2ssIGV2ZW50IClcbn1cblxuZnVuY3Rpb24gb25FeGlzdGluZ1RyYWNrKCBmdW4gKSB7IHJldHVybiAoIGlkZW50aWZpZXIsIGFyZyApID0+IHtcblx0bGV0IHRyYWNrID0gdHJhY2tzWyBpZGVudGlmaWVyIF1cblx0aWYgKCAhdHJhY2sgKVxuXHRcdHJldHVyblxuXHR0cmFjay5hYmFuZG9uZWQgPSBmYWxzZVxuXHRmdW4oIHRyYWNrLCBhcmcgKVxufSB9XG5cbmxldCBjb250aW51ZVRyYWNrID0gb25FeGlzdGluZ1RyYWNrKCBwdXNoRXZlbnQgKVxuXG5sZXQgc3RvcFRyYWNrID0gb25FeGlzdGluZ1RyYWNrKCAoIHRyYWNrLCBldmVudCApID0+IHtcblx0cHVzaEV2ZW50KCB0cmFjaywgZXZlbnQgKVxuXHRzdG9wRXZlbnRzKCB0cmFjayApXG59IClcblxubGV0IHJlbW92ZVRyYWNrID0gb25FeGlzdGluZ1RyYWNrKCBzdG9wRXZlbnRzIClcblxubGV0IGNhbmNlbFRyYWNrID0gb25FeGlzdGluZ1RyYWNrKCAoIHRyYWNrLCBldmVudCApID0+IHtcblx0dHJhY2suZGV0YWlsLmNhbmNlbEV2ZW50ID0gZXZlbnRcblx0c3RvcEV2ZW50cyggdHJhY2sgKVxufSApXG5cbmZ1bmN0aW9uIGZvclRvdWNoZXMoIGV2ZW50LCBjYiApIHtcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyArK2kgKSB7XG5cdFx0bGV0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMuaXRlbSggaSApXG5cdFx0Y2IoIHRvdWNoLmlkZW50aWZpZXIsIHtcblx0XHRcdHR5cGU6IGB0b3VjaG1vdmVgLFxuXHRcdFx0aWRlbnRpZmllcjogdG91Y2guaWRlbnRpZmllcixcblx0XHRcdHRhcmdldDogdG91Y2gudGFyZ2V0LFxuXHRcdFx0c2NyZWVuWDogdG91Y2guc2NyZWVuWCxcblx0XHRcdHNjcmVlblk6IHRvdWNoLnNjcmVlblksXG5cdFx0XHRjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuXHRcdFx0Y2xpZW50WTogdG91Y2guY2xpZW50WSxcblx0XHRcdHBhZ2VYOiB0b3VjaC5wYWdlWCxcblx0XHRcdHBhZ2VZOiB0b3VjaC5wYWdlWSxcblx0XHRcdHJhZGl1c1g6IHRvdWNoLnJhZGl1c1gsXG5cdFx0XHRyYWRpdXNZOiB0b3VjaC5yYWRpdXNZLFxuXHRcdFx0cm90YXRpb25BbmdsZTogdG91Y2gucm90YXRpb25BbmdsZSxcblx0XHRcdGZvcmNlOiB0b3VjaC5mb3JjZSxcblx0XHRcdHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wLFxuXHRcdFx0cHJldmVudERlZmF1bHQ6IDo6ZXZlbnQucHJldmVudERlZmF1bHQsXG5cdFx0fSApXG5cdH1cblx0bGV0IGN1cnJlbnQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7ICsraSApXG5cdFx0Y3VycmVudFsgZXZlbnQudG91Y2hlcy5pdGVtKCBpICkuaWRlbnRpZmllciBdID0gdHJ1ZVxuXHRmb3IgKCBsZXQgaWRlbnRpZmllciBpbiB0cmFja3MgKVxuXHRcdGlmICggISggaWRlbnRpZmllciBpbiBjdXJyZW50ICkgKVxuXHRcdFx0cmVtb3ZlVHJhY2soIGlkZW50aWZpZXIgKVxuXHRcdGVsc2Vcblx0XHRcdHRyYWNrc1sgaWRlbnRpZmllciBdLmFiYW5kb25lZCA9IGZhbHNlXG59XG5cbmxldCBjb250YWluZXIgPSBkb2N1bWVudFxuXG5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lciggYG1vdXNlZG93bmAsIGV2ZW50ID0+IHtcblx0aWYgKCBldmVudC5idXR0b24gPT0gMCApXG5cdFx0c3RhcnRUcmFjayggYG1vdXNlYCwgZXZlbnQgKVxuXHRlbHNlIGlmICggISggZXZlbnQuYnV0dG9ucyAmIDEgKSApXG5cdFx0cmVtb3ZlVHJhY2soIGBtb3VzZWAgKVxufSApXG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgbW91c2Vtb3ZlYCwgZXZlbnQgPT4ge1xuXHRpZiAoIGV2ZW50LmJ1dHRvbnMgJiAxIClcblx0XHRjb250aW51ZVRyYWNrKCBgbW91c2VgLCBldmVudCApXG5cdGVsc2Vcblx0XHRyZW1vdmVUcmFjayggYG1vdXNlYCApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGBtb3VzZXVwYCwgZXZlbnQgPT4ge1xuXHRpZiAoIGV2ZW50LmJ1dHRvbiA9PSAwIClcblx0XHRzdG9wVHJhY2soIGBtb3VzZWAsIGV2ZW50IClcblx0ZWxzZSBpZiAoICEoIGV2ZW50LmJ1dHRvbnMgJiAxICkgKVxuXHRcdHJlbW92ZVRyYWNrKCBgbW91c2VgIClcbn0gKVxuXG5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lciggYHRvdWNoc3RhcnRgLCBldmVudCA9PiB7XG5cdGZvclRvdWNoZXMoIGV2ZW50LCBzdGFydFRyYWNrIClcbn0gKVxuXG5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lciggYHRvdWNobW92ZWAsIGV2ZW50ID0+IHtcblx0Zm9yVG91Y2hlcyggZXZlbnQsIGNvbnRpbnVlVHJhY2sgKVxufSApXG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2hlbmRgLCBldmVudCA9PiB7XG5cdGZvclRvdWNoZXMoIGV2ZW50LCBzdG9wVHJhY2sgKVxufSApXG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2hjYW5jZWxgLCBldmVudCA9PiB7XG5cdGZvclRvdWNoZXMoIGV2ZW50LCBjYW5jZWxUcmFjayApXG59IClcbiIsIm1vZHVsZS5leHBvcnRzID0gYXBwID0+IHtcblx0bGV0IENvbW1hbmQgPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL0NvbW1hbmRgICkgKVxuXHRyZXR1cm4gYXR0ciA9PiA8Q29tbWFuZFxuXHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRBZGRFeGlzdGluZ0l0ZW1cIlxuXHRcdG9uY2xpY2sgPSB7ICgpID0+IHtcblx0XHRcdGFwcC5kaWFsb2cgPSBgU2VhcmNoSXRlbXNgXG5cdFx0XHRhcHAuc2VhcmNoQWN0aW9uID0gaXRlbUlkID0+IHtcblx0XHRcdFx0YXBwLmxpbmtJdGVtKCBhcHAuYWN0aXZlRGV2aWNlSWQsIGl0ZW1JZCApXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0fVxuXHRcdFx0YXBwLnNlYXJjaEZpbHRlciA9IG51bGxcblx0XHRcdGlmICggYXBwLmRldmljZVR5cGUgPT0gYGdyb3VwYCApXG5cdFx0XHRcdGFwcC5zZWFyY2hGaWx0ZXIgPSBpdGVtSWQgPT4ge1xuXHRcdFx0XHRcdGxldCBkZXZpY2UgPSBhcHAuZ2V0RGV2aWNlKCBpdGVtSWQgKVxuXHRcdFx0XHRcdHJldHVybiBkZXZpY2UgJiYgZGV2aWNlLnR5cGUgPT0gYHNpbmdsZWBcblx0XHRcdFx0fVxuXHRcdH0gfVxuXHRcdF8gPSB7IGF0dHIgfVxuXHQvPlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4ge1xuXHRsZXQgQ29tbWFuZCA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQ29tbWFuZGAgKSApXG5cdGxldCBBZGRFeGlzdGluZ0l0ZW0gPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL0FkZEV4aXN0aW5nSXRlbWAgKSApXG5cdHJldHVybiA8ZGl2PlxuXHRcdDxBZGRFeGlzdGluZ0l0ZW0gLz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZENyZWF0ZU5ld0dyb3VwXCJcblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IHsgYXBwLmFkZEdyb3VwKCBhcHAuYWN0aXZlRGV2aWNlSWQgKSB9IH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkTmV3RGV2aWNlXCJcblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IGFwcC5hZGREZXZpY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCApIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkUGxhY2VcIlxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4ge1xuXHRcdFx0XHQvLyBhcHAuZGlhbG9nID0gYEFkZFBsYWNlYFxuXHRcdFx0XHRhcHAuYWRkUGxhY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCApXG5cdFx0XHR9IH1cblx0XHQvPlxuXHQ8L2Rpdj5cbn1cbiIsIi8vIGxldCBodHRwQ2xpZW50ID0gcmVxdWlyZSggYGh0dHBDbGllbnRgIClcbi8vIGxldCBjb29raWVzID0gcmVxdWlyZSggYGNvb2tpZXNgIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIHsgYXBwaWQsIEljb25UZW1wbGF0ZXMgfSApID0+IHtcblxuXHRsZXQgeyBhcHAsIGxvY2FsIH0gPSByZXF1aXJlKCBgYXBwYCApKCBhcHBpZCApXG5cdGFwcC5wYWdlU3RhcnRpbmcgPSB0cnVlXG5cblx0d2luZG93Ll9hcHAgPSBhcHBcblx0d2luZG93Ll9sb2NhbCA9IGxvY2FsXG5cdHdpbmRvdy5fZGV2ZGIgPSByZXF1aXJlKCBgZGV2ZGJgIClcblxuXHRpZiAoIG5hdmlnYXRvci5zdGFuZGFsb25lICkge1xuXHRcdC8vIGNvb2tpZXMuc2V0SXRlbSggYHN0YW5kYWxvbmVgLCAxLCBJbmZpbml0eSApIC0tINGD0YHRkSDQsNC00L3QviDQvdC1INC/0LDRgdGM0L/Rj9Cy0LDQtdC8INC/0LDRgdGC0LDQstGW0YbRjCDQutGD0LrRgyDQv9C10YDQsNC0INC/0LXRgNGI0YvQvCDQt9Cy0LDRgNC+0YLQsNC8INC00LAg0YHQtdGA0LLQtdGA0LBcblx0fVxuXHRlbHNlIHtcblx0XHRyYSggKCkgPT4ge1xuXHRcdFx0aWYgKCBsb2NhbC5hY3RpdmVEZXZpY2VJZCAmJiBsb2NhbC5hY3RpdmVEZXZpY2VJZC52YWx1ZU9mKCkgKSB7XG5cdFx0XHRcdGxldCB0aXRsZSA9IGBUSVRMRV8keyBsb2NhbC5hY3RpdmVEZXZpY2VJZCB9YFxuXHRcdFx0XHRsZXQgaWNvbiA9IGBJQ09OXyR7IGxvY2FsLmFjdGl2ZURldmljZUlkIH1gXG5cdFx0XHRcdHNjcmVlblRpdGxlLnNldEF0dHJpYnV0ZSggYGNvbnRlbnRgLCB0aXRsZSApXG5cdFx0XHRcdGlmICggbG9jYWwuYWN0aXZlRGV2aWNlSWQgJiYgbG9jYWwuYWN0aXZlRGV2aWNlSWQgIT0gYG1haW5gIClcblx0XHRcdFx0XHRoaXN0b3J5LnJlcGxhY2VTdGF0ZSggbnVsbCwgdGl0bGUsIGA/YXBwaWNvbj0keyBpY29uIH1gKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUoIG51bGwsIHRpdGxlLCBgP2ApXG5cdFx0XHRcdC8vIGh0dHBDbGllbnQucG9zdCggYC9jb29raWU/YXBwaWNvbj0keyBpY29uIH1gLCBgYCApXG5cdFx0XHRcdC8vIGNvb2tpZXMuc2V0SXRlbSggYGFwcGljb25gLCBpY29uLCBJbmZpbml0eSApXG5cdFx0XHRcdC8vIExPRyggbG9jYWwuYWN0aXZlRGV2aWNlSWQuYmx1ZSApXG5cdFx0XHR9XG5cdFx0fSApXG5cdH1cblxuXHRsZXQgTWFpblNjcmVlbiA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvTWFpblNjcmVlbmAgKSApXG5cdGxldCBTdGFydHVwU2NyZWVuID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9TdGFydHVwU2NyZWVuYCApIClcblx0bGV0IExvYWRpbmdTY3JlZW4gPSAoKSA9PiA8ZGl2IGNsYXNzID0gXCJsb2FkaW5nU2NyZWVuXCIgPjwvZGl2PlxuXG5cdGxldCBhcHBsaWNhdGlvbiA9IDxkaXYgY2xhc3MgPSB7ICgpID0+IGBcblx0XHRhcHBsaWNhdGlvblxuXHRcdCR7IGFwcC5wYWdlU3RhcnRpbmcgPyBgcGFnZVN0YXJ0aW5nYCA6IGBwYWdlUnVubmluZ2AgfVxuXHRcdCR7IGFwcC5pbml0aWFsTG9hZGluZyA/IGBKU09ObG9hZGluZ2AgOiBgSlNPTmxvYWRlZGAgfVxuXHRcdCR7IGFwcC5pbml0aWFsaXplZCA/IGBhbHJlYWR5UnVuYCA6IGBmaXJzdFJ1bmAgfVxuXHRcdCR7IGFwcC5jb25uZWN0ZWRUb1NlcnZlciA/IGBhcHBDb25uZWN0ZWRgIDogYGFwcERpc2Nvbm5lY3RlZGAgfVxuXHRcdCR7IGBgIC8qIGFwcC5jcmVkZW50aWFscyA9PSBudWxsID8gYHNob3dMb2dpbmAgOiBgaGlkZUxvZ2luYCAqLyB9XG5cdFx0JHsgYXBwLnRlbXBsYXRlcyA/IGB0ZW1wbGF0ZXNMb2FkZWRgIDogYHRlbXBsYXRlc0xvYWRpbmdgIH1cblx0XHQkeyBhcHAuZGlhbG9nICYmIGBkaWFsb2ckeyBhcHAuZGlhbG9nIH1gIH1cblx0XHQkeyBhcHAuZGlhbG9nID8gYGRpYWxvZ0lzUHJlc2VudGAgOiBgZGlhbG9nSXNBYnNlbnRgIH1cblx0XHRhcHBfbGFiZWxzXyR7ICEhbG9jYWwubGFiZWxzIH1cblx0XHRhcHBfZWRpdGluZ18keyAhIWFwcC5lZGl0aW5nIH1cblx0YCB9ID5cblx0XHQ8TWFpblNjcmVlbiAvPlxuXHRcdDxTdGFydHVwU2NyZWVuIC8+XG5cdFx0PExvYWRpbmdTY3JlZW4gLz5cblx0PC9kaXY+XG5cblx0YXBwLmljb25zID0gSWNvblRlbXBsYXRlcy5yZWR1Y2UoICggaWNvbnMsIHRlbXBsYXRlICkgPT4ge1xuXHRcdGljb25zWyB0ZW1wbGF0ZS5kYXRhc2V0Lm5hbWUgXSA9IHRlbXBsYXRlXG5cdFx0cmV0dXJuIGljb25zXG5cdH0sIE9iamVjdC5jcmVhdGUoIG51bGwgKSApXG5cblx0bGV0IEJ1dHRvbiA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQnV0dG9uYCApIClcblxuXHRsZXQgQ2xvc2VFcnJvciA9ICggYXR0ciwgdGV4dCApID0+IHtcblx0XHRyZXR1cm4gPHBcblx0XHRcdG9udG91Y2ggPSB7ICgpID0+IHtcblx0XHRcdFx0bGV0IGVycm9yID0gYXBwLmVycm9yXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0XHRhcHAuZXJyb3IgPSBudWxsXG5cdFx0XHRcdGF0dHIub25jbGljayAmJiBhdHRyLm9uY2xpY2soIGVycm9yIClcblx0XHRcdH0gfVxuXHRcdFx0XyA9IHsgT2JqZWN0LmFzc2lnbigge30sIGF0dHIsIHsgb25jbGljazogbnVsbCB9ICkgfVxuXHRcdD57IHRleHQgfTwvcD5cblx0fVxuXG5cdGxldCBDbG9zZURpYWxvZyA9ICggYXR0ciwgdGV4dCApID0+IHtcblx0XHRyZXR1cm4gPHBcblx0XHRcdG9udG91Y2ggPSB7ICgpID0+IHtcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRcdGF0dHIub25jbGljayAmJiBhdHRyLm9uY2xpY2soKVxuXHRcdFx0fSB9XG5cdFx0XHRfID0geyBPYmplY3QuYXNzaWduKCB7fSwgYXR0ciwgeyBvbmNsaWNrOiBudWxsIH0gKSB9XG5cdFx0PnsgdGV4dCB9PC9wPlxuXHR9XG5cblx0Ly8gZGlhbG9nc1xuXHRsZXQgZGlhbG9nVGVtcGxhdGVzID0ge1xuXG5cdFx0U2VydmljZURpYWxvZzogKCkgPT4gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9TZXJ2aWNlRGlhbG9nYCApICksXG5cdFx0Q29udGV4dE1lbnU6ICgpID0+IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQ29udGV4dE1lbnVgICkgKSxcblx0XHRBZGRNZW51OiAoKSA9PiBhcHAubG9hZCggcmVxdWlyZSggYHVpL0FkZE1lbnVgICkgKSxcblx0XHRTZWFyY2hJdGVtczogKCkgPT4gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9TZWFyY2hJdGVtc2AgKSApLFxuXHRcdEFza05ld05hbWU6ICgpID0+IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQXNrTmV3TmFtZWAgKSApLFxuXHRcdEFza1RvTGlua0RldmljZTogKCkgPT4gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9Bc2tUb0xpbmtEZXZpY2VgICkgKSxcblxuXHRcdEFza0lmRGV2aWNlSGFzQmVlbkxpbmtlZDogKCkgPT4gPGRpdj5cblx0XHRcdDxwPtCj0YHRgtGA0L7QudGB0YLQstC+INCx0YvQu9C+INGD0YHQv9C10YjQvdC+INC/0YDQuNCy0Y/Qt9Cw0L3Qvj88L3A+XG5cdFx0XHQ8QnV0dG9uIG9uY2xpY2sgPSBcIlN0b3BEZXZpY2VOb3RpZmljYXRpb25cIiA+0LTQsDwvQnV0dG9uPlxuXHRcdFx0PEJ1dHRvbiBvbmNsaWNrID0gXCJBc2tUb0xpbmtEZXZpY2VcIiA+0L3QtdGCPC9CdXR0b24+XG5cdFx0PC9kaXY+LFxuXG5cdFx0U3RvcERldmljZU5vdGlmaWNhdGlvbjogKCkgPT4gPGRpdj5cblx0XHRcdDxwPtCf0L7QttCw0LvRg9C50YHRgtCwLDxici8+0L/QtdGA0LXQstC10LTQuNGC0LUg0YPRgdGC0YDQvtC50YHRgtCy0L4g0LIg0YDQsNCx0L7Rh9C40Lkg0YDQtdC20LjQvC48L3A+XG5cdFx0XHQ8QnV0dG9uPtCX0LDQutGA0YvRgtGMPC9CdXR0b24+XG5cdFx0PC9kaXY+LFxuXG5cdFx0RXJyb3JOb0NhcnJpZXI6ICgpID0+IDxkaXYgY2xhc3MgPSBcImVycm9yRGlhbG9nXCIgPlxuXHRcdFx0PHA+0J7RiNC40LHQutCwPC9wPlxuXHRcdFx0PHA+0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsCDQv9GA0Lgg0L/QvtC/0YvRgtC60LUg0YHQstGP0LfQsNGC0YzRgdGPINGBINC80L7QtNC10LzQvtC8LjwvcD5cblx0XHRcdDxCdXR0b24+0JfQsNC60YDRi9GC0Yw8L0J1dHRvbj5cblx0XHQ8L2Rpdj4sXG5cblx0XHRFcnJvclVubGlua2luZ0RldmljZTogKCkgPT4gPGRpdiBjbGFzcyA9IFwiZXJyb3JEaWFsb2dcIiA+XG5cdFx0XHQ8cD7QntGI0LjQsdC60LA8L3A+XG5cdFx0XHQ8cD7QndC1INGD0LTQsNC70L7RgdGMINGB0LLRj9C30LDRgtGM0YHRjyDRgSDRg9GB0YLRgNC+0LnRgdGC0LLQvtC8INC4INC+0YLQstGP0LfQsNGC0Ywg0LXQs9C+LjwvcD5cblx0XHRcdDxwPtCn0YLQviDRgdC70LXQtNGD0LXRgiDRgdC00LXQu9Cw0YLRjD88L3A+XG5cdFx0XHQ8dWw+XG5cdFx0XHQ8Q2xvc2VFcnJvciBvbmNsaWNrID0geyBlcnJvciA9PiBhcHAucHVyZ2VJdGVtKCBlcnJvci5kYXRhLmRldmljZUlkICkgfVxuXHRcdFx0XHQ+PGxpPtCf0L7Qv9GL0YLQsNGC0YzRgdGPINC+0YLQstGP0LfQsNGC0Ywg0YPRgdGC0YDQvtC50YHRgtCy0L4g0LXRidGRINGA0LDQtzwvbGk+PC9DbG9zZUVycm9yPlxuXHRcdFx0PENsb3NlRXJyb3Jcblx0XHRcdFx0PjxsaT7QntGC0LzQtdC90LjRgtGMINGD0LTQsNC70LXQvdC40LU8L2xpPjwvQ2xvc2VFcnJvcj5cblx0XHRcdDxDbG9zZUVycm9yIG9uY2xpY2sgPSB7IGVycm9yID0+IGFwcC5wdXJnZUl0ZW0oIGVycm9yLmRhdGEuZGV2aWNlSWQsIHRydWUgKSB9XG5cdFx0XHRcdD48bGk+0JfQsNCx0YvRgtGMINC40L3RhNC+0YDQvNCw0YbQuNGOINC+0LEg0YPRgdGC0YDQvtC50YHRgtCy0LU8L2xpPjwvQ2xvc2VFcnJvcj5cblx0XHRcdDwvdWw+XG5cdFx0PC9kaXY+LFxuXG5cdFx0RGVsZXRlRGV2aWNlOiAoKSA9PiA8ZGl2PlxuXHRcdFx0PHA+eyAoIHtcblx0XHRcdFx0cGxhY2U6IDxzcGFuPtCf0L7QvNC10YnQtdC90LjQtSAo0LzQtdGB0YLQvikgXCJ7IGFwcC5jYXB0aW9uIH1cIiDQsdGD0LTQtdGCINGD0LTQsNC70LXQvdC+INC40Lcg0L/RgNC+0LPRgNCw0LzQvNGLLjwvc3Bhbj4sXG5cdFx0XHRcdHNpbmdsZTogPHNwYW4+0KPRgdGC0YDQvtC50YHRgtCy0L4gXCJ7IGFwcC5jYXB0aW9uIH1cIiDQsdGD0LTQtdGCINGD0LTQsNC70LXQvdC+INC40Lcg0L/RgNC+0LPRgNCw0LzQvNGLLjwvc3Bhbj4sXG5cdFx0XHRcdGdyb3VwOiA8c3Bhbj7Qk9GA0YPQv9C/0LAgXCJ7IGFwcC5jYXB0aW9uIH1cIiDQsdGD0LTQtdGCINGD0LTQsNC70LXQvdCwINC40Lcg0L/RgNC+0LPRgNCw0LzQvNGLLjwvc3Bhbj4sXG5cdFx0XHR9IClbIGFwcC5kZXZpY2VUeXBlIF0gfTwvcD5cblx0XHRcdDx1bD5cblx0XHRcdDxDbG9zZURpYWxvZyBjbGFzcyA9IFwiZGFuZ2Vyb3VzQWN0aW9uXCIgb25jbGljayA9IHsgKCkgPT4gYXBwLnB1cmdlSXRlbSggYXBwLmFjdGl2ZURldmljZUlkICkgfVxuXHRcdFx0XHQ+PGxpPtCj0LTQsNC70LjRgtGMPC9saT48L0Nsb3NlRGlhbG9nPlxuXHRcdFx0PENsb3NlRGlhbG9nXG5cdFx0XHRcdD48bGk+0J3QtSDRg9C00LDQu9GP0YLRjDwvbGk+PC9DbG9zZURpYWxvZz5cblx0XHRcdDwvdWw+XG5cdFx0PC9kaXY+LFxuXG5cdFx0U3RhdGVXYWl0OiAoKSA9PiA8ZGl2PlxuXHRcdFx0PHA+0J/QvtC00L7QttC00LjRgtC1Li4uPC9wPlxuXHRcdDwvZGl2PixcblxuXHRcdEFza1RvUmVzZXQ6ICgpID0+IDxkaXY+XG5cdFx0XHQ8cD7Qn9Cw0LzRj9GC0Ywg0LrQvtC90YLRgNC+0LvQu9C10YDQsCDQsdGD0LTQtdGCINC+0YfQuNGJ0LXQvdCwLDxici8+0L3QviDQv9Cw0LzRj9GC0Ywg0YPRgdGC0YDQvtC50YHRgtCyINC+0YfQuNGJ0LDRgtGM0YHRjyDQvdC1INCx0YPQtNC10YIuPC9wPlxuXHRcdFx0PEJ1dHRvbiBjbGFzcyA9IFwiZGFuZ2Vyb3VzQWN0aW9uXCIgb25jbGljayA9IHsgYXBwLnJlc2V0IH0gPtCe0YfQuNGB0YLQuNGC0Yw8YnIvPtC/0LDQvNGP0YLRjDwvQnV0dG9uPlxuXHRcdDwvZGl2PixcblxuXHRcdC8vIEFkZFBsYWNlLFxuXHRcdC8vIEFkZERldmljZSxcblx0fVxuXG5cdHJhKCAoKSA9PiB7XG5cdFx0bGV0IGRpYWxvZ05hbWUgPSBhcHAuZGlhbG9nXG5cdFx0aWYgKCAhZGlhbG9nTmFtZSApXG5cdFx0XHRyZXR1cm5cblxuXHRcdGlmICggIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggZGlhbG9nVGVtcGxhdGVzLCBkaWFsb2dOYW1lICkgKSB7XG5cdFx0XHRhbGVydCggYEVycm9yOiBDb3VsZCBub3QgZmluZCBkaWFsb2cgbmFtZWRcXG5cIiR7IGRpYWxvZ05hbWUgfVwiYCApXG5cdFx0XHRyYS5kZXRhY2goICgpID0+IGFwcC5kaWFsb2cgPSBgYCApXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0bGV0IFRlbXBsYXRlID0gZGlhbG9nVGVtcGxhdGVzWyBkaWFsb2dOYW1lIF1cblx0XHRpZiAoICFUZW1wbGF0ZSApXG5cdFx0XHRyZXR1cm5cblx0XHRkaWFsb2dUZW1wbGF0ZXNbIGRpYWxvZ05hbWUgXSA9IG51bGxcblxuXHRcdGxldCBkaWFsb2cgPSBUZW1wbGF0ZSgpXG5cdFx0ZGlhbG9nLmNsYXNzTGlzdC5hZGQoIGRpYWxvZ05hbWUgKVxuXHRcdGRpYWxvZy5jbGFzc0xpc3QuYWRkKCBgbW9kYWxEaWFsb2dgIClcblx0XHRyYSgge1xuXHRcdFx0Z2V0IGlzQWN0aXZlKCkgeyByZXR1cm4gZGlhbG9nTmFtZSA9PSBhcHAuZGlhbG9nIH0sXG5cdFx0XHRnZXQgdXBkYXRlQ2xhc3MoKSB7XG5cdFx0XHRcdGxldCBldmVudFxuXHRcdFx0XHRpZiAoIHRoaXMuaXNBY3RpdmUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQgPSBgZGlhbG9nc2hvd2Bcblx0XHRcdFx0XHRkaWFsb2cuY2xhc3NMaXN0LmFkZCggYGRpYWxvZ1Nob3duYCApXG5cdFx0XHRcdFx0ZGlhbG9nLmNsYXNzTGlzdC5yZW1vdmUoIGBkaWFsb2dIaWRkZW5gIClcblx0XHRcdFx0XHRsZXQgaW5wdXQgPSBkaWFsb2cucXVlcnlTZWxlY3RvciggYCpbIGF1dG9mb2N1cyBdYCApXG5cdFx0XHRcdFx0aWYgKCBpbnB1dCApXG5cdFx0XHRcdFx0XHRhcHAuZm9jdXMoIGlucHV0IClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRldmVudCA9IGBkaWFsb2doaWRlYFxuXHRcdFx0XHRcdGRpYWxvZy5jbGFzc0xpc3QucmVtb3ZlKCBgZGlhbG9nU2hvd25gIClcblx0XHRcdFx0XHRkaWFsb2cuY2xhc3NMaXN0LmFkZCggYGRpYWxvZ0hpZGRlbmAgKVxuXHRcdFx0XHRcdGZvciAoIGxldCBlbGVtIG9mIGRpYWxvZy5xdWVyeVNlbGVjdG9yQWxsKCBgKjpmb2N1c2AgKSApXG5cdFx0XHRcdFx0XHRlbGVtLmJsdXIoKVxuXHRcdFx0XHRcdGRpYWxvZy5ibHVyKClcblx0XHRcdFx0fVxuXHRcdFx0XHRkaWFsb2cuZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KCBldmVudCwgeyBkZXRhaWw6IG51bGwgfSApIClcblx0XHRcdH0sXG5cdFx0fSApXG5cdFx0YXBwbGljYXRpb24uYXBwZW5kQ2hpbGQoIGRpYWxvZyApXG5cdH0gKVxuXG5cdHNldFRpbWVvdXQoICgpID0+IGFwcC5wYWdlU3RhcnRpbmcgPSBmYWxzZSwgMSApXG5cblx0cmV0dXJuIGFwcGxpY2F0aW9uXG59XG4iLCJsZXQgaHRtbHV0aWxzID0gcmVxdWlyZSggYGh0bWx1dGlsc2AgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiB7XG5cdGxldCAkID0ge31cblx0cmV0dXJuIDxkaXYgb25kaWFsb2dzaG93ID0geyAoKSA9PiB7XG5cdFx0JC5zdHJpbmcudmFsdWUgPSBhcHAuZ2V0TWVzc2FnZSggYXBwLmdldERldmljZSggYXBwLmFjdGl2ZURldmljZUlkICkgKVxuXHRcdCQuc3RyaW5nLnNldFNlbGVjdGlvblJhbmdlKCAwLCAkLnN0cmluZy52YWx1ZS5sZW5ndGggKVxuXHR9IH0gPlxuXHRcdDxwPtCd0LDQt9Cy0LDQvdC40LU6PC9wPlxuXHRcdDxmb3JtIG9uc3VibWl0ID0geyBldmVudCA9PiB7XG5cdFx0XHRldmVudCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRsZXQgbmFtZSA9ICQuc3RyaW5nLnZhbHVlLnRyaW0oKVxuXHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRpZiAoIG5hbWUgKVxuXHRcdFx0XHRhcHAucmVuYW1lSXRlbSggYXBwLmFjdGl2ZURldmljZUlkLCBuYW1lIClcblx0XHR9IH0gPlxuXHRcdFx0eyAkLnN0cmluZyA9IDx0ZXh0YXJlYSBuYW1lID0gXCJzdHJpbmdcIiBjb2xzID0gXCIzNVwiIHJvd3MgPSBcIjJcIiBhdXRvZm9jdXMgPSBcImF1dG9mb2N1c1wiIC8+IH1cblx0XHRcdDxwPjxhIGNsYXNzID0gXCJidXR0b25cIiBocmVmID0gXCJqYXZhc2NyaXB0OnZvaWQoMClcIiB0YXJnZXQgPSBcIl9zZWxmXCIgb250b3VjaCA9IHsgaHRtbHV0aWxzLlN1Ym1pdCB9ID7Ql9Cw0LrRgNGL0YLRjDwvYT48L3A+XG5cdFx0PC9mb3JtPlxuXHQ8L2Rpdj5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXBwID0+IHtcblx0bGV0IEJ1dHRvbiA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQnV0dG9uYCApIClcblx0cmV0dXJuIDxkaXY+XG5cdFx0PHA+0J/QvtC20LDQu9GD0LnRgdGC0LAsPGJyLz7Qv9C10YDQtdCy0LXQtNC40YLQtSDRg9GB0YLRgNC+0LnRgdGC0LLQviDQsiDRgNC10LbQuNC8PGJyLz7Qv9GA0L7Qs9GA0LDQvNC80LjRgNC+0LLQsNC90LjRjyDQuCDQvdCw0LbQvNC40YLQtTwvcD5cblx0XHQ8QnV0dG9uIG9uY2xpY2sgPSB7ICgpID0+IHtcblx0XHRcdGxldCBwbGFjZUlkID0gYXBwLmxpbmtpbmdQbGFjZUlkIHx8IGFwcC5hY3RpdmVEZXZpY2VJZFxuXHRcdFx0YXBwLmRpYWxvZyA9IGBTdGF0ZVdhaXRgXG5cdFx0XHRjby5nbyggZnVuY3Rpb24qICgpIHtcblx0XHRcdFx0eWllbGQgYXBwLmNvbW1hbmQoIHBsYWNlSWQsIGBMaW5rYCApXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgQXNrSWZEZXZpY2VIYXNCZWVuTGlua2VkYFxuXHRcdFx0XHRhcHAubGlua2luZ1BsYWNlSWQgPSBwbGFjZUlkXG5cdFx0XHR9ICkuY2F0Y2goIGVycm9yID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coIGVycm9yIClcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBFcnJvck5vQ2FycmllcmBcblx0XHRcdH0gKVxuXHRcdH0gfVxuXHRcdD7Qt9C00LXRgdGMPC9CdXR0b24+XG5cdDwvZGl2PlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4gKCBhdHRyLCBjb250ZW50ICkgPT5cblx0PGEgY2xhc3MgPSBcImJ1dHRvblwiIGhyZWYgPSBcImphdmFzY3JpcHQ6dm9pZCgwKVwiIHRhcmdldCA9IFwiX3NlbGZcIiBvbnRvdWNoID0geyBldmVudCA9PiB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdGlmICggdHlwZW9mIGF0dHIub25jbGljayA9PSBgc3RyaW5nYCApXG5cdFx0XHRhcHAuZGlhbG9nID0gYXR0ci5vbmNsaWNrXG5cdFx0ZWxzZSB7XG5cdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdGF0dHIub25jbGljayAmJiBhdHRyLm9uY2xpY2soKVxuXHRcdH1cblx0fSB9XG5cdF8gPSB7IE9iamVjdC5hc3NpZ24oIHt9LCBhdHRyLCB7IG9uY2xpY2s6IG51bGwgfSApIH1cblx0Pntcblx0XHRjb250ZW50XG5cdH08L2E+XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiAoIHsgb25jbGljaywgdXJsLCB2aXNpYmxlLCBlbmFibGVkLCBtZXNzYWdlIH0gKSA9PiB7XG5cdGxldCBjb250ZW50ID0gYXBwLm1lc3NhZ2UoIG1lc3NhZ2UgKVxuXHRsZXQgaXNFbmFibGVkID0gKCkgPT4gKCB1cmwgfHwgb25jbGljayApICYmICggIWVuYWJsZWQgfHwgZW5hYmxlZCgpIClcblx0aWYgKCB0eXBlb2YgdmlzaWJsZSA9PSBgc3RyaW5nYCApIHtcblx0XHRsZXQgZGV2aWNlVHlwZSA9IHZpc2libGVcblx0XHR2aXNpYmxlID0gKCkgPT4gYXBwLmRldmljZVR5cGUgPT0gZGV2aWNlVHlwZVxuXHR9XG5cdGxldCBjbGFzc05hbWUgPSAoKSA9PiBgY29tbWFuZCAkeyBtZXNzYWdlIH0gJHsgaXNFbmFibGVkKCkgPyBgZW5hYmxlZGAgOiBgZGlzYWJsZWRgIH0gJHsgdmlzaWJsZSA9PSBudWxsIHx8IHZpc2libGUoKSA/IGBpdGVtVmlzaWJsZWAgOiBgaXRlbUhpZGRlbmAgfWBcblx0aWYgKCB1cmwgJiYgIW9uY2xpY2sgKVxuXHRcdHJldHVybiA8YSBjbGFzcyA9IHsgY2xhc3NOYW1lIH0gaHJlZiA9IHsgdXJsIH0gcmVsID0gXCJleHRlcm5hbFwiIHRhcmdldCA9IFwiX2JsYW5rXCIgPnsgY29udGVudCB9PC9hPlxuXHRlbHNlXG5cdFx0cmV0dXJuIDxhIGNsYXNzID0geyBjbGFzc05hbWUgfSBocmVmID0gXCJqYXZhc2NyaXB0OnZvaWQoMClcIiB0YXJnZXQgPSBcIl9zZWxmXCIgb250b3VjaCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0aWYgKCBvbmNsaWNrICYmIGlzRW5hYmxlZCgpICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBvbmNsaWNrID09IGBzdHJpbmdgIClcblx0XHRcdFx0XHRhcHAuZGlhbG9nID0gb25jbGlja1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdFx0XHRvbmNsaWNrKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gfSA+eyBjb250ZW50IH08L2E+XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICggYXBwLCBsb2NhbCApID0+IHtcblx0bGV0IENvbW1hbmQgPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL0NvbW1hbmRgICkgKVxuXHRsZXQgQWRkRXhpc3RpbmdJdGVtID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9BZGRFeGlzdGluZ0l0ZW1gICkgKVxuXHRyZXR1cm4gPGRpdj5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZFNlYXJjaERldmljZXNcIlxuXHRcdFx0b25jbGljayA9IFwiU2VhcmNoSXRlbXNcIlxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRUb0Zhdm91cml0ZXNcIlxuXHRcdFx0dmlzaWJsZSA9IHsgKCkgPT4gIWFwcC5lZGl0aW5nICYmIGFwcC5hY3RpdmVEZXZpY2VJZCAhPSBhcHAubWFpbiB9XG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiB7XG5cdFx0XHRcdGFwcC5saW5rQWN0aXZlVG9GYXZvdXJpdGVzKClcblx0XHRcdFx0YXBwLm5vdGlmaWNhdGlvbiggYNCU0L7QsdCw0LLQu9C10L3QviDQsiDQuNC30LHRgNCw0L3QvdC+0LVgIClcblx0XHRcdH0gfVxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRMaW5rRGV2aWNlXCJcblx0XHRcdHZpc2libGUgPSBcImRldmljZVwiXG5cdFx0XHRvbmNsaWNrID0gXCJBc2tUb0xpbmtEZXZpY2VcIlxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRBZGRcIlxuXHRcdFx0dmlzaWJsZSA9IHsgKCkgPT4gIWFwcC5lZGl0aW5nICYmIGFwcC5kZXZpY2VUeXBlID09IGBwbGFjZWAgfVxuXHRcdFx0b25jbGljayA9IFwiQWRkTWVudVwiXG5cdFx0Lz5cblx0XHQ8QWRkRXhpc3RpbmdJdGVtXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuZGV2aWNlVHlwZSA9PSBgZ3JvdXBgIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kTW92ZUljb25zXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuZGV2aWNlVHlwZSAhPSBgc2luZ2xlYCB9XG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiBhcHAuZWRpdGluZyA9IHRydWUgfVxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRSZW5hbWVJdGVtXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyB9XG5cdFx0XHRvbmNsaWNrID0gXCJBc2tOZXdOYW1lXCJcblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kUHVyZ2VJdGVtXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuYWN0aXZlRGV2aWNlSWQgIT0gYXBwLm1haW4gfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4ge1xuXHRcdFx0XHRhcHAuZGlhbG9nID0gYERlbGV0ZURldmljZWBcblx0XHRcdFx0Ly8gYXBwLnB1cmdlSXRlbSggYXBwLmFjdGl2ZURldmljZUlkIClcblx0XHRcdH0gfVxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRTaG93TGFiZWxzXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFsb2NhbC5sYWJlbHMgJiYgYXBwLmFjdGl2ZURldmljZUlkID09IGFwcC5tYWluIH1cblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IGxvY2FsLmxhYmVscyA9IHRydWUgfVxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRIaWRlTGFiZWxzXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+IGxvY2FsLmxhYmVscyAmJiBhcHAuYWN0aXZlRGV2aWNlSWQgPT0gYXBwLm1haW4gfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4gbG9jYWwubGFiZWxzID0gZmFsc2UgfVxuXHRcdC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRSZXNldFRvRmFjdG9yeVNldHRpbmdzXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+IGFwcC5hY3RpdmVEZXZpY2VJZCA9PSBhcHAubWFpbiB9XG5cdFx0XHRlbmFibGVkID0geyAoKSA9PiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgIT0gYHRlc3Quc2gubmVyb2VsZWN0cm9uaWNzLmJ5YCB9XG5cdFx0XHRvbmNsaWNrID0gXCJBc2tUb1Jlc2V0XCJcblx0XHQvPlxuXHQ8L2Rpdj5cbn1cbiIsImxldCBsb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5sZXQgaHRtbHV0aWxzID0gcmVxdWlyZSggYGh0bWx1dGlsc2AgKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggYXBwLCBsb2NhbCApID0+ICggeyBwbGFjZUlkLCBpY29uSWQsIGljb25EZXNjciwgcG9zaXRpb24gfSApID0+IHtcblx0Ly8gVE9ETzogcmVmYWN0b3Jpbmc6IG1vdmUgdG8gbW9yZSBKU1ggKD8pXG5cdC8vIFRPRE86IG9uVGFwLCBvblByZXNzLCBvbkNsaWNrIGhhbmRsZXJzIG11c3QgcmVtb3ZlIHRoZW1zZWxmIHdoZW4gdGhyZWFkIGlzIGJlaW5nIGtpbGxlZFxuXHRsZXQgaWNvbiwgb2ZmLCBvbiwgYWJzZW50LCBpbWFnZVxuXHRsZXQgaXNNb3VzZSA9IGZhbHNlXG5cblx0bGV0IHBsYWNlUmVjdCA9IGh0bWx1dGlscy50aWNrQ2FjaGUoICgpID0+IHtcblx0XHRsZXQgeCA9IGljb24ucGFyZW50Tm9kZVxuXHRcdGxldCByXG5cdFx0d2hpbGUgKCByID0geC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgIXIud2lkdGggfHwgIXIuaGVpZ2h0IClcblx0XHRcdHggPSB4LnBhcmVudE5vZGVcblx0XHRyZXR1cm4gclxuXHR9IClcblxuXHRsZXQgcmVsUG9pbnQgPSBwID0+IHtcblx0XHRsZXQgciA9IHBsYWNlUmVjdCgpXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6ICggcC54IC0gci5sZWZ0ICkgLyByLndpZHRoICogMTAwLFxuXHRcdFx0eTogKCBwLnkgLSByLnRvcCApIC8gci5oZWlnaHQgKiAxMDAsXG5cdFx0fVxuXHR9XG5cblx0bGV0IGdldFBvaW50ID0gZGF0YSA9PiB7XG5cdFx0cmV0dXJuIHJlbFBvaW50KCB7IHg6IGRhdGEucGFnZVgsIHk6IGRhdGEucGFnZVkgfSApXG5cdH1cblxuXHRsZXQgZ2V0TGVmdFRvcCA9IGRhdGEgPT4ge1xuXHRcdGxldCBwID0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXHRcdHJldHVybiByZWxQb2ludCggeyB4OiBwLmxlZnQsIHk6IHAudG9wIH0gKVxuXHR9XG5cblx0Ly8gbGV0IGljb25zQ291bnQgPSAoKSA9PiB7XG5cdC8vIFx0bGV0IHBsYWNlID0gYXBwLmdldERldmljZSggcGxhY2VJZCApXG5cdC8vIFx0cmV0dXJuIGxvZGFzaC5rZXlzKCBwbGFjZSAmJiBwbGFjZS5jb250ZW50ICkubGVuZ3RoXG5cdC8vIH1cblxuXHRsZXQgaW1hZ2VIZWlnaHQgPSBodG1sdXRpbHMudGlja0NhY2hlKCAoKSA9PiB7XG5cdFx0aWYgKCAhaXNNb3VzZSApXG5cdFx0XHRyZXR1cm4gaWNvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblx0XHRpZiAoIG9wdHMuaWNvbkRhdGEgKSB7XG5cdFx0XHRpZiAoIG9wdHMuaWNvbkRhdGEuZGV2aWNlSW1hZ2VHZXRIZWlnaHQgKSB7XG5cdFx0XHRcdGxldCByID0gb3B0cy5pY29uRGF0YS5kZXZpY2VJbWFnZUdldEhlaWdodCgpXG5cdFx0XHRcdGlmICggciApXG5cdFx0XHRcdFx0cmV0dXJuIHJcblx0XHRcdH1cblx0XHRcdGxldCBoID0gb3B0cy5pY29uRGF0YS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBgZGV2aWNlX2ltYWdlX2hlaWdodGAgKVsgMCBdXG5cdFx0XHRpZiAoIGggIT0gbnVsbCAmJiBoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCApIHtcblx0XHRcdFx0bGV0IHIgPSBoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuXHRcdFx0XHRpZiAoIHIgKVxuXHRcdFx0XHRcdHJldHVybiByXG5cdFx0XHR9XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvcHRzLmljb25EYXRhLmNoaWxkTm9kZXMubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdGxldCByID0gb3B0cy5pY29uRGF0YS5jaGlsZE5vZGVzLml0ZW0oIGkgKVxuXHRcdFx0XHRpZiAoIHIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICkge1xuXHRcdFx0XHRcdHIgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuXHRcdFx0XHRcdGlmICggciApXG5cdFx0XHRcdFx0XHRyZXR1cm4gclxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbWFnZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblx0fSApXG5cblx0bGV0IG9wdHMgPSByYSgge1xuXG5cdFx0Z2V0IGljb25OYW1lKCkgeyByZXR1cm4gaWNvbkRlc2NyICYmIGljb25EZXNjci52YWx1ZU9mKCkgJiYgaWNvbkRlc2NyLnZhbHVlT2YoKS5pY29uIHx8IG51bGwgfSxcblx0XHRnZXQgaWNvblRlbXBsYXRlKCkgeyByZXR1cm4gdGhpcy5pY29uTmFtZSAmJiBhcHAuaWNvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBhcHAuaWNvbnMsIHRoaXMuaWNvbk5hbWUgKSAmJiBhcHAuaWNvbnNbIHRoaXMuaWNvbk5hbWUgXSB8fCBudWxsIH0sXG5cdFx0aWNvbkRhdGE6IG51bGwsXG5cdFx0Z2V0IHVwZGF0ZUljb25EYXRhU3RhdGUoKSB7XG5cdFx0XHRsZXQgZGF0YSA9IHRoaXMuaWNvbkRhdGFcblx0XHRcdGlmICggZGF0YSAmJiBkYXRhLmRldmljZVNldFN0YXRlIClcblx0XHRcdFx0ZGF0YS5kZXZpY2VTZXRTdGF0ZSggdGhpcy5zdGF0ZSApXG5cdFx0fSxcblxuXHRcdGdldCBkaW1tZXJpbmcoKSB7XG5cdFx0XHRsZXQgaSA9IGljb25EZXNjciA9PSBudWxsID8gbnVsbCA6IGljb25EZXNjci52YWx1ZU9mKClcblx0XHRcdGxldCBpZCA9IGkgPT0gbnVsbCA/IG51bGwgOiBpLmRpbW1lcmluZyA9PSBudWxsID8gbnVsbCA6ICEhaS5kaW1tZXJpbmdcblx0XHRcdGlmICggaWQgIT0gbnVsbCApXG5cdFx0XHRcdHJldHVybiBpZFxuXHRcdFx0aWYgKCBpICE9IG51bGwgJiYgaS50eXBlID09PSBgcGxhY2VgIClcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH0sXG5cdFx0Z2V0IGltYWdlX29uKCkge1xuXHRcdFx0bGV0IGkgPSBpY29uRGVzY3IgJiYgaWNvbkRlc2NyLnZhbHVlT2YoKVxuXHRcdFx0bGV0IGZpbGUgPSBgYFxuXHRcdFx0XHR8fCBpICYmIGkuaW1hZ2Vfb25cblx0XHRcdFx0fHwgaSAmJiBpLmltYWdlXG5cdFx0XHRyZXR1cm4gZmlsZSAmJiBgL2ltYWdlcy8keyBmaWxlIH1gXG5cdFx0fSxcblx0XHRnZXQgdXBkYXRlX2ltYWdlX29uKCkge1xuXHRcdFx0aWYgKCBvcHRzLmltYWdlX29uIClcblx0XHRcdFx0b24uc3JjID0gb3B0cy5pbWFnZV9vblxuXHRcdH0sXG5cdFx0Z2V0IGltYWdlX29mZigpIHtcblx0XHRcdGxldCBpID0gaWNvbkRlc2NyICYmIGljb25EZXNjci52YWx1ZU9mKClcblx0XHRcdGxldCBmaWxlID0gYGBcblx0XHRcdFx0fHwgaSAmJiBpLmltYWdlX29mZlxuXHRcdFx0XHR8fCBpICYmIGkuaW1hZ2Vcblx0XHRcdHJldHVybiBmaWxlICYmIGAvaW1hZ2VzLyR7IGZpbGUgfWBcblx0XHR9LFxuXHRcdGdldCB1cGRhdGVfaW1hZ2Vfb2ZmKCkge1xuXHRcdFx0aWYgKCBvcHRzLmltYWdlX29mZiApXG5cdFx0XHRcdG9mZi5zcmMgPSBvcHRzLmltYWdlX29mZlxuXHRcdH0sXG5cblx0XHRpY29uQ29tbWFuZCggY21kLCBkYXRhICkgeyByZXR1cm4gYXBwLmljb25Db21tYW5kKCBpY29uRGVzY3IsIGljb25JZCwgY21kLCBkYXRhICkgfSxcblxuXHRcdGlzRGltbWVyaW5nOiBmYWxzZSxcblx0XHRtb3Zpbmc6IGZhbHNlLFxuXHRcdG1vdmVkOiBmYWxzZSxcblx0XHR4OiBudWxsLFxuXHRcdHk6IG51bGwsXG5cblx0XHRnZXQgcHJlc2VudCgpIHsgcmV0dXJuICEhKCBpY29uRGVzY3IuZ2V0KCBgY29udGVudGAgKSB8fCBpY29uRGVzY3IuZ2V0KCBgZ3JvdXBgICkgKSB9LFxuXHRcdHN0YXRlOiAwLFxuXHRcdG9ubmluZzogZmFsc2UsXG5cdFx0b2ZmaW5nOiBmYWxzZSxcblx0XHRmaW5hbDogdHJ1ZSxcblx0XHRlcnJvcm5lb3VzOiBmYWxzZSxcblx0XHRnZXQgdXBkYXRlU3RhdGUoKSB7XG5cdFx0XHRsZXQgZCA9IGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpXG5cdFx0XHRpZiAoICFkIClcblx0XHRcdFx0cmV0dXJuIDBcblx0XHRcdGlmICggZC5uZXdzdGF0ZV90aW1lc3RhbXAgJiYgKCAhZC5zdGF0ZV90aW1lc3RhbXAgfHwgZC5uZXdzdGF0ZV90aW1lc3RhbXAgPiBkLnN0YXRlX3RpbWVzdGFtcCApICkge1xuXHRcdFx0XHRsZXQgZm9ubmluZyA9IGQubmV3c3RhdGUgPj0gZC5zdGF0ZVxuXHRcdFx0XHR0aGlzLm9ubmluZyA9IGZvbm5pbmdcblx0XHRcdFx0dGhpcy5vZmZpbmcgPSAhZm9ubmluZ1xuXHRcdFx0XHR0aGlzLmZpbmFsID0gZmFsc2Vcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IGQubmV3c3RhdGVcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9ubmluZyA9IGZhbHNlXG5cdFx0XHRcdHRoaXMub2ZmaW5nID0gZmFsc2Vcblx0XHRcdFx0dGhpcy5maW5hbCA9IHRydWVcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IGQuc3RhdGVcblx0XHRcdH1cblx0XHRcdHRoaXMuZXJyb3JuZW91cyA9ICEhZC5lcnJvcm5lb3VzXG5cdFx0fSxcblxuXHRcdHNldE9wYWNpdHkoIG5vZGUsIG9wYWNpdHkgKSB7XG5cdFx0XHRpZiAoIG9wYWNpdHkgPT0gbnVsbCApIHtcblx0XHRcdFx0ZGVsZXRlIG5vZGUuc3R5bGUub3BhY2l0eVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG5vZGUuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHlcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldCB1cGRhdGVPcGFjaXR5KCkge1xuXHRcdFx0aWYgKCB0aGlzLmljb25UZW1wbGF0ZSApIHtcblx0XHRcdFx0b24uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCJcblx0XHRcdFx0b2ZmLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiXG5cdFx0XHRcdGFic2VudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIlxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICF0aGlzLnByZXNlbnQgKSB7XG5cdFx0XHRcdHRoaXMuc2V0T3BhY2l0eSggb24sIDAgKVxuXHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9mZiwgMCApXG5cdFx0XHRcdHRoaXMuc2V0T3BhY2l0eSggYWJzZW50LCAwLjcgKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0T3BhY2l0eSggYWJzZW50LCAwIClcblx0XHRcdFx0aWYgKCB0aGlzLmRpbW1lcmluZyApIHtcblx0XHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9uLCB0aGlzLnN0YXRlIClcblx0XHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9mZiwgKCAxIC0gdGhpcy5zdGF0ZSApICogMC4zMzMgKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2V0T3BhY2l0eSggb24sICshIXRoaXMuc3RhdGUgKVxuXHRcdFx0XHRcdHRoaXMuc2V0T3BhY2l0eSggb2ZmLCArIXRoaXMuc3RhdGUgKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0fSApXG5cblx0Y29uc3QgTU9WRV9QQUdFX0RJU1QgPSAwLjFcblx0Y29uc3QgTU9WRV9TSURFX0RJU1QgPSAwLjI1XG5cblx0ZnVuY3Rpb24gY29tcGFyZUluZGV4KCBhLCBiICkge1xuXHRcdHJldHVybiBhLmluZGV4IC0gYi5pbmRleFxuXHR9XG5cblx0bGV0IG1vdmUgPSBmdW5jdGlvbiogKCBzdGFydCwgbmV4dCApIHtcblx0XHRpZiAoIG9wdHMubW92aW5nIClcblx0XHRcdG9wdHMubW92aW5nLmtpbGwoIGByZXN0YXJ0aW5nIGJ5IGFub3RoZXIgZmluZ2VyYCApXG5cblx0XHRsZXQgY2hhbmdlcyA9IGFwcC5sb2NhbERldmljZXMuY3JlYXRlUmVjb3JkKClcblx0XHRsZXQgY3VycmVudFBvc2l0aW9uID0gcG9zaXRpb24udmFsdWVPZigpXG5cdFx0bGV0IGRvbmUgPSBmYWxzZVxuXG5cdFx0Ly8gVE9ETzogYWxsIHJhIHN0cnVjdHVyZXMgbXVzdCBiZSBsaW5rZWQgdG8gdGhlIGN1cnJlbnQgdGhyZWFkIGFuZCBtdXN0IGxpbmsgYWxsIHRoZXJlIHRpY2sgcHJvY3MgdG8gdGhlIGN1cnJlbnQgdGhyZWFkIGFuZCBzbyB1cGRhdGUgYWxsIHRoZXJlIHRpY2tzIG9uIHN1YnNlcXVlbnQgeWllbGQgYW5kIGFsc28gdXBkYXRlIHRoZW0gYWxsIHdoaWxlIGZpbmlzaGluZyB0aHJlYWQgZWl0aGVyIG5vcm1hbCBvciBhYm5vcm1hbCBhbmQgdGhlbiBzdWNoIHJhIHN0cnVjdHVyZXMgbXVzdCBiZSBkZXN0cm95ZWQgdG8gdW5saW5rIGZyb20gYW55IGV4dGVybmFsIGRlcGVuZGVuY3kuIFRoaXMgbXVzdCBiZSBkb25lIHZpYSBpbXBsZW1lbnRpbmcgY28ubmV4dFRpY2sgaW4gdGVybXMgbGlrZSBpb2pzLnByb2Nlc3MubmV4dFRpY2sgLSBuZXh0VGljayBjYWxsYmFja3MgbXVzdCBiZSBwcm9jZXNzZWQgYmVmb3JlIHlpZWxkaW5nIHN1YnNlcXVlbnQgcmVzdWx0LiBTbyBpdCBpcyBwb3NzaWJsZSB0byBsZXQgZXhjZXB0aW9ucyBiZSByYWlzZWQgaW4gcHJvcGVyIHdheS4gQW5kIGl0IG1lYW5zIHRoYXQgaWYgcG9zc2libGUgbmV4dFRpY2sgY2FsbGJhY2tzIHdpbGwgZmlyZSBqdXN0IGFmdGVyIHJlcXVlc3QgZm9yIG5leHQgeWllbGQuXG5cblx0XHRsZXQgaG92ZXIgPSByYSgge1xuXHRcdFx0c2F2ZWRJZDogbnVsbCxcblx0XHRcdGNhY2hlZElkOiBudWxsLFxuXHRcdFx0aWQ6IG51bGwsXG5cdFx0XHRwb3NpdGlvbjogbnVsbCxcblxuXHRcdFx0dXBkYXRlQXBwKCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNhdmVkSWQgKVxuXHRcdFx0XHRcdGFwcC5ob3ZlciA9IGx1LmFwcGx5RGlmZiggYXBwLmhvdmVyLCB7IFsgdGhpcy5zYXZlZElkIF06IHsgWyBwbGFjZUlkIF06IHsgWyBpY29uSWQgXTogdmFsdWUgfSB9IH0gKVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVE9ETzogaW5zZXJ0IGRlYm91bmNlIG1lY2hhbmlzbSBqdXN0IGludG8gcmFcblx0XHRcdGdldCB1cGRhdGVDYWNoZSgpIHsgLy8gZGVib3VuY2UgaWQgY2hhbmdpbmdcblx0XHRcdFx0dGhpcy5jYWNoZWRJZCA9IHRoaXMuaWRcblx0XHRcdH0sXG5cblx0XHRcdGdldCBzYXZlSWQoKSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlQXBwKCBudWxsIClcblx0XHRcdFx0dGhpcy5zYXZlZElkID0gdGhpcy5jYWNoZWRJZFxuXHRcdFx0XHR0aGlzLnVwZGF0ZUFwcCggdHJ1ZSApXG5cdFx0XHR9LFxuXHRcdH0gKVxuXG5cdFx0dHJ5IHtcblx0XHRcdGxldCBzZWxmID0gY28uY3VycmVudFxuXHRcdFx0cmEoICgpID0+ICFkb25lICYmICFhcHAuZWRpdGluZyAmJiBzZWxmLmtpbGwoKSApXG5cblx0XHRcdGxldCBwID0gZ2V0UG9pbnQoIHN0YXJ0IClcblx0XHRcdGxldCByID0gZ2V0TGVmdFRvcCggaWNvbiApXG5cdFx0XHRvcHRzLm1vdmluZyA9IGNvLmN1cnJlbnRcblx0XHRcdG9wdHMubW92ZWQgPSBmYWxzZVxuXHRcdFx0bGV0IGZpbmdlclNoaWZ0ID0ge1xuXHRcdFx0XHR4OiByLnggLSBwLngsXG5cdFx0XHRcdHk6IHIueSAtIHAueSxcblx0XHRcdH1cblx0XHRcdG9wdHMueCA9IHIueFxuXHRcdFx0b3B0cy55ID0gci55XG5cblx0XHRcdGZvciAoIGxldCBwdDsgcHQgPSB5aWVsZCBuZXh0OyApIHtcblx0XHRcdFx0bGV0IGZpbmdlciA9IGdldFBvaW50KCBwdCApXG5cdFx0XHRcdGxldCBjb3JuZXIgPSB7XG5cdFx0XHRcdFx0eDogZmluZ2VyLnggKyBmaW5nZXJTaGlmdC54LFxuXHRcdFx0XHRcdHk6IGZpbmdlci55ICsgZmluZ2VyU2hpZnQueSxcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wdHMueCAhPSBjb3JuZXIueCB8fCBvcHRzLnkgIT0gY29ybmVyLnkgKVxuXHRcdFx0XHRcdG9wdHMubW92ZWQgPSB0cnVlXG5cdFx0XHRcdG9wdHMueCA9IGNvcm5lci54XG5cdFx0XHRcdG9wdHMueSA9IGNvcm5lci55XG5cblx0XHRcdFx0bGV0IHBhZ2VTaXplID0ge1xuXHRcdFx0XHRcdHg6IGFwcC5wYWdlV2lkdGgsXG5cdFx0XHRcdFx0eTogYXBwLnBhZ2VIZWlnaHQsXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGNlbGxTaXplID0ge1xuXHRcdFx0XHRcdHg6IDEwMCAvIHBhZ2VTaXplLngsXG5cdFx0XHRcdFx0eTogMTAwIC8gcGFnZVNpemUueSxcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaW5kZXggPSB7XG5cdFx0XHRcdFx0eDogTWF0aC5taW4oIHBhZ2VTaXplLnggLSAxLCBNYXRoLm1heCggMCwgTWF0aC5mbG9vciggZmluZ2VyLnggLyBjZWxsU2l6ZS54ICkgKSApLFxuXHRcdFx0XHRcdHk6IE1hdGgubWluKCBwYWdlU2l6ZS55IC0gMSwgTWF0aC5tYXgoIDAsIE1hdGguZmxvb3IoIGZpbmdlci55IC8gY2VsbFNpemUueSApICkgKSxcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaW5DZWxsID0ge1xuXHRcdFx0XHRcdHg6IGZpbmdlci54IC8gY2VsbFNpemUueCAtIGluZGV4LngsXG5cdFx0XHRcdFx0eTogZmluZ2VyLnkgLyBjZWxsU2l6ZS55IC0gaW5kZXgueSxcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBwbGFjZVBvc2l0aW9uID0gaW5kZXgueCArIGluZGV4LnkgKiBwYWdlU2l6ZS54ICsgKCBsb2NhbC5wbGFjZXNQYWdlc1sgcGxhY2VJZCBdIHx8IDAgKSAqIHBhZ2VTaXplLnggKiBwYWdlU2l6ZS55XG5cblx0XHRcdFx0bGV0IGlzSW5DZW50ZXIgPSBpbkNlbGwueCA+IE1PVkVfU0lERV9ESVNUICYmIGluQ2VsbC54IDwgMSAtIE1PVkVfU0lERV9ESVNUICYmIGluQ2VsbC55ID4gTU9WRV9TSURFX0RJU1QgJiYgaW5DZWxsLnkgPCAxIC0gTU9WRV9TSURFX0RJU1RcblxuXHRcdFx0XHRpZiAoICFpc0luQ2VudGVyIHx8IGhvdmVyLnBvc2l0aW9uICE9IHBsYWNlUG9zaXRpb24gKVxuXHRcdFx0XHRcdGhvdmVyLmlkID0gbnVsbFxuXHRcdFx0XHRob3Zlci5wb3NpdGlvbiA9IHBsYWNlUG9zaXRpb25cblxuXHRcdFx0XHRpZiAoIHB0LnR5cGUgIT0gYHN0b3BgIClcblx0XHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRcdGhvdmVyLmlkID0gbnVsbFxuXG5cdFx0XHRcdGlmICggaW5DZWxsID4gMSAtIE1PVkVfUEFHRV9ESVNUICYmIGNlbGxTaXplLnggPT0gcGFnZVNpemUueCAtIDEgKSB7XG5cdFx0XHRcdFx0Ly8gVE9ETzogc2Nyb2xsIHBhZ2UgcmlnaHRcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggaW5DZWxsIDwgTU9WRV9QQUdFX0RJU1QgJiYgY2VsbFNpemUueCA9PSBwYWdlU2l6ZS54IC0gMSApIHtcblx0XHRcdFx0XHQvLyBUT0RPOiBzY3JvbGwgcGFnZSBsZWZ0XG5cdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBwbGFjZSA9IGx1LmdldCggY2hhbmdlcywgYHN1bW1hcnlgLCBgY29udGVudGAsIHBsYWNlSWQsIGBjb250ZW50YCApXG5cdFx0XHRcdGlmICggIXBsYWNlIHx8ICFwbGFjZVsgaWNvbklkIF0gKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRsZXQga2V5cyA9IGxvZGFzaC5rZXlzKCBwbGFjZSApXG5cdFx0XHRcdFx0Lm1hcCgga2V5ID0+ICggeyBrZXksIGluZGV4OiBwbGFjZVsga2V5IF0uaW5kZXggfSApIClcblx0XHRcdFx0XHQuc29ydCggY29tcGFyZUluZGV4IClcblxuXHRcdFx0XHRsZXQgbmV3SW5kZXhcblxuXHRcdFx0XHRpZiAoIHBsYWNlUG9zaXRpb24gPCAwICkge1xuXHRcdFx0XHRcdGlmICggY3VycmVudFBvc2l0aW9uIDw9IDAgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRuZXdJbmRleCA9IGtleXNbIDAgXS5pbmRleCAtIDFcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggcGxhY2VQb3NpdGlvbiA+IGtleXMubGVuZ3RoIC0gMSApIHtcblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRQb3NpdGlvbiA+PSBrZXlzLmxlbmd0aCAtIDEgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRuZXdJbmRleCA9IGtleXNbIGtleXMubGVuZ3RoIC0gMSBdLmluZGV4ICsgMVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICggY3VycmVudFBvc2l0aW9uID09IHBsYWNlUG9zaXRpb24gKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRpZiAoIGlzSW5DZW50ZXIgKSB7XG5cdFx0XHRcdFx0XHQvLyBUT0RPXG5cdFx0XHRcdFx0XHRob3Zlci5pZCA9IGtleXNbIHBsYWNlUG9zaXRpb24gXS5rZXlcblx0XHRcdFx0XHRcdGxldCBzcmNUeXBlID0gaWNvbkRlc2NyICYmIGljb25EZXNjci52YWx1ZU9mKCkgJiYgaWNvbkRlc2NyLnZhbHVlT2YoKS50eXBlXG5cdFx0XHRcdFx0XHRsZXQgZHN0RGV2aWNlID0gYXBwLmdldERldmljZSggaG92ZXIuaWQgKVxuXHRcdFx0XHRcdFx0bGV0IGRzdFR5cGUgPSBkc3REZXZpY2UgJiYgZHN0RGV2aWNlLnR5cGVcblx0XHRcdFx0XHRcdGlmICggZHN0VHlwZSA9PSBgcGxhY2VgIClcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdGlmICggZHN0VHlwZSA9PSBgZ3JvdXBgICYmIHNyY1R5cGUgPT0gYHNpbmdsZWAgKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogYWxsb3cgZHN0VHlwZSA9PSBgc2luZ2xlYCAmJiBzcmNUeXBlID09IGBzaW5nbGVgXG5cdFx0XHRcdFx0XHRob3Zlci5pZCA9IG51bGxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBpbkNlbGwueCA+IDAuNSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VycmVudFBvc2l0aW9uID09IHBsYWNlUG9zaXRpb24gKyAxIClcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdGlmICggaW5kZXgueCA9PSBwYWdlU2l6ZS54IC0gMSAmJiBjdXJyZW50UG9zaXRpb24gPiBwbGFjZVBvc2l0aW9uIClcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdGlmICggcGxhY2VQb3NpdGlvbiA+PSBrZXlzLmxlbmd0aCAtIDEgKVxuXHRcdFx0XHRcdFx0XHRuZXdJbmRleCA9IGtleXNbIHBsYWNlUG9zaXRpb24gXS5pbmRleCArIDFcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0bmV3SW5kZXggPSAoIGtleXNbIHBsYWNlUG9zaXRpb24gXS5pbmRleCArIGtleXNbIHBsYWNlUG9zaXRpb24gKyAxIF0uaW5kZXggKSAvIDJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnRQb3NpdGlvbiA9PSBwbGFjZVBvc2l0aW9uIC0gMSApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4LnggPT0gMCAmJiBjdXJyZW50UG9zaXRpb24gPCBwbGFjZVBvc2l0aW9uIClcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdGlmICggcGxhY2VQb3NpdGlvbiA8PSAwIClcblx0XHRcdFx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyBwbGFjZVBvc2l0aW9uIF0uaW5kZXggLSAxXG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdG5ld0luZGV4ID0gKCBrZXlzWyBwbGFjZVBvc2l0aW9uIF0uaW5kZXggKyBrZXlzWyBwbGFjZVBvc2l0aW9uIC0gMSBdLmluZGV4ICkgLyAyXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IG5ld1Bvc2l0aW9uID0ga2V5cy5tYXAoIGsgPT4gay5rZXkgIT0gaWNvbklkID8gayA6IHsga2V5OiBrLmtleSwgaW5kZXg6IG5ld0luZGV4IH0gKS5zb3J0KCBjb21wYXJlSW5kZXggKS5maW5kSW5kZXgoIGsgPT4gay5rZXkgPT0gaWNvbklkIClcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRQb3NpdGlvbiA9PSBuZXdQb3NpdGlvbiApXG5cdFx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0XHRjdXJyZW50UG9zaXRpb24gPSBuZXdQb3NpdGlvblxuXHRcdFx0XHRjaGFuZ2VzLmFzc2lnbiggeyBjb250ZW50OiB7IFsgcGxhY2VJZCBdOiB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXTogeyBpbmRleDogbmV3SW5kZXggfSB9IH0gfSB9IClcblx0XHRcdH1cblx0XHRcdGRvbmUgPSB0cnVlXG5cdFx0XHRpZiAoIGhvdmVyLmlkICkge1xuXHRcdFx0XHRjaGFuZ2VzLmNsb3NlKClcblx0XHRcdFx0Ly8gVE9ET1xuXHRcdFx0XHQvLyBsZXQgbmV3UGxhY2UgPSBhcHAuZ2V0RGV2aWNlKCBob3Zlci5pZCApXG5cdFx0XHRcdC8vIGlmICggbmV3UGxhY2UgJiYgbmV3UGxhY2UudHlwZSA9PSBgc2luZ2xlYCApIHtcblx0XHRcdFx0Ly8gXHRhcHAubGlua2luZ0RldmljZXMgPSBbIGhvdmVyLmlkLCBpY29uSWQgXVxuXHRcdFx0XHQvLyBcdGFwcC5kaWFsb2cgPSBgQ3JlYXRlUGxhY2VPckdyb3VwYFxuXHRcdFx0XHQvLyB9XG5cdFx0XHRcdC8vIGVsc2Vcblx0XHRcdFx0YXBwLmluc2VydEludG8oIGhvdmVyLmlkLCBpY29uSWQsIHBsYWNlSWQgKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHlpZWxkIGNvLnNsZWVwKClcblx0XHRcdFx0bHUud2hlbiggY2hhbmdlcy5zYXZlKCksICgpID0+IGNoYW5nZXMuY2xvc2UoKSApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0aG92ZXIuaWQgPSBudWxsXG5cdFx0XHRpZiAoICFkb25lICkge1xuXHRcdFx0XHRkb25lID0gdHJ1ZVxuXHRcdFx0XHRjaGFuZ2VzLmNsb3NlKClcblx0XHRcdH1cblx0XHRcdGlmICggb3B0cy5tb3ZpbmcgPT0gY28uY3VycmVudCApIHtcblx0XHRcdFx0b3B0cy5tb3ZpbmcgPSBudWxsXG5cdFx0XHRcdG9wdHMubW92ZWQgPSBmYWxzZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGxldCBkaW1tID0gZnVuY3Rpb24qICggbmV4dCApIHtcblx0XHRsZXQgY2hhbmdlcyA9IGFwcC5sb2NhbERldmljZXMuY3JlYXRlUmVjb3JkKClcblx0XHR0cnkge1xuXHRcdFx0bGV0IHN0YXRlXG5cdFx0XHRvcHRzLmlzRGltbWVyaW5nID0gdHJ1ZVxuXHRcdFx0bGV0IGluaXRpYWxEaW1tZXJpbmdTdGF0ZSA9IGljb25EZXNjciAmJiBpY29uRGVzY3IuZ2V0KCBgc3RhdGVgIClcblx0XHRcdGZvciAoIGxldCBwdDsgcHQgPSB5aWVsZCBuZXh0OyApIHtcblx0XHRcdFx0aWYgKCBwdC5kZXRhaWwudHlwZSA9PSBgc3dpcGVgICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGB1cGAgKVxuXHRcdFx0XHRcdFx0c3RhdGUgPSAxXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0c3RhdGUgPSAwXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGRlbHRhID0gLXB0LmRlbHRhWSAvICggaW1hZ2VIZWlnaHQoKSAqIDEuMCAvKiBtb3ZlIG11bHRpcGx5ZXIgKi8gKVxuXHRcdFx0XHRcdHN0YXRlID0gTWF0aC5taW4oIDEsIE1hdGgubWF4KCAwLCBpbml0aWFsRGltbWVyaW5nU3RhdGUgKyBkZWx0YSApIClcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09IDAgfHwgc3RhdGUgPT0gMSApXG5cdFx0XHRcdFx0XHRpbml0aWFsRGltbWVyaW5nU3RhdGUgPSBzdGF0ZSAtIGRlbHRhXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hhbmdlcy51cGRhdGUoIHsgY29udGVudDogeyBbIGljb25JZCBdOiB7IHN0YXRlIH0gfSB9IClcblx0XHRcdH1cblx0XHRcdGlmICggc3RhdGUgIT0gbnVsbCApXG5cdFx0XHRcdG9wdHMuaWNvbkNvbW1hbmQoIGBTZXRgLCBzdGF0ZSApXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0Y2hhbmdlcy5jbG9zZSgpXG5cdFx0XHRvcHRzLmlzRGltbWVyaW5nID0gZmFsc2Vcblx0XHR9XG5cdH1cblxuXHRsZXQgUGljdHVyZSA9IGF0dHJpYnV0ZXMgPT4gPGltZ1xuXHRcdGNsYXNzID0gXCJlcnJvclwiXG5cdFx0b25lcnJvciA9IHsgZnVuY3Rpb24gKCkgeyB0aGlzLmNsYXNzTGlzdC5hZGQoIGBlcnJvcmAgKSB9IH1cblx0XHRvbmxvYWQgPSB7IGZ1bmN0aW9uICgpIHsgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCBgZXJyb3JgICkgfSB9XG5cdFx0XyA9IHsgYXR0cmlidXRlcyB9XG5cdC8+XG5cblx0cmV0dXJuIDxkaXZcblx0XHRvbmNyZWF0ZSA9IHsgZSA9PiBpY29uID0gZS50YXJnZXQgfVxuXHRcdG9ubW91c2Vkb3duID0geyAoKSA9PiBpc01vdXNlID0gdHJ1ZSB9XG5cdFx0b253aGVlbCA9IHsgZSA9PiBjb25zb2xlLmxvZyggZS5kZWx0YVksIGUuZGVsdGFNb2RlLCBlICkgfVxuXHRcdGNsYXNzID0geyAoKSA9PiBgXG5cdFx0XHRpY29uXG5cdFx0XHQkeyBvcHRzLm9ubmluZyAmJiBgb25uaW5nYCB9XG5cdFx0XHQkeyBvcHRzLm9mZmluZyAmJiBgb2ZmaW5nYCB9XG5cdFx0XHQkeyBvcHRzLmZpbmFsICYmIGBmaW5hbGAgfVxuXHRcdFx0JHsgb3B0cy5lcnJvcm5lb3VzICYmIGBlcnJvcm5lb3VzYCB9XG5cdFx0XHQkeyBvcHRzLmRpbW1lcmluZy52YWx1ZU9mKCkgPyBgZGltbWVyaW5nYCA6IGBzd2l0Y2hpbmdgIH1cblx0XHRcdCR7IGljb25JZCB9XG5cdFx0XHRpY29uX21vdmluZ18keyAhIW9wdHMubW92aW5nIH1cblx0XHRcdGljb25fbW92ZWRfJHsgISFvcHRzLm1vdmluZyAmJiAhIW9wdHMubW92ZWQgfVxuXHRcdFx0aWNvbl9kZXN0aW5hdGlvbl8keyAhISggYXBwLmhvdmVyICYmIGFwcC5ob3ZlclsgaWNvbklkIF0gKSB9XG5cdFx0YCB9XG5cdFx0c3R5bGUgPSB7IGZ1bmN0aW9uKiBibG9jaygpIHtcblx0XHRcdC8vINC60LDQu9GWINCw0LTRgNCw0LfRgyDQv9GA0YvRgdCy0L7RltGG0YwgbGVmdCDRliB0b3Ag0YLQviDRh9Cw0LzRg9GB0YzRhtGWINC90LUg0L/RgNCw0YbRg9C1IHRyYW5zaXRpb25cblx0XHRcdC8vIFRPRE86INGA0LDQt9Cw0LHRgNCw0YbRhtCwLCDRhtGWINGR0YHRjNGG0Ywg0Y/QutGWINC3INCz0Y3RgtGL0YUg0LTQstGD0YUg0YDQsNC00LrQvtGeINC70ZbRiNC90ZY/XG5cdFx0XHRhcHAuZWRpdGluZyAmJiAoIHlpZWxkIGNvLnNsZWVwKCkgKVxuXHRcdFx0IWJsb2NrLnJ1biA/IGJsb2NrLnJ1biA9IHRydWUgOiAoIHlpZWxkIGNvLnJlcXVlc3RBbmltYXRpb25GcmFtZSApXG5cdFx0XHQvL1xuXG5cdFx0XHRsZXQgcHRcblx0XHRcdGlmICggb3B0cy5tb3ZpbmcgKVxuXHRcdFx0XHRwdCA9IHsgeDogb3B0cy54LCB5OiBvcHRzLnkgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBpID0gbHUudmFsdWVPZiggcG9zaXRpb24gKVxuXHRcdFx0XHRsZXQgcGggPSBhcHAucGFnZUhlaWdodCB8fCAxXG5cdFx0XHRcdGxldCBwdyA9IGFwcC5wYWdlV2lkdGggfHwgMVxuXHRcdFx0XHRsZXQgcHMgPSBwdyAqIHBoXG5cdFx0XHRcdGxldCBwaSA9IGkgJSBwc1xuXHRcdFx0XHRsZXQgcCA9ICggaSAtIHBpICkgLyBwc1xuXHRcdFx0XHRsZXQgdyA9IHBpICUgcHdcblx0XHRcdFx0bGV0IGggPSAoIHBpIC0gdyApIC8gcHdcblx0XHRcdFx0dyArPSBwdyAqIHBcblx0XHRcdFx0cHQgPSB7IHg6IHcgKiAxMDAgLyBwdywgeTogaCAqIDEwMCAvIHBoIH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGxlZnQ6IGAkeyBwdC54IH0lYCxcblx0XHRcdFx0dG9wOiBgJHsgcHQueSB9JWAsXG5cdFx0XHR9XG5cdFx0fSB9XG5cdD5cblx0XHQ8ZGl2IGNsYXNzID0gXCJpY29uQ29udHJvbFwiXG5cdFx0XHRvbnRvdWNoID0geyBodG1sdXRpbHMucHJldmVudERlZmF1bHQgfVxuXHRcdFx0b250YXAgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBvcHRzLmljb25Db21tYW5kKCBgU2hvcnRgICkgfVxuXHRcdFx0b25wcmVzcyA9IHsgKCkgPT4gIWFwcC5lZGl0aW5nICYmIG9wdHMuaWNvbkNvbW1hbmQoIGBMb25nYCApIH1cblx0XHRcdG9ucGFuID0geyBmdW5jdGlvbiogKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoIGFwcC5lZGl0aW5nICkge1xuXHRcdFx0XHRcdC8vIG1vdmluZ1xuXHRcdFx0XHRcdGxldCBuZXh0ID0gZGF0YS5kZXRhaWwubG9jaygpXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGZvciAoIGxldCBwdDsgcHQgPSB5aWVsZCBuZXh0OyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBwdC5kZXRhaWwucHJlc3NlZCA9PT0gZmFsc2UgKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0XHRpZiAoIHB0LmRldGFpbC5wcmVzc2VkID09IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRcdHlpZWxkIG1vdmUoIHB0LCBuZXh0IClcblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdFx0XHRkYXRhLmRldGFpbC51bmxvY2soIG5leHQgKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGB1cGAgfHwgZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGBkb3duYCApIHtcblx0XHRcdFx0XHQvLyBkaW1tZXJpbmdcblx0XHRcdFx0XHRkYXRhLnN0b3BQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0eWllbGQgZGltbSggZGF0YS5kZXRhaWwubmV4dCApXG5cdFx0XHRcdH1cblx0XHRcdH0gfVxuXHRcdD5cblx0XHRcdDxkaXYgY2xhc3MgPSBcImltYWdlXCIgb25jcmVhdGUgPSB7IGUgPT4gaW1hZ2UgPSBlLnRhcmdldCB9ID5cblx0XHRcdFx0PFBpY3R1cmUgY2xhc3MgPSBcIndhaXRcIiBzcmMgPSBcIi9pbWFnZXMvd2FpdC5zdmdcIiBzdHlsZSA9IHt7XG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogKCkgPT4gdGhpcy5maW5hbCA/IGBoaWRkZW5gIDogbnVsbCxcblx0XHRcdFx0fX0gLz5cblx0XHRcdFx0PFBpY3R1cmUgY2xhc3MgPSBcIm9mZlwiIHNyYyA9IFwiL2ltYWdlcy9yb29tLnN2Z1wiIG9uY3JlYXRlID0geyBlID0+IG9mZiA9IGUudGFyZ2V0IH0gLz5cblx0XHRcdFx0PFBpY3R1cmUgY2xhc3MgPSBcIm9uXCIgc3JjID0gXCIvaW1hZ2VzL3Jvb21fb24uc3ZnXCIgb25jcmVhdGUgPSB7IGUgPT4gb24gPSBlLnRhcmdldCB9IC8+XG5cdFx0XHRcdDxQaWN0dXJlIGNsYXNzID0gXCJhYnNlbnRcIiBzcmMgPSBcIi9pbWFnZXMvcm9vbV9hYnNlbnQuc3ZnXCIgb25jcmVhdGUgPSB7IGUgPT4gYWJzZW50ID0gZS50YXJnZXQgfSAvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzID0geyAoKSA9PiBgXG5cdFx0XHRcdFx0c3ZnXG5cdFx0XHRcdFx0JHsgYHN0YXRlYCArICggIW9wdHMucHJlc2VudCA/IGBBYnNlbnRgIDogKCBNYXRoLnJvdW5kKCBvcHRzLnN0YXRlICogMTAwICkgKyAxMDAwICkudG9TdHJpbmcoKS5zbGljZSggMSApICkgfVxuXHRcdFx0XHRcdCR7ICFvcHRzLmlzRGltbWVyaW5nID8gYHNtb290aGluZ2AgOiBgYCB9XG5cdFx0XHRcdGAgfSA+e1xuXHRcdFx0XHRcdCgpID0+IG9wdHMuaWNvbkRhdGEgPSBvcHRzLmljb25UZW1wbGF0ZSAmJiBodG1sdXRpbHMuaW1wb3J0Q29tcG9uZW50KCBvcHRzLmljb25UZW1wbGF0ZSApIHx8IG51bGxcblx0XHRcdFx0fTwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8c3BhbiBjbGFzcyA9IFwiaWNvbkxhYmVsXCIgPnsgKCkgPT5cblx0XHRcdFx0aWNvbkRlc2NyLmdldCggbG9jYWwubGFuZ3VhZ2UgKSB8fCBpY29uRGVzY3IuZ2V0KCBgcnVgICkgfHwgaWNvbkRlc2NyLmdldCggYGVuYCApXG5cdFx0XHR9PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImljb25QZXJjZW50YWdlXCIgPnsgKCkgPT5cblx0XHRcdFx0b3B0cy5wcmVzZW50ICYmIG9wdHMuZGltbWVyaW5nICYmIGAkeyBNYXRoLnJvdW5kKCBvcHRzLnN0YXRlICogMTAwICkgfSVgXG5cdFx0XHR9PC9zcGFuPlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3MgPSBcImRlbGV0ZVNpZ25cIiBvbnRvdWNoc3RhcnQgPSB7ICgpID0+IGFwcC5kZWxldGVJdGVtKCBwbGFjZUlkLCBpY29uSWQgKSB9IG9ubW91c2Vkb3duID0geyAoKSA9PiBhcHAuZGVsZXRlSXRlbSggcGxhY2VJZCwgaWNvbklkICkgfSAvPlxuXHQ8L2Rpdj5cbn1cbiIsImxldCBodG1sdXRpbHMgPSByZXF1aXJlKCBgaHRtbHV0aWxzYCApXG5sZXQgVUlEID0gcmVxdWlyZSggYHVpZGAgKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggYXBwLCBsb2NhbCApID0+IHtcblxuXHRsZXQgUGxhY2UgPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL1BsYWNlYCApIClcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGxldCBpZCA9IFVJRCgpXG5cblx0XHRmdW5jdGlvbiogcGFuKCBuZXh0ICkge1xuXHRcdFx0Ly8gVE9ETzogbm8gdHJhbnNpdGlvbiB3aGlsZSBwYW5uaW5nXG5cdFx0XHRsZXQgbGFzdERlbHRhWCwgcGFnZSwgc2l6ZVxuXHRcdFx0bGV0IGRldmljZWlkID0gYXBwLmFjdGl2ZURldmljZUlkXG5cdFx0XHRhcHAucGxhY2VzU2hpZnRzLmRlZmluZVByb3BlcnR5KCBkZXZpY2VpZCApXG5cdFx0XHRsb2NhbC5wbGFjZXNQYWdlcy5kZWZpbmVQcm9wZXJ0eSggZGV2aWNlaWQgKVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICggbGV0IGRhdGE7IGRhdGEgPSB5aWVsZCBuZXh0OyApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEubGFzdERlbHRhWCApXG5cdFx0XHRcdFx0XHRsYXN0RGVsdGFYID0gZGF0YS5sYXN0RGVsdGFYXG5cdFx0XHRcdFx0bGV0IGRlbHRhWCA9IGRhdGEuZGVsdGFYXG5cdFx0XHRcdFx0bGV0IHJlY3QgPSBhcHAubWVudUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblx0XHRcdFx0XHRsZXQgZGV2aWNlID0gYXBwLmdldERldmljZSggZGV2aWNlaWQgKVxuXHRcdFx0XHRcdGlmICggIWRldmljZSB8fCAhZGV2aWNlLmNvbnRlbnQgKVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0c2l6ZSA9IE1hdGguY2VpbCggT2JqZWN0LmtleXMoIGRldmljZS5jb250ZW50ICkubGVuZ3RoIC8gKCBhcHAucGFnZVdpZHRoICogYXBwLnBhZ2VIZWlnaHQgKSApXG5cdFx0XHRcdFx0aWYgKCBzaXplID09IDAgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRwYWdlID0gbG9jYWwucGxhY2VzUGFnZXNbIGRldmljZWlkIF0gfHwgMFxuXHRcdFx0XHRcdGxldCBpbml0aWFsU2hpZnQgPSAtcGFnZSAqIHJlY3Qud2lkdGhcblx0XHRcdFx0XHRsZXQgc2hpZnQgPSBkYXRhLmRlbHRhWFxuXHRcdFx0XHRcdGlmICggc2hpZnQgPiAwICYmIHBhZ2UgPT0gMCB8fCBzaGlmdCA8IDAgJiYgcGFnZSA9PSBzaXplIC0gMSApXG5cdFx0XHRcdFx0XHRzaGlmdCAvPSAzXG5cdFx0XHRcdFx0YXBwLnBsYWNlc1NoaWZ0c1sgZGV2aWNlaWQgXSA9IHNoaWZ0XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBsYXN0RGVsdGFYICkge1xuXHRcdFx0XHRcdGlmICggbGFzdERlbHRhWCA+IDAgJiYgcGFnZSA+IDAgKVxuXHRcdFx0XHRcdFx0bG9jYWwucGxhY2VzUGFnZXNbIGRldmljZWlkIF0gPSBwYWdlIC0gMVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBsYXN0RGVsdGFYIDwgMCAmJiBwYWdlIDwgc2l6ZSAtIDEgKVxuXHRcdFx0XHRcdFx0bG9jYWwucGxhY2VzUGFnZXNbIGRldmljZWlkIF0gPSBwYWdlICsgMVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0YXBwLnBsYWNlc1NoaWZ0c1sgZGV2aWNlaWQgXSA9IDBcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gPGRpdiA+XG5cdFx0XHQ8c3R5bGUgY2xhc3MgPSBcInN0eWxlXCIgPnsgKCkgPT4gYFxuXHRcdFx0XHQuJHsgaWQgfSAuaWNvbiB7XG5cdFx0XHRcdFx0d2lkdGg6ICR7IDEwMCAvIGFwcC5wYWdlV2lkdGggfSU7XG5cdFx0XHRcdFx0aGVpZ2h0OiAkeyAxMDAgLyBhcHAucGFnZUhlaWdodCB9JTtcblx0XHRcdFx0fVxuXHRcdFx0YCB9PC9zdHlsZT5cblx0XHRcdDxkaXYgY2xhc3MgPSBcInRvcFwiID5cblx0XHRcdFx0PHNwYW4gY2xhc3MgPSBcInRvcF9zZWxmXCIgPlxuXHRcdFx0XHRcdDxodG1sdXRpbHMuQ2VudGVyZWQ+eyAoKSA9PiBhcHAuY2FwdGlvbiB9PC9odG1sdXRpbHMuQ2VudGVyZWQ+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcyA9IHsgKCkgPT4gYG1lbnUgJHsgaWQgfSAkeyBhcHAuYWN0aXZlRGV2aWNlSWQgfWAgfVxuXHRcdFx0XHRvbnBhbiA9IHsgZnVuY3Rpb24qICggZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZGV0YWlsLmRpcmVjdGlvbiA9PSBgbGVmdGAgfHwgZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGByaWdodGAgKSB7XG5cdFx0XHRcdFx0XHRkYXRhLnN0b3BQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHR5aWVsZCogcGFuKCBldmVudC5kZXRhaWwubmV4dCApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IH1cblx0XHRcdFx0b25jcmVhdGUgPSB7IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRhcHAubWVudUVsZW1lbnQgPSB0aGlzXG5cdFx0XHRcdFx0bGV0IHNob3duID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdFx0cmEoICgpID0+IHtcblx0XHRcdFx0XHRcdGxldCBpZCA9IGFwcC5hY3RpdmVEZXZpY2VJZFxuXHRcdFx0XHRcdFx0aWYgKCAhaWQgfHwgc2hvd25bIGlkIF0gKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdGFwcC5wbGFjZXNTaGlmdHMuZGVmaW5lUHJvcGVydHkoIGlkIClcblx0XHRcdFx0XHRcdGxvY2FsLnBsYWNlc1BhZ2VzLmRlZmluZVByb3BlcnR5KCBpZCApXG5cdFx0XHRcdFx0XHRzaG93blsgaWQgXSA9IHRydWVcblx0XHRcdFx0XHRcdC8vIFRPRE86IHJlbW92ZSA8UGxhY2UvPiB3aGVuIHN1Y2ggYSBwbGFjZSBpcyBhY3R1YWxseSByZW1vdmVkIGZyb20gZGF0YWJhc2Vcblx0XHRcdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQoIDxQbGFjZSBwbGFjZUlkID0geyBpZCB9IHBsYWNlRGVzY3IgPSB7IHJhKCAoKSA9PiBhcHAuZ2V0RGV2aWNlKCBpZCApICkgfSAvPiApXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdH0gfVxuXHRcdFx0Lz5cblx0XHRcdDxkaXYgY2xhc3MgPSBcImJvdHRvbVwiID5cblx0XHRcdFx0PGRpdiBjbGFzcyA9IFwiaGVscFwiXG5cdFx0XHRcdFx0b25wcmVzcyA9IHsgKCkgPT4gYXBwLmRpYWxvZyA9IGBTZXJ2aWNlRGlhbG9nYCB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxkaXYgY2xhc3MgPSBcImxvZ29cIlxuXHRcdFx0XHRcdG9ucHJlc3MgPSB7ICgpID0+IGFwcC5kaWFsb2cgPSBgQ29udGV4dE1lbnVgIH1cblx0XHRcdFx0XHRvbnRhcCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5zaGlmdEtleSB8fCBldmVudC5zcmNFdmVudCAmJiBldmVudC5zcmNFdmVudC5zaGlmdEtleSApXG5cdFx0XHRcdFx0XHRcdHJldHVybiBhcHAuZGlhbG9nID0gYENvbnRleHRNZW51YFxuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNyY0V2ZW50ICYmIGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYXBwLmRpYWxvZyA9IGBTZWFyY2hJdGVtc2Bcblx0XHRcdFx0XHRcdGFwcC5lZGl0aW5nID0gZmFsc2Vcblx0XHRcdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0XHRcdFx0YXBwLmdvKCBhcHAubWFpbiApXG5cdFx0XHRcdFx0fSB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxkaXYgY2xhc3MgPSBcImJhY2tcIlxuXHRcdFx0XHRcdG9udG91Y2ggPSB7ICgpID0+IHtcblx0XHRcdFx0XHRcdGlmICggYXBwLmVkaXRpbmcgKVxuXHRcdFx0XHRcdFx0XHRhcHAuZWRpdGluZyA9IGZhbHNlXG5cdFx0XHRcdFx0XHRlbHNlIGlmICggYXBwLmRpYWxvZyApXG5cdFx0XHRcdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRhcHAuYmFjaygpXG5cdFx0XHRcdFx0fSB9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0fVxufVxuIiwibGV0IEFwcGxpY2F0aW9uID0gcmVxdWlyZSggYHVpL0FwcGxpY2F0aW9uYCApXG5cbm1vZHVsZS5leHBvcnRzID0gKCB7IEljb25UZW1wbGF0ZXMgfSApID0+IDxzcGFuPlxuXHQ8c3R5bGU+IHsgYC5hcHBsaWNhdGlvbiB7IHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50OyB9IH0gYCB9IDwvc3R5bGU+XG5cdDxBcHBsaWNhdGlvbiBJY29uVGVtcGxhdGVzID0geyBJY29uVGVtcGxhdGVzIH0gLz5cbjwvc3Bhbj5cbiIsIm1vZHVsZS5leHBvcnRzID0gKCBhcHAsIGxvY2FsICkgPT4ge1xuXG5cdGxldCBJY29uID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9JY29uYCApIClcblxuXHRyZXR1cm4gKCB7IHBsYWNlSWQsIHBsYWNlRGVzY3IgfSApID0+IHtcblx0XHRsZXQgaWRzID0gcmEoICgpID0+IHtcblx0XHRcdGxldCBjb250ZW50ID0gcGxhY2VEZXNjci5nZXQoIGBjb250ZW50YCApXG5cdFx0XHRyZXR1cm4gcmEuQXJyYXkoIGxvZGFzaC5rZXlzKCBjb250ZW50ICkuc29ydCggKCBhLCBiICkgPT4gbHUuY29tcGFyZSggY29udGVudFsgYSBdLmluZGV4LCBjb250ZW50WyBiIF0uaW5kZXggKSApIClcblx0XHR9IClcblx0XHRsZXQgY29udGVudCA9IHJhLm1hcCggaWRzLCAoIGljb25JZCwgcG9zaXRpb24gKSA9PiA8SWNvblxuXHRcdFx0cGxhY2VJZCA9IHsgcGxhY2VJZCB9XG5cdFx0XHRpY29uSWQgPSB7IGljb25JZCB9XG5cdFx0XHRwb3NpdGlvbiA9IHsgcG9zaXRpb24gfVxuXHRcdFx0aWNvbkRlc2NyID0geyByYSggKCkgPT4gYXBwLmdldERldmljZSggaWNvbklkICkgKSB9XG5cdFx0Lz4gKVxuXHRcdHJldHVybiA8ZGl2PlxuXHRcdFx0PHN0eWxlPnsgYFxuXHRcdFx0XHQuJHsgcGxhY2VJZCB9IC5wbGFjZS4keyBwbGFjZUlkIH0ge1xuXHRcdFx0XHRcdGRpc3BsYXk6IGluaXRpYWw7XG5cdFx0XHRcdH1cblx0XHRcdGAgfTwvc3R5bGU+XG5cdFx0XHQ8ZGl2IGNsYXNzID0geyBgcGxhY2UgJHsgcGxhY2VJZCB9YCB9IHN0eWxlID0ge3tcblx0XHRcdFx0dHJhbnNmb3JtOiAoKSA9PiBgdHJhbnNsYXRlWCggJHtcblx0XHRcdFx0XHQtKCBsb2NhbC5wbGFjZXNQYWdlc1sgcGxhY2VJZCBdIHx8IDAgKSAqIGFwcC5tZW51RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIGFwcC5wbGFjZXNTaGlmdHNbIHBsYWNlSWQgXSB8fCAwXG5cdFx0XHRcdH1weCApYCxcblx0XHRcdH19ID57XG5cdFx0XHRcdCgpID0+IGNvbnRlbnRcblx0XHRcdH08L2Rpdj5cblx0XHQ8L2Rpdj5cblx0fVxufVxuIiwibGV0IERMID0gcmVxdWlyZSggYERhbWVyYXVMZXZlbnNodGVpbmAgKVxuXG5sZXQgbm90QUNoYXIgPSBjaGFyID0+IGNoYXIgPD0gYCBgIHx8IGNoYXIgPT0gYC1gXG5cbmxldCBmdXp6eSA9ICggbWFzaywgdGV4dCApID0+IERMKCBtYXNrLnRvVXBwZXJDYXNlKCksIHRleHQudG9VcHBlckNhc2UoKSwge1xuXHRyZXBsYWNlOiBJbmZpbml0eSxcblx0ZGVsZXRlOiBjaGFyID0+IG5vdEFDaGFyKCBjaGFyICkgPyAxZS0yIDogSW5maW5pdHksXG5cdGluc2VydDogY2hhciA9PiBub3RBQ2hhciggY2hhciApID8gMWUtMiA6IDEsXG5cdHRyYW5zcG9zZTogMSxcbn0gKVxuXG5mdW5jdGlvbiB3YXRjaCggZGF0YSwgY2IgKSB7XG5cdGxldCB2XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCB2ID09IG51bGwgKSByYS5kZXRhY2goICgpID0+IHtcblx0XHRcdHYgPSByYSggZGF0YSApXG5cdFx0XHRyYSggKCkgPT4ge1xuXHRcdFx0XHR2LnZhbHVlT2YoKVxuXHRcdFx0XHRjYigpXG5cdFx0XHR9IClcblx0XHR9IClcblx0XHRyZXR1cm4gdi52YWx1ZU9mKClcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiB7XG5cdGxldCBvcHRzLCAkID0ge31cblxuXHRsZXQgU2VhcmNoSXRlbSA9ICggeyBwbGFjZUlkIH0gKSA9PlxuXHRcdDxkaXYgY2xhc3MgPSB7IGBzZWFyY2hJdGVtICR7IHBsYWNlSWQgfWAgfSBvbnNjcm9sbHRhcCA9IHsgKCkgPT4gb3B0cy5nb3RvKCBwbGFjZUlkICkgfSA+XG5cdFx0XHQ8c3BhbiBjbGFzcyA9IFwiY2FwdGlvblwiID57ICgpID0+IG9wdHMucGxhY2VJbmZvc1sgcGxhY2VJZCBdLmNhcHRpb24gfTwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJwbGFjZXNcIiA+eyAoKSA9PiBvcHRzLnBsYWNlSW5mb3NbIHBsYWNlSWQgXS5wdGV4dCB9PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImNtZERlbGV0ZUZyb21Qcm9ncmFtXCI+PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImNtZEFwcGVuZFwiPjwvc3Bhbj5cblx0XHQ8L2Rpdj5cblxuXHRvcHRzID0gcmEoIHtcblx0XHRnb3RvKCBpZCApIHtcblx0XHRcdGlmICggIWlkIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRsZXQgcGxhY2VJbmZvID0gb3B0cy5wbGFjZUluZm9zWyBpZCBdXG5cdFx0XHR+KCBhcHAuc2VhcmNoQWN0aW9uIHx8IGFwcC5nbyApKCBpZCwgcGxhY2VJbmZvICYmIHBsYWNlSW5mby5wbGFjZXMgKVxuXHRcdH0sXG5cdFx0Z2V0IGRldmljZUlkcygpIHsgcmV0dXJuIHJhLkFycmF5KCBhcHAuZGV2aWNlSWRzLmZpbHRlciggaWQgPT4gaWQgIT0gYXBwLm1haW4gKSApIH0sXG5cdFx0Z2V0IHBsYWNlSW5mb3MoKSB7XG5cdFx0XHRsZXQgY2FjaGUgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGZvciAoIGxldCBpZCBvZiB0aGlzLmRldmljZUlkcyApIHtcblx0XHRcdFx0bGV0IGluZm8gPSBhcHAuZ2V0RGV2aWNlKCBpZCApXG5cdFx0XHRcdGNhY2hlWyBpZCBdID0ge1xuXHRcdFx0XHRcdGluZm8sXG5cdFx0XHRcdFx0Y2FwdGlvbjogYXBwLmdldE1lc3NhZ2UoIGluZm8gKSxcblx0XHRcdFx0XHRwbGFjZXM6IFtdLFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCBsZXQgaWQgb2YgdGhpcy5kZXZpY2VJZHMgKVxuXHRcdFx0XHRsb2Rhc2guZm9yRWFjaCggY2FjaGVbIGlkIF0uaW5mby5jb250ZW50LCAoIF8sIGtleSApID0+XG5cdFx0XHRcdFx0Y2FjaGVbIGtleSBdICYmICggY2FjaGVbIGtleSBdLnBsYWNlcy5wdXNoKCBpZCApIClcblx0XHRcdFx0KVxuXHRcdFx0bGV0IHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0Zm9yICggbGV0IGlkIG9mIHRoaXMuZGV2aWNlSWRzICkge1xuXHRcdFx0XHRsZXQgYyA9IGNhY2hlWyBpZCBdXG5cdFx0XHRcdGxldCBwdGV4dCA9IGMucGxhY2VzLm1hcCggaWQgPT4gY2FjaGVbIGlkIF0uY2FwdGlvbiApLmpvaW4oIGAsIGAgKVxuXHRcdFx0XHRpZiAoIHB0ZXh0IClcblx0XHRcdFx0XHRwdGV4dCA9IGAoJHsgcHRleHQgfSlgXG5cdFx0XHRcdHJldFsgaWQgXSA9IHsgaWQsIGNhcHRpb246IGMuY2FwdGlvbiB8fCBgPCoqKj5gLCBwbGFjZXM6IGMucGxhY2VzLCBwdGV4dCB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmEuSlNPTiggcmV0IClcblx0XHR9LFxuXHRcdGdldCBsYWJlbHMoKSB7IHJldHVybiByYS5rZXltYXAoIG9wdHMubGl2ZS5kZXZpY2VJZHMsIHBsYWNlSWQgPT4gPFNlYXJjaEl0ZW0gcGxhY2VJZCA9IHsgcGxhY2VJZCB9IC8+ICkgfSxcblx0XHRnZXQgZmlsdGVyZWQoKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSAkLm1hc2sucmFWYWx1ZVxuXHRcdFx0bGV0IGFyciA9IFtdXG5cdFx0XHRmb3IgKCBsZXQgaWQgb2YgdGhpcy5kZXZpY2VJZHMuZmlsdGVyKCBhcHAuc2VhcmNoRmlsdGVyIHx8IEJvb2xlYW4gKSApIHtcblx0XHRcdFx0bGV0IGkgPSBvcHRzLnBsYWNlSW5mb3NbIGlkIF1cblx0XHRcdFx0bGV0IGtleSA9IFtdXG5cdFx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdFx0a2V5LnB1c2goXG5cdFx0XHRcdFx0XHRmdXp6eSggdmFsdWUsIGkuY2FwdGlvbiApLFxuXHRcdFx0XHRcdFx0Ly8gPz8/IE1hdGgubWF4KCAuLi5pLnBsYWNlcy5tYXAoIGlkID0+IGZ1enp5KCB2YWx1ZSwgb3B0cy5wbGFjZUluZm9zWyBpZCBdLmNhcHRpb24gKSApICksXG5cdFx0XHRcdFx0XHRmdXp6eSggdmFsdWUsIGkuY2FwdGlvbiArIGAgYCArIGkucHRleHQgKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRpZiAoIGtleS5ldmVyeSggayA9PiBNYXRoLmFicyggayApID09IEluZmluaXR5ICkgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkucHVzaCggaS5jYXB0aW9uLnRvVXBwZXJDYXNlKCkgKVxuXHRcdFx0XHRhcnIucHVzaCggeyBpZCwga2V5IH0gKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJhLkFycmF5KCBhcnJcblx0XHRcdFx0LnNvcnQoICggYSwgYiApID0+IGxvZGFzaFxuXHRcdFx0XHRcdC56aXAoIGEua2V5LCBiLmtleSApXG5cdFx0XHRcdFx0Lm1hcCggcGFpciA9PiBsdS5jb21wYXJlKCAuLi5wYWlyICkgKVxuXHRcdFx0XHRcdC5yZWR1Y2UoICggYSwgYiApID0+IGEgfHwgYiApXG5cdFx0XHRcdClcblx0XHRcdFx0Lm1hcCggYSA9PiBhLmlkIClcblx0XHRcdClcblx0XHR9LFxuXHRcdGdldCBpdGVtcygpIHtcblx0XHRcdHJldHVybiByYS5BcnJheSggdGhpcy5maWx0ZXJlZC5tYXAoIGlkID0+IHRoaXMubGFiZWxzLmdldCggaWQgKSApIClcblx0XHR9LFxuXHR9IClcblx0d2luZG93Ll9zZWFyY2ggPSBvcHRzXG5cdHJldHVybiA8ZGl2XG5cdFx0b25kaWFsb2dzaG93ID0geyAoKSA9PiB7XG5cdFx0XHQkLnNjcm9sbGVyICYmICQuc2Nyb2xsZXIucmVmcmVzaCgpXG5cdFx0XHQvLyBUT0RPOiDRgNCw0LfQsNCx0YDQsNGG0YbQsCwg0LAg0YbRliDRgtGA0Y3QsdCwINC30LDRhtGW0YDQsNGG0Ywg0L/QvtGI0YPQuj9cblx0XHRcdCQubWFzay5yYVZhbHVlID0gYGBcblx0XHR9IH1cblx0PlxuXHRcdDxmb3JtXG5cdFx0XHRvbnN1Ym1pdCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0XHRldmVudCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRcdG9wdHMuZ290byggb3B0cy5maWx0ZXJlZFsgMCBdIClcblx0XHRcdH0gfVxuXHRcdD5cblx0XHRcdDxpbnB1dCBuYW1lID0gXCJtYXNrXCIgdHlwZSA9IFwidGV4dFwiIGF1dG9mb2N1cyA9IFwiYXV0b2ZvY3VzXCIgb25jcmVhdGUgPSB7IGV2ZW50ID0+ICQubWFzayA9IGV2ZW50LnRhcmdldCB9IC8+XG5cdFx0XHQ8ZGl2IGNsYXNzID0gXCJzY3JvbGxcIiBvbmNyZWF0ZSA9IHsgZXZlbnQgPT4gJC5zY3JvbGwgPSBldmVudC50YXJnZXQgfSA+XG5cdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcyA9IFwiaXRlbXNcIiA+e1xuXHRcdFx0XHRcdFx0d2F0Y2goICgpID0+IG9wdHMuaXRlbXMsICgpID0+IHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhJC5zY3JvbGxlciApXG5cdFx0XHRcdFx0XHRcdFx0JC5zY3JvbGxlciA9IG5ldyAoIHJlcXVpcmUoIGBpc2Nyb2xsYCApICkoICQuc2Nyb2xsLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb3VzZVdoZWVsOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0c2Nyb2xsYmFyczogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcDogYHNjcm9sbHRhcGAsXG5cdFx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHQkLnNjcm9sbGVyLnJlZnJlc2goKVxuXHRcdFx0XHRcdFx0fSwgMTAwICkgKVxuXHRcdFx0XHRcdH08L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzID0gXCJzY3JvbGxBcmVhQm90dG9tRmlsbGVyXCIgLz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Zvcm0+XG5cdDwvZGl2PlxufVxuIiwibGV0IGh0bWx1dGlscyA9IHJlcXVpcmUoIGBodG1sdXRpbHNgIClcblxubW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4ge1xuXHRsZXQganNvblxuXHRyZXR1cm4gPGRpdiBvbmRpYWxvZ3Nob3cgPSB7ICgpID0+IGpzb24udmFsdWUgPSBKU09OLnN0cmluZ2lmeSggYXBwLmdldERldmljZSggYXBwLmFjdGl2ZURldmljZUlkICksIG51bGwsIDMgKSB9ID5cblx0XHQ8Zm9ybVxuXHRcdFx0b25zdWJtaXQgPSB7IGV2ZW50ID0+IHtcblx0XHRcdFx0ZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0XHRsZXQgdGV4dCA9IGpzb24udmFsdWUudHJpbSgpIHx8IG51bGxcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dCAmJiBKU09OLnBhcnNlKCB0ZXh0IClcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0XHRcdHJldHVybiBhbGVydCggZXJyb3IgKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRlYnVnZ2VyXG5cdFx0XHRcdGlmICggdGV4dCApXG5cdFx0XHRcdFx0YXBwLnNhdmVEZXZpY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCwgdGV4dCApXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0fSB9XG5cdFx0PlxuXHRcdFx0PHRleHRhcmVhXG5cdFx0XHRcdG5hbWUgPSBcImpzb25cIlxuXHRcdFx0XHRhdXRvZm9jdXMgPSBcImF1dG9mb2N1c1wiXG5cdFx0XHRcdG9uY3JlYXRlID0geyBldmVudCA9PiBqc29uID0gZXZlbnQudGFyZ2V0IH1cblx0XHRcdFx0c3R5bGUgPSB7e1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBgYWJzb2x1dGVgLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdFx0dG9wOiBgMTBtbWAsXG5cdFx0XHRcdFx0Ym90dG9tOiBgMTVtbWAsXG5cdFx0XHRcdFx0Zm9udFNpemU6IGA1MCVgLFxuXHRcdFx0XHR9fVxuXHRcdFx0Lz5cblx0XHRcdDxhXG5cdFx0XHRcdGNsYXNzID0gXCJzYXZlXCJcblx0XHRcdFx0aHJlZiA9IFwiamF2YXNjcmlwdDp2b2lkKDApXCJcblx0XHRcdFx0dGFyZ2V0ID0gXCJfc2VsZlwiXG5cdFx0XHRcdG9udG91Y2ggPSB7IGh0bWx1dGlscy5TdWJtaXQgfVxuXHRcdFx0XHRzdHlsZSA9IHt7XG5cdFx0XHRcdFx0cG9zaXRpb246IGBhYnNvbHV0ZWAsXG5cdFx0XHRcdFx0ZGlzcGxheTogYGJsb2NrYCxcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdGhlaWdodDogYDEwbW1gLFxuXHRcdFx0XHRcdGJvdHRvbTogYDBgLFxuXHRcdFx0XHR9fVxuXHRcdFx0PlNhdmU8L2E+XG5cdFx0PC9mb3JtPlxuXHQ8L2Rpdj5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXBwID0+ICgpID0+IDxkaXYgY2xhc3MgPSBcInN0YXJ0dXBTY3JlZW5cIiA+XG5cdDxwPtCU0L7QsdGA0L4g0L/QvtC20LDQu9C+0LLQsNGC0Ywg0LIg0JLQsNGIPGJyLz7Qo9C80L3Ri9C5INCU0L7QvCE8L3A+XG5cdDxkaXYgY2xhc3MgPSBcInRlbXBsYXRlc1wiID5cblx0XHQ8cD7Qn9C+0LbQsNC70YPQudGB0YLQsCwg0LLRi9Cx0LXRgNC40YLQtSDQvNC10YHRgtC+LCDQs9C00LUg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINGN0YLQvtGCINC/0YPQu9GM0YI6PC9wPlxuXHRcdDx1bCBjbGFzcyA9IFwiaG91c2VUZW1wbGF0ZXNcIiA+eyAoKSA9PiAoIGFwcC50ZW1wbGF0ZXMgfHwgW10gKS5jb25jYXQoIFsge1xuXHRcdFx0bWVudTogYNC90LDRh9Cw0YLRjCDRgSDRh9C40YHRgtC+0LPQviDQu9C40YHRgtCwYCxcblx0XHRcdHJ1OiBg0JzQvtC5INC00L7QvGAsXG5cdFx0XHRlbjogYEhvbWVgLFxuXHRcdFx0dHlwZTogYHBsYWNlYCxcblx0XHR9IF0gKS5tYXAoIGhvdXNlVGVtcGxhdGUgPT5cblx0XHRcdDxsaSBjbGFzcyA9IFwiaG91c2VUZW1wbGF0ZVwiIG9udG91Y2ggPSB7ICgpID0+IGFwcC5zZXRUZW1wbGF0ZSggaG91c2VUZW1wbGF0ZSApIH0gPntcblx0XHRcdFx0aG91c2VUZW1wbGF0ZS5tZW51IHx8IGFwcC5nZXRNZXNzYWdlKCBob3VzZVRlbXBsYXRlIClcblx0XHRcdH08L2xpPlxuXHRcdCkgfTwvdWw+XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzID0gXCJsb2FkaW5nXCIgPjwvZGl2PlxuPC9kaXY+XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5sZXQgY291bnRlciA9IDBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1aWQoIG9iaiApIHtcblx0bGV0IGkgPSAoICsrY291bnRlciApLnRvU3RyaW5nKCAzNiApXG5cdGxldCByID0gcGFyc2VJbnQoIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSggMiwgMTcgKSApLnRvU3RyaW5nKCAzNiApXG5cdGxldCBpZCA9ICggci5sZW5ndGggKyA5ICkudG9TdHJpbmcoIDM2ICkgKyByICsgaVxuXHRpZiAoIG9iaiA9PSBudWxsIClcblx0XHRyZXR1cm4gaWRcblx0ZWxzZSB7XG5cdFx0b2JqLnVpZCA9IGlkXG5cdFx0cmV0dXJuIG9ialxuXHR9XG59XG4iLCIvKlxucG9zdCAvZGV2aWNlcyB7XCJQXCI6MX1cbiovXG5cbmZ1bmN0aW9uIGNoZWNrQnJvd3NlckZ1bmN0aW9ucygpIHtcblx0bGV0IHJldCA9IHRydWVcblx0XHQmJiB0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCAhPSBgdW5kZWZpbmVkYCAmJiBIVE1MVGVtcGxhdGVFbGVtZW50XG5cdHJldHVybiAhIXJldFxufVxuXG5pZiAoICFjaGVja0Jyb3dzZXJGdW5jdGlvbnMoKSApIHtcblx0d2luZG93Ll9fVU5TVVBQT1JURURfXygpXG5cdHRocm93IG5ldyBFcnJvciggXCJ1bnN1cHBvcnRlZFwiIClcbn1cblxucmVxdWlyZSggYGJyb3dzZXItbmV4dHRpY2tgIClcbnJlcXVpcmUoIGBwbGF0Zm9ybWAgKVxucmVxdWlyZSggYGh0bWxwb2x5ZmlsbGAgKVxucmVxdWlyZSggYHRyYWNrYCApXG5yZXF1aXJlKCBgZ2VzdHVyZWAgKVxuXG5nbG9iYWwubHUgPSByZXF1aXJlKCBgbG9jYWxVdGlsc2AgKVxuZ2xvYmFsLnJhID0gcmVxdWlyZSggYHJhYCApXG5nbG9iYWwuY28gPSByZXF1aXJlKCBgY29gIClcbmdsb2JhbC5sb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5yZXF1aXJlKCBgY29sb3JzYCApXG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCBldmVudCApIHtcblx0aWYgKCBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSggYHJlbGAgKSA9PSBgZXh0ZXJuYWxgIClcblx0XHRyZXR1cm5cblx0Zm9yICggbGV0IEMgb2YgWyBIVE1MSW5wdXRFbGVtZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50LCBIVE1MT3B0aW9uRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQgXSApXG5cdFx0aWYgKCBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBDIClcblx0XHRcdHJldHVyblxuXHQvLyBhdHRlbXB0IHRvIHVzZSBuYXRpdmUgc2Nyb2xsaW5nIC0gdW5zdWNjZXNzZnVsbFxuXHQvLyBsZXQgQyA9IGV2ZW50LnRhcmdldFxuXHQvLyB3aGlsZSAoIEMgJiYgQy5jbGFzc0xpc3QgKSB7XG5cdC8vIFx0aWYgKCBDLmNsYXNzTGlzdC5jb250YWlucyggYHNjcm9sbGAgKSApXG5cdC8vIFx0XHRyZXR1cm5cblx0Ly8gXHRDID0gQy5wYXJlbnROb2RlXG5cdC8vIH1cblx0ZXZlbnQucHJldmVudERlZmF1bHQoKVxufVxuXG5mb3IgKCBsZXQgdHlwZSBvZiBbIGB0b3VjaHN0YXJ0YCwgYHRvdWNobW92ZWAsIGB0b3VjaGVuZGAsIGB0b3VjaGNhbmNlbGAgXSApXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBwcmV2ZW50RGVmYXVsdCApXG5cbmdsb2JhbC5MT0cgPSBmdW5jdGlvbiAoIHN0ciApIHtcblx0Ly8gaWYgKCBTdHJpbmcoIHN0ciApID09IGB1bmRlZmluZWRgIClcblx0Ly8gXHRkZWJ1Z2dlclxuXHRjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzIClcblx0Z2xvYmFsLl9BTEVSVCAmJiBnbG9iYWwuX0FMRVJUKCBzdHIgKVxuXHRsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblx0eGhyLm9wZW4oIGBQT1NUYCwgYC9sb2c/JHsgZW5jb2RlVVJJQ29tcG9uZW50KCBzdHIgKSB9YCApXG5cdHhoci5vbmVycm9yID0gbG9kYXNoLm5vb3Bcblx0eGhyLnNlbmQoKVxuXHRyZXR1cm4gc3RyXG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBgZXJyb3JgLCBmdW5jdGlvbiBvbkVycm9yKCBlICkge1xuXHRpZiAoICFlLm1lc3NhZ2UubWF0Y2goIDQwNCApICYmICFvbkVycm9yLnByb2Nlc3NpbmcgKSB7XG5cdFx0b25FcnJvci5wcm9jZXNzaW5nID0gdHJ1ZVxuXHRcdHRyeSB7XG5cdFx0XHRMT0coIGAkeyBlLm1lc3NhZ2UucmVkIH0gYXQgJHsgZS5saW5lbm8gfTokeyBlLmNvbG5vIH0gaW4gJHsgZS5maWxlbmFtZSB9YCApXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0b25FcnJvci5wcm9jZXNzaW5nID0gZmFsc2Vcblx0XHR9XG5cdH1cbn0gKVxuXG5sZXQgb25lcnJvciA9IHdpbmRvdy5vbmVycm9yXG53aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uICggbWVzc2FnZSwgdXJsLCBsaW5lLCBjb2x1bW4sIGVycm9yICkge1xuXHRsZXQgcmV0XG5cdGlmICggZXJyb3IgKSB7XG5cdFx0TE9HKCBgc3RhY2s6IGAgKyBlcnJvci5zdGFjayApXG5cdH1cblx0aWYgKCBvbmVycm9yICkge1xuXHRcdHRyeSB7XG5cdFx0XHR3aW5kb3cub25lcnJvciA9IG9uZXJyb3Jcblx0XHRcdHJldCA9IG9uZXJyb3IuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0b25lcnJvciA9IHdpbmRvdy5vbmVycm9yXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXRcbn1cblxuLy8gcmVxdWlyZSggYHRvdWNoTG9nYCApXG4vLyByZXF1aXJlKCBgdG91Y2hTaG93YCApXG4vLyByZXF1aXJlKCBgdG91Y2hlc2AgKVxuXG5nbG9iYWwuUmVhY3QgPSByZXF1aXJlKCBgY29tcG9uZW50c2AgKVxuXG5mdW5jdGlvbiBzY3JpcHQoIHRleHQgKSB7XG5cdGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgc2NyaXB0YCApXG5cdHNjcmlwdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRleHQgKSApXG5cdHJldHVybiBzY3JpcHRcbn1cblxuY28uZ28oIGZ1bmN0aW9uKiAoKSB7XG5cdGxldCBodG1sID0gY2FjaGVVcmxSZXNvdXJjZSggYC4vbWFpbi5odG1sYCApXG5cdGh0bWwgPSB5aWVsZCBodG1sXG5cblx0bGV0IGRhdGEgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblxuXHRsZXQgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYGRpdmAgKVxuXHR0bXAuaW5uZXJIVE1MID0gaHRtbFxuXHR0bXAgPSB0bXAuY2hpbGRyZW5bIDAgXVxuXHRsZXQgY2hpbGRyZW4gPSBbXVxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0bXAuY2hpbGROb2Rlcy5sZW5ndGg7ICsraSApXG5cdFx0Y2hpbGRyZW4ucHVzaCggdG1wLmNoaWxkTm9kZXNbIGkgXSApXG5cdGNoaWxkcmVuLmZvckVhY2goIGMgPT4gdG1wLnJlbW92ZUNoaWxkKCBjICkgKVxuXHRjaGlsZHJlbi5mb3JFYWNoKCBjID0+IHtcblx0XHRpZiAoIGMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCApXG5cdFx0XHRjID0gc2NyaXB0KCBjLmlubmVySFRNTCApXG5cdFx0ZGF0YS5hcHBlbmRDaGlsZCggYyApXG5cdH0gKVxuXG5cdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGRhdGEgKVxufSApXG5cbi8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAvLyBUT0RPOiDQstGL0LTQsNC70ZbRhtGMINC/0LDRgdGM0LvRjyDQstGL0YHRgtCw0LLRiy4g0J3QsNC00YLQsCDRgdGC0YDQsNGI0L3QsCDRj9C90L4g0LTQt9GR0YDQs9Cw0LXRhtGG0LAg0L/RgNGLINC/0LXRgNCw0LfQsNCz0YDRg9C30YbRi1xuLy8gXHRgbWVzc2FnZWAsXG4vLyBcdGV2ZW50ID0+IHtcbi8vIFx0XHRpZiAoIGV2ZW50ICYmIGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS53aGF0ID09IGB1cmxSZXNvdXJjZVVwZGF0ZWRgIClcbi8vIFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KFxuLy8gXHRcdFx0XHQoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCksXG4vLyBcdFx0XHRcdDEwMDBcbi8vIFx0XHRcdClcbi8vIFx0fSxcbi8vIFx0ZmFsc2Vcbi8vIClcbiIsImxldCByYSA9IHJlcXVpcmUoIGByYWAgKVxuXG5sZXQgd2luZG93U2l6ZSA9IHJhLmNsZWFuKCB7XG5cdHdpZHRoOiAxLFxuXHRoZWlnaHQ6IDEsXG5cdHBwbW06IDEsXG5cdHdpZHRobW06IDEsXG5cdGhlaWdodG1tOiAxLFxuXHRwaXhlbFJhdGlvOiAxLFxuXHRvcmllbnRhdGlvbjogMCxcblx0bGF5b3V0OiBgdmVydGljYWxgLFxuXHR3aW5kb3c6IGBicm93c2VyYCxcbn0gKS5zZXROYW1lKCBgd2luZG93U2l6ZWAgKVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggYHJlc2l6ZWAsIHVwZGF0ZVNpemUgKVxuXG4vLyBsZXQgb3JpZW50YXRpb25zID0ge31cblxubGV0IGNtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYGRpdmAgKVxuY20uc3R5bGUubGVmdCA9IGAwYFxuY20uc3R5bGUudG9wID0gYDBgXG5jbS5zdHlsZS53aWR0aCA9IGAxMGNtYFxuY20uc3R5bGUuaGVpZ2h0ID0gYDEwY21gXG5jbS5zdHlsZS5wb3NpdGlvbiA9IGBmaXhlZGBcbmNtLnN0eWxlLnpJbmRleCA9IGAtOTk5OWBcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGNtIClcbmxldCBwcG1tID0gY20uY2xpZW50V2lkdGggLyAxMDBcbmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIGNtIClcblxudXBkYXRlU2l6ZSgpXG5cbmZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG5cblx0bGV0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGhcblx0bGV0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuXG5cdGxldCBvcmllbnRhdGlvbiA9ICggd2luZG93Lm9yaWVudGF0aW9uIHx8IDAgKSAlIDM2MFxuXHRpZiAoIG9yaWVudGF0aW9uIDwgMCApIG9yaWVudGF0aW9uICs9IDM2MFxuXG5cdHdpbmRvd1NpemUud2lkdGggPSB3aWR0aFxuXHR3aW5kb3dTaXplLmhlaWdodCA9IGhlaWdodFxuXHR3aW5kb3dTaXplLnBwbW0gPSBwcG1tXG5cdHdpbmRvd1NpemUud2lkdGhtbSA9IHdpZHRoIC8gcHBtbVxuXHR3aW5kb3dTaXplLmhlaWdodG1tID0gaGVpZ2h0IC8gcHBtbVxuXHR3aW5kb3dTaXplLnBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxXG5cdHdpbmRvd1NpemUub3JpZW50YXRpb24gPSBvcmllbnRhdGlvblxuXHR3aW5kb3dTaXplLmxheW91dCA9IHdpZHRoIDw9IGhlaWdodCA/IGB2ZXJ0aWNhbGAgOiBgaG9yaXpvbnRhbGBcblx0d2luZG93U2l6ZS53aW5kb3cgPSB3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgPyBgYXBwYCA6IGBicm93c2VyYFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1NpemVcbiIsInJlcXVpcmUoIFwid2VicGFnZVwiIClcbnJlcXVpcmUoIFwidWkvT25lQXBwXCIgKVxuZ2xvYmFsLnJlcXVpcmUgPSBmdW5jdGlvbiByKCBuYW1lICkge1xuXHRcdFx0XHRcdGdsb2JhbC5yZXF1aXJlID0gbnVsbFxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVxdWlyZS5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdFx0XHRnbG9iYWwucmVxdWlyZSA9IHJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cbiJdfQ==
