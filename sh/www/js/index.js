(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

require("core-js/shim");

require("regenerator/runtime");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/lib/babel/polyfill.js","/node_modules/babel-core/lib/babel")

},{"_process":99,"buffer":94,"core-js/shim":90,"regenerator/runtime":91}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// false -> Array#indexOf
// true  -> Array#includes
var $ = require('./$');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = $.toObject($this)
      , length = $.toLength(O.length)
      , index  = $.toIndex(fromIndex, length)
      , value;
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index;
    } return !IS_INCLUDES && -1;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.array-includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var $   = require('./$')
  , ctx = require('./$.ctx');
module.exports = function(TYPE){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that){
    var O      = Object($.assertDefined($this))
      , self   = $.ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = $.toLength(self.length)
      , index  = 0
      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.array-methods.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.ctx":11,"_process":99,"buffer":94}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
assert.def = $.assertDefined;
assert.fn = function(it){
  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');
  return it;
};
assert.obj = function(it){
  if(!$.isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
assert.inst = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
module.exports = assert;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.assert.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , enumKeys = require('./$.enum-keys');
// 19.1.2.1 Object.assign(target, source, ...)
/* eslint-disable no-unused-vars */
module.exports = Object.assign || function assign(target, source){
/* eslint-enable no-unused-vars */
  var T = Object($.assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = $.ES5Object(arguments[i++])
      , keys   = enumKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.assign.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.enum-keys":14,"_process":99,"buffer":94}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , TAG      = require('./$.wks')('toStringTag')
  , toString = {}.toString;
function cof(it){
  return toString.call(it).slice(8, -1);
}
cof.classof = function(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
};
cof.set = function(it, tag, stat){
  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);
};
module.exports = cof;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.cof.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.wks":41,"_process":99,"buffer":94}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , safe     = require('./$.uid').safe
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , step     = require('./$.iter').step
  , $has     = $.has
  , set      = $.set
  , isObject = $.isObject
  , hide     = $.hide
  , isExtensible = Object.isExtensible || isObject
  , ID       = safe('id')
  , O1       = safe('O1')
  , LAST     = safe('last')
  , FIRST    = safe('first')
  , ITER     = safe('iter')
  , SIZE     = $.DESC ? safe('size') : 'size'
  , id       = 0;

function fastKey(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
}

function getEntry(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that[O1][index];
  // frozen object case
  for(entry = that[FIRST]; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
}

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      assert.inst(that, C, NAME);
      set(that, O1, $.create(null));
      set(that, SIZE, 0);
      set(that, LAST, undefined);
      set(that, FIRST, undefined);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that[FIRST] = that[LAST] = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that[O1][entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that[FIRST] == entry)that[FIRST] = next;
          if(that[LAST] == entry)that[LAST] = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments[1], 3)
          , entry;
        while(entry = entry ? entry.n : this[FIRST]){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if($.DESC)$.setDesc(C.prototype, 'size', {
      get: function(){
        return assert.def(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that[O1][index] = entry;
    } return that;
  },
  getEntry: getEntry,
  // add .keys, .values, .entries, [@@iterator]
  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
  setIter: function(C, NAME, IS_MAP){
    require('./$.iter-define')(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-strong.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.ctx":11,"./$.for-of":15,"./$.iter":22,"./$.iter-define":20,"./$.mix":25,"./$.uid":39,"_process":99,"buffer":94}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def')
  , forOf = require('./$.for-of');
module.exports = function(NAME){
  $def($def.P, NAME, {
    toJSON: function toJSON(){
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    }
  });
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.for-of":15,"_process":99,"buffer":94}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $         = require('./$')
  , safe      = require('./$.uid').safe
  , assert    = require('./$.assert')
  , forOf     = require('./$.for-of')
  , $has      = $.has
  , isObject  = $.isObject
  , hide      = $.hide
  , isExtensible = Object.isExtensible || isObject
  , id        = 0
  , ID        = safe('id')
  , WEAK      = safe('weak')
  , LEAK      = safe('leak')
  , method    = require('./$.array-methods')
  , find      = method(5)
  , findIndex = method(6);
function findFrozen(store, key){
  return find(store.array, function(it){
    return it[0] === key;
  });
}
// fallback for frozen keys
function leakStore(that){
  return that[LEAK] || hide(that, LEAK, {
    array: [],
    get: function(key){
      var entry = findFrozen(this, key);
      if(entry)return entry[1];
    },
    has: function(key){
      return !!findFrozen(this, key);
    },
    set: function(key, value){
      var entry = findFrozen(this, key);
      if(entry)entry[1] = value;
      else this.array.push([key, value]);
    },
    'delete': function(key){
      var index = findIndex(this.array, function(it){
        return it[0] === key;
      });
      if(~index)this.array.splice(index, 1);
      return !!~index;
    }
  })[LEAK];
}

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      $.set(assert.inst(that, C, NAME), ID, id++);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this)['delete'](key);
        return $has(key, WEAK) && $has(key[WEAK], this[ID]) && delete key[WEAK][this[ID]];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this).has(key);
        return $has(key, WEAK) && $has(key[WEAK], this[ID]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    if(!isExtensible(assert.obj(key))){
      leakStore(that).set(key, value);
    } else {
      $has(key, WEAK) || hide(key, WEAK, {});
      key[WEAK][that[ID]] = value;
    } return that;
  },
  leakStore: leakStore,
  WEAK: WEAK,
  ID: ID
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection-weak.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.array-methods":3,"./$.assert":4,"./$.for-of":15,"./$.mix":25,"./$.uid":39,"_process":99,"buffer":94}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $     = require('./$')
  , $def  = require('./$.def')
  , BUGGY = require('./$.iter').BUGGY
  , forOf = require('./$.for-of')
  , species = require('./$.species')
  , assertInstance = require('./$.assert').inst;

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = $.g[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  function fixMethod(KEY){
    var fn = proto[KEY];
    require('./$.redef')(proto, KEY,
      KEY == 'delete' ? function(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'has' ? function has(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'get' ? function get(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
      : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  }
  if(!$.isFunction(C) || !(IS_WEAK || !BUGGY && proto.forEach && proto.entries)){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    require('./$.mix')(C.prototype, methods);
  } else {
    var inst  = new C
      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
      , buggyZero;
    // wrap for init collections from iterable
    if(!require('./$.iter-detect')(function(iter){ new C(iter); })){ // eslint-disable-line no-new
      C = wrapper(function(target, iterable){
        assertInstance(target, C, NAME);
        var that = new Base;
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    IS_WEAK || inst.forEach(function(val, key){
      buggyZero = 1 / key === -Infinity;
    });
    // fix converting -0 key to +0
    if(buggyZero){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    // + fix .add & .set for chaining
    if(buggyZero || chain !== inst)fixMethod(ADDER);
  }

  require('./$.cof').set(C, NAME);

  O[NAME] = C;
  $def($def.G + $def.W + $def.F * (C != Base), O);
  species(C);
  species($.core[NAME]); // for wrapper

  if(!IS_WEAK)common.setIter(C, NAME, IS_MAP);

  return C;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.collection.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.for-of":15,"./$.iter":22,"./$.iter-detect":21,"./$.mix":25,"./$.redef":28,"./$.species":33,"_process":99,"buffer":94}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Optional / simple context binding
var assertFunction = require('./$.assert').fn;
module.exports = function(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  } return function(/* ...args */){
      return fn.apply(that, arguments);
    };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.ctx.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assert":4,"_process":99,"buffer":94}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $          = require('./$')
  , global     = $.g
  , core       = $.core
  , isFunction = $.isFunction
  , $redef     = require('./$.redef');
function ctx(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
}
global.core = core;
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
function $def(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , isProto  = type & $def.P
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {}).prototype
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    if(type & $def.B && own)exp = ctx(out, global);
    else exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
    // extend global
    if(target && !own)$redef(target, key, out);
    // export
    if(exports[key] != out)$.hide(exports, key, exp);
    if(isProto)(exports.prototype || (exports.prototype = {}))[key] = out;
  }
}
module.exports = $def;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.def.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.redef":28,"_process":99,"buffer":94}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , document = $.g.document
  , isObject = $.isObject
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.dom-create.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getDesc    = $.getDesc
    , getSymbols = $.getSymbols;
  if(getSymbols)$.each.call(getSymbols(it), function(key){
    if(getDesc(it, key).enumerable)keys.push(key);
  });
  return keys;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.enum-keys.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var ctx  = require('./$.ctx')
  , get  = require('./$.iter').get
  , call = require('./$.iter-call');
module.exports = function(iterable, entries, fn, that){
  var iterator = get(iterable)
    , f        = ctx(fn, that, entries ? 2 : 1)
    , step;
  while(!(step = iterator.next()).done){
    if(call(iterator, f, step.value, entries) === false){
      return call.close(iterator);
    }
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.for-of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.ctx":11,"./$.iter":22,"./$.iter-call":19,"_process":99,"buffer":94}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function($){
  $.FW   = true;
  $.path = $.g;
  return $;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.fw.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var $ = require('./$')
  , toString = {}.toString
  , getNames = $.getNames;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

function getWindowNames(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
}

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames($.toObject(it));
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.get-names.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.invoke.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assertObject = require('./$.assert').obj;
function close(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)assertObject(ret.call(iterator));
}
function call(iterator, fn, value, entries){
  try {
    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
  } catch(e){
    close(iterator);
    throw e;
  }
}
call.close = close;
module.exports = call;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-call.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assert":4,"_process":99,"buffer":94}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def            = require('./$.def')
  , $redef          = require('./$.redef')
  , $               = require('./$')
  , cof             = require('./$.cof')
  , $iter           = require('./$.iter')
  , SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , FF_ITERATOR     = '@@iterator'
  , KEYS            = 'keys'
  , VALUES          = 'values'
  , Iterators       = $iter.Iterators;
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
  $iter.create(Constructor, NAME, next);
  function createMethod(kind){
    function $$(that){
      return new Constructor(that, kind);
    }
    switch(kind){
      case KEYS: return function keys(){ return $$(this); };
      case VALUES: return function values(){ return $$(this); };
    } return function entries(){ return $$(this); };
  }
  var TAG      = NAME + ' Iterator'
    , proto    = Base.prototype
    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , _default = _native || createMethod(DEFAULT)
    , methods, key;
  // Fix native
  if(_native){
    var IteratorPrototype = $.getProto(_default.call(new Base));
    // Set @@toStringTag to native iterators
    cof.set(IteratorPrototype, TAG, true);
    // FF fix
    if($.FW && $.has(proto, FF_ITERATOR))$iter.set(IteratorPrototype, $.that);
  }
  // Define iterator
  if($.FW || FORCE)$iter.set(proto, _default);
  // Plug for library
  Iterators[NAME] = _default;
  Iterators[TAG]  = $.that;
  if(DEFAULT){
    methods = {
      keys:    IS_SET            ? _default : createMethod(KEYS),
      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
      entries: DEFAULT != VALUES ? _default : createMethod('entries')
    };
    if(FORCE)for(key in methods){
      if(!(key in proto))$redef(proto, key, methods[key]);
    } else $def($def.P + $def.F * $iter.BUGGY, NAME, methods);
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-define.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.def":12,"./$.iter":22,"./$.redef":28,"./$.wks":41,"_process":99,"buffer":94}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , SAFE_CLOSING    = false;
try {
  var riter = [7][SYMBOL_ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }
module.exports = function(exec){
  if(!SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[SYMBOL_ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[SYMBOL_ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter-detect.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.wks":41,"_process":99,"buffer":94}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $                 = require('./$')
  , cof               = require('./$.cof')
  , classof           = cof.classof
  , assert            = require('./$.assert')
  , assertObject      = assert.obj
  , SYMBOL_ITERATOR   = require('./$.wks')('iterator')
  , FF_ITERATOR       = '@@iterator'
  , Iterators         = require('./$.shared')('iterators')
  , IteratorPrototype = {};
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, $.that);
function setIterator(O, value){
  $.hide(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);
}

module.exports = {
  // Safari has buggy iterators w/o `next`
  BUGGY: 'keys' in [] && !('next' in [].keys()),
  Iterators: Iterators,
  step: function(done, value){
    return {value: value, done: !!done};
  },
  is: function(it){
    var O      = Object(it)
      , Symbol = $.g.Symbol;
    return (Symbol && Symbol.iterator || FF_ITERATOR) in O
      || SYMBOL_ITERATOR in O
      || $.has(Iterators, classof(O));
  },
  get: function(it){
    var Symbol = $.g.Symbol
      , getIter;
    if(it != undefined){
      getIter = it[Symbol && Symbol.iterator || FF_ITERATOR]
        || it[SYMBOL_ITERATOR]
        || Iterators[classof(it)];
    }
    assert($.isFunction(getIter), it, ' is not iterable!');
    return assertObject(getIter.call(it));
  },
  set: setIterator,
  create: function(Constructor, NAME, next, proto){
    Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});
    cof.set(Constructor, NAME + ' Iterator');
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.iter.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.shared":32,"./$.wks":41,"_process":99,"buffer":94}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var global = typeof self != 'undefined' ? self : Function('return this')()
  , core   = {}
  , defineProperty = Object.defineProperty
  , hasOwnProperty = {}.hasOwnProperty
  , ceil  = Math.ceil
  , floor = Math.floor
  , max   = Math.max
  , min   = Math.min;
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
  try {
    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
  } catch(e){ /* empty */ }
}();
var hide = createDefiner(1);
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
}
function desc(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return $.setDesc(object, key, desc(bitmap, value));
  } : simpleSet;
}

function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
function assertDefined(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
}

var $ = module.exports = require('./$.fw')({
  g: global,
  core: core,
  html: global.document && document.documentElement,
  // http://jsperf.com/core-js-isobject
  isObject:   isObject,
  isFunction: isFunction,
  that: function(){
    return this;
  },
  // 7.1.4 ToInteger
  toInteger: toInteger,
  // 7.1.15 ToLength
  toLength: function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  },
  toIndex: function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  },
  has: function(it, key){
    return hasOwnProperty.call(it, key);
  },
  create:     Object.create,
  getProto:   Object.getPrototypeOf,
  DESC:       DESC,
  desc:       desc,
  getDesc:    Object.getOwnPropertyDescriptor,
  setDesc:    defineProperty,
  setDescs:   Object.defineProperties,
  getKeys:    Object.keys,
  getNames:   Object.getOwnPropertyNames,
  getSymbols: Object.getOwnPropertySymbols,
  assertDefined: assertDefined,
  // Dummy, fix for not array-like ES3 string in es5 module
  ES5Object: Object,
  toObject: function(it){
    return $.ES5Object(assertDefined(it));
  },
  hide: hide,
  def: createDefiner(0),
  set: global.Symbol ? simpleSet : hide,
  each: [].forEach
});
/* eslint-disable no-undef */
if(typeof __e != 'undefined')__e = core;
if(typeof __g != 'undefined')__g = global;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.fw":16,"_process":99,"buffer":94}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $ = require('./$');
module.exports = function(object, el){
  var O      = $.toObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.keyof.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $redef = require('./$.redef');
module.exports = function(target, src){
  for(var key in src)$redef(target, key, src[key]);
  return target;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.mix.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.redef":28,"_process":99,"buffer":94}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $            = require('./$')
  , assertObject = require('./$.assert').obj;
module.exports = function ownKeys(it){
  assertObject(it);
  var keys       = $.getNames(it)
    , getSymbols = $.getSymbols;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.own-keys.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"_process":99,"buffer":94}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $      = require('./$')
  , invoke = require('./$.invoke')
  , assertFunction = require('./$.assert').fn;
module.exports = function(/* ...pargs */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = $.path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !_length)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(_length > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.partial.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.invoke":18,"_process":99,"buffer":94}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $   = require('./$')
  , tpl = String({}.hasOwnProperty)
  , SRC = require('./$.uid').safe('src')
  , _toString = Function.toString;

function $redef(O, key, val, safe){
  if($.isFunction(val)){
    var base = O[key];
    $.hide(val, SRC, base ? String(base) : tpl.replace(/hasOwnProperty/, String(key)));
    if(!('name' in val))val.name = key;
  }
  if(O === $.g){
    O[key] = val;
  } else {
    if(!safe)delete O[key];
    $.hide(O, key, val);
  }
}

// add fake Function#toString for correct work wrapped methods / constructors
// with methods similar to LoDash isNative
$redef(Function.prototype, 'toString', function toString(){
  return $.has(this, SRC) ? this[SRC] : _toString.call(this);
});

$.core.inspectSource = function(it){
  return _toString.call(it);
};

module.exports = $redef;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.redef.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.uid":39,"_process":99,"buffer":94}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
module.exports = function(regExp, replace, isStatic){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.replacer.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.same.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],31:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var $      = require('./$')
  , assert = require('./$.assert');
function check(O, proto){
  assert.obj(O);
  assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
}
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line
    ? function(buggy, set){
        try {
          set = require('./$.ctx')(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
          set({}, []);
        } catch(e){ buggy = true; }
        return function setPrototypeOf(O, proto){
          check(O, proto);
          if(buggy)O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }()
    : undefined),
  check: check
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.set-proto.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.ctx":11,"_process":99,"buffer":94}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $      = require('./$')
  , SHARED = '__core-js_shared__'
  , store  = $.g[SHARED] || $.hide($.g, SHARED, {})[SHARED];
module.exports = function(key){
  return store[key] || (store[key] = {});
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.shared.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $       = require('./$')
  , SPECIES = require('./$.wks')('species');
module.exports = function(C){
  if($.DESC && !(SPECIES in C))$.setDesc(C, SPECIES, {
    configurable: true,
    get: $.that
  });
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.species.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.wks":41,"_process":99,"buffer":94}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// true  -> String#at
// false -> String#codePointAt
var $ = require('./$');
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String($.assertDefined(that))
      , i = $.toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l
      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://wiki.ecmascript.org/doku.php?id=strawman:string_padding
var $      = require('./$')
  , repeat = require('./$.string-repeat');

module.exports = function(that, minLength, fillChar, left){
  // 1. Let O be CheckObjectCoercible(this value).
  // 2. Let S be ToString(O).
  var S = String($.assertDefined(that));
  // 4. If intMinLength is undefined, return S.
  if(minLength === undefined)return S;
  // 4. Let intMinLength be ToInteger(minLength).
  var intMinLength = $.toInteger(minLength);
  // 5. Let fillLen be the number of characters in S minus intMinLength.
  var fillLen = intMinLength - S.length;
  // 6. If fillLen < 0, then throw a RangeError exception.
  // 7. If fillLen is +∞, then throw a RangeError exception.
  if(fillLen < 0 || fillLen === Infinity){
    throw new RangeError('Cannot satisfy string length ' + minLength + ' for string: ' + S);
  }
  // 8. Let sFillStr be the string represented by fillStr.
  // 9. If sFillStr is undefined, let sFillStr be a space character.
  var sFillStr = fillChar === undefined ? ' ' : String(fillChar);
  // 10. Let sFillVal be a String made of sFillStr, repeated until fillLen is met.
  var sFillVal = repeat.call(sFillStr, Math.ceil(fillLen / sFillStr.length));
  // truncate if we overflowed
  if(sFillVal.length > fillLen)sFillVal = left
    ? sFillVal.slice(sFillVal.length - fillLen)
    : sFillVal.slice(0, fillLen);
  // 11. Return a string made from sFillVal, followed by S.
  // 11. Return a String made from S, followed by sFillVal.
  return left ? sFillVal.concat(S) : S.concat(sFillVal);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-pad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.string-repeat":36,"_process":99,"buffer":94}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $ = require('./$');

module.exports = function repeat(count){
  var str = String($.assertDefined(this))
    , res = ''
    , n   = $.toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.string-repeat.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $      = require('./$')
  , ctx    = require('./$.ctx')
  , cof    = require('./$.cof')
  , invoke = require('./$.invoke')
  , cel    = require('./$.dom-create')
  , global             = $.g
  , isFunction         = $.isFunction
  , html               = $.html
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , postMessage        = global.postMessage
  , addEventListener   = global.addEventListener
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
function run(){
  var id = +this;
  if($.has(queue, id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
}
function listner(event){
  run.call(event.data);
}
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!isFunction(setTask) || !isFunction(clearTask)){
  setTask = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(cof(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    };
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.task.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.ctx":11,"./$.dom-create":13,"./$.invoke":18,"_process":99,"buffer":94}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(exec){
  try {
    exec();
    return false;
  } catch(e){
    return true;
  }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.throws.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"_process":99,"buffer":94}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var sid = 0;
function uid(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++sid + Math.random()).toString(36));
}
uid.safe = require('./$').g.Symbol || uid;
module.exports = uid;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.uid.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./$.wks')('unscopables');
if(!(UNSCOPABLES in []))require('./$').hide(Array.prototype, UNSCOPABLES, {});
module.exports = function(key){
  [][UNSCOPABLES][key] = true;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.unscope.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.wks":41,"_process":99,"buffer":94}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var global = require('./$').g
  , store  = require('./$.shared')('wks');
module.exports = function(name){
  return store[name] || (store[name] =
    global.Symbol && global.Symbol[name] || require('./$.uid').safe('Symbol.' + name));
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/$.wks.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.shared":32,"./$.uid":39,"_process":99,"buffer":94}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $                = require('./$')
  , cel              = require('./$.dom-create')
  , cof              = require('./$.cof')
  , $def             = require('./$.def')
  , invoke           = require('./$.invoke')
  , arrayMethod      = require('./$.array-methods')
  , IE_PROTO         = require('./$.uid').safe('__proto__')
  , assert           = require('./$.assert')
  , assertObject     = assert.obj
  , ObjectProto      = Object.prototype
  , html             = $.html
  , A                = []
  , _slice           = A.slice
  , _join            = A.join
  , classof          = cof.classof
  , has              = $.has
  , defineProperty   = $.setDesc
  , getOwnDescriptor = $.getDesc
  , defineProperties = $.setDescs
  , isFunction       = $.isFunction
  , isObject         = $.isObject
  , toObject         = $.toObject
  , toLength         = $.toLength
  , toIndex          = $.toIndex
  , IE8_DOM_DEFINE   = false
  , $indexOf         = require('./$.array-includes')(false)
  , $forEach         = arrayMethod(0)
  , $map             = arrayMethod(1)
  , $filter          = arrayMethod(2)
  , $some            = arrayMethod(3)
  , $every           = arrayMethod(4);

if(!$.DESC){
  try {
    IE8_DOM_DEFINE = defineProperty(cel('div'), 'x',
      {get: function(){ return 8; }}
    ).x == 8;
  } catch(e){ /* empty */ }
  $.setDesc = function(O, P, Attributes){
    if(IE8_DOM_DEFINE)try {
      return defineProperty(O, P, Attributes);
    } catch(e){ /* empty */ }
    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
    if('value' in Attributes)assertObject(O)[P] = Attributes.value;
    return O;
  };
  $.getDesc = function(O, P){
    if(IE8_DOM_DEFINE)try {
      return getOwnDescriptor(O, P);
    } catch(e){ /* empty */ }
    if(has(O, P))return $.desc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
  };
  $.setDescs = defineProperties = function(O, Properties){
    assertObject(O);
    var keys   = $.getKeys(Properties)
      , length = keys.length
      , i = 0
      , P;
    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
    return O;
  };
}
$def($def.S + $def.F * !$.DESC, 'Object', {
  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $.getDesc,
  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  defineProperty: $.setDesc,
  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
  defineProperties: defineProperties
});

  // IE 8- don't enum bug keys
var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
            'toLocaleString,toString,valueOf').split(',')
  // Additional keys for getOwnPropertyNames
  , keys2 = keys1.concat('length', 'prototype')
  , keysLen1 = keys1.length;

// Create object with `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = cel('iframe')
    , i      = keysLen1
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write('<script>document.F=Object</script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict.prototype[keys1[i]];
  return createDict();
};
function createGetKeys(names, length){
  return function(object){
    var O      = toObject(object)
      , i      = 0
      , result = []
      , key;
    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(length > i)if(has(O, key = names[i++])){
      ~$indexOf(result, key) || result.push(key);
    }
    return result;
  };
}
function Empty(){}
$def($def.S, 'Object', {
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  getPrototypeOf: $.getProto = $.getProto || function(O){
    O = Object(assert.def(O));
    if(has(O, IE_PROTO))return O[IE_PROTO];
    if(isFunction(O.constructor) && O instanceof O.constructor){
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  },
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  create: $.create = $.create || function(O, /*?*/Properties){
    var result;
    if(O !== null){
      Empty.prototype = assertObject(O);
      result = new Empty();
      Empty.prototype = null;
      // add "__proto__" for Object.getPrototypeOf shim
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : defineProperties(result, Properties);
  },
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false),
  // 19.1.2.17 / 15.2.3.8 Object.seal(O)
  seal: function seal(it){
    return it; // <- cap
  },
  // 19.1.2.5 / 15.2.3.9 Object.freeze(O)
  freeze: function freeze(it){
    return it; // <- cap
  },
  // 19.1.2.15 / 15.2.3.10 Object.preventExtensions(O)
  preventExtensions: function preventExtensions(it){
    return it; // <- cap
  },
  // 19.1.2.13 / 15.2.3.11 Object.isSealed(O)
  isSealed: function isSealed(it){
    return !isObject(it); // <- cap
  },
  // 19.1.2.12 / 15.2.3.12 Object.isFrozen(O)
  isFrozen: function isFrozen(it){
    return !isObject(it); // <- cap
  },
  // 19.1.2.11 / 15.2.3.13 Object.isExtensible(O)
  isExtensible: function isExtensible(it){
    return isObject(it); // <- cap
  }
});

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
$def($def.P, 'Function', {
  bind: function(that /*, args... */){
    var fn       = assert.fn(this)
      , partArgs = _slice.call(arguments, 1);
    function bound(/* args... */){
      var args   = partArgs.concat(_slice.call(arguments))
        , constr = this instanceof bound
        , ctx    = constr ? $.create(fn.prototype) : that
        , result = invoke(fn, args, ctx);
      return constr ? ctx : result;
    }
    if(fn.prototype)bound.prototype = fn.prototype;
    return bound;
  }
});

// Fix for not array-like ES3 string and DOM objects
if(!(0 in Object('z') && 'z'[0] == 'z')){
  $.ES5Object = function(it){
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
}

var buggySlice = true;
try {
  if(html)_slice.call(html);
  buggySlice = false;
} catch(e){ /* empty */ }

$def($def.P + $def.F * buggySlice, 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return _slice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

$def($def.P + $def.F * ($.ES5Object != Object), 'Array', {
  join: function join(){
    return _join.apply($.ES5Object(this), arguments);
  }
});

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
$def($def.S, 'Array', {
  isArray: function(arg){
    return cof(arg) == 'Array';
  }
});
function createArrayReduce(isRight){
  return function(callbackfn, memo){
    assert.fn(callbackfn);
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = isRight ? length - 1 : 0
      , i      = isRight ? -1 : 1;
    if(arguments.length < 2)for(;;){
      if(index in O){
        memo = O[index];
        index += i;
        break;
      }
      index += i;
      assert(isRight ? index >= 0 : length > index, 'Reduce of empty array with no initial value');
    }
    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
      memo = callbackfn(memo, O[index], index, this);
    }
    return memo;
  };
}
$def($def.P, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: $.each = $.each || function forEach(callbackfn/*, that = undefined */){
    return $forEach(this, callbackfn, arguments[1]);
  },
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn/*, that = undefined */){
    return $map(this, callbackfn, arguments[1]);
  },
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn/*, that = undefined */){
    return $filter(this, callbackfn, arguments[1]);
  },
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn/*, that = undefined */){
    return $some(this, callbackfn, arguments[1]);
  },
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn/*, that = undefined */){
    return $every(this, callbackfn, arguments[1]);
  },
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: createArrayReduce(false),
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: createArrayReduce(true),
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(el /*, fromIndex = 0 */){
    return $indexOf(this, el, arguments[1]);
  },
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, $.toInteger(fromIndex));
    if(index < 0)index = toLength(length + index);
    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
    return -1;
  }
});

// 21.1.3.25 / 15.5.4.20 String.prototype.trim()
$def($def.P, 'String', {trim: require('./$.replacer')(/^\s*([\s\S]*\S)?\s*$/, '$1')});

// 20.3.3.1 / 15.9.4.4 Date.now()
$def($def.S, 'Date', {now: function(){
  return +new Date;
}});

function lz(num){
  return num > 9 ? num : '0' + num;
}

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
// PhantomJS and old webkit had a broken Date implementation.
var date       = new Date(-5e13 - 1)
  , brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z'
      && require('./$.throws')(function(){ new Date(NaN).toISOString(); }));
$def($def.P + $def.F * brokenDate, 'Date', {toISOString: function(){
  if(!isFinite(this))throw RangeError('Invalid time value');
  var d = this
    , y = d.getUTCFullYear()
    , m = d.getUTCMilliseconds()
    , s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
}});

if(classof(function(){ return arguments; }()) == 'Object')cof.classof = function(it){
  var tag = classof(it);
  return tag == 'Object' && isFunction(it.callee) ? 'Arguments' : tag;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es5.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.array-includes":2,"./$.array-methods":3,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.dom-create":13,"./$.invoke":18,"./$.replacer":29,"./$.throws":38,"./$.uid":39,"_process":99,"buffer":94}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
  copyWithin: function copyWithin(target/* = 0 */, start /* = 0, end = @length */){
    var O     = Object($.assertDefined(this))
      , len   = $.toLength(O.length)
      , to    = toIndex(target, len)
      , from  = toIndex(start, len)
      , end   = arguments[2]
      , fin   = end === undefined ? len : toIndex(end, len)
      , count = Math.min(fin - from, len - to)
      , inc   = 1;
    if(from < to && to < from + count){
      inc  = -1;
      from = from + count - 1;
      to   = to   + count - 1;
    }
    while(count-- > 0){
      if(from in O)O[to] = O[from];
      else delete O[to];
      to   += inc;
      from += inc;
    } return O;
  }
});
require('./$.unscope')('copyWithin');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.copy-within.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
  fill: function fill(value /*, start = 0, end = @length */){
    var O      = Object($.assertDefined(this))
      , length = $.toLength(O.length)
      , index  = toIndex(arguments[1], length)
      , end    = arguments[2]
      , endPos = end === undefined ? length : toIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
  }
});
require('./$.unscope')('fill');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.fill.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var KEY    = 'findIndex'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(6);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.find-index.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-methods":3,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var KEY    = 'find'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(5);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.find.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-methods":3,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $     = require('./$')
  , ctx   = require('./$.ctx')
  , $def  = require('./$.def')
  , $iter = require('./$.iter')
  , call  = require('./$.iter-call');
$def($def.S + $def.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = Object($.assertDefined(arrayLike))
      , mapfn   = arguments[1]
      , mapping = mapfn !== undefined
      , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
      , index   = 0
      , length, result, step, iterator;
    if($iter.is(O)){
      iterator = $iter.get(O);
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result   = new (typeof this == 'function' ? this : Array);
      for(; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, f, [step.value, index], true) : step.value;
      }
    } else {
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result = new (typeof this == 'function' ? this : Array)(length = $.toLength(O.length));
      for(; length > index; index++){
        result[index] = mapping ? f(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.from.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.ctx":11,"./$.def":12,"./$.iter":22,"./$.iter-call":19,"./$.iter-detect":21,"_process":99,"buffer":94}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $          = require('./$')
  , setUnscope = require('./$.unscope')
  , ITER       = require('./$.uid').safe('iter')
  , $iter      = require('./$.iter')
  , step       = $iter.step
  , Iterators  = $iter.Iterators;

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , kind  = iter.k
    , index = iter.i++;
  if(!O || index >= O.length){
    iter.o = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

setUnscope('keys');
setUnscope('values');
setUnscope('entries');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.iterator.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.iter":22,"./$.iter-define":20,"./$.uid":39,"./$.unscope":40,"_process":99,"buffer":94}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def = require('./$.def');
$def($def.S, 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , length = arguments.length
      // strange IE quirks mode bug -> use typeof instead of isFunction
      , result = new (typeof this == 'function' ? this : Array)(length);
    while(length > index)result[index] = arguments[index++];
    result.length = length;
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"_process":99,"buffer":94}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./$.species')(Array);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.array.species.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.species":33,"_process":99,"buffer":94}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $             = require('./$')
  , HAS_INSTANCE  = require('./$.wks')('hasInstance')
  , FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(!$.isFunction(this) || !$.isObject(O))return false;
  if(!$.isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = $.getProto(O))if(this.prototype === O)return true;
  return false;
}});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.function.has-instance.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.wks":41,"_process":99,"buffer":94}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , NAME = 'name'
  , setDesc = $.setDesc
  , FunctionProto = Function.prototype;
// 19.2.4.2 name
NAME in FunctionProto || $.FW && $.DESC && setDesc(FunctionProto, NAME, {
  configurable: true,
  get: function(){
    var match = String(this).match(/^\s*function ([^ (]*)/)
      , name  = match ? match[1] : '';
    $.has(this, NAME) || setDesc(this, NAME, $.desc(5, name));
    return name;
  },
  set: function(value){
    $.has(this, NAME) || setDesc(this, NAME, $.desc(0, value));
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.function.name.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"_process":99,"buffer":94}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments[0]); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.map.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-strong":7,"_process":99,"buffer":94}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Infinity = 1 / 0
  , $def  = require('./$.def')
  , E     = Math.E
  , pow   = Math.pow
  , abs   = Math.abs
  , exp   = Math.exp
  , log   = Math.log
  , sqrt  = Math.sqrt
  , ceil  = Math.ceil
  , floor = Math.floor
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);
function roundTiesToEven(n){
  return n + 1 / EPSILON - 1 / EPSILON;
}

// 20.2.2.28 Math.sign(x)
function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
}
// 20.2.2.5 Math.asinh(x)
function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}
// 20.2.2.14 Math.expm1(x)
function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
}

$def($def.S, 'Math', {
  // 20.2.2.3 Math.acosh(x)
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
  },
  // 20.2.2.5 Math.asinh(x)
  asinh: asinh,
  // 20.2.2.7 Math.atanh(x)
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
  },
  // 20.2.2.9 Math.cbrt(x)
  cbrt: function cbrt(x){
    return sign(x = +x) * pow(abs(x), 1 / 3);
  },
  // 20.2.2.11 Math.clz32(x)
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * Math.LOG2E) : 32;
  },
  // 20.2.2.12 Math.cosh(x)
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  },
  // 20.2.2.14 Math.expm1(x)
  expm1: expm1,
  // 20.2.2.16 Math.fround(x)
  fround: function fround(x){
    var $abs  = abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  },
  // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , len  = arguments.length
      , larg = 0
      , arg, div;
    while(i < len){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  },
  // 20.2.2.18 Math.imul(x, y)
  imul: function imul(x, y){
    var UInt16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UInt16 & xn
      , yl = UInt16 & yn;
    return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
  },
  // 20.2.2.20 Math.log1p(x)
  log1p: function log1p(x){
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
  },
  // 20.2.2.21 Math.log10(x)
  log10: function log10(x){
    return log(x) / Math.LN10;
  },
  // 20.2.2.22 Math.log2(x)
  log2: function log2(x){
    return log(x) / Math.LN2;
  },
  // 20.2.2.28 Math.sign(x)
  sign: sign,
  // 20.2.2.30 Math.sinh(x)
  sinh: function sinh(x){
    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
  },
  // 20.2.2.33 Math.tanh(x)
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  },
  // 20.2.2.34 Math.trunc(x)
  trunc: function trunc(it){
    return (it > 0 ? floor : ceil)(it);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.math.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"_process":99,"buffer":94}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $          = require('./$')
  , isObject   = $.isObject
  , isFunction = $.isFunction
  , NUMBER     = 'Number'
  , $Number    = $.g[NUMBER]
  , Base       = $Number
  , proto      = $Number.prototype;
function toPrimitive(it){
  var fn, val;
  if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
  if(isFunction(fn = it.toString) && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to number");
}
function toNumber(it){
  if(isObject(it))it = toPrimitive(it);
  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
    var binary = false;
    switch(it.charCodeAt(1)){
      case 66 : case 98  : binary = true;
      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
    }
  } return +it;
}
if($.FW && !($Number('0o1') && $Number('0b1'))){
  $Number = function Number(it){
    return this instanceof $Number ? new Base(toNumber(it)) : toNumber(it);
  };
  $.each.call($.DESC ? $.getNames(Base) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES6 (in case, if modules with ES6 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
    ).split(','), function(key){
      if($.has(Base, key) && !$.has($Number, key)){
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    }
  );
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./$.redef')($.g, NUMBER, $Number);
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.number.constructor.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.redef":28,"_process":99,"buffer":94}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $     = require('./$')
  , $def  = require('./$.def')
  , abs   = Math.abs
  , floor = Math.floor
  , _isFinite = $.g.isFinite
  , MAX_SAFE_INTEGER = 0x1fffffffffffff; // pow(2, 53) - 1 == 9007199254740991;
function isInteger(it){
  return !$.isObject(it) && _isFinite(it) && floor(it) === it;
}
$def($def.S, 'Number', {
  // 20.1.2.1 Number.EPSILON
  EPSILON: Math.pow(2, -52),
  // 20.1.2.2 Number.isFinite(number)
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  },
  // 20.1.2.3 Number.isInteger(number)
  isInteger: isInteger,
  // 20.1.2.4 Number.isNaN(number)
  isNaN: function isNaN(number){
    return number != number;
  },
  // 20.1.2.5 Number.isSafeInteger(number)
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
  },
  // 20.1.2.6 Number.MAX_SAFE_INTEGER
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
  // 20.1.2.10 Number.MIN_SAFE_INTEGER
  MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
  // 20.1.2.12 Number.parseFloat(string)
  parseFloat: parseFloat,
  // 20.1.2.13 Number.parseInt(string, radix)
  parseInt: parseInt
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.number.statics.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"_process":99,"buffer":94}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');
$def($def.S, 'Object', {assign: require('./$.assign')});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.assign.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.assign":5,"./$.def":12,"_process":99,"buffer":94}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.10 Object.is(value1, value2)
var $def = require('./$.def');
$def($def.S, 'Object', {
  is: require('./$.same')
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.is.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.same":30,"_process":99,"buffer":94}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $def = require('./$.def');
$def($def.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.set-prototype-of.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.set-proto":31,"_process":99,"buffer":94}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $        = require('./$')
  , $def     = require('./$.def')
  , isObject = $.isObject
  , toObject = $.toObject;
$.each.call(('freeze,seal,preventExtensions,isFrozen,isSealed,isExtensible,' +
  'getOwnPropertyDescriptor,getPrototypeOf,keys,getOwnPropertyNames').split(',')
, function(KEY, ID){
  var fn     = ($.core.Object || {})[KEY] || Object[KEY]
    , forced = 0
    , method = {};
  method[KEY] = ID == 0 ? function freeze(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 1 ? function seal(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 2 ? function preventExtensions(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 3 ? function isFrozen(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 4 ? function isSealed(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 5 ? function isExtensible(it){
    return isObject(it) ? fn(it) : false;
  } : ID == 6 ? function getOwnPropertyDescriptor(it, key){
    return fn(toObject(it), key);
  } : ID == 7 ? function getPrototypeOf(it){
    return fn(Object($.assertDefined(it)));
  } : ID == 8 ? function keys(it){
    return fn(toObject(it));
  } : require('./$.get-names').get;
  try {
    fn('z');
  } catch(e){
    forced = 1;
  }
  $def($def.S + $def.F * forced, 'Object', method);
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.statics-accept-primitives.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.get-names":17,"_process":99,"buffer":94}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , tmp = {};
tmp[require('./$.wks')('toStringTag')] = 'z';
if(require('./$').FW && cof(tmp) != 'z'){
  require('./$.redef')(Object.prototype, 'toString', function toString(){
    return '[object ' + cof.classof(this) + ']';
  }, true);
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.object.to-string.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.redef":28,"./$.wks":41,"_process":99,"buffer":94}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , cof      = require('./$.cof')
  , $def     = require('./$.def')
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , setProto = require('./$.set-proto').set
  , same     = require('./$.same')
  , species  = require('./$.species')
  , SPECIES  = require('./$.wks')('species')
  , RECORD   = require('./$.uid').safe('record')
  , PROMISE  = 'Promise'
  , global   = $.g
  , process  = global.process
  , asap     = process && process.nextTick || require('./$.task').set
  , P        = global[PROMISE]
  , isFunction     = $.isFunction
  , isObject       = $.isObject
  , assertFunction = assert.fn
  , assertObject   = assert.obj
  , Wrapper;

function testResolve(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
}

var useNative = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = isFunction(P) && isFunction(P.resolve) && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
function isPromise(it){
  return isObject(it) && (useNative ? cof.classof(it) == 'Promise' : RECORD in it);
}
function sameConstructor(a, b){
  // library wrapper special case
  if(!$.FW && a === P && b === Wrapper)return true;
  return same(a, b);
}
function getConstructor(C){
  var S = assertObject(C)[SPECIES];
  return S != undefined ? S : C;
}
function isThenable(it){
  var then;
  if(isObject(it))then = it.then;
  return isFunction(then) ? then : false;
}
function notify(record){
  var chain = record.c;
  if(chain.length)asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    function run(react){
      var cb = ok ? react.ok : react.fail
        , ret, then;
      try {
        if(cb){
          if(!ok)record.h = true;
          ret = cb === true ? value : cb(value);
          if(ret === react.P){
            react.rej(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(ret)){
            then.call(ret, react.res, react.rej);
          } else react.res(ret);
        } else react.rej(value);
      } catch(err){
        react.rej(err);
      }
    }
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
  });
}
function isUnhandled(promise){
  var record = promise[RECORD]
    , chain  = record.a || record.c
    , i      = 0
    , react;
  if(record.h)return false;
  while(chain.length > i){
    react = chain[i++];
    if(react.fail || !isUnhandled(react.P))return false;
  } return true;
}
function $reject(value){
  var record = this
    , promise;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  setTimeout(function(){
    asap(function(){
      if(isUnhandled(promise = record.p)){
        if(cof(process) == 'process'){
          process.emit('unhandledRejection', value, promise);
        } else if(global.console && isFunction(console.error)){
          console.error('Unhandled promise rejection', value);
        }
      }
      record.a = undefined;
    });
  }, 1);
  notify(record);
}
function $resolve(value){
  var record = this
    , then, wrapper;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(then = isThenable(value)){
      wrapper = {r: record, d: false}; // wrap
      then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
    } else {
      record.v = value;
      record.s = 1;
      notify(record);
    }
  } catch(err){
    $reject.call(wrapper || {r: record, d: false}, err); // wrap
  }
}

// constructor polyfill
if(!useNative){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    assertFunction(executor);
    var record = {
      p: assert.inst(this, P, PROMISE),       // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false                                // <- handled rejection
    };
    $.hide(this, RECORD, record);
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.mix')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var S = assertObject(assertObject(this).constructor)[SPECIES];
      var react = {
        ok:   isFunction(onFulfilled) ? onFulfilled : true,
        fail: isFunction(onRejected)  ? onRejected  : false
      };
      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
        react.res = assertFunction(res);
        react.rej = assertFunction(rej);
      });
      var record = this[RECORD];
      record.c.push(react);
      if(record.a)record.a.push(react);
      if(record.s)notify(record);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

// export
$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
cof.set(P, PROMISE);
species(P);
species(Wrapper = $.core[PROMISE]);

// statics
$def($def.S + $def.F * !useNative, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    return new (getConstructor(this))(function(res, rej){ rej(r); });
  }
});
$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    return isPromise(x) && sameConstructor(x.constructor, this)
      ? x : new this(function(res){ res(x); });
  }
});
$def($def.S + $def.F * !(useNative && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C      = getConstructor(this)
      , values = [];
    return new C(function(res, rej){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        C.resolve(promise).then(function(value){
          results[index] = value;
          --remaining || res(results);
        }, rej);
      });
      else res(results);
    });
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C = getConstructor(this);
    return new C(function(res, rej){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(res, rej);
      });
    });
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.promise.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.ctx":11,"./$.def":12,"./$.for-of":15,"./$.iter-detect":21,"./$.mix":25,"./$.same":30,"./$.set-proto":31,"./$.species":33,"./$.task":37,"./$.uid":39,"./$.wks":41,"_process":99,"buffer":94}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $         = require('./$')
  , $def      = require('./$.def')
  , setProto  = require('./$.set-proto')
  , $iter     = require('./$.iter')
  , ITERATOR  = require('./$.wks')('iterator')
  , ITER      = require('./$.uid').safe('iter')
  , step      = $iter.step
  , assert    = require('./$.assert')
  , isObject  = $.isObject
  , getProto  = $.getProto
  , $Reflect  = $.g.Reflect
  , _apply    = Function.apply
  , assertObject = assert.obj
  , _isExtensible = Object.isExtensible || isObject
  , _preventExtensions = Object.preventExtensions
  // IE TP has broken Reflect.enumerate
  , buggyEnumerate = !($Reflect && $Reflect.enumerate && ITERATOR in $Reflect.enumerate({}));

function Enumerate(iterated){
  $.set(this, ITER, {o: iterated, k: undefined, i: 0});
}
$iter.create(Enumerate, 'Object', function(){
  var iter = this[ITER]
    , keys = iter.k
    , key;
  if(keys == undefined){
    iter.k = keys = [];
    for(key in iter.o)keys.push(key);
  }
  do {
    if(iter.i >= keys.length)return step(1);
  } while(!((key = keys[iter.i++]) in iter.o));
  return step(0, key);
});

var reflect = {
  // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
  apply: function apply(target, thisArgument, argumentsList){
    return _apply.call(target, thisArgument, argumentsList);
  },
  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
  construct: function construct(target, argumentsList /*, newTarget*/){
    var proto    = assert.fn(arguments.length < 3 ? target : arguments[2]).prototype
      , instance = $.create(isObject(proto) ? proto : Object.prototype)
      , result   = _apply.call(target, instance, argumentsList);
    return isObject(result) ? result : instance;
  },
  // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
  defineProperty: function defineProperty(target, propertyKey, attributes){
    assertObject(target);
    try {
      $.setDesc(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.4 Reflect.deleteProperty(target, propertyKey)
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = $.getDesc(assertObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  },
  // 26.1.6 Reflect.get(target, propertyKey [, receiver])
  get: function get(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = $.getDesc(assertObject(target), propertyKey), proto;
    if(desc)return $.has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getProto(target))
      ? get(proto, propertyKey, receiver)
      : undefined;
  },
  // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return $.getDesc(assertObject(target), propertyKey);
  },
  // 26.1.8 Reflect.getPrototypeOf(target)
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(assertObject(target));
  },
  // 26.1.9 Reflect.has(target, propertyKey)
  has: function has(target, propertyKey){
    return propertyKey in target;
  },
  // 26.1.10 Reflect.isExtensible(target)
  isExtensible: function isExtensible(target){
    return _isExtensible(assertObject(target));
  },
  // 26.1.11 Reflect.ownKeys(target)
  ownKeys: require('./$.own-keys'),
  // 26.1.12 Reflect.preventExtensions(target)
  preventExtensions: function preventExtensions(target){
    assertObject(target);
    try {
      if(_preventExtensions)_preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
  set: function set(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = $.getDesc(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getProto(target))){
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = $.desc(0);
    }
    if($.has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || $.desc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
};
// 26.1.14 Reflect.setPrototypeOf(target, proto)
if(setProto)reflect.setPrototypeOf = function setPrototypeOf(target, proto){
  setProto.check(target, proto);
  try {
    setProto.set(target, proto);
    return true;
  } catch(e){
    return false;
  }
};

$def($def.G, {Reflect: {}});

$def($def.S + $def.F * buggyEnumerate, 'Reflect', {
  // 26.1.5 Reflect.enumerate(target)
  enumerate: function enumerate(target){
    return new Enumerate(assertObject(target));
  }
});

$def($def.S, 'Reflect', reflect);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.reflect.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.def":12,"./$.iter":22,"./$.own-keys":26,"./$.set-proto":31,"./$.uid":39,"./$.wks":41,"_process":99,"buffer":94}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $       = require('./$')
  , cof     = require('./$.cof')
  , $RegExp = $.g.RegExp
  , Base    = $RegExp
  , proto   = $RegExp.prototype
  , re      = /a/g
  // "new" creates a new object
  , CORRECT_NEW = new $RegExp(re) !== re
  // RegExp allows a regex with flags as the pattern
  , ALLOWS_RE_WITH_FLAGS = function(){
    try {
      return $RegExp(re, 'i') == '/a/i';
    } catch(e){ /* empty */ }
  }();
if($.FW && $.DESC){
  if(!CORRECT_NEW || !ALLOWS_RE_WITH_FLAGS){
    $RegExp = function RegExp(pattern, flags){
      var patternIsRegExp  = cof(pattern) == 'RegExp'
        , flagsIsUndefined = flags === undefined;
      if(!(this instanceof $RegExp) && patternIsRegExp && flagsIsUndefined)return pattern;
      return CORRECT_NEW
        ? new Base(patternIsRegExp && !flagsIsUndefined ? pattern.source : pattern, flags)
        : new Base(patternIsRegExp ? pattern.source : pattern
          , patternIsRegExp && flagsIsUndefined ? pattern.flags : flags);
    };
    $.each.call($.getNames(Base), function(key){
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function(){ return Base[key]; },
        set: function(it){ Base[key] = it; }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    require('./$.redef')($.g, 'RegExp', $RegExp);
  }
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')$.setDesc(proto, 'flags', {
    configurable: true,
    get: require('./$.replacer')(/^.*\/(\w*)$/, '$1')
  });
}
require('./$.species')($RegExp);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.regexp.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.redef":28,"./$.replacer":29,"./$.species":33,"_process":99,"buffer":94}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments[0]); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.set.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-strong":7,"_process":99,"buffer":94}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(false);
$def($def.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.code-point-at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-at":34,"_process":99,"buffer":94}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def')
  , toLength = $.toLength;

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.endsWith(/./); }), 'String', {
  // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that = String($.assertDefined(this))
      , endPosition = arguments[1]
      , len = toLength(that.length)
      , end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    searchString += '';
    return that.slice(end - searchString.length, end) === searchString;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.ends-with.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.def":12,"./$.throws":38,"_process":99,"buffer":94}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def    = require('./$.def')
  , toIndex = require('./$').toIndex
  , fromCharCode = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res = []
      , len = arguments.length
      , i   = 0
      , code;
    while(len > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.from-code-point.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"_process":99,"buffer":94}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.7 String.prototype.includes(searchString, position = 0)
  includes: function includes(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    return !!~String($.assertDefined(this)).indexOf(searchString, arguments[1]);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.def":12,"_process":99,"buffer":94}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var set   = require('./$').set
  , $at   = require('./$.string-at')(true)
  , ITER  = require('./$.uid').safe('iter')
  , $iter = require('./$.iter')
  , step  = $iter.step;

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  set(this, ITER, {o: String(iterated), i: 0});
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , index = iter.i
    , point;
  if(index >= O.length)return step(1);
  point = $at(O, index);
  iter.i += point.length;
  return step(0, point);
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.iterator.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.iter":22,"./$.iter-define":20,"./$.string-at":34,"./$.uid":39,"_process":99,"buffer":94}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $    = require('./$')
  , $def = require('./$.def');

$def($def.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl = $.toObject(callSite.raw)
      , len = $.toLength(tpl.length)
      , sln = arguments.length
      , res = []
      , i   = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < sln)res.push(String(arguments[i]));
    } return res.join('');
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.raw.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"_process":99,"buffer":94}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./$.string-repeat')
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.repeat.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-repeat":36,"_process":99,"buffer":94}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.startsWith(/./); }), 'String', {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
  startsWith: function startsWith(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that  = String($.assertDefined(this))
      , index = $.toLength(Math.min(arguments[1], that.length));
    searchString += '';
    return that.slice(index, index + searchString.length) === searchString;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.string.starts-with.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.cof":6,"./$.def":12,"./$.throws":38,"_process":99,"buffer":94}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
// ECMAScript 6 symbols shim
var $        = require('./$')
  , setTag   = require('./$.cof').set
  , uid      = require('./$.uid')
  , shared   = require('./$.shared')
  , $def     = require('./$.def')
  , $redef   = require('./$.redef')
  , keyOf    = require('./$.keyof')
  , enumKeys = require('./$.enum-keys')
  , assertObject = require('./$.assert').obj
  , ObjectProto = Object.prototype
  , DESC     = $.DESC
  , has      = $.has
  , $create  = $.create
  , getDesc  = $.getDesc
  , setDesc  = $.setDesc
  , desc     = $.desc
  , $names   = require('./$.get-names')
  , getNames = $names.get
  , toObject = $.toObject
  , $Symbol  = $.g.Symbol
  , setter   = false
  , TAG      = uid('tag')
  , HIDDEN   = uid('hidden')
  , _propertyIsEnumerable = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols = shared('symbols')
  , useNative = $.isFunction($Symbol);

var setSymbolDesc = DESC ? function(){ // fallback for old Android
  try {
    return $create(setDesc({}, HIDDEN, {
      get: function(){
        return setDesc(this, HIDDEN, {value: false})[HIDDEN];
      }
    }))[HIDDEN] || setDesc;
  } catch(e){
    return function(it, key, D){
      var protoDesc = getDesc(ObjectProto, key);
      if(protoDesc)delete ObjectProto[key];
      setDesc(it, key, D);
      if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
    };
  }
}() : setDesc;

function wrap(tag){
  var sym = AllSymbols[tag] = $.set($create($Symbol.prototype), TAG, tag);
  DESC && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, desc(1, value));
    }
  });
  return sym;
}

function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, desc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = $create(D, {enumerable: desc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
}
function defineProperties(it, P){
  assertObject(it);
  var keys = enumKeys(P = toObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)defineProperty(it, key = keys[i++], P[key]);
  return it;
}
function create(it, P){
  return P === undefined ? $create(it) : defineProperties($create(it), P);
}
function propertyIsEnumerable(key){
  var E = _propertyIsEnumerable.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
}
function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
}
function getOwnPropertyNames(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
}
function getOwnPropertySymbols(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
}

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments[0]));
  };
  $redef($Symbol.prototype, 'toString', function(){
    return this[TAG];
  });

  $.create     = create;
  $.setDesc    = defineProperty;
  $.getDesc    = getOwnPropertyDescriptor;
  $.setDescs   = defineProperties;
  $.getNames   = $names.get = getOwnPropertyNames;
  $.getSymbols = getOwnPropertySymbols;

  if($.DESC && $.FW)$redef(ObjectProto, 'propertyIsEnumerable', propertyIsEnumerable, true);
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
    'species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), function(it){
    var sym = require('./$.wks')(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  }
);

setter = true;

$def($def.G + $def.W, {Symbol: $Symbol});

$def($def.S, 'Symbol', symbolStatics);

$def($def.S + $def.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: getOwnPropertySymbols
});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setTag($.g.JSON, 'JSON', true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.symbol.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.enum-keys":14,"./$.get-names":17,"./$.keyof":24,"./$.redef":28,"./$.shared":32,"./$.uid":39,"./$.wks":41,"_process":99,"buffer":94}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $         = require('./$')
  , weak      = require('./$.collection-weak')
  , leakStore = weak.leakStore
  , ID        = weak.ID
  , WEAK      = weak.WEAK
  , has       = $.has
  , isObject  = $.isObject
  , isExtensible = Object.isExtensible || isObject
  , tmp       = {};

// 23.3 WeakMap Objects
var $WeakMap = require('./$.collection')('WeakMap', function(get){
  return function WeakMap(){ return get(this, arguments[0]); };
}, {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      if(!isExtensible(key))return leakStore(this).get(key);
      if(has(key, WEAK))return key[WEAK][this[ID]];
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
}, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  $.each.call(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    require('./$.redef')(proto, key, function(a, b){
      // store frozen objects on leaky map
      if(isObject(a) && !isExtensible(a)){
        var result = leakStore(this)[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.weak-map.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.collection":10,"./$.collection-weak":9,"./$.redef":28,"_process":99,"buffer":94}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var weak = require('./$.collection-weak');

// 23.4 WeakSet Objects
require('./$.collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments[0]); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es6.weak-set.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection":10,"./$.collection-weak":9,"_process":99,"buffer":94}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def      = require('./$.def')
  , $includes = require('./$.array-includes')(true);
$def($def.P, 'Array', {
  // https://github.com/domenic/Array.prototype.includes
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments[1]);
  }
});
require('./$.unscope')('includes');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.array.includes.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.array-includes":2,"./$.def":12,"./$.unscope":40,"_process":99,"buffer":94}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Map');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.map.to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection-to-json":8,"_process":99,"buffer":94}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://gist.github.com/WebReflection/9353781
var $       = require('./$')
  , $def    = require('./$.def')
  , ownKeys = require('./$.own-keys');

$def($def.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O      = $.toObject(object)
      , result = {};
    $.each.call(ownKeys(O), function(key){
      $.setDesc(result, key, $.desc(0, $.getDesc(O, key)));
    });
    return result;
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.own-keys":26,"_process":99,"buffer":94}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://goo.gl/XkBrjD
var $    = require('./$')
  , $def = require('./$.def');
function createObjectToArray(isEntries){
  return function(object){
    var O      = $.toObject(object)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = Array(length)
      , key;
    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
    else while(length > i)result[i] = O[keys[i++]];
    return result;
  };
}
$def($def.S, 'Object', {
  values:  createObjectToArray(false),
  entries: createObjectToArray(true)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.object.to-array.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"_process":99,"buffer":94}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://gist.github.com/kangax/9698100
var $def = require('./$.def');
$def($def.S, 'RegExp', {
  escape: require('./$.replacer')(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.regexp.escape.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.replacer":29,"_process":99,"buffer":94}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Set');
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.set.to-json.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.collection-to-json":8,"_process":99,"buffer":94}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// https://github.com/mathiasbynens/String.prototype.at
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(true);
$def($def.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.at.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-at":34,"_process":99,"buffer":94}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  lpad: function lpad(n){
    return $pad(this, n, arguments[1], true);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.lpad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-pad":35,"_process":99,"buffer":94}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  rpad: function rpad(n){
    return $pad(this, n, arguments[1], false);
  }
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/es7.string.rpad.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.string-pad":35,"_process":99,"buffer":94}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// JavaScript 1.6 / Strawman array statics shim
var $       = require('./$')
  , $def    = require('./$.def')
  , $Array  = $.core.Array || Array
  , statics = {};
function setStatics(keys, length){
  $.each.call(keys.split(','), function(key){
    if(length == undefined && key in $Array)statics[key] = $Array[key];
    else if(key in [])statics[key] = require('./$.ctx')(Function.call, [][key], length);
  });
}
setStatics('pop,reverse,shift,keys,values,entries', 1);
setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
           'reduce,reduceRight,copyWithin,fill,turn');
$def($def.S, 'Array', statics);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/js.array.statics.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.ctx":11,"./$.def":12,"_process":99,"buffer":94}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./es6.array.iterator');
var $           = require('./$')
  , Iterators   = require('./$.iter').Iterators
  , ITERATOR    = require('./$.wks')('iterator')
  , ArrayValues = Iterators.Array
  , NL          = $.g.NodeList
  , HTC         = $.g.HTMLCollection
  , NLProto     = NL && NL.prototype
  , HTCProto    = HTC && HTC.prototype;
if($.FW){
  if(NL && !(ITERATOR in NLProto))$.hide(NLProto, ITERATOR, ArrayValues);
  if(HTC && !(ITERATOR in HTCProto))$.hide(HTCProto, ITERATOR, ArrayValues);
}
Iterators.NodeList = Iterators.HTMLCollection = ArrayValues;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.dom.iterable.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.iter":22,"./$.wks":41,"./es6.array.iterator":48,"_process":99,"buffer":94}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var $def  = require('./$.def')
  , $task = require('./$.task');
$def($def.G + $def.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.immediate.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$.def":12,"./$.task":37,"_process":99,"buffer":94}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// ie9- setTimeout & setInterval additional parameters fix
var $         = require('./$')
  , $def      = require('./$.def')
  , invoke    = require('./$.invoke')
  , partial   = require('./$.partial')
  , navigator = $.g.navigator
  , MSIE      = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
function wrap(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      $.isFunction(fn) ? fn : Function(fn)
    ), time);
  } : set;
}
$def($def.G + $def.B + $def.F * MSIE, {
  setTimeout:  wrap($.g.setTimeout),
  setInterval: wrap($.g.setInterval)
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/modules/web.timers.js","/node_modules/babel-core/node_modules/core-js/modules")

},{"./$":23,"./$.def":12,"./$.invoke":18,"./$.partial":27,"_process":99,"buffer":94}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./modules/es5');
require('./modules/es6.symbol');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.object.statics-accept-primitives');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.number.constructor');
require('./modules/es6.number.statics');
require('./modules/es6.math');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.iterator');
require('./modules/es6.array.species');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.regexp');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.reflect');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.lpad');
require('./modules/es7.string.rpad');
require('./modules/es7.regexp.escape');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.to-array');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/js.array.statics');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/$').core;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/core-js/shim.js","/node_modules/babel-core/node_modules/core-js")

},{"./modules/$":23,"./modules/es5":42,"./modules/es6.array.copy-within":43,"./modules/es6.array.fill":44,"./modules/es6.array.find":46,"./modules/es6.array.find-index":45,"./modules/es6.array.from":47,"./modules/es6.array.iterator":48,"./modules/es6.array.of":49,"./modules/es6.array.species":50,"./modules/es6.function.has-instance":51,"./modules/es6.function.name":52,"./modules/es6.map":53,"./modules/es6.math":54,"./modules/es6.number.constructor":55,"./modules/es6.number.statics":56,"./modules/es6.object.assign":57,"./modules/es6.object.is":58,"./modules/es6.object.set-prototype-of":59,"./modules/es6.object.statics-accept-primitives":60,"./modules/es6.object.to-string":61,"./modules/es6.promise":62,"./modules/es6.reflect":63,"./modules/es6.regexp":64,"./modules/es6.set":65,"./modules/es6.string.code-point-at":66,"./modules/es6.string.ends-with":67,"./modules/es6.string.from-code-point":68,"./modules/es6.string.includes":69,"./modules/es6.string.iterator":70,"./modules/es6.string.raw":71,"./modules/es6.string.repeat":72,"./modules/es6.string.starts-with":73,"./modules/es6.symbol":74,"./modules/es6.weak-map":75,"./modules/es6.weak-set":76,"./modules/es7.array.includes":77,"./modules/es7.map.to-json":78,"./modules/es7.object.get-own-property-descriptors":79,"./modules/es7.object.to-array":80,"./modules/es7.regexp.escape":81,"./modules/es7.set.to-json":82,"./modules/es7.string.at":83,"./modules/es7.string.lpad":84,"./modules/es7.string.rpad":85,"./modules/js.array.statics":86,"./modules/web.dom.iterable":87,"./modules/web.immediate":88,"./modules/web.timers":89,"_process":99,"buffer":94}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(
      innerFn, self || null,
      new Context(tryLocsList || [])
    );

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function(arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument
        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
        : result;
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      var enqueueResult =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(function() {
          return invoke(method, arg);
        }) : new Promise(function(resolve) {
          resolve(invoke(method, arg));
        });

      // Avoid propagating enqueueResult failures to Promises returned by
      // later invocations of the iterator, and call generator.return() to
      // allow the generator a chance to clean up.
      previousPromise = enqueueResult.catch(invokeReturn);

      return enqueueResult;
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/node_modules/regenerator/runtime.js","/node_modules/babel-core/node_modules/regenerator")

},{"_process":99,"buffer":94}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = require("./lib/babel/polyfill");

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babel-core/polyfill.js","/node_modules/babel-core")

},{"./lib/babel/polyfill":1,"_process":99,"buffer":94}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = require("babel-core/polyfill");

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/babelify/polyfill.js","/node_modules/babelify")

},{"_process":99,"babel-core/polyfill":92,"buffer":94}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
    return fromTypedArray(that, object)
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = String(string)

  if (string.length === 0) return 0

  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      return string.length
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return string.length * 2
    case 'hex':
      return string.length >>> 1
    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(string).length
    case 'base64':
      return base64ToBytes(string).length
    default:
      return string.length
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/index.js","/node_modules/browserify/node_modules/buffer")

},{"_process":99,"base64-js":95,"buffer":94,"ieee754":96,"is-array":97}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib")

},{"_process":99,"buffer":94}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","/node_modules/browserify/node_modules/buffer/node_modules/ieee754")

},{"_process":99,"buffer":94}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js","/node_modules/browserify/node_modules/buffer/node_modules/is-array")

},{"_process":99,"buffer":94}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/events/events.js","/node_modules/browserify/node_modules/events")

},{"_process":99,"buffer":94}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/process/browser.js","/node_modules/browserify/node_modules/process")

},{"_process":99,"buffer":94}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/punycode/punycode.js","/node_modules/browserify/node_modules/punycode")

},{"_process":99,"buffer":94}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/decode.js","/node_modules/browserify/node_modules/querystring-es3")

},{"_process":99,"buffer":94}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/encode.js","/node_modules/browserify/node_modules/querystring-es3")

},{"_process":99,"buffer":94}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/querystring-es3/index.js","/node_modules/browserify/node_modules/querystring-es3")

},{"./decode":101,"./encode":102,"_process":99,"buffer":94}],104:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/browserify/node_modules/url/url.js","/node_modules/browserify/node_modules/url")

},{"_process":99,"buffer":94,"punycode":100,"querystring":103}],105:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

The MIT License (MIT)

Original Library 
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var ansiStyles = colors.styles = require('./styles');
var defineProps = Object.defineProperties;

colors.supportsColor = require('./system/supports-colors');

if (typeof colors.enabled === "undefined") {
  colors.enabled = colors.supportsColor;
}

colors.stripColors = colors.strip = function(str){
  return ("" + str).replace(/\x1B\[\d+m/g, '');
};


var stylize = colors.stylize = function stylize (str, style) {
  if (!colors.enabled) {
    return str+'';
  }

  return ansiStyles[style].open + str + ansiStyles[style].close;
}

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe,  '\\$&');
}

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function () {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function (key) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function () {
        return build(this._styles.concat(key));
      }
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = arguments;
  var argsLen = args.length;
  var str = argsLen !== 0 && String(arguments[0]);
  if (argsLen > 1) {
    for (var a = 1; a < argsLen; a++) {
      str += ' ' + args[a];
    }
  }

  if (!colors.enabled || !str) {
    return str;
  }

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
  }

  return str;
}

function applyTheme (theme) {
  for (var style in theme) {
    (function(style){
      colors[style] = function(str){
        if (typeof theme[style] === 'object'){
          var out = str;
          for (var i in theme[style]){
            out = colors[theme[style][i]](out);
          }
          return out;
        }
        return colors[theme[style]](str);
      };
    })(style)
  }
}

colors.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      colors.themes[theme] = require(theme);
      applyTheme(colors.themes[theme]);
      return colors.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function (name) {
    ret[name] = {
      get: function () {
        return build([name]);
      }
    };
  });
  return ret;
}

var sequencer = function sequencer (map, str) {
  var exploded = str.split(""), i = 0;
  exploded = exploded.map(map);
  return exploded.join("");
};

// custom formatter methods
colors.trap = require('./custom/trap');
colors.zalgo = require('./custom/zalgo');

// maps
colors.maps = {};
colors.maps.america = require('./maps/america');
colors.maps.zebra = require('./maps/zebra');
colors.maps.rainbow = require('./maps/rainbow');
colors.maps.random = require('./maps/random')

for (var map in colors.maps) {
  (function(map){
    colors[map] = function (str) {
      return sequencer(colors.maps[map], str);
    }
  })(map)
}

defineProps(colors, init());
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/colors.js","/node_modules/colors/lib")

},{"./custom/trap":106,"./custom/zalgo":107,"./maps/america":110,"./maps/rainbow":111,"./maps/random":112,"./maps/zebra":113,"./styles":114,"./system/supports-colors":115,"_process":99,"buffer":94}],106:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module['exports'] = function runTheTrap (text, options) {
  var result = "";
  text = text || "Run the trap, drop the bass";
  text = text.split('');
  var trap = {
    a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
    b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
    c: ["\u00a9", "\u023b", "\u03fe"],
    d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
    e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
    f: ["\u04fa"],
    g: ["\u0262"],
    h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
    i: ["\u0f0f"],
    j: ["\u0134"],
    k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
    l: ["\u0139"],
    m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
    n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
    o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
    p: ["\u01f7", "\u048e"],
    q: ["\u09cd"],
    r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
    s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
    t: ["\u0141", "\u0166", "\u0373"],
    u: ["\u01b1", "\u054d"],
    v: ["\u05d8"],
    w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
    x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
    y: ["\u00a5", "\u04b0", "\u04cb"],
    z: ["\u01b5", "\u0240"]
  }
  text.forEach(function(c){
    c = c.toLowerCase();
    var chars = trap[c] || [" "];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== "undefined") {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;

}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/custom/trap.js","/node_modules/colors/lib/custom")

},{"_process":99,"buffer":94}],107:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// please no
module['exports'] = function zalgo(text, options) {
  text = text || "   he is here   ";
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }
  

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] =   typeof options["up"]   !== 'undefined' ? options["up"]   : true;
    options["mid"] =  typeof options["mid"]  !== 'undefined' ? options["mid"]  : true;
    options["down"] = typeof options["down"] !== 'undefined' ? options["down"] : true;
    options["size"] = typeof options["size"] !== 'undefined' ? options["size"] : "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.mid = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.mid = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text, options);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/custom/zalgo.js","/node_modules/colors/lib/custom")

},{"_process":99,"buffer":94}],108:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('./colors');

module['exports'] = function () {

  //
  // Extends prototype of native string object to allow for "foo".red syntax
  //
  var addProperty = function (color, func) {
    String.prototype.__defineGetter__(color, func);
  };

  var sequencer = function sequencer (map, str) {
      return function () {
        var exploded = this.split(""), i = 0;
        exploded = exploded.map(map);
        return exploded.join("");
      }
  };

  addProperty('strip', function () {
    return colors.strip(this);
  });

  addProperty('stripColors', function () {
    return colors.strip(this);
  });

  addProperty("trap", function(){
    return colors.trap(this);
  });

  addProperty("zalgo", function(){
    return colors.zalgo(this);
  });

  addProperty("zebra", function(){
    return colors.zebra(this);
  });

  addProperty("rainbow", function(){
    return colors.rainbow(this);
  });

  addProperty("random", function(){
    return colors.random(this);
  });

  addProperty("america", function(){
    return colors.america(this);
  });

  //
  // Iterate through all default styles and colors
  //
  var x = Object.keys(colors.styles);
  x.forEach(function (style) {
    addProperty(style, function () {
      return colors.stylize(this, style);
    });
  });

  function applyTheme(theme) {
    //
    // Remark: This is a list of methods that exist
    // on String that you should not overwrite.
    //
    var stringPrototypeBlacklist = [
      '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
      'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
      'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
      'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
    ];

    Object.keys(theme).forEach(function (prop) {
      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
        console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
      }
      else {
        if (typeof(theme[prop]) === 'string') {
          colors[prop] = colors[theme[prop]];
          addProperty(prop, function () {
            return colors[theme[prop]](this);
          });
        }
        else {
          addProperty(prop, function () {
            var ret = this;
            for (var t = 0; t < theme[prop].length; t++) {
              ret = exports[theme[prop][t]](ret);
            }
            return ret;
          });
        }
      }
    });
  }

  colors.setTheme = function (theme) {
    if (typeof theme === 'string') {
      try {
        colors.themes[theme] = require(theme);
        applyTheme(colors.themes[theme]);
        return colors.themes[theme];
      } catch (err) {
        console.log(err);
        return err;
      }
    } else {
      applyTheme(theme);
    }
  };

};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/extendStringPrototype.js","/node_modules/colors/lib")

},{"./colors":105,"_process":99,"buffer":94}],109:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('./colors');
module['exports'] = colors;

// Remark: By default, colors will add style properties to String.prototype
//
// If you don't wish to extend String.prototype you can do this instead and native String will not be touched
//
//   var colors = require('colors/safe);
//   colors.red("foo")
//
//
require('./extendStringPrototype')();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/index.js","/node_modules/colors/lib")

},{"./colors":105,"./extendStringPrototype":108,"_process":99,"buffer":94}],110:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function() {
  return function (letter, i, exploded) {
    if(letter === " ") return letter;
    switch(i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter)
      case 2: return colors.blue(letter)
    }
  }
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/america.js","/node_modules/colors/lib/maps")

},{"../colors":105,"_process":99,"buffer":94}],111:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
})();


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/rainbow.js","/node_modules/colors/lib/maps")

},{"../colors":105,"_process":99,"buffer":94}],112:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = (function () {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
  return function(letter, i, exploded) {
    return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
  };
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/random.js","/node_modules/colors/lib/maps")

},{"../colors":105,"_process":99,"buffer":94}],113:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var colors = require('../colors');

module['exports'] = function (letter, i, exploded) {
  return i % 2 === 0 ? letter : colors.inverse(letter);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/maps/zebra.js","/node_modules/colors/lib/maps")

},{"../colors":105,"_process":99,"buffer":94}],114:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49]

};

Object.keys(codes).forEach(function (key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/styles.js","/node_modules/colors/lib")

},{"_process":99,"buffer":94}],115:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var argv = process.argv;

module.exports = (function () {
  if (argv.indexOf('--no-color') !== -1 ||
    argv.indexOf('--color=false') !== -1) {
    return false;
  }

  if (argv.indexOf('--color') !== -1 ||
    argv.indexOf('--color=true') !== -1 ||
    argv.indexOf('--color=always') !== -1) {
    return true;
  }

  if (process.stdout && !process.stdout.isTTY) {
    return false;
  }

  if (process.platform === 'win32') {
    return true;
  }

  if ('COLORTERM' in process.env) {
    return true;
  }

  if (process.env.TERM === 'dumb') {
    return false;
  }

  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    return true;
  }

  return false;
})();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/colors/lib/system/supports-colors.js","/node_modules/colors/lib/system")

},{"_process":99,"buffer":94}],116:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * @license
 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
      descriptor.value = null;
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * https://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.2';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/lodash/dist/lodash.js","/node_modules/lodash/dist")

},{"_process":99,"buffer":94}],117:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
	costs: {
		delete: number | function ( char )
		insert: number | function ( char )
		replace: number | function ( what, by )
		transpose: number | function ( left, right )
	}
*/

"use strict";

function getCost(costs, op, a, b) {
	var cost = typeof costs == "object" ? costs[op] : costs;
	return typeof cost == "function" ? cost.call(costs, a, b) : cost;
}

module.exports = function (s1, s2) {
	var costs = arguments[2] === undefined ? 1 : arguments[2];

	var d = [];
	for (var i = 0; i <= s1.length; ++i) {
		d[i] = i < 3 ? [] : d[i - 3]; // some optimization
		for (var j = 0; j <= s2.length; ++j) {
			d[i][j] = i == 0 && j == 0 ? 0 : i == 0 ? d[i][j - 1] + getCost(costs, "insert", s2[j - 1]) : j == 0 ? d[i - 1][j] + getCost(costs, "delete", s1[i - 1]) : Math.min(d[i - 1][j] + getCost(costs, "delete", s1[i - 1]), d[i][j - 1] + getCost(costs, "insert", s2[j - 1]), d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : getCost(costs, "replace", s1[i - 1], s2[j - 1])), i > 1 && j > 1 && s1[i - 1] == s2[j - 2] && s1[i - 2] == s2[j - 1] ? d[i - 2][j - 2] + getCost(costs, "transpose", s1[i - 2], s1[i - 1]) : Infinity);
		}
	}
	return d[s1.length][s2.length];
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/DamerauLevenshtein.js","/src")

},{"_process":99,"buffer":94}],118:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ra = require("ra");

module.exports = function (key) {
	var defaults = arguments[1] === undefined ? null : arguments[1];

	var ret = ra.clean(defaults).setConst("reset", function () {
		localStorage.removeItem(key);
		ret.assign(defaults);
	}).setName("localStorage." + key);
	var stored = localStorage.getItem(key);
	if (stored != null) ret.assign(JSON.parse(stored));
	ra.clean(function () {
		if (ret.valueOf() != defaults) localStorage.setItem(key, JSON.stringify(ret));
	});
	return ret;
};
// ret.loaded = true

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/JSONlocal.js","/src")

},{"_process":99,"buffer":94,"ra":136}],119:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

require("colors");

var LOG = function LOG(msg) {
  for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    data[_key - 1] = arguments[_key];
  }

  return console.log.apply(console, ["" + new Date().toISOString().replace("T", "=").replace("Z", "") + " " + msg].concat(data));
};
LOG.LOG = LOG;
LOG.INFO = LOG;
LOG.TRACE = LOG;
LOG.ERROR = LOG;
LOG.WARNING = LOG;

module.exports = LOG;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/LOG.js","/src")

},{"_process":99,"buffer":94,"colors":109}],120:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var lodash = require("lodash");

var PongJSON = (function (_require) {
	function PongJSON(q) {
		var _this = this;

		_classCallCheck(this, PongJSON);

		_get(Object.getPrototypeOf(PongJSON.prototype), "constructor", this).call(this);
		this._q = q;
		this.pipeFrom(q);
		q.onmessage = function (message) {
			return _this._message(message);
		};
	}

	_inherits(PongJSON, _require);

	_createClass(PongJSON, [{
		key: "unwise",
		value: function unwise() {
			var q = this._q;
			this._q = null;
			q.onopen = null;
			q.onclose = null;
			q.onerror = null;
			q.onmessage = null;
			return q.unwise ? q.unwise() : q;
		}
	}, {
		key: "_message",
		value: function _message(message) {
			if (message.what == "ping") this._q.send({ what: "pong", pong: message.ping });else this.domessage(message);
		}
	}, {
		key: "_send",
		value: function _send(message) {
			this._q.send(message);
		}
	}, {
		key: "_close",
		value: function _close() {
			this._q.onclose = null;
			this._q.close();
		}
	}]);

	return PongJSON;
})(require("WebQueue"));

var PingPongJSON = (function (_PongJSON) {
	function PingPongJSON(q) {
		var _this2 = this;

		var _ref = arguments[1] === undefined ? {} : arguments[1];

		var _ref$interval = _ref.interval;
		var interval = _ref$interval === undefined ? 60000 : _ref$interval;
		var _ref$timeout = _ref.timeout;
		var timeout = _ref$timeout === undefined ? 15000 : _ref$timeout;
		var _ref$maxpings = _ref.maxpings;
		var maxpings = _ref$maxpings === undefined ? 1000 : _ref$maxpings;

		_classCallCheck(this, PingPongJSON);

		_get(Object.getPrototypeOf(PingPongJSON.prototype), "constructor", this).call(this, q);
		this._pings = {};
		this._count = 0;
		this._pinterval = interval == Infinity ? null : setInterval(function () {
			return _this2.ping();
		}, interval);
		this._timeout = timeout;
		this._maxpings = maxpings;
	}

	_inherits(PingPongJSON, _PongJSON);

	_createClass(PingPongJSON, [{
		key: "_message",
		value: function _message(message) {
			if (message.what == "pong") {
				if (Object.prototype.hasOwnProperty.call(this._pings, message.pong)) {
					clearTimeout(this._pings[message.pong]);
					delete this._pings[message.pong];
					--this._count;
				}
			} else _get(Object.getPrototypeOf(PingPongJSON.prototype), "_message", this).call(this, message);
		}
	}, {
		key: "_send",
		value: function _send(message) {
			_get(Object.getPrototypeOf(PingPongJSON.prototype), "_send", this).call(this, message);
			this.ping();
		}
	}, {
		key: "_close",
		value: function _close() {
			clearInterval(this._pinterval);
			this._pinterval = null;
			lodash.forEach(this._pings, function (t) {
				return clearTimeout(t);
			});
			this._pings = null;
			_get(Object.getPrototypeOf(PingPongJSON.prototype), "_close", this).call(this);
		}
	}, {
		key: "ping",
		value: function ping() {
			var _this3 = this;

			if (!this._q) return;
			if (this._count > this._maxpings) return this._ontimeout();
			var id = "" + Math.random();
			this._q.send({ what: "ping", ping: id });
			this._pings[id] = setTimeout(function () {
				console.log(id.red);
				_this3._ontimeout();
			}, this._timeout);
			++this._count;
		}
	}, {
		key: "_ontimeout",
		value: function _ontimeout() {
			try {
				this.doerror(new Error("timeout"));
			} finally {
				this.close();
			}
		}
	}]);

	return PingPongJSON;
})(PongJSON);

module.exports = function (q, options) {
	return new PingPongJSON(q, options);
};
module.exports.silent = function (q) {
	return new PongJSON(q);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/PingPongJSON.js","/src")

},{"WebQueue":121,"_process":99,"buffer":94,"lodash":116}],121:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WebQueue = (function () {
	function WebQueue() {
		_classCallCheck(this, WebQueue);

		this.onopen = null;
		this.onclose = null;
		this.onmessage = null;
		this.onerror = null;
		this._closed = false;
		this._opened = false;
	}

	_createClass(WebQueue, [{
		key: "doopen",
		value: function doopen() {
			if (!this._closed && this.onopen && !this._opened) {
				this._opened = true;
				this.onopen();
			}
		}
	}, {
		key: "doclose",
		value: function doclose() {
			if (this.onclose) this.onclose();
		}
	}, {
		key: "domessage",
		value: function domessage(message) {
			if (!this._closed && this.onmessage) {
				if (!this._opened) this.doopen();
				this.onmessage(message);
			}
		}
	}, {
		key: "doerror",
		value: function doerror(error) {
			if (this.onerror) this.onerror(error);else process.nextTick(function () {
				throw error;
			});
		}
	}, {
		key: "_send",
		value: function _send() {}
	}, {
		key: "send",
		value: function send(message) {
			if (!this._closed) this._send(message);
		}
	}, {
		key: "_close",
		value: function _close() {}
	}, {
		key: "close",
		value: function close() {
			if (this._closed) return;
			try {
				this._close();
			} finally {
				this._closed = true;
				this.doclose();
			}
		}
	}, {
		key: "pipeFrom",
		value: function pipeFrom(q) {
			var _this = this;

			q.onopen = function () {
				return _this.doopen();
			};
			q.onclose = function () {
				return _this.close();
			};
			q.onerror = function (error) {
				return _this.doerror(error);
			};
			q.onmessage = function (message) {
				return _this.domessage(message);
			};
		}
	}]);

	return WebQueue;
})();

module.exports = WebQueue;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/WebQueue.js","/src")

},{"_process":99,"buffer":94}],122:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var WebSocketToJSON = (function (_require) {
	function WebSocketToJSON(ws) {
		var _this = this;

		_classCallCheck(this, WebSocketToJSON);

		_get(Object.getPrototypeOf(WebSocketToJSON.prototype), "constructor", this).call(this);
		this._ws = ws;
		this.pipeFrom(ws);
		ws.onmessage = function (event) {
			var message = undefined;
			try {
				message = JSON.parse(String(event.data));
			} catch (error) {
				return _this.doerror(error);
			}
			_this.domessage(message);
		};
	}

	_inherits(WebSocketToJSON, _require);

	_createClass(WebSocketToJSON, [{
		key: "unwise",
		value: function unwise() {
			var ws = this._ws;
			this._ws = null;
			ws.onopen = null;
			ws.onclose = null;
			ws.onerror = null;
			ws.onmessage = null;
			return ws;
		}
	}, {
		key: "_send",
		value: function _send(message) {
			this._ws.send(JSON.stringify(message));
		}
	}, {
		key: "_close",
		value: function _close() {
			this._ws.onclose = null;
			this._ws.close();
		}
	}]);

	return WebSocketToJSON;
})(require("WebQueue"));

module.exports = function (ws) {
	return new WebSocketToJSON(ws);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/WebSocketToJSON.js","/src")

},{"WebQueue":121,"_process":99,"buffer":94}],123:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

TODO 2015.03.25 У ТЗ не было: Рэдагаваньне месцаў магчыма патрэбнае толькі лакальна з асобнымі камандамі меню "захаваць для змоўчанага" і "загрузіць на ўсе прылады".

*/
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var JSONlocal = require("JSONlocal");
var lu = require("localUtils");
var ra = require("ra");
var lodash = require("lodash");
var UID = require("uid");
var httpClient = require("httpClient");
var EventEmitter = require("events").EventEmitter || require("events");
// let deviceActions = require( `netro/deviceActions` )
var WebSocketToJSON = require("WebSocketToJSON");
var PingPongJSON = require("PingPongJSON");
var devdb = require("devdb");

var WebSocketRetry = 1000;
var savePlacesTimeout = 3000;

var PersistentWebSocket = (function (_EventEmitter) {
	function PersistentWebSocket(url) {
		_classCallCheck(this, PersistentWebSocket);

		_get(Object.getPrototypeOf(PersistentWebSocket.prototype), "constructor", this).call(this);
		this.connected = false;
		this.closed = false;
		this._ws = null;
		this._sheduledCreating = null;
		this._first = true;
		this._lastClose = -Infinity;
		this.url = url;
		this.user = undefined;
		this.key = undefined
		// window.addEventListener( `_application_resumed` )
		;
	}

	_inherits(PersistentWebSocket, _EventEmitter);

	_createClass(PersistentWebSocket, [{
		key: "_setConnected",
		value: function _setConnected(value) {
			value = !!value;
			if (this.connected != value) {
				this.connected = value;
				this.emit("changed", value);
			}
		}
	}, {
		key: "_clearHandle",
		value: function _clearHandle() {
			if (this._ws) {
				this._ws.onclose = null;
				this._ws.close();
				this._ws = null;
				this._setConnected(false);
			}
			if (this._sheduledCreating) {
				clearTimeout(this._sheduledCreating);
				this._sheduledCreating = null;
			}
		}
	}, {
		key: "_ensureHandle",
		value: function _ensureHandle() {
			if (!this._ws) this._createHandle();
		}
	}, {
		key: "_createHandle",
		value: function _createHandle() {
			var _this = this;

			this._clearHandle();
			if (!this._url) return;
			this._ws = PingPongJSON(WebSocketToJSON(new WebSocket(this._url)));
			this._ws.onclose = function () {
				_this._ws = null;
				_this._setConnected(false);
				_this.emit("pause");
				if (!_this.closed) {
					var t = _this._lastClose;
					_this._lastClose = Date.now();
					_this._sheduledCreating = setTimeout(function () {
						_this._createHandle();
					}, Math.max(0, WebSocketRetry - (_this._lastClose - t)));
				}
			};
			this._ws.onerror = function (error) {
				_this.emit("error", error);
			};
			this._ws.onopen = function () {
				_this._setConnected(true);
				if (_this._first) {
					_this._first = false;
					_this.emit("open");
				}
				_this.emit("resume");
			};
			this._ws.onmessage = function (message) {
				_this.emit("message", message);
			};
		}
	}, {
		key: "reinit",
		value: function reinit() {
			this._ws && this._ws.close();
		}
	}, {
		key: "send",
		value: function send(data) {
			this._ensureHandle();
			if (!(this._ws && this.connected && !this.closed)) throw new Error("socket is not open");
			this._ws.send(data);
		}
	}, {
		key: "delete",
		value: function _delete() {
			this.close();
		}
	}, {
		key: "close",
		value: function close() {
			this.closed = true;
			this._clearHandle();
			this.emit("close");
		}
	}, {
		key: "ask",
		value: function ask(question) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var id, message;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							id = UID();

							this.send({ id: id, question: question });
							context$3$0.next = 4;
							return this.get(id);

						case 4:
							message = context$3$0.sent;

							if (!message.error) {
								context$3$0.next = 7;
								break;
							}

							throw new Error(message.error);

						case 7:
							return context$3$0.abrupt("return", message.answer);

						case 8:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		}
	}, {
		key: "get",
		value: function get(predicate, timeout) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var _ref, event, data;

				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (typeof predicate == "string" || typeof predicate == "number") {
								(function () {
									var id = predicate;
									predicate = function (msg) {
										return msg.id == id;
									};
								})();
							} else if (!(typeof predicate == "function")) {
								(function () {
									var p = predicate;
									predicate = function (msg) {
										return lodash.every(p, function (value, key) {
											return msg[key] == value;
										});
									};
								})();
							}
							context$3$0.next = 3;
							return co.receive(this, { close: true, message: predicate, timeout: timeout });

						case 3:
							_ref = context$3$0.sent;
							event = _ref.event;
							data = _ref.data;

							if (!(event == "message")) {
								context$3$0.next = 8;
								break;
							}

							return context$3$0.abrupt("return", data);

						case 8:
							throw new Error("timeout");

						case 9:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		}
	}, {
		key: "url",
		get: function () {
			return this._url;
		},
		set: function (url) {
			this._url = url;
			this._createHandle();
		}
	}]);

	return PersistentWebSocket;
})(EventEmitter);

function wsClient(app, url) {
	var ws = new PersistentWebSocket();
	ra(function () {
		return ws.url = app.localModem && app.localModem + url;
	});
	ws.active = ra.on(ws, ["pause", "resume"], function () {
		return ws.connected;
	});
	return ws;
}

function wsJSONclient(app, url) {

	var json = JSONlocal(url, { uid: null });
	var ws = wsClient(app, url);
	var init = function init() {
		return ws.send({ what: "init", id: json.uid });
	};
	var resolvers = {};

	var doError = function doError(message, data) {
		throw new Error("wsJSONclient: " + message + ": " + JSON.stringify(data));
	};

	lu.on(ws, {
		resume: init,
		message: function message(_message) {
			switch (_message.what) {
				case "error":
					doError("error from server", _message);
				case "saved":
					{
						var resolve = resolvers[_message.messageId];
						delete resolvers[_message.messageId];
						resolve && resolve();
						return;
					}
				case "data":
					{
						if (_message.partial && _message.previous != json.uid) init();else if (Object.prototype.hasOwnProperty.call(_message, "data")) json.assign(lu.applyDiff(json.valueOf(), _message.data, _message.partial));
						return;
					}
				default:
					doError("unknown message from server", _message);
			}
		},
		error: function error() {
			app.onCredentials();
		}
	});

	function doReject(messageId, reject) {
		delete resolvers[messageId];
		reject();
	}

	var save = function save(partial, data) {
		return new Promise(function (resolve, reject) {
			var messageId = UID();
			resolvers[messageId] = resolve;
			ws.send({ what: "save", data: partial ? data : Object.assign({ __partial__: false }, data || {}), messageId: messageId });
			setTimeout(doReject, savePlacesTimeout, messageId, reject);
		});
	};

	return {
		data: json.getReadOnly(),
		active: ws.active,
		send: function send(data) {
			return save(false, data);
		},
		update: function update(data) {
			return save(true, data);
		},
		"delete": function _delete() {
			ws.close();
		}
	};
}

module.exports = function (appid) {

	var localDefaults = {
		activeDeviceId: "",
		language: "ru",
		iconSize: 40, // millimeters
		labels: true,
		placesPages: {}
	};

	var local = JSONlocal(appid, localDefaults);

	var app = ra.clean(Object.defineProperties({

		getMessage: function getMessage(data) {
			var language = local.language || "ru";
			return [language, "ru", "en", "by"].filter(function (l) {
				return Object.prototype.hasOwnProperty.call(data, l);
			}).map(function (l) {
				return data[l];
			})[0];
		},

		pageWidth: 2,
		pageHeight: 3,
		pageStarting: false,
		dialog: "",
		editing: false,
		moving: 0,
		history: [],
		menuElement: null, // div

		loggedin: false,
		// credentials: 1,
		onCredentials: function onCredentials() {
			this.loggedin = false;
		},

		go: function go(to, path) {
			var _this2 = this;

			if (!to) return;
			var h = this.history;
			var a = local.activeDeviceId;
			var l = undefined;
			while (h.length && (l = h[h.length - 1], l == to || l == a || path && path.indexOf(l) >= 0)) h.pop();
			if (a != to) h.push(a);
			path && h.push.apply(h, _toConsumableArray(path.filter(function (id) {
				return id != _this2.main;
			}).reverse()));
			local.activeDeviceId = to;
			this.dialog = "";
		},

		back: function back() {
			while (this.history.length) {
				var device = this.history.pop();
				if (this.getDevice(device)) return local.activeDeviceId = device;
			}
			local.activeDeviceId = this.main;
		},

		windowSize: require("windowSize").getReadOnly(),

		placesShifts: {},

		login: function login(name, pwd) {},

		getDevice: function getDevice(deviceId) {
			return this.devices.content && this.devices.content[lu.valueOf(deviceId)];
		},

		linkingPlaceId: null,

		setDatabase: function setDatabase(devices) {
			this.serverDevices.send(devices);
		},

		reset: function reset() {
			local.reset();
			this.setDatabase({ uid: UID() });
			this.dialog = "";
			this.editing = false;
			this.history.length = 0;
		},

		setTemplate: function setTemplate(template) {
			console.log(template);
			var devices = {
				uid: UID(),
				content: {}
			};
			function copy(template, device) {
				Object.keys(template).forEach(function (key) {
					return key != "image" && // TODO: !!!!!!!!
					key != "content" && key != "type" && (device[key] = template[key]);
				});
				return device;
			}
			function walk(template, id) {
				if (template.content || template.type == "place") {
					(function () {
						var content = {};
						devices.content[id] = copy(template, { type: "place", content: content });
						var index = 0;
						template.content && template.content.forEach(function (p) {
							return content[walk(p, UID())] = { index: index++ };
						});
					})();
				} else {
					devices.content[id] = copy(template, { type: "single" });
				}
				return id;
			}
			devices.main = walk(template, UID());
			this.setDatabase(devices);
		},

		message: function message(id) {
			var ret = this.messages && this.messages[id];
			if (ret == null) ret = id;
			return ret;
		},

		notification: function notification(message) {},

		saveDevice: function saveDevice(deviceId, device) {
			var diff = lu.makeDiff(this.getDevice(deviceId), device);
			return diff == null ? Promise.resolve() : this.serverDevices.update({ content: _defineProperty({}, deviceId, diff) });
		},

		newIndex: function newIndex(iconId) {
			return Object.keys(this.getDevice(iconId).content || {}).length + 1;
		},

		linkItem: function linkItem(iconId, itemId, extra) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var place, device, rec, packet, result;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!(iconId == itemId)) {
								context$3$0.next = 2;
								break;
							}

							throw new Error("cannot link place to itself");

						case 2:
							place = this.getDevice(iconId);
							device = this.getDevice(itemId);

							if (!(place.type == "group")) {
								context$3$0.next = 9;
								break;
							}

							if (place.group) {
								context$3$0.next = 7;
								break;
							}

							throw new Error("internal error: no GROUP number found");

						case 7:
							if (device.group) {
								context$3$0.next = 9;
								break;
							}

							throw new Error("cannot add unlinked device to a group");

						case 9:
							rec = this.localDevices.createRecord();
							context$3$0.prev = 10;
							packet = { content: _defineProperty({}, iconId, { content: _defineProperty({}, itemId, { index: this.newIndex(iconId) }) }) };
							result = !extra ? packet : lu.mergeDiffs(extra, packet);

							debugger;
							rec.assign(result);

							if (!(place.type == "group")) {
								context$3$0.next = 18;
								break;
							}

							context$3$0.next = 18;
							return this.command(itemId, "AppendTo", place.group);

						case 18:
							context$3$0.next = 20;
							return rec.save();

						case 20:
							context$3$0.prev = 20;

							rec.close();
							return context$3$0.finish(20);

						case 23:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[10,, 20, 23]]);
			}), this);
		},

		linkToFavourites: function linkToFavourites(itemId) {
			return this.linkItem(this.main, itemId);
		},

		linkActiveToFavourites: function linkActiveToFavourites(itemId) {
			return this.linkToFavourites(this.activeDeviceId);
		},

		addItem: function addItem(iconId, item) {
			var _content5;

			var id = arguments[2] === undefined ? UID() : arguments[2];
			var index = arguments[3] === undefined ? null : arguments[3];

			return this.serverDevices.update({ content: (_content5 = {}, _defineProperty(_content5, iconId, { content: _defineProperty({}, id, { index: index != null ? index : this.newIndex(iconId) }) }), _defineProperty(_content5, id, item), _content5) });
		},

		addPlace: function addPlace(iconId) {
			return this.addItem(iconId, {
				type: "place",
				ru: "Помещение",
				en: "Room"
			});
		},

		addDevice: function addDevice(iconId) {
			return this.addItem(iconId, {
				type: "single",
				ru: "Устройство",
				en: "Device"
			});
		},

		addGroup: function addGroup(iconId, id) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!id) id = UID();
							context$3$0.next = 3;
							return this.addItem(iconId, {
								type: "group",
								ru: "Группа",
								en: "Group"
							}, id);

						case 3:
							context$3$0.next = 5;
							return this.command(id, "Reserve");

						case 5:
							return context$3$0.abrupt("return", id);

						case 6:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}), this);
		},

		deleteItem: function deleteItem(iconId, itemId) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var place, rec;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							place = this.getDevice(iconId);
							rec = this.localDevices.createRecord();
							context$3$0.prev = 2;

							rec.assign({ content: _defineProperty({}, iconId, { content: _defineProperty({}, itemId, null) }) });

							if (!(place.type == "group" && place.group)) {
								context$3$0.next = 7;
								break;
							}

							context$3$0.next = 7;
							return this.command(itemId, "RemoveFrom", place.group);

						case 7:
							context$3$0.next = 9;
							return rec.save();

						case 9:
							context$3$0.prev = 9;

							rec.close();
							return context$3$0.finish(9);

						case 12:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[2,, 9, 12]]);
			}), this);
		},

		insertInto: function insertInto(iconId, itemId, fromId) {
			return this.linkItem(iconId, itemId, { content: _defineProperty({}, fromId, { content: _defineProperty({}, itemId, null) }) });
		},

		errors: null,
		"throw": function _throw(dialog, data, retry) {
			if (!dialog) throw new Error("an error has to have its own dialog");
			this.errors = (this.errors || []).concat([{
				dialog: dialog,
				data: data,
				retry: retry
			}]);
		},
		clearError: function clearError() {
			var _this3 = this;

			ra.detach(function () {
				if (_this3.error) {
					_this3.dialog = "";
					_this3.errors = _this3.errors && _this3.errors.slice(1);
				}
			});
		},

		error: null,

		purgeItem: function purgeItem(deviceId, force) {
			return co.gocall(regeneratorRuntime.mark(function callee$2$0() {
				var device, rec, cmd;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							device = this.getDevice(deviceId);
							rec = this.localDevices.createRecord();
							context$3$0.prev = 2;

							rec.assign(devdb.Clear(this.devices, deviceId));
							cmd = undefined;

							if (device && device.group != null) if (device.type == "group") cmd = "Clear";else if (device.type == "single") cmd = "Unlink";

							if (!cmd) {
								context$3$0.next = 11;
								break;
							}

							context$3$0.next = 9;
							return this.command(deviceId, cmd);

						case 9:
							context$3$0.next = 13;
							break;

						case 11:
							context$3$0.next = 13;
							return rec.save();

						case 13:
							context$3$0.prev = 13;

							if (!force) {
								context$3$0.next = 17;
								break;
							}

							context$3$0.next = 17;
							return rec.save();

						case 17:
							rec.close();
							// server MUST send us actual state BEFORE returning result of command execution
							if ((lu.valueOf(this.serverDevices.data) || 1)[deviceId]) this["throw"]("ErrorUnlinkingDevice", { deviceId: deviceId });
							return context$3$0.finish(13);

						case 20:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this, [[2,, 13, 20]]);
			}), this);
		},

		renameItem: function renameItem(iconId, name) {
			var ret = lodash.reduce(this.getDevice(iconId), function (ret, _, key) {
				if (key.length == 2) ret[key] = null;
				return ret;
			}, {});
			ret[localDefaults.language || "ru"] = name;
			return this.serverDevices.update({ content: _defineProperty({}, iconId, ret) });
		},

		command: function command(deviceId, cmd, data) {

			// debugger

			// TODO:
			// let newstate = deviceActions.getNewState( this.getDevice( deviceId ), cmd )
			// if ( newstate != null ) {
			// }

			return this.commands.ask({ device: deviceId, command: cmd, data: data });
		},

		iconCommand: function iconCommand(icon, iconId, cmd, data) {
			// console.log( icon, iconId, cmd )
			icon = lu.valueOf(icon);
			if (icon.type == "place" ? cmd == "Short" : cmd == "Long") return this.go(iconId);
			if (icon.type != "place" && !icon.group) {
				this.dialog = "AskToLinkDevice";
				this.linkingPlaceId = iconId;
				// return Promise.reject( new Error( `device not configured` ) )
				return Promise.resolve();
			}
			if (cmd == "Short" || cmd == "Long") {
				if (icon && icon.state) {
					cmd = "Set";
					data = 0;
				} else {
					cmd = "Set";
					data = 1;
				}
				// cmd = `Comfort_1`
			}
			return this.command(iconId, cmd, data);
		},

		focus: function focus(node) {
			// magic actions to force allow to show keyboard by input.focus() on iOS ( so far checked iOS 8 )
			setTimeout(function () {
				return node.focus();
			}, 400);
		},

		searchAction: null,
		searchFilter: null,

		icons: null,

		modules: new WeakMap(),
		load: function load(module) {
			var ret = this.modules.get(module);
			if (ret == null) {
				ret = module(app, local);
				this.modules.set(module, ret);
			}
			return ret;
		},

		hover: null,

		"debugger": function _debugger() {
			debugger;
		}

	}, {
		modemLocations: { // TODO абнаўляць!! інтэрфейсы як толькі яны ў мадэма абнаўляюцца!!

			get: function () {
				return httpClient.get("/modem_locations");
			},
			configurable: true,
			enumerable: true
		},
		localModem: {
			get: function () {
				return this.modemLocations ? this.modemLocations[0].url.replace(/^http(?=s?\:\/\/)/, "ws") : "";
			},
			configurable: true,
			enumerable: true
		},
		doLogin: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					var script;
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						var _this4 = this;

						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!(!this.loggedin && this.modemLocations)) {
									context$3$0.next = 23;
									break;
								}

								script = document.createElement("script");

								script.src = "" + this.modemLocations[0].url + "/login?" + UID();
								document.body.appendChild(script);
								context$3$0.prev = 4;
								context$3$0.next = 7;
								return script
								// yield Promise.race( [ co.promise( script ), co.timeout( 15000 ) ] )
								;

							case 7:
								context$3$0.next = 16;
								break;

							case 9:
								context$3$0.prev = 9;
								context$3$0.t0 = context$3$0["catch"](4);

								LOG("error while trying to login: " + (context$3$0.t0 && context$3$0.t0.message && context$3$0.t0));
								console.error(context$3$0.t0);
								context$3$0.next = 15;
								return co.sleep(300);

							case 15:
								return context$3$0.abrupt("continue", 0);

							case 16:
								context$3$0.prev = 16;

								document.body.removeChild(script);
								return context$3$0.finish(16);

							case 19:
								LOG("logged in");
								ra.detach(function () {
									return _this4.loggedin = true;
								});
								context$3$0.next = 0;
								break;

							case 23:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this, [[4, 9, 16, 19]]);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		serverDevices: {
			get: function () {
				return wsJSONclient(this, "/database");
			},
			configurable: true,
			enumerable: true
		},
		localDevices: {
			get: function () {
				var _this5 = this;

				return ra.db(this.serverDevices.data, function (data) {
					return _this5.serverDevices.update(data);
				});
			},
			configurable: true,
			enumerable: true
		},
		devices: {
			get: function () {
				return this.localDevices.valueOf() || {};
			},
			configurable: true,
			enumerable: true
		},
		commands: {
			get: function () {
				return wsClient(this, "/commands");
			},
			configurable: true,
			enumerable: true
		},
		connectedToServer: {
			get: function () {
				return true && this.serverDevices.active.valueOf() && this.commands.active.valueOf();
			},
			configurable: true,
			enumerable: true
		},
		main: {
			get: function () {
				return this.devices.main;
			},
			configurable: true,
			enumerable: true
		},
		activeDeviceId: {
			get: function () {
				return local.activeDeviceId || this.main;
			},
			configurable: true,
			enumerable: true
		},
		activeDevice: {
			get: function () {
				return this.getDevice(this.activeDeviceId);
			},
			configurable: true,
			enumerable: true
		},
		activeContentIds: {
			get: function () {
				var device = this.activeDevice;
				return ra.Array(lodash.keys(device && device.content).sort(function (a, b) {
					return device.content[a].index - device.content[b].index;
				}));
			},
			configurable: true,
			enumerable: true
		},
		activeContent: {
			get: function () {
				return ra.Array(this.activeContentIds.map(this.getDevice));
			},
			configurable: true,
			enumerable: true
		},
		clearLinkingPlaceId: {
			get: function () {
				if (this.dialog != "AskToLinkDevice" && this.dialog != "AskIfDeviceHasBeenLinked") this.linkingPlaceId = null;
			},
			configurable: true,
			enumerable: true
		},
		checkIfTimeToGoBack: {
			get: function () {
				// lu.valueOf( this.places )
				if (!this.getDevice(this.activeDeviceId)) this.back();
			},
			configurable: true,
			enumerable: true
		},
		caption: {
			get: function () {
				return this.getMessage(this.getDevice(this.activeDeviceId)) || this.message("favorites");
			},
			configurable: true,
			enumerable: true
		},
		deviceType: {
			get: function () {
				var ret = this.getDevice(this.activeDeviceId);
				if (!ret) ret = this.getDevice(this.main);
				return ret && ret.type || "place";
			},
			configurable: true,
			enumerable: true
		},
		deviceIds: {
			get: function () {
				return ra.Array(lodash.keys(this.devices.content).sort());
			},
			configurable: true,
			enumerable: true
		},
		initialLoading: {
			get: function () {
				return !this.devices.uid;
			},
			configurable: true,
			enumerable: true
		},
		initialized: {
			get: function () {
				return !this.initialLoading && !!this.devices.main;
			},
			configurable: true,
			enumerable: true
		},
		templates: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								context$3$0.prev = 0;
								context$3$0.next = 3;
								return httpClient.get("/templates");

							case 3:
								return context$3$0.abrupt("return", context$3$0.sent);

							case 6:
								context$3$0.prev = 6;
								context$3$0.t0 = context$3$0["catch"](0);
								return context$3$0.abrupt("return", context$3$0.t0);

							case 9:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this, [[0, 6]]);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		allMessages: {
			get: function () {
				return regeneratorRuntime.mark(function callee$2$0() {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								context$3$0.next = 2;
								return httpClient.get("/messages");

							case 2:
								return context$3$0.abrupt("return", context$3$0.sent);

							case 3:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this);
				}).call(this);
			},
			configurable: true,
			enumerable: true
		},
		messages: {
			get: function () {
				var allMessages = this.allMessages;
				if (allMessages == null) return;
				var ret = {};
				var language = local.language || "ru";
				lodash.forOwn(allMessages, function (value, key) {
					return ret[key] = Object.prototype.hasOwnProperty.call(value, language) ? value[language] : key;
				});
				return ret;
			},
			configurable: true,
			enumerable: true
		},
		checkError: {
			get: function () {
				var _this6 = this;

				if (!this.dialog) if (this.errors && this.errors.length) ra.detach(function () {
					var error = _this6.errors[0];
					_this6.errors = _this6.errors && _this6.errors.slice(1);
					_this6.dialog = error.dialog;
					_this6.error = error;
				});else this.error = null;
			},
			configurable: true,
			enumerable: true
		},
		checkSearchDialog: {
			get: function () {
				if (this.dialog != "SearchItems") {
					this.searchAction = null;
					this.searchFilter = null;
				}
			},
			configurable: true,
			enumerable: true
		}
	})).setName("app");

	return { app: app, local: local };
};
// TODO: this code with an XMLHttpRequest does not work on iPhone :(((
// let xhr = new XMLHttpRequest
// xhr.open( `POST`, this.modemLocations[ 0 ].url + `/login`, true, `nero`, `123` )
// xhr.withCredentials = true
// try {
// 	xhr.send()
// 	yield xhr
// 	// alert( xhr.status )
// 	LOG( ( `` + xhr.status ).blue )
// 	if ( xhr.status >= 200 && xhr.status <= 299 )
// 		return ra.detach( () => this.loggedin = true )
// }
// catch ( error ) {
// 	// alert( `ERR` )
// 	console.log( `error while trying to login`, error )
// }
// yield co.sleep( 300 )

// alert( message )

// debugger

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/app.js","/src")

},{"JSONlocal":118,"PingPongJSON":120,"WebSocketToJSON":122,"_process":99,"buffer":94,"devdb":127,"events":98,"httpClient":131,"localUtils":134,"lodash":116,"ra":136,"uid":155,"windowSize":157}],124:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var MAX_TICKS = 100000;

var setTimeout = window.setTimeout;
// let setInterval = window.setInterval

process.nextTick = nextTick;

var queue = [];
var timer = null;
var processing = false;
var secret = "process-tick-" + Math.random();

var installTimer = function installTimer() {
	timer = setTimeout(onTimer, 1);
};

if (window.postMessage && window.addEventListener) {
	(function () {
		window.addEventListener("message", function (ev) {
			var source = ev.source;
			if ((source == window || source == null) && ev.data == secret) {
				ev.stopPropagation();
				onTimer();
			}
		});
		var postMessage = window.postMessage;
		installTimer = function () {
			postMessage(secret, "*");
			timer = true;
		};
	})();
}

!["setTimeout", "setInterval", "requestAnimationFrame"].forEach(function (name) {
	var proc = hookMethod(window, name, function (handler, time) {
		if (typeof arguments[0] == "function") arguments[0] = getProxy(arguments[0]);
		return proc.apply(this, arguments);
	});
});

![window, document].forEach(hookEventListener);

function onTimer() {
	timer = null;
	processQueue();
}

function ensureTimer() {
	if (!timer && !processing) installTimer();
}

function nextTick(fun) {
	queue.push(fun);
	ensureTimer();
}

function processQueue() {
	if (processing || !queue.length) return;
	var index = 0;
	processing = true;
	try {
		while (index < MAX_TICKS && index < queue.length) queue[index++]();
	} finally {
		// console.log( `ticks: ` + index )
		processing = false;
		queue.splice(0, index);
		if (queue.length) ensureTimer();
	}
}

function getProxy(handler) {
	function proxy() {
		var ret = handler.handleEvent ? handler.handleEvent.apply(handler, arguments) : handler.apply(this, arguments);
		processQueue();
		return ret;
	}
	var ret = undefined;
	if ((ret = handler[secret]) != null) return ret;else {
		assignProperty(proxy, secret, proxy);
		return assignProperty(handler, secret, proxy);
	}
}

function hookEventListener(obj) {
	if (obj.addEventListener) {
		(function () {
			var addEventListener = hookMethod(obj, "addEventListener", function (event, handler) {
				arguments[1] = getProxy(arguments[1]);
				return addEventListener.apply(this, arguments);
			});
			var removeEventListener = hookMethod(obj, "removeEventListener", function (event, handler) {
				if (arguments[1][secret]) arguments[1] = arguments[1][secret];
				return removeEventListener.apply(this, arguments);
			});
		})();
	}
}

function hookMethod(obj, name, proxy) {
	var ret = obj[name];
	if (ret) {
		assignProperty(proxy, "toString", function () {
			return ret.toString();
		});
		obj[name] = proxy;
	}
	return ret;
}

function assignProperty(obj, name, value) {
	if (Object.defineProperty) Object.defineProperty(obj, name, { value: value });else obj[name] = value;
	return value;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/browser-nexttick.js","/src")

},{"_process":99,"buffer":94}],125:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var later = require("later");
var EventEmitter = require("events").EventEmitter;

var co = module.exports = exports = new EventEmitter();

var threadCatcher = null;

exports.cb = null;
exports.global = null;

exports.go = function (fun) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	if (typeof fun == "function") fun = fun.apply(null, args);
	if (!fun.next) {
		(function () {
			var value = fun;
			fun = {
				next: function next() {
					var ret = { value: value, done: !value };
					value = null;
					return ret;
				}
			};
		})();
	}
	return new Thread(fun);
};

exports.gocall = function (fun, context) {
	for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
		args[_key2 - 2] = arguments[_key2];
	}

	return new Thread(fun.apply(context, args));
};

exports.func = function (fun) {
	if (arguments.length >= 2) fun = Array.prototype.reduceRight.call(arguments, function (g, f) {
		return f(g);
	});
	return function proc() {
		return new Thread(fun.apply(this, arguments));
	};
};

exports.eventHandler = function (fun) {
	return function proc() {
		var ret = new Thread(fun.apply(this, arguments));
		ret.waitForInput();
		return ret;
	};
};

// the first argument is an error, the second one is a result
exports.cbfunc = function (funWithCB) {
	return function () {
		var _this = this;

		for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
			args[_key3] = arguments[_key3];
		}

		return new Promise(function (resolve, reject) {
			return funWithCB.call.apply(funWithCB, [_this].concat(args, [function (error, value) {
				if (error != null) reject(error);else resolve(value);
			}]));
		});
	};
};

exports.catchThreads = function (cb, onThread) {
	var oldCatcher = threadCatcher;
	threadCatcher = onThread;
	try {
		return cb();
	} finally {
		threadCatcher = oldCatcher;
	}
};

exports.receive = function (emitter, events) {
	return new Promise(function (resolve, reject) {
		var handlers = Object.create(null);
		var timer = undefined;
		var rejecter = co.defer(function () {
			clear();
			reject();
		});

		var _loop = function (_event) {
			if (Object.prototype.hasOwnProperty.call(events, _event)) {
				var _ret3 = (function () {
					var predicate = events[_event];
					if (predicate == null)
						//
						// allow simpler events defining like
						//
						// yield co.receive( obj, { data: true, timeout: getTimeout( ... ) } )
						//
						// instead of
						//
						// let events = { data: true }
						// if ( getTimeout( ... ) != null ) events.timeout = getTimeout( ... )
						// yield co.receive( obj, events )
						//
						return {
							v: "continue"
						};
					if (_event == "timeout") timer = setTimeout(function () {
						return done("timeout", null);
					}, predicate);else emitter.addListener(_event, handlers[_event] = function (data) {
						if (typeof predicate != "function" || predicate(data)) done(_event, data);
					});
				})();

				if (typeof _ret3 === "object") return _ret3.v;
			}
		};

		for (var _event in events) {
			var _ret2 = _loop(_event);

			if (_ret2 === "continue") continue;
		}function clear() {
			if (!handlers) return;
			clearTimeout(timer);
			for (var _event2 in handlers) {
				emitter.removeListener(_event2, handlers[_event2]);
			}rejecter.close();
			handlers = null;
		}
		function done(event, data) {
			clear();
			resolve({ event: event, data: data });
		}
	});
};

var noopthen = { then: function then() {} };
exports.wait = function () {
	return noopthen;
};

exports.sleep = function (milliseconds) {
	return { then: function then(resolve) {
			var timer = setTimeout(resolve, milliseconds);
			return { kill: function kill() {
					clearTimout(timer);
				} };
		} };
};

exports.tick = exports.sleep(1);

exports.timeout = function (milliseconds) {
	return { then: function then(_, reject) {
			var timer = setTimeout(reject, milliseconds);
			return { kill: function kill() {
					clearTimout(timer);
				} };
		} };
};

exports.promise = function (value) {
	return Promise.all([co.go(regeneratorRuntime.mark(function callee$1$0() {
		return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
			while (1) switch (context$2$0.prev = context$2$0.next) {
				case 0:
					context$2$0.next = 2;
					return value;

				case 2:
				case "end":
					return context$2$0.stop();
			}
		}, callee$1$0, this);
	}))]);
};

exports.requestAnimationFrame = { then: function then(resolve) {
		if (typeof cancelAnimationFrame == "function") {
			var _ret4 = (function () {
				var frame = requestAnimationFrame(resolve);
				return {
					v: { kill: function kill() {
							cancelAnimationFrame(frame);
						} }
				};
			})();

			if (typeof _ret4 === "object") return _ret4.v;
		} else return exports.sleep(1).then(resolve);
	} };

var rethrow = function rethrow(e) {
	return setTimeout(function () {
		throw e;
	}, 1);
};

function iteratorFailed(error) {
	return { done: true, iteratorFailed: true, value: error };
}

function iteratorNext(iterator, result) {
	try {
		return iterator.next(result);
	} catch (error) {
		return iteratorFailed(error);
	}
}

function iteratorThrow(iterator, result) {
	if (!iterator["throw"]) return iteratorFailed(result);
	try {
		return iterator["throw"](result);
	} catch (error) {
		return iteratorFailed(error);
	}
}

var DONE = { done: true };

var EKill = (function (_Error) {
	function EKill() {
		var message = arguments[0] === undefined ? "kill" : arguments[0];

		_classCallCheck(this, EKill);

		_get(Object.getPrototypeOf(EKill.prototype), "constructor", this).call(this, message);
	}

	_inherits(EKill, _Error);

	return EKill;
})(Error);

exports.EKill = EKill;

function iteratorReturn(iterator) {
	if (iterator["return"]) {
		try {
			iterator["return"]();
		} catch (error) {
			return iteratorFailed(error);
		}
	} else if (iterator["throw"]) {
		var e = new EKill();
		var v = iteratorThrow(iterator, e);
		if (!v.done || !v.iteratorFailed) rethrow(new Error("thread has eaten EKill"));else if (v.value != e) return v;
	}
	return DONE;
}

function iteratorCheck(ret) {
	if (ret && ret.done && ret.iteratorFailed) throw ret.value;else return ret;
}

function killIterator(iterator) {
	if (iterator) {
		var res = iteratorReturn(iterator);
		if (res.done && res.iteratorFailed) rethrow(res.value);
	}
}

// Thread

var catchDefer = function catchDefer(func) {
	// optimization -- using try/catch in a separate function.
	try {
		return func();
	} catch (error) {
		return { next: function next() {
				return iteratorFailed(error);
			} };
	}
};

var IteratorProxy = (function () {
	function IteratorProxy(iterator) {
		_classCallCheck(this, IteratorProxy);

		if (iterator instanceof IteratorProxy) return iterator;
		this._iterator = iterator;
		this._deferred = null;
		this._result = null;
	}

	_createClass(IteratorProxy, [{
		key: "defer",
		value: function defer(proc) {
			var _this2 = this;

			if (typeof proc != "function") throw new Error("type error: only functions can be deferred");
			if (!this._deferred) this._deferred = [];
			this._deferred.push(proc);
			return { close: function close() {
					if (_this2._deferred) for (var i = _this2._deferred.length - 1; i >= 0; --i) {
						if (_this2._deferred[i] == proc) {
							_this2._deferred.splice(i, 1);
							return;
						}
					}
				} };
		}
	}, {
		key: "save",
		value: function save(result) {
			if (!this._result) this._result = result;else if (result.iteratorFailed) {
				if (this._result.iteratorFailed) rethrow(this._result.value);
				this._result = result;
			}
		}
	}, {
		key: "call",
		value: function call(proc, value) {
			var old = IteratorProxy._iterator;
			IteratorProxy._iterator = this;
			try {
				start: for (;;) {
					var ret = proc(this._iterator, value);
					if (!ret.done) return ret;
					this._iterator = null;
					if (!this._deferred) return ret;
					this.save(ret);
					while (this._deferred.length) {
						var def = catchDefer(this._deferred.pop());
						if (def == null || typeof def.next != "function") continue;
						this._iterator = def;
						value = undefined;
						proc = iteratorNext;
						continue start;
					}
					ret = this._result;
					this._result = null;
					return ret;
				}
			} finally {
				IteratorProxy._iterator = old;
			}
		}
	}, {
		key: "next",
		value: function next(value) {
			return iteratorCheck(this.call(iteratorNext, value));
		}
	}, {
		key: "throw",
		value: function _throw(value) {
			return iteratorCheck(this.call(iteratorThrow, value));
		}
	}, {
		key: "return",
		value: function _return(value) {
			if (!this._iterator) return;
			this.save({ done: true, value: value });
			var old = IteratorProxy._iterator;
			IteratorProxy._iterator = this;
			try {
				var ret = iteratorReturn(this._iterator);
				this._iterator = null;
				if (!this.deferred) {
					iteratorCheck(ret);
					return;
				}
				this.save(ret);
				while (this._deferred.length) {
					var def = catchDefer(this._deferred.pop());
					if (def != null && typeof def.next == "function") {
						var _ret5 = iteratorNext(def);
						if (!_ret5.done) _ret5 = iteratorReturn(def);
						this.save(_ret5);
					}
				}
				ret = this._result;
				this._result = null;
				iteratorCheck(ret);
			} finally {
				IteratorProxy._iterator = old;
			}
		}
	}]);

	return IteratorProxy;
})();

IteratorProxy._iterator = null;

// function* _IteratorProxy( iterator ) {
// 	let deffered = []
// 	let ret = null
// 	function save( it ) {
// 		if ( ret == null || it.iteratorFailed ) {
// 			if ( ret && ret.iteratorFailed )
// 				rethrow( ret.value )
// 			ret = it
// 		}
// 	}
// 	let step = iteratorNext
// 	let it = null
// 	try {
// 		main: while ( true ) {
// 			let yieldResult
// 			step = iteratorNext
// 			if ( it != null ) {
// 				try {
// 					yieldResult = yield it.value
// 				}
// 				catch ( error ) {
// 					yieldResult = error
// 					step = iteratorThrow
// 				}
// 			}
// 			else
// 				yieldResult = undefined
// 			_IteratorProxy.deferred = deferred
// 			it = step( iterator, yieldResult )
// 			_IteratorProxy.deferred = null
// 			if ( !it.done )
// 				continue main
// 			save( it )
// 			it = undefined
// 			while ( deffered.length ) {
// 				iterator = catchDefer( deffered.shift() )
// 				if ( iterator != null && typeof iterator.next == `function` )
// 					continue main
// 			}
// 			iterator = null
// 			break main
// 		}
// 	}
// 	finally {
// 		if ( iterator )
// 			save( iteratorReturn( iterator ) )
// 		while ( deffered.length ) {
// 			iterator = catchDefer( deffered.shift() )
// 			if ( iterator != null && typeof iterator.next == `function` ) {
// 				it = iteratorNext( iterator, undefined )
// 				if ( !it.done )
// 					it = iteratorReturn( iterator )
// 				save( it )
// 			}
// 		}
// 		if ( ret )
// 			if ( ret.iteratorFailed )
// 				throw ret.value
// 			else
// 				return ret.value
// 	}
// }

exports.defer = function (proc) {
	if (!IteratorProxy._iterator) throw new Error("defer: not in a co-thread");
	return IteratorProxy._iterator.defer(proc);
};

// exports._defer = proc => {
// 	if ( typeof proc != `function` )
// 		throw new Error( `type error: only functions can be deferred` )
// 	let deferred = _IteratorProxy.deferred
// 	if ( deferred )
// 		throw new Error( `defer: not in a co-thread` )
// 	deferred.push( proc )
// 	return { close: () => {
// 		if ( deferred )
// 			for ( let i = deferred.length - 1; i >= 0; --i )
// 				if ( deferred[ i ] == proc ) {
// 					deferred.splice( i, 1 )
// 					return
// 				}
// 	} }
// }

var Thread = (function () {
	function Thread(iterator) {
		var _this3 = this;

		_classCallCheck(this, Thread);

		this._attachedToStack = true;
		this._iterator = new IteratorProxy(iterator);
		this._stopCount = 0;
		this._stack = [];
		this.global = Object.create(null);
		this._currentPromise = null;
		this._running = false;
		this._killing = null;
		this._cb = function (error, data) {
			if (_this3._step) if (error) _this3._step.fail(error);else _this3._step.next(data);
		};
		this.$name = { toString: function toString() {
				return "<Thread>";
			} };

		this._newStep();
		this._start = function () {
			if (_this3._start && _this3._step && _this3._step.next) {
				if (_this3._stopCount > 0) _this3._step.resume = _this3._start;else {
					_this3._start = null;
					_this3._step.next();
				}
			}
		};

		this._promise = new Promise(function (resolve, reject) {
			_this3._resolve = resolve;
			_this3._reject = reject;
		});
		if (!this._resolve) throw new Error("assertion failure: wrong implementation of Promise");

		later.then(this._start);
		if (threadCatcher) threadCatcher(this);

		exports.emit("start", this);
	}

	_createClass(Thread, [{
		key: "linkName",
		value: function linkName(value) {
			var suffix = arguments[1] === undefined ? ":thread" : arguments[1];

			if (value.$name) value = value.$name;
			this.$name.toString = function () {
				return "" + value + suffix;
			};
			return this;
		}
	}, {
		key: "waitForInput",
		value: function waitForInput() {
			this._checkFinished();
			if (this._stopCount > 0) throw new Error("thread is paused");
			if (this._start) this._start();
			return this;
		}
	}, {
		key: "_attachPromise",
		value: function _attachPromise(promise) {
			promise.kill = this.kill.bind(this);
			return promise;
		}
	}, {
		key: "then",
		value: function then(onFulfilled, onRejected) {
			this._attachedToStack = false;
			return this._attachPromise(this._promise.then(onFulfilled, onRejected));
		}
	}, {
		key: "catch",
		value: function _catch(onRejected) {
			this._attachedToStack = false;
			return this._attachPromise(this._promise["catch"](onRejected));
		}
	}, {
		key: "isFinished",
		value: function isFinished() {
			return !this._step || this._killing;
		}
	}, {
		key: "isPaused",
		value: function isPaused() {
			return this._stopCount > 0;
		}
	}, {
		key: "throw",
		value: function _throw(exception) {
			if (this.global == exports.global) throw exception;
			this._checkFinished();
			this._newStep();
			if (this._stopCount > 0) this._step.resume = this._step.fail.bind(this._step, exception);else this._step.fail(exception);
		}
	}, {
		key: "attachToStack",
		value: function attachToStack() {
			this._attachedToStack = true;
		}
	}, {
		key: "kill",
		value: function kill(reason) {
			if (this.isFinished()) return;
			this._reject(reason);
			if (this._running) {
				this._killing = { reason: reason };
				throw new EKill();
			}
			var previousThread = exports.current;
			var previosCB = exports.cb;
			var previosGlobal = exports.global;
			exports.cb = this._cb;
			exports.global = this.global;
			exports.current = this;
			killIterator(this._iterator);
			for (var a = this._stack, i = a.length - 1; i >= 0; --i) {
				killIterator(a[i]);
			}exports.cb = previosCB;
			exports.global = previosGlobal;
			exports.current = previousThread;
			if (this._currentPromise) {
				try {
					this._currentPromise.kill(reason);
				} catch (e) {
					rethrow(e);
				}
			}
			this._done();
		}
	}, {
		key: "pause",
		value: function pause() {
			this._checkFinished();
			++this._stopCount;
		}
	}, {
		key: "resume",
		value: function resume() {
			if (this._stopCount == 0) throw new Error("thread not paused");
			if (0 == --this._stopCount && this._step && this._step.resume) {
				later.then(this._step.resume);
				this._step.resume = null;
			}
		}
	}, {
		key: "_tick",
		value: function _tick(step, imethod, result) {
			if (this["debugger"] || step["debugger"]) debugger;
			if (this._running) throw new Error("FATAL: reentering thread tick");
			if (step !== this._step) return;
			if (this._stopCount > 0) {
				step.resume = this._tick.bind(this, step, imethod, result);
				return;
			}
			for (;;) {
				this._currentPromise = null;
				this._running = true;
				var previousThread = exports.current;
				var previosCB = exports.cb;
				var previosGlobal = exports.global;
				exports.cb = this._cb;
				exports.global = this.global;
				exports.current = this;
				var v = this._iterator.call(imethod, result);
				exports.cb = previosCB;
				exports.global = previosGlobal;
				exports.current = previousThread;
				this._running = false;
				if (this["debugger"] || step["debugger"]) debugger;
				if (this._killing) {
					var reason = this._killing.reason;
					this._killing = null;
					this.kill(reason);
					return;
				}
				if (v.done) {
					if (this.isFinished()) return;
					if (this._iterator = this._stack.pop()) {
						imethod = v.iteratorFailed ? iteratorThrow : iteratorNext;
						result = v.value;
						continue;
					}
					var r = v.iteratorFailed ? this._reject : this._resolve;
					this._done();
					if (v.iteratorFailed && this._attachedToStack) rethrow(v.value);
					r(v.value);
				} else if (!v.value) // any falsy value
					exports.tick.then(step.next);else if (v.value.then) {
					var p = v.value.then(step.next, step.fail);
					if (p && p.kill) this._currentPromise = p;
				} else if (v.value.next) {
					this._stack.push(this._iterator);
					this._iterator = new IteratorProxy(v.value);
					imethod = iteratorNext;
					result = undefined;
					continue;
				} else if ("onload" in v.value && !v.value.onload && "onerror" in v.value && !v.value.onerror) {
					v.value.onload = step.next;
					v.value.onerror = step.fail;
				} else if ("onsuccess" in v.value && !v.value.onload && "onerror" in v.value && !v.value.onerror) {
					if (!step.success_error) step.success_error = {
						onsuccess: function onsuccess(event) {
							step.next(event.target.result);
						},
						onerror: function onerror(event) {
							step.fail(event.target.error || event);
						}
					};
					v.value.onsuccess = step.success_error.onsuccess;
					v.value.onerror = step.success_error.onerror;
				} else throw new Error("thread type error");
				break;
			}
		}
	}, {
		key: "_done",
		value: function _done() {
			this._step = null;
			this._iterator = null;
			this._stack = null;
			this._resolve = null;
			this._reject = null;
			this._currentPromise = null;
			this._killing = null;
		}
	}, {
		key: "_newStep",
		value: function _newStep() {
			var step = this._step = { resume: null };
			step.next = this._tick.bind(this, step, iteratorNext);
			step.fail = this._tick.bind(this, step, iteratorThrow);
			var $name = this.$name;
			step.next.$name = { toString: function toString() {
					return $name + ":next";
				} };
			step.fail.$name = { toString: function toString() {
					return $name + ":fail";
				} };
		}
	}, {
		key: "_onPromise",
		value: function _onPromise(resolve, reject) {
			this._resolve = resolve;
			this._reject = reject;
			this.resume();
		}
	}, {
		key: "_checkFinished",
		value: function _checkFinished() {
			if (this.isFinished()) throw new Error("thread is already finished");
		}
	}]);

	return Thread;
})();

exports.Thread = Thread;

{
	(function () {
		var notEnumerable = { enumerable: false };
		Object.keys(Thread.prototype).forEach(function (k) {
			return k.match(/^_/) && Object.defineProperty(Thread.prototype, k, notEnumerable);
		});

		var mainThread = new Thread({ next: function next() {
				return { value: { then: function then() {} } };
			} }).waitForInput();
		exports.current = null;
		exports.global = mainThread.global;
		exports.cb = null;
	})();
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/co.js","/src")

},{"_process":99,"buffer":94,"events":98,"later":133}],126:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var co = require("co");
var ra = require("ra");
var lodash = require("lodash");

function toNode(child, node) {
	restart: for (;;) {
		child = child && typeof child.valueOf == "function" ? child.valueOf() : child;
		if (Array.isArray(child)) {
			if (child.length == 0) return null;
			if (child.length == 1) {
				child = child[0];
				continue restart;
			}
			if (!node) node = document.createDocumentFragment();
			child.forEach(function (child) {
				return toNode(child, node);
			});
			child = node;
		} else {
			if (typeof child == "string") child = document.createTextNode(child);
			if (node) {
				node.appendChild(child);
				child = node;
			}
		}
		return child;
	}
}

function fcalc(f, cb) {
	if (typeof f != "function") cb(f);else {
		(function () {
			var first = true;
			ra(false, regeneratorRuntime.mark(function callee$2$0() {
				var ret;
				return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
					while (1) switch (context$3$0.prev = context$3$0.next) {
						case 0:
							if (!first) {
								context$3$0.next = 4;
								break;
							}

							first = false;
							context$3$0.next = 6;
							break;

						case 4:
							context$3$0.next = 6;
							return co.requestAnimationFrame;

						case 6:
							ret = f();

							if (!(ret && ret.next && ret["throw"])) {
								context$3$0.next = 11;
								break;
							}

							context$3$0.next = 10;
							return ret;

						case 10:
							ret = context$3$0.sent;

						case 11:
							cb(ret);

						case 12:
						case "end":
							return context$3$0.stop();
					}
				}, callee$2$0, this);
			}));
		})();
	}
}

function checkDOMControl(control) {
	var q = [control.ownerDocument && control.ownerDocument.documentElement, document.documentElement, control.ownerDocument && control.ownerDocument.body, document.body].filter(Boolean);
	var p = control;
	while (p) {
		if (q.indexOf(p) >= 0) {
			ra.forceCalculations();
			return;
		}
		p = p.parentNode;
	}
}

function setContent(control, content) {
	var cb = arguments[2] === undefined ? null : arguments[2];
	fcalc(content, function (content) {
		checkDOMControl(control);
		var c = toNode(content);
		if (c) {
			checkDOMControl(control);
			control.innerHTML = "";
			control.appendChild(c);
		} else control.innerHTML = "";
		cb && cb();
	});
}

function toAttrString(value) {
	if (Array.isArray(value)) return value.map(toAttrString).join(" ");else if (value) return "" + value;else return "";
}

function appendContent(content, f) {
	if (!f) f = document.createDocumentFragment();
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = content[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var c = _step.value;

			if (typeof c == "function") {
				var p = document.createElement("span");
				setContent(p, c);
				f.appendChild(p);
			} else if (c instanceof Node) f.appendChild(c);else if (c != null && typeof c != "string" && c[Symbol.iterator]) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = c[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _cc = _step2.value;

						appendContent(_cc, f);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			} else f.appendChild(document.createTextNode(c));
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator["return"]) {
				_iterator["return"]();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return f;
}

var GeneratorFunctionPrototype = Object.getPrototypeOf(regeneratorRuntime.mark(function callee$0$0() {
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
}));

module.exports = {
	createElement: function createElement(name, attributes) {
		for (var _len = arguments.length, content = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			content[_key - 2] = arguments[_key];
		}

		if (typeof name == "function") return name(attributes && attributes._ ? Object.assign({}, attributes, attributes._, { _: null }) : attributes || 0, appendContent(content));
		var onCreate = undefined;
		var ret = document.createElement(name);
		var classes = [];
		function applyAttributes(attributes) {
			if (attributes == null) return;
			lodash.forEach(attributes, function (value, name) {
				if (name == "_") {} else if (name == "class") classes.push(value);else if (name == "style")
					// TODO: smth like to "class" attribute - parse parent style and update it
					fcalc(value, function (value) {
						if (typeof value == "string") ret.setAttribute("style", value);else lodash.forEach(value, function (value, name) {
							return fcalc(value, function (value) {
								return ret.style[name] = value;
							});
						});
					});else if (name == "oncreate") onCreate = value;else if (name.match(/^on/)) {
					if (value != null) {
						if (typeof value == "function") value = [value];
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;

						try {
							for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var handler = _step3.value;

								if (Object.getPrototypeOf(handler) == GeneratorFunctionPrototype) handler = co.eventHandler(handler);
								ret.addEventListener(name.slice("on".length), handler);
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
									_iterator3["return"]();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
					}
				} else fcalc(value, function (value) {
					value = toAttrString(value);
					if (ret.getAttribute(name) != value) ret.setAttribute(name, value);
				});
			});
			if (Object.prototype.hasOwnProperty.call(attributes, "_")) applyAttributes(attributes._);
		}
		applyAttributes(attributes);
		if (classes.length) {
			(function () {
				var copy = classes.map(function () {
					return null;
				});
				classes.forEach(function (c, i) {
					return fcalc(c, function (c) {
						copy[i] = c;
						var className = toAttrString(copy).replace(/(^|\s|\r|\n)(null|undefined|false|0|\-0|NaN)(?=$|\s|\r|\n)/g, "");
						if (ret.className != className) ret.className = className;
					});
				});
			})();
		}
		switch (content.length) {
			case 0:
				break;
			case 1:
				setContent(ret, content[0]);
				break;
			default:
				ret.appendChild(appendContent(content));
				break;
		}
		if (typeof onCreate == "function") {
			onCreate.call(ret, {
				type: "create",
				target: ret,
				srcElement: ret,
				currentTarget: ret
			});
		}
		return ret;
	}
};

var updateInputValue = function updateInputValue() {
	var _this = this;

	setTimeout(function () {
		return _this._raValue.assign(_this.value);
	});
};
var raValue = {
	get: function get() {
		var _this2 = this;

		if (!this._raValue) ra.detach(function () {
			_this2._raValue = ra();
			_this2._raValue.assign(_this2.value);
			_this2.addEventListener("change", updateInputValue);
			_this2.addEventListener("keypress", updateInputValue);
			_this2.addEventListener("keydown", updateInputValue);
			_this2.addEventListener("keyup", updateInputValue);
		});
		return this._raValue.valueOf();
	},
	set: function set(value) {
		if (this.value != value) {
			this.value = value;
			if (this._raValue) this._raValue.assign(this.value);
		}
	}
};

var _arr = [HTMLInputElement, HTMLTextAreaElement];
for (var _i = 0; _i < _arr.length; _i++) {
	var C = _arr[_i];
	Object.defineProperty(C.prototype, "raValue", raValue);
}
// noop

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/components.js","/src")

},{"_process":99,"buffer":94,"co":125,"lodash":116,"ra":136}],127:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var UID = require("uid");
var lu = require("localUtils");

exports.Clear = exports.Unlink = function (devices, deviceId) {
	return lodash.reduce(devices.content, function (ret, q, index) {
		if (q) if (index == deviceId) ret.content[index] = null;else if (q.content && q.content[deviceId]) ret.content[index] = { content: _defineProperty({}, deviceId, null) };
		return ret;
	}, { content: {} });
};

exports.Set = function (devices, deviceId, data) {
	var device = devices.content[deviceId];
	if (!device || !device.group) return;
	var ret = { content: _defineProperty({}, deviceId, data) };
	if (device.type == "group") ret = lodash.reduce(device.content, function (ret, q, index) {
		if (q) ret.content[index] = data;
		return ret;
	}, ret);
	return ret;
};

exports.findFreeGroup = function (devices) {
	var groups = [];
	for (var i = 1; i <= 1022; ++i) {
		groups[i] = i;
	}lodash.forEach(devices.content, function (device) {
		return device && Number.isFinite(device.group) && (groups[device.group] = false);
	});
	groups = groups.filter(Boolean);
	return !groups.length ? null : groups[Math.floor(Math.random() * groups.length) % groups.length];
};

exports.cleanDatabase = function (devices) {
	var ret = devices || {};
	function _save(diff) {
		ret = lu.applyDiff(ret, diff);
	}
	function _change(path, value) {
		_save(path.reduceRight(function (ret, key) {
			return _defineProperty({}, key, ret);
		}, value));
	}
	function assign() {
		for (var _len = arguments.length, path = Array(_len), _key = 0; _key < _len; _key++) {
			path[_key] = arguments[_key];
		}

		_change(path, path.pop());
	}
	function remove() {
		for (var _len2 = arguments.length, path = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			path[_key2] = arguments[_key2];
		}

		_change(path, null);
	}

	// move root items to content
	if (!ret.content) lodash.forEach(ret, function (place, placeId) {
		if (place != null && typeof place != "object") return;
		remove(placeId);
		assign("content", placeId, place);
	});else // TODO delete later
		lodash.forEach(ret, function (place, placeId) {
			if (place != null && typeof place != "object") return;
			if (placeId == "content") return;
			remove(placeId);
		});

	// remove items with wrong type & remove group from places
	lodash.forEach(ret.content, function (place, placeId) {
		if (place == null || typeof place != "object") return remove("content", placeId);
		if (place.type == "device") // TODO: remove later
			assign("content", placeId, "type", "single");
		if (place.device == placeId) remove("content", placeId, "device");else if (!(place.type || "").match(/^(place|group|single)$/)) return remove("content", placeId);
		if (place.group != null && (!Number.isFinite(place.group) || place.type == "place")) remove("content", placeId, "group");
	});

	// create main
	if (ret && typeof ret.main != "string") {
		(function () {
			var main = UID();
			var i = 0;
			lodash.forEach(ret.content, function (place, key) {
				return assign("content", main, "content", key, ++i);
			});
			if (ret.content && ret.content[main]) assign("main", main);
		})();
	}

	// remove items with duplicate group
	var reachable = undefined;
	function groupIndex(key) {
		if (!reachable) {
			(function () {
				var push = function (key) {
					if (!(key in reachable) && ret.content.hasOwnProperty(key)) {
						reachable[key] = true;
						reachableKeys.push(key);
					}
					return key;
				};

				reachable = Object.create(null);
				var reachableKeys = [];

				push(ret.main);
				for (var _i = 0; _i < reachableKeys.length; ++_i) {
					var place = ret.content[reachableKeys[_i]];
					if (place && place.content) Object.keys(place.content).forEach(push);
				}
			})();
		}
		var i = 0;
		if (ret.content[key].type == "group") i += 2;
		if (key in reachable) i += 1;
	}

	var groups = Object.create(null);
	lodash.forEach(ret.content, function (place, key) {
		if (!place || place.group == null) return;
		if (!groups[place.group]) groups[place.group] = key;else {
			if (groupIndex(groups[place.group]) < groupIndex(key)) {
				remove("content", groups[place.group]);
				groups[place.group] = key;
			} else remove("content", key);
		}
	});

	// check content
	lodash.forEach(ret.content, function (place, key) {
		if (!place || place.content == null) return;
		if (typeof place.content != "object") return remove("content", key, "content");
		lodash.forEach(place.content, function (_, ckey) {
			if (!ret.content[ckey] || typeof ret.content[ckey] != "object") remove("content", key, "content", ckey);
		});
		place = ret.content[key]; // reassign place cause it could change in previous forEach
		lodash.keys(place.content).sort(function (a, b) {
			return (place.content[a].index || 0) - (place.content[b].index || 0);
		}).forEach(function (ckey, index) {
			if (place.content[ckey].index != index) assign("content", key, "content", ckey, "index", index);
		});
	});

	return lu.makeDiff(devices, ret);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/devdb.js","/src")

},{"_process":99,"buffer":94,"localUtils":134,"lodash":116,"uid":155}],128:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

2014.09.22

it should be better to use hammer.js, but i cannot use it without problems -
hammer.js often drops events, while direct addEventListener does not.

*/

"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var co = require("co");
var sparsequeue = require("sparsequeue");

var TRACE = undefined;
// let TC = 0
// TRACE = ( ...info ) => LOG( `${ ++TC } g ${ JSON.stringify( info ).slice( 0, 100 ) }`.green )

var SWIPE_TIMEOUT = 400; // ms
var PRESS_TIMEOUT = 500; // ms
var PRESS_MOVE_OUT = 2 /* ~mm */ * (96 / 25.4);

function squareDistance(p1, p2) {
	return (p1.pageX - p2.pageX) * (p1.pageX - p2.pageX) + (p1.pageY - p2.pageY) * (p1.pageY - p2.pageY);
}

function getX(p) {
	return p.pageX;
}
function getY(p) {
	return p.pageY;
}
function increasing(v, i, p) {
	return i == 0 || v >= p[i - 1];
}
function decreasing(v, i, p) {
	return i == 0 || v <= p[i - 1];
}

document.addEventListener("touch", co.eventHandler(regeneratorRuntime.mark(function callee$0$0(event) {
	var all, trace, last, pressed, swiped, pan, panlock, sent, send, ensurepan, sendpan, pressTimeout, stoppedTimeout, startStoppedTimeout, stopPoint, pt, longmove, dx, dy, sizex, sizey, prev, direction, traceX, traceY, bounds;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				startStoppedTimeout = function startStoppedTimeout() {
					clearTimeout(stoppedTimeout);
					stoppedTimeout = setTimeout(function () {
						ensurepan();
						sendpan("stop");
						startStoppedTimeout();
					}, PRESS_TIMEOUT);
				};

				sendpan = function sendpan(type, direction, pt, detail) {
					var data = send(type, direction, pt, detail);
					if (pan) {
						if (panlock && panlock.length) {
							panlock[0].queue.push(data);
							panlock.forEach(function (p, i) {
								return i > 0 && (p.dirty = true);
							});
							pan.dirty = true;
						} else pan.queue.push(data);
					}
				};

				ensurepan = function ensurepan(direction) {
					if (pan) return;
					pan = { queue: new sparsequeue() };
					send("pan", direction, last, {
						next: pan.queue,
						lock: function lock() {
							if (!panlock) panlock = [];
							var ret = { queue: new sparsequeue() };
							panlock.push(ret);
							return ret.queue;
						},
						unlock: function unlock(lock) {
							panlock = panlock.filter(function (l) {
								return l != lock;
							});
							var p = panlock[0] || pan;
							if (p.dirty) {
								p.dirty = false;
								sendpan("pan", "unlocked");
							}
						}
					}, "");
				};

				send = function send(type, direction, pt, detail, typeDirection) {
					TRACE && TRACE(type, all);
					if (typeDirection == null) typeDirection = direction;
					if (!detail) detail = {};
					detail.direction = direction;
					detail.pressed = pressed;
					detail.type = type;
					detail.start = event;
					detail.original = pt || event;
					var ret = new CustomEvent(type + (typeDirection || ""), { bubbles: true, cancelable: true, detail: detail });
					ret.pageX = last.pageX;
					ret.pageY = last.pageY;
					ret.clientX = last.clientX;
					ret.clientY = last.clientY;
					ret.screenX = last.screenX;
					ret.screenY = last.screenY;
					ret.deltaX = last.pageX - event.pageX;
					ret.deltaY = last.pageY - event.pageY;
					ret.lastDeltaX = last.pageX - sent.pageX;
					ret.lastDeltaY = last.pageY - sent.pageY;
					sent = last;
					ret.preventDefault = function () {
						return event.preventDefault();
					};
					event.target.dispatchEvent(ret);
					return ret;
				};

				all = undefined;
				trace = [event];
				last = event;
				pressed = null;
				swiped = false;
				pan = null;
				panlock = null;
				sent = event;

				co.defer(function () {
					panlock && panlock.forEach(function (lock) {
						return lock.queue.close();
					});
					pan && pan.queue.close();
				});

				pressTimeout = undefined;
				stoppedTimeout = undefined;

				co.defer(function () {
					clearTimeout(pressTimeout);
					clearTimeout(stoppedTimeout);
				});

				pressTimeout = setTimeout(function () {
					pressed = true;
					send("press");
				}, PRESS_TIMEOUT);

				startStoppedTimeout();

				TRACE && TRACE("enter", { x: event.pageX, y: event.pageY, t: event.timeStamp });

				stopPoint = event;
				pt = undefined;

			case 21:
				context$1$0.next = 23;
				return event.detail.next;

			case 23:
				if (!(pt = context$1$0.sent)) {
					context$1$0.next = 31;
					break;
				}

				if (TRACE) {
					(all || (all = [])).push({ x: pt.pageX, y: pt.pageY, t: pt.timeStamp - event.timeStamp });
					TRACE("next", all);
				}
				if (last.timeStamp - event.timeStamp > SWIPE_TIMEOUT) trace = null;

				longmove = squareDistance(pt, stopPoint) > PRESS_MOVE_OUT * PRESS_MOVE_OUT;

				if (longmove) {
					stopPoint = pt;
					startStoppedTimeout();
				}

				if (longmove || !trace || trace.length > 1) {
					if (pressed == null) {
						pressed = false;
						clearTimeout(pressTimeout);
					}
					dx = pt.pageX - last.pageX;
					dy = pt.pageY - last.pageY;

					if (dx || dy) {
						sizex = Math.abs(dx);
						sizey = Math.abs(dy);
						prev = last;

						if (trace) trace.push(last);
						last = pt;
						direction = "";

						if (sizex >= sizey && dx > 0) direction = "right";else if (sizex >= sizey && dx < 0) direction = "left";else if (sizex < sizey && dy > 0) direction = "down";else if (sizex < sizey && dy < 0) direction = "up";
						ensurepan(direction);
						sendpan("pan", direction, last);
					}
				}

			case 29:
				context$1$0.next = 21;
				break;

			case 31:
				clearTimeout(pressTimeout);
				if (last.timeStamp - event.timeStamp < SWIPE_TIMEOUT && trace && trace.length > 2) {
					// remove first point to eliminate touch bouncing effect
					trace.shift();
					traceX = trace.map(getX);
					traceY = trace.map(getY);
					bounds = {
						x: Math.max.apply(Math, _toConsumableArray(traceX)) - Math.min.apply(Math, _toConsumableArray(traceX)),
						y: Math.max.apply(Math, _toConsumableArray(traceY)) - Math.min.apply(Math, _toConsumableArray(traceY))
					};
					direction = "";

					if (bounds.x > bounds.y && traceX.every(increasing)) direction = "right";else if (bounds.x > bounds.y && traceX.every(decreasing)) direction = "left";else if (bounds.x < bounds.y && traceY.every(increasing)) direction = "down";else if (bounds.x < bounds.y && traceY.every(decreasing)) direction = "up";
					if (direction) {
						swiped = true;
						sendpan("swipe", direction, last);
					}
				}
				if (!pressed && !swiped && !pan) sendpan("tap");
				TRACE && TRACE("done", all);

			case 35:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/gesture.js","/src")

},{"_process":99,"buffer":94,"co":125,"sparsequeue":138}],129:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var style = document.createElement("div").style;
if (!("transform" in style) && "webkitTransform" in style) {
	Object.defineProperty(CSSStyleDeclaration.prototype, "transform", {
		get: function get() {
			return this.webkitTransform;
		},
		set: function set(value) {
			this.webkitTransform = value;
		}
	});
}

// let slice = [].slice

if (!NodeList.prototype[Symbol.iterator]) NodeList.prototype[Symbol.iterator] = regeneratorRuntime.mark(function callee$0$0() {
	var i, l;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				i = 0, l = this.length;

			case 1:
				if (!(i < l)) {
					context$1$0.next = 7;
					break;
				}

				context$1$0.next = 4;
				return this.item(i);

			case 4:
				++i;
				context$1$0.next = 1;
				break;

			case 7:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
});

// return slice.call( this )[ Symbol.iterator ]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/htmlpolyfill.js","/src")

},{"_process":99,"buffer":94}],130:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

exports.preventDefault = function (event) {
	return event && event.preventDefault && event.preventDefault();
};

exports.Submit = function (event) {
	event && event.preventDefault();
	var c = this;
	while (c && !(c instanceof HTMLFormElement)) c = c.parentNode;
	if (c) c.dispatchEvent(new CustomEvent("submit", null));
	return false;
};

var centered = "\n\twidth: 100%;\n\theight: 100%;\n\tvertical-align: middle;\n\ttext-align: center;\n";

exports.Centered = function (_, content) {
	return React.createElement(
		"table",
		{ style: centered },
		React.createElement(
			"tr",
			{ style: centered },
			React.createElement(
				"td",
				{ style: centered },
				content
			)
		)
	);
};

exports.isEmptyNode = function (node) {
	return node instanceof Comment || node instanceof ProcessingInstruction || node instanceof Text && !node.nodeValue.trim();
};

exports.importTemplate = function (template) {
	return document.importNode(template.content, true);
};

exports.importElement = function (template) {
	var ret = exports.importTemplate(template);
	if (!ret) return null;
	while (ret.lastChild && exports.isEmptyNode(ret.lastChild)) ret.removeChild(ret.lastChild);
	while (ret.firstChild && exports.isEmptyNode(ret.firstChild)) ret.removeChild(ret.firstChild);
	if (!ret.firstChild) return null;
	if (ret.childNodes.length == 1) return ret.childNodes.item(0);
	var root = document.createElement("span");
	root.appendChild(ret);
	return root;
};

exports.importComponent = function (template) {
	var data = exports.importElement(template);
	if (data) {
		var init = data.getElementsByClassName("init")[0];
		if (init && init.type == "init") {
			var finit = new Function("component", [].slice.call(init.childNodes).map(function (x) {
				return x.data || "";
			}).join(""));
			finit(data);
		}
	}
	return data;
};

exports.tickCache = function (fun) {
	var cachedResult = undefined;
	var cached = false;

	var clearCache = function clearCache() {
		cachedResult = null;
		cached = false;
	};

	return function () {
		if (!cached) {
			cachedResult = fun.apply(this, arguments);
			cached = true;
			setImmediate(clearCache);
		}
		return cachedResult;
	};
};

exports.createEvent = function (type, detail, on) {
	var event = new CustomEvent(type, { detail: detail, bubbles: true, cancelable: true });
	if (on) {
		event.pageX = on.pageX;
		event.pageY = on.pageY;
		event.clientX = on.clientX;
		event.clientY = on.clientY;
		event.screenX = on.screenX;
		event.screenY = on.screenY;
	}
	return event;
};

exports.sendEvent = function (type, detail, on) {
	return on.target.dispatchEvent(exports.createEvent(type, detail, on));
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/htmlutils.js","/src")

},{"_process":99,"buffer":94}],131:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var httpClient = {
	get: function get(url, encoding) {
		return httpClient.xhr({ method: "GET", url: url, encoding: encoding });
	},

	post: function post(url, data, encoding) {
		return httpClient.xhr({ method: "POST", url: url, data: data, encoding: encoding });
	},

	xhr: function xhr(options) {
		var method = options.method;
		var url = options.url;
		var encoding = options.encoding;
		var data = options.data;

		var xhr = new XMLHttpRequest();
		if (encoding == "binary") xhr.responseType = "arraybuffer";else xhr.responseType = "text";
		var promise = new Promise(function (resolve, reject) {
			var onerror = function onerror(error) {
				if (typeof error == "string") {
					error = new Error(error);
					error.method = method;
					error.url = url;
				}
				global._ALERT && global._ALERT("try " + error + url);
				reject(error);
			};
			xhr.ontimeout = function () {
				return onerror(new Error("TIMEOUT " + url));
			};
			xhr.onerror = function (e) {
				return onerror(e || "ERROR");
			};
			xhr.onreadystatechange = function () {
				if (xhr.readyState == xhr.DONE && xhr.status == 0) xhr.ontimeout();
			};
			xhr.onload = function () {
				// alert( xhr.status )
				if (xhr.status >= 200 && xhr.status <= 299) return resolve(xhr.response == null ? null : xhr.response);
				if (xhr.status == 401) {
					// append some thing to the page to force standalone browser to show login dialog
					var surl = require("url").parse(url);
					if (surl.host) {
						(function () {
							surl = "" + surl.protocol + "//" + surl.host + "/dummy." + Math.random() + ".js";
							var script = document.createElement("script");
							script.src = surl;
							// alert( surl )
							document.body.appendChild(script);
							setTimeout(function () {
								return document.body.removeChild(script);
							}, 1000);
						})();
					}
				}
				onerror("" + xhr.status + " " + xhr.statusText);
			};
		});
		switch (encoding) {
			case "immutable":
				promise = promise.then(function (data) {
					return Immutable.fromJS(JSON.parse(data));
				});
				break;
			case "binary":
				promise = promise.then(function (data) {
					return new Uint8Array(data);
				});
				break;
			case "text":
				break;
			default:
				promise = promise.then(function (data) {
					var actualEncoding = encoding;
					if (!actualEncoding) {
						var ct = xhr.getResponseHeader("content-type") || "";
						if (ct.match(/^application\/json/)) actualEncoding = "json";
					}
					switch (actualEncoding) {
						case "json":
							return JSON.parse(data);
					}
					return data;
				});
		}
		xhr.open(method || "GET", url);
		xhr.withCredentials = true;
		xhr.send(data);
		xhr.then = promise.then.bind(promise);
		xhr["catch"] = promise["catch"].bind(promise);
		return xhr;
	},

	url: function url(_url, params) {
		params && Object.keys(params).forEach(function (k, i) {
			return _url = _url + (i > 0 ? "&" : "?") + encodeURIComponent(k) + "=" + encodeURIComponent(params[k]);
		});
		return _url;
	}
};

module.exports = httpClient;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/httpClient.js","/src")

},{"_process":99,"buffer":94,"url":104}],132:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

vadzim zienka

2015.05.11
added this.stoppedTransition to not to fire tap when scrolling is stopped by that tap.

 */

/*! iScroll v5.1.3 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */
'use strict';

(function (window, document, Math) {
	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
		window.setTimeout(callback, 1000 / 60);
	};

	var utils = (function () {
		var me = {};

		var _elementStyle = document.createElement('div').style;
		var _vendor = (function () {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			    transform,
			    i = 0,
			    l = vendors.length;

			for (; i < l; i++) {
				transform = vendors[i] + 'ransform';
				if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
			}

			return false;
		})();

		function _prefixStyle(style) {
			if (_vendor === false) return false;
			if (_vendor === '') return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		}

		me.getTime = Date.now || function getTime() {
			return new Date().getTime();
		};

		me.extend = function (target, obj) {
			for (var i in obj) {
				target[i] = obj[i];
			}
		};

		me.addEvent = function (el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};

		me.removeEvent = function (el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};

		me.prefixPointerEvent = function (pointerEvent) {
			return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) : pointerEvent;
		};

		me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
			    speed = Math.abs(distance) / time,
			    destination,
			    duration;

			deceleration = deceleration === undefined ? 0.0006 : deceleration;

			destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
			duration = speed / deceleration;

			if (destination < lowerMargin) {
				destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if (destination > 0) {
				destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}

			return {
				destination: Math.round(destination),
				duration: duration
			};
		};

		var _transform = _prefixStyle('transform');

		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: window.PointerEvent || window.MSPointerEvent, // IE10 is prefixed
			hasTransition: _prefixStyle('transition') in _elementStyle
		});

		// This should find all Android browsers lower than build 535.19 (both stock browser and webview)
		me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !/Chrome\/\d/.test(window.navigator.appVersion);

		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});

		me.hasClass = function (e, c) {
			var re = new RegExp('(^|\\s)' + c + '(\\s|$)');
			return re.test(e.className);
		};

		me.addClass = function (e, c) {
			if (me.hasClass(e, c)) {
				return;
			}

			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};

		me.removeClass = function (e, c) {
			if (!me.hasClass(e, c)) {
				return;
			}

			var re = new RegExp('(^|\\s)' + c + '(\\s|$)', 'g');
			e.className = e.className.replace(re, ' ');
		};

		me.offset = function (el) {
			var left = -el.offsetLeft,
			    top = -el.offsetTop;

			// jshint -W084
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			// jshint +W084

			return {
				left: left,
				top: top
			};
		};

		me.preventDefaultException = function (el, exceptions) {
			for (var i in exceptions) {
				if (exceptions[i].test(el[i])) {
					return true;
				}
			}

			return false;
		};

		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,

			mousedown: 2,
			mousemove: 2,
			mouseup: 2,

			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,

			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});

		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function fn(k) {
					return k * (2 - k);
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
				fn: function fn(k) {
					return Math.sqrt(1 - --k * k);
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function fn(k) {
					var b = 4;
					return (k = k - 1) * k * ((b + 1) * k + b) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function fn(k) {
					if ((k /= 1) < 1 / 2.75) {
						return 7.5625 * k * k;
					} else if (k < 2 / 2.75) {
						return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
					} else if (k < 2.5 / 2.75) {
						return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
					} else {
						return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function fn(k) {
					var f = 0.22,
					    e = 0.4;

					if (k === 0) {
						return 0;
					}
					if (k == 1) {
						return 1;
					}

					return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
				}
			}
		});

		me.tap = function (e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};

		me.click = function (e) {
			var target = e.target,
			    ev;

			if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);

				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};

		return me;
	})();

	function IScroll(el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style; // cache style for better performance

		this.options = {

			resizeScrollbars: true,

			mouseWheelSpeed: 20,

			snapThreshold: 0.334,

			// INSERT POINT: OPTIONS

			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,

			bounce: true,
			bounceTime: 600,
			bounceEasing: '',

			preventDefault: true,
			preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

			HWCompositing: true,
			useTransition: true,
			useTransform: true
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		// Normalize options
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;

		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

		// If you want eventPassthrough I have to lock one of the axes
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

		// With eventPassthrough we also need lockDirection mechanism
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

		if (this.options.tap === true) {
			this.options.tap = 'tap';
		}

		if (this.options.shrinkScrollbars == 'scale') {
			this.options.useTransition = false;
		}

		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

		if (this.options.probeType == 3) {
			this.options.useTransition = false;
		}

		// INSERT POINT: NORMALIZATION

		// Some defaults	
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};

		// INSERT POINT: DEFAULTS

		this._init();
		this.refresh();

		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	}

	IScroll.prototype = {
		version: '5.1.3',

		_init: function _init() {
			this._initEvents();

			if (this.options.scrollbars || this.options.indicators) {
				this._initIndicators();
			}

			if (this.options.mouseWheel) {
				this._initWheel();
			}

			if (this.options.snap) {
				this._initSnap();
			}

			if (this.options.keyBindings) {
				this._initKeys();
			}

			// INSERT POINT: _init
		},

		destroy: function destroy() {
			this._initEvents(true);

			this._execEvent('destroy');
		},

		_transitionEnd: function _transitionEnd(e) {
			if (e.target != this.scroller || !this.isInTransition) {
				return;
			}

			this._transitionTime();
			if (!this.resetPosition(this.options.bounceTime)) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},

		_start: function _start(e) {
			// React to left mouse button only
			if (utils.eventType[e.type] != 1) {
				if (e.button !== 0) {
					return;
				}
			}

			if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    pos;

			this.initiated = utils.eventType[e.type];
			this.moved = false;
			this.distX = 0;
			this.distY = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;

			this._transitionTime();

			this.startTime = utils.getTime();

			this.stoppedTransition = false;
			if (this.options.useTransition && this.isInTransition) {
				this.stoppedTransition = true;
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if (!this.options.useTransition && this.isAnimating) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}

			this.startX = this.x;
			this.startY = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault) {
				// increases performance on Android? TODO: check!
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    deltaX = point.pageX - this.pointX,
			    deltaY = point.pageY - this.pointY,
			    timestamp = utils.getTime(),
			    newX,
			    newY,
			    absDistX,
			    absDistY;

			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this.distX += deltaX;
			this.distY += deltaY;
			absDistX = Math.abs(this.distX);
			absDistY = Math.abs(this.distY);

			// We need to move at least 10 pixels for the scrolling to initiate
			if (timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10)) {
				return;
			}

			// If you are scrolling in one direction lock the other
			if (!this.directionLocked && !this.options.freeScroll) {
				if (absDistX > absDistY + this.options.directionLockThreshold) {
					this.directionLocked = 'h'; // lock horizontally
				} else if (absDistY >= absDistX + this.options.directionLockThreshold) {
					this.directionLocked = 'v'; // lock vertically
				} else {
					this.directionLocked = 'n'; // no lock
				}
			}

			if (this.directionLocked == 'h') {
				if (this.options.eventPassthrough == 'vertical') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'horizontal') {
					this.initiated = false;
					return;
				}

				deltaY = 0;
			} else if (this.directionLocked == 'v') {
				if (this.options.eventPassthrough == 'horizontal') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'vertical') {
					this.initiated = false;
					return;
				}

				deltaX = 0;
			}

			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			// Slow down if outside of the boundaries
			if (newX > 0 || newX < this.maxScrollX) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if (newY > 0 || newY < this.maxScrollY) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}

			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

			if (!this.moved) {
				this._execEvent('scrollStart');
			}

			this.moved = true;

			this._translate(newX, newY);

			/* REPLACE START: _move */
			if (timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;

				if (this.options.probeType == 1) {
					this._execEvent('scroll');
				}
			}

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}
			/* REPLACE END: _move */
		},

		_end: function _end(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.changedTouches ? e.changedTouches[0] : e,
			    momentumX,
			    momentumY,
			    duration = utils.getTime() - this.startTime,
			    newX = Math.round(this.x),
			    newY = Math.round(this.y),
			    distanceX = Math.abs(newX - this.startX),
			    distanceY = Math.abs(newY - this.startY),
			    time = 0,
			    easing = '';

			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();

			// reset if we are outside of the boundaries
			if (this.resetPosition(this.options.bounceTime)) {
				return;
			}

			this.scrollTo(newX, newY); // ensures that the last position is rounded

			// we scrolled less than 10 pixels
			if (!this.moved) {
				if (!this.stoppedTransition) {
					if (this.options.tap) {
						utils.tap(e, this.options.tap);
					}

					if (this.options.click) {
						utils.click(e);
					}
				}

				this._execEvent('scrollCancel');
				return;
			}

			if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
				this._execEvent('flick');
				return;
			}

			// start momentum animation if needed
			if (this.options.momentum && duration < 300) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}

			if (this.options.snap) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
				newX = snap.x;
				newY = snap.y;

				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}

			// INSERT POINT: _end

			if (newX != this.x || newY != this.y) {
				// change easing function when scroller goes out of the boundaries
				if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
					easing = utils.ease.quadratic;
				}

				this.scrollTo(newX, newY, time, easing);
				return;
			}

			this._execEvent('scrollEnd');
		},

		_resize: function _resize() {
			var that = this;

			clearTimeout(this.resizeTimeout);

			this.resizeTimeout = setTimeout(function () {
				that.refresh();
			}, this.options.resizePolling);
		},

		resetPosition: function resetPosition(time) {
			var x = this.x,
			    y = this.y;

			time = time || 0;

			if (!this.hasHorizontalScroll || this.x > 0) {
				x = 0;
			} else if (this.x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (!this.hasVerticalScroll || this.y > 0) {
				y = 0;
			} else if (this.y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			if (x == this.x && y == this.y) {
				return false;
			}

			this.scrollTo(x, y, time, this.options.bounceEasing);

			return true;
		},

		disable: function disable() {
			this.enabled = false;
		},

		enable: function enable() {
			this.enabled = true;
		},

		refresh: function refresh() {
			var rf = this.wrapper.offsetHeight; // Force reflow

			this.wrapperWidth = this.wrapper.clientWidth;
			this.wrapperHeight = this.wrapper.clientHeight;

			/* REPLACE START: refresh */

			this.scrollerWidth = this.scroller.offsetWidth;
			this.scrollerHeight = this.scroller.offsetHeight;

			this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY = this.wrapperHeight - this.scrollerHeight;

			/* REPLACE END: refresh */

			this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

			if (!this.hasHorizontalScroll) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}

			if (!this.hasVerticalScroll) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}

			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;

			this.wrapperOffset = utils.offset(this.wrapper);

			this._execEvent('refresh');

			this.resetPosition();

			// INSERT POINT: _refresh
		},

		on: function on(type, fn) {
			if (!this._events[type]) {
				this._events[type] = [];
			}

			this._events[type].push(fn);
		},

		off: function off(type, fn) {
			if (!this._events[type]) {
				return;
			}

			var index = this._events[type].indexOf(fn);

			if (index > -1) {
				this._events[type].splice(index, 1);
			}
		},

		_execEvent: function _execEvent(type) {
			if (!this._events[type]) {
				return;
			}

			var i = 0,
			    l = this._events[type].length;

			if (!l) {
				return;
			}

			for (; i < l; i++) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},

		scrollBy: function scrollBy(x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;

			this.scrollTo(x, y, time, easing);
		},

		scrollTo: function scrollTo(x, y, time, easing) {
			easing = easing || utils.ease.circular;

			this.isInTransition = this.options.useTransition && time > 0;

			if (!time || this.options.useTransition && easing.style) {
				this._transitionTimingFunction(easing.style);
				this._transitionTime(time);
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},

		scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);

			if (!el) {
				return;
			}

			var pos = utils.offset(el);

			pos.left -= this.wrapperOffset.left;
			pos.top -= this.wrapperOffset.top;

			// if offsetX/Y are true we center the element to the screen
			if (offsetX === true) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if (offsetY === true) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}

			pos.left -= offsetX || 0;
			pos.top -= offsetY || 0;

			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

			this.scrollTo(pos.left, pos.top, time, easing);
		},

		_transitionTime: function _transitionTime(time) {
			time = time || 0;

			this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
			}

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTime(time);
				}
			}

			// INSERT POINT: _transitionTime
		},

		_transitionTimingFunction: function _transitionTimingFunction(easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}

			// INSERT POINT: _transitionTimingFunction
		},

		_translate: function _translate(x, y) {
			if (this.options.useTransform) {

				/* REPLACE START: _translate */

				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

				/* REPLACE END: _translate */
			} else {
				x = Math.round(x);
				y = Math.round(y);
				this.scrollerStyle.left = x + 'px';
				this.scrollerStyle.top = y + 'px';
			}

			this.x = x;
			this.y = y;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].updatePosition();
				}
			}

			// INSERT POINT: _translate
		},

		_initEvents: function _initEvents(remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
			    target = this.options.bindToWrapper ? this.wrapper : window;

			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);

			if (this.options.click) {
				eventType(this.wrapper, 'click', this, true);
			}

			if (!this.options.disableMouse) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}

			if (utils.hasPointer && !this.options.disablePointer) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}

			if (utils.hasTouch && !this.options.disableTouch) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}

			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},

		getComputedPosition: function getComputedPosition() {
			var matrix = window.getComputedStyle(this.scroller, null),
			    x,
			    y;

			if (this.options.useTransform) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}

			return { x: x, y: y };
		},

		_initIndicators: function _initIndicators() {
			var interactive = this.options.interactiveScrollbars,
			    customStyle = typeof this.options.scrollbars != 'string',
			    indicators = [],
			    indicator;

			var that = this;

			this.indicators = [];

			if (this.options.scrollbars) {
				// Vertical scrollbar
				if (this.options.scrollY) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}

				// Horizontal scrollbar
				if (this.options.scrollX) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}

			if (this.options.indicators) {
				// TODO: check concat compatibility
				indicators = indicators.concat(this.options.indicators);
			}

			for (var i = indicators.length; i--;) {
				this.indicators.push(new Indicator(this, indicators[i]));
			}

			// TODO: check if we can use array.map (wide compatibility and performance issues)
			function _indicatorsMap(fn) {
				for (var i = that.indicators.length; i--;) {
					fn.call(that.indicators[i]);
				}
			}

			if (this.options.fadeScrollbars) {
				this.on('scrollEnd', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollCancel', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1);
					});
				});

				this.on('beforeScrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1, true);
					});
				});
			}

			this.on('refresh', function () {
				_indicatorsMap(function () {
					this.refresh();
				});
			});

			this.on('destroy', function () {
				_indicatorsMap(function () {
					this.destroy();
				});

				delete this.indicators;
			});
		},

		_initWheel: function _initWheel() {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

			this.on('destroy', function () {
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},

		_wheel: function _wheel(e) {
			if (!this.enabled) {
				return;
			}

			e.preventDefault();
			e.stopPropagation();

			var wheelDeltaX,
			    wheelDeltaY,
			    newX,
			    newY,
			    that = this;

			if (this.wheelTimeout === undefined) {
				that._execEvent('scrollStart');
			}

			// Execute the scrollEnd event after 400ms the wheel stopped scrolling
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function () {
				that._execEvent('scrollEnd');
				that.wheelTimeout = undefined;
			}, 400);

			if ('deltaX' in e) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ('wheelDeltaX' in e) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ('wheelDelta' in e) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ('detail' in e) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}

			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;

			if (!this.hasVerticalScroll) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}

			if (this.options.snap) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;

				if (wheelDeltaX > 0) {
					newX--;
				} else if (wheelDeltaX < 0) {
					newX++;
				}

				if (wheelDeltaY > 0) {
					newY--;
				} else if (wheelDeltaY < 0) {
					newY++;
				}

				this.goToPage(newX, newY);

				return;
			}

			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

			if (newX > 0) {
				newX = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
			}

			if (newY > 0) {
				newY = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
			}

			this.scrollTo(newX, newY, 0);

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}

			// INSERT POINT: _wheel
		},

		_initSnap: function _initSnap() {
			this.currentPage = {};

			if (typeof this.options.snap == 'string') {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}

			this.on('refresh', function () {
				var i = 0,
				    l,
				    m = 0,
				    n,
				    cx,
				    cy,
				    x = 0,
				    y,
				    stepX = this.options.snapStepX || this.wrapperWidth,
				    stepY = this.options.snapStepY || this.wrapperHeight,
				    el;

				this.pages = [];

				if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
					return;
				}

				if (this.options.snap === true) {
					cx = Math.round(stepX / 2);
					cy = Math.round(stepY / 2);

					while (x > -this.scrollerWidth) {
						this.pages[i] = [];
						l = 0;
						y = 0;

						while (y > -this.scrollerHeight) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};

							y -= stepY;
							l++;
						}

						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;

					for (; i < l; i++) {
						if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
							m = 0;
							n++;
						}

						if (!this.pages[m]) {
							this.pages[m] = [];
						}

						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);

						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};

						if (x > this.maxScrollX) {
							m++;
						}
					}
				}

				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

				// Update snap threshold if needed
				if (this.options.snapThreshold % 1 === 0) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});

			this.on('flick', function () {
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);

				this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
			});
		},

		_nearestSnap: function _nearestSnap(x, y) {
			if (!this.pages.length) {
				return { x: 0, y: 0, pageX: 0, pageY: 0 };
			}

			var i = 0,
			    l = this.pages.length,
			    m = 0;

			// Check if we exceeded the snap threshold
			if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
				return this.currentPage;
			}

			if (x > 0) {
				x = 0;
			} else if (x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (y > 0) {
				y = 0;
			} else if (y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			for (; i < l; i++) {
				if (x >= this.pages[i][0].cx) {
					x = this.pages[i][0].x;
					break;
				}
			}

			l = this.pages[i].length;

			for (; m < l; m++) {
				if (y >= this.pages[0][m].cy) {
					y = this.pages[0][m].y;
					break;
				}
			}

			if (i == this.currentPage.pageX) {
				i += this.directionX;

				if (i < 0) {
					i = 0;
				} else if (i >= this.pages.length) {
					i = this.pages.length - 1;
				}

				x = this.pages[i][0].x;
			}

			if (m == this.currentPage.pageY) {
				m += this.directionY;

				if (m < 0) {
					m = 0;
				} else if (m >= this.pages[0].length) {
					m = this.pages[0].length - 1;
				}

				y = this.pages[0][m].y;
			}

			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},

		goToPage: function goToPage(x, y, time, easing) {
			easing = easing || this.options.bounceEasing;

			if (x >= this.pages.length) {
				x = this.pages.length - 1;
			} else if (x < 0) {
				x = 0;
			}

			if (y >= this.pages[x].length) {
				y = this.pages[x].length - 1;
			} else if (y < 0) {
				y = 0;
			}

			var posX = this.pages[x][y].x,
			    posY = this.pages[x][y].y;

			time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;

			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};

			this.scrollTo(posX, posY, time, easing);
		},

		next: function next(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x++;

			if (x >= this.pages.length && this.hasVerticalScroll) {
				x = 0;
				y++;
			}

			this.goToPage(x, y, time, easing);
		},

		prev: function prev(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x--;

			if (x < 0 && this.hasVerticalScroll) {
				x = 0;
				y--;
			}

			this.goToPage(x, y, time, easing);
		},

		_initKeys: function _initKeys(e) {
			// default key bindings
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;

			// if you give me characters I give you keycode
			if (typeof this.options.keyBindings == 'object') {
				for (i in this.options.keyBindings) {
					if (typeof this.options.keyBindings[i] == 'string') {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}

			for (i in keys) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}

			utils.addEvent(window, 'keydown', this);

			this.on('destroy', function () {
				utils.removeEvent(window, 'keydown', this);
			});
		},

		_key: function _key(e) {
			if (!this.enabled) {
				return;
			}

			var snap = this.options.snap,
			    // we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			    newY = snap ? this.currentPage.pageY : this.y,
			    now = utils.getTime(),
			    prevTime = this.keyTime || 0,
			    acceleration = 0.25,
			    pos;

			if (this.options.useTransition && this.isInTransition) {
				pos = this.getComputedPosition();

				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}

			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

			switch (e.keyCode) {
				case this.options.keyBindings.pageUp:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX += snap ? 1 : this.wrapperWidth;
					} else {
						newY += snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.pageDown:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX -= snap ? 1 : this.wrapperWidth;
					} else {
						newY -= snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.end:
					newX = snap ? this.pages.length - 1 : this.maxScrollX;
					newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
					break;
				case this.options.keyBindings.home:
					newX = 0;
					newY = 0;
					break;
				case this.options.keyBindings.left:
					newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.up:
					newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.right:
					newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.down:
					newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				default:
					return;
			}

			if (snap) {
				this.goToPage(newX, newY);
				return;
			}

			if (newX > 0) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}

			if (newY > 0) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}

			this.scrollTo(newX, newY, 0);

			this.keyTime = now;
		},

		_animate: function _animate(destX, destY, duration, easingFn) {
			var that = this,
			    startX = this.x,
			    startY = this.y,
			    startTime = utils.getTime(),
			    destTime = startTime + duration;

			function step() {
				var now = utils.getTime(),
				    newX,
				    newY,
				    easing;

				if (now >= destTime) {
					that.isAnimating = false;
					that._translate(destX, destY);

					if (!that.resetPosition(that.options.bounceTime)) {
						that._execEvent('scrollEnd');
					}

					return;
				}

				now = (now - startTime) / duration;
				easing = easingFn(now);
				newX = (destX - startX) * easing + startX;
				newY = (destY - startY) * easing + startY;
				that._translate(newX, newY);

				if (that.isAnimating) {
					rAF(step);
				}

				if (that.options.probeType == 3) {
					that._execEvent('scroll');
				}
			}

			this.isAnimating = true;
			step();
		},

		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
				case 'orientationchange':
				case 'resize':
					this._resize();
					break;
				case 'transitionend':
				case 'webkitTransitionEnd':
				case 'oTransitionEnd':
				case 'MSTransitionEnd':
					this._transitionEnd(e);
					break;
				case 'wheel':
				case 'DOMMouseScroll':
				case 'mousewheel':
					this._wheel(e);
					break;
				case 'keydown':
					this._key(e);
					break;
				case 'click':
					if (!e._constructed) {
						e.preventDefault();
						e.stopPropagation();
					}
					break;
			}
		}
	};
	function createDefaultScrollbar(direction, interactive, type) {
		var scrollbar = document.createElement('div'),
		    indicator = document.createElement('div');

		if (type === true) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}

		indicator.className = 'iScrollIndicator';

		if (direction == 'h') {
			if (type === true) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if (type === true) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}

		scrollbar.style.cssText += ';overflow:hidden';

		if (!interactive) {
			scrollbar.style.pointerEvents = 'none';
		}

		scrollbar.appendChild(indicator);

		return scrollbar;
	}

	function Indicator(scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;

		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;

		if (this.options.interactive) {
			if (!this.options.disableTouch) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}

		if (this.options.fade) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
			this.wrapperStyle.opacity = '0';
		}
	}

	Indicator.prototype = {
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
			}
		},

		destroy: function destroy() {
			if (this.options.interactive) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);

				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);

				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}

			if (this.options.defaultScrollbars) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},

		_start: function _start(e) {
			var point = e.touches ? e.touches[0] : e;

			e.preventDefault();
			e.stopPropagation();

			this.transitionTime();

			this.initiated = true;
			this.moved = false;
			this.lastPointX = point.pageX;
			this.lastPointY = point.pageY;

			this.startTime = utils.getTime();

			if (!this.options.disableTouch) {
				utils.addEvent(window, 'touchmove', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(window, 'mousemove', this);
			}

			this.scroller._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			var point = e.touches ? e.touches[0] : e,
			    deltaX,
			    deltaY,
			    newX,
			    newY,
			    timestamp = utils.getTime();

			if (!this.moved) {
				this.scroller._execEvent('scrollStart');
			}

			this.moved = true;

			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;

			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			this._pos(newX, newY);

			if (this.scroller.options.probeType == 1 && timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.scroller._execEvent('scroll');
			} else if (this.scroller.options.probeType > 1) {
				this.scroller._execEvent('scroll');
			}

			// INSERT POINT: indicator._move

			e.preventDefault();
			e.stopPropagation();
		},

		_end: function _end(e) {
			if (!this.initiated) {
				return;
			}

			this.initiated = false;

			e.preventDefault();
			e.stopPropagation();

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			if (this.scroller.options.snap) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

				if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}

			if (this.moved) {
				this.scroller._execEvent('scrollEnd');
			}
		},

		transitionTime: function transitionTime(time) {
			time = time || 0;
			this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
			}
		},

		transitionTimingFunction: function transitionTimingFunction(easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},

		refresh: function refresh() {
			this.transitionTime();

			if (this.options.listenX && !this.options.listenY) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if (this.options.listenY && !this.options.listenX) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}

			if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}

			var r = this.wrapper.offsetHeight; // force refresh

			if (this.options.listenX) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if (this.options.resize) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}

				this.maxPosX = this.wrapperWidth - this.indicatorWidth;

				if (this.options.shrink == 'clip') {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}

				this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
			}

			if (this.options.listenY) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if (this.options.resize) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;

				if (this.options.shrink == 'clip') {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
			}

			this.updatePosition();
		},

		updatePosition: function updatePosition() {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			    y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

			if (!this.options.ignoreBoundaries) {
				if (x < this.minBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if (x > this.maxBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}

				if (y < this.minBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if (y > this.maxBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}

			this.x = x;
			this.y = y;

			if (this.scroller.options.useTransform) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},

		_pos: function _pos(x, y) {
			if (x < 0) {
				x = 0;
			} else if (x > this.maxPosX) {
				x = this.maxPosX;
			}

			if (y < 0) {
				y = 0;
			} else if (y > this.maxPosY) {
				y = this.maxPosY;
			}

			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

			this.scroller.scrollTo(x, y);
		},

		fade: function fade(val, hold) {
			if (hold && !this.visible) {
				return;
			}

			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;

			var time = val ? 250 : 500,
			    delay = val ? 0 : 300;

			val = val ? '1' : '0';

			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

			this.fadeTimeout = setTimeout((function (val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}).bind(this, val), delay);
		}
	};

	IScroll.utils = utils;

	if (typeof module != 'undefined' && module.exports) {
		module.exports = IScroll;
	} else {
		window.IScroll = IScroll;
	}
})(window, document, Math);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/iscroll.js","/src")

},{"_process":99,"buffer":94}],133:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = new (require("scheduler"))();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/later.js","/src")

},{"_process":99,"buffer":94,"scheduler":137}],134:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var co = require("co");

var NON_PARTIAL = Object.create(null);
NON_PARTIAL.__partial__ = false;

var PARTIAL = Object.create(null);

function assert(value, message) {
	if (!value) throw new Error("" + message);
}

var LiteralPrototype = Object.getPrototypeOf({});

var lu = module.exports = {

	dumpPromise: function dumpPromise(p) {
		return p.then(function (result) {
			return lu.log("result:", result);
		}, function (error) {
			return lu.error("error:", error);
		});
	},

	dump: function dump(msg, value) {
		console.log(msg, value);
		return value;
	},

	log: console.log.bind(console),
	info: (console.info || console.log).bind(console),
	warn: (console.warn || console.log).bind(console),
	error: (console.error || console.log).bind(console),
	trace: (console.trace || console.log).bind(console),

	mapObj: function mapObj(obj, props) {
		var ret = Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
		lodash.forEach(props, function (fun, key) {
			return ret[key] = typeof fun == "function" ? fun(obj[key]) : fun;
		});
		return ret;
	},

	rests: function rests(num) {
		for (var _len = arguments.length, _rests = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			_rests[_key - 1] = arguments[_key];
		}

		var ret = [];
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = _rests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var r = _step.value;

				var n = num % r;
				num = (num - n) / r;
				ret.push(n);
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator["return"]) {
					_iterator["return"]();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return ret;
	},

	pad: function pad(s, n, p) {
		s = String(s);
		var x = "";
		n -= s.length;
		while (n > 0) {
			x += p;
			--n;
		}
		return x + s;
	},

	time: function time() {
		var d = new Date();
		return "" + d.getHours() + ":" + lu.pad(d.getMinutes(), 2, 0) + ":" + lu.pad(d.getSeconds(), 2, 0) + "." + lu.pad(d.getMilliseconds(), 3, 0);
	},

	stack: function stack() {
		return new Error().stack;
	},

	options: function options(_options, def) {
		var ret = {};
		for (var i in def) {
			if (Object.prototype.hasOwnProperty.call(def, i)) if (_options == null) ret[i] = def[i];else {
				var op = _options[i];
				if (op == null) op = def[i];
				ret[i] = op;
			}
		}return ret;
	},

	str: function str(obj, depth) {
		if (depth == null) depth = 1;
		if (!obj || !depth || depth < 1) return "" + obj;
		if (Array.isArray(obj)) return "[ " + obj.map(function (x) {
			return lu.str(x, depth - 1);
		}).join(" ") + " ]";
		if (!obj.constructor || obj.constructor == Object) return "{ " + Object.keys(obj).map(function (x) {
			return x + "=" + lu.str(obj[x], depth - 1);
		}).join(" ") + " }";
		return String(obj);
	},

	toOneLine: function toOneLine(obj) {
		var ret = JSON.stringify(obj);
		ret += "\n";
		return ret;
	},

	byLines: function byLines(callback) {
		var buffer = "";
		return function (chunk) {
			buffer += String(chunk);
			var ret = buffer.split("\n");
			buffer = ret.pop();
			ret.forEach(callback);
		};
	},

	byJSON: function byJSON(callback) {
		return byLines(function (line) {
			return callback(JSON.parse(line.trim()));
		});
	},

	valueOf: function valueOf(val) {
		return val == null ? null : val.valueOf == null ? val : val.valueOf();
	},

	returnThis: function returnThis() {
		return this;
	},
	returnNull: function returnNull() {
		return null;
	},
	returnTrue: function returnTrue() {
		return true;
	},
	returnFalse: function returnFalse() {
		return false;
	},
	returnZero: function returnZero() {
		return 0;
	},
	returnOne: function returnOne() {
		return 1;
	},

	promiseSucceeded: Promise.resolve(),
	promiseNull: Promise.resolve(null),
	promiseTrue: Promise.resolve(true),
	promiseFalse: Promise.resolve(false),
	promiseZero: Promise.resolve(0),
	promiseOne: Promise.resolve(1),

	returnNullPromise: function returnNullPromise() {
		return lu.promiseNull;
	},
	returnTruePromise: function returnTruePromise() {
		return lu.promiseTrue;
	},
	returnFalsePromise: function returnFalsePromise() {
		return lu.promiseFalse;
	},
	returnZeroPromise: function returnZeroPromise() {
		return lu.promiseZero;
	},
	returnOnePromise: function returnOnePromise() {
		return lu.promiseOne;
	},

	when: function when(promise, cb) {
		if (promise != null) promise.then(cb, cb);else process.nextTick(cb);
		return promise;
	},

	waitFor: function waitFor(timeout, interval, callback) {
		if (typeof timeout == "function") {
			interval = timeout;
			timeout = 5000;
		}
		if (typeof interval == "function") {
			callback = interval;
			interval = 200;
		}
		return new Promise(function (resolve, reject) {
			var start = Date.now();
			setTimeout(function check() {
				var ret = undefined;
				if (ret = callback()) resolve(ret);else if (Date.now() - start > timeout) reject(new Error("timeout"));else setTimeout(check, interval);
			}, interval);
		});
	},

	empty: Object.freeze(Object.create(null)),

	JSONEqual: function JSONEqual(a, b) {
		return JSON.stringify(a) == JSON.stringify(b);
	},

	"new": function _new() {
		for (var _len2 = arguments.length, descedents = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			descedents[_key2] = arguments[_key2];
		}

		return Object.assign.apply(Object, [{}].concat(descedents));
	},

	call: function call(fun) {
		for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
			args[_key3 - 1] = arguments[_key3];
		}

		return fun.apply(undefined, args);
	},

	rethrow: function rethrow(e) {
		setTimeout(function () {
			throw e;
		}, 1);
	},

	// optimization -- using try/catch in a separate function.
	"catch": function _catch(cb, ret) {
		try {
			return cb();
		} catch (e) {
			return ret(e);
		}
	},

	catchMap: function catchMap(cb, mapResult, mapError) {
		var result = undefined;
		try {
			result = cb();
		} catch (error) {
			return mapError(error);
		}
		return mapResult(result);
	},

	catchCall: function catchCall(cb) {
		try {
			return { ok: true, result: cb() };
		} catch (error) {
			return { ok: false, error: error };
		}
	},

	"try": regeneratorRuntime.mark(function _try(fun) {
		var startTimeToWait = arguments[1] === undefined ? 100 : arguments[1];
		var maxTimeToWait = arguments[2] === undefined ? 3000 : arguments[2];
		var multiply = arguments[3] === undefined ? 1.5 : arguments[3];
		var timeToWait;
		return regeneratorRuntime.wrap(function _try$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					timeToWait = startTimeToWait;

				case 1:
					context$1$0.prev = 1;
					context$1$0.next = 4;
					return fun();

				case 4:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 7:
					context$1$0.prev = 7;
					context$1$0.t0 = context$1$0["catch"](1);

					lu.rethrow(context$1$0.t0);
					context$1$0.next = 12;
					return co.sleep(timeToWait);

				case 12:
					timeToWait = Math.min(timeToWait * multiply, maxTimeToWait);

				case 13:
					context$1$0.next = 1;
					break;

				case 15:
				case "end":
					return context$1$0.stop();
			}
		}, _try, this, [[1, 7]]);
	}),

	unique: function unique(value, index, array) {
		return index == 0 || value != array[index - 1];
	},

	joinData: function joinData(array) {
		return array.length == 0 ? "" : typeof array[0] == "string" ? array.join("") : Buffer.isBuffer(array[0]) ? Buffer.concat(array) : array.join("");
	},

	on: function on(emitter, events) {
		lodash.forEach(events, function (handler, event) {
			return emitter.on(event, handler);
		});
	},

	off: function off(emitter, events) {
		lodash.forEach(events, function (handler, event) {
			return emitter.removeListener(event, handler);
		});
	},

	readStream: regeneratorRuntime.mark(function readStream(stream) {
		return regeneratorRuntime.wrap(function readStream$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return { then: function then(resolve, reject) {
							var content = [];
							stream.on("data", function (chunk) {
								return content.push(chunk);
							});
							stream.on("end", function () {
								return resolve(lu.joinData(content));
							});
							stream.on("error", reject);
						} };

				case 2:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 3:
				case "end":
					return context$1$0.stop();
			}
		}, readStream, this);
	}),

	readJSON: regeneratorRuntime.mark(function readJSON(stream) {
		return regeneratorRuntime.wrap(function readJSON$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return lu.readStream(stream);

				case 2:
					context$1$0.t0 = context$1$0.sent;
					return context$1$0.abrupt("return", JSON.parse(context$1$0.t0));

				case 4:
				case "end":
					return context$1$0.stop();
			}
		}, readJSON, this);
	}),

	readChunk: regeneratorRuntime.mark(function readChunk(stream) {
		return regeneratorRuntime.wrap(function readChunk$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					context$1$0.next = 2;
					return { then: function then(resolve, reject) {
							stream.on("data", onData);
							stream.on("end", onEnd);
							stream.on("error", onError);
							function done() {
								stream.removeListener("data", onData);
								stream.removeListener("end", onEnd);
								stream.removeListener("error", onError);
							}
							function onData(chunk) {
								done();
								resolve(chunk);
							}
							function onEnd() {
								done();
								resolve(null);
							}
							function onError(error) {
								done();
								reject(error);
							}
						} };

				case 2:
					return context$1$0.abrupt("return", context$1$0.sent);

				case 3:
				case "end":
					return context$1$0.stop();
			}
		}, readChunk, this);
	}),

	"static": function _static(fun) {
		return co.func(regeneratorRuntime.mark(function callee$1$0(request, response) {
			var headWritten, responseEnded, body;
			return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						headWritten = false, responseEnded = false;
						context$2$0.prev = 1;
						context$2$0.next = 4;
						return fun();

					case 4:
						body = context$2$0.sent;

						response.writeHead(200, _defineProperty({}, "Content-Type", "text/html; charset=UTF-8"));
						headWritten = true;
						if (typeof body != "string") body = React.renderComponentToString(body);
						response.end(body);
						responseEnded = true;

					case 10:
						context$2$0.prev = 10;

						if (!headWritten) response.writeHead(500, _defineProperty({}, "Content-Type", "text/plain"));
						if (!responseEnded) response.end("<<< ERROR >>>");
						return context$2$0.finish(10);

					case 14:
					case "end":
						return context$2$0.stop();
				}
			}, callee$1$0, this, [[1,, 10, 14]]);
		}));
	},

	property: function property(obj, name, defaultValue) {
		var privateName = "_" + name;
		if (arguments.length > 2) obj[privateName] = defaultValue;
		obj[name] = function (value) {
			if (arguments.length == 0) return obj[privateName];else {
				obj[privateName] = value;
				return obj;
			}
		};
		return obj;
	},

	polling: function polling(stream) {
		var ret = {
			stop: function stop() {
				if (!ret) return;
				if (ret._polling != null) {
					clearTimeout(ret._polling);
					ret._polling = null;
				}
				ret = null;
			},
			_polling: null,
			_tryToSendChunk: function _tryToSendChunk() {
				if (!ret) return;
				ret._polling = null;
				if (!stream.write(ret._chunk)) stream.once("drain", ret._tryToSendChunk);else {
					if (typeof stream.flush == "function") stream.flush();
					ret._polling = setTimeout(ret._tryToSendChunk, ret._interval);
				}
			}
		};

		lu.property(ret, "chunk", "\n");
		lu.property(ret, "interval", 60000);

		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("end", ret.stop);
		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("close", ret.stop);
		// TODO: this event never fires! what's the shit? check it! may be the reason is .use( require( `compression` )( { threshold: 0 } ) )?
		stream.once("error", ret.stop);

		process.nextTick(ret._tryToSendChunk);

		return ret;
	},

	testDiff: function testDiff() {
		var p = { a: 1, x: { u: 9 } };
		var q = { x: { c: 2 } };
		assert(JSON.stringify(q) == JSON.stringify(lu.applyDiff(p, lu.makeDiff(p, q))));
	},

	isSet: function isSet(obj) {
		if (obj == null) return false;
		var proto = Object.getPrototypeOf(obj);
		return proto === LiteralPrototype || proto === null;
	},

	applyDiff: function applyDiff(dest, diff, partial) {
		var ret = dest;
		var cnt = 0;

		function copyDest() {
			ret = Object.create(null);
			for (var key in dest) {
				if (Object.prototype.hasOwnProperty.call(dest, key)) {
					var value = dest[key];
					if (value === undefined) continue;
					ret[key] = dest[key];
					++cnt;
				}
			}
		}

		if (diff && diff.__partial__ === false) partial = false;

		for (var key in diff) {
			if (key != "__partial__" && Object.prototype.hasOwnProperty.call(diff, key)) {
				var value = diff[key];
				if (value === undefined) continue;
				if (value != null && typeof value == "object") value = lu.applyDiff(ret && ret[key], value, partial);
				if (value == null) {
					if (ret != null && Object.prototype.hasOwnProperty.call(ret, key)) {
						if (ret === dest) copyDest();
						delete ret[key];
						--cnt;
					}
				} else {
					if (ret == null || ret[key] !== value) {
						if (ret === dest) copyDest();
						ret[key] = value;
					}
					cnt = Infinity;
				}
			}
		}if (partial === false) for (var key in ret) {
			if (Object.prototype.hasOwnProperty.call(ret, key)) {
				if (!Object.prototype.hasOwnProperty.call(diff, key) || diff[key] === undefined) {
					if (ret === dest) copyDest();
					delete ret[key];
					--cnt;
				} else cnt = Infinity;
			}
		}if (ret !== dest && cnt == 0) ret = null;

		return ret;
	},

	mergeDiffs: function mergeDiffs(a, b) {

		if (a == null) a = NON_PARTIAL;
		if (b == null) b = NON_PARTIAL;

		if (b.__partial__ === false) return b;

		var ret = a;

		function copyDest() {
			ret = Object.create(null);
			for (var key in a) {
				if (Object.prototype.hasOwnProperty.call(a, key)) {
					var value = a[key];
					if (value === undefined) continue;
					ret[key] = a[key];
				}
			}
		}

		for (var key in b) {
			if (Object.prototype.hasOwnProperty.call(b, key)) {
				var value = b[key];
				if (value === undefined) continue;
				if (value == null) value = NON_PARTIAL;
				if (typeof value == "object") {
					var r = ret ? ret[key] : undefined;
					if (r === undefined) r = PARTIAL;
					value = lu.mergeDiffs(r, value);
				}
				if (ret == null || ret[key] !== value) {
					if (ret === a) copyDest();
					ret[key] = value;
				}
			}
		}if (ret !== a && typeof a != "object") ret.__partial__ = false;

		return ret;
	},

	makeDiff: function makeDiff(previous, next) {
		if (previous === next) return undefined;
		var ret = undefined;
		function toArray(obj) {
			var ret = [];
			lodash.forEach(obj, function (value, key) {
				return ret.push({ value: value, key: key });
			});
			return ret.sort(function (v1, v2) {
				return v1.key < v2.key ? -1 : v1.key > v2.key ? 1 : 0;
			});
		}
		var pa = toArray(previous);
		var na = toArray(next);
		var p = pa.pop();
		var n = na.pop();
		while (p || n) {
			if (!n || p && p.key > n.key) {
				if (!ret) ret = Object.create(null);
				ret[p.key] = null; // deleting
				p = pa.pop();
			} else if (!p || p.key < n.key) {
				if (!ret) ret = Object.create(null);
				ret[n.key] = n.value;
				n = na.pop();
			} else {
				if (p.value !== n.value) {
					if (lu.isSet(p.value) && lu.isSet(n.value)) {
						var diff = lu.makeDiff(p.value, n.value);
						if (diff) {
							if (!ret) ret = Object.create(null);
							ret[n.key] = diff;
						}
					} else {
						if (!ret) ret = Object.create(null);
						ret[n.key] = n.value;
					}
				}
				p = pa.pop();
				n = na.pop();
			}
		}
		return ret ? ret : undefined;
	},

	concatString: function concatString(array) {
		var ret = "";
		!(function walk(array) {
			if (typeof array != "object") ret += array;else if (array.length != null) array.forEach(walk);else {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _s = _step2.value;

						walk(_s);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		})(array);
		return ret;
	},

	sortedDiff: function sortedDiff(first, second) {
		var fi = first[Symbol.iterator]();
		var si = second[Symbol.iterator]();
		var ret = {
			common: [],
			first: [],
			second: []
		};
		var fv = fi.next(),
		    sv = si.next();
		while (!fv.done || !sv.done) {
			if (sv.done || fv.value < sv.value) {
				ret.first.push(fv.value);
				fv = fi.next();
			} else if (fv.done || fv.value > sv.value) {
				ret.second.push(sv.value);
				sv = si.next();
			} else {
				ret.common.push(fv.value);
				fv = fi.next();
				sv = si.next();
			}
		}
		return ret;
	},

	measure: function measure(fun) {
		var now = global.performance || global.Date;
		var t = now.now();
		try {
			return fun();
		} finally {
			t = (now.now() - t) / 1000;
			if (t > 0) {
				var i = 1;
				while (t < 1000) {
					i *= 10;
					t *= 10;
				}
				t = Math.round(t) / i;
			}
			console.log(t);
		}
	},

	skip: regeneratorRuntime.mark(function skip(c, buf) {
		var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, b;

		return regeneratorRuntime.wrap(function skip$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion3 = true;
					_didIteratorError3 = false;
					_iteratorError3 = undefined;
					context$1$0.prev = 3;
					_iterator3 = buf[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
						context$1$0.next = 16;
						break;
					}

					b = _step3.value;

					if (!(c > 0)) {
						context$1$0.next = 11;
						break;
					}

					--c;
					context$1$0.next = 13;
					break;

				case 11:
					context$1$0.next = 13;
					return b;

				case 13:
					_iteratorNormalCompletion3 = true;
					context$1$0.next = 5;
					break;

				case 16:
					context$1$0.next = 22;
					break;

				case 18:
					context$1$0.prev = 18;
					context$1$0.t0 = context$1$0["catch"](3);
					_didIteratorError3 = true;
					_iteratorError3 = context$1$0.t0;

				case 22:
					context$1$0.prev = 22;
					context$1$0.prev = 23;

					if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
						_iterator3["return"]();
					}

				case 25:
					context$1$0.prev = 25;

					if (!_didIteratorError3) {
						context$1$0.next = 28;
						break;
					}

					throw _iteratorError3;

				case 28:
					return context$1$0.finish(25);

				case 29:
					return context$1$0.finish(22);

				case 30:
				case "end":
					return context$1$0.stop();
			}
		}, skip, this, [[3, 18, 22, 30], [23,, 25, 29]]);
	}),

	take: regeneratorRuntime.mark(function take(c, buf) {
		var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, b;

		return regeneratorRuntime.wrap(function take$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion4 = true;
					_didIteratorError4 = false;
					_iteratorError4 = undefined;
					context$1$0.prev = 3;
					_iterator4 = buf[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
						context$1$0.next = 17;
						break;
					}

					b = _step4.value;

					if (!(c > 0)) {
						context$1$0.next = 13;
						break;
					}

					--c;
					context$1$0.next = 11;
					return b;

				case 11:
					context$1$0.next = 14;
					break;

				case 13:
					return context$1$0.abrupt("break", 17);

				case 14:
					_iteratorNormalCompletion4 = true;
					context$1$0.next = 5;
					break;

				case 17:
					context$1$0.next = 23;
					break;

				case 19:
					context$1$0.prev = 19;
					context$1$0.t0 = context$1$0["catch"](3);
					_didIteratorError4 = true;
					_iteratorError4 = context$1$0.t0;

				case 23:
					context$1$0.prev = 23;
					context$1$0.prev = 24;

					if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
						_iterator4["return"]();
					}

				case 26:
					context$1$0.prev = 26;

					if (!_didIteratorError4) {
						context$1$0.next = 29;
						break;
					}

					throw _iteratorError4;

				case 29:
					return context$1$0.finish(26);

				case 30:
					return context$1$0.finish(23);

				case 31:
				case "end":
					return context$1$0.stop();
			}
		}, take, this, [[3, 19, 23, 31], [24,, 26, 30]]);
	}),

	copy: function copy(buf) {
		var ret = lu.array(buf);
		if (ret == buf) ret = buf.slice();
		return ret;
	},

	array1: function array1(value) {
		if (Array.isArray(value)) return value;else return [value];
	},

	array: function array(buf) {
		if (Array.isArray(buf)) return buf;
		var ret = [];
		if (!buf[Symbol.iterator]) for (var i = 0; i < buf.length; ++i) {
			ret.push(buf[i]);
		} else {
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = buf[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var _b = _step5.value;

					ret.push(_b);
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
						_iterator5["return"]();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}return ret;
	},

	buffer: function buffer(buf) {
		if (buf instanceof Buffer) return buf;else return new Buffer(lu.array(buf));
	},

	vector: function vector(buf) {
		return buf instanceof Buffer ? buf : lu.array(buf);
	},

	concat: regeneratorRuntime.mark(function concat(list) {
		var _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, l, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, x;

		return regeneratorRuntime.wrap(function concat$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					_iteratorNormalCompletion6 = true;
					_didIteratorError6 = false;
					_iteratorError6 = undefined;
					context$1$0.prev = 3;
					_iterator6 = list[Symbol.iterator]();

				case 5:
					if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
						context$1$0.next = 36;
						break;
					}

					l = _step6.value;
					_iteratorNormalCompletion7 = true;
					_didIteratorError7 = false;
					_iteratorError7 = undefined;
					context$1$0.prev = 10;
					_iterator7 = l[Symbol.iterator]();

				case 12:
					if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
						context$1$0.next = 19;
						break;
					}

					x = _step7.value;
					context$1$0.next = 16;
					return x;

				case 16:
					_iteratorNormalCompletion7 = true;
					context$1$0.next = 12;
					break;

				case 19:
					context$1$0.next = 25;
					break;

				case 21:
					context$1$0.prev = 21;
					context$1$0.t0 = context$1$0["catch"](10);
					_didIteratorError7 = true;
					_iteratorError7 = context$1$0.t0;

				case 25:
					context$1$0.prev = 25;
					context$1$0.prev = 26;

					if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
						_iterator7["return"]();
					}

				case 28:
					context$1$0.prev = 28;

					if (!_didIteratorError7) {
						context$1$0.next = 31;
						break;
					}

					throw _iteratorError7;

				case 31:
					return context$1$0.finish(28);

				case 32:
					return context$1$0.finish(25);

				case 33:
					_iteratorNormalCompletion6 = true;
					context$1$0.next = 5;
					break;

				case 36:
					context$1$0.next = 42;
					break;

				case 38:
					context$1$0.prev = 38;
					context$1$0.t1 = context$1$0["catch"](3);
					_didIteratorError6 = true;
					_iteratorError6 = context$1$0.t1;

				case 42:
					context$1$0.prev = 42;
					context$1$0.prev = 43;

					if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
						_iterator6["return"]();
					}

				case 45:
					context$1$0.prev = 45;

					if (!_didIteratorError6) {
						context$1$0.next = 48;
						break;
					}

					throw _iteratorError6;

				case 48:
					return context$1$0.finish(45);

				case 49:
					return context$1$0.finish(42);

				case 50:
				case "end":
					return context$1$0.stop();
			}
		}, concat, this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
	}),

	word: function word(w) {
		return [w & 255, w >> 8 & 255];
	},

	dword: function dword(w) {
		return [w & 255, w >> 8 & 255, w >> 16 & 255, w >> 24 & 255];
	},

	makeWord: function makeWord(lo, hi) {
		return (lo & 255) + (hi & 255) << 8;
	},

	arrayEqual: function arrayEqual(a, b) {
		return a && b && a.length == b.length && a.every(function (ai, i) {
			return ai == b[i];
		});
	},

	compare: function compare(a, b) {
		if (a == b) return 0;
		if (a < b) return -1;
		return 1;
	},

	formatms: function formatms(value) {
		var ret = "";
		value = Math.round(value);
		var ms = value % 1000;
		value -= ms;
		value /= 1000;
		var s = value % 60;
		value -= s;
		value /= 60;
		var m = value % 60;
		value -= m;
		value /= 60;
		var h = value;
		ret += h ? h : "";
		ret += ret ? ":" + z(m, 2) : m ? m : "";
		ret += ret ? ":" + z(s, 2) : s;
		ret += "." + z(ms, 3);
		return ret;
		function z(value, len) {
			var str = String(value);
			var ret = "";
			for (var i = str.length; i < len; ++i) {
				ret += "0";
			}ret += str;
			return ret;
		}
	},

	get: function get(obj) {
		for (var _len4 = arguments.length, path = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
			path[_key4 - 1] = arguments[_key4];
		}

		var _iteratorNormalCompletion8 = true;
		var _didIteratorError8 = false;
		var _iteratorError8 = undefined;

		try {
			for (var _iterator8 = path[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
				var p = _step8.value;

				if (obj == null) break;else obj = obj[p];
			}
		} catch (err) {
			_didIteratorError8 = true;
			_iteratorError8 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion8 && _iterator8["return"]) {
					_iterator8["return"]();
				}
			} finally {
				if (_didIteratorError8) {
					throw _iteratorError8;
				}
			}
		}

		return obj;
	},

	limitCalls: function limitCalls(limit, period, message) {
		var calls = 0;
		return function () {
			if (calls >= limit) if (message) throw new Error.create(message);else return false;
			++calls;
			setTimeout(function () {
				return --calls;
			}, period);
			return true;
		};
	}

};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/localUtils.js","/src")

},{"_process":99,"buffer":94,"co":125,"lodash":116}],135:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

Object.defineProperty(Object.prototype, "_LOG_", { value: function value() {
		console.log(this);
		return this;
	}, configurable: true });

if (typeof Symbol == "function" && Symbol.iterator) {
	var x = null;
	try {
		x = eval.call(null, "(function*(){}().constructor.prototype)");
	} catch (_) {}
	if (x && !x[Symbol.iterator]) x[Symbol.iterator] = function () {
		return this;
	};
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/platform.js","/src")

},{"_process":99,"buffer":94}],136:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*

TODO:

* Warning if a live property has not been read during the life time of observable value or during some period of time (e.g. 1-30 minutes) since creating that observable value.

* check for changes during execution of (function*) and restart calculus.


TODO BUG:
let app = ra.clean( {
	moving1: {
		a: 1,
		b: 2,
		c: {
			d: 3,
		},
	},
}
_app.moving1.a
1
_app.moving1.c.d
3
_app.moving1={a:4}
Object {a: 4}
_app.moving1.c.d
3                       <----------- !!!  MUST BE NULL !!!!
_app.moving1.c
Cell {_id: "j87yqkoqppuv", _value: null, _error: null, _isValueEqual: function, _initialized: true…}
_app.moving1.c.valueOf()
null


*/

"use strict";

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var later = require("later").push;
var co = require("co");
var UID = require("uid");
var lodash = require("lodash");

var _require = require("LOG");

var LOG = _require.LOG;

var actionKey = "_RA_ACTION_" + UID();
var raValue = "_RA_VALUE_" + UID();

// let debugLog = false

var updates = {};
updates.scheduled = false;
updates.procs = [];
updates.index = 0;
updates.maxIndex = 32768;
updates.processing = false;
updates.totalTime = 0;
updates.maxTime = 0;
updates.maxTime1 = 0;
updates.minTime = Infinity;
updates.runCount = 0;
updates.runAllCount = 0;

global.updates = updates; // debugger

var performance = global.performance || global.Date;
updates.start = performance.now();

updates.log = function () {
	return console.log(":: " + updates.totalTime / 1000 + " / " + (performance.now() - updates.start) / 1000 + " (" + updates.maxTime / 1000 + ", " + updates.maxTime1 / 1000 + ", " + updates.minTime / 1000 + ", " + Action.maxCount + ", " + updates.runCount + ", " + updates.runAllCount + ")");
};

// co.go( function* () { // debugger
// 	let sleep5000 = co.sleep( 5000 )
// 	for (;;) {
// 		let totalTime = updates.totalTime
// 		yield sleep5000
// 		if ( totalTime != updates.totalTime )
// 			updates.log()
// 	}
// } )

updates.checkSchedule = function () {
	if (!updates.scheduled && updates.procs.length > 0) {
		updates.scheduled = true;
		later(updates.tick);
	}
};

updates.tick = function () {
	updates.scheduled = false;
	for (var _try = 0; _try < 1000; ++_try) {
		try {
			updates.runAll();
			break;
		} catch (error) {
			setTimeout(function () {
				throw error;
			}, 1);
		}
	}
	updates.checkSchedule();
};

updates.runAll = function () {
	// if ( updates.processing )
	// 	return

	var start = performance.now();
	var st1 = start;
	var runCount = updates.runCount;

	var processing = updates.processing;
	updates.processing = true;
	var action = co.global[actionKey];
	if (action != null) co.global[actionKey] = null;
	try {
		while (updates.index < updates.procs.length) {
			if (global.APP_TIMEOUT && global.APP_TIMEOUT < Date.now) {
				alert("Application is running too long");
			}
			var proc = updates.procs[updates.index];
			++updates.index;
			++updates.runCount;
			if (updates.index >= updates.maxIndex && updates.index * 3 > updates.procs.length) {
				updates.procs.splice(0, updates.index);
				updates.index = 0;
			}
			proc();
			var t1 = performance.now();
			if (updates.maxTime1 < t1 - st1) updates.maxTime1 = t1 - st1;
			// if ( t1 - st1 > 10 )
			// 	console.log( t1 - st1, `` + proc.$name ) // debugger
			st1 = t1;
		}
		updates.index = updates.procs.length = 0;
	} finally {
		if (action != null) co.global[actionKey] = action;
		updates.processing = processing;
		if (!processing) {
			var time = performance.now() - start;
			updates.totalTime += time;
			if (updates.maxTime < time) updates.maxTime = time;
			runCount = updates.runCount - runCount;
			if (runCount) {
				++updates.runAllCount;
				if (updates.minTime > time) updates.minTime = time;
			}
			if (time > 300) LOG("updates have been run for " + time.toString().red + " ms");
		}
	}
};

updates.later = function (proc) {
	updates.procs.push(proc);
	updates.checkSchedule();
};

updates.later.then = updates.later;

var checkNull = function checkNull(value) {
	return value == null ? null : value;
};
var returnThis = function returnThis() {
	return this;
};

var isLiteral = function isLiteral(value) {
	return value && typeof value == "object" && value.constructor == Object;
};
var getValue = function getValue(value) {
	return value == null || value.valueOf == null ? value : value.valueOf();
};

function AbstractGuard() {}

var invalidKeyCall = function invalidKeyCall(key) {
	throw new Error("access to an undeclared property \"" + this.$name + "." + key + "\"");
};

var usedProps = Object.create(null);
var usedPropsProto = Object.create(null);
var guardProp = function guardProp(key) {
	if (!usedProps[key]) {
		usedProps[key] = true;
		Object.defineProperty(usedPropsProto, key, {
			get: function get() {
				invalidKeyCall.call(this, key);
			},
			set: function set() {
				invalidKeyCall.call(this, key);
			}
		});
	}
};
AbstractGuard.prototype = usedPropsProto;

// Не зразумела толкам, як гэты Proxy працуе ў якасьці прататыпу.
// Пакуль што, здаецца, паводзіны не адпавядаюць сьпецыфікацыі (2014.11.25)

// if ( typeof Proxy == "function" ) {
// 	AbstractGuard.prototype = new Proxy( AbstractGuard.prototype, {
// 		get: function ( _, key ) { invalidKeyCall.call( this, key ) },
// 		set: function ( _, key ) { invalidKeyCall.call( this, key ) },
// 	} )
// }

if (global.APP_DEBUG) {
	//
	// аб'яўленьне аб'екта з ~700-800 уласьцівасьцяў з функцыямі чытаньня/запісу
	// займае ў Google Chrome'е каля траціны секунды.
	// Правераныя спосабы:
	// - дабаўленьне па адным праз Object.defineProperty
	// - дабаўленьне гуртам праз Object.defineProperties
	// - кампіляцыя зыходніка праз лакальны eval
	// - кампіляцыя зыходніка праз глабальны eval
	// - кампіляцыя зыходніка праз дабаўленьне тэгу script з зыходнікам
	// Не правераныя спосабы:
	// - дабаўленьне тэгу script з пазнакай src
	// Паляпшае сітуацыю (напалову):
	// - стварэньне для кожнай уласьцівасьці новага аб'екта са старым аб'ектам
	// у якасьці прататыпу. Пры гэтым доступ да неаб'яўленых уласьцівасьцяў можа
	// стаць адносна доўгім па часе, але ж гэта ня так важна, бо ў выніку ўсё адно
	// кідаецца памылка.
	//
	// Генерацыя тэксту зыходніка адбываецца імгненна.
	//
	// Зыходзячы з гэтага улучаць стражнікаў доступу да неаб'яўленых уласьцівасьцяў
	// трэба толькі пры адладцы.
	//
	AbstractGuard.prototype = (global.__UsedScriptIdentifiers__ + "").split(/[\s,]+/).reduce(function (proto, key) {
		return Object.create(proto, _defineProperty({}, key, {
			get: function get() {
				invalidKeyCall.call(this, key);
			},
			set: function set(_) {
				invalidKeyCall.call(this, key);
			}
		}));
	}, AbstractGuard.prototype);
}

AbstractGuard.prototype = Object.create(AbstractGuard.prototype, {
	toString: { value: ({}).toString },
	valueOf: { value: ({}).valueOf },
	toLocaleString: { value: ({}).toLocaleString },
	hasOwnProperty: { value: ({}).hasOwnProperty },
	isPrototypeOf: { value: ({}).isPrototypeOf },
	propertyIsEnumerable: { value: ({}).propertyIsEnumerable },
	$name: { value: "<...>", writable: 1 }
});

var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);

var ImmutableInterface = (function (_AbstractGuard) {
	function ImmutableInterface() {
		_classCallCheck(this, ImmutableInterface);

		if (_AbstractGuard != null) {
			_AbstractGuard.apply(this, arguments);
		}
	}

	_inherits(ImmutableInterface, _AbstractGuard);

	_createClass(ImmutableInterface, [{
		key: "get",
		value: function get(key) {
			if (key != null) {
				var m = this.valueOf();
				if (m != null && Object.prototype.hasOwnProperty.call(m, key)) return m[key];
			}
			return null;
		}
	}, {
		key: "map",
		value: function map(fun) {
			var m = this.valueOf();
			return m && (Array.isArray(m) ? lodash.map(m, fun) : lodash.mapValues(m, fun));
		}
	}, {
		key: "keys",
		value: function keys() {
			var m = this.valueOf();
			return m == null ? EMPTY_ARRAY : Object.keys(m);
		}
	}, {
		key: "props",

		// debugger
		get: function () {
			throw new Error("access to deprecated 'props' property detected");
		}
	}, {
		key: "declaredProperties",
		get: function () {
			return this.live;
		}
	}, {
		key: "length",
		get: function () {
			var m = this.valueOf();return m == null ? 0 : Object.keys(m).length;
		}
	}]);

	return ImmutableInterface;
})(AbstractGuard);

var ReadOnlyCell = (function (_ImmutableInterface) {
	function ReadOnlyCell(parent) {
		_classCallCheck(this, ReadOnlyCell);

		_get(Object.getPrototypeOf(ReadOnlyCell.prototype), "constructor", this).call(this);
		this._parent = parent;
	}

	_inherits(ReadOnlyCell, _ImmutableInterface);

	_createClass(ReadOnlyCell, [{
		key: "getReadOnly",
		value: function getReadOnly() {
			return this;
		}
	}, {
		key: "valueOf",
		value: function valueOf() {
			return this._parent.valueOf.apply(this._parent, arguments);
		}
	}, {
		key: "noTouch",
		value: function noTouch() {
			return this._parent.noTouch.apply(this._parent, arguments);
		}
	}, {
		key: "toString",
		value: function toString() {
			return this._parent.toString.apply(this._parent, arguments);
		}
	}, {
		key: "toJSON",
		value: function toJSON() {
			return this._parent.toJSON.apply(this._parent, arguments);
		}
	}, {
		key: "getName",
		value: function getName() {
			return this._parent.getName.apply(this._parent, arguments);
		}
	}, {
		key: "live",
		get: function () {
			return this._parent.live;
		}
	}, {
		key: "$name",
		get: function () {
			return this._parent.$name;
		}
	}]);

	return ReadOnlyCell;
})(ImmutableInterface);

var Getter = function Getter(fun, isValueEqual) {
	var last = undefined;
	var ret = !isValueEqual ? function () {
		return fun.apply(this, arguments);
	} : function () {
		var ret = fun.apply(this, arguments);
		if (!is(last, ret, isValueEqual)) last = ret;
		return last;
	};
	ret.isGetter = true;
	return ret;
};

var Type = function Type(f) {
	g.typeDescriptor = true;
	return g;
	function g() {
		return f.apply(this, arguments);
	}
};

var runGetter = function runGetter(cell, getter, sticky) {
	return new Action(getter, cell, sticky).linkName(cell, ":getter");
};

var runSetter = function runSetter(cell, setter, sticky) {
	return new Action(function () {
		return setter(cell.valueOf());
	}, null, sticky).linkName(cell, ":setter");
};

function is(a, b, isEqual) {
	return Object.is(a, b) || b && typeof b.isEqualTo == "function" && b.isEqualTo(a) || a && typeof a.isEqualTo == "function" && a.isEqualTo(b) || typeof isEqual == "function" && isEqual(a, b);
}

var This = (function () {
	function This() {
		_classCallCheck(this, This);
	}

	_createClass(This, [{
		key: "_defineThatProperty",
		value: function _defineThatProperty(key, that) {
			Object.defineProperty(this, key, {
				configurable: true,
				enumerable: true,
				get: function get() {
					return that[key];
				},
				set: function set(value) {
					that[key] = value;
				}
			});
		}
	}], [{
		key: "create",
		value: function create(parent, that) {
			var ret = null;
			if (!parent) ret = new This();else ret = Object.create(parent);
			ret.valueOf = function () {
				return that.valueOf();
			};
			ret.toString = function () {
				return that.toString();
			};
			ret.toJSON = function () {
				return that.toJSON();
			};
			ret.assign = function (value) {
				return that.assign(value);
			};
			ret["throw"] = function (value) {
				return that["throw"](value);
			};
			Object.defineProperty(ret, "live", { get: function get() {
					return that.live;
				} });
			return ret;
		}
	}]);

	return This;
})();

var Cell = (function (_ImmutableInterface2) {
	function Cell(sticky) {
		var _this = this;

		_classCallCheck(this, Cell);

		_get(Object.getPrototypeOf(Cell.prototype), "constructor", this).call(this);
		this._id = UID();
		this._that = null;
		this._value = null;
		this._error = null;
		this._isValueEqual = is;
		this._initialized = false;
		this._frozen = false;
		this._closed = false;
		this._dirty = false;
		this._live = null;
		this._liveArray = null;
		this._actionsArr = [];
		this._parent = null;
		this._onchange = [];
		this.$name = { toString: function toString() {
				return _this.getName();
			} };
		this._notifyWritten();
		this._sticky = !!sticky;
	}

	_inherits(Cell, _ImmutableInterface2);

	_createClass(Cell, [{
		key: "valueOf",
		value: function valueOf() {
			return this._read();
		}
	}, {
		key: "assign",
		value: function assign(value) {
			return this._write(value, false, null);
		}
	}, {
		key: "update",
		value: function update(diff) {
			return this.assign(lu.applyDiff(this.noTouch(), diff));
		}
	}, {
		key: "throw",
		value: function _throw(value) {
			return this._write(null, false, value);
		}
	}, {
		key: "touch",
		value: function touch() {
			this._fire();
		}
	}, {
		key: "noTouch",
		value: function noTouch() {
			if (this._dirty) this._updateSelf();
			if (this._error) throw this._error;
			return this._value;
		}
	}, {
		key: "then",
		value: function then(proc) {
			this._onchange.push(proc);
		}
	}, {
		key: "close",
		value: function close() {
			if (this._closed) return;
			this._closed = true;
			this._fire();
			if (this._parent) this._parent.close();
			if (this._liveArray) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this._liveArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var p = _step.value;

						p.close();
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator["return"]) {
							_iterator["return"]();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				this._liveArray = null;
			}
			this._value = null;
			this._error = null;
			this._actionsArr = null;
			this._parent = null;
		}
	}, {
		key: "freeze",
		value: function freeze() {
			if (this._closed || this._frozen) return;
			this._frozen = true;
			this._fire(); // TODO для выдаленьня спасылак абысьціся без _fire і адпаведна без лішняга прагону
			if (this._parent) this._parent.freeze();
			if (this._liveArray) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = this._liveArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var p = _step2.value;

						p.freeze();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		}
	}, {
		key: "getReadOnly",
		value: function getReadOnly() {
			return this._readOnly || (this._readOnly = new ReadOnlyCell(this));
		}
	}, {
		key: "toString",
		value: function toString() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			var v = this._read();
			return v == null || !v.toString ? "" + v : v.toString.apply(v, args);
		}
	}, {
		key: "toJSON",
		value: function toJSON() {
			for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}

			var v = this._read();
			return v == null || !v.toJSON ? v : v.toJSON.apply(v, args);
		}
	}, {
		key: "with",
		value: function _with(cb) {
			return cb.call(this._getThat());
		}
	}, {
		key: "setName",
		value: function setName(name) {
			this._name = name;
			return this;
		}
	}, {
		key: "getName",
		value: function getName() {
			var ret = this._name || this._key;
			var p = this._parent;
			while (p) {
				ret = (p._name || p._key) + "." + ret;
				p = p._parent;
			}
			return ret;
		}
	}, {
		key: "_getThat",
		value: function _getThat() {
			if (!this._that) {
				this._that = This.create(this._parent && this._parent._getThat(), this);
				if (this._live) for (var i in this._live) {
					this._that._defineThatProperty(i, this);
				}
			}
			return this._that;
		}
	}, {
		key: "defineProperty",
		value: function defineProperty(key) {
			// pass key == `` to make Cell object, not value
			if (!this._live) {
				this._live = Object.create(null);
				this._liveArray = [];
			}
			if (!key) return;
			guardProp(key);
			var c = this._live[key];
			if (c) return c;
			c = new Cell(this._sticky);
			this._live[key] = c;
			this._liveArray.push(c);
			c._key = key;
			c._parent = this;
			c._level = (this._level || 0) + 1;
			Object.defineProperty(this, key, {
				enumerable: true,
				configurable: true,
				get: function get() {
					if (c._live) return c;else return c._read();
				},
				set: function set(value) {
					if (c._live) value = getValue(value);
					c._write(value, false);
				}
			});
			if (this._that) this._that._defineThatProperty(key, this);
			if (this._value != null) c._write(this._value[key], true);
			return c;
		}
	}, {
		key: "init",
		value: function init(value) {
			this._init(value, false, false);
		}
	}, {
		key: "setConst",
		value: function setConst(prop, value) {
			Object.defineProperty(this, prop, { enumerable: true, get: function get() {
					return value;
				} });
			return this;
		}
	}, {
		key: "setVar",
		value: function setVar(prop, value) {
			Object.defineProperty(this, prop, { enumerable: true, writable: true, value: value });
			return this;
		}
	}, {
		key: "_init",
		value: function _init(value, recursive, isGetter, isValueEqual) {
			var cell = this;
			if (!recursive && cell._initialized) throw new Error("already initialized");
			if (this._parent) this._parent._dirty = true;
			cell._initialized = true;
			if (isValueEqual) this._isValueEqual = isValueEqual;
			value = checkNull(value);
			if (typeof value == "function" && value.typeDescriptor) value = value(cell._key);
			if (value == null) // we are already null at the point of birth
				return;
			if (value[raValue]) // force just a value
				return cell._value = value;
			if (typeof value == "function") {
				if (isGetter || value.isGetter) // getter
					runGetter(cell, function () {
						return value.call(cell._parent && cell._parent._getThat());
					}, this._sticky);else // method
					cell._value = function () {
						return value.apply(cell._parent && cell._parent._getThat(), arguments);
					};
				return;
			}
			if (!isLiteral(value)) // just a value
				return cell._value = value;
			// subrecord description
			if (recursive) throw new Error("wrong parameters");
			cell.defineProperty();
			for (var key in value) {
				var descr = Object.getOwnPropertyDescriptor(value, key);
				if (!descr) continue;
				var get = descr.get;
				var subValue = descr.value;
				if (descr.set) throw new Error("wrong parameters");else if (get) subValue = get;
				if (key == "$") cell._init(subValue, true, !!get);else cell.defineProperty(key, true)._init(subValue, false, !!get);
			}
		}
	}, {
		key: "_read",
		value: function _read() {
			if (this._dirty) this._updateSelf();
			var action = co.global[actionKey];
			if (action) {
				if (this._closed) action.close();else if (!this._frozen) action.onread(this);
			}
			if (this._error) throw this._error;
			return this._value;
		}
	}, {
		key: "_write",
		value: function _write(newValue, down, newError) {
			if (newError == null) newError = null;
			if (this._frozen) throw new Error("Try to change a frozen value");
			this._initialized = true;
			this._dirty = false;
			newValue = checkNull(newValue);
			if (this._closed) {
				var action = co.global[actionKey];
				if (action) action.close();
			} else if (!this._isValueEqual(this._value, newValue) || this._error != newError) {
				// console.log(`>`+this.$name)//debugger
				this._value = newValue;
				this._error = newError;
				if (this._live) {
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = this._liveArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var _p = _step3.value;

							_p._write(newValue && newValue[_p._key], true);
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
								_iterator3["return"]();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}this._fire();
				if (!down) {
					var p = this._parent;
					while (p && !p._dirty) {
						p._dirty = true;
						p._fire();
						p = p._parent;
					}
				}
			}
			if (!down) this._notifyWritten();
			return newValue;
		}
	}, {
		key: "_updateSelf",
		value: function _updateSelf() {
			var cnt = 0;
			var ret = {};
			for (var key in this._value) {
				if (Object.prototype.hasOwnProperty.call(this._value, key)) {
					ret[key] = this._value[key];
					++cnt;
				}
			}var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = this._liveArray[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var p = _step4.value;

					if (p._dirty) p._updateSelf();
					if (p._error) {
						this._error = p._error;
						this._value = null;
						this._dirty = false;
						return;
					}
					var value = p._value;
					if (value == null) {
						if (Object.prototype.hasOwnProperty.call(ret, p._key)) {
							delete ret[p._key];
							--cnt;
						}
					} else {
						ret[p._key] = value;
						cnt = Infinity;
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
						_iterator4["return"]();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			if (cnt == 0) ret = null;

			this._value = ret;
			this._dirty = false;
		}
	}, {
		key: "debug",
		value: function debug(cb) {
			this._actionsArr.push({ action: { _fire: cb } });
		}
	}, {
		key: "debugger",
		value: function _debugger() {
			this.debug(function () {
				debugger;
			});
		}
	}, {
		key: "_fire",
		value: function _fire() {
			var a = undefined;
			a = this._actionsArr;
			if (a.length) {
				for (var i = 0; i < a.length; i++) {
					var c = a[i];
					if (c.action) c.action._fire();
					c.pushedC = false;
				}
				a.length = 0;
			}
			a = this._onchange;
			if (a.length) {
				for (var i = 0; i < a.length; i++) {
					updates.later(a[i]);
				}a.length = 0;
			}
		}
	}, {
		key: "_notifyWritten",
		value: function _notifyWritten() {
			var action = co.global[actionKey];
			if (action) action.onwritten(this);
		}
	}, {
		key: "live",
		get: function () {
			return this._live;
		}
	}, {
		key: raValue,
		get: function () {
			return true;
		}
	}]);

	return Cell;
})(ImmutableInterface);

var rethrow = function rethrow(error) {
	return setTimeout(function () {
		throw error;
	}, 1);
};

var Action = (function () {
	function Action(fun, dest, sticky) {
		var _this2 = this;

		_classCallCheck(this, Action);

		this._id = UID();
		this._fun = fun;
		this._dest = dest;
		this._cellSet = {};
		this._cellSetSize = 0;
		this._cellArr = [];
		this.$name = { toString: function toString() {
				return "<Action>";
			} };
		this._thread = co.gocall(this._loop, this).linkName(this).waitForInput();
		this._runCount = 0;
		var owner = undefined;
		if ((owner = co.global[actionKey]) && owner._children) owner._children.push(this);
		this._children = null;
		this._threads = null;
		this._onthread = null;
		this._generatorProxy = null;
		this._generator = null;
		if (sticky) {
			this._children = [];
			this._threads = [];
			this._onthread = function (thread) {
				return _this2._threads.push(thread);
			};
		}
	}

	_createClass(Action, [{
		key: "linkName",
		value: function linkName(value) {
			var suffix = arguments[1] === undefined ? ":action" : arguments[1];

			if (value.$name) value = value.$name;
			this.$name.toString = function () {
				return "" + value + suffix;
			};
			return this;
		}
	}, {
		key: "_initGeneratorProxy",
		value: function _initGeneratorProxy() {
			var _generatorProxy,
			    _this3 = this;

			var _value = undefined;
			var _next = function _next() {
				return _this3._generator.next(_value);
			};
			var _throw2 = function _throw2() {
				return _this3._generator["throw"](_value);
			};
			var _return2 = function _return2() {
				return _this3._generator["return"](_value);
			};
			this._generatorProxy = (_generatorProxy = {}, _defineProperty(_generatorProxy, Symbol.iterator, returnThis), _defineProperty(_generatorProxy, "next", function next(v) {
				_value = v;
				try {
					return co.catchThreads(_next, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _defineProperty(_generatorProxy, "throw", function _throw(v) {
				_value = v;
				try {
					return co.catchThreads(_throw2, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _defineProperty(_generatorProxy, "return", function _return(v) {
				_value = v;
				try {
					return co.catchThreads(_return2, _this3._onthread);
				} finally {
					_value = null;
				}
			}), _generatorProxy);
		}
	}, {
		key: "_loop",
		value: regeneratorRuntime.mark(function _loop() {
			var next, errorCatched, ret;
			return regeneratorRuntime.wrap(function _loop$(context$2$0) {
				var _this4 = this;

				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						context$2$0.next = 2;
						return updates.later;

					case 2:
						next = { then: function then(next) {
								_this4._onchange = next;
							} };

						co.global[actionKey] = this;
						errorCatched = false;

					case 5:
						context$2$0.prev = 5;

					case 6:
						if (errorCatched) {
							context$2$0.next = 48;
							break;
						}

						if (!this.isClosed()) {
							context$2$0.next = 9;
							break;
						}

						return context$2$0.abrupt("break", 66);

					case 9:
						this._begin();
						errorCatched = true;
						ret = undefined;

						if (!this._children) {
							context$2$0.next = 34;
							break;
						}

						ret = co.catchThreads(this._fun, this._onthread);

						if (!(!ret || ret[raValue])) {
							context$2$0.next = 17;
							break;
						}

						context$2$0.next = 32;
						break;

					case 17:
						if (!(ret.next && ret["throw"])) {
							context$2$0.next = 28;
							break;
						}

						if (!this._generatorProxy) this._initGeneratorProxy();
						this._generator = ret;
						context$2$0.prev = 20;
						return context$2$0.delegateYield(this._generatorProxy, "t0", 22);

					case 22:
						ret = context$2$0.t0;

					case 23:
						context$2$0.prev = 23;
						this._generator = null;return context$2$0.finish(23);

					case 26:
						context$2$0.next = 32;
						break;

					case 28:
						if (!ret.then) {
							context$2$0.next = 32;
							break;
						}

						context$2$0.next = 31;
						return ret;

					case 31:
						ret = context$2$0.sent;

					case 32:
						context$2$0.next = 47;
						break;

					case 34:
						ret = (0, this._fun)();

						if (!(!ret || ret[raValue])) {
							context$2$0.next = 38;
							break;
						}

						context$2$0.next = 47;
						break;

					case 38:
						if (!(ret.next && ret["throw"])) {
							context$2$0.next = 43;
							break;
						}

						return context$2$0.delegateYield(ret, "t1", 40);

					case 40:
						ret = context$2$0.t1;
						context$2$0.next = 47;
						break;

					case 43:
						if (!ret.then) {
							context$2$0.next = 47;
							break;
						}

						context$2$0.next = 46;
						return ret;

					case 46:
						ret = context$2$0.sent;

					case 47:
						if (this._dest) this._dest.assign(ret);

					case 48:
						errorCatched = false;

						if (!this.isClosed()) {
							context$2$0.next = 51;
							break;
						}

						return context$2$0.abrupt("break", 66);

					case 51:
						context$2$0.t2 = this._end();
						context$2$0.next = context$2$0.t2 === false ? 54 : context$2$0.t2 === true ? 55 : 57;
						break;

					case 54:
						return context$2$0.abrupt("break", 66);

					case 55:
						context$2$0.next = 57;
						return next
						// case null:
						/* immediate recalculation */
						;

					case 57:
						context$2$0.next = 6;
						break;

					case 59:
						context$2$0.next = 64;
						break;

					case 61:
						context$2$0.prev = 61;
						context$2$0.t3 = context$2$0["catch"](5);

						if (errorCatched) this._dest["throw"](context$2$0.t3);else rethrow(context$2$0.t3);

					case 64:
						context$2$0.next = 5;
						break;

					case 66:
						co.global[actionKey] = null;
						this._finalize();

					case 68:
					case "end":
						return context$2$0.stop();
				}
			}, _loop, this, [[5, 61], [20,, 23, 26]]);
		})
	}, {
		key: "isClosed",
		value: function isClosed() {
			return !this._cellSet;
		}
	}, {
		key: "close",
		value: function close() {
			var thread = this._thread;
			this._fire();
			this._finalize();
			thread && thread.kill();
		}
	}, {
		key: "_closeChildren",
		value: function _closeChildren() {
			var c = undefined;
			if (c = this._children) {
				for (var i = 0, l = c.length; i < l; ++i) {
					c[i].close();
				}c.length = 0;
			}
			if (c = this._threads) {
				for (var i = 0, l = c.length; i < l; ++i) {
					c[i].kill();
				}c.length = 0;
			}
		}
	}, {
		key: "_finalize",
		value: function _finalize() {
			this._unsubscribe();
			this._cellSet = null;
			this._cellArr = null;
			this._fun = null;
			this._dest = null;
			this._thread = null;
		}
	}, {
		key: "_begin",
		value: function _begin() {
			this._unsubscribe();
			++this._runCount;
			if (Action.maxCount < this._runCount) {
				Action.maxCount = this._runCount;
			}
		}
	}, {
		key: "_unsubscribe",
		value: function _unsubscribe() {
			this._onchange = null;
			var a = this._cellArr;
			if (a) {
				for (var i = 0; i < a.length; ++i) {
					var c = a[i];
					c.cell = null;
					c.value = null;
					c.action = null;
					c.read = false;
					c.written = false;
					c.pushedA = false
					// do not change c.pushedC here!!
					;
				}
				if (this._cellSetSize > 32 && a.length < this._cellSetSize / 4) {
					this._cellSet = {};
					this._cellSetSize = 0;
				}
				a.length = 0;
			}
			this._closeChildren();
		}
	}, {
		key: "_end",
		value: function _end() {
			var ret = false;
			var a = this._cellArr;
			for (var i = 0; i < a.length; ++i) {
				var c = a[i];
				if (c.written) c.action = null;else {
					if (!c.pushedC) {
						c.cell._actionsArr.push(c);
						c.pushedC = true;
					}
					if (!is(c.value, c.cell._value) || c.error != c.cell._error) return null;
					c.action = this;
					ret = true;
				}
				c.value = null;
				c.cell = null;
			}
			return ret;
		}
	}, {
		key: "_linkCell",
		value: function _linkCell(cell) {
			var c = this._cellSet[cell._id];
			if (c == null) {
				c = this._cellSet[cell._id] = {
					cell: null,
					value: null,
					error: null,
					action: null,
					read: false,
					written: false,
					pushedA: false,
					pushedC: false
				};
				++this._cellSetSize;
			}
			if (!c.pushedA) {
				this._cellArr.push(c);
				c.cell = cell;
				c.pushedA = true;
			}
			return c;
		}
	}, {
		key: "onread",
		value: function onread(cell) {
			var c = this._linkCell(cell);
			c.read = true;
			c.value = cell._value;
			c.error = cell._error;
		}
	}, {
		key: "onwritten",
		value: function onwritten(cell) {
			this._linkCell(cell).written = true;
		}
	}, {
		key: "_fire",
		value: function _fire() {
			if (this._onchange) updates.later(this._onchange);
			this._unsubscribe();
		}
	}]);

	return Action;
})();

Action.maxCount = 0;

var newReactive = function newReactive(getter, handlers, sticky, isValueEqual) {
	var _iteratorNormalCompletion5 = true;
	var _didIteratorError5 = false;
	var _iteratorError5 = undefined;

	try {
		for (var _iterator5 = handlers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
			var h = _step5.value;

			if (h != null && typeof h != "function") throw new Error("wrong parameters");
		}
	} catch (err) {
		_didIteratorError5 = true;
		_iteratorError5 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
				_iterator5["return"]();
			}
		} finally {
			if (_didIteratorError5) {
				throw _iteratorError5;
			}
		}
	}

	var cell = new Cell(sticky);
	if (getter !== undefined) cell._init(getter, false, true, isValueEqual);
	var _iteratorNormalCompletion6 = true;
	var _didIteratorError6 = false;
	var _iteratorError6 = undefined;

	try {
		for (var _iterator6 = handlers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
			var h = _step6.value;

			h && (h.length ? runSetter : runGetter)(cell, h, sticky);
		}
	} catch (err) {
		_didIteratorError6 = true;
		_iteratorError6 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
				_iterator6["return"]();
			}
		} finally {
			if (_didIteratorError6) {
				throw _iteratorError6;
			}
		}
	}

	return cell;
};

var ra = function ra() {
	var name = undefined,
	    fun = undefined,
	    sticky = undefined,
	    isValueEqual = undefined,
	    index = 0;
	if (typeof arguments[index] == "string") name = arguments[index++];
	if (typeof arguments[index] == "boolean") sticky = arguments[index++];
	fun = arguments[index++];
	if (typeof arguments[index] == "function") isValueEqual = arguments[index++];
	return newReactive(fun, [], sticky, isValueEqual);
};

function ArrayIsEqualTo(a) {
	return this == a || Array.isArray(a) && this.length == a.length && this.every(function (e, i) {
		return is(e, a[i]);
	});
}

function JsonIsEqualTo(a) {
	return this == a || JSON.stringify(this) == JSON.stringify(a);
}

exports = module.exports = ra;

exports.ra = ra;

exports.is = is;

exports.Array = function (array) {
	array.isEqualTo = ArrayIsEqualTo;
	return array;
};

exports.JSON = function (obj) {
	obj.isEqualTo = JsonIsEqualTo;
	return obj;
};

exports.Value = function (obj) {
	obj && obj.defineProperty(raValue, { value: true, configurable: true, enumerable: false, writable: false });
	return obj;
};

exports.clean = function (getter) {
	for (var _len3 = arguments.length, handers = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		handers[_key3 - 1] = arguments[_key3];
	}

	return newReactive(getter, handers, false);
};

exports.detach = function (fun) {
	var old = undefined;
	if (old = co.global[actionKey]) {
		co.global[actionKey] = null;
		try {
			return fun();
		} finally {
			co.global[actionKey] = old;
		}
	} else return fun();
};

exports.detached = function (fun) {
	return function () {
		var old = undefined;
		if (old = co.global[actionKey]) {
			co.global[actionKey] = null;
			try {
				return fun.apply(this, arguments);
			} finally {
				co.global[actionKey] = old;
			}
		} else return fun.apply(this, arguments);
	};
};

exports.on = function (emitter, event, getter) {
	var ret = ra();
	var handler = function handler(data) {
		return ret.assign(getter(data));
	};
	if (event == "string") emitter.on(event, handler);else {
		var _iteratorNormalCompletion7 = true;
		var _didIteratorError7 = false;
		var _iteratorError7 = undefined;

		try {
			for (var _iterator7 = event[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
				var _e = _step7.value;

				emitter.on(_e, handler);
			}
		} catch (err) {
			_didIteratorError7 = true;
			_iteratorError7 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
					_iterator7["return"]();
				}
			} finally {
				if (_didIteratorError7) {
					throw _iteratorError7;
				}
			}
		}
	}handler();
	return ret;
};

exports.Cell = Cell;
exports.ImmutableInterface = ImmutableInterface;
exports.AbstractGuard = AbstractGuard;
exports.Getter = Getter;
exports.Type = Type;
exports.importFrom = function (observable) {
	return Type(function (name) {
		return Getter(function () {
			return observable.live[name].valueOf();
		});
	});
};
exports.forceCalculations = function () {
	return updates.runAll();
};

function createActual() {
	var ret = ra();
	ret.assign(ret);
	ra(function () {
		var value = ret.valueOf();
		ra.detach(function () {
			return ret.assign(value);
		});
	});
	return ret;
}

var _DBChunk_Getter = UID();

var DBChunk = (function () {
	function DBChunk(getter, save, initial, previous) {
		_classCallCheck(this, DBChunk);

		this._previous = previous;
		this._getter = getter;
		this._save = save;
		var chunk = this._chunk = ra();
		chunk.assign(initial);
		var actual = this._actual = createActual();
		actual[_DBChunk_Getter] = ra(function () {
			return lu.applyDiff(getter.valueOf(), chunk.valueOf());
		});
		this._summary = ra(function () {
			return actual.valueOf()[_DBChunk_Getter].valueOf();
		});
	}

	_createClass(DBChunk, [{
		key: "createNext",
		value: function createNext() {
			var initial = arguments[0] === undefined ? null : arguments[0];
			return new DBChunk(this._summary, this._save, initial, this._actual);
		}
	}, {
		key: "valueOf",
		value: function valueOf() {
			return this.chunk;
		}
	}, {
		key: "assign",
		value: function assign(value) {
			this.chunk = value;
		}
	}, {
		key: "save",
		value: function save() {
			return this._save(this.chunk);
		}
	}, {
		key: "update",
		value: function update(diff) {
			return this._chunk.update(diff);
		}
	}, {
		key: "set",
		value: function set(name, value) {
			return this._chunk.set(name, value);
		}
	}, {
		key: "get",
		value: function get(name) {
			return this._chunk.get(name);
		}
	}, {
		key: "close",
		value: function close() {
			this._chunk.assign(null);
			if (this._previous) {
				this._actual.assign(this._previous);
				this._previous = null;
			}
		}
	}, {
		key: "before",
		get: function () {
			return this._getter.valueOf();
		}
	}, {
		key: "summary",
		get: function () {
			return this._summary.valueOf();
		}
	}, {
		key: "chunk",
		get: function () {
			return this._chunk.valueOf();
		},
		set: function (value) {
			this._chunk.assign(value);
		}
	}]);

	return DBChunk;
})();

var DB = (function () {
	function DB(getter, save) {
		var _this5 = this;

		_classCallCheck(this, DB);

		this._head = ra();
		this._head.assign(new DBChunk(getter, save));
		this._value = ra(function () {
			return _this5._head.valueOf().summary;
		});
	}

	_createClass(DB, [{
		key: "valueOf",
		value: function valueOf() {
			return this._value.valueOf();
		}
	}, {
		key: "createRecord",
		value: function createRecord() {
			// not detached
			var ret = this._head.valueOf().createNext();
			this._head.assign(ret);
			return ret;
		}
	}, {
		key: "data",
		get: function () {
			return this.valueOf();
		}
	}]);

	return DB;
})();

exports.db = function (getter, save) {
	return new DB(getter, save);
};

function toKey(obj) {
	if (!toKey.Keys) toKey.Keys = typeof WeakMap != "undefined" ? new WeakMap() : (function () {
		var id = "_to_key_" + UID();
		return {
			set: function set(obj, value) {
				Object.defineProperty(obj, id, {
					enumerable: false,
					configurable: true,
					writable: false,
					value: value
				});
			},
			get: function get(obj) {
				return obj[id];
			},
			has: function has(obj) {
				return Object.prototype.hasOwnProperty.call(obj, id);
			}
		};
	})();
	if (obj && (typeof obj == "object" || typeof obj == "function")) {
		if (!toKey.Keys.has(obj)) toKey.Keys.set(obj, UID());
		return toKey.Keys.get(obj);
	}
	return typeof obj + obj;
}

exports.makeKey = function (obj, key) {
	return ra(function () {
		return obj.get(key);
	});
};

exports.map = function (array, mapper) {
	if (!(array instanceof Cell)) throw new Error("ra.map: first argument must be a cell");
	var cache = Object.create(null);
	var ret = ra();
	ra.detach(function () {
		return ra(function () {
			// TODO праверыць, што пры array.close() гэта функцыя адпрацоўвае і прыбівае ўсе cache[].index і cache[].proc
			var a = array.valueOf();
			ra.detach(function () {
				var retarr = [];
				var index = 0;
				lodash.forEach(cache, function (c) {
					return c.abandoned = true;
				});
				a && a.forEach(function (value) {
					var key = toKey(value);
					var c = undefined;
					if (!(c = cache[key])) c = cache[key] = {
						value: value,
						index: ra()
					};
					c.abandoned = false;
					c.index.assign(index++);
					if (!c.proc) c.proc = ra(function () {
						return mapper(value, c.index);
					});
					retarr.push(c.proc);
				});
				lodash.keys(cache).forEach(function (key) {
					var c = cache[key];
					if (c.abandoned) {
						delete cache[key];
						c.index.close();
						c.proc.close();
					}
				});
				ret.assign(ra.Array(retarr));
			});
		});
	});
	return ret;
};

exports.keymap = function (array, mapper) {
	var mapped = ra.map(array, mapper);
	return ra(function () {
		return lodash.zipObject(array.valueOf(), mapped.valueOf());
	});
}

// exports.slice = ( dest, source, keysVar ) => {
// 	throw new Error( "message" )
// 	// TODO: optimization
// 	if ( !( dest instanceof Cell ) )
// 		dest = ra.clean( dest )
// 	let cacheHolder = ra.clean()
// 	ra.clean( () => {
// 		let keys = getValue( keysVar )
// 		if ( keys )
// 			keys.sort()
// 		updates.later( () => {
// 			let c = ra.clean()
// 			let s = c.defineProperty( `source` )
// 			let d = c.defineProperty( `dest` )
// 			keys && keys.forEach( k => {
// 				let sk = s.defineProperty( k )
// 				let dk = d.defineProperty( k )
// 				ra.clean( () => dk.assign( sk.valueOf() ) )
// 			} )
// 			let t = cacheHolder.valueOf()
// 			cacheHolder.assign( c )
// 			t && t.close()
// 		} )
// 	} )
// 	ra.clean( () => {
// 		let c = cacheHolder.valueOf()
// 		c && c.source && c.source.assign( source.valueOf() )
// 	} )
// 	ra.clean( () => {
// 		let c = cacheHolder.valueOf()
// 		dest.assign( c && c.dest && c.dest.valueOf() )
// 	} )
// 	return dest
// }
; // noop
// noop
// delete( obj ) { delete obj[ id ] },

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ra.js","/src")

},{"LOG":119,"_process":99,"buffer":94,"co":125,"later":133,"lodash":116,"uid":155}],137:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var maxIndex = 32768;

var Scheduler = (function () {
	function Scheduler(options) {
		_classCallCheck(this, Scheduler);

		this.setImmediate = options && options.setImmediate || process.nextTick;
		this.maxTicks = options && options.maxTicks || Infinity;
		this._procs = [];
		this._index = 0;
		this._scheduled = false;
		this._processing = false;
		this._handler = this._handler.bind(this);
		this.push = this.then.bind(this);
	}

	_createClass(Scheduler, [{
		key: "then",
		value: function then(proc) {
			this._procs.push(proc);
			if (!this._processing) this._schedule();
		}
	}, {
		key: "_schedule",
		value: function _schedule() {
			if (!this._scheduled) {
				this.setImmediate(this._handler);
				this._scheduled = true;
			}
		}
	}, {
		key: "_handler",
		value: function _handler() {
			this._scheduled = false;
			while (this._procs.length) {
				try {
					this._handler1();
				} catch (error) {
					setTimeout(function () {
						throw error;
					}, 0);
				}
			}
		}
	}, {
		key: "_handler1",
		value: function _handler1() {
			this._processing = true;
			try {
				var t = 0;
				while (this._index < this._procs.length && ++t <= this.maxTicks) {
					var proc = this._procs[this._index];
					this._procs[this._index] = null;
					++this._index;
					if (this._index >= maxIndex && this._index * 3 > this._procs.length) {
						this._procs.splice(0, this._index);
						this._index = 0;
					}
					proc();
				}
			} finally {
				this._processing = false;
				if (this._procs.length && this._index >= this._procs.length) this._procs.length = this._index = 0;
				if (this._index) this._schedule();
			}
		}
	}]);

	return Scheduler;
})();

module.exports = Scheduler;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/scheduler.js","/src")

},{"_process":99,"buffer":94}],138:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function rethrow(error) {
	setTimeout(function () {
		throw error;
	});
}

function safeEach(array, cb) {
	for (var i = 0, l = array.length; i < l; ++i) {
		try {
			cb(array.shift());
		} catch (error) {
			rethrow(error);
		}
	}
}

module.exports = (function () {
	function SparseQueue() {
		_classCallCheck(this, SparseQueue);

		this._cbs = [];
	}

	_createClass(SparseQueue, [{
		key: "then",
		value: function then(cb) {
			if (this._closed) process.nextTick(function () {
				return cb(undefined);
			});else this._cbs.push(cb);
		}
	}, {
		key: "isClosed",
		value: function isClosed() {
			return this._closed;
		}
	}, {
		key: "close",
		value: function close() {
			this._closed = true;
			safeEach(this._cbs, function (handler) {
				return handler(undefined);
			});
		}
	}, {
		key: "push",
		value: function push(data) {
			if (this._closed) throw new Error("queue is aready closed");
			safeEach(this._cbs, function (handler) {
				return handler(data);
			});
		}
	}, {
		key: "pushcb",
		value: function pushcb(data) {
			if (this._closed) throw new Error("queue is aready closed");
			safeEach(this._cbs, function (handler) {
				return handler(data());
			});
		}
	}]);

	return SparseQueue;
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/sparsequeue.js","/src")

},{"_process":99,"buffer":94}],139:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
by design:
Не ствараем ніякіх буфераў для падзей (накшталт touchmove ці mousemove) - падзеі ўсё адно альбо апрацоўваюцца хутка, альбо толькі займаюць месца ў буферах і затарможваюць апрацоўку, калі апрацоўшчыкі ўсё ж прачнуцца.
*/

"use strict";

var sparsequeue = require("sparsequeue");

var tracks = Object.create(null);

setInterval(function () {
	for (var identifier in tracks) {
		var track = tracks[identifier];
		if (track.abandoned) {} else track.abandoned = true;
	}
}, 7000);

function pushEvent(track, event) {
	track.points.push(event);
	if (track.preventDefault && event.preventDefault) event.preventDefault();
}

function stopEvents(track) {
	track.points.close();
}

function startTrack(identifier, event) {
	var points = new sparsequeue();
	var detail = {
		cancelEvent: null,
		next: points
	};
	var track = {
		abandoned: false,
		closed: false,
		detail: detail,
		points: points,
		preventDefault: false
	};
	tracks[identifier] = track;
	var ret = new CustomEvent("touch", { detail: detail, bubbles: true, cancelable: true });
	ret.pageX = event.pageX;
	ret.pageY = event.pageY;
	ret.clientX = event.clientX;
	ret.clientY = event.clientY;
	ret.screenX = event.screenX;
	ret.screenY = event.screenY;
	ret.preventDefault = function () {
		event.preventDefault();
		track.preventDefault = true;
	};
	event.target.dispatchEvent(ret);
	pushEvent(track, event);
}

function onExistingTrack(fun) {
	return function (identifier, arg) {
		var track = tracks[identifier];
		if (!track) return;
		track.abandoned = false;
		fun(track, arg);
	};
}

var continueTrack = onExistingTrack(pushEvent);

var stopTrack = onExistingTrack(function (track, event) {
	pushEvent(track, event);
	stopEvents(track);
});

var removeTrack = onExistingTrack(stopEvents);

var cancelTrack = onExistingTrack(function (track, event) {
	track.detail.cancelEvent = event;
	stopEvents(track);
});

function forTouches(event, cb) {
	for (var i = 0; i < event.changedTouches.length; ++i) {
		var touch = event.changedTouches.item(i);
		cb(touch.identifier, {
			type: "touchmove",
			identifier: touch.identifier,
			target: touch.target,
			screenX: touch.screenX,
			screenY: touch.screenY,
			clientX: touch.clientX,
			clientY: touch.clientY,
			pageX: touch.pageX,
			pageY: touch.pageY,
			radiusX: touch.radiusX,
			radiusY: touch.radiusY,
			rotationAngle: touch.rotationAngle,
			force: touch.force,
			timeStamp: event.timeStamp,
			preventDefault: event.preventDefault.bind(event)
		});
	}
	var current = Object.create(null);
	for (var i = 0; i < event.touches.length; ++i) {
		current[event.touches.item(i).identifier] = true;
	}for (var identifier in tracks) {
		if (!(identifier in current)) removeTrack(identifier);else tracks[identifier].abandoned = false;
	}
}

var container = document;

container.addEventListener("mousedown", function (event) {
	if (event.button == 0) startTrack("mouse", event);else if (!(event.buttons & 1)) removeTrack("mouse");
});

container.addEventListener("mousemove", function (event) {
	if (event.buttons & 1) continueTrack("mouse", event);else removeTrack("mouse");
});

container.addEventListener("mouseup", function (event) {
	if (event.button == 0) stopTrack("mouse", event);else if (!(event.buttons & 1)) removeTrack("mouse");
});

container.addEventListener("touchstart", function (event) {
	forTouches(event, startTrack);
});

container.addEventListener("touchmove", function (event) {
	forTouches(event, continueTrack);
});

container.addEventListener("touchend", function (event) {
	forTouches(event, stopTrack);
});

container.addEventListener("touchcancel", function (event) {
	forTouches(event, cancelTrack);
});

// if ( track.handler.return )
// 	track.handler.return()
// delete tracks[ identifier ]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/track.js","/src")

},{"_process":99,"buffer":94,"sparsequeue":138}],140:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Command = app.load(require("ui/Command"));
	return function (attr) {
		return React.createElement(Command, {
			message: "commandAddExistingItem",
			onclick: function () {
				app.dialog = "SearchItems";
				app.searchAction = function (itemId) {
					app.linkItem(app.activeDeviceId, itemId);
					app.dialog = "";
				};
				app.searchFilter = null;
				if (app.deviceType == "group") app.searchFilter = function (itemId) {
					var device = app.getDevice(itemId);
					return device && device.type == "single";
				};
			},
			_: attr
		});
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AddExistingItem.js","/src/ui")

},{"_process":99,"buffer":94,"ui/Command":146}],141:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Command = app.load(require("ui/Command"));
	var AddExistingItem = app.load(require("ui/AddExistingItem"));
	return React.createElement(
		"div",
		null,
		React.createElement(AddExistingItem, null),
		React.createElement(Command, {
			message: "commandCreateNewGroup",
			onclick: function () {
				app.addGroup(app.activeDeviceId);
			}
		}),
		React.createElement(Command, {
			message: "commandAddNewDevice",
			onclick: function () {
				return app.addDevice(app.activeDeviceId);
			}
		}),
		React.createElement(Command, {
			message: "commandAddPlace",
			onclick: function () {
				app.addPlace(app.activeDeviceId);
			}
		})
	);
};

// app.dialog = `AddPlace`

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AddMenu.js","/src/ui")

},{"_process":99,"buffer":94,"ui/AddExistingItem":140,"ui/Command":146}],142:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// let httpClient = require( `httpClient` )
// let cookies = require( `cookies` )

"use strict";

module.exports = function (_ref) {
	var appid = _ref.appid;
	var IconTemplates = _ref.IconTemplates;

	var _require = require("app")(appid);

	var app = _require.app;
	var local = _require.local;

	app.pageStarting = true;

	window._app = app;
	window._local = local;
	window._devdb = require("devdb");

	if (navigator.standalone) {} else {
		ra(function () {
			if (local.activeDeviceId && local.activeDeviceId.valueOf()) {
				var title = "TITLE_" + local.activeDeviceId;
				var icon = "ICON_" + local.activeDeviceId;
				screenTitle.setAttribute("content", title);
				if (local.activeDeviceId && local.activeDeviceId != "main") history.replaceState(null, title, "?appicon=" + icon);else history.replaceState(null, title, "?");
			}
		});
	}

	var MainScreen = app.load(require("ui/MainScreen"));
	var StartupScreen = app.load(require("ui/StartupScreen"));
	var LoadingScreen = function LoadingScreen() {
		return React.createElement("div", { "class": "loadingScreen" });
	};

	var application = React.createElement(
		"div",
		{ "class": function () {
				return "\n\t\tapplication\n\t\t" + (app.pageStarting ? "pageStarting" : "pageRunning") + "\n\t\t" + (app.initialLoading ? "JSONloading" : "JSONloaded") + "\n\t\t" + (app.initialized ? "alreadyRun" : "firstRun") + "\n\t\t" + (app.connectedToServer ? "appConnected" : "appDisconnected") + "\n\t\t" + "" + "\n\t\t" + (app.templates ? "templatesLoaded" : "templatesLoading") + "\n\t\t" + (app.dialog && "dialog" + app.dialog) + "\n\t\t" + (app.dialog ? "dialogIsPresent" : "dialogIsAbsent") + "\n\t\tapp_labels_" + !!local.labels + "\n\t\tapp_editing_" + !!app.editing + "\n\t";
			} },
		React.createElement(MainScreen, null),
		React.createElement(StartupScreen, null),
		React.createElement(LoadingScreen, null)
	);

	app.icons = IconTemplates.reduce(function (icons, template) {
		icons[template.dataset.name] = template;
		return icons;
	}, Object.create(null));

	var Button = app.load(require("ui/Button"));

	var CloseError = function CloseError(attr, text) {
		return React.createElement(
			"p",
			{
				ontouch: function () {
					var error = app.error;
					app.dialog = "";
					app.error = null;
					attr.onclick && attr.onclick(error);
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			text
		);
	};

	var CloseDialog = function CloseDialog(attr, text) {
		return React.createElement(
			"p",
			{
				ontouch: function () {
					app.dialog = "";
					attr.onclick && attr.onclick();
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			text
		);
	};

	// dialogs
	var dialogTemplates = {

		ServiceDialog: function ServiceDialog() {
			return app.load(require("ui/ServiceDialog"));
		},
		ContextMenu: function ContextMenu() {
			return app.load(require("ui/ContextMenu"));
		},
		AddMenu: function AddMenu() {
			return app.load(require("ui/AddMenu"));
		},
		SearchItems: function SearchItems() {
			return app.load(require("ui/SearchItems"));
		},
		AskNewName: function AskNewName() {
			return app.load(require("ui/AskNewName"));
		},
		AskToLinkDevice: function AskToLinkDevice() {
			return app.load(require("ui/AskToLinkDevice"));
		},

		AskIfDeviceHasBeenLinked: function AskIfDeviceHasBeenLinked() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Устройство было успешно привязано?"
				),
				React.createElement(
					Button,
					{ onclick: "StopDeviceNotification" },
					"да"
				),
				React.createElement(
					Button,
					{ onclick: "AskToLinkDevice" },
					"нет"
				)
			);
		},

		StopDeviceNotification: function StopDeviceNotification() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Пожалуйста,",
					React.createElement("br", null),
					"переведите устройство в рабочий режим."
				),
				React.createElement(
					Button,
					null,
					"Закрыть"
				)
			);
		},

		ErrorNoCarrier: function ErrorNoCarrier() {
			return React.createElement(
				"div",
				{ "class": "errorDialog" },
				React.createElement(
					"p",
					null,
					"Ошибка"
				),
				React.createElement(
					"p",
					null,
					"Произошла ошибка при попытке связаться с модемом."
				),
				React.createElement(
					Button,
					null,
					"Закрыть"
				)
			);
		},

		ErrorUnlinkingDevice: function ErrorUnlinkingDevice() {
			return React.createElement(
				"div",
				{ "class": "errorDialog" },
				React.createElement(
					"p",
					null,
					"Ошибка"
				),
				React.createElement(
					"p",
					null,
					"Не удалось связаться с устройством и отвязать его."
				),
				React.createElement(
					"p",
					null,
					"Что следует сделать?"
				),
				React.createElement(
					"ul",
					null,
					React.createElement(
						CloseError,
						{ onclick: function (error) {
								return app.purgeItem(error.data.deviceId);
							}
						},
						React.createElement(
							"li",
							null,
							"Попытаться отвязать устройство ещё раз"
						)
					),
					React.createElement(
						CloseError,
						null,
						React.createElement(
							"li",
							null,
							"Отменить удаление"
						)
					),
					React.createElement(
						CloseError,
						{ onclick: function (error) {
								return app.purgeItem(error.data.deviceId, true);
							}
						},
						React.createElement(
							"li",
							null,
							"Забыть информацию об устройстве"
						)
					)
				)
			);
		},

		DeleteDevice: function DeleteDevice() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					({
						place: React.createElement(
							"span",
							null,
							"Помещение (место) \"",
							app.caption,
							"\" будет удалено из программы."
						),
						single: React.createElement(
							"span",
							null,
							"Устройство \"",
							app.caption,
							"\" будет удалено из программы."
						),
						group: React.createElement(
							"span",
							null,
							"Группа \"",
							app.caption,
							"\" будет удалена из программы."
						)
					})[app.deviceType]
				),
				React.createElement(
					"ul",
					null,
					React.createElement(
						CloseDialog,
						{ "class": "dangerousAction", onclick: function () {
								return app.purgeItem(app.activeDeviceId);
							}
						},
						React.createElement(
							"li",
							null,
							"Удалить"
						)
					),
					React.createElement(
						CloseDialog,
						null,
						React.createElement(
							"li",
							null,
							"Не удалять"
						)
					)
				)
			);
		},

		StateWait: function StateWait() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Подождите..."
				)
			);
		},

		AskToReset: function AskToReset() {
			return React.createElement(
				"div",
				null,
				React.createElement(
					"p",
					null,
					"Память контроллера будет очищена,",
					React.createElement("br", null),
					"но память устройств очищаться не будет."
				),
				React.createElement(
					Button,
					{ "class": "dangerousAction", onclick: app.reset },
					"Очистить",
					React.createElement("br", null),
					"память"
				)
			);
		}

	};

	ra(function () {
		var dialogName = app.dialog;
		if (!dialogName) return;

		if (!Object.prototype.hasOwnProperty.call(dialogTemplates, dialogName)) {
			alert("Error: Could not find dialog named\n\"" + dialogName + "\"");
			ra.detach(function () {
				return app.dialog = "";
			});
			return;
		}
		var Template = dialogTemplates[dialogName];
		if (!Template) return;
		dialogTemplates[dialogName] = null;

		var dialog = Template();
		dialog.classList.add(dialogName);
		dialog.classList.add("modalDialog");
		ra(Object.defineProperties({}, {
			isActive: {
				get: function () {
					return dialogName == app.dialog;
				},
				configurable: true,
				enumerable: true
			},
			updateClass: {
				get: function () {
					var event = undefined;
					if (this.isActive) {
						event = "dialogshow";
						dialog.classList.add("dialogShown");
						dialog.classList.remove("dialogHidden");
						var input = dialog.querySelector("*[ autofocus ]");
						if (input) app.focus(input);
					} else {
						event = "dialoghide";
						dialog.classList.remove("dialogShown");
						dialog.classList.add("dialogHidden");
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
							for (var _iterator = dialog.querySelectorAll("*:focus")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var elem = _step.value;

								elem.blur();
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator["return"]) {
									_iterator["return"]();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}

						dialog.blur();
					}
					dialog.dispatchEvent(new CustomEvent(event, { detail: null }));
				},
				configurable: true,
				enumerable: true
			}
		}));
		application.appendChild(dialog);
	});

	setTimeout(function () {
		return app.pageStarting = false;
	}, 1);

	return application;
};

// cookies.setItem( `standalone`, 1, Infinity ) -- усё адно не пасьпяваем паставіць куку перад першым зваротам да сервера
// httpClient.post( `/cookie?appicon=${ icon }`, `` )
// cookies.setItem( `appicon`, icon, Infinity )
// LOG( local.activeDeviceId.blue )
/* app.credentials == null ? `showLogin` : `hideLogin` */ // AddPlace,
// AddDevice,

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Application.js","/src/ui")

},{"_process":99,"app":123,"buffer":94,"devdb":127,"ui/AddMenu":141,"ui/AskNewName":143,"ui/AskToLinkDevice":144,"ui/Button":145,"ui/ContextMenu":147,"ui/MainScreen":149,"ui/SearchItems":152,"ui/ServiceDialog":153,"ui/StartupScreen":154}],143:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");

module.exports = function (app) {
	var $ = {};
	return React.createElement(
		"div",
		{ ondialogshow: function () {
				$.string.value = app.getMessage(app.getDevice(app.activeDeviceId));
				$.string.setSelectionRange(0, $.string.value.length);
			} },
		React.createElement(
			"p",
			null,
			"Название:"
		),
		React.createElement(
			"form",
			{ onsubmit: function (event) {
					event && event.preventDefault();
					var name = $.string.value.trim();
					app.dialog = "";
					if (name) app.renameItem(app.activeDeviceId, name);
				} },
			$.string = React.createElement("textarea", { name: "string", cols: "35", rows: "2", autofocus: "autofocus" }),
			React.createElement(
				"p",
				null,
				React.createElement(
					"a",
					{ "class": "button", href: "javascript:void(0)", target: "_self", ontouch: htmlutils.Submit },
					"Закрыть"
				)
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AskNewName.js","/src/ui")

},{"_process":99,"buffer":94,"htmlutils":130}],144:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	var Button = app.load(require("ui/Button"));
	return React.createElement(
		"div",
		null,
		React.createElement(
			"p",
			null,
			"Пожалуйста,",
			React.createElement("br", null),
			"переведите устройство в режим",
			React.createElement("br", null),
			"программирования и нажмите"
		),
		React.createElement(
			Button,
			{ onclick: function () {
					var placeId = app.linkingPlaceId || app.activeDeviceId;
					app.dialog = "StateWait";
					co.go(regeneratorRuntime.mark(function callee$2$0() {
						return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
							while (1) switch (context$3$0.prev = context$3$0.next) {
								case 0:
									context$3$0.next = 2;
									return app.command(placeId, "Link");

								case 2:
									app.dialog = "AskIfDeviceHasBeenLinked";
									app.linkingPlaceId = placeId;

								case 4:
								case "end":
									return context$3$0.stop();
							}
						}, callee$2$0, this);
					}))["catch"](function (error) {
						console.log(error);
						app.dialog = "ErrorNoCarrier";
					});
				}
			},
			"здесь"
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/AskToLinkDevice.js","/src/ui")

},{"_process":99,"buffer":94,"ui/Button":145}],145:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function (attr, content) {
		return React.createElement(
			"a",
			{ "class": "button", href: "javascript:void(0)", target: "_self", ontouch: function (event) {
					event.preventDefault();
					if (typeof attr.onclick == "string") app.dialog = attr.onclick;else {
						app.dialog = "";
						attr.onclick && attr.onclick();
					}
				},
				_: Object.assign({}, attr, { onclick: null })
			},
			content
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Button.js","/src/ui")

},{"_process":99,"buffer":94}],146:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function (_ref) {
		var onclick = _ref.onclick;
		var url = _ref.url;
		var visible = _ref.visible;
		var enabled = _ref.enabled;
		var message = _ref.message;

		var content = app.message(message);
		var isEnabled = function isEnabled() {
			return (url || onclick) && (!enabled || enabled());
		};
		if (typeof visible == "string") {
			(function () {
				var deviceType = visible;
				visible = function () {
					return app.deviceType == deviceType;
				};
			})();
		}
		var className = function className() {
			return "command " + message + " " + (isEnabled() ? "enabled" : "disabled") + " " + (visible == null || visible() ? "itemVisible" : "itemHidden");
		};
		if (url && !onclick) return React.createElement(
			"a",
			{ "class": className, href: url, rel: "external", target: "_blank" },
			content
		);else return React.createElement(
			"a",
			{ "class": className, href: "javascript:void(0)", target: "_self", ontouch: function (event) {
					event.preventDefault();
					if (onclick && isEnabled()) {
						if (typeof onclick == "string") app.dialog = onclick;else {
							app.dialog = "";
							onclick();
						}
					}
				} },
			content
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Command.js","/src/ui")

},{"_process":99,"buffer":94}],147:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app, local) {
	var Command = app.load(require("ui/Command"));
	var AddExistingItem = app.load(require("ui/AddExistingItem"));
	return React.createElement(
		"div",
		null,
		React.createElement(Command, {
			message: "commandSearchDevices",
			onclick: "SearchItems"
		}),
		React.createElement(Command, {
			message: "commandToFavourites",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.linkActiveToFavourites();
				app.notification("Добавлено в избранное");
			}
		}),
		React.createElement(Command, {
			message: "commandLinkDevice",
			visible: "device",
			onclick: "AskToLinkDevice"
		}),
		React.createElement(Command, {
			message: "commandAdd",
			visible: function () {
				return !app.editing && app.deviceType == "place";
			},
			onclick: "AddMenu"
		}),
		React.createElement(AddExistingItem, {
			message: "commandAdd",
			visible: function () {
				return !app.editing && app.deviceType == "group";
			}
		}),
		React.createElement(Command, {
			message: "commandMoveIcons",
			visible: function () {
				return !app.editing && app.deviceType != "single";
			},
			onclick: function () {
				return app.editing = true;
			}
		}),
		React.createElement(Command, {
			message: "commandRenameItem",
			visible: function () {
				return !app.editing;
			},
			onclick: "AskNewName"
		}),
		React.createElement(Command, {
			message: "commandPurgeItem",
			visible: function () {
				return !app.editing && app.activeDeviceId != app.main;
			},
			onclick: function () {
				app.dialog = "DeleteDevice";
			}
		}),
		React.createElement(Command, {
			message: "commandShowLabels",
			visible: function () {
				return !local.labels && app.activeDeviceId == app.main;
			},
			onclick: function () {
				return local.labels = true;
			}
		}),
		React.createElement(Command, {
			message: "commandHideLabels",
			visible: function () {
				return local.labels && app.activeDeviceId == app.main;
			},
			onclick: function () {
				return local.labels = false;
			}
		}),
		React.createElement(Command, {
			message: "commandResetToFactorySettings",
			visible: function () {
				return app.activeDeviceId == app.main;
			},
			enabled: function () {
				return window.location.hostname != "test.sh.neroelectronics.by";
			},
			onclick: "AskToReset"
		})
	);
};
// app.purgeItem( app.activeDeviceId )

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/ContextMenu.js","/src/ui")

},{"_process":99,"buffer":94,"ui/AddExistingItem":140,"ui/Command":146}],148:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

var lodash = require("lodash");
var htmlutils = require("htmlutils");

module.exports = function (app, local) {
	return function (_ref) {
		var placeId = _ref.placeId;
		var iconId = _ref.iconId;
		var iconDescr = _ref.iconDescr;
		var position = _ref.position;

		// TODO: refactoring: move to more JSX (?)
		// TODO: onTap, onPress, onClick handlers must remove themself when thread is being killed
		var icon = undefined,
		    off = undefined,
		    on = undefined,
		    absent = undefined,
		    image = undefined;
		var isMouse = false;

		var placeRect = htmlutils.tickCache(function () {
			var x = icon.parentNode;
			var r = undefined;
			while ((r = x.getBoundingClientRect(), !r.width || !r.height)) x = x.parentNode;
			return r;
		});

		var relPoint = function relPoint(p) {
			var r = placeRect();
			return {
				x: (p.x - r.left) / r.width * 100,
				y: (p.y - r.top) / r.height * 100
			};
		};

		var getPoint = function getPoint(data) {
			return relPoint({ x: data.pageX, y: data.pageY });
		};

		var getLeftTop = function getLeftTop(data) {
			var p = data.getBoundingClientRect();
			return relPoint({ x: p.left, y: p.top });
		};

		// let iconsCount = () => {
		// 	let place = app.getDevice( placeId )
		// 	return lodash.keys( place && place.content ).length
		// }

		var imageHeight = htmlutils.tickCache(function () {
			if (!isMouse) return icon.getBoundingClientRect().height;
			if (opts.iconData) {
				if (opts.iconData.deviceImageGetHeight) {
					var r = opts.iconData.deviceImageGetHeight();
					if (r) return r;
				}
				var h = opts.iconData.getElementsByClassName("device_image_height")[0];
				if (h != null && h.getBoundingClientRect) {
					var r = h.getBoundingClientRect().height;
					if (r) return r;
				}
				for (var i = 0; i < opts.iconData.childNodes.length; ++i) {
					var r = opts.iconData.childNodes.item(i);
					if (r.getBoundingClientRect) {
						r = r.getBoundingClientRect().height;
						if (r) return r;
					}
				}
			}
			return image.getBoundingClientRect().height;
		});

		var opts = ra(Object.defineProperties({
			iconData: null,

			iconCommand: function iconCommand(cmd, data) {
				return app.iconCommand(iconDescr, iconId, cmd, data);
			},

			isDimmering: false,
			moving: false,
			moved: false,
			x: null,
			y: null,

			state: 0,
			onning: false,
			offing: false,
			final: true,
			errorneous: false,

			setOpacity: function setOpacity(node, opacity) {
				if (opacity == null) {
					delete node.style.opacity;
				} else {
					node.style.opacity = opacity;
				}
			}
		}, {
			iconName: {
				get: function () {
					return iconDescr && iconDescr.valueOf() && iconDescr.valueOf().icon || null;
				},
				configurable: true,
				enumerable: true
			},
			iconTemplate: {
				get: function () {
					return this.iconName && app.icons && Object.prototype.hasOwnProperty.call(app.icons, this.iconName) && app.icons[this.iconName] || null;
				},
				configurable: true,
				enumerable: true
			},
			updateIconDataState: {
				get: function () {
					var data = this.iconData;
					if (data && data.deviceSetState) data.deviceSetState(this.state);
				},
				configurable: true,
				enumerable: true
			},
			dimmering: {
				get: function () {
					var i = iconDescr == null ? null : iconDescr.valueOf();
					var id = i == null ? null : i.dimmering == null ? null : !!i.dimmering;
					if (id != null) return id;
					if (i != null && i.type === "place") return false;
					return true;
				},
				configurable: true,
				enumerable: true
			},
			image_on: {
				get: function () {
					var i = iconDescr && iconDescr.valueOf();
					var file = "" || i && i.image_on || i && i.image;
					return file && "/images/" + file;
				},
				configurable: true,
				enumerable: true
			},
			update_image_on: {
				get: function () {
					if (opts.image_on) on.src = opts.image_on;
				},
				configurable: true,
				enumerable: true
			},
			image_off: {
				get: function () {
					var i = iconDescr && iconDescr.valueOf();
					var file = "" || i && i.image_off || i && i.image;
					return file && "/images/" + file;
				},
				configurable: true,
				enumerable: true
			},
			update_image_off: {
				get: function () {
					if (opts.image_off) off.src = opts.image_off;
				},
				configurable: true,
				enumerable: true
			},
			present: {
				get: function () {
					return !!(iconDescr.get("content") || iconDescr.get("group"));
				},
				configurable: true,
				enumerable: true
			},
			updateState: {
				get: function () {
					var d = iconDescr && iconDescr.valueOf();
					if (!d) return 0;
					if (d.newstate_timestamp && (!d.state_timestamp || d.newstate_timestamp > d.state_timestamp)) {
						var fonning = d.newstate >= d.state;
						this.onning = fonning;
						this.offing = !fonning;
						this.final = false;
						this.state = d.newstate;
					} else {
						this.onning = false;
						this.offing = false;
						this.final = true;
						this.state = d.state;
					}
					this.errorneous = !!d.errorneous;
				},
				configurable: true,
				enumerable: true
			},
			updateOpacity: {
				get: function () {
					if (this.iconTemplate) {
						on.style.visibility = "hidden";
						off.style.visibility = "hidden";
						absent.style.visibility = "hidden";
					} else if (!this.present) {
						this.setOpacity(on, 0);
						this.setOpacity(off, 0);
						this.setOpacity(absent, 0.7);
					} else {
						this.setOpacity(absent, 0);
						if (this.dimmering) {
							this.setOpacity(on, this.state);
							this.setOpacity(off, (1 - this.state) * 0.333);
						} else {
							this.setOpacity(on, +!!this.state);
							this.setOpacity(off, +!this.state);
						}
					}
				},
				configurable: true,
				enumerable: true
			}
		}));

		var MOVE_PAGE_DIST = 0.1;
		var MOVE_SIDE_DIST = 0.25;

		function compareIndex(a, b) {
			return a.index - b.index;
		}

		var move = regeneratorRuntime.mark(function move(start, next) {
			var changes, currentPosition, done, hover, _ret;

			return regeneratorRuntime.wrap(function move$(context$3$0) {
				var _this = this;

				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						if (opts.moving) opts.moving.kill("restarting by another finger");

						changes = app.localDevices.createRecord();
						currentPosition = position.valueOf();
						done = false;
						hover = ra(Object.defineProperties({
							savedId: null,
							cachedId: null,
							id: null,
							position: null,

							updateApp: function updateApp(value) {
								if (this.savedId) app.hover = lu.applyDiff(app.hover, _defineProperty({}, this.savedId, _defineProperty({}, placeId, _defineProperty({}, iconId, value))));
							}

						}, {
							updateCache: { // TODO: insert debounce mechanism just into ra

								get: function () {
									// debounce id changing
									this.cachedId = this.id;
								},
								configurable: true,
								enumerable: true
							},
							saveId: {
								get: function () {
									this.updateApp(null);
									this.savedId = this.cachedId;
									this.updateApp(true);
								},
								configurable: true,
								enumerable: true
							}
						}));
						context$3$0.prev = 5;
						return context$3$0.delegateYield(regeneratorRuntime.mark(function callee$3$0() {
							var self, p, r, fingerShift, _loop, pt, _ret2;

							return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
								while (1) switch (context$4$0.prev = context$4$0.next) {
									case 0:
										self = co.current;

										ra(function () {
											return !done && !app.editing && self.kill();
										});

										p = getPoint(start);
										r = getLeftTop(icon);

										opts.moving = co.current;
										opts.moved = false;
										fingerShift = {
											x: r.x - p.x,
											y: r.y - p.y
										};

										opts.x = r.x;
										opts.y = r.y;

										_loop = function (pt) {
											var finger = getPoint(pt);
											var corner = {
												x: finger.x + fingerShift.x,
												y: finger.y + fingerShift.y
											};
											if (opts.x != corner.x || opts.y != corner.y) opts.moved = true;
											opts.x = corner.x;
											opts.y = corner.y;

											var pageSize = {
												x: app.pageWidth,
												y: app.pageHeight
											};
											var cellSize = {
												x: 100 / pageSize.x,
												y: 100 / pageSize.y
											};
											var index = {
												x: Math.min(pageSize.x - 1, Math.max(0, Math.floor(finger.x / cellSize.x))),
												y: Math.min(pageSize.y - 1, Math.max(0, Math.floor(finger.y / cellSize.y)))
											};
											var inCell = {
												x: finger.x / cellSize.x - index.x,
												y: finger.y / cellSize.y - index.y
											};

											var placePosition = index.x + index.y * pageSize.x + (local.placesPages[placeId] || 0) * pageSize.x * pageSize.y;

											var isInCenter = inCell.x > MOVE_SIDE_DIST && inCell.x < 1 - MOVE_SIDE_DIST && inCell.y > MOVE_SIDE_DIST && inCell.y < 1 - MOVE_SIDE_DIST;

											if (!isInCenter || hover.position != placePosition) hover.id = null;
											hover.position = placePosition;

											if (pt.type != "stop") return "continue";

											hover.id = null;

											if (inCell > 1 - MOVE_PAGE_DIST && cellSize.x == pageSize.x - 1) {
												// TODO: scroll page right
												return "continue";
											}
											if (inCell < MOVE_PAGE_DIST && cellSize.x == pageSize.x - 1) {
												// TODO: scroll page left
												return "continue";
											}

											var place = lu.get(changes, "summary", "content", placeId, "content");
											if (!place || !place[iconId]) return {
													v: {
														v: undefined
													}
												};
											var keys = lodash.keys(place).map(function (key) {
												return { key: key, index: place[key].index };
											}).sort(compareIndex);

											var newIndex = undefined;

											if (placePosition < 0) {
												if (currentPosition <= 0) return "continue";
												newIndex = keys[0].index - 1;
											} else if (placePosition > keys.length - 1) {
												if (currentPosition >= keys.length - 1) return "continue";
												newIndex = keys[keys.length - 1].index + 1;
											} else {
												if (currentPosition == placePosition) return "continue";
												if (isInCenter) {
													// TODO
													hover.id = keys[placePosition].key;
													var srcType = iconDescr && iconDescr.valueOf() && iconDescr.valueOf().type;
													var dstDevice = app.getDevice(hover.id);
													var dstType = dstDevice && dstDevice.type;
													if (dstType == "place") return "continue";
													if (dstType == "group" && srcType == "single") return "continue";
													// TODO: allow dstType == `single` && srcType == `single`
													hover.id = null;
												}
												if (inCell.x > 0.5) {
													if (currentPosition == placePosition + 1) return "continue";
													if (index.x == pageSize.x - 1 && currentPosition > placePosition) return "continue";
													if (placePosition >= keys.length - 1) newIndex = keys[placePosition].index + 1;else newIndex = (keys[placePosition].index + keys[placePosition + 1].index) / 2;
												} else {
													if (currentPosition == placePosition - 1) return "continue";
													if (index.x == 0 && currentPosition < placePosition) return "continue";
													if (placePosition <= 0) newIndex = keys[placePosition].index - 1;else newIndex = (keys[placePosition].index + keys[placePosition - 1].index) / 2;
												}
											}

											var newPosition = keys.map(function (k) {
												return k.key != iconId ? k : { key: k.key, index: newIndex };
											}).sort(compareIndex).findIndex(function (k) {
												return k.key == iconId;
											});

											if (currentPosition == newPosition) return "continue";

											currentPosition = newPosition;
											changes.assign({ content: _defineProperty({}, placeId, { content: _defineProperty({}, iconId, { index: newIndex }) }) });
										};

										pt = undefined;

									case 11:
										context$4$0.next = 13;
										return next;

									case 13:
										if (!(pt = context$4$0.sent)) {
											context$4$0.next = 23;
											break;
										}

										_ret2 = _loop(pt);
										context$4$0.t0 = _ret2;
										context$4$0.next = context$4$0.t0 === "continue" ? 18 : 19;
										break;

									case 18:
										return context$4$0.abrupt("continue", 21);

									case 19:
										if (!(typeof _ret2 === "object")) {
											context$4$0.next = 21;
											break;
										}

										return context$4$0.abrupt("return", _ret2.v);

									case 21:
										context$4$0.next = 11;
										break;

									case 23:
										done = true;

										if (!hover.id) {
											context$4$0.next = 29;
											break;
										}

										changes.close();
										// TODO
										// let newPlace = app.getDevice( hover.id )
										// if ( newPlace && newPlace.type == `single` ) {
										// 	app.linkingDevices = [ hover.id, iconId ]
										// 	app.dialog = `CreatePlaceOrGroup`
										// }
										// else
										app.insertInto(hover.id, iconId, placeId);
										context$4$0.next = 32;
										break;

									case 29:
										context$4$0.next = 31;
										return co.sleep();

									case 31:
										lu.when(changes.save(), function () {
											return changes.close();
										});

									case 32:
									case "end":
										return context$4$0.stop();
								}
							}, callee$3$0, _this);
						})(), "t0", 7);

					case 7:
						_ret = context$3$0.t0;

						if (!(typeof _ret === "object")) {
							context$3$0.next = 10;
							break;
						}

						return context$3$0.abrupt("return", _ret.v);

					case 10:
						context$3$0.prev = 10;

						hover.id = null;
						if (!done) {
							done = true;
							changes.close();
						}
						if (opts.moving == co.current) {
							opts.moving = null;
							opts.moved = false;
						}
						return context$3$0.finish(10);

					case 15:
					case "end":
						return context$3$0.stop();
				}
			}, move, this, [[5,, 10, 15]]);
		});

		var dimm = regeneratorRuntime.mark(function dimm(next) {
			var changes, state, initialDimmeringState, pt, delta;
			return regeneratorRuntime.wrap(function dimm$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						changes = app.localDevices.createRecord();
						context$3$0.prev = 1;
						state = undefined;

						opts.isDimmering = true;
						initialDimmeringState = iconDescr && iconDescr.get("state");
						pt = undefined;

					case 6:
						context$3$0.next = 8;
						return next;

					case 8:
						if (!(pt = context$3$0.sent)) {
							context$3$0.next = 13;
							break;
						}

						if (pt.detail.type == "swipe") {
							if (data.detail.direction == "up") state = 1;else state = 0;
						} else {
							delta = -pt.deltaY / (imageHeight() * 1 /* move multiplyer */);

							state = Math.min(1, Math.max(0, initialDimmeringState + delta));
							if (state == 0 || state == 1) initialDimmeringState = state - delta;
						}
						changes.update({ content: _defineProperty({}, iconId, { state: state }) });

					case 11:
						context$3$0.next = 6;
						break;

					case 13:
						if (state != null) opts.iconCommand("Set", state);

					case 14:
						context$3$0.prev = 14;

						changes.close();
						opts.isDimmering = false;
						return context$3$0.finish(14);

					case 18:
					case "end":
						return context$3$0.stop();
				}
			}, dimm, this, [[1,, 14, 18]]);
		});

		var Picture = function Picture(attributes) {
			return React.createElement("img", {
				"class": "error",
				onerror: function () {
					this.classList.add("error");
				},
				onload: function () {
					this.classList.remove("error");
				},
				_: attributes
			});
		};

		return React.createElement(
			"div",
			{
				oncreate: function (e) {
					return icon = e.target;
				},
				onmousedown: function () {
					return isMouse = true;
				},
				onwheel: function (e) {
					return console.log(e.deltaY, e.deltaMode, e);
				},
				"class": function () {
					return "\n\t\t\ticon\n\t\t\t" + (opts.onning && "onning") + "\n\t\t\t" + (opts.offing && "offing") + "\n\t\t\t" + (opts.final && "final") + "\n\t\t\t" + (opts.errorneous && "errorneous") + "\n\t\t\t" + (opts.dimmering.valueOf() ? "dimmering" : "switching") + "\n\t\t\t" + iconId + "\n\t\t\ticon_moving_" + !!opts.moving + "\n\t\t\ticon_moved_" + (!!opts.moving && !!opts.moved) + "\n\t\t\ticon_destination_" + !!(app.hover && app.hover[iconId]) + "\n\t\t";
				},
				style: regeneratorRuntime.mark(function block() {
					var pt, i, ph, pw, ps, pi, p, w, h;
					return regeneratorRuntime.wrap(function block$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!app.editing) {
									context$3$0.next = 3;
									break;
								}

								context$3$0.next = 3;
								return co.sleep();

							case 3:
								if (block.run) {
									context$3$0.next = 7;
									break;
								}

								block.run = true;
								context$3$0.next = 9;
								break;

							case 7:
								context$3$0.next = 9;
								return co.requestAnimationFrame;

							case 9:
								pt = undefined;

								if (opts.moving) pt = { x: opts.x, y: opts.y };else {
									i = lu.valueOf(position);
									ph = app.pageHeight || 1;
									pw = app.pageWidth || 1;
									ps = pw * ph;
									pi = i % ps;
									p = (i - pi) / ps;
									w = pi % pw;
									h = (pi - w) / pw;

									w += pw * p;
									pt = { x: w * 100 / pw, y: h * 100 / ph };
								}
								return context$3$0.abrupt("return", {
									left: "" + pt.x + "%",
									top: "" + pt.y + "%"
								});

							case 12:
							case "end":
								return context$3$0.stop();
						}
					}, block, this);
				})
			},
			React.createElement(
				"div",
				{ "class": "iconControl",
					ontouch: htmlutils.preventDefault,
					ontap: function () {
						return !app.editing && opts.iconCommand("Short");
					},
					onpress: function () {
						return !app.editing && opts.iconCommand("Long");
					},
					onpan: regeneratorRuntime.mark(function callee$2$0(data) {
						var next, pt;
						return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
							while (1) switch (context$3$0.prev = context$3$0.next) {
								case 0:
									if (!app.editing) {
										context$3$0.next = 20;
										break;
									}

									next = data.detail.lock();
									context$3$0.prev = 2;
									pt = undefined;

								case 4:
									context$3$0.next = 6;
									return next;

								case 6:
									if (!(pt = context$3$0.sent)) {
										context$3$0.next = 15;
										break;
									}

									if (!(pt.detail.pressed === false)) {
										context$3$0.next = 9;
										break;
									}

									return context$3$0.abrupt("return");

								case 9:
									if (!(pt.detail.pressed == null)) {
										context$3$0.next = 11;
										break;
									}

									return context$3$0.abrupt("continue", 13);

								case 11:
									return context$3$0.delegateYield(move(pt, next), "t0", 12);

								case 12:
									return context$3$0.abrupt("break", 15);

								case 13:
									context$3$0.next = 4;
									break;

								case 15:
									context$3$0.prev = 15;

									data.detail.unlock(next);
									return context$3$0.finish(15);

								case 18:
									context$3$0.next = 23;
									break;

								case 20:
									if (!(data.detail.direction == "up" || data.detail.direction == "down")) {
										context$3$0.next = 23;
										break;
									}

									data.stopPropagation();
									return context$3$0.delegateYield(dimm(data.detail.next), "t1", 23);

								case 23:
								case "end":
									return context$3$0.stop();
							}
						}, callee$2$0, this, [[2,, 15, 18]]);
					})
				},
				React.createElement(
					"div",
					{ "class": "image", oncreate: function (e) {
							return image = e.target;
						} },
					React.createElement(Picture, { "class": "wait", src: "/images/wait.svg", style: {
							visibility: function visibility() {
								return undefined.final ? "hidden" : null;
							}
						} }),
					React.createElement(Picture, { "class": "off", src: "/images/room.svg", oncreate: function (e) {
							return off = e.target;
						} }),
					React.createElement(Picture, { "class": "on", src: "/images/room_on.svg", oncreate: function (e) {
							return on = e.target;
						} }),
					React.createElement(Picture, { "class": "absent", src: "/images/room_absent.svg", oncreate: function (e) {
							return absent = e.target;
						} }),
					React.createElement(
						"div",
						{ "class": function () {
								return "\n\t\t\t\t\tsvg\n\t\t\t\t\t" + ("state" + (!opts.present ? "Absent" : (Math.round(opts.state * 100) + 1000).toString().slice(1))) + "\n\t\t\t\t\t" + (!opts.isDimmering ? "smoothing" : "") + "\n\t\t\t\t";
							} },
						function () {
							return opts.iconData = opts.iconTemplate && htmlutils.importComponent(opts.iconTemplate) || null;
						}
					)
				),
				React.createElement(
					"span",
					{ "class": "iconLabel" },
					function () {
						return iconDescr.get(local.language) || iconDescr.get("ru") || iconDescr.get("en");
					}
				),
				React.createElement(
					"span",
					{ "class": "iconPercentage" },
					function () {
						return opts.present && opts.dimmering && "" + Math.round(opts.state * 100) + "%";
					}
				)
			),
			React.createElement("div", { "class": "deleteSign", ontouchstart: function () {
					return app.deleteItem(placeId, iconId);
				}, onmousedown: function () {
					return app.deleteItem(placeId, iconId);
				} })
		);
	};
};

// TODO: all ra structures must be linked to the current thread and must link all there tick procs to the current thread and so update all there ticks on subsequent yield and also update them all while finishing thread either normal or abnormal and then such ra structures must be destroyed to unlink from any external dependency. This must be done via implementing co.nextTick in terms like iojs.process.nextTick - nextTick callbacks must be processed before yielding subsequent result. So it is possible to let exceptions be raised in proper way. And it means that if possible nextTick callbacks will fire just after request for next yield.

// калі адразу прысвоіць left і top то чамусьці не працуе transition
// TODO: разабрацца, ці ёсьць які з гэтых двух радкоў лішні?

//

// moving

// dimmering

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Icon.js","/src/ui")

},{"_process":99,"buffer":94,"htmlutils":130,"lodash":116}],149:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");
var UID = require("uid");

module.exports = function (app, local) {

	var Place = app.load(require("ui/Place"));

	return function () {
		var marked2$0 = [pan].map(regeneratorRuntime.mark);

		var id = UID();

		function pan(next) {
			var lastDeltaX, page, size, deviceid, data, deltaX, rect, device, initialShift, shift;
			return regeneratorRuntime.wrap(function pan$(context$3$0) {
				while (1) switch (context$3$0.prev = context$3$0.next) {
					case 0:
						lastDeltaX = undefined, page = undefined, size = undefined;
						deviceid = app.activeDeviceId;

						app.placesShifts.defineProperty(deviceid);
						local.placesPages.defineProperty(deviceid);
						context$3$0.prev = 4;
						data = undefined;

					case 6:
						context$3$0.next = 8;
						return next;

					case 8:
						if (!(data = context$3$0.sent)) {
							context$3$0.next = 25;
							break;
						}

						if (data.lastDeltaX) lastDeltaX = data.lastDeltaX;
						deltaX = data.deltaX;
						rect = app.menuElement.getBoundingClientRect();
						device = app.getDevice(deviceid);

						if (!(!device || !device.content)) {
							context$3$0.next = 15;
							break;
						}

						return context$3$0.abrupt("return");

					case 15:
						size = Math.ceil(Object.keys(device.content).length / (app.pageWidth * app.pageHeight));

						if (!(size == 0)) {
							context$3$0.next = 18;
							break;
						}

						return context$3$0.abrupt("continue", 23);

					case 18:
						page = local.placesPages[deviceid] || 0;
						initialShift = -page * rect.width;
						shift = data.deltaX;

						if (shift > 0 && page == 0 || shift < 0 && page == size - 1) shift /= 3;
						app.placesShifts[deviceid] = shift;

					case 23:
						context$3$0.next = 6;
						break;

					case 25:
						if (lastDeltaX) {
							if (lastDeltaX > 0 && page > 0) local.placesPages[deviceid] = page - 1;else if (lastDeltaX < 0 && page < size - 1) local.placesPages[deviceid] = page + 1;
						}

					case 26:
						context$3$0.prev = 26;

						app.placesShifts[deviceid] = 0;
						return context$3$0.finish(26);

					case 29:
					case "end":
						return context$3$0.stop();
				}
			}, marked2$0[0], this, [[4,, 26, 29]]);
		}

		return React.createElement(
			"div",
			null,
			React.createElement(
				"style",
				{ "class": "style" },
				function () {
					return "\n\t\t\t\t." + id + " .icon {\n\t\t\t\t\twidth: " + 100 / app.pageWidth + "%;\n\t\t\t\t\theight: " + 100 / app.pageHeight + "%;\n\t\t\t\t}\n\t\t\t";
				}
			),
			React.createElement(
				"div",
				{ "class": "top" },
				React.createElement(
					"span",
					{ "class": "top_self" },
					React.createElement(
						htmlutils.Centered,
						null,
						function () {
							return app.caption;
						}
					)
				)
			),
			React.createElement("div", { "class": function () {
					return "menu " + id + " " + app.activeDeviceId;
				},
				onpan: regeneratorRuntime.mark(function callee$2$0(data) {
					return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
						while (1) switch (context$3$0.prev = context$3$0.next) {
							case 0:
								if (!(data.detail.direction == "left" || data.detail.direction == "right")) {
									context$3$0.next = 3;
									break;
								}

								data.stopPropagation();
								return context$3$0.delegateYield(pan(event.detail.next), "t0", 3);

							case 3:
							case "end":
								return context$3$0.stop();
						}
					}, callee$2$0, this);
				}),
				oncreate: function () {
					var _this = this;

					app.menuElement = this;
					var shown = Object.create(null);
					ra(function () {
						var id = app.activeDeviceId;
						if (!id || shown[id]) return;
						app.placesShifts.defineProperty(id);
						local.placesPages.defineProperty(id);
						shown[id] = true;

						_this.appendChild(React.createElement(Place, { placeId: id, placeDescr: ra(function () {
								return app.getDevice(id);
							}) }));
					});
				}
			}),
			React.createElement(
				"div",
				{ "class": "bottom" },
				React.createElement("div", { "class": "help",
					onpress: function () {
						return app.dialog = "ServiceDialog";
					}
				}),
				React.createElement("div", { "class": "logo",
					onpress: function () {
						return app.dialog = "ContextMenu";
					},
					ontap: function (event) {
						if (event.shiftKey || event.srcEvent && event.srcEvent.shiftKey) return app.dialog = "ContextMenu";
						if (event.ctrlKey || event.srcEvent && event.srcEvent.ctrlKey) return app.dialog = "SearchItems";
						app.editing = false;
						app.dialog = "";
						app.go(app.main);
					}
				}),
				React.createElement("div", { "class": "back",
					ontouch: function () {
						if (app.editing) app.editing = false;else if (app.dialog) app.dialog = "";else app.back();
					}
				})
			)
		);
	};
};

// TODO: no transition while panning
// TODO: remove <Place/> when such a place is actually removed from database

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/MainScreen.js","/src/ui")

},{"_process":99,"buffer":94,"htmlutils":130,"ui/Place":151,"uid":155}],150:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var Application = require("ui/Application");

module.exports = function (_ref) {
	var IconTemplates = _ref.IconTemplates;
	return React.createElement(
		"span",
		null,
		React.createElement(
			"style",
			null,
			" ",
			".application { position: fixed !important; } } ",
			" "
		),
		React.createElement(Application, { IconTemplates: IconTemplates })
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/OneApp.js","/src/ui")

},{"_process":99,"buffer":94,"ui/Application":142}],151:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app, local) {

	var Icon = app.load(require("ui/Icon"));

	return function (_ref) {
		var placeId = _ref.placeId;
		var placeDescr = _ref.placeDescr;

		var ids = ra(function () {
			var content = placeDescr.get("content");
			return ra.Array(lodash.keys(content).sort(function (a, b) {
				return lu.compare(content[a].index, content[b].index);
			}));
		});
		var content = ra.map(ids, function (iconId, position) {
			return React.createElement(Icon, {
				placeId: placeId,
				iconId: iconId,
				position: position,
				iconDescr: ra(function () {
					return app.getDevice(iconId);
				})
			});
		});
		return React.createElement(
			"div",
			null,
			React.createElement(
				"style",
				null,
				"\n\t\t\t\t." + placeId + " .place." + placeId + " {\n\t\t\t\t\tdisplay: initial;\n\t\t\t\t}\n\t\t\t"
			),
			React.createElement(
				"div",
				{ "class": "place " + placeId, style: {
						transform: function transform() {
							return "translateX( " + (-(local.placesPages[placeId] || 0) * app.menuElement.getBoundingClientRect().width + app.placesShifts[placeId] || 0) + "px )";
						}
					} },
				function () {
					return content;
				}
			)
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/Place.js","/src/ui")

},{"_process":99,"buffer":94,"ui/Icon":148}],152:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var DL = require("DamerauLevenshtein");

var notAChar = function notAChar(char) {
	return char <= " " || char == "-";
};

var fuzzy = function fuzzy(mask, text) {
	return DL(mask.toUpperCase(), text.toUpperCase(), {
		replace: Infinity,
		"delete": function _delete(char) {
			return notAChar(char) ? 0.01 : Infinity;
		},
		insert: function insert(char) {
			return notAChar(char) ? 0.01 : 1;
		},
		transpose: 1
	});
};

function watch(data, cb) {
	var v = undefined;
	return function () {
		if (v == null) ra.detach(function () {
			v = ra(data);
			ra(function () {
				v.valueOf();
				cb();
			});
		});
		return v.valueOf();
	};
}

module.exports = function (app) {
	var opts = undefined,
	    $ = {};

	var SearchItem = function SearchItem(_ref) {
		var placeId = _ref.placeId;
		return React.createElement(
			"div",
			{ "class": "searchItem " + placeId, onscrolltap: function () {
					return opts.goto(placeId);
				} },
			React.createElement(
				"span",
				{ "class": "caption" },
				function () {
					return opts.placeInfos[placeId].caption;
				}
			),
			React.createElement(
				"span",
				{ "class": "places" },
				function () {
					return opts.placeInfos[placeId].ptext;
				}
			),
			React.createElement("span", { "class": "cmdDeleteFromProgram" }),
			React.createElement("span", { "class": "cmdAppend" })
		);
	};

	opts = ra(Object.defineProperties({
		goto: function goto(id) {
			if (!id) return;
			var placeInfo = opts.placeInfos[id];
			~(app.searchAction || app.go)(id, placeInfo && placeInfo.places);
		}
	}, {
		deviceIds: {
			get: function () {
				return ra.Array(app.deviceIds.filter(function (id) {
					return id != app.main;
				}));
			},
			configurable: true,
			enumerable: true
		},
		placeInfos: {
			get: function () {
				var cache = Object.create(null);
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this.deviceIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var id = _step.value;

						var info = app.getDevice(id);
						cache[id] = {
							info: info,
							caption: app.getMessage(info),
							places: []
						};
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator["return"]) {
							_iterator["return"]();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					var _loop = function () {
						var id = _step2.value;

						lodash.forEach(cache[id].info.content, function (_, key) {
							return cache[key] && cache[key].places.push(id);
						});
					};

					for (var _iterator2 = this.deviceIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						_loop();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
							_iterator2["return"]();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}

				var ret = Object.create(null);
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = this.deviceIds[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var id = _step3.value;

						var c = cache[id];
						var ptext = c.places.map(function (id) {
							return cache[id].caption;
						}).join(", ");
						if (ptext) ptext = "(" + ptext + ")";
						ret[id] = { id: id, caption: c.caption || "<***>", places: c.places, ptext: ptext };
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
							_iterator3["return"]();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				return ra.JSON(ret);
			},
			configurable: true,
			enumerable: true
		},
		labels: {
			get: function () {
				return ra.keymap(opts.live.deviceIds, function (placeId) {
					return React.createElement(SearchItem, { placeId: placeId });
				});
			},
			configurable: true,
			enumerable: true
		},
		filtered: {
			get: function () {
				var value = $.mask.raValue;
				var arr = [];
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = this.deviceIds.filter(app.searchFilter || Boolean)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var id = _step4.value;

						var i = opts.placeInfos[id];
						var key = [];
						if (value) {
							key.push(fuzzy(value, i.caption),
							// ??? Math.max( ...i.places.map( id => fuzzy( value, opts.placeInfos[ id ].caption ) ) ),
							fuzzy(value, i.caption + " " + i.ptext));
							if (key.every(function (k) {
								return Math.abs(k) == Infinity;
							})) continue;
						}
						key.push(i.caption.toUpperCase());
						arr.push({ id: id, key: key });
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
							_iterator4["return"]();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				return ra.Array(arr.sort(function (a, b) {
					return lodash.zip(a.key, b.key).map(function (pair) {
						var _lu;

						return (_lu = lu).compare.apply(_lu, _toConsumableArray(pair));
					}).reduce(function (a, b) {
						return a || b;
					});
				}).map(function (a) {
					return a.id;
				}));
			},
			configurable: true,
			enumerable: true
		},
		items: {
			get: function () {
				var _this = this;

				return ra.Array(this.filtered.map(function (id) {
					return _this.labels.get(id);
				}));
			},
			configurable: true,
			enumerable: true
		}
	}));
	window._search = opts;
	return React.createElement(
		"div",
		{
			ondialogshow: function () {
				$.scroller && $.scroller.refresh();
				// TODO: разабрацца, а ці трэба заціраць пошук?
				$.mask.raValue = "";
			}
		},
		React.createElement(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					opts.goto(opts.filtered[0]);
				}
			},
			React.createElement("input", { name: "mask", type: "text", autofocus: "autofocus", oncreate: function (event) {
					return $.mask = event.target;
				} }),
			React.createElement(
				"div",
				{ "class": "scroll", oncreate: function (event) {
						return $.scroll = event.target;
					} },
				React.createElement(
					"div",
					null,
					React.createElement(
						"div",
						{ "class": "items" },
						watch(function () {
							return opts.items;
						}, function () {
							return setTimeout(function () {
								if (!$.scroller) $.scroller = new (require("iscroll"))($.scroll, {
									mouseWheel: true,
									scrollbars: true,
									tap: "scrolltap"
								});else $.scroller.refresh();
							}, 100);
						})
					),
					React.createElement("div", { "class": "scrollAreaBottomFiller" })
				)
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/SearchItems.js","/src/ui")

},{"DamerauLevenshtein":117,"_process":99,"buffer":94,"iscroll":132}],153:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var htmlutils = require("htmlutils");

module.exports = function (app) {
	var json = undefined;
	return React.createElement(
		"div",
		{ ondialogshow: function () {
				return json.value = JSON.stringify(app.getDevice(app.activeDeviceId), null, 3);
			} },
		React.createElement(
			"form",
			{
				onsubmit: function (event) {
					event && event.preventDefault();
					var text = json.value.trim() || null;
					try {
						text = text && JSON.parse(text);
					} catch (error) {
						return alert(error);
					}
					debugger;
					if (text) app.saveDevice(app.activeDeviceId, text);
					app.dialog = "";
				}
			},
			React.createElement("textarea", {
				name: "json",
				autofocus: "autofocus",
				oncreate: function (event) {
					return json = event.target;
				},
				style: {
					position: "absolute",
					left: 0,
					right: 0,
					top: "10mm",
					bottom: "15mm",
					fontSize: "50%"
				}
			}),
			React.createElement(
				"a",
				{
					"class": "save",
					href: "javascript:void(0)",
					target: "_self",
					ontouch: htmlutils.Submit,
					style: {
						position: "absolute",
						display: "block",
						left: 0,
						right: 0,
						height: "10mm",
						bottom: "0"
					}
				},
				"Save"
			)
		)
	);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/ServiceDialog.js","/src/ui")

},{"_process":99,"buffer":94,"htmlutils":130}],154:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = function (app) {
	return function () {
		return React.createElement(
			"div",
			{ "class": "startupScreen" },
			React.createElement(
				"p",
				null,
				"Добро пожаловать в Ваш",
				React.createElement("br", null),
				"Умный Дом!"
			),
			React.createElement(
				"div",
				{ "class": "templates" },
				React.createElement(
					"p",
					null,
					"Пожалуйста, выберите место, где используется этот пульт:"
				),
				React.createElement(
					"ul",
					{ "class": "houseTemplates" },
					function () {
						return (app.templates || []).concat([{
							menu: "начать с чистого листа",
							ru: "Мой дом",
							en: "Home",
							type: "place"
						}]).map(function (houseTemplate) {
							return React.createElement(
								"li",
								{ "class": "houseTemplate", ontouch: function () {
										return app.setTemplate(houseTemplate);
									} },
								houseTemplate.menu || app.getMessage(houseTemplate)
							);
						});
					}
				)
			),
			React.createElement("div", { "class": "loading" })
		);
	};
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/ui/StartupScreen.js","/src/ui")

},{"_process":99,"buffer":94}],155:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var counter = 0;

module.exports = function uid(obj) {
	var i = (++counter).toString(36);
	var r = parseInt(Math.random().toString().slice(2, 17)).toString(36);
	var id = (r.length + 9).toString(36) + r + i;
	if (obj == null) return id;else {
		obj.uid = id;
		return obj;
	}
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/uid.js","/src")

},{"_process":99,"buffer":94}],156:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
post /devices {"P":1}
*/

"use strict";

function checkBrowserFunctions() {
	var ret = true && typeof HTMLTemplateElement != "undefined" && HTMLTemplateElement;
	return !!ret;
}

if (!checkBrowserFunctions()) {
	window.__UNSUPPORTED__();
	throw new Error("unsupported");
}

require("browser-nexttick");
require("platform");
require("htmlpolyfill");
require("track");
require("gesture");

global.lu = require("localUtils");
global.ra = require("ra");
global.co = require("co");
global.lodash = require("lodash");
require("colors");

function preventDefault(event) {
	if (event.target && event.target.getAttribute("rel") == "external") return;
	var _arr = [HTMLInputElement, HTMLTextAreaElement, HTMLOptionElement, HTMLButtonElement];
	for (var _i = 0; _i < _arr.length; _i++) {
		var C = _arr[_i];
		if (event.target instanceof C) return;
	} // attempt to use native scrolling - unsuccessfull
	// let C = event.target
	// while ( C && C.classList ) {
	// 	if ( C.classList.contains( `scroll` ) )
	// 		return
	// 	C = C.parentNode
	// }
	event.preventDefault();
}

var _arr2 = ["touchstart", "touchmove", "touchend", "touchcancel"];
for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	var type = _arr2[_i2];
	window.addEventListener(type, preventDefault);
}global.LOG = function (str) {
	// if ( String( str ) == `undefined` )
	// 	debugger
	console.log.apply(console, arguments);
	global._ALERT && global._ALERT(str);
	var xhr = new XMLHttpRequest();
	xhr.open("POST", "/log?" + encodeURIComponent(str));
	xhr.onerror = lodash.noop;
	xhr.send();
	return str;
};

window.addEventListener("error", function onError(e) {
	if (!e.message.match(404) && !onError.processing) {
		onError.processing = true;
		try {
			LOG("" + e.message.red + " at " + e.lineno + ":" + e.colno + " in " + e.filename);
		} finally {
			onError.processing = false;
		}
	}
});

var onerror = window.onerror;
window.onerror = function (message, url, line, column, error) {
	var ret = undefined;
	if (error) {
		LOG("stack: " + error.stack);
	}
	if (onerror) {
		try {
			window.onerror = onerror;
			ret = onerror.apply(this, arguments);
		} finally {
			onerror = window.onerror;
		}
	}
	return ret;
};

// require( `touchLog` )
// require( `touchShow` )
// require( `touches` )

global.React = require("components");

function script(text) {
	var script = document.createElement("script");
	script.appendChild(document.createTextNode(text));
	return script;
}

co.go(regeneratorRuntime.mark(function callee$0$0() {
	var html, data, tmp, children, i;
	return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				html = cacheUrlResource("./main.html");
				context$1$0.next = 3;
				return html;

			case 3:
				html = context$1$0.sent;
				data = document.createDocumentFragment();
				tmp = document.createElement("div");

				tmp.innerHTML = html;
				tmp = tmp.children[0];
				children = [];

				for (i = 0; i < tmp.childNodes.length; ++i) {
					children.push(tmp.childNodes[i]);
				}children.forEach(function (c) {
					return tmp.removeChild(c);
				});
				children.forEach(function (c) {
					if (c instanceof HTMLScriptElement) c = script(c.innerHTML);
					data.appendChild(c);
				});

				document.body.appendChild(data);

			case 13:
			case "end":
				return context$1$0.stop();
		}
	}, callee$0$0, this);
}));

// window.addEventListener( // TODO: выдаліць пасьля выставы. Надта страшна яно дзёргаецца пры перазагрузцы
// 	`message`,
// 	event => {
// 		if ( event && event.data && event.data.what == `urlResourceUpdated` )
// 			window.setTimeout(
// 				() => window.location.reload(),
// 				1000
// 			)
// 	},
// 	false
// )

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/webpage.js","/src")

},{"_process":99,"browser-nexttick":124,"buffer":94,"co":125,"colors":109,"components":126,"gesture":128,"htmlpolyfill":129,"localUtils":134,"lodash":116,"platform":135,"ra":136,"track":139}],157:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ra = require("ra");

var windowSize = ra.clean({
	width: 1,
	height: 1,
	ppmm: 1,
	widthmm: 1,
	heightmm: 1,
	pixelRatio: 1,
	orientation: 0,
	layout: "vertical",
	window: "browser"
}).setName("windowSize");

window.addEventListener("resize", updateSize);

// let orientations = {}

var cm = document.createElement("div");
cm.style.left = "0";
cm.style.top = "0";
cm.style.width = "10cm";
cm.style.height = "10cm";
cm.style.position = "fixed";
cm.style.zIndex = "-9999";
document.body.appendChild(cm);
var ppmm = cm.clientWidth / 100;
document.body.removeChild(cm);

updateSize();

function updateSize() {

	var width = window.innerWidth;
	var height = window.innerHeight;

	var orientation = (window.orientation || 0) % 360;
	if (orientation < 0) orientation += 360;

	windowSize.width = width;
	windowSize.height = height;
	windowSize.ppmm = ppmm;
	windowSize.widthmm = width / ppmm;
	windowSize.heightmm = height / ppmm;
	windowSize.pixelRatio = window.devicePixelRatio || 1;
	windowSize.orientation = orientation;
	windowSize.layout = width <= height ? "vertical" : "horizontal";
	windowSize.window = window.navigator.standalone ? "app" : "browser";
}

module.exports = windowSize;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/windowSize.js","/src")

},{"_process":99,"buffer":94,"ra":136}],158:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require( "webpage" )
require( "ui/OneApp" )
global.require = function r( name ) {
					global.require = null
					try {
						return require.apply( this, arguments )
					}
					finally {
						global.require = r
					}
				}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/tmp/index.js","/tmp")

},{"_process":99,"buffer":94,"ui/OneApp":150,"webpage":156}]},{},[93,158])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9saWIvYmFiZWwvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY3R4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmVudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZncuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZ2V0LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5taXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQub3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQucGFydGlhbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5yZWRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5yZXBsYWNlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zYW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnNldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc3RyaW5nLXBhZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdHJpbmctcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnRhc2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudGhyb3dzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnVpZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC51bnNjb3BlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLndrcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM1LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5zdGF0aWNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnN0YXRpY3MtYWNjZXB0LXByaW1pdGl2ZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVnZXhwLmVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmxwYWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucnBhZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvanMuYXJyYXkuc3RhdGljcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3IvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsaWZ5L3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL2NvbG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL2N1c3RvbS90cmFwLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvY3VzdG9tL3phbGdvLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvZXh0ZW5kU3RyaW5nUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9ycy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9tYXBzL2FtZXJpY2EuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9tYXBzL3JhaW5ib3cuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9tYXBzL3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvcnMvbGliL21hcHMvemVicmEuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9zdHlsZXMuanMiLCJub2RlX21vZHVsZXMvY29sb3JzL2xpYi9zeXN0ZW0vc3VwcG9ydHMtY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9kaXN0L2xvZGFzaC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9EYW1lcmF1TGV2ZW5zaHRlaW4uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvSlNPTmxvY2FsLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL0xPRy5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9QaW5nUG9uZ0pTT04uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvV2ViUXVldWUuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvV2ViU29ja2V0VG9KU09OLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2FwcC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9icm93c2VyLW5leHR0aWNrLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2NvbXBvbmVudHMuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvZGV2ZGIuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvZ2VzdHVyZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9odG1scG9seWZpbGwuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvaHRtbHV0aWxzLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL2h0dHBDbGllbnQuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvaXNjcm9sbC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9sYXRlci5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9sb2NhbFV0aWxzLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3BsYXRmb3JtLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3JhLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3NjaGVkdWxlci5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy9zcGFyc2VxdWV1ZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy90cmFjay5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9BZGRFeGlzdGluZ0l0ZW0uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQWRkTWVudS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9BcHBsaWNhdGlvbi5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9Bc2tOZXdOYW1lLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL0Fza1RvTGlua0RldmljZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9CdXR0b24uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvQ29tbWFuZC5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9Db250ZXh0TWVudS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aS9JY29uLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL01haW5TY3JlZW4uanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvT25lQXBwLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1BsYWNlLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1NlYXJjaEl0ZW1zLmpzIiwiL2hvbWUvdmFkemltL3Yvd29yay9uZXJvanMvc3JjL3VpL1NlcnZpY2VEaWFsb2cuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvdWkvU3RhcnR1cFNjcmVlbi5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy91aWQuanMiLCIvaG9tZS92YWR6aW0vdi93b3JrL25lcm9qcy9zcmMvd2VicGFnZS5qcyIsIi9ob21lL3ZhZHppbS92L3dvcmsvbmVyb2pzL3NyYy93aW5kb3dTaXplLmpzIiwidG1wL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNSQTtBQUNBO0FBQ0E7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWkE7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbENBO0FBQ0E7QUFDQTs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0pBO0FBQ0E7QUFDQTs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDSkE7QUFDQTs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25uQkE7QUFDQTs7Ozs7QUNEQTtBQUNBOzs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdDRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6bk5BLFNBQVMsT0FBTyxDQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRztBQUNuQyxLQUFJLElBQUksR0FBRyxPQUFPLEtBQUssWUFBWSxHQUFHLEtBQUssQ0FBRSxFQUFFLENBQUUsR0FBRyxLQUFLLENBQUE7QUFDekQsUUFBTyxPQUFPLElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUUsR0FBRyxJQUFJLENBQUE7Q0FDbEU7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFFLEVBQUUsRUFBRSxFQUFFLEVBQWlCO0tBQWYsS0FBSyxnQ0FBRyxDQUFDOztBQUNuQyxLQUFJLENBQUMsR0FBRyxFQUFFLENBQUE7QUFDVixNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFF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ekUsUUFBSyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDOztBQUU3QyxPQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRztBQUNqQyxRQUFJLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUV4RSxRQUFJLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUMzQyxJQUFJLENBQUMsR0FBRyxDQUNQLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQ2xELElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQ2xELEVBQUUsR0FBRyxDQUFDLENBQUM7O0FBRVYsUUFBSyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUc7QUFDN0QsU0FBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLFNBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQztBQUM3QixTQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDakMsU0FBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJ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QUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxvQkFBb0IsQ0FBQTtDQUNuRTs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQTs7Ozs7O0FDbEQzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci9ydW50aW1lXCIpO1xuXG5pZiAoZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsL3BvbHlmaWxsIGlzIGFsbG93ZWRcIik7XG59XG5nbG9iYWwuX2JhYmVsUG9seWZpbGwgPSB0cnVlOyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9ICQudG9PYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9ICQudG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9ICQudG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4O1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07IiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyICQgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3R4ID0gcmVxdWlyZSgnLi8kLmN0eCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZCgkdGhpcykpXG4gICAgICAsIHNlbGYgICA9ICQuRVM1T2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSAkLnRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IEFycmF5KGxlbmd0aCkgOiBJU19GSUxURVIgPyBbXSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cxLCBtc2cyKXtcbiAgaWYoIWNvbmRpdGlvbil0aHJvdyBUeXBlRXJyb3IobXNnMiA/IG1zZzEgKyBtc2cyIDogbXNnMSk7XG59XG5hc3NlcnQuZGVmID0gJC5hc3NlcnREZWZpbmVkO1xuYXNzZXJ0LmZuID0gZnVuY3Rpb24oaXQpe1xuICBpZighJC5pc0Z1bmN0aW9uKGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuYXNzZXJ0Lm9iaiA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoISQuaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbmFzc2VydC5pbnN0ID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBUeXBlRXJyb3IobmFtZSArIFwiOiB1c2UgdGhlICduZXcnIG9wZXJhdG9yIVwiKTtcbiAgcmV0dXJuIGl0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0OyIsInZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZW51bUtleXMgPSByZXF1aXJlKCcuLyQuZW51bS1rZXlzJyk7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4gIHZhciBUID0gT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZCh0YXJnZXQpKVxuICAgICwgbCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGkgPSAxO1xuICB3aGlsZShsID4gaSl7XG4gICAgdmFyIFMgICAgICA9ICQuRVM1T2JqZWN0KGFyZ3VtZW50c1tpKytdKVxuICAgICAgLCBrZXlzICAgPSBlbnVtS2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKVRba2V5ID0ga2V5c1tqKytdXSA9IFNba2V5XTtcbiAgfVxuICByZXR1cm4gVDtcbn07IiwidmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBUQUcgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKVxuICAsIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5mdW5jdGlvbiBjb2YoaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufVxuY29mLmNsYXNzb2YgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBUO1xuICByZXR1cm4gaXQgPT0gdW5kZWZpbmVkID8gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogJ051bGwnXG4gICAgOiB0eXBlb2YgKFQgPSAoTyA9IE9iamVjdChpdCkpW1RBR10pID09ICdzdHJpbmcnID8gVCA6IGNvZihPKTtcbn07XG5jb2Yuc2V0ID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICEkLmhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkkLmhpZGUoaXQsIFRBRywgdGFnKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGNvZjsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGN0eCAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgc2FmZSAgICAgPSByZXF1aXJlKCcuLyQudWlkJykuc2FmZVxuICAsIGFzc2VydCAgID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpXG4gICwgZm9yT2YgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBzdGVwICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyJykuc3RlcFxuICAsICRoYXMgICAgID0gJC5oYXNcbiAgLCBzZXQgICAgICA9ICQuc2V0XG4gICwgaXNPYmplY3QgPSAkLmlzT2JqZWN0XG4gICwgaGlkZSAgICAgPSAkLmhpZGVcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGlzT2JqZWN0XG4gICwgSUQgICAgICAgPSBzYWZlKCdpZCcpXG4gICwgTzEgICAgICAgPSBzYWZlKCdPMScpXG4gICwgTEFTVCAgICAgPSBzYWZlKCdsYXN0JylcbiAgLCBGSVJTVCAgICA9IHNhZmUoJ2ZpcnN0JylcbiAgLCBJVEVSICAgICA9IHNhZmUoJ2l0ZXInKVxuICAsIFNJWkUgICAgID0gJC5ERVNDID8gc2FmZSgnc2l6ZScpIDogJ3NpemUnXG4gICwgaWQgICAgICAgPSAwO1xuXG5mdW5jdGlvbiBmYXN0S2V5KGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoISRoYXMoaXQsIElEKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG9iamVjdCBpZFxuICAgIGhpZGUoaXQsIElELCArK2lkKTtcbiAgLy8gcmV0dXJuIG9iamVjdCBpZCB3aXRoIHByZWZpeFxuICB9IHJldHVybiAnTycgKyBpdFtJRF07XG59XG5cbmZ1bmN0aW9uIGdldEVudHJ5KHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0W08xXVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0W0ZJUlNUXTsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFzc2VydC5pbnN0KHRoYXQsIEMsIE5BTUUpO1xuICAgICAgc2V0KHRoYXQsIE8xLCAkLmNyZWF0ZShudWxsKSk7XG4gICAgICBzZXQodGhhdCwgU0laRSwgMCk7XG4gICAgICBzZXQodGhhdCwgTEFTVCwgdW5kZWZpbmVkKTtcbiAgICAgIHNldCh0aGF0LCBGSVJTVCwgdW5kZWZpbmVkKTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVxdWlyZSgnLi8kLm1peCcpKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0W08xXSwgZW50cnkgPSB0aGF0W0ZJUlNUXTsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXRbRklSU1RdID0gdGhhdFtMQVNUXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0W08xXVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmKHRoYXRbRklSU1RdID09IGVudHJ5KXRoYXRbRklSU1RdID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0W0xBU1RdID09IGVudHJ5KXRoYXRbTEFTVF0gPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpc1tGSVJTVF0pe1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoJC5ERVNDKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBhc3NlcnQuZGVmKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdFtMQVNUXSA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXRbTEFTVF0sICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXRbRklSU1RdKXRoYXRbRklSU1RdID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXRbTzFdW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgc2V0SXRlcjogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICByZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICBzZXQodGhpcywgSVRFUiwge286IGl0ZXJhdGVkLCBrOiBraW5kfSk7XG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cbiAgICAgICAgLCBraW5kICA9IGl0ZXIua1xuICAgICAgICAsIGVudHJ5ID0gaXRlci5sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighaXRlci5vIHx8ICEoaXRlci5sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiBpdGVyLm9bRklSU1RdKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIGl0ZXIubyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBmb3JPZiA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gICRkZWYoJGRlZi5QLCBOQU1FLCB7XG4gICAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGZvck9mKHRoaXMsIGZhbHNlLCBhcnIucHVzaCwgYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICB9KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgc2FmZSAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmVcbiAgLCBhc3NlcnQgICAgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JylcbiAgLCBmb3JPZiAgICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCAkaGFzICAgICAgPSAkLmhhc1xuICAsIGlzT2JqZWN0ICA9ICQuaXNPYmplY3RcbiAgLCBoaWRlICAgICAgPSAkLmhpZGVcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGlzT2JqZWN0XG4gICwgaWQgICAgICAgID0gMFxuICAsIElEICAgICAgICA9IHNhZmUoJ2lkJylcbiAgLCBXRUFLICAgICAgPSBzYWZlKCd3ZWFrJylcbiAgLCBMRUFLICAgICAgPSBzYWZlKCdsZWFrJylcbiAgLCBtZXRob2QgICAgPSByZXF1aXJlKCcuLyQuYXJyYXktbWV0aG9kcycpXG4gICwgZmluZCAgICAgID0gbWV0aG9kKDUpXG4gICwgZmluZEluZGV4ID0gbWV0aG9kKDYpO1xuZnVuY3Rpb24gZmluZEZyb3plbihzdG9yZSwga2V5KXtcbiAgcmV0dXJuIGZpbmQoc3RvcmUuYXJyYXksIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59XG4vLyBmYWxsYmFjayBmb3IgZnJvemVuIGtleXNcbmZ1bmN0aW9uIGxlYWtTdG9yZSh0aGF0KXtcbiAgcmV0dXJuIHRoYXRbTEVBS10gfHwgaGlkZSh0aGF0LCBMRUFLLCB7XG4gICAgYXJyYXk6IFtdLFxuICAgIGdldDogZnVuY3Rpb24oa2V5KXtcbiAgICAgIHZhciBlbnRyeSA9IGZpbmRGcm96ZW4odGhpcywga2V5KTtcbiAgICAgIGlmKGVudHJ5KXJldHVybiBlbnRyeVsxXTtcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24oa2V5KXtcbiAgICAgIHJldHVybiAhIWZpbmRGcm96ZW4odGhpcywga2V5KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICB2YXIgZW50cnkgPSBmaW5kRnJvemVuKHRoaXMsIGtleSk7XG4gICAgICBpZihlbnRyeSllbnRyeVsxXSA9IHZhbHVlO1xuICAgICAgZWxzZSB0aGlzLmFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9LFxuICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuYXJyYXksIGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgICB9KTtcbiAgICAgIGlmKH5pbmRleCl0aGlzLmFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gISF+aW5kZXg7XG4gICAgfVxuICB9KVtMRUFLXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgJC5zZXQoYXNzZXJ0Lmluc3QodGhhdCwgQywgTkFNRSksIElELCBpZCsrKTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVxdWlyZSgnLi8kLm1peCcpKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIWlzRXh0ZW5zaWJsZShrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcylbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiAkaGFzKGtleSwgV0VBSykgJiYgJGhhcyhrZXlbV0VBS10sIHRoaXNbSURdKSAmJiBkZWxldGUga2V5W1dFQUtdW3RoaXNbSURdXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZighaXNFeHRlbnNpYmxlKGtleSkpcmV0dXJuIGxlYWtTdG9yZSh0aGlzKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuICRoYXMoa2V5LCBXRUFLKSAmJiAkaGFzKGtleVtXRUFLXSwgdGhpc1tJRF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIGlmKCFpc0V4dGVuc2libGUoYXNzZXJ0Lm9iaihrZXkpKSl7XG4gICAgICBsZWFrU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkaGFzKGtleSwgV0VBSykgfHwgaGlkZShrZXksIFdFQUssIHt9KTtcbiAgICAgIGtleVtXRUFLXVt0aGF0W0lEXV0gPSB2YWx1ZTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBsZWFrU3RvcmU6IGxlYWtTdG9yZSxcbiAgV0VBSzogV0VBSyxcbiAgSUQ6IElEXG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBCVUdHWSA9IHJlcXVpcmUoJy4vJC5pdGVyJykuQlVHR1lcbiAgLCBmb3JPZiA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHNwZWNpZXMgPSByZXF1aXJlKCcuLyQuc3BlY2llcycpXG4gICwgYXNzZXJ0SW5zdGFuY2UgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JykuaW5zdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9ICQuZ1tOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgZnVuY3Rpb24gZml4TWV0aG9kKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZXF1aXJlKCcuLyQucmVkZWYnKShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7IHJldHVybiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IH1cbiAgICAgIDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpeyByZXR1cm4gZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyB9XG4gICAgICA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKXsgcmV0dXJuIGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgfVxuICAgICAgOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSl7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfVxuICBpZighJC5pc0Z1bmN0aW9uKEMpIHx8ICEoSVNfV0VBSyB8fCAhQlVHR1kgJiYgcHJvdG8uZm9yRWFjaCAmJiBwcm90by5lbnRyaWVzKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlcXVpcmUoJy4vJC5taXgnKShDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3QgID0gbmV3IENcbiAgICAgICwgY2hhaW4gPSBpbnN0W0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSlcbiAgICAgICwgYnVnZ3laZXJvO1xuICAgIC8vIHdyYXAgZm9yIGluaXQgY29sbGVjdGlvbnMgZnJvbSBpdGVyYWJsZVxuICAgIGlmKCFyZXF1aXJlKCcuLyQuaXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgbmV3IEMoaXRlcik7IH0pKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgICBhc3NlcnRJbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IG5ldyBCYXNlO1xuICAgICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgSVNfV0VBSyB8fCBpbnN0LmZvckVhY2goZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgYnVnZ3laZXJvID0gMSAvIGtleSA9PT0gLUluZmluaXR5O1xuICAgIH0pO1xuICAgIC8vIGZpeCBjb252ZXJ0aW5nIC0wIGtleSB0byArMFxuICAgIGlmKGJ1Z2d5WmVybyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICAvLyArIGZpeCAuYWRkICYgLnNldCBmb3IgY2hhaW5pbmdcbiAgICBpZihidWdneVplcm8gfHwgY2hhaW4gIT09IGluc3QpZml4TWV0aG9kKEFEREVSKTtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vJC5jb2YnKS5zZXQoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRkZWYoJGRlZi5HICsgJGRlZi5XICsgJGRlZi5GICogKEMgIT0gQmFzZSksIE8pO1xuICBzcGVjaWVzKEMpO1xuICBzcGVjaWVzKCQuY29yZVtOQU1FXSk7IC8vIGZvciB3cmFwcGVyXG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldEl0ZXIoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwiLy8gT3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYXNzZXJ0RnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYXNzZXJ0JykuZm47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhc3NlcnRGdW5jdGlvbihmbik7XG4gIGlmKH5sZW5ndGggJiYgdGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH0gcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn07IiwidmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgPSAkLmdcbiAgLCBjb3JlICAgICAgID0gJC5jb3JlXG4gICwgaXNGdW5jdGlvbiA9ICQuaXNGdW5jdGlvblxuICAsICRyZWRlZiAgICAgPSByZXF1aXJlKCcuLyQucmVkZWYnKTtcbmZ1bmN0aW9uIGN0eChmbiwgdGhhdCl7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRkZWYuRiA9IDE7ICAvLyBmb3JjZWRcbiRkZWYuRyA9IDI7ICAvLyBnbG9iYWxcbiRkZWYuUyA9IDQ7ICAvLyBzdGF0aWNcbiRkZWYuUCA9IDg7ICAvLyBwcm90b1xuJGRlZi5CID0gMTY7IC8vIGJpbmRcbiRkZWYuVyA9IDMyOyAvLyB3cmFwXG5mdW5jdGlvbiAkZGVmKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHBcbiAgICAsIGlzR2xvYmFsID0gdHlwZSAmICRkZWYuR1xuICAgICwgaXNQcm90byAgPSB0eXBlICYgJGRlZi5QXG4gICAgLCB0YXJnZXQgICA9IGlzR2xvYmFsID8gZ2xvYmFsIDogdHlwZSAmICRkZWYuU1xuICAgICAgICA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pLnByb3RvdHlwZVxuICAgICwgZXhwb3J0cyAgPSBpc0dsb2JhbCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICBpZihpc0dsb2JhbClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gISh0eXBlICYgJGRlZi5GKSAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBpZih0eXBlICYgJGRlZi5CICYmIG93billeHAgPSBjdHgob3V0LCBnbG9iYWwpO1xuICAgIGVsc2UgZXhwID0gaXNQcm90byAmJiBpc0Z1bmN0aW9uKG91dCkgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0ICYmICFvd24pJHJlZGVmKHRhcmdldCwga2V5LCBvdXQpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpJC5oaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihpc1Byb3RvKShleHBvcnRzLnByb3RvdHlwZSB8fCAoZXhwb3J0cy5wcm90b3R5cGUgPSB7fSkpW2tleV0gPSBvdXQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gJGRlZjsiLCJ2YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGRvY3VtZW50ID0gJC5nLmRvY3VtZW50XG4gICwgaXNPYmplY3QgPSAkLmlzT2JqZWN0XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSAkLmdldEtleXMoaXQpXG4gICAgLCBnZXREZXNjICAgID0gJC5nZXREZXNjXG4gICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzO1xuICBpZihnZXRTeW1ib2xzKSQuZWFjaC5jYWxsKGdldFN5bWJvbHMoaXQpLCBmdW5jdGlvbihrZXkpe1xuICAgIGlmKGdldERlc2MoaXQsIGtleSkuZW51bWVyYWJsZSlrZXlzLnB1c2goa2V5KTtcbiAgfSk7XG4gIHJldHVybiBrZXlzO1xufTsiLCJ2YXIgY3R4ICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIGdldCAgPSByZXF1aXJlKCcuLyQuaXRlcicpLmdldFxuICAsIGNhbGwgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XG4gIHZhciBpdGVyYXRvciA9IGdldChpdGVyYWJsZSlcbiAgICAsIGYgICAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBzdGVwO1xuICB3aGlsZSghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpe1xuICAgIGlmKGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpID09PSBmYWxzZSl7XG4gICAgICByZXR1cm4gY2FsbC5jbG9zZShpdGVyYXRvcik7XG4gICAgfVxuICB9XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCl7XG4gICQuRlcgICA9IHRydWU7XG4gICQucGF0aCA9ICQuZztcbiAgcmV0dXJuICQ7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcclxudmFyICQgPSByZXF1aXJlKCcuLyQnKVxyXG4gICwgdG9TdHJpbmcgPSB7fS50b1N0cmluZ1xyXG4gICwgZ2V0TmFtZXMgPSAkLmdldE5hbWVzO1xyXG5cclxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xyXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xyXG5cclxuZnVuY3Rpb24gZ2V0V2luZG93TmFtZXMoaXQpe1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZ2V0TmFtZXMoaXQpO1xyXG4gIH0gY2F0Y2goZSl7XHJcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xyXG4gIGlmKHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nKXJldHVybiBnZXRXaW5kb3dOYW1lcyhpdCk7XHJcbiAgcmV0dXJuIGdldE5hbWVzKCQudG9PYmplY3QoaXQpKTtcclxufTsiLCIvLyBGYXN0IGFwcGx5XG4vLyBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgY2FzZSA1OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCJ2YXIgYXNzZXJ0T2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLm9iajtcbmZ1bmN0aW9uIGNsb3NlKGl0ZXJhdG9yKXtcbiAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgaWYocmV0ICE9PSB1bmRlZmluZWQpYXNzZXJ0T2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG59XG5mdW5jdGlvbiBjYWxsKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYXNzZXJ0T2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICB9IGNhdGNoKGUpe1xuICAgIGNsb3NlKGl0ZXJhdG9yKTtcbiAgICB0aHJvdyBlO1xuICB9XG59XG5jYWxsLmNsb3NlID0gY2xvc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGNhbGw7IiwidmFyICRkZWYgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRyZWRlZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZicpXG4gICwgJCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCAkaXRlciAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcicpXG4gICwgU1lNQk9MX0lURVJBVE9SID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgRkZfSVRFUkFUT1IgICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgID0gJ3ZhbHVlcydcbiAgLCBJdGVyYXRvcnMgICAgICAgPSAkaXRlci5JdGVyYXRvcnM7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFKXtcbiAgJGl0ZXIuY3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgZnVuY3Rpb24gY3JlYXRlTWV0aG9kKGtpbmQpe1xuICAgIGZ1bmN0aW9uICQkKHRoYXQpe1xuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGF0LCBraW5kKTtcbiAgICB9XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gJCQodGhpcyk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJCQodGhpcyk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gJCQodGhpcyk7IH07XG4gIH1cbiAgdmFyIFRBRyAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBwcm90byAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCBfbmF0aXZlICA9IHByb3RvW1NZTUJPTF9JVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsIF9kZWZhdWx0ID0gX25hdGl2ZSB8fCBjcmVhdGVNZXRob2QoREVGQVVMVClcbiAgICAsIG1ldGhvZHMsIGtleTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZihfbmF0aXZlKXtcbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSAkLmdldFByb3RvKF9kZWZhdWx0LmNhbGwobmV3IEJhc2UpKTtcbiAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgY29mLnNldChJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAvLyBGRiBmaXhcbiAgICBpZigkLkZXICYmICQuaGFzKHByb3RvLCBGRl9JVEVSQVRPUikpJGl0ZXIuc2V0KEl0ZXJhdG9yUHJvdG90eXBlLCAkLnRoYXQpO1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigkLkZXIHx8IEZPUkNFKSRpdGVyLnNldChwcm90bywgX2RlZmF1bHQpO1xuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IF9kZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSAkLnRoYXQ7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgICAgICAgICA/IF9kZWZhdWx0IDogY3JlYXRlTWV0aG9kKEtFWVMpLFxuICAgICAgdmFsdWVzOiAgREVGQVVMVCA9PSBWQUxVRVMgPyBfZGVmYXVsdCA6IGNyZWF0ZU1ldGhvZChWQUxVRVMpLFxuICAgICAgZW50cmllczogREVGQVVMVCAhPSBWQUxVRVMgPyBfZGVmYXVsdCA6IGNyZWF0ZU1ldGhvZCgnZW50cmllcycpXG4gICAgfTtcbiAgICBpZihGT1JDRSlmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKSRyZWRlZihwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZGVmKCRkZWYuUCArICRkZWYuRiAqICRpdGVyLkJVR0dZLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxufTsiLCJ2YXIgU1lNQk9MX0lURVJBVE9SID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HICAgID0gZmFsc2U7XG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bU1lNQk9MX0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIGlmKCFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbU1lNQk9MX0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHNhZmUgPSB0cnVlOyB9O1xuICAgIGFycltTWU1CT0xfSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNvZiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgY2xhc3NvZiAgICAgICAgICAgPSBjb2YuY2xhc3NvZlxuICAsIGFzc2VydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpXG4gICwgYXNzZXJ0T2JqZWN0ICAgICAgPSBhc3NlcnQub2JqXG4gICwgU1lNQk9MX0lURVJBVE9SICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBGRl9JVEVSQVRPUiAgICAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEl0ZXJhdG9ycyAgICAgICAgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpKCdpdGVyYXRvcnMnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuc2V0SXRlcmF0b3IoSXRlcmF0b3JQcm90b3R5cGUsICQudGhhdCk7XG5mdW5jdGlvbiBzZXRJdGVyYXRvcihPLCB2YWx1ZSl7XG4gICQuaGlkZShPLCBTWU1CT0xfSVRFUkFUT1IsIHZhbHVlKTtcbiAgLy8gQWRkIGl0ZXJhdG9yIGZvciBGRiBpdGVyYXRvciBwcm90b2NvbFxuICBpZihGRl9JVEVSQVRPUiBpbiBbXSkkLmhpZGUoTywgRkZfSVRFUkFUT1IsIHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgQlVHR1k6ICdrZXlzJyBpbiBbXSAmJiAhKCduZXh0JyBpbiBbXS5rZXlzKCkpLFxuICBJdGVyYXRvcnM6IEl0ZXJhdG9ycyxcbiAgc3RlcDogZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICAgIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xuICB9LFxuICBpczogZnVuY3Rpb24oaXQpe1xuICAgIHZhciBPICAgICAgPSBPYmplY3QoaXQpXG4gICAgICAsIFN5bWJvbCA9ICQuZy5TeW1ib2w7XG4gICAgcmV0dXJuIChTeW1ib2wgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IEZGX0lURVJBVE9SKSBpbiBPXG4gICAgICB8fCBTWU1CT0xfSVRFUkFUT1IgaW4gT1xuICAgICAgfHwgJC5oYXMoSXRlcmF0b3JzLCBjbGFzc29mKE8pKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihpdCl7XG4gICAgdmFyIFN5bWJvbCA9ICQuZy5TeW1ib2xcbiAgICAgICwgZ2V0SXRlcjtcbiAgICBpZihpdCAhPSB1bmRlZmluZWQpe1xuICAgICAgZ2V0SXRlciA9IGl0W1N5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgRkZfSVRFUkFUT1JdXG4gICAgICAgIHx8IGl0W1NZTUJPTF9JVEVSQVRPUl1cbiAgICAgICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbiAgICB9XG4gICAgYXNzZXJ0KCQuaXNGdW5jdGlvbihnZXRJdGVyKSwgaXQsICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAgIHJldHVybiBhc3NlcnRPYmplY3QoZ2V0SXRlci5jYWxsKGl0KSk7XG4gIH0sXG4gIHNldDogc2V0SXRlcmF0b3IsXG4gIGNyZWF0ZTogZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIHByb3RvKXtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLmNyZWF0ZShwcm90byB8fCBJdGVyYXRvclByb3RvdHlwZSwge25leHQ6ICQuZGVzYygxLCBuZXh0KX0pO1xuICAgIGNvZi5zZXQoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClcbiAgLCBjb3JlICAgPSB7fVxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eVxuICAsIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yXG4gICwgbWF4ICAgPSBNYXRoLm1heFxuICAsIG1pbiAgID0gTWF0aC5taW47XG4vLyBUaGUgZW5naW5lIHdvcmtzIGZpbmUgd2l0aCBkZXNjcmlwdG9ycz8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eS5cbnZhciBERVNDID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gMjsgfX0pLmEgPT0gMjtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xudmFyIGhpZGUgPSBjcmVhdGVEZWZpbmVyKDEpO1xuLy8gNy4xLjQgVG9JbnRlZ2VyXG5mdW5jdGlvbiB0b0ludGVnZXIoaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn1cbmZ1bmN0aW9uIGRlc2MoYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gc2ltcGxlU2V0KG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZpbmVyKGJpdG1hcCl7XG4gIHJldHVybiBERVNDID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBkZXNjKGJpdG1hcCwgdmFsdWUpKTtcbiAgfSA6IHNpbXBsZVNldDtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoaXQpe1xuICByZXR1cm4gaXQgIT09IG51bGwgJiYgKHR5cGVvZiBpdCA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaXQgPT0gJ2Z1bmN0aW9uJyk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZChpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn1cblxudmFyICQgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5mdycpKHtcbiAgZzogZ2xvYmFsLFxuICBjb3JlOiBjb3JlLFxuICBodG1sOiBnbG9iYWwuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9jb3JlLWpzLWlzb2JqZWN0XG4gIGlzT2JqZWN0OiAgIGlzT2JqZWN0LFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICB0aGF0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyA3LjEuNCBUb0ludGVnZXJcbiAgdG9JbnRlZ2VyOiB0b0ludGVnZXIsXG4gIC8vIDcuMS4xNSBUb0xlbmd0aFxuICB0b0xlbmd0aDogZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG4gIH0sXG4gIHRvSW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICAgIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihpdCwga2V5KXtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbiAgfSxcbiAgY3JlYXRlOiAgICAgT2JqZWN0LmNyZWF0ZSxcbiAgZ2V0UHJvdG86ICAgT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICBERVNDOiAgICAgICBERVNDLFxuICBkZXNjOiAgICAgICBkZXNjLFxuICBnZXREZXNjOiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBzZXREZXNjOiAgICBkZWZpbmVQcm9wZXJ0eSxcbiAgc2V0RGVzY3M6ICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXG4gIGdldEtleXM6ICAgIE9iamVjdC5rZXlzLFxuICBnZXROYW1lczogICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgZ2V0U3ltYm9sczogT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgYXNzZXJ0RGVmaW5lZDogYXNzZXJ0RGVmaW5lZCxcbiAgLy8gRHVtbXksIGZpeCBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZyBpbiBlczUgbW9kdWxlXG4gIEVTNU9iamVjdDogT2JqZWN0LFxuICB0b09iamVjdDogZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiAkLkVTNU9iamVjdChhc3NlcnREZWZpbmVkKGl0KSk7XG4gIH0sXG4gIGhpZGU6IGhpZGUsXG4gIGRlZjogY3JlYXRlRGVmaW5lcigwKSxcbiAgc2V0OiBnbG9iYWwuU3ltYm9sID8gc2ltcGxlU2V0IDogaGlkZSxcbiAgZWFjaDogW10uZm9yRWFjaFxufSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuaWYodHlwZW9mIF9fZSAhPSAndW5kZWZpbmVkJylfX2UgPSBjb3JlO1xuaWYodHlwZW9mIF9fZyAhPSAndW5kZWZpbmVkJylfX2cgPSBnbG9iYWw7IiwidmFyICQgPSByZXF1aXJlKCcuLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSAkLnRvT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9ICQuZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07IiwidmFyICRyZWRlZiA9IHJlcXVpcmUoJy4vJC5yZWRlZicpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjKXtcclxuICBmb3IodmFyIGtleSBpbiBzcmMpJHJlZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufTsiLCJ2YXIgJCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBhc3NlcnRPYmplY3QgPSByZXF1aXJlKCcuLyQuYXNzZXJ0Jykub2JqO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvd25LZXlzKGl0KXtcbiAgYXNzZXJ0T2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgICAgICAgPSAkLmdldE5hbWVzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBpbnZva2UgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBhc3NlcnRGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKS5mbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oLyogLi4ucGFyZ3MgKi8pe1xuICB2YXIgZm4gICAgID0gYXNzZXJ0RnVuY3Rpb24odGhpcylcbiAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIHBhcmdzICA9IEFycmF5KGxlbmd0aClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIF8gICAgICA9ICQucGF0aC5fXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigocGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciB0aGF0ICAgID0gdGhpc1xuICAgICAgLCBfbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBqID0gMCwgayA9IDAsIGFyZ3M7XG4gICAgaWYoIWhvbGRlciAmJiAhX2xlbmd0aClyZXR1cm4gaW52b2tlKGZuLCBwYXJncywgdGhhdCk7XG4gICAgYXJncyA9IHBhcmdzLnNsaWNlKCk7XG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gajsgaisrKWlmKGFyZ3Nbal0gPT09IF8pYXJnc1tqXSA9IGFyZ3VtZW50c1trKytdO1xuICAgIHdoaWxlKF9sZW5ndGggPiBrKWFyZ3MucHVzaChhcmd1bWVudHNbaysrXSk7XG4gICAgcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG59OyIsInZhciAkICAgPSByZXF1aXJlKCcuLyQnKVxyXG4gICwgdHBsID0gU3RyaW5nKHt9Lmhhc093blByb3BlcnR5KVxyXG4gICwgU1JDID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ3NyYycpXHJcbiAgLCBfdG9TdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZztcclxuXHJcbmZ1bmN0aW9uICRyZWRlZihPLCBrZXksIHZhbCwgc2FmZSl7XHJcbiAgaWYoJC5pc0Z1bmN0aW9uKHZhbCkpe1xyXG4gICAgdmFyIGJhc2UgPSBPW2tleV07XHJcbiAgICAkLmhpZGUodmFsLCBTUkMsIGJhc2UgPyBTdHJpbmcoYmFzZSkgOiB0cGwucmVwbGFjZSgvaGFzT3duUHJvcGVydHkvLCBTdHJpbmcoa2V5KSkpO1xyXG4gICAgaWYoISgnbmFtZScgaW4gdmFsKSl2YWwubmFtZSA9IGtleTtcclxuICB9XHJcbiAgaWYoTyA9PT0gJC5nKXtcclxuICAgIE9ba2V5XSA9IHZhbDtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYoIXNhZmUpZGVsZXRlIE9ba2V5XTtcclxuICAgICQuaGlkZShPLCBrZXksIHZhbCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9yc1xyXG4vLyB3aXRoIG1ldGhvZHMgc2ltaWxhciB0byBMb0Rhc2ggaXNOYXRpdmVcclxuJHJlZGVmKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcclxuICByZXR1cm4gJC5oYXModGhpcywgU1JDKSA/IHRoaXNbU1JDXSA6IF90b1N0cmluZy5jYWxsKHRoaXMpO1xyXG59KTtcclxuXHJcbiQuY29yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xyXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChpdCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICRyZWRlZjsiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlZ0V4cCwgcmVwbGFjZSwgaXNTdGF0aWMpe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpc1N0YXRpYyA/IGl0IDogdGhpcykucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XHJcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XHJcbn07IiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyICQgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgYXNzZXJ0ID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpO1xuZnVuY3Rpb24gY2hlY2soTywgcHJvdG8pe1xuICBhc3NlcnQub2JqKE8pO1xuICBhc3NlcnQocHJvdG8gPT09IG51bGwgfHwgJC5pc09iamVjdChwcm90byksIHByb3RvLCBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICA/IGZ1bmN0aW9uKGJ1Z2d5LCBzZXQpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldCA9IHJlcXVpcmUoJy4vJC5jdHgnKShGdW5jdGlvbi5jYWxsLCAkLmdldERlc2MoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgICAgc2V0KHt9LCBbXSk7XG4gICAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgICByZXR1cm4gTztcbiAgICAgICAgfTtcbiAgICAgIH0oKVxuICAgIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59OyIsInZhciAkICAgICAgPSByZXF1aXJlKCcuLyQnKVxyXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcclxuICAsIHN0b3JlICA9ICQuZ1tTSEFSRURdIHx8ICQuaGlkZSgkLmcsIFNIQVJFRCwge30pW1NIQVJFRF07XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcclxufTsiLCJ2YXIgJCAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDKXtcbiAgaWYoJC5ERVNDICYmICEoU1BFQ0lFUyBpbiBDKSkkLnNldERlc2MoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6ICQudGhhdFxuICB9KTtcbn07IiwiLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbnZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKCQuYXNzZXJ0RGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9ICQudG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGxcbiAgICAgIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07IiwiLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46c3RyaW5nX3BhZGRpbmdcbnZhciAkICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHJlcGVhdCA9IHJlcXVpcmUoJy4vJC5zdHJpbmctcmVwZWF0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgbWluTGVuZ3RoLCBmaWxsQ2hhciwgbGVmdCl7XG4gIC8vIDEuIExldCBPIGJlIENoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXMgdmFsdWUpLlxuICAvLyAyLiBMZXQgUyBiZSBUb1N0cmluZyhPKS5cbiAgdmFyIFMgPSBTdHJpbmcoJC5hc3NlcnREZWZpbmVkKHRoYXQpKTtcbiAgLy8gNC4gSWYgaW50TWluTGVuZ3RoIGlzIHVuZGVmaW5lZCwgcmV0dXJuIFMuXG4gIGlmKG1pbkxlbmd0aCA9PT0gdW5kZWZpbmVkKXJldHVybiBTO1xuICAvLyA0LiBMZXQgaW50TWluTGVuZ3RoIGJlIFRvSW50ZWdlcihtaW5MZW5ndGgpLlxuICB2YXIgaW50TWluTGVuZ3RoID0gJC50b0ludGVnZXIobWluTGVuZ3RoKTtcbiAgLy8gNS4gTGV0IGZpbGxMZW4gYmUgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIFMgbWludXMgaW50TWluTGVuZ3RoLlxuICB2YXIgZmlsbExlbiA9IGludE1pbkxlbmd0aCAtIFMubGVuZ3RoO1xuICAvLyA2LiBJZiBmaWxsTGVuIDwgMCwgdGhlbiB0aHJvdyBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uLlxuICAvLyA3LiBJZiBmaWxsTGVuIGlzICviiJ4sIHRoZW4gdGhyb3cgYSBSYW5nZUVycm9yIGV4Y2VwdGlvbi5cbiAgaWYoZmlsbExlbiA8IDAgfHwgZmlsbExlbiA9PT0gSW5maW5pdHkpe1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDYW5ub3Qgc2F0aXNmeSBzdHJpbmcgbGVuZ3RoICcgKyBtaW5MZW5ndGggKyAnIGZvciBzdHJpbmc6ICcgKyBTKTtcbiAgfVxuICAvLyA4LiBMZXQgc0ZpbGxTdHIgYmUgdGhlIHN0cmluZyByZXByZXNlbnRlZCBieSBmaWxsU3RyLlxuICAvLyA5LiBJZiBzRmlsbFN0ciBpcyB1bmRlZmluZWQsIGxldCBzRmlsbFN0ciBiZSBhIHNwYWNlIGNoYXJhY3Rlci5cbiAgdmFyIHNGaWxsU3RyID0gZmlsbENoYXIgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsQ2hhcik7XG4gIC8vIDEwLiBMZXQgc0ZpbGxWYWwgYmUgYSBTdHJpbmcgbWFkZSBvZiBzRmlsbFN0ciwgcmVwZWF0ZWQgdW50aWwgZmlsbExlbiBpcyBtZXQuXG4gIHZhciBzRmlsbFZhbCA9IHJlcGVhdC5jYWxsKHNGaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIHNGaWxsU3RyLmxlbmd0aCkpO1xuICAvLyB0cnVuY2F0ZSBpZiB3ZSBvdmVyZmxvd2VkXG4gIGlmKHNGaWxsVmFsLmxlbmd0aCA+IGZpbGxMZW4pc0ZpbGxWYWwgPSBsZWZ0XG4gICAgPyBzRmlsbFZhbC5zbGljZShzRmlsbFZhbC5sZW5ndGggLSBmaWxsTGVuKVxuICAgIDogc0ZpbGxWYWwuc2xpY2UoMCwgZmlsbExlbik7XG4gIC8vIDExLiBSZXR1cm4gYSBzdHJpbmcgbWFkZSBmcm9tIHNGaWxsVmFsLCBmb2xsb3dlZCBieSBTLlxuICAvLyAxMS4gUmV0dXJuIGEgU3RyaW5nIG1hZGUgZnJvbSBTLCBmb2xsb3dlZCBieSBzRmlsbFZhbC5cbiAgcmV0dXJuIGxlZnQgPyBzRmlsbFZhbC5jb25jYXQoUykgOiBTLmNvbmNhdChzRmlsbFZhbCk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KXtcbiAgdmFyIHN0ciA9IFN0cmluZygkLmFzc2VydERlZmluZWQodGhpcykpXG4gICAgLCByZXMgPSAnJ1xuICAgICwgbiAgID0gJC50b0ludGVnZXIoY291bnQpO1xuICBpZihuIDwgMCB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3R4ICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY29mICAgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgaW52b2tlID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgY2VsICAgID0gcmVxdWlyZSgnLi8kLmRvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9ICQuZ1xuICAsIGlzRnVuY3Rpb24gICAgICAgICA9ICQuaXNGdW5jdGlvblxuICAsIGh0bWwgICAgICAgICAgICAgICA9ICQuaHRtbFxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIHBvc3RNZXNzYWdlICAgICAgICA9IGdsb2JhbC5wb3N0TWVzc2FnZVxuICAsIGFkZEV2ZW50TGlzdGVuZXIgICA9IGdsb2JhbC5hZGRFdmVudExpc3RlbmVyXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbmZ1bmN0aW9uIHJ1bigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYoJC5oYXMocXVldWUsIGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufVxuZnVuY3Rpb24gbGlzdG5lcihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufVxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIWlzRnVuY3Rpb24oc2V0VGFzaykgfHwgIWlzRnVuY3Rpb24oY2xlYXJUYXNrKSl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbihmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZShpc0Z1bmN0aW9uKGZuKSA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbihpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKGNvZihwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIE1vZGVybiBicm93c2Vycywgc2tpcCBpbXBsZW1lbnRhdGlvbiBmb3IgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyBvYmplY3RcbiAgfSBlbHNlIGlmKGFkZEV2ZW50TGlzdGVuZXIgJiYgaXNGdW5jdGlvbihwb3N0TWVzc2FnZSkgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHBvc3RNZXNzYWdlKGlkLCAnKicpO1xuICAgIH07XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RuZXIsIGZhbHNlKTtcbiAgLy8gV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoaXNGdW5jdGlvbihNZXNzYWdlQ2hhbm5lbCkpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0bmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCJ2YXIgc2lkID0gMDtcbmZ1bmN0aW9uIHVpZChrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytzaWQgKyBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNikpO1xufVxudWlkLnNhZmUgPSByZXF1aXJlKCcuLyQnKS5nLlN5bWJvbCB8fCB1aWQ7XG5tb2R1bGUuZXhwb3J0cyA9IHVpZDsiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuLyQud2tzJykoJ3Vuc2NvcGFibGVzJyk7XG5pZighKFVOU0NPUEFCTEVTIGluIFtdKSlyZXF1aXJlKCcuLyQnKS5oaWRlKEFycmF5LnByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgW11bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi8kJykuZ1xuICAsIHN0b3JlICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKSgnd2tzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBnbG9iYWwuU3ltYm9sICYmIGdsb2JhbC5TeW1ib2xbbmFtZV0gfHwgcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTsiLCJ2YXIgJCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY2VsICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBjb2YgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGludm9rZSAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBhcnJheU1ldGhvZCAgICAgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKVxuICAsIElFX1BST1RPICAgICAgICAgPSByZXF1aXJlKCcuLyQudWlkJykuc2FmZSgnX19wcm90b19fJylcbiAgLCBhc3NlcnQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpXG4gICwgYXNzZXJ0T2JqZWN0ICAgICA9IGFzc2VydC5vYmpcbiAgLCBPYmplY3RQcm90byAgICAgID0gT2JqZWN0LnByb3RvdHlwZVxuICAsIGh0bWwgICAgICAgICAgICAgPSAkLmh0bWxcbiAgLCBBICAgICAgICAgICAgICAgID0gW11cbiAgLCBfc2xpY2UgICAgICAgICAgID0gQS5zbGljZVxuICAsIF9qb2luICAgICAgICAgICAgPSBBLmpvaW5cbiAgLCBjbGFzc29mICAgICAgICAgID0gY29mLmNsYXNzb2ZcbiAgLCBoYXMgICAgICAgICAgICAgID0gJC5oYXNcbiAgLCBkZWZpbmVQcm9wZXJ0eSAgID0gJC5zZXREZXNjXG4gICwgZ2V0T3duRGVzY3JpcHRvciA9ICQuZ2V0RGVzY1xuICAsIGRlZmluZVByb3BlcnRpZXMgPSAkLnNldERlc2NzXG4gICwgaXNGdW5jdGlvbiAgICAgICA9ICQuaXNGdW5jdGlvblxuICAsIGlzT2JqZWN0ICAgICAgICAgPSAkLmlzT2JqZWN0XG4gICwgdG9PYmplY3QgICAgICAgICA9ICQudG9PYmplY3RcbiAgLCB0b0xlbmd0aCAgICAgICAgID0gJC50b0xlbmd0aFxuICAsIHRvSW5kZXggICAgICAgICAgPSAkLnRvSW5kZXhcbiAgLCBJRThfRE9NX0RFRklORSAgID0gZmFsc2VcbiAgLCAkaW5kZXhPZiAgICAgICAgID0gcmVxdWlyZSgnLi8kLmFycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgJGZvckVhY2ggICAgICAgICA9IGFycmF5TWV0aG9kKDApXG4gICwgJG1hcCAgICAgICAgICAgICA9IGFycmF5TWV0aG9kKDEpXG4gICwgJGZpbHRlciAgICAgICAgICA9IGFycmF5TWV0aG9kKDIpXG4gICwgJHNvbWUgICAgICAgICAgICA9IGFycmF5TWV0aG9kKDMpXG4gICwgJGV2ZXJ5ICAgICAgICAgICA9IGFycmF5TWV0aG9kKDQpO1xuXG5pZighJC5ERVNDKXtcbiAgdHJ5IHtcbiAgICBJRThfRE9NX0RFRklORSA9IGRlZmluZVByb3BlcnR5KGNlbCgnZGl2JyksICd4JyxcbiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA4OyB9fVxuICAgICkueCA9PSA4O1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gICQuc2V0RGVzYyA9IGZ1bmN0aW9uKE8sIFAsIEF0dHJpYnV0ZXMpe1xuICAgIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gICAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICAgIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICAgIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylhc3NlcnRPYmplY3QoTylbUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgIHJldHVybiBPO1xuICB9O1xuICAkLmdldERlc2MgPSBmdW5jdGlvbihPLCBQKXtcbiAgICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgICAgcmV0dXJuIGdldE93bkRlc2NyaXB0b3IoTywgUCk7XG4gICAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICAgIGlmKGhhcyhPLCBQKSlyZXR1cm4gJC5kZXNjKCFPYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKE8sIFApLCBPW1BdKTtcbiAgfTtcbiAgJC5zZXREZXNjcyA9IGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbihPLCBQcm9wZXJ0aWVzKXtcbiAgICBhc3NlcnRPYmplY3QoTyk7XG4gICAgdmFyIGtleXMgICA9ICQuZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpID0gMFxuICAgICAgLCBQO1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpJC5zZXREZXNjKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICAgIHJldHVybiBPO1xuICB9O1xufVxuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhJC5ERVNDLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuNiAvIDE1LjIuMy4zIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkLmdldERlc2MsXG4gIC8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkLnNldERlc2MsXG4gIC8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogZGVmaW5lUHJvcGVydGllc1xufSk7XG5cbiAgLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGtleXMxID0gKCdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLCcgK1xuICAgICAgICAgICAgJ3RvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnKS5zcGxpdCgnLCcpXG4gIC8vIEFkZGl0aW9uYWwga2V5cyBmb3IgZ2V0T3duUHJvcGVydHlOYW1lc1xuICAsIGtleXMyID0ga2V5czEuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJylcbiAgLCBrZXlzTGVuMSA9IGtleXMxLmxlbmd0aDtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGNlbCgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGtleXNMZW4xXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZSgnPHNjcmlwdD5kb2N1bWVudC5GPU9iamVjdDwvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdC5wcm90b3R5cGVba2V5czFbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUdldEtleXMobmFtZXMsIGxlbmd0aCl7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3Qpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdChvYmplY3QpXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgICAgfiRpbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gRW1wdHkoKXt9XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbiAgZ2V0UHJvdG90eXBlT2Y6ICQuZ2V0UHJvdG8gPSAkLmdldFByb3RvIHx8IGZ1bmN0aW9uKE8pe1xuICAgIE8gPSBPYmplY3QoYXNzZXJ0LmRlZihPKSk7XG4gICAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gICAgaWYoaXNGdW5jdGlvbihPLmNvbnN0cnVjdG9yKSAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbiAgfSxcbiAgLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkLmdldE5hbWVzID0gJC5nZXROYW1lcyB8fCBjcmVhdGVHZXRLZXlzKGtleXMyLCBrZXlzMi5sZW5ndGgsIHRydWUpLFxuICAvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkLmNyZWF0ZSA9ICQuY3JlYXRlIHx8IGZ1bmN0aW9uKE8sIC8qPyovUHJvcGVydGllcyl7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZihPICE9PSBudWxsKXtcbiAgICAgIEVtcHR5LnByb3RvdHlwZSA9IGFzc2VydE9iamVjdChPKTtcbiAgICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2Ygc2hpbVxuICAgICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gICAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xuICB9LFxuICAvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbiAga2V5czogJC5nZXRLZXlzID0gJC5nZXRLZXlzIHx8IGNyZWF0ZUdldEtleXMoa2V5czEsIGtleXNMZW4xLCBmYWxzZSksXG4gIC8vIDE5LjEuMi4xNyAvIDE1LjIuMy44IE9iamVjdC5zZWFsKE8pXG4gIHNlYWw6IGZ1bmN0aW9uIHNlYWwoaXQpe1xuICAgIHJldHVybiBpdDsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi41IC8gMTUuMi4zLjkgT2JqZWN0LmZyZWV6ZShPKVxuICBmcmVlemU6IGZ1bmN0aW9uIGZyZWV6ZShpdCl7XG4gICAgcmV0dXJuIGl0OyAvLyA8LSBjYXBcbiAgfSxcbiAgLy8gMTkuMS4yLjE1IC8gMTUuMi4zLjEwIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpe1xuICAgIHJldHVybiBpdDsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi4xMyAvIDE1LjIuMy4xMSBPYmplY3QuaXNTZWFsZWQoTylcbiAgaXNTZWFsZWQ6IGZ1bmN0aW9uIGlzU2VhbGVkKGl0KXtcbiAgICByZXR1cm4gIWlzT2JqZWN0KGl0KTsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi4xMiAvIDE1LjIuMy4xMiBPYmplY3QuaXNGcm96ZW4oTylcbiAgaXNGcm96ZW46IGZ1bmN0aW9uIGlzRnJvemVuKGl0KXtcbiAgICByZXR1cm4gIWlzT2JqZWN0KGl0KTsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi4xMSAvIDE1LjIuMy4xMyBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpOyAvLyA8LSBjYXBcbiAgfVxufSk7XG5cbi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbiRkZWYoJGRlZi5QLCAnRnVuY3Rpb24nLCB7XG4gIGJpbmQ6IGZ1bmN0aW9uKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBmbiAgICAgICA9IGFzc2VydC5mbih0aGlzKVxuICAgICAgLCBwYXJ0QXJncyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZnVuY3Rpb24gYm91bmQoLyogYXJncy4uLiAqLyl7XG4gICAgICB2YXIgYXJncyAgID0gcGFydEFyZ3MuY29uY2F0KF9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICwgY29uc3RyID0gdGhpcyBpbnN0YW5jZW9mIGJvdW5kXG4gICAgICAgICwgY3R4ICAgID0gY29uc3RyID8gJC5jcmVhdGUoZm4ucHJvdG90eXBlKSA6IHRoYXRcbiAgICAgICAgLCByZXN1bHQgPSBpbnZva2UoZm4sIGFyZ3MsIGN0eCk7XG4gICAgICByZXR1cm4gY29uc3RyID8gY3R4IDogcmVzdWx0O1xuICAgIH1cbiAgICBpZihmbi5wcm90b3R5cGUpYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICAgIHJldHVybiBib3VuZDtcbiAgfVxufSk7XG5cbi8vIEZpeCBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZyBhbmQgRE9NIG9iamVjdHNcbmlmKCEoMCBpbiBPYmplY3QoJ3onKSAmJiAneidbMF0gPT0gJ3onKSl7XG4gICQuRVM1T2JqZWN0ID0gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbiAgfTtcbn1cblxudmFyIGJ1Z2d5U2xpY2UgPSB0cnVlO1xudHJ5IHtcbiAgaWYoaHRtbClfc2xpY2UuY2FsbChodG1sKTtcbiAgYnVnZ3lTbGljZSA9IGZhbHNlO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG4kZGVmKCRkZWYuUCArICRkZWYuRiAqIGJ1Z2d5U2xpY2UsICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpe1xuICAgIHZhciBsZW4gICA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKVxuICAgICAgLCBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZihrbGFzcyA9PSAnQXJyYXknKXJldHVybiBfc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgID0gdG9JbmRleChiZWdpbiwgbGVuKVxuICAgICAgLCB1cFRvICAgPSB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBzaXplICAgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpXG4gICAgICAsIGNsb25lZCA9IEFycmF5KHNpemUpXG4gICAgICAsIGkgICAgICA9IDA7XG4gICAgZm9yKDsgaSA8IHNpemU7IGkrKyljbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcblxuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiAoJC5FUzVPYmplY3QgIT0gT2JqZWN0KSwgJ0FycmF5Jywge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKCl7XG4gICAgcmV0dXJuIF9qb2luLmFwcGx5KCQuRVM1T2JqZWN0KHRoaXMpLCBhcmd1bWVudHMpO1xuICB9XG59KTtcblxuLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbiRkZWYoJGRlZi5TLCAnQXJyYXknLCB7XG4gIGlzQXJyYXk6IGZ1bmN0aW9uKGFyZyl7XG4gICAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlSZWR1Y2UoaXNSaWdodCl7XG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFja2ZuLCBtZW1vKXtcbiAgICBhc3NlcnQuZm4oY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAgICwgaSAgICAgID0gaXNSaWdodCA/IC0xIDogMTtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMilmb3IoOzspe1xuICAgICAgaWYoaW5kZXggaW4gTyl7XG4gICAgICAgIG1lbW8gPSBPW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYXNzZXJ0KGlzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXgsICdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICAgIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBPKXtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIE9baW5kZXhdLCBpbmRleCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufVxuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6ICQuZWFjaCA9ICQuZWFjaCB8fCBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfSxcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBjcmVhdGVBcnJheVJlZHVjZShmYWxzZSksXG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogY3JlYXRlQXJyYXlSZWR1Y2UodHJ1ZSksXG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2YoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5kZXhPZih0aGlzLCBlbCwgYXJndW1lbnRzWzFdKTtcbiAgfSxcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbihlbCwgZnJvbUluZGV4IC8qID0gQFsqLTFdICovKXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IGxlbmd0aCAtIDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpaW5kZXggPSBNYXRoLm1pbihpbmRleCwgJC50b0ludGVnZXIoZnJvbUluZGV4KSk7XG4gICAgaWYoaW5kZXggPCAwKWluZGV4ID0gdG9MZW5ndGgobGVuZ3RoICsgaW5kZXgpO1xuICAgIGZvcig7aW5kZXggPj0gMDsgaW5kZXgtLSlpZihpbmRleCBpbiBPKWlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gaW5kZXg7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcblxuLy8gMjEuMS4zLjI1IC8gMTUuNS40LjIwIFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHt0cmltOiByZXF1aXJlKCcuLyQucmVwbGFjZXInKSgvXlxccyooW1xcc1xcU10qXFxTKT9cXHMqJC8sICckMScpfSk7XG5cbi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxuJGRlZigkZGVmLlMsICdEYXRlJywge25vdzogZnVuY3Rpb24oKXtcbiAgcmV0dXJuICtuZXcgRGF0ZTtcbn19KTtcblxuZnVuY3Rpb24gbHoobnVtKXtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59XG5cbi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG4vLyBQaGFudG9tSlMgYW5kIG9sZCB3ZWJraXQgaGFkIGEgYnJva2VuIERhdGUgaW1wbGVtZW50YXRpb24uXG52YXIgZGF0ZSAgICAgICA9IG5ldyBEYXRlKC01ZTEzIC0gMSlcbiAgLCBicm9rZW5EYXRlID0gIShkYXRlLnRvSVNPU3RyaW5nICYmIGRhdGUudG9JU09TdHJpbmcoKSA9PSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJ1xuICAgICAgJiYgcmVxdWlyZSgnLi8kLnRocm93cycpKGZ1bmN0aW9uKCl7IG5ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKTsgfSkpO1xuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBicm9rZW5EYXRlLCAnRGF0ZScsIHt0b0lTT1N0cmluZzogZnVuY3Rpb24oKXtcbiAgaWYoIWlzRmluaXRlKHRoaXMpKXRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXNcbiAgICAsIHkgPSBkLmdldFVUQ0Z1bGxZZWFyKClcbiAgICAsIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gICAgLCBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufX0pO1xuXG5pZihjbGFzc29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ09iamVjdCcpY29mLmNsYXNzb2YgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0YWcgPSBjbGFzc29mKGl0KTtcbiAgcmV0dXJuIHRhZyA9PSAnT2JqZWN0JyAmJiBpc0Z1bmN0aW9uKGl0LmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHRhZztcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCB0b0luZGV4ID0gJC50b0luZGV4O1xuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4gIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xuICAgIHZhciBPICAgICA9IE9iamVjdCgkLmFzc2VydERlZmluZWQodGhpcykpXG4gICAgICAsIGxlbiAgID0gJC50b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxuICAgICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAgICwgZW5kICAgPSBhcmd1bWVudHNbMl1cbiAgICAgICwgZmluICAgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIGNvdW50ID0gTWF0aC5taW4oZmluIC0gZnJvbSwgbGVuIC0gdG8pXG4gICAgICAsIGluYyAgID0gMTtcbiAgICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xuICAgICAgaW5jICA9IC0xO1xuICAgICAgZnJvbSA9IGZyb20gKyBjb3VudCAtIDE7XG4gICAgICB0byAgID0gdG8gICArIGNvdW50IC0gMTtcbiAgICB9XG4gICAgd2hpbGUoY291bnQtLSA+IDApe1xuICAgICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcbiAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgdG8gICArPSBpbmM7XG4gICAgICBmcm9tICs9IGluYztcbiAgICB9IHJldHVybiBPO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoJ2NvcHlXaXRoaW4nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvSW5kZXggPSAkLnRvSW5kZXg7XG4kZGVmKCRkZWYuUCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbiAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgTyAgICAgID0gT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZCh0aGlzKSlcbiAgICAgICwgbGVuZ3RoID0gJC50b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChhcmd1bWVudHNbMV0sIGxlbmd0aClcbiAgICAgICwgZW5kICAgID0gYXJndW1lbnRzWzJdXG4gICAgICAsIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCk7XG4gICAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICAgIHJldHVybiBPO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoJ2ZpbGwnKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciBLRVkgICAgPSAnZmluZEluZGV4J1xuICAsICRkZWYgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGZvcmNlZCA9IHRydWVcbiAgLCAkZmluZCAgPSByZXF1aXJlKCcuLyQuYXJyYXktbWV0aG9kcycpKDYpO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi8kLnVuc2NvcGUnKShLRVkpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciBLRVkgICAgPSAnZmluZCdcbiAgLCAkZGVmICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBmb3JjZWQgPSB0cnVlXG4gICwgJGZpbmQgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKSg1KTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi8kLnVuc2NvcGUnKShLRVkpOyIsInZhciAkICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3R4ICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRpdGVyID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIGNhbGwgID0gcmVxdWlyZSgnLi8kLml0ZXItY2FsbCcpO1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSBPYmplY3QoJC5hc3NlcnREZWZpbmVkKGFycmF5TGlrZSkpXG4gICAgICAsIG1hcGZuICAgPSBhcmd1bWVudHNbMV1cbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgZiAgICAgICA9IG1hcHBpbmcgPyBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMikgOiB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKCRpdGVyLmlzKE8pKXtcbiAgICAgIGl0ZXJhdG9yID0gJGl0ZXIuZ2V0KE8pO1xuICAgICAgLy8gc3RyYW5nZSBJRSBxdWlya3MgbW9kZSBidWcgLT4gdXNlIHR5cGVvZiBpbnN0ZWFkIG9mIGlzRnVuY3Rpb25cbiAgICAgIHJlc3VsdCAgID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KTtcbiAgICAgIGZvcig7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgZiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdHJhbmdlIElFIHF1aXJrcyBtb2RlIGJ1ZyAtPiB1c2UgdHlwZW9mIGluc3RlYWQgb2YgaXNGdW5jdGlvblxuICAgICAgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShsZW5ndGggPSAkLnRvTGVuZ3RoKE8ubGVuZ3RoKSk7XG4gICAgICBmb3IoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gZihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCJ2YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgc2V0VW5zY29wZSA9IHJlcXVpcmUoJy4vJC51bnNjb3BlJylcbiAgLCBJVEVSICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ2l0ZXInKVxuICAsICRpdGVyICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcicpXG4gICwgc3RlcCAgICAgICA9ICRpdGVyLnN0ZXBcbiAgLCBJdGVyYXRvcnMgID0gJGl0ZXIuSXRlcmF0b3JzO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAkLnNldCh0aGlzLCBJVEVSLCB7bzogJC50b09iamVjdChpdGVyYXRlZCksIGk6IDAsIGs6IGtpbmR9KTtcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIGl0ZXIgID0gdGhpc1tJVEVSXVxuICAgICwgTyAgICAgPSBpdGVyLm9cbiAgICAsIGtpbmQgID0gaXRlci5rXG4gICAgLCBpbmRleCA9IGl0ZXIuaSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgaXRlci5vID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5zZXRVbnNjb3BlKCdrZXlzJyk7XG5zZXRVbnNjb3BlKCd2YWx1ZXMnKTtcbnNldFVuc2NvcGUoJ2VudHJpZXMnKTsiLCJ2YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbiRkZWYoJGRlZi5TLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgIC8vIHN0cmFuZ2UgSUUgcXVpcmtzIG1vZGUgYnVnIC0+IHVzZSB0eXBlb2YgaW5zdGVhZCBvZiBpc0Z1bmN0aW9uXG4gICAgICAsIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkobGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwicmVxdWlyZSgnLi8kLnNwZWNpZXMnKShBcnJheSk7IiwidmFyICQgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIEhBU19JTlNUQU5DRSAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2hhc0luc3RhbmNlJylcbiAgLCBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZighKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkkLnNldERlc2MoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZighJC5pc0Z1bmN0aW9uKHRoaXMpIHx8ICEkLmlzT2JqZWN0KE8pKXJldHVybiBmYWxzZTtcbiAgaWYoISQuaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKXJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUoTyA9ICQuZ2V0UHJvdG8oTykpaWYodGhpcy5wcm90b3R5cGUgPT09IE8pcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn19KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgTkFNRSA9ICduYW1lJ1xuICAsIHNldERlc2MgPSAkLnNldERlc2NcbiAgLCBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGdW5jdGlvblByb3RvIHx8ICQuRlcgJiYgJC5ERVNDICYmIHNldERlc2MoRnVuY3Rpb25Qcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKXtcbiAgICB2YXIgbWF0Y2ggPSBTdHJpbmcodGhpcykubWF0Y2goL15cXHMqZnVuY3Rpb24gKFteIChdKikvKVxuICAgICAgLCBuYW1lICA9IG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICAkLmhhcyh0aGlzLCBOQU1FKSB8fCBzZXREZXNjKHRoaXMsIE5BTUUsICQuZGVzYyg1LCBuYW1lKSk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICQuaGFzKHRoaXMsIE5BTUUpIHx8IHNldERlc2ModGhpcywgTkFNRSwgJC5kZXNjKDAsIHZhbHVlKSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50c1swXSk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpOyIsInZhciBJbmZpbml0eSA9IDEgLyAwXG4gICwgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBFICAgICA9IE1hdGguRVxuICAsIHBvdyAgID0gTWF0aC5wb3dcbiAgLCBhYnMgICA9IE1hdGguYWJzXG4gICwgZXhwICAgPSBNYXRoLmV4cFxuICAsIGxvZyAgID0gTWF0aC5sb2dcbiAgLCBzcXJ0ICA9IE1hdGguc3FydFxuICAsIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yXG4gICwgRVBTSUxPTiAgID0gcG93KDIsIC01MilcbiAgLCBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKVxuICAsIE1BWDMyICAgICA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpXG4gICwgTUlOMzIgICAgID0gcG93KDIsIC0xMjYpO1xuZnVuY3Rpb24gcm91bmRUaWVzVG9FdmVuKG4pe1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59XG5cbi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbmZ1bmN0aW9uIHNpZ24oeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn1cbi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbmZ1bmN0aW9uIGFzaW5oKHgpe1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcbn1cbi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG5mdW5jdGlvbiBleHBtMSh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IGV4cCh4KSAtIDE7XG59XG5cbiRkZWYoJGRlZi5TLCAnTWF0aCcsIHtcbiAgLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IGlzRmluaXRlKHgpID8gbG9nKHggLyBFICsgc3FydCh4ICsgMSkgKiBzcXJ0KHggLSAxKSAvIEUpICsgMSA6IHg7XG4gIH0sXG4gIC8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbiAgYXNpbmg6IGFzaW5oLFxuICAvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBsb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfSxcbiAgLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCl7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIHBvdyhhYnMoeCksIDEgLyAzKTtcbiAgfSxcbiAgLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpe1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBmbG9vcihsb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9LFxuICAvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfSxcbiAgLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbiAgZXhwbTE6IGV4cG0xLFxuICAvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbiAgZnJvdW5kOiBmdW5jdGlvbiBmcm91bmQoeCl7XG4gICAgdmFyICRhYnMgID0gYWJzKHgpXG4gICAgICAsICRzaWduID0gc2lnbih4KVxuICAgICAgLCBhLCByZXN1bHQ7XG4gICAgaWYoJGFicyA8IE1JTjMyKXJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gICAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICAgIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAgIGlmKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gICAgcmV0dXJuICRzaWduICogcmVzdWx0O1xuICB9LFxuICAvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBsZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgbGVuKXtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZihsYXJnIDwgYXJnKXtcbiAgICAgICAgZGl2ICA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSAgPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmKGFyZyA+IDApe1xuICAgICAgICBkaXYgID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBzcXJ0KHN1bSk7XG4gIH0sXG4gIC8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUludDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJbnQxNiAmIHhuXG4gICAgICAsIHlsID0gVUludDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSW50MTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSW50MTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfSxcbiAgLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbiAgbG9nMXA6IGZ1bmN0aW9uIGxvZzFwKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IGxvZygxICsgeCk7XG4gIH0sXG4gIC8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KXtcbiAgICByZXR1cm4gbG9nKHgpIC8gTWF0aC5MTjEwO1xuICB9LFxuICAvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCl7XG4gICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4yO1xuICB9LFxuICAvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG4gIHNpZ246IHNpZ24sXG4gIC8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KXtcbiAgICByZXR1cm4gYWJzKHggPSAreCkgPCAxID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDIgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChFIC8gMik7XG4gIH0sXG4gIC8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KXtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcbiAgICAgICwgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9LFxuICAvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpe1xuICAgIHJldHVybiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBpc09iamVjdCAgID0gJC5pc09iamVjdFxuICAsIGlzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb25cbiAgLCBOVU1CRVIgICAgID0gJ051bWJlcidcbiAgLCAkTnVtYmVyICAgID0gJC5nW05VTUJFUl1cbiAgLCBCYXNlICAgICAgID0gJE51bWJlclxuICAsIHByb3RvICAgICAgPSAkTnVtYmVyLnByb3RvdHlwZTtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKGl0KXtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKGlzRnVuY3Rpb24oZm4gPSBpdC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKGlzRnVuY3Rpb24oZm4gPSBpdC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBudW1iZXJcIik7XG59XG5mdW5jdGlvbiB0b051bWJlcihpdCl7XG4gIGlmKGlzT2JqZWN0KGl0KSlpdCA9IHRvUHJpbWl0aXZlKGl0KTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIgJiYgaXQuY2hhckNvZGVBdCgwKSA9PSA0OCl7XG4gICAgdmFyIGJpbmFyeSA9IGZhbHNlO1xuICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgIGNhc2UgNjYgOiBjYXNlIDk4ICA6IGJpbmFyeSA9IHRydWU7XG4gICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByZXR1cm4gcGFyc2VJbnQoaXQuc2xpY2UoMiksIGJpbmFyeSA/IDIgOiA4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn1cbmlmKCQuRlcgJiYgISgkTnVtYmVyKCcwbzEnKSAmJiAkTnVtYmVyKCcwYjEnKSkpe1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKGl0KXtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mICROdW1iZXIgPyBuZXcgQmFzZSh0b051bWJlcihpdCkpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICAkLmVhY2guY2FsbCgkLkRFU0MgPyAkLmdldE5hbWVzKEJhc2UpIDogKFxuICAgICAgLy8gRVMzOlxuICAgICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICAgKS5zcGxpdCgnLCcpLCBmdW5jdGlvbihrZXkpe1xuICAgICAgaWYoJC5oYXMoQmFzZSwga2V5KSAmJiAhJC5oYXMoJE51bWJlciwga2V5KSl7XG4gICAgICAgICQuc2V0RGVzYygkTnVtYmVyLCBrZXksICQuZ2V0RGVzYyhCYXNlLCBrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi8kLnJlZGVmJykoJC5nLCBOVU1CRVIsICROdW1iZXIpO1xufSIsInZhciAkICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBhYnMgICA9IE1hdGguYWJzXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yXG4gICwgX2lzRmluaXRlID0gJC5nLmlzRmluaXRlXG4gICwgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmY7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTE7XG5mdW5jdGlvbiBpc0ludGVnZXIoaXQpe1xuICByZXR1cm4gISQuaXNPYmplY3QoaXQpICYmIF9pc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn1cbiRkZWYoJGRlZi5TLCAnTnVtYmVyJywge1xuICAvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxuICBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpLFxuICAvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpe1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfSxcbiAgLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG4gIGlzSW50ZWdlcjogaXNJbnRlZ2VyLFxuICAvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKXtcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfSxcbiAgLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcil7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gIH0sXG4gIC8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIE1BWF9TQUZFX0lOVEVHRVI6IE1BWF9TQUZFX0lOVEVHRVIsXG4gIC8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuICBNSU5fU0FGRV9JTlRFR0VSOiAtTUFYX1NBRkVfSU5URUdFUixcbiAgLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiAgcGFyc2VGbG9hdDogcGFyc2VGbG9hdCxcbiAgLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuICBwYXJzZUludDogcGFyc2VJbnRcbn0pOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbiRkZWYoJGRlZi5TLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi8kLmFzc2lnbicpfSk7IiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIGlzOiByZXF1aXJlKCcuLyQuc2FtZScpXG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldH0pOyIsInZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpc09iamVjdCA9ICQuaXNPYmplY3RcbiAgLCB0b09iamVjdCA9ICQudG9PYmplY3Q7XG4kLmVhY2guY2FsbCgoJ2ZyZWV6ZSxzZWFsLHByZXZlbnRFeHRlbnNpb25zLGlzRnJvemVuLGlzU2VhbGVkLGlzRXh0ZW5zaWJsZSwnICtcbiAgJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcixnZXRQcm90b3R5cGVPZixrZXlzLGdldE93blByb3BlcnR5TmFtZXMnKS5zcGxpdCgnLCcpXG4sIGZ1bmN0aW9uKEtFWSwgSUQpe1xuICB2YXIgZm4gICAgID0gKCQuY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGZvcmNlZCA9IDBcbiAgICAsIG1ldGhvZCA9IHt9O1xuICBtZXRob2RbS0VZXSA9IElEID09IDAgPyBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBpdDtcbiAgfSA6IElEID09IDEgPyBmdW5jdGlvbiBzZWFsKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogaXQ7XG4gIH0gOiBJRCA9PSAyID8gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBpdDtcbiAgfSA6IElEID09IDMgPyBmdW5jdGlvbiBpc0Zyb3plbihpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IHRydWU7XG4gIH0gOiBJRCA9PSA0ID8gZnVuY3Rpb24gaXNTZWFsZWQoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiB0cnVlO1xuICB9IDogSUQgPT0gNSA/IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGZhbHNlO1xuICB9IDogSUQgPT0gNiA/IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgICByZXR1cm4gZm4odG9PYmplY3QoaXQpLCBrZXkpO1xuICB9IDogSUQgPT0gNyA/IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gZm4oT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZChpdCkpKTtcbiAgfSA6IElEID09IDggPyBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gZm4odG9PYmplY3QoaXQpKTtcbiAgfSA6IHJlcXVpcmUoJy4vJC5nZXQtbmFtZXMnKS5nZXQ7XG4gIHRyeSB7XG4gICAgZm4oJ3onKTtcbiAgfSBjYXRjaChlKXtcbiAgICBmb3JjZWQgPSAxO1xuICB9XG4gICRkZWYoJGRlZi5TICsgJGRlZi5GICogZm9yY2VkLCAnT2JqZWN0JywgbWV0aG9kKTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIHRtcCA9IHt9O1xudG1wW3JlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZihyZXF1aXJlKCcuLyQnKS5GVyAmJiBjb2YodG1wKSAhPSAneicpe1xuICByZXF1aXJlKCcuLyQucmVkZWYnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY29mLmNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3R4ICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgYXNzZXJ0ICAgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JylcbiAgLCBmb3JPZiAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHNldFByb3RvID0gcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldFxuICAsIHNhbWUgICAgID0gcmVxdWlyZSgnLi8kLnNhbWUnKVxuICAsIHNwZWNpZXMgID0gcmVxdWlyZSgnLi8kLnNwZWNpZXMnKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJylcbiAgLCBSRUNPUkQgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdyZWNvcmQnKVxuICAsIFBST01JU0UgID0gJ1Byb21pc2UnXG4gICwgZ2xvYmFsICAgPSAkLmdcbiAgLCBwcm9jZXNzICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgYXNhcCAgICAgPSBwcm9jZXNzICYmIHByb2Nlc3MubmV4dFRpY2sgfHwgcmVxdWlyZSgnLi8kLnRhc2snKS5zZXRcbiAgLCBQICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIGlzRnVuY3Rpb24gICAgID0gJC5pc0Z1bmN0aW9uXG4gICwgaXNPYmplY3QgICAgICAgPSAkLmlzT2JqZWN0XG4gICwgYXNzZXJ0RnVuY3Rpb24gPSBhc3NlcnQuZm5cbiAgLCBhc3NlcnRPYmplY3QgICA9IGFzc2VydC5vYmpcbiAgLCBXcmFwcGVyO1xuXG5mdW5jdGlvbiB0ZXN0UmVzb2x2ZShzdWIpe1xuICB2YXIgdGVzdCA9IG5ldyBQKGZ1bmN0aW9uKCl7fSk7XG4gIGlmKHN1Yil0ZXN0LmNvbnN0cnVjdG9yID0gT2JqZWN0O1xuICByZXR1cm4gUC5yZXNvbHZlKHRlc3QpID09PSB0ZXN0O1xufVxuXG52YXIgdXNlTmF0aXZlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHdvcmtzID0gZmFsc2U7XG4gIGZ1bmN0aW9uIFAyKHgpe1xuICAgIHZhciBzZWxmID0gbmV3IFAoeCk7XG4gICAgc2V0UHJvdG8oc2VsZiwgUDIucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0cnkge1xuICAgIHdvcmtzID0gaXNGdW5jdGlvbihQKSAmJiBpc0Z1bmN0aW9uKFAucmVzb2x2ZSkgJiYgdGVzdFJlc29sdmUoKTtcbiAgICBzZXRQcm90byhQMiwgUCk7XG4gICAgUDIucHJvdG90eXBlID0gJC5jcmVhdGUoUC5wcm90b3R5cGUsIHtjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBQMn19KTtcbiAgICAvLyBhY3R1YWwgRmlyZWZveCBoYXMgYnJva2VuIHN1YmNsYXNzIHN1cHBvcnQsIHRlc3QgdGhhdFxuICAgIGlmKCEoUDIucmVzb2x2ZSg1KS50aGVuKGZ1bmN0aW9uKCl7fSkgaW5zdGFuY2VvZiBQMikpe1xuICAgICAgd29ya3MgPSBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7IHdvcmtzID0gZmFsc2U7IH1cbiAgcmV0dXJuIHdvcmtzO1xufSgpO1xuXG4vLyBoZWxwZXJzXG5mdW5jdGlvbiBpc1Byb21pc2UoaXQpe1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICh1c2VOYXRpdmUgPyBjb2YuY2xhc3NvZihpdCkgPT0gJ1Byb21pc2UnIDogUkVDT1JEIGluIGl0KTtcbn1cbmZ1bmN0aW9uIHNhbWVDb25zdHJ1Y3RvcihhLCBiKXtcbiAgLy8gbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICBpZighJC5GVyAmJiBhID09PSBQICYmIGIgPT09IFdyYXBwZXIpcmV0dXJuIHRydWU7XG4gIHJldHVybiBzYW1lKGEsIGIpO1xufVxuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IoQyl7XG4gIHZhciBTID0gYXNzZXJ0T2JqZWN0KEMpW1NQRUNJRVNdO1xuICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcbn1cbmZ1bmN0aW9uIGlzVGhlbmFibGUoaXQpe1xuICB2YXIgdGhlbjtcbiAgaWYoaXNPYmplY3QoaXQpKXRoZW4gPSBpdC50aGVuO1xuICByZXR1cm4gaXNGdW5jdGlvbih0aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5vdGlmeShyZWNvcmQpe1xuICB2YXIgY2hhaW4gPSByZWNvcmQuYztcbiAgaWYoY2hhaW4ubGVuZ3RoKWFzYXAoZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSByZWNvcmQudlxuICAgICAgLCBvayAgICA9IHJlY29yZC5zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIGZ1bmN0aW9uIHJ1bihyZWFjdCl7XG4gICAgICB2YXIgY2IgPSBvayA/IHJlYWN0Lm9rIDogcmVhY3QuZmFpbFxuICAgICAgICAsIHJldCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGNiKXtcbiAgICAgICAgICBpZighb2spcmVjb3JkLmggPSB0cnVlO1xuICAgICAgICAgIHJldCA9IGNiID09PSB0cnVlID8gdmFsdWUgOiBjYih2YWx1ZSk7XG4gICAgICAgICAgaWYocmV0ID09PSByZWFjdC5QKXtcbiAgICAgICAgICAgIHJlYWN0LnJlaihUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJldCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJldCwgcmVhY3QucmVzLCByZWFjdC5yZWopO1xuICAgICAgICAgIH0gZWxzZSByZWFjdC5yZXMocmV0KTtcbiAgICAgICAgfSBlbHNlIHJlYWN0LnJlaih2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgIHJlYWN0LnJlaihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBjaGFpbi5sZW5ndGggPSAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzVW5oYW5kbGVkKHByb21pc2Upe1xuICB2YXIgcmVjb3JkID0gcHJvbWlzZVtSRUNPUkRdXG4gICAgLCBjaGFpbiAgPSByZWNvcmQuYSB8fCByZWNvcmQuY1xuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVhY3Q7XG4gIGlmKHJlY29yZC5oKXJldHVybiBmYWxzZTtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3QgPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0LmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0LlApKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICRyZWplY3QodmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpc1xuICAgICwgcHJvbWlzZTtcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHJlY29yZC52ID0gdmFsdWU7XG4gIHJlY29yZC5zID0gMjtcbiAgcmVjb3JkLmEgPSByZWNvcmQuYy5zbGljZSgpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgYXNhcChmdW5jdGlvbigpe1xuICAgICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSA9IHJlY29yZC5wKSl7XG4gICAgICAgIGlmKGNvZihwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoZ2xvYmFsLmNvbnNvbGUgJiYgaXNGdW5jdGlvbihjb25zb2xlLmVycm9yKSl7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWNvcmQuYSA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfSwgMSk7XG4gIG5vdGlmeShyZWNvcmQpO1xufVxuZnVuY3Rpb24gJHJlc29sdmUodmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpc1xuICAgICwgdGhlbiwgd3JhcHBlcjtcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIHdyYXBwZXIgPSB7cjogcmVjb3JkLCBkOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgICAgIHJlY29yZC5zID0gMTtcbiAgICAgIG5vdGlmeShyZWNvcmQpO1xuICAgIH1cbiAgfSBjYXRjaChlcnIpe1xuICAgICRyZWplY3QuY2FsbCh3cmFwcGVyIHx8IHtyOiByZWNvcmQsIGQ6IGZhbHNlfSwgZXJyKTsgLy8gd3JhcFxuICB9XG59XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighdXNlTmF0aXZlKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFzc2VydEZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgcDogYXNzZXJ0Lmluc3QodGhpcywgUCwgUFJPTUlTRSksICAgICAgIC8vIDwtIHByb21pc2VcbiAgICAgIGM6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICAgIGE6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgICAgczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgICBkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gZG9uZVxuICAgICAgdjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICBoOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gaGFuZGxlZCByZWplY3Rpb25cbiAgICB9O1xuICAgICQuaGlkZSh0aGlzLCBSRUNPUkQsIHJlY29yZCk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgcmVjb3JkLCAxKSwgY3R4KCRyZWplY3QsIHJlY29yZCwgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbChyZWNvcmQsIGVycik7XG4gICAgfVxuICB9O1xuICByZXF1aXJlKCcuLyQubWl4JykoUC5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIFMgPSBhc3NlcnRPYmplY3QoYXNzZXJ0T2JqZWN0KHRoaXMpLmNvbnN0cnVjdG9yKVtTUEVDSUVTXTtcbiAgICAgIHZhciByZWFjdCA9IHtcbiAgICAgICAgb2s6ICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWUsXG4gICAgICAgIGZhaWw6IGlzRnVuY3Rpb24ob25SZWplY3RlZCkgID8gb25SZWplY3RlZCAgOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBwcm9taXNlID0gcmVhY3QuUCA9IG5ldyAoUyAhPSB1bmRlZmluZWQgPyBTIDogUCkoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgICByZWFjdC5yZXMgPSBhc3NlcnRGdW5jdGlvbihyZXMpO1xuICAgICAgICByZWFjdC5yZWogPSBhc3NlcnRGdW5jdGlvbihyZWopO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVjb3JkID0gdGhpc1tSRUNPUkRdO1xuICAgICAgcmVjb3JkLmMucHVzaChyZWFjdCk7XG4gICAgICBpZihyZWNvcmQuYSlyZWNvcmQuYS5wdXNoKHJlYWN0KTtcbiAgICAgIGlmKHJlY29yZC5zKW5vdGlmeShyZWNvcmQpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGV4cG9ydFxuJGRlZigkZGVmLkcgKyAkZGVmLlcgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCB7UHJvbWlzZTogUH0pO1xuY29mLnNldChQLCBQUk9NSVNFKTtcbnNwZWNpZXMoUCk7XG5zcGVjaWVzKFdyYXBwZXIgPSAkLmNvcmVbUFJPTUlTRV0pO1xuXG4vLyBzdGF0aWNzXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICF1c2VOYXRpdmUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocil7XG4gICAgcmV0dXJuIG5ldyAoZ2V0Q29uc3RydWN0b3IodGhpcykpKGZ1bmN0aW9uKHJlcywgcmVqKXsgcmVqKHIpOyB9KTtcbiAgfVxufSk7XG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICghdXNlTmF0aXZlIHx8IHRlc3RSZXNvbHZlKHRydWUpKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICByZXR1cm4gaXNQcm9taXNlKHgpICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKVxuICAgICAgPyB4IDogbmV3IHRoaXMoZnVuY3Rpb24ocmVzKXsgcmVzKHgpOyB9KTtcbiAgfVxufSk7XG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICEodXNlTmF0aXZlICYmIHJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICBQLmFsbChpdGVyKVsnY2F0Y2gnXShmdW5jdGlvbigpe30pO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICA9IGdldENvbnN0cnVjdG9yKHRoaXMpXG4gICAgICAsIHZhbHVlcyA9IFtdO1xuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihyZXMsIHJlail7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIHZhbHVlcy5wdXNoLCB2YWx1ZXMpO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcbiAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xuICAgICAgaWYocmVtYWluaW5nKSQuZWFjaC5jYWxsKHZhbHVlcywgZnVuY3Rpb24ocHJvbWlzZSwgaW5kZXgpe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXMocmVzdWx0cyk7XG4gICAgICAgIH0sIHJlaik7XG4gICAgICB9KTtcbiAgICAgIGVsc2UgcmVzKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDID0gZ2V0Q29uc3RydWN0b3IodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKHJlcywgcmVqKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTsiLCJ2YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBzZXRQcm90byAgPSByZXF1aXJlKCcuLyQuc2V0LXByb3RvJylcbiAgLCAkaXRlciAgICAgPSByZXF1aXJlKCcuLyQuaXRlcicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgSVRFUiAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ2l0ZXInKVxuICAsIHN0ZXAgICAgICA9ICRpdGVyLnN0ZXBcbiAgLCBhc3NlcnQgICAgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JylcbiAgLCBpc09iamVjdCAgPSAkLmlzT2JqZWN0XG4gICwgZ2V0UHJvdG8gID0gJC5nZXRQcm90b1xuICAsICRSZWZsZWN0ICA9ICQuZy5SZWZsZWN0XG4gICwgX2FwcGx5ICAgID0gRnVuY3Rpb24uYXBwbHlcbiAgLCBhc3NlcnRPYmplY3QgPSBhc3NlcnQub2JqXG4gICwgX2lzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBfcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnNcbiAgLy8gSUUgVFAgaGFzIGJyb2tlbiBSZWZsZWN0LmVudW1lcmF0ZVxuICAsIGJ1Z2d5RW51bWVyYXRlID0gISgkUmVmbGVjdCAmJiAkUmVmbGVjdC5lbnVtZXJhdGUgJiYgSVRFUkFUT1IgaW4gJFJlZmxlY3QuZW51bWVyYXRlKHt9KSk7XG5cbmZ1bmN0aW9uIEVudW1lcmF0ZShpdGVyYXRlZCl7XG4gICQuc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgazogdW5kZWZpbmVkLCBpOiAwfSk7XG59XG4kaXRlci5jcmVhdGUoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIGl0ZXIgPSB0aGlzW0lURVJdXG4gICAgLCBrZXlzID0gaXRlci5rXG4gICAgLCBrZXk7XG4gIGlmKGtleXMgPT0gdW5kZWZpbmVkKXtcbiAgICBpdGVyLmsgPSBrZXlzID0gW107XG4gICAgZm9yKGtleSBpbiBpdGVyLm8pa2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgZG8ge1xuICAgIGlmKGl0ZXIuaSA+PSBrZXlzLmxlbmd0aClyZXR1cm4gc3RlcCgxKTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW2l0ZXIuaSsrXSkgaW4gaXRlci5vKSk7XG4gIHJldHVybiBzdGVwKDAsIGtleSk7XG59KTtcblxudmFyIHJlZmxlY3QgPSB7XG4gIC8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3Qpe1xuICAgIHJldHVybiBfYXBwbHkuY2FsbCh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCk7XG4gIH0sXG4gIC8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgdmFyIHByb3RvICAgID0gYXNzZXJ0LmZuKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdKS5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSAkLmNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAsIHJlc3VsdCAgID0gX2FwcGx5LmNhbGwodGFyZ2V0LCBpbnN0YW5jZSwgYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfSxcbiAgLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpe1xuICAgIGFzc2VydE9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICAkLnNldERlc2ModGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gJC5nZXREZXNjKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfSxcbiAgLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xuICAgIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgICAsIGRlc2MgPSAkLmdldERlc2MoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KSwgcHJvdG87XG4gICAgaWYoZGVzYylyZXR1cm4gJC5oYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgOiBkZXNjLmdldCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KSlcbiAgICAgID8gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiAkLmdldERlc2MoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfSxcbiAgLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KXtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xuICB9LFxuICAvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfSxcbiAgLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCl7XG4gICAgcmV0dXJuIF9pc0V4dGVuc2libGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xuICB9LFxuICAvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG4gIG93bktleXM6IHJlcXVpcmUoJy4vJC5vd24ta2V5cycpLFxuICAvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KXtcbiAgICBhc3NlcnRPYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYoX3ByZXZlbnRFeHRlbnNpb25zKV9wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIC8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG4gIHNldDogZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XG4gICAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM11cbiAgICAgICwgb3duRGVzYyAgPSAkLmdldERlc2MoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KVxuICAgICAgLCBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICAgIGlmKCFvd25EZXNjKXtcbiAgICAgIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KSkpe1xuICAgICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgb3duRGVzYyA9ICQuZGVzYygwKTtcbiAgICB9XG4gICAgaWYoJC5oYXMob3duRGVzYywgJ3ZhbHVlJykpe1xuICAgICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSAkLmdldERlc2MocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCAkLmRlc2MoMCk7XG4gICAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgICAgJC5zZXREZXNjKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbiAgfVxufTtcbi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxuaWYoc2V0UHJvdG8pcmVmbGVjdC5zZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pe1xuICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgdHJ5IHtcbiAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4kZGVmKCRkZWYuRywge1JlZmxlY3Q6IHt9fSk7XG5cbiRkZWYoJGRlZi5TICsgJGRlZi5GICogYnVnZ3lFbnVtZXJhdGUsICdSZWZsZWN0Jywge1xuICAvLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpe1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHJlZmxlY3QpOyIsInZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgICAgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJFJlZ0V4cCA9ICQuZy5SZWdFeHBcbiAgLCBCYXNlICAgID0gJFJlZ0V4cFxuICAsIHByb3RvICAgPSAkUmVnRXhwLnByb3RvdHlwZVxuICAsIHJlICAgICAgPSAvYS9nXG4gIC8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3RcbiAgLCBDT1JSRUNUX05FVyA9IG5ldyAkUmVnRXhwKHJlKSAhPT0gcmVcbiAgLy8gUmVnRXhwIGFsbG93cyBhIHJlZ2V4IHdpdGggZmxhZ3MgYXMgdGhlIHBhdHRlcm5cbiAgLCBBTExPV1NfUkVfV0lUSF9GTEFHUyA9IGZ1bmN0aW9uKCl7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAkUmVnRXhwKHJlLCAnaScpID09ICcvYS9pJztcbiAgICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIH0oKTtcbmlmKCQuRlcgJiYgJC5ERVNDKXtcbiAgaWYoIUNPUlJFQ1RfTkVXIHx8ICFBTExPV1NfUkVfV0lUSF9GTEFHUyl7XG4gICAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwYXR0ZXJuLCBmbGFncyl7XG4gICAgICB2YXIgcGF0dGVybklzUmVnRXhwICA9IGNvZihwYXR0ZXJuKSA9PSAnUmVnRXhwJ1xuICAgICAgICAsIGZsYWdzSXNVbmRlZmluZWQgPSBmbGFncyA9PT0gdW5kZWZpbmVkO1xuICAgICAgaWYoISh0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cCkgJiYgcGF0dGVybklzUmVnRXhwICYmIGZsYWdzSXNVbmRlZmluZWQpcmV0dXJuIHBhdHRlcm47XG4gICAgICByZXR1cm4gQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwYXR0ZXJuSXNSZWdFeHAgJiYgIWZsYWdzSXNVbmRlZmluZWQgPyBwYXR0ZXJuLnNvdXJjZSA6IHBhdHRlcm4sIGZsYWdzKVxuICAgICAgICA6IG5ldyBCYXNlKHBhdHRlcm5Jc1JlZ0V4cCA/IHBhdHRlcm4uc291cmNlIDogcGF0dGVyblxuICAgICAgICAgICwgcGF0dGVybklzUmVnRXhwICYmIGZsYWdzSXNVbmRlZmluZWQgPyBwYXR0ZXJuLmZsYWdzIDogZmxhZ3MpO1xuICAgIH07XG4gICAgJC5lYWNoLmNhbGwoJC5nZXROYW1lcyhCYXNlKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgIGtleSBpbiAkUmVnRXhwIHx8ICQuc2V0RGVzYygkUmVnRXhwLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oaXQpeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAgICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gICAgcmVxdWlyZSgnLi8kLnJlZGVmJykoJC5nLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG4gIH1cbiAgLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuICBpZigvLi9nLmZsYWdzICE9ICdnJykkLnNldERlc2MocHJvdG8sICdmbGFncycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiByZXF1aXJlKCcuLyQucmVwbGFjZXInKSgvXi4qXFwvKFxcdyopJC8sICckMScpXG4gIH0pO1xufVxucmVxdWlyZSgnLi8kLnNwZWNpZXMnKSgkUmVnRXhwKTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHNbMF0pOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykoZmFsc2UpO1xuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvTGVuZ3RoID0gJC50b0xlbmd0aDtcblxuLy8gc2hvdWxkIHRocm93IGVycm9yIG9uIHJlZ2V4XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqICFyZXF1aXJlKCcuLyQudGhyb3dzJykoZnVuY3Rpb24oKXsgJ3EnLmVuZHNXaXRoKC8uLyk7IH0pLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgdmFyIHRoYXQgPSBTdHJpbmcoJC5hc3NlcnREZWZpbmVkKHRoaXMpKVxuICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50c1sxXVxuICAgICAgLCBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcbiAgICAgICwgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XG4gICAgcmV0dXJuIHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoU3RyaW5nLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoU3RyaW5nO1xuICB9XG59KTsiLCJ2YXIgJGRlZiAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvSW5kZXggPSByZXF1aXJlKCcuLyQnKS50b0luZGV4XG4gICwgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRkZWYoJGRlZi5TICsgJGRlZi5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdXG4gICAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaSAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGxlbiA+IGkpe1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgcmV0dXJuICEhflN0cmluZygkLmFzc2VydERlZmluZWQodGhpcykpLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCJ2YXIgc2V0ICAgPSByZXF1aXJlKCcuLyQnKS5zZXRcbiAgLCAkYXQgICA9IHJlcXVpcmUoJy4vJC5zdHJpbmctYXQnKSh0cnVlKVxuICAsIElURVIgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ2l0ZXInKVxuICAsICRpdGVyID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIHN0ZXAgID0gJGl0ZXIuc3RlcDtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICBzZXQodGhpcywgSVRFUiwge286IFN0cmluZyhpdGVyYXRlZCksIGk6IDB9KTtcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cbiAgICAsIE8gICAgID0gaXRlci5vXG4gICAgLCBpbmRleCA9IGl0ZXIuaVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiBzdGVwKDEpO1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIGl0ZXIuaSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiBzdGVwKDAsIHBvaW50KTtcbn0pOyIsInZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpe1xuICAgIHZhciB0cGwgPSAkLnRvT2JqZWN0KGNhbGxTaXRlLnJhdylcbiAgICAgICwgbGVuID0gJC50b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBzbG4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlcyA9IFtdXG4gICAgICAsIGkgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBzbG4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwidmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi8kLnN0cmluZy1yZXBlYXQnKVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNvZiAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4vLyBzaG91bGQgdGhyb3cgZXJyb3Igb24gcmVnZXhcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogIXJlcXVpcmUoJy4vJC50aHJvd3MnKShmdW5jdGlvbigpeyAncScuc3RhcnRzV2l0aCgvLi8pOyB9KSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgdmFyIHRoYXQgID0gU3RyaW5nKCQuYXNzZXJ0RGVmaW5lZCh0aGlzKSlcbiAgICAgICwgaW5kZXggPSAkLnRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50c1sxXSwgdGhhdC5sZW5ndGgpKTtcbiAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XG4gICAgcmV0dXJuIHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBzZXRUYWcgICA9IHJlcXVpcmUoJy4vJC5jb2YnKS5zZXRcbiAgLCB1aWQgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsIHNoYXJlZCAgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpXG4gICwgJGRlZiAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcmVkZWYgICA9IHJlcXVpcmUoJy4vJC5yZWRlZicpXG4gICwga2V5T2YgICAgPSByZXF1aXJlKCcuLyQua2V5b2YnKVxuICAsIGVudW1LZXlzID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpXG4gICwgYXNzZXJ0T2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLm9ialxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZVxuICAsIERFU0MgICAgID0gJC5ERVNDXG4gICwgaGFzICAgICAgPSAkLmhhc1xuICAsICRjcmVhdGUgID0gJC5jcmVhdGVcbiAgLCBnZXREZXNjICA9ICQuZ2V0RGVzY1xuICAsIHNldERlc2MgID0gJC5zZXREZXNjXG4gICwgZGVzYyAgICAgPSAkLmRlc2NcbiAgLCAkbmFtZXMgICA9IHJlcXVpcmUoJy4vJC5nZXQtbmFtZXMnKVxuICAsIGdldE5hbWVzID0gJG5hbWVzLmdldFxuICAsIHRvT2JqZWN0ID0gJC50b09iamVjdFxuICAsICRTeW1ib2wgID0gJC5nLlN5bWJvbFxuICAsIHNldHRlciAgID0gZmFsc2VcbiAgLCBUQUcgICAgICA9IHVpZCgndGFnJylcbiAgLCBISURERU4gICA9IHVpZCgnaGlkZGVuJylcbiAgLCBfcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIHVzZU5hdGl2ZSA9ICQuaXNGdW5jdGlvbigkU3ltYm9sKTtcblxudmFyIHNldFN5bWJvbERlc2MgPSBERVNDID8gZnVuY3Rpb24oKXsgLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkXG4gIHRyeSB7XG4gICAgcmV0dXJuICRjcmVhdGUoc2V0RGVzYyh7fSwgSElEREVOLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzZXREZXNjKHRoaXMsIEhJRERFTiwge3ZhbHVlOiBmYWxzZX0pW0hJRERFTl07XG4gICAgICB9XG4gICAgfSkpW0hJRERFTl0gfHwgc2V0RGVzYztcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gICAgICB2YXIgcHJvdG9EZXNjID0gZ2V0RGVzYyhPYmplY3RQcm90bywga2V5KTtcbiAgICAgIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgICAgIHNldERlc2MoaXQsIGtleSwgRCk7XG4gICAgICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKXNldERlc2MoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbiAgICB9O1xuICB9XG59KCkgOiBzZXREZXNjO1xuXG5mdW5jdGlvbiB3cmFwKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSAkLnNldCgkY3JlYXRlKCRTeW1ib2wucHJvdG90eXBlKSwgVEFHLCB0YWcpO1xuICBERVNDICYmIHNldHRlciAmJiBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgZGVzYygxLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzeW07XG59XG5cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpc2V0RGVzYyhpdCwgSElEREVOLCBkZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9ICRjcmVhdGUoRCwge2VudW1lcmFibGU6IGRlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gc2V0RGVzYyhpdCwga2V5LCBEKTtcbn1cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhc3NlcnRPYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b09iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufVxuZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/ICRjcmVhdGUoaXQpIDogZGVmaW5lUHJvcGVydGllcygkY3JlYXRlKGl0KSwgUCk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IF9wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRoaXMsIGtleSk7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV1cbiAgICA/IEUgOiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b09iamVjdChpdCksIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn1cbmZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b09iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCF1c2VOYXRpdmUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICByZXR1cm4gd3JhcCh1aWQoYXJndW1lbnRzWzBdKSk7XG4gIH07XG4gICRyZWRlZigkU3ltYm9sLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpc1tUQUddO1xuICB9KTtcblxuICAkLmNyZWF0ZSAgICAgPSBjcmVhdGU7XG4gICQuc2V0RGVzYyAgICA9IGRlZmluZVByb3BlcnR5O1xuICAkLmdldERlc2MgICAgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICQuc2V0RGVzY3MgICA9IGRlZmluZVByb3BlcnRpZXM7XG4gICQuZ2V0TmFtZXMgICA9ICRuYW1lcy5nZXQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAkLmdldFN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoJC5ERVNDICYmICQuRlcpJHJlZGVmKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCBwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG59XG5cbnZhciBzeW1ib2xTdGF0aWNzID0ge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59O1xuLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXG4vLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXG4vLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3Jcbi8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxuLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2Vcbi8vIDE5LjQuMi45IFN5bWJvbC5zZWFyY2hcbi8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xuLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxuLy8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxuLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xuLy8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xuJC5lYWNoLmNhbGwoKFxuICAgICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsJyArXG4gICAgJ3NwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4gICkuc3BsaXQoJywnKSwgZnVuY3Rpb24oaXQpe1xuICAgIHZhciBzeW0gPSByZXF1aXJlKCcuLyQud2tzJykoaXQpO1xuICAgIHN5bWJvbFN0YXRpY3NbaXRdID0gdXNlTmF0aXZlID8gc3ltIDogd3JhcChzeW0pO1xuICB9XG4pO1xuXG5zZXR0ZXIgPSB0cnVlO1xuXG4kZGVmKCRkZWYuRyArICRkZWYuVywge1N5bWJvbDogJFN5bWJvbH0pO1xuXG4kZGVmKCRkZWYuUywgJ1N5bWJvbCcsIHN5bWJvbFN0YXRpY3MpO1xuXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICF1c2VOYXRpdmUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6IGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKCQuZy5KU09OLCAnSlNPTicsIHRydWUpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHdlYWsgICAgICA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGxlYWtTdG9yZSA9IHdlYWsubGVha1N0b3JlXG4gICwgSUQgICAgICAgID0gd2Vhay5JRFxuICAsIFdFQUsgICAgICA9IHdlYWsuV0VBS1xuICAsIGhhcyAgICAgICA9ICQuaGFzXG4gICwgaXNPYmplY3QgID0gJC5pc09iamVjdFxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCB0bXAgICAgICAgPSB7fTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1dlYWtNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50c1swXSk7IH07XG59LCB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgaWYoaXNPYmplY3Qoa2V5KSl7XG4gICAgICBpZighaXNFeHRlbnNpYmxlKGtleSkpcmV0dXJuIGxlYWtTdG9yZSh0aGlzKS5nZXQoa2V5KTtcbiAgICAgIGlmKGhhcyhrZXksIFdFQUspKXJldHVybiBrZXlbV0VBS11bdGhpc1tJRF1dO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCBrZXksIHZhbHVlKTtcbiAgfVxufSwgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmKG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICAkLmVhY2guY2FsbChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZXF1aXJlKCcuLyQucmVkZWYnKShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGxlYWt5IG1hcFxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIHZhciByZXN1bHQgPSBsZWFrU3RvcmUodGhpcylba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1dlYWtTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50c1swXSk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZiAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi8kLmFycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG4kZGVmKCRkZWYuUCwgJ0FycmF5Jywge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZG9tZW5pYy9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoJ2luY2x1ZGVzJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uLzkzNTM3ODFcbnZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgb3duS2V5cyA9IHJlcXVpcmUoJy4vJC5vd24ta2V5cycpO1xuXG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgPSAkLnRvT2JqZWN0KG9iamVjdClcbiAgICAgICwgcmVzdWx0ID0ge307XG4gICAgJC5lYWNoLmNhbGwob3duS2V5cyhPKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICQuc2V0RGVzYyhyZXN1bHQsIGtleSwgJC5kZXNjKDAsICQuZ2V0RGVzYyhPLCBrZXkpKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiLy8gaHR0cDovL2dvby5nbC9Ya0JyakRcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuZnVuY3Rpb24gY3JlYXRlT2JqZWN0VG9BcnJheShpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICB2YXIgTyAgICAgID0gJC50b09iamVjdChvYmplY3QpXG4gICAgICAsIGtleXMgICA9ICQuZ2V0S2V5cyhPKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpICAgICAgPSAwXG4gICAgICAsIHJlc3VsdCA9IEFycmF5KGxlbmd0aClcbiAgICAgICwga2V5O1xuICAgIGlmKGlzRW50cmllcyl3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IFtrZXkgPSBrZXlzW2krK10sIE9ba2V5XV07XG4gICAgZWxzZSB3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IE9ba2V5c1tpKytdXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogIGNyZWF0ZU9iamVjdFRvQXJyYXkoZmFsc2UpLFxuICBlbnRyaWVzOiBjcmVhdGVPYmplY3RUb0FycmF5KHRydWUpXG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9rYW5nYXgvOTY5ODEwMFxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ1JlZ0V4cCcsIHtcbiAgZXNjYXBlOiByZXF1aXJlKCcuLyQucmVwbGFjZXInKSgvKFtcXFxcXFwtW1xcXXt9KCkqKz8uLF4kfF0pL2csICdcXFxcJDEnLCB0cnVlKVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4ndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykodHJ1ZSk7XG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRwYWQgPSByZXF1aXJlKCcuLyQuc3RyaW5nLXBhZCcpO1xuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIGxwYWQ6IGZ1bmN0aW9uIGxwYWQobil7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbiwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcGFkID0gcmVxdWlyZSgnLi8kLnN0cmluZy1wYWQnKTtcbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICBycGFkOiBmdW5jdGlvbiBycGFkKG4pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG4sIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTsiLCIvLyBKYXZhU2NyaXB0IDEuNiAvIFN0cmF3bWFuIGFycmF5IHN0YXRpY3Mgc2hpbVxudmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkQXJyYXkgID0gJC5jb3JlLkFycmF5IHx8IEFycmF5XG4gICwgc3RhdGljcyA9IHt9O1xuZnVuY3Rpb24gc2V0U3RhdGljcyhrZXlzLCBsZW5ndGgpe1xuICAkLmVhY2guY2FsbChrZXlzLnNwbGl0KCcsJyksIGZ1bmN0aW9uKGtleSl7XG4gICAgaWYobGVuZ3RoID09IHVuZGVmaW5lZCAmJiBrZXkgaW4gJEFycmF5KXN0YXRpY3Nba2V5XSA9ICRBcnJheVtrZXldO1xuICAgIGVsc2UgaWYoa2V5IGluIFtdKXN0YXRpY3Nba2V5XSA9IHJlcXVpcmUoJy4vJC5jdHgnKShGdW5jdGlvbi5jYWxsLCBbXVtrZXldLCBsZW5ndGgpO1xuICB9KTtcbn1cbnNldFN0YXRpY3MoJ3BvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMnLCAxKTtcbnNldFN0YXRpY3MoJ2luZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMnLCAzKTtcbnNldFN0YXRpY3MoJ2pvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZiwnICtcbiAgICAgICAgICAgJ3JlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGwsdHVybicpO1xuJGRlZigkZGVmLlMsICdBcnJheScsIHN0YXRpY3MpOyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgJCAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIEl0ZXJhdG9ycyAgID0gcmVxdWlyZSgnLi8kLml0ZXInKS5JdGVyYXRvcnNcbiAgLCBJVEVSQVRPUiAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5XG4gICwgTkwgICAgICAgICAgPSAkLmcuTm9kZUxpc3RcbiAgLCBIVEMgICAgICAgICA9ICQuZy5IVE1MQ29sbGVjdGlvblxuICAsIE5MUHJvdG8gICAgID0gTkwgJiYgTkwucHJvdG90eXBlXG4gICwgSFRDUHJvdG8gICAgPSBIVEMgJiYgSFRDLnByb3RvdHlwZTtcbmlmKCQuRlcpe1xuICBpZihOTCAmJiAhKElURVJBVE9SIGluIE5MUHJvdG8pKSQuaGlkZShOTFByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICBpZihIVEMgJiYgIShJVEVSQVRPUiBpbiBIVENQcm90bykpJC5oaWRlKEhUQ1Byb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xufVxuSXRlcmF0b3JzLk5vZGVMaXN0ID0gSXRlcmF0b3JzLkhUTUxDb2xsZWN0aW9uID0gQXJyYXlWYWx1ZXM7IiwidmFyICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHRhc2sgPSByZXF1aXJlKCcuLyQudGFzaycpO1xuJGRlZigkZGVmLkcgKyAkZGVmLkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAgICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTsiLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpbnZva2UgICAgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBwYXJ0aWFsICAgPSByZXF1aXJlKCcuLyQucGFydGlhbCcpXG4gICwgbmF2aWdhdG9yID0gJC5nLm5hdmlnYXRvclxuICAsIE1TSUUgICAgICA9ICEhbmF2aWdhdG9yICYmIC9NU0lFIC5cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbmZ1bmN0aW9uIHdyYXAoc2V0KXtcbiAgcmV0dXJuIE1TSUUgPyBmdW5jdGlvbihmbiwgdGltZSAvKiwgLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIHNldChpbnZva2UoXG4gICAgICBwYXJ0aWFsLFxuICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgJC5pc0Z1bmN0aW9uKGZuKSA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59XG4kZGVmKCRkZWYuRyArICRkZWYuQiArICRkZWYuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogIHdyYXAoJC5nLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcCgkLmcuc2V0SW50ZXJ2YWwpXG59KTsiLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM1Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zdGF0aWNzLWFjY2VwdC1wcmltaXRpdmVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuc3RhdGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmxwYWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnJwYWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVnZXhwLmVzY2FwZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudG8tYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9qcy5hcnJheS5zdGF0aWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy8kJykuY29yZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID1cbiAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKFxuICAgICAgaW5uZXJGbiwgc2VsZiB8fCBudWxsLFxuICAgICAgbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pXG4gICAgKTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgLy8gVGhpcyBpbnZva2UgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiBhIHN0eWxlIHRoYXQgYXNzdW1lcyBzb21lXG4gICAgLy8gY2FsbGluZyBmdW5jdGlvbiAob3IgUHJvbWlzZSkgd2lsbCBoYW5kbGUgZXhjZXB0aW9ucy5cbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5lcmF0b3JbbWV0aG9kXShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudFxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oaW52b2tlTmV4dCwgaW52b2tlVGhyb3cpXG4gICAgICAgIDogcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBpbnZva2VOZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgdmFyIGludm9rZVRocm93ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIHZhciBpbnZva2VSZXR1cm4gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwicmV0dXJuXCIpO1xuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgZW5xdWV1ZVJlc3VsdCA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgICAgfSkgOiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbnZva2UobWV0aG9kLCBhcmcpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGVucXVldWVSZXN1bHQgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnlcbiAgICAgIC8vIGxhdGVyIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvciwgYW5kIGNhbGwgZ2VuZXJhdG9yLnJldHVybigpIHRvXG4gICAgICAvLyBhbGxvdyB0aGUgZ2VuZXJhdG9yIGEgY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgcHJldmlvdXNQcm9taXNlID0gZW5xdWV1ZVJlc3VsdC5jYXRjaChpbnZva2VSZXR1cm4pO1xuXG4gICAgICByZXR1cm4gZW5xdWV1ZVJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgY29udGV4dC5zZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgLy8gUHJlLWluaXRpYWxpemUgYXQgbGVhc3QgMjAgdGVtcG9yYXJ5IHZhcmlhYmxlcyB0byBlbmFibGUgaGlkZGVuXG4gICAgICAvLyBjbGFzcyBvcHRpbWl6YXRpb25zIGZvciBzaW1wbGUgZ2VuZXJhdG9ycy5cbiAgICAgIGZvciAodmFyIHRlbXBJbmRleCA9IDAsIHRlbXBOYW1lO1xuICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCB0ZW1wTmFtZSA9IFwidFwiICsgdGVtcEluZGV4KSB8fCB0ZW1wSW5kZXggPCAyMDtcbiAgICAgICAgICAgKyt0ZW1wSW5kZXgpIHtcbiAgICAgICAgdGhpc1t0ZW1wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvYmFiZWwvcG9seWZpbGxcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1jb3JlL3BvbHlmaWxsXCIpO1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gU3RyaW5nKHN0cmluZylcblxuICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aCAqIDJcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGggPj4+IDFcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbi8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG5CdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCB8IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpcXC1dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuICB2YXIgaSA9IDBcblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgyMDAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCIvKlxuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuT3JpZ2luYWwgTGlicmFyeSBcbiAgLSBDb3B5cmlnaHQgKGMpIE1hcmFrIFNxdWlyZXNcblxuQWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5XG4gLSBDb3B5cmlnaHQgKGMpIFNpbmRyZSBTb3JodXMgPHNpbmRyZXNvcmh1c0BnbWFpbC5jb20+IChzaW5kcmVzb3JodXMuY29tKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbiovXG5cbnZhciBjb2xvcnMgPSB7fTtcbm1vZHVsZVsnZXhwb3J0cyddID0gY29sb3JzO1xuXG5jb2xvcnMudGhlbWVzID0ge307XG5cbnZhciBhbnNpU3R5bGVzID0gY29sb3JzLnN0eWxlcyA9IHJlcXVpcmUoJy4vc3R5bGVzJyk7XG52YXIgZGVmaW5lUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblxuY29sb3JzLnN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCcuL3N5c3RlbS9zdXBwb3J0cy1jb2xvcnMnKTtcblxuaWYgKHR5cGVvZiBjb2xvcnMuZW5hYmxlZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBjb2xvcnMuZW5hYmxlZCA9IGNvbG9ycy5zdXBwb3J0c0NvbG9yO1xufVxuXG5jb2xvcnMuc3RyaXBDb2xvcnMgPSBjb2xvcnMuc3RyaXAgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gKFwiXCIgKyBzdHIpLnJlcGxhY2UoL1xceDFCXFxbXFxkK20vZywgJycpO1xufTtcblxuXG52YXIgc3R5bGl6ZSA9IGNvbG9ycy5zdHlsaXplID0gZnVuY3Rpb24gc3R5bGl6ZSAoc3RyLCBzdHlsZSkge1xuICBpZiAoIWNvbG9ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIHN0cisnJztcbiAgfVxuXG4gIHJldHVybiBhbnNpU3R5bGVzW3N0eWxlXS5vcGVuICsgc3RyICsgYW5zaVN0eWxlc1tzdHlsZV0uY2xvc2U7XG59XG5cbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xudmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UobWF0Y2hPcGVyYXRvcnNSZSwgICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gYnVpbGQoX3N0eWxlcykge1xuICB2YXIgYnVpbGRlciA9IGZ1bmN0aW9uIGJ1aWxkZXIoKSB7XG4gICAgcmV0dXJuIGFwcGx5U3R5bGUuYXBwbHkoYnVpbGRlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgYnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcbiAgLy8gX19wcm90b19fIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcbiAgLy8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlLlxuICBidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvO1xuICByZXR1cm4gYnVpbGRlcjtcbn1cblxudmFyIHN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgYW5zaVN0eWxlcy5ncmV5ID0gYW5zaVN0eWxlcy5ncmF5O1xuICBPYmplY3Qua2V5cyhhbnNpU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBhbnNpU3R5bGVzW2tleV0uY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwKGFuc2lTdHlsZXNba2V5XS5jbG9zZSksICdnJyk7XG4gICAgcmV0W2tleV0gPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkKHRoaXMuX3N0eWxlcy5jb25jYXQoa2V5KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59KSgpO1xuXG52YXIgcHJvdG8gPSBkZWZpbmVQcm9wcyhmdW5jdGlvbiBjb2xvcnMoKSB7fSwgc3R5bGVzKTtcblxuZnVuY3Rpb24gYXBwbHlTdHlsZSgpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBhcmdzTGVuICE9PSAwICYmIFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICBpZiAoYXJnc0xlbiA+IDEpIHtcbiAgICBmb3IgKHZhciBhID0gMTsgYSA8IGFyZ3NMZW47IGErKykge1xuICAgICAgc3RyICs9ICcgJyArIGFyZ3NbYV07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb2xvcnMuZW5hYmxlZCB8fCAhc3RyKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBuZXN0ZWRTdHlsZXMgPSB0aGlzLl9zdHlsZXM7XG5cbiAgdmFyIGkgPSBuZXN0ZWRTdHlsZXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGNvZGUgPSBhbnNpU3R5bGVzW25lc3RlZFN0eWxlc1tpXV07XG4gICAgc3RyID0gY29kZS5vcGVuICsgc3RyLnJlcGxhY2UoY29kZS5jbG9zZVJlLCBjb2RlLm9wZW4pICsgY29kZS5jbG9zZTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGhlbWUgKHRoZW1lKSB7XG4gIGZvciAodmFyIHN0eWxlIGluIHRoZW1lKSB7XG4gICAgKGZ1bmN0aW9uKHN0eWxlKXtcbiAgICAgIGNvbG9yc1tzdHlsZV0gPSBmdW5jdGlvbihzdHIpe1xuICAgICAgICBpZiAodHlwZW9mIHRoZW1lW3N0eWxlXSA9PT0gJ29iamVjdCcpe1xuICAgICAgICAgIHZhciBvdXQgPSBzdHI7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGVtZVtzdHlsZV0pe1xuICAgICAgICAgICAgb3V0ID0gY29sb3JzW3RoZW1lW3N0eWxlXVtpXV0ob3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3JzW3RoZW1lW3N0eWxlXV0oc3RyKTtcbiAgICAgIH07XG4gICAgfSkoc3R5bGUpXG4gIH1cbn1cblxuY29sb3JzLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbG9ycy50aGVtZXNbdGhlbWVdID0gcmVxdWlyZSh0aGVtZSk7XG4gICAgICBhcHBseVRoZW1lKGNvbG9ycy50aGVtZXNbdGhlbWVdKTtcbiAgICAgIHJldHVybiBjb2xvcnMudGhlbWVzW3RoZW1lXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhcHBseVRoZW1lKHRoZW1lKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIHJldCA9IHt9O1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXRbbmFtZV0gPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkKFtuYW1lXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBzZXF1ZW5jZXIgPSBmdW5jdGlvbiBzZXF1ZW5jZXIgKG1hcCwgc3RyKSB7XG4gIHZhciBleHBsb2RlZCA9IHN0ci5zcGxpdChcIlwiKSwgaSA9IDA7XG4gIGV4cGxvZGVkID0gZXhwbG9kZWQubWFwKG1hcCk7XG4gIHJldHVybiBleHBsb2RlZC5qb2luKFwiXCIpO1xufTtcblxuLy8gY3VzdG9tIGZvcm1hdHRlciBtZXRob2RzXG5jb2xvcnMudHJhcCA9IHJlcXVpcmUoJy4vY3VzdG9tL3RyYXAnKTtcbmNvbG9ycy56YWxnbyA9IHJlcXVpcmUoJy4vY3VzdG9tL3phbGdvJyk7XG5cbi8vIG1hcHNcbmNvbG9ycy5tYXBzID0ge307XG5jb2xvcnMubWFwcy5hbWVyaWNhID0gcmVxdWlyZSgnLi9tYXBzL2FtZXJpY2EnKTtcbmNvbG9ycy5tYXBzLnplYnJhID0gcmVxdWlyZSgnLi9tYXBzL3plYnJhJyk7XG5jb2xvcnMubWFwcy5yYWluYm93ID0gcmVxdWlyZSgnLi9tYXBzL3JhaW5ib3cnKTtcbmNvbG9ycy5tYXBzLnJhbmRvbSA9IHJlcXVpcmUoJy4vbWFwcy9yYW5kb20nKVxuXG5mb3IgKHZhciBtYXAgaW4gY29sb3JzLm1hcHMpIHtcbiAgKGZ1bmN0aW9uKG1hcCl7XG4gICAgY29sb3JzW21hcF0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2VyKGNvbG9ycy5tYXBzW21hcF0sIHN0cik7XG4gICAgfVxuICB9KShtYXApXG59XG5cbmRlZmluZVByb3BzKGNvbG9ycywgaW5pdCgpKTsiLCJtb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uIHJ1blRoZVRyYXAgKHRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIHRleHQgPSB0ZXh0IHx8IFwiUnVuIHRoZSB0cmFwLCBkcm9wIHRoZSBiYXNzXCI7XG4gIHRleHQgPSB0ZXh0LnNwbGl0KCcnKTtcbiAgdmFyIHRyYXAgPSB7XG4gICAgYTogW1wiXFx1MDA0MFwiLCBcIlxcdTAxMDRcIiwgXCJcXHUwMjNhXCIsIFwiXFx1MDI0NVwiLCBcIlxcdTAzOTRcIiwgXCJcXHUwMzliXCIsIFwiXFx1MDQxNFwiXSxcbiAgICBiOiBbXCJcXHUwMGRmXCIsIFwiXFx1MDE4MVwiLCBcIlxcdTAyNDNcIiwgXCJcXHUwMjZlXCIsIFwiXFx1MDNiMlwiLCBcIlxcdTBlM2ZcIl0sXG4gICAgYzogW1wiXFx1MDBhOVwiLCBcIlxcdTAyM2JcIiwgXCJcXHUwM2ZlXCJdLFxuICAgIGQ6IFtcIlxcdTAwZDBcIiwgXCJcXHUwMThhXCIsIFwiXFx1MDUwMFwiICwgXCJcXHUwNTAxXCIgLFwiXFx1MDUwMlwiLCBcIlxcdTA1MDNcIl0sXG4gICAgZTogW1wiXFx1MDBjYlwiLCBcIlxcdTAxMTVcIiwgXCJcXHUwMThlXCIsIFwiXFx1MDI1OFwiLCBcIlxcdTAzYTNcIiwgXCJcXHUwM2JlXCIsIFwiXFx1MDRiY1wiLCBcIlxcdTBhNmNcIl0sXG4gICAgZjogW1wiXFx1MDRmYVwiXSxcbiAgICBnOiBbXCJcXHUwMjYyXCJdLFxuICAgIGg6IFtcIlxcdTAxMjZcIiwgXCJcXHUwMTk1XCIsIFwiXFx1MDRhMlwiLCBcIlxcdTA0YmFcIiwgXCJcXHUwNGM3XCIsIFwiXFx1MDUwYVwiXSxcbiAgICBpOiBbXCJcXHUwZjBmXCJdLFxuICAgIGo6IFtcIlxcdTAxMzRcIl0sXG4gICAgazogW1wiXFx1MDEzOFwiLCBcIlxcdTA0YTBcIiwgXCJcXHUwNGMzXCIsIFwiXFx1MDUxZVwiXSxcbiAgICBsOiBbXCJcXHUwMTM5XCJdLFxuICAgIG06IFtcIlxcdTAyOGRcIiwgXCJcXHUwNGNkXCIsIFwiXFx1MDRjZVwiLCBcIlxcdTA1MjBcIiwgXCJcXHUwNTIxXCIsIFwiXFx1MGQ2OVwiXSxcbiAgICBuOiBbXCJcXHUwMGQxXCIsIFwiXFx1MDE0YlwiLCBcIlxcdTAxOWRcIiwgXCJcXHUwMzc2XCIsIFwiXFx1MDNhMFwiLCBcIlxcdTA0OGFcIl0sXG4gICAgbzogW1wiXFx1MDBkOFwiLCBcIlxcdTAwZjVcIiwgXCJcXHUwMGY4XCIsIFwiXFx1MDFmZVwiLCBcIlxcdTAyOThcIiwgXCJcXHUwNDdhXCIsIFwiXFx1MDVkZFwiLCBcIlxcdTA2ZGRcIiwgXCJcXHUwZTRmXCJdLFxuICAgIHA6IFtcIlxcdTAxZjdcIiwgXCJcXHUwNDhlXCJdLFxuICAgIHE6IFtcIlxcdTA5Y2RcIl0sXG4gICAgcjogW1wiXFx1MDBhZVwiLCBcIlxcdTAxYTZcIiwgXCJcXHUwMjEwXCIsIFwiXFx1MDI0Y1wiLCBcIlxcdTAyODBcIiwgXCJcXHUwNDJmXCJdLFxuICAgIHM6IFtcIlxcdTAwYTdcIiwgXCJcXHUwM2RlXCIsIFwiXFx1MDNkZlwiLCBcIlxcdTAzZThcIl0sXG4gICAgdDogW1wiXFx1MDE0MVwiLCBcIlxcdTAxNjZcIiwgXCJcXHUwMzczXCJdLFxuICAgIHU6IFtcIlxcdTAxYjFcIiwgXCJcXHUwNTRkXCJdLFxuICAgIHY6IFtcIlxcdTA1ZDhcIl0sXG4gICAgdzogW1wiXFx1MDQyOFwiLCBcIlxcdTA0NjBcIiwgXCJcXHUwNDdjXCIsIFwiXFx1MGQ3MFwiXSxcbiAgICB4OiBbXCJcXHUwNGIyXCIsIFwiXFx1MDRmZVwiLCBcIlxcdTA0ZmNcIiwgXCJcXHUwNGZkXCJdLFxuICAgIHk6IFtcIlxcdTAwYTVcIiwgXCJcXHUwNGIwXCIsIFwiXFx1MDRjYlwiXSxcbiAgICB6OiBbXCJcXHUwMWI1XCIsIFwiXFx1MDI0MFwiXVxuICB9XG4gIHRleHQuZm9yRWFjaChmdW5jdGlvbihjKXtcbiAgICBjID0gYy50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjaGFycyA9IHRyYXBbY10gfHwgW1wiIFwiXTtcbiAgICB2YXIgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiB0cmFwW2NdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXN1bHQgKz0gdHJhcFtjXVtyYW5kXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGM7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcblxufVxuIiwiLy8gcGxlYXNlIG5vXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uIHphbGdvKHRleHQsIG9wdGlvbnMpIHtcbiAgdGV4dCA9IHRleHQgfHwgXCIgICBoZSBpcyBoZXJlICAgXCI7XG4gIHZhciBzb3VsID0ge1xuICAgIFwidXBcIiA6IFtcbiAgICAgICfMjScsICfMjicsICfMhCcsICfMhScsXG4gICAgICAnzL8nLCAnzJEnLCAnzIYnLCAnzJAnLFxuICAgICAgJ82SJywgJ82XJywgJ82RJywgJ8yHJyxcbiAgICAgICfMiCcsICfMiicsICfNgicsICfMkycsXG4gICAgICAnzIgnLCAnzYonLCAnzYsnLCAnzYwnLFxuICAgICAgJ8yDJywgJ8yCJywgJ8yMJywgJ82QJyxcbiAgICAgICfMgCcsICfMgScsICfMiycsICfMjycsXG4gICAgICAnzJInLCAnzJMnLCAnzJQnLCAnzL0nLFxuICAgICAgJ8yJJywgJ82jJywgJ82kJywgJ82lJyxcbiAgICAgICfNpicsICfNpycsICfNqCcsICfNqScsXG4gICAgICAnzaonLCAnzasnLCAnzawnLCAnza0nLFxuICAgICAgJ82uJywgJ82vJywgJ8y+JywgJ82bJyxcbiAgICAgICfNhicsICfMmidcbiAgICBdLFxuICAgIFwiZG93blwiIDogW1xuICAgICAgJ8yWJywgJ8yXJywgJ8yYJywgJ8yZJyxcbiAgICAgICfMnCcsICfMnScsICfMnicsICfMnycsXG4gICAgICAnzKAnLCAnzKQnLCAnzKUnLCAnzKYnLFxuICAgICAgJ8ypJywgJ8yqJywgJ8yrJywgJ8ysJyxcbiAgICAgICfMrScsICfMricsICfMrycsICfMsCcsXG4gICAgICAnzLEnLCAnzLInLCAnzLMnLCAnzLknLFxuICAgICAgJ8y6JywgJ8y7JywgJ8y8JywgJ82FJyxcbiAgICAgICfNhycsICfNiCcsICfNiScsICfNjScsXG4gICAgICAnzY4nLCAnzZMnLCAnzZQnLCAnzZUnLFxuICAgICAgJ82WJywgJ82ZJywgJ82aJywgJ8yjJ1xuICAgIF0sXG4gICAgXCJtaWRcIiA6IFtcbiAgICAgICfMlScsICfMmycsICfMgCcsICfMgScsXG4gICAgICAnzZgnLCAnzKEnLCAnzKInLCAnzKcnLFxuICAgICAgJ8yoJywgJ8y0JywgJ8y1JywgJ8y2JyxcbiAgICAgICfNnCcsICfNnScsICfNnicsXG4gICAgICAnzZ8nLCAnzaAnLCAnzaInLCAnzLgnLFxuICAgICAgJ8y3JywgJ82hJywgJyDSiSdcbiAgICBdXG4gIH0sXG4gIGFsbCA9IFtdLmNvbmNhdChzb3VsLnVwLCBzb3VsLmRvd24sIHNvdWwubWlkKSxcbiAgemFsZ28gPSB7fTtcblxuICBmdW5jdGlvbiByYW5kb21OdW1iZXIocmFuZ2UpIHtcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzX2NoYXIoY2hhcmFjdGVyKSB7XG4gICAgdmFyIGJvb2wgPSBmYWxzZTtcbiAgICBhbGwuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICBib29sID0gKGkgPT09IGNoYXJhY3Rlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvb2w7XG4gIH1cbiAgXG5cbiAgZnVuY3Rpb24gaGVDb21lcyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnLCBjb3VudHMsIGw7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9uc1tcInVwXCJdID0gICB0eXBlb2Ygb3B0aW9uc1tcInVwXCJdICAgIT09ICd1bmRlZmluZWQnID8gb3B0aW9uc1tcInVwXCJdICAgOiB0cnVlO1xuICAgIG9wdGlvbnNbXCJtaWRcIl0gPSAgdHlwZW9mIG9wdGlvbnNbXCJtaWRcIl0gICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnNbXCJtaWRcIl0gIDogdHJ1ZTtcbiAgICBvcHRpb25zW1wiZG93blwiXSA9IHR5cGVvZiBvcHRpb25zW1wiZG93blwiXSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zW1wiZG93blwiXSA6IHRydWU7XG4gICAgb3B0aW9uc1tcInNpemVcIl0gPSB0eXBlb2Ygb3B0aW9uc1tcInNpemVcIl0gIT09ICd1bmRlZmluZWQnID8gb3B0aW9uc1tcInNpemVcIl0gOiBcIm1heGlcIjtcbiAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnJyk7XG4gICAgZm9yIChsIGluIHRleHQpIHtcbiAgICAgIGlmIChpc19jaGFyKGwpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdGV4dFtsXTtcbiAgICAgIGNvdW50cyA9IHtcInVwXCIgOiAwLCBcImRvd25cIiA6IDAsIFwibWlkXCIgOiAwfTtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5zaXplKSB7XG4gICAgICBjYXNlICdtaW5pJzpcbiAgICAgICAgY291bnRzLnVwID0gcmFuZG9tTnVtYmVyKDgpO1xuICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDIpO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXhpJzpcbiAgICAgICAgY291bnRzLnVwID0gcmFuZG9tTnVtYmVyKDE2KSArIDM7XG4gICAgICAgIGNvdW50cy5taWQgPSByYW5kb21OdW1iZXIoNCkgKyAxO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig2NCkgKyAzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcig4KSArIDE7XG4gICAgICAgIGNvdW50cy5taWQgPSByYW5kb21OdW1iZXIoNikgLyAyO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig4KSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyID0gW1widXBcIiwgXCJtaWRcIiwgXCJkb3duXCJdO1xuICAgICAgZm9yICh2YXIgZCBpbiBhcnIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJyW2RdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPD0gY291bnRzW2luZGV4XTsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnNbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBzb3VsW2luZGV4XVtyYW5kb21OdW1iZXIoc291bFtpbmRleF0ubGVuZ3RoKV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gZG9uJ3Qgc3VtbW9uIGhpbVxuICByZXR1cm4gaGVDb21lcyh0ZXh0LCBvcHRpb25zKTtcbn1cbiIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uICgpIHtcblxuICAvL1xuICAvLyBFeHRlbmRzIHByb3RvdHlwZSBvZiBuYXRpdmUgc3RyaW5nIG9iamVjdCB0byBhbGxvdyBmb3IgXCJmb29cIi5yZWQgc3ludGF4XG4gIC8vXG4gIHZhciBhZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChjb2xvciwgZnVuYykge1xuICAgIFN0cmluZy5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhjb2xvciwgZnVuYyk7XG4gIH07XG5cbiAgdmFyIHNlcXVlbmNlciA9IGZ1bmN0aW9uIHNlcXVlbmNlciAobWFwLCBzdHIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleHBsb2RlZCA9IHRoaXMuc3BsaXQoXCJcIiksIGkgPSAwO1xuICAgICAgICBleHBsb2RlZCA9IGV4cGxvZGVkLm1hcChtYXApO1xuICAgICAgICByZXR1cm4gZXhwbG9kZWQuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgfTtcblxuICBhZGRQcm9wZXJ0eSgnc3RyaXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbG9ycy5zdHJpcCh0aGlzKTtcbiAgfSk7XG5cbiAgYWRkUHJvcGVydHkoJ3N0cmlwQ29sb3JzJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2xvcnMuc3RyaXAodGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwidHJhcFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBjb2xvcnMudHJhcCh0aGlzKTtcbiAgfSk7XG5cbiAgYWRkUHJvcGVydHkoXCJ6YWxnb1wiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBjb2xvcnMuemFsZ28odGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwiemVicmFcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLnplYnJhKHRoaXMpO1xuICB9KTtcblxuICBhZGRQcm9wZXJ0eShcInJhaW5ib3dcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY29sb3JzLnJhaW5ib3codGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwicmFuZG9tXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGNvbG9ycy5yYW5kb20odGhpcyk7XG4gIH0pO1xuXG4gIGFkZFByb3BlcnR5KFwiYW1lcmljYVwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBjb2xvcnMuYW1lcmljYSh0aGlzKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBkZWZhdWx0IHN0eWxlcyBhbmQgY29sb3JzXG4gIC8vXG4gIHZhciB4ID0gT2JqZWN0LmtleXMoY29sb3JzLnN0eWxlcyk7XG4gIHguZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBhZGRQcm9wZXJ0eShzdHlsZSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvbG9ycy5zdHlsaXplKHRoaXMsIHN0eWxlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYXBwbHlUaGVtZSh0aGVtZSkge1xuICAgIC8vXG4gICAgLy8gUmVtYXJrOiBUaGlzIGlzIGEgbGlzdCBvZiBtZXRob2RzIHRoYXQgZXhpc3RcbiAgICAvLyBvbiBTdHJpbmcgdGhhdCB5b3Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUuXG4gICAgLy9cbiAgICB2YXIgc3RyaW5nUHJvdG90eXBlQmxhY2tsaXN0ID0gW1xuICAgICAgJ19fZGVmaW5lR2V0dGVyX18nLCAnX19kZWZpbmVTZXR0ZXJfXycsICdfX2xvb2t1cEdldHRlcl9fJywgJ19fbG9va3VwU2V0dGVyX18nLCAnY2hhckF0JywgJ2NvbnN0cnVjdG9yJyxcbiAgICAgICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnLCAnY2hhckNvZGVBdCcsXG4gICAgICAnaW5kZXhPZicsICdsYXN0SW5kZXhvZicsICdsZW5ndGgnLCAnbG9jYWxlQ29tcGFyZScsICdtYXRjaCcsICdyZXBsYWNlJywgJ3NlYXJjaCcsICdzbGljZScsICdzcGxpdCcsICdzdWJzdHJpbmcnLFxuICAgICAgJ3RvTG9jYWxlTG93ZXJDYXNlJywgJ3RvTG9jYWxlVXBwZXJDYXNlJywgJ3RvTG93ZXJDYXNlJywgJ3RvVXBwZXJDYXNlJywgJ3RyaW0nLCAndHJpbUxlZnQnLCAndHJpbVJpZ2h0J1xuICAgIF07XG5cbiAgICBPYmplY3Qua2V5cyh0aGVtZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgaWYgKHN0cmluZ1Byb3RvdHlwZUJsYWNrbGlzdC5pbmRleE9mKHByb3ApICE9PSAtMSkge1xuICAgICAgICBjb25zb2xlLmxvZygnd2FybjogJy5yZWQgKyAoJ1N0cmluZy5wcm90b3R5cGUnICsgcHJvcCkubWFnZW50YSArICcgaXMgcHJvYmFibHkgc29tZXRoaW5nIHlvdSBkb25cXCd0IHdhbnQgdG8gb3ZlcnJpZGUuIElnbm9yaW5nIHN0eWxlIG5hbWUnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mKHRoZW1lW3Byb3BdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb2xvcnNbcHJvcF0gPSBjb2xvcnNbdGhlbWVbcHJvcF1dO1xuICAgICAgICAgIGFkZFByb3BlcnR5KHByb3AsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcnNbdGhlbWVbcHJvcF1dKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFkZFByb3BlcnR5KHByb3AsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGVtZVtwcm9wXS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgICByZXQgPSBleHBvcnRzW3RoZW1lW3Byb3BdW3RdXShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29sb3JzLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbG9ycy50aGVtZXNbdGhlbWVdID0gcmVxdWlyZSh0aGVtZSk7XG4gICAgICAgIGFwcGx5VGhlbWUoY29sb3JzLnRoZW1lc1t0aGVtZV0pO1xuICAgICAgICByZXR1cm4gY29sb3JzLnRoZW1lc1t0aGVtZV07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlUaGVtZSh0aGVtZSk7XG4gICAgfVxuICB9O1xuXG59OyIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuL2NvbG9ycycpO1xubW9kdWxlWydleHBvcnRzJ10gPSBjb2xvcnM7XG5cbi8vIFJlbWFyazogQnkgZGVmYXVsdCwgY29sb3JzIHdpbGwgYWRkIHN0eWxlIHByb3BlcnRpZXMgdG8gU3RyaW5nLnByb3RvdHlwZVxuLy9cbi8vIElmIHlvdSBkb24ndCB3aXNoIHRvIGV4dGVuZCBTdHJpbmcucHJvdG90eXBlIHlvdSBjYW4gZG8gdGhpcyBpbnN0ZWFkIGFuZCBuYXRpdmUgU3RyaW5nIHdpbGwgbm90IGJlIHRvdWNoZWRcbi8vXG4vLyAgIHZhciBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZSk7XG4vLyAgIGNvbG9ycy5yZWQoXCJmb29cIilcbi8vXG4vL1xucmVxdWlyZSgnLi9leHRlbmRTdHJpbmdQcm90b3R5cGUnKSgpOyIsInZhciBjb2xvcnMgPSByZXF1aXJlKCcuLi9jb2xvcnMnKTtcblxubW9kdWxlWydleHBvcnRzJ10gPSAoZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICAgIGlmKGxldHRlciA9PT0gXCIgXCIpIHJldHVybiBsZXR0ZXI7XG4gICAgc3dpdGNoKGklMykge1xuICAgICAgY2FzZSAwOiByZXR1cm4gY29sb3JzLnJlZChsZXR0ZXIpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gY29sb3JzLndoaXRlKGxldHRlcilcbiAgICAgIGNhc2UgMjogcmV0dXJuIGNvbG9ycy5ibHVlKGxldHRlcilcbiAgICB9XG4gIH1cbn0pKCk7IiwidmFyIGNvbG9ycyA9IHJlcXVpcmUoJy4uL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByYWluYm93Q29sb3JzID0gWydyZWQnLCAneWVsbG93JywgJ2dyZWVuJywgJ2JsdWUnLCAnbWFnZW50YSddOyAvL1JvWSBHIEJpVlxuICByZXR1cm4gZnVuY3Rpb24gKGxldHRlciwgaSwgZXhwbG9kZWQpIHtcbiAgICBpZiAobGV0dGVyID09PSBcIiBcIikge1xuICAgICAgcmV0dXJuIGxldHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbG9yc1tyYWluYm93Q29sb3JzW2krKyAlIHJhaW5ib3dDb2xvcnMubGVuZ3RoXV0obGV0dGVyKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG4iLCJ2YXIgY29sb3JzID0gcmVxdWlyZSgnLi4vY29sb3JzJyk7XG5cbm1vZHVsZVsnZXhwb3J0cyddID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF2YWlsYWJsZSA9IFsndW5kZXJsaW5lJywgJ2ludmVyc2UnLCAnZ3JleScsICd5ZWxsb3cnLCAncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAnd2hpdGUnLCAnY3lhbicsICdtYWdlbnRhJ107XG4gIHJldHVybiBmdW5jdGlvbihsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gICAgcmV0dXJuIGxldHRlciA9PT0gXCIgXCIgPyBsZXR0ZXIgOiBjb2xvcnNbYXZhaWxhYmxlW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChhdmFpbGFibGUubGVuZ3RoIC0gMSkpXV0obGV0dGVyKTtcbiAgfTtcbn0pKCk7IiwidmFyIGNvbG9ycyA9IHJlcXVpcmUoJy4uL2NvbG9ycycpO1xuXG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uIChsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gIHJldHVybiBpICUgMiA9PT0gMCA/IGxldHRlciA6IGNvbG9ycy5pbnZlcnNlKGxldHRlcik7XG59OyIsIi8qXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgc3R5bGVzID0ge307XG5tb2R1bGVbJ2V4cG9ydHMnXSA9IHN0eWxlcztcblxudmFyIGNvZGVzID0ge1xuICByZXNldDogWzAsIDBdLFxuXG4gIGJvbGQ6IFsxLCAyMl0sXG4gIGRpbTogWzIsIDIyXSxcbiAgaXRhbGljOiBbMywgMjNdLFxuICB1bmRlcmxpbmU6IFs0LCAyNF0sXG4gIGludmVyc2U6IFs3LCAyN10sXG4gIGhpZGRlbjogWzgsIDI4XSxcbiAgc3RyaWtldGhyb3VnaDogWzksIDI5XSxcblxuICBibGFjazogWzMwLCAzOV0sXG4gIHJlZDogWzMxLCAzOV0sXG4gIGdyZWVuOiBbMzIsIDM5XSxcbiAgeWVsbG93OiBbMzMsIDM5XSxcbiAgYmx1ZTogWzM0LCAzOV0sXG4gIG1hZ2VudGE6IFszNSwgMzldLFxuICBjeWFuOiBbMzYsIDM5XSxcbiAgd2hpdGU6IFszNywgMzldLFxuICBncmF5OiBbOTAsIDM5XSxcbiAgZ3JleTogWzkwLCAzOV0sXG5cbiAgYmdCbGFjazogWzQwLCA0OV0sXG4gIGJnUmVkOiBbNDEsIDQ5XSxcbiAgYmdHcmVlbjogWzQyLCA0OV0sXG4gIGJnWWVsbG93OiBbNDMsIDQ5XSxcbiAgYmdCbHVlOiBbNDQsIDQ5XSxcbiAgYmdNYWdlbnRhOiBbNDUsIDQ5XSxcbiAgYmdDeWFuOiBbNDYsIDQ5XSxcbiAgYmdXaGl0ZTogWzQ3LCA0OV0sXG5cbiAgLy8gbGVnYWN5IHN0eWxlcyBmb3IgY29sb3JzIHByZSB2MS4wLjBcbiAgYmxhY2tCRzogWzQwLCA0OV0sXG4gIHJlZEJHOiBbNDEsIDQ5XSxcbiAgZ3JlZW5CRzogWzQyLCA0OV0sXG4gIHllbGxvd0JHOiBbNDMsIDQ5XSxcbiAgYmx1ZUJHOiBbNDQsIDQ5XSxcbiAgbWFnZW50YUJHOiBbNDUsIDQ5XSxcbiAgY3lhbkJHOiBbNDYsIDQ5XSxcbiAgd2hpdGVCRzogWzQ3LCA0OV1cblxufTtcblxuT2JqZWN0LmtleXMoY29kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdmFsID0gY29kZXNba2V5XTtcbiAgdmFyIHN0eWxlID0gc3R5bGVzW2tleV0gPSBbXTtcbiAgc3R5bGUub3BlbiA9ICdcXHUwMDFiWycgKyB2YWxbMF0gKyAnbSc7XG4gIHN0eWxlLmNsb3NlID0gJ1xcdTAwMWJbJyArIHZhbFsxXSArICdtJztcbn0pOyIsIi8qXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgYXJndiA9IHByb2Nlc3MuYXJndjtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndi5pbmRleE9mKCctLW5vLWNvbG9yJykgIT09IC0xIHx8XG4gICAgYXJndi5pbmRleE9mKCctLWNvbG9yPWZhbHNlJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyZ3YuaW5kZXhPZignLS1jb2xvcicpICE9PSAtMSB8fFxuICAgIGFyZ3YuaW5kZXhPZignLS1jb2xvcj10cnVlJykgIT09IC0xIHx8XG4gICAgYXJndi5pbmRleE9mKCctLWNvbG9yPWFsd2F5cycpICE9PSAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoJ0NPTE9SVEVSTScgaW4gcHJvY2Vzcy5lbnYpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5URVJNID09PSAnZHVtYicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0pKCk7IiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjQuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiAtbyAuL2Rpc3QvbG9kYXNoLmpzYFxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS41LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZSBFUzUgZW52aXJvbm1lbnRzICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgdG8gcG9vbCBhcnJheXMgYW5kIG9iamVjdHMgdXNlZCBpbnRlcm5hbGx5ICovXG4gIHZhciBhcnJheVBvb2wgPSBbXSxcbiAgICAgIG9iamVjdFBvb2wgPSBbXTtcblxuICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIHRvIHByZWZpeCBrZXlzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGBfX3Byb3RvX19gIGFuZCBwcm9wZXJ0aWVzIG9uIGBPYmplY3QucHJvdG90eXBlYCAqL1xuICB2YXIga2V5UHJlZml4ID0gK25ldyBEYXRlICsgJyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gNzU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heCBzaXplIG9mIHRoZSBgYXJyYXlQb29sYCBhbmQgYG9iamVjdFBvb2xgICovXG4gIHZhciBtYXhQb29sU2l6ZSA9IDQwO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCB3aGl0ZXNwYWNlICovXG4gIHZhciB3aGl0ZXNwYWNlID0gKFxuICAgIC8vIHdoaXRlc3BhY2VcbiAgICAnIFxcdFxceDBCXFxmXFx4QTBcXHVmZWZmJyArXG5cbiAgICAvLyBsaW5lIHRlcm1pbmF0b3JzXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyB1bmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzXG4gICAgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDAnXG4gICk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIEVTNiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAqIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Z1bmN0aW9uJywgJ01hdGgnLCAnTnVtYmVyJywgJ09iamVjdCcsXG4gICAgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnXycsICdhdHRhY2hFdmVudCcsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLFxuICAgICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkgKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IDA7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCBzaG9ydGN1dHMgKi9cbiAgdmFyIGFyZ3NDbGFzcyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlDbGFzcyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBmdW5jQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FyZ3NDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdCc6ICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSB8fCB0aGlzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AgKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAgKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYCAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgICovXG4gIHZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXNcbiAgICogb3IgYGZyb21JbmRleGAgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb250YWluc2AgZm9yIGNhY2hlIG9iamVjdHMgdGhhdCBtaW1pY3MgdGhlIHJldHVyblxuICAgKiBzaWduYXR1cmUgb2YgYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGNhY2hlID0gY2FjaGUuY2FjaGU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3ZhbHVlXSA/IDAgOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgIH1cbiAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWU7XG4gICAgY2FjaGUgPSAoY2FjaGUgPSBjYWNoZVt0eXBlXSkgJiYgY2FjaGVba2V5XTtcblxuICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnXG4gICAgICA/IChjYWNoZSAmJiBiYXNlSW5kZXhPZihjYWNoZSwgdmFsdWUpID4gLTEgPyAwIDogLTEpXG4gICAgICA6IChjYWNoZSA/IDAgOiAtMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGdpdmVuIHZhbHVlIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgY2FjaGVbdmFsdWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWUsXG4gICAgICAgICAgdHlwZUNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAodHlwZUNhY2hlW2tleV0gfHwgKHR5cGVDYWNoZVtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5tYXhgIGFuZCBgXy5taW5gIGFzIHRoZSBkZWZhdWx0IGNhbGxiYWNrIHdoZW4gYSBnaXZlblxuICAgKiBjb2xsZWN0aW9uIGlzIGEgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGNoYXJhY3RlciB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgZ2l2ZW4gY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIGVsZW1lbnRzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWMgPSBhLmNyaXRlcmlhLFxuICAgICAgICBiYyA9IGIuY3JpdGVyaWEsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFjLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY1tpbmRleF0sXG4gICAgICAgICAgb3RoZXIgPSBiY1tpbmRleF07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgdHlwZW9mIG90aGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYGFgIGFuZCBgYmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgb3IgYG51bGxgIGlmIGNhY2hpbmcgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IGFycmF5WzBdLFxuICAgICAgICBtaWQgPSBhcnJheVsobGVuZ3RoIC8gMikgfCAwXSxcbiAgICAgICAgbGFzdCA9IGFycmF5W2xlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBtaWQgJiYgdHlwZW9mIG1pZCA9PSAnb2JqZWN0JyAmJiBsYXN0ICYmIHR5cGVvZiBsYXN0ID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkXG4gICAqIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IGZyb20gdGhlIGFycmF5IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gYXJyYXlQb29sLnBvcCgpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGZyb20gdGhlIG9iamVjdCBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPYmplY3QoKSB7XG4gICAgcmV0dXJuIG9iamVjdFBvb2wucG9wKCkgfHwge1xuICAgICAgJ2FycmF5JzogbnVsbCxcbiAgICAgICdjYWNoZSc6IG51bGwsXG4gICAgICAnY3JpdGVyaWEnOiBudWxsLFxuICAgICAgJ2ZhbHNlJzogZmFsc2UsXG4gICAgICAnaW5kZXgnOiAwLFxuICAgICAgJ251bGwnOiBmYWxzZSxcbiAgICAgICdudW1iZXInOiBudWxsLFxuICAgICAgJ29iamVjdCc6IG51bGwsXG4gICAgICAncHVzaCc6IG51bGwsXG4gICAgICAnc3RyaW5nJzogbnVsbCxcbiAgICAgICd0cnVlJzogZmFsc2UsXG4gICAgICAndW5kZWZpbmVkJzogZmFsc2UsXG4gICAgICAndmFsdWUnOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYmFjayB0byB0aGUgYXJyYXkgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VBcnJheShhcnJheSkge1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgaWYgKGFycmF5UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgYXJyYXlQb29sLnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGJhY2sgdG8gdGhlIG9iamVjdCBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZU9iamVjdChvYmplY3QpIHtcbiAgICB2YXIgY2FjaGUgPSBvYmplY3QuY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICB9XG4gICAgb2JqZWN0LmFycmF5ID0gb2JqZWN0LmNhY2hlID0gb2JqZWN0LmNyaXRlcmlhID0gb2JqZWN0Lm9iamVjdCA9IG9iamVjdC5udW1iZXIgPSBvYmplY3Quc3RyaW5nID0gb2JqZWN0LnZhbHVlID0gbnVsbDtcbiAgICBpZiAob2JqZWN0UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgb2JqZWN0UG9vbC5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWNlcyB0aGUgYGNvbGxlY3Rpb25gIGZyb20gdGhlIGBzdGFydGAgaW5kZXggdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLFxuICAgKiB0aGUgYGVuZGAgaW5kZXguXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlIGxpc3RzXG4gICAqIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0IHx8IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0IG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcbiAgICAvLyBhZnRlciBidWlsdC1pbiBjb25zdHJ1Y3RvcnMgbGlrZSBgT2JqZWN0YCwgZm9yIHRoZSBjcmVhdGlvbiBvZiBsaXRlcmFscy5cbiAgICAvLyBFUzUgY2xlYXJzIHRoaXMgdXAgYnkgc3RhdGluZyB0aGF0IGxpdGVyYWxzIG11c3QgdXNlIGJ1aWx0LWluIGNvbnN0cnVjdG9ycy5cbiAgICAvLyBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKSA6IHJvb3Q7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBCb29sZWFuID0gY29udGV4dC5Cb29sZWFuLFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBub0NvbmZsaWN0YCAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgW1tDbGFzc11dIG9mIHZhbHVlcyAqL1xuICAgIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICAgIHZhciByZU5hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVJlZi5zcGxpY2UsXG4gICAgICAgIHVuc2hpZnQgPSBhcnJheVJlZi51bnNoaWZ0O1xuXG4gICAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJRSA4IG9ubHkgYWNjZXB0cyBET00gZWxlbWVudHNcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge30sXG4gICAgICAgICAgICBmdW5jID0gaXNOYXRpdmUoZnVuYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xuICAgIHZhciBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVJc05hTiA9IGNvbnRleHQuaXNOYU4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXMsXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCBhIGJ1aWx0LWluIGNvbnN0cnVjdG9yIGJ5IFtbQ2xhc3NdXSAqL1xuICAgIHZhciBjdG9yQnlDbGFzcyA9IHt9O1xuICAgIGN0b3JCeUNsYXNzW2FycmF5Q2xhc3NdID0gQXJyYXk7XG4gICAgY3RvckJ5Q2xhc3NbYm9vbENsYXNzXSA9IEJvb2xlYW47XG4gICAgY3RvckJ5Q2xhc3NbZGF0ZUNsYXNzXSA9IERhdGU7XG4gICAgY3RvckJ5Q2xhc3NbZnVuY0NsYXNzXSA9IEZ1bmN0aW9uO1xuICAgIGN0b3JCeUNsYXNzW29iamVjdENsYXNzXSA9IE9iamVjdDtcbiAgICBjdG9yQnlDbGFzc1tudW1iZXJDbGFzc10gPSBOdW1iZXI7XG4gICAgY3RvckJ5Q2xhc3NbcmVnZXhwQ2xhc3NdID0gUmVnRXhwO1xuICAgIGN0b3JCeUNsYXNzW3N0cmluZ0NsYXNzXSA9IFN0cmluZztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5hYmxlIGludHVpdGl2ZVxuICAgICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIExvLURhc2ggbWV0aG9kcywgd3JhcHBlcnMgYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgYEFycmF5YCBtZXRob2RzOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICAgKiBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXNzaWduYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNoYWluYCwgYGNvbXBhY3RgLFxuICAgICAqIGBjb21wb3NlYCwgYGNvbmNhdGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjcmVhdGVDYWxsYmFja2AsIGBjdXJyeWAsXG4gICAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgICAqIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsXG4gICAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAgICogYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGlja2AsIGBwbHVja2AsIGBwdWxsYCwgYHB1c2hgLFxuICAgICAqIGByYW5nZWAsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCxcbiAgICAgKiBhbmQgYHppcGBcbiAgICAgKlxuICAgICAqIFRoZSBub24tY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgICAqIGBpbmRleE9mYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLFxuICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgICAqIGBsYXN0SW5kZXhPZmAsIGBtaXhpbmAsIGBub0NvbmZsaWN0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVzdWx0YCwgYHNoaWZ0YCwgYHNpemVgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBydW5JbkNvbnRleHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBmdW5jdGlvbnMgYGZpcnN0YCBhbmQgYGxhc3RgIHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGBuYCBpc1xuICAgICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluaW5nIGNhbiBiZSBlbmFibGVkIGJ5IHVzaW5nIHRoZSBgXy5jaGFpbmAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAvLyBkb24ndCB3cmFwIGlmIGFscmVhZHkgd3JhcHBlZCwgZXZlbiBpZiB3cmFwcGVkIGJ5IGEgZGlmZmVyZW50IGBsb2Rhc2hgIGNvbnN0cnVjdG9yXG4gICAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpXG4gICAgICAgPyB2YWx1ZVxuICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFzdCBwYXRoIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluQWxsIEEgZmxhZyB0byBlbmFibGUgY2hhaW5pbmcgZm9yIGFsbCBtZXRob2RzXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBgbmV3IGxvZGFzaFdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBsb2Rhc2hgXG4gICAgbG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBsb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gZmxhZyBlbnZpcm9ubWVudHMgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAhaXNOYXRpdmUoY29udGV4dC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChydW5JbkNvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAgICogZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgLy8gYXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IGRlb3B0aW1pemF0aW9ucyBieSB1c2luZyBgc2xpY2VgIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0FyciA/IHNsaWNlKHZhbHVlKSA6IGFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgICBhcmdzIHx8IChhcmdzID0gc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZVdyYXBwZXIoW2Z1bmMsIChpc0N1cnJ5Qm91bmQgPyBiaXRtYXNrIDogYml0bWFzayAmIH4zKSwgYXJncywgbnVsbCwgdGhpc0FyZywgYXJpdHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncyB8fCAoYXJncyA9IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBpc0xhcmdlID0gbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3QodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGlzU3RyaWN0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAgICogdGhhdCBhbGxvd3MgcGFydGlhbCBcIl8ud2hlcmVcIiBzdHlsZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXNXaGVyZT1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhLFxuICAgICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGEgJiZcbiAgICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgcmV0dXJuICthID09ICtiO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIChhICE9ICthKVxuICAgICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40KVxuICAgICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChhV3JhcHBlZCB8fCBiV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEsIGBhcmd1bWVudHNgIG9iamVjdHMgaGF2ZSBgQXJyYXlgIGNvbnN0cnVjdG9yc1xuICAgICAgICB2YXIgY3RvckEgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY3RvckIgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgICAhKGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiYgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQikgJiZcbiAgICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuICAgICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbaW5kZXhdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2suIFRoZSBnaXZlbiBgc2V0dGVyYCBmdW5jdGlvbiBzZXRzIHRoZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICAgKiBvZiB0aGUgY29tcG9zZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIHNldHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgXG4gICAgICogd2l0aCBhbiBvcHRpb25hbCBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgMSAtIGBfLmJpbmRgXG4gICAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICA0IC0gYF8uY3VycnlgXG4gICAgICogIDggLSBgXy5jdXJyeWAgKGJvdW5kKVxuICAgICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAgICogIDMyIC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsQXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbFJpZ2h0QXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBiaXRtYXNrICYgMzI7XG5cbiAgICAgIGlmICghaXNCaW5kS2V5ICYmICFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsICYmICFwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICAgIGlzUGFydGlhbCA9IHBhcnRpYWxBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjMyO1xuICAgICAgICBpc1BhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMgJiYgZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAoYmluZERhdGEgJiYgYmluZERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgICBiaW5kRGF0YSA9IHNsaWNlKGJpbmREYXRhKTtcbiAgICAgICAgaWYgKGJpbmREYXRhWzJdKSB7XG4gICAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmREYXRhWzNdKSB7XG4gICAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGB0aGlzQmluZGluZ2AgaXMgbm90IHByZXZpb3VzbHkgYm91bmRcbiAgICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgICBpZiAoaXNDdXJyeSAmJiAhKGJpbmREYXRhWzFdICYgNCkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIGxlZnQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgICB1bnNoaWZ0LmFwcGx5KGJpbmREYXRhWzNdIHx8IChiaW5kRGF0YVszXSA9IFtdKSwgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgICAgYmluZERhdGFbMV0gfD0gYml0bWFzaztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgICAgfVxuICAgICAgLy8gZmFzdCBwYXRoIGZvciBgXy5iaW5kYFxuICAgICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiByZU5hdGl2ZS50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgICAqL1xuICAgIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYGlzUGxhaW5PYmplY3RgIHdoaWNoIGNoZWNrcyBpZiBhIGdpdmVuIHZhbHVlXG4gICAgICogaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLCBhc3N1bWluZyBvYmplY3RzIGNyZWF0ZWRcbiAgICAgKiBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IgaGF2ZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFuZCB0aGF0XG4gICAgICogdGhlcmUgYXJlIG5vIGBPYmplY3QucHJvdG90eXBlYCBleHRlbnNpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgY3RvcixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIC8vIGF2b2lkIG5vbiBPYmplY3Qgb2JqZWN0cywgYGFyZ3VtZW50c2Agb2JqZWN0cywgYW5kIERPTSBlbGVtZW50c1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpIHx8XG4gICAgICAgICAgKGN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgaXNGdW5jdGlvbihjdG9yKSAmJiAhKGN0b3IgaW5zdGFuY2VvZiBjdG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAgICAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuICAgICAgLy8gb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICBmb3JJbih2YWx1ZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgdW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sQ2hhcihtYXRjaCkge1xuICAgICAgcmV0dXJuIGh0bWxVbmVzY2FwZXNbbWF0Y2hdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcmd1bWVudHMoYXJndW1lbnRzKTsgfSkoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcnJheShhcmd1bWVudHMpOyB9KSgpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcyB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIHByb2R1Y2VzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIGdpdmVuIG9iamVjdCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICB2YXIgc2hpbUtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghKG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3RdKSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgZm9yIChpbmRleCBpbiBpdGVyYWJsZSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhYmxlLCBpbmRleCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2V5cyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbJ29uZScsICd0d28nLCAndGhyZWUnXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzOlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBgPmAgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2UgYD5gIGFuZCBgL2BcbiAgICAgKiBkb24ndCByZXF1aXJlIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nIHVubGVzcyB0aGV5J3JlIHBhcnRcbiAgICAgKiBvZiBhIHRhZyBvciBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMgKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpXG4gICAgICovXG4gICAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmIzM5OydcbiAgICB9O1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMgKi9cbiAgICB2YXIgaHRtbFVuZXNjYXBlcyA9IGludmVydChodG1sRXNjYXBlcyk7XG5cbiAgICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMgKi9cbiAgICB2YXIgcmVFc2NhcGVkSHRtbCA9IFJlZ0V4cCgnKCcgKyBrZXlzKGh0bWxVbmVzY2FwZXMpLmpvaW4oJ3wnKSArICcpJywgJ2cnKSxcbiAgICAgICAgcmVVbmVzY2FwZWRIdG1sID0gUmVnRXhwKCdbJyArIGtleXMoaHRtbEVzY2FwZXMpLmpvaW4oJycpICsgJ10nLCAnZycpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91c1xuICAgICAqIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZVxuICAgICAqIGFzc2lnbmVkIHZhbHVlcy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnbmFtZSc6ICdmcmVkJyB9LCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiBhID09ICd1bmRlZmluZWQnID8gYiA6IGE7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAgICogZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBndWFyZCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gdHlwZW9mIGd1YXJkID09ICdudW1iZXInID8gMiA6IGFyZ3MubGVuZ3RoO1xuICAgICAgaWYgKGFyZ3NMZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tYXJnc0xlbmd0aCAtIDFdLCBhcmdzW2FyZ3NMZW5ndGgtLV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChhcmdzTGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NbLS1hcmdzTGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgaXRlcmFibGUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSB7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrID8gY2FsbGJhY2socmVzdWx0W2luZGV4XSwgaXRlcmFibGVbaW5kZXhdKSA6IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgd2lsbCBhbHNvXG4gICAgICogYmUgY2xvbmVkLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwPWZhbHNlXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUoY2hhcmFjdGVycyk7XG4gICAgICogc2hhbGxvd1swXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUoY2hhcmFjdGVycywgdHJ1ZSk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5taXhpbih7XG4gICAgICogICAnY2xvbmUnOiBfLnBhcnRpYWxSaWdodChfLmNsb25lLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgKiAgIH0pXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lKGRvY3VtZW50LmJvZHkpO1xuICAgICAqIGNsb25lLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcyB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGBcbiAgICAgIC8vIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzIGZvciBgaXNEZWVwYCBhbmQgYGNhbGxiYWNrYFxuICAgICAgaWYgKHR5cGVvZiBpc0RlZXAgIT0gJ2Jvb2xlYW4nICYmIGlzRGVlcCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSBpc0RlZXA7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmVcbiAgICAgKiBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90KiogY2xvbmVkLiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kXG4gICAgICogb2JqZWN0cyBjcmVhdGVkIGJ5IGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy5cbiAgICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChjaGFyYWN0ZXJzKTtcbiAgICAgKiBkZWVwWzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdub2RlJzogZWxlbWVudFxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lRGVlcCh2aWV3LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZSh0cnVlKSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNsb25lLm5vZGUgPT0gdmlldy5ub2RlO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIHByb3ZpZGVkIGl0cyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZFxuICAgICAqIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7ICdjb25zdHJ1Y3Rvcic6IENpcmNsZSB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID8gYXNzaWduKHJlc3VsdCwgcHJvcGVydGllcykgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIE9uY2UgYVxuICAgICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCBkZWZhdWx0cyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCB3aXRob3V0IHVzaW5nIGl0c1xuICAgICAqICBga2V5YCBhbmQgYG9iamVjdGAgYXJndW1lbnRzIGFzIHNvdXJjZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAgICogXy5kZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgaXRlcmFibGUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSB7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbaW5kZXhdID09ICd1bmRlZmluZWQnKSByZXN1bHRbaW5kZXhdID0gaXRlcmFibGVbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50IHRoYXQgcGFzc2VzIHRoZSBjYWxsYmFjayBjaGVjaywgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgJ2ZyZWQnOiB7ICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogeyAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgLCBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zIGBiYXJuZXlgXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDQwIH0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JPd25SaWdodChvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsXG4gICAgICogZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFNoYXBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgdGhpcy54ICs9IHg7XG4gICAgICogICB0aGlzLnkgKz0geTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgU2hhcGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAneCcsICd5JywgYW5kICdtb3ZlJyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIgZm9ySW4gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IGNvbGxlY3Rpb24sIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgU2hhcGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbW92ZScsICd5JywgYW5kICd4JyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuXG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcGFpcnMucHVzaChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMubGVuZ3RoO1xuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhwYWlyc1tsZW5ndGgtLV0sIHBhaXJzW2xlbmd0aF0sIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCwgZXhlY3V0aW5nIHRoZSBjYWxsYmFja1xuICAgICAqIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodCh7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdsZW5ndGgnLCAnMScsIGFuZCAnMCcgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF07XG4gICAgICAgIGlmIChjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzb3J0ZWQgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgb2YgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyxcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCwgb2YgYG9iamVjdGAgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMoXyk7XG4gICAgICogLy8gPT4gWydhbGwnLCAnYW55JywgJ2JpbmQnLCAnYmluZEFsbCcsICdjbG9uZScsICdjb21wYWN0JywgJ2NvbXBvc2UnLCAuLi5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgbmFtZSBleGlzdHMgYXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAsXG4gICAgICogaW5zdGVhZCBvZiBhbiBpbmhlcml0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBrZXkgaXMgYSBkaXJlY3QgcHJvcGVydHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oYXMoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sICdiJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludmVydCh7ICdmaXJzdCc6ICdmcmVkJywgJ3NlY29uZCc6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAnZmlyc3QnLCAnYmFybmV5JzogJ3NlY29uZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVydChvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W29iamVjdFtrZXldXSA9IGtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBkYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBkYXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZW1wdHkuIEFycmF5cywgc3RyaW5ncywgb3IgYGFyZ3VtZW50c2Agb2JqZWN0cyB3aXRoIGFcbiAgICAgKiBsZW5ndGggb2YgYDBgIGFuZCBvYmplY3RzIHdpdGggbm8gb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29uc2lkZXJlZFxuICAgICAqIFwiZW1wdHlcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KCcnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICBpZiAoKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzIHx8IGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gYXJnc0NsYXNzICkgfHxcbiAgICAgICAgICAoY2xhc3NOYW1lID09IG9iamVjdENsYXNzICYmIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvck93bih2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50IHRvIGVhY2ggb3RoZXIuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBjb21wYXJpc29ucyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChhLCBiKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBjb3B5ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogb2JqZWN0ID09IGNvcHk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIGNvcHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB3b3JkcyA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlcldvcmRzID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwod29yZHMsIG90aGVyV29yZHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHZhciByZUdyZWV0ID0gL14oPzpoZWxsb3xoaSkkL2ksXG4gICAgICogICAgICAgYUdyZWV0ID0gXy5pc1N0cmluZyhhKSAmJiByZUdyZWV0LnRlc3QoYSksXG4gICAgICogICAgICAgYkdyZWV0ID0gXy5pc1N0cmluZyhiKSAmJiByZUdyZWV0LnRlc3QoYik7XG4gICAgICpcbiAgICAgKiAgIHJldHVybiAoYUdyZWV0IHx8IGJHcmVldCkgPyAoYUdyZWV0ID09IGJHcmVldCkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhLCBiLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcywgb3IgY2FuIGJlIGNvZXJjZWQgdG8sIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNGaW5pdGVgIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgZm9yXG4gICAgICogYm9vbGVhbnMgYW5kIGVtcHR5IHN0cmluZ3MuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZmluaXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoLTEwMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKHRydWUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUlzRmluaXRlKHZhbHVlKSAmJiAhbmF0aXZlSXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCgxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgdmFsdWUgaXMgdGhlIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3RcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OFxuICAgICAgLy8gYW5kIGF2b2lkIGEgVjggYnVnXG4gICAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxXG4gICAgICByZXR1cm4gISEodmFsdWUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzTmFOYCB3aGljaCB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1lcmljIHZhbHVlcy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIGBOYU5gIGFzIGEgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZlxuICAgICAgLy8gKHBlcmZvcm0gdGhlIFtbQ2xhc3NdXSBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lIGhvc3Qgb2JqZWN0cyBpbiBJRSlcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBgTmFOYCBpcyBjb25zaWRlcmVkIGEgbnVtYmVyLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3g4LjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDguNCAqIDUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gbnVtYmVyQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgU2hhcGUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc1BsYWluT2JqZWN0ID0gIWdldFByb3RvdHlwZU9mID8gc2hpbUlzUGxhaW5PYmplY3QgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZixcbiAgICAgICAgICBvYmpQcm90byA9IGlzTmF0aXZlKHZhbHVlT2YpICYmIChvYmpQcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlT2YpKSAmJiBnZXRQcm90b3R5cGVPZihvYmpQcm90byk7XG5cbiAgICAgIHJldHVybiBvYmpQcm90b1xuICAgICAgICA/ICh2YWx1ZSA9PSBvYmpQcm90byB8fCBnZXRQcm90b3R5cGVPZih2YWx1ZSkgPT0gb2JqUHJvdG8pXG4gICAgICAgIDogc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2ZyZWQvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gcmVnZXhwQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkIGJ5XG4gICAgICogcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocm91Z2ggdGhlIGNhbGxiYWNrLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB2YWx1ZXMgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXMoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzfSAsIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyhjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAgICAgKiBkb24ndCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzXG4gICAgICogd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBhbmQgc291cmNlIHByb3BlcnRpZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIG1lcmdpbmcgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBuYW1lcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICduYW1lJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ2FnZSc6IDM2IH0sXG4gICAgICogICAgIHsgJ2FnZSc6IDQwIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShuYW1lcywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnY2hhcmFjdGVycyc6IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogdmFyIGZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydhcHBsZSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXJGb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYmFuYW5hJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnY2Fycm90J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShmb29kLCBvdGhlckZvb2QsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzQXJyYXkoYSkgPyBhLmNvbmNhdChiKSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcnVpdHMnOiBbJ2FwcGxlJywgJ2JhbmFuYSddLCAndmVnZXRhYmxlcyc6IFsnYmVldCcsICdjYXJyb3RdIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZShvYmplY3QpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IDI7XG5cbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdICE9ICdudW1iZXInKSB7XG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbbGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWxlbmd0aCAtIDFdLCBhcmdzW2xlbmd0aC0tXSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbbGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NbLS1sZW5ndGhdO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZXMgPSBzbGljZShhcmd1bWVudHMsIDEsIGxlbmd0aCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBzdGFja0EgPSBnZXRBcnJheSgpLFxuICAgICAgICAgIHN0YWNrQiA9IGdldEFycmF5KCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZXNbaW5kZXhdLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgZXhjbHVkaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2hcbiAgICAgKiBwcm9wZXJ0eSBvZiBgb2JqZWN0YCBvbWl0dGluZyB0aGUgcHJvcGVydGllcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleVxuICAgICAqIGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLnN0cmluZ3xzdHJpbmdbXX0gW2NhbGxiYWNrXSBUaGUgcHJvcGVydGllcyB0byBvbWl0IG9yIHRoZVxuICAgICAqICBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRob3V0IHRoZSBvbWl0dGVkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ub21pdCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgcHJvcHMucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMgPSBiYXNlRGlmZmVyZW5jZShwcm9wcywgYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSkpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgYW4gb2JqZWN0J3Mga2V5LXZhbHVlIHBhaXJzLFxuICAgICAqIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIG5ldyBhcnJheSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFpcnMoeyAnYmFybmV5JzogMzYsICdmcmVkJzogNDAgfSk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhaXJzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGNvbXBvc2VkIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2hcbiAgICAgKiBwcm9wZXJ0eSBvZiBgb2JqZWN0YCBwaWNraW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eVxuICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBpY2soeyAnbmFtZSc6ICdmcmVkJywgJ191c2VyaWQnOiAnZnJlZDEnIH0sICduYW1lJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLnBpY2soeyAnbmFtZSc6ICdmcmVkJywgJ191c2VyaWQnOiAnZnJlZDEnIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkuY2hhckF0KDApICE9ICdfJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHByb3BzID0gYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSksXG4gICAgICAgICAgICBsZW5ndGggPSBpc09iamVjdChvYmplY3QpID8gcHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYCB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyB0aHJvdWdoIGEgY2FsbGJhY2ssIHdpdGggZWFjaCBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOyAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNxdWFyZXMgPSBfLnRyYW5zZm9ybShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdLCBmdW5jdGlvbihyZXN1bHQsIG51bSkge1xuICAgICAqICAgbnVtICo9IG51bTtcbiAgICAgKiAgIGlmIChudW0gJSAyKSB7XG4gICAgICogICAgIHJldHVybiByZXN1bHQucHVzaChudW0pIDwgMztcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgOSwgMjVdXG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgIHByb3RvID0gY3RvciAmJiBjdG9yLnByb3RvdHlwZTtcblxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gYmFzZUNyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICAgIChpc0FyciA/IGZvckVhY2ggOiBmb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleGVzLCBvciBrZXlzLCBvZiB0aGVcbiAgICAgKiBgY29sbGVjdGlvbmAuIEluZGV4ZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW118c3RyaW5nfHN0cmluZ1tdKX0gW2luZGV4XSBUaGUgaW5kZXhlcyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiAgIHRvIHJldHJpZXZlLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqICBwcm92aWRlZCBpbmRleGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sIFswLCAyLCA0XSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnLCAnZSddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXQoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3MsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICBsZW5ndGggPSAoYXJnc1syXSAmJiBhcmdzWzJdW2FyZ3NbMV1dID09PSBjb2xsZWN0aW9uKSA/IDEgOiBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIGEgY29sbGVjdGlvbiB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaW5jbHVkZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucygncGViYmxlcycsICdlYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4KSB8fCAwO1xuICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSAoaXNTdHJpbmcoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LCBmcm9tSW5kZXgpIDogaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkpID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoKytpbmRleCA+PSBmcm9tSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IHZhbHVlID09PSB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSsrIDogcmVzdWx0W2tleV0gPSAxKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJucyB0cnVleSB2YWx1ZSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbGxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSAhIWNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9ICEhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBzZWxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGV2ZW5zID0gXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50IHRoYXRcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZGV0ZWN0LCBmaW5kV2hlcmVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2hcbiAgICAgKiBlbGVtZW50LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBgbGVuZ3RoYCBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2goZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zICcxLDIsMydcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyB0aGUgb2JqZWN0IChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaFJpZ2h0KGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgJzMsMiwxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25bbGVuZ3RoXSwgbGVuZ3RoLCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGtleSA9IHByb3BzID8gcHJvcHNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNvbGxlY3Rpb25ba2V5XSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldIDogcmVzdWx0W2tleV0gPSBbXSkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgZ2l2ZW4gY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleXMgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleXMsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleXMsIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShjaGFyYWN0ZXJzLCBmdW5jdGlvbihrZXkpIHsgdGhpcy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9LCBTdHJpbmcpO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIgaW5kZXhCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIG5hbWVkIGJ5IGBtZXRob2ROYW1lYCBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYFxuICAgICAqIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYG1ldGhvZE5hbWVgIGlzIGEgZnVuY3Rpb24gaXRcbiAgICAgKiB3aWxsIGJlIGludm9rZWQgZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlKGNvbGxlY3Rpb24sIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBtZXRob2ROYW1lID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gKGlzRnVuYyA/IG1ldGhvZE5hbWUgOiB2YWx1ZVttZXRob2ROYW1lXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICogdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29sbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmVzdWx0WysraW5kZXhdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPiBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYEluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWluKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWluKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPCBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGFsbCBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHBsdWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayhjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIHZhciBwbHVjayA9IG1hcDtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYSBjb2xsZWN0aW9uIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBjYWxsYmFjayBleGVjdXRpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZXhlY3V0aW9uLiBJZlxuICAgICAqIGBhY2N1bXVsYXRvcmAgaXMgbm90IHByb3ZpZGVkIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBpbml0aWFsIGBhY2N1bXVsYXRvcmAgdmFsdWUuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOyAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRsLCBpbmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzdW0gPSBfLnJlZHVjZShbMSwgMiwgM10sIGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbnVtO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoIWNvbGxlY3Rpb24pIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAobm9hY2N1bSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY29sbGVjdGlvblsrK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbGlzdCA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKiB2YXIgZmxhdCA9IF8ucmVkdWNlUmlnaHQobGlzdCwgZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uIHRoYXQgdGhlIGNhbGxiYWNrIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1ZXkgZm9yLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgZmFpbGVkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9kZHMgPSBfLnJlamVjdChbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSByYW5kb20gZWxlbWVudCBvciBgbmAgcmFuZG9tIGVsZW1lbnRzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGBcbiAgICAgKiAgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50cyBhcyBgbmAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoICE9ICdudW1iZXInKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uID8gY29sbGVjdGlvbltiYXNlUmFuZG9tKDAsIGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNodWZmbGUoY29sbGVjdGlvbik7XG4gICAgICByZXN1bHQubGVuZ3RoID0gbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlIEZpc2hlci1ZYXRlc1xuICAgICAqIHNodWZmbGUuIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IHNodWZmbGVkIGNvbGxlY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNCwgNSwgNl0pO1xuICAgICAqIC8vID0+IFs0LCAxLCA2LCAzLCA1LCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKDAsICsraW5kZXgpO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0W3JhbmRdO1xuICAgICAgICByZXN1bHRbcmFuZF0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGBjb2xsZWN0aW9uLmxlbmd0aGAgZm9yIGFycmF5c1xuICAgICAqIGFuZCBhcnJheS1saWtlIG9iamVjdHMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgY29sbGVjdGlvbi5sZW5ndGhgIG9yIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDJdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydWV5IHZhbHVlIGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYVxuICAgICAqIGNvbGxlY3Rpb24uIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFzIHNvb24gYXMgaXQgZmluZHMgYSBwYXNzaW5nIHZhbHVlIGFuZFxuICAgICAqIGRvZXMgbm90IGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGNvbGxlY3Rpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYW55XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoKHJlc3VsdCA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gIShyZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCB3aWxsIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyXG4gICAgICogb2YgZXF1YWwgZWxlbWVudHMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB3aWxsIGJlIHNvcnRlZCBieSBlYWNoIHByb3BlcnR5IHZhbHVlLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNvcnRlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguc2luKG51bSk7IH0pO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuc2luKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDI2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogMzAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCAnYWdlJyksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAyNl0sIFsnZnJlZCcsIDMwXSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKlxuICAgICAqIC8vIHNvcnRpbmcgYnkgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsIFsnbmFtZScsICdhZ2UnXSksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9ID4gW1snYmFybmV5JywgMjZdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoY2FsbGJhY2spLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0WysraW5kZXhdID0gZ2V0T2JqZWN0KCk7XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIG9iamVjdC5jcml0ZXJpYSA9IG1hcChjYWxsYmFjaywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAob2JqZWN0LmNyaXRlcmlhID0gZ2V0QXJyYXkoKSlbMF0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QuaW5kZXggPSBpbmRleDtcbiAgICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgIHJlc3VsdC5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBvYmplY3QudmFsdWU7XG4gICAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgICByZWxlYXNlQXJyYXkob2JqZWN0LmNyaXRlcmlhKTtcbiAgICAgICAgfVxuICAgICAgICByZWxlYXNlT2JqZWN0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBgY29sbGVjdGlvbmAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpOyB9KSgxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc2xpY2UoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIG9mIGVhY2ggZWxlbWVudCBpbiBhIGBjb2xsZWN0aW9uYCB0byB0aGUgZ2l2ZW5cbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0LCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ud2hlcmUoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9XVxuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdwZXRzJzogWydkaW5vJ10gfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfV1cbiAgICAgKi9cbiAgICB2YXIgd2hlcmUgPSBmaWx0ZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgYWxsIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHZhbHVlcyBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nIHN0cmljdFxuICAgICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXlzIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMSwgMiwgMywgNCwgNV0sIFs1LCAyLCAxMF0pO1xuICAgICAqIC8vID0+IFsxLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpZmZlcmVuY2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IHRoYXQgcGFzc2VzIHRoZSBjYWxsYmFjayBjaGVjaywgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgMjA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlID4gMzA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvciBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgcmV0dXJuZWQgYXMgbG9uZ1xuICAgICAqIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGhlYWQsIHRha2VcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudChzKSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpcnN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlyc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcnN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAobiA9PSBudWxsIHx8IHRoaXNBcmcpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCAwLCBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIG4pLCBsZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheSAodGhlIG5lc3RpbmcgY2FuIGJlIHRvIGFueSBkZXB0aCkuIElmIGBpc1NoYWxsb3dgXG4gICAgICogaXMgdHJ1ZXksIHRoZSBhcnJheSB3aWxsIG9ubHkgYmUgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlXG4gICAgICogZmxhdHRlbmluZy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NoYWxsb3c9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbWzRdXV07XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDMwLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5mbGF0dGVuKGNoYXJhY3RlcnMsICdwZXRzJyk7XG4gICAgICogLy8gPT4gWydob3BweScsICdiYWJ5IHB1c3MnLCAnZGlubyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Jvb2xlYW4nICYmIGlzU2hhbGxvdyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSAodHlwZW9mIGlzU2hhbGxvdyAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NoYWxsb3ddID09PSBhcnJheSkgPyBudWxsIDogaXNTaGFsbG93O1xuICAgICAgICBpc1NoYWxsb3cgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5ID0gbWFwKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBhbHJlYWR5IHNvcnRlZFxuICAgICAqIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgIHdpbGwgcnVuIGEgZmFzdGVyIGJpbmFyeSBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tIG9yIGB0cnVlYFxuICAgICAqICB0byBwZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDEsIDIsIDIsIDMsIDNdLCAyLCB0cnVlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCB8fCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpbmRleF0gPT09IHZhbHVlID8gaW5kZXggOiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb3IgbGFzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGFcbiAgICAgKiBjYWxsYmFjayBpcyBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbVxuICAgICAqIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kXG4gICAgICogdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrPTFdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5pbml0aWFsKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5pbml0aWFsKGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSAoY2FsbGJhY2sgPT0gbnVsbCB8fCB0aGlzQXJnKSA/IDEgOiBjYWxsYmFjayB8fCBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCAwLCBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pLCBsZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBnZXRBcnJheSgpLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgdHJ1c3RJbmRleE9mID0gaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgc2VlbiA9IGdldEFycmF5KCk7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgICAgICBhcmdzLnB1c2godmFsdWUpO1xuICAgICAgICAgIGNhY2hlcy5wdXNoKHRydXN0SW5kZXhPZiAmJiB2YWx1ZS5sZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiZcbiAgICAgICAgICAgIGNyZWF0ZUNhY2hlKGFyZ3NJbmRleCA/IGFyZ3NbYXJnc0luZGV4XSA6IHNlZW4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGFycmF5ID0gYXJnc1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbMF07XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2Yoc2VlbiwgdmFsdWUpKSA8IDApIHtcbiAgICAgICAgICBhcmdzSW5kZXggPSBhcmdzTGVuZ3RoO1xuICAgICAgICAgIChjYWNoZSB8fCBzZWVuKS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB3aGlsZSAoLS1hcmdzSW5kZXgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVzW2FyZ3NJbmRleF07XG4gICAgICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKGFyZ3NbYXJnc0luZGV4XSwgdmFsdWUpKSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzTGVuZ3RoXTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgcmVsZWFzZU9iamVjdChjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbGVhc2VBcnJheShjYWNoZXMpO1xuICAgICAgcmVsZWFzZUFycmF5KHNlZW4pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb3IgbGFzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhcmUgcmV0dXJuZWQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudChzKSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ubGFzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubGFzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAobiA9PSBudWxsIHx8IHRoaXNBcmcpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCBuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkXG4gICAgICogYXMgdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBpbmRleCArIGZyb21JbmRleCkgOiBuYXRpdmVNaW4oZnJvbUluZGV4LCBpbmRleCAtIDEpKSArIDE7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHByb3ZpZGVkIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBhcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV0gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcbiAgICAgKiBfLnB1bGwoYXJyYXksIDIsIDMpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsKGFycmF5KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGBlbmRgLiBJZiBgc3RhcnRgIGlzIGxlc3MgdGhhbiBgc3RvcGAgYVxuICAgICAqIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IHJhbmdlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBzdGVwID0gdHlwZW9mIHN0ZXAgPT0gJ251bWJlcicgPyBzdGVwIDogKCtzdGVwIHx8IDEpO1xuXG4gICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHVzZSBgQXJyYXkobGVuZ3RoKWAgc28gZW5naW5lcyBsaWtlIENoYWtyYSBhbmQgVjggYXZvaWQgc2xvd2VyIG1vZGVzXG4gICAgICAvLyBodHRwOi8veW91dHUuYmUvWEFxSXBHVThaWmsjdD0xN20yNXNcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heCgwLCBjZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSkpLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSB0aGF0IHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNCwgNSwgNl07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uaW5pdGlhbGAgdGhpcyBtZXRob2QgZ2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9yXG4gICAgICogZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGVsZW1lbnRzXG4gICAgICogYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZHJvcCwgdGFpbFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrPTFdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IGZhbHNlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSAoY2FsbGJhY2sgPT0gbnVsbCB8fCB0aGlzQXJnKSA/IDEgOiBuYXRpdmVNYXgoMCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoIGEgdmFsdWVcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBhIGdpdmVuIHNvcnRlZCBhcnJheSBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgc29ydFxuICAgICAqIG9yZGVyIG9mIHRoZSBhcnJheS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvclxuICAgICAqIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGVcbiAgICAgKiBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMjAsIDMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvcnRlZEluZGV4KFt7ICd4JzogMjAgfSwgeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGRpY3QgPSB7XG4gICAgICogICAnd29yZFRvTnVtYmVyJzogeyAndHdlbnR5JzogMjAsICd0aGlydHknOiAzMCwgJ2ZvdXJ0eSc6IDQwLCAnZmlmdHknOiA1MCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gZGljdC53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9LCBkaWN0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICAvLyBleHBsaWNpdGx5IHJlZmVyZW5jZSBgaWRlbnRpdHlgIGZvciBiZXR0ZXIgaW5saW5pbmcgaW4gRmlyZWZveFxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkgOiBpZGVudGl0eTtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUpO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgICAoY2FsbGJhY2soYXJyYXlbbWlkXSkgPCB2YWx1ZSlcbiAgICAgICAgICA/IGxvdyA9IG1pZCArIDFcbiAgICAgICAgICA6IGhpZ2ggPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG93O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDUsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pb24oKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgc29ydGVkLCBwcm92aWRpbmdcbiAgICAgKiBgdHJ1ZWAgZm9yIGBpc1NvcnRlZGAgd2lsbCB1c2UgYSBmYXN0ZXIgYWxnb3JpdGhtLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZSB1bmlxdWVuZXNzXG4gICAgICogaXMgY29tcHV0ZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW5pcXVlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCBgYXJyYXlgIGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDIsIDEsIDMsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMSwgMiwgMiwgM10sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy51bmlxKFsnQScsICdiJywgJ0MnLCAnYScsICdCJywgJ2MnXSwgZnVuY3Rpb24obGV0dGVyKSB7IHJldHVybiBsZXR0ZXIudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgICogLy8gPT4gWydBJywgJ2InLCAnQyddXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDIuNSwgMywgMS41LCAyLCAzLjVdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzEsIDIuNSwgM11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8udW5pcShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkICE9ICdib29sZWFuJyAmJiBpc1NvcnRlZCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSAodHlwZW9mIGlzU29ydGVkICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU29ydGVkXSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU29ydGVkO1xuICAgICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBwcm92aWRlZCB2YWx1ZXMgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzEsIDIsIDEsIDAsIDMsIDEsIDRdLCAwLCAxKTtcbiAgICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3aXRob3V0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgc3ltbWV0cmljIGRpZmZlcmVuY2Ugb2YgdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAgICAgKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSk7XG4gICAgICogLy8gPT4gWzMsIDUsIDRdXG4gICAgICpcbiAgICAgKiBfLnhvcihbMSwgMiwgNV0sIFsyLCAzLCA1XSwgWzMsIDQsIDVdKTtcbiAgICAgKiAvLyA9PiBbMSwgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4b3IoKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheSkgfHwgaXNBcmd1bWVudHMoYXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgICAgPyBiYXNlVW5pcShiYXNlRGlmZmVyZW5jZShyZXN1bHQsIGFycmF5KS5jb25jYXQoYmFzZURpZmZlcmVuY2UoYXJyYXksIHJlc3VsdCkpKVxuICAgICAgICAgICAgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW56aXBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBBcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcCgpIHtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzIDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBtYXgocGx1Y2soYXJyYXksICdsZW5ndGgnKSkgOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzIG9mIGBrZXlzYCBhbmQgYHZhbHVlc2AuIFByb3ZpZGVcbiAgICAgKiBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LCBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWBcbiAgICAgKiBvciB0d28gYXJyYXlzLCBvbmUgb2YgYGtleXNgIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBvYmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgb2Yga2V5cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBnaXZlbiBrZXlzIGFuZFxuICAgICAqICBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChrZXlzLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMgPyBrZXlzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGlmICghdmFsdWVzICYmIGxlbmd0aCAmJiAhaXNBcnJheShrZXlzWzBdKSkge1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGBmdW5jYCwgd2l0aCAgdGhlIGB0aGlzYCBiaW5kaW5nIGFuZFxuICAgICAqIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgb25seSBhZnRlciBiZWluZyBjYWxsZWQgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGJlZm9yZVxuICAgICAqICBgZnVuY2AgaXMgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdEb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ0RvbmUgc2F2aW5nIScsIGFmdGVyIGFsbCBzYXZlcyBoYXZlIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZnVuYyA9IF8uYmluZChmdW5jLCB7ICduYW1lJzogJ2ZyZWQnIH0sICdoaScpO1xuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMlxuICAgICAgICA/IGNyZWF0ZVdyYXBwZXIoZnVuYywgMTcsIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIHRoaXNBcmcpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihmdW5jLCAxLCBudWxsLCBudWxsLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLiBNZXRob2QgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBtZXRob2QgbmFtZXMuIElmIG5vIG1ldGhvZCBuYW1lcyBhcmUgcHJvdmlkZWQgYWxsIHRoZSBmdW5jdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAgd2lsbCBiZSBib3VuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBbbWV0aG9kTmFtZV0gVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG9cbiAgICAgKiAgYmluZCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgbWV0aG9kIG5hbWVzIG9yIGFycmF5cyBvZiBtZXRob2QgbmFtZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnb25DbGljayc6IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7IH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcpO1xuICAgICAqIGpRdWVyeSgnI2RvY3MnKS5vbignY2xpY2snLCB2aWV3Lm9uQ2xpY2spO1xuICAgICAqIC8vID0+IGxvZ3MgJ2NsaWNrZWQgZG9jcycsIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEFsbChvYmplY3QpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSkgOiBmdW5jdGlvbnMob2JqZWN0KSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBjcmVhdGVXcmFwcGVyKG9iamVjdFtrZXldLCAxLCBudWxsLCBudWxsLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gXG4gICAgICogYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kS2V5YCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGJvdW5kXG4gICAgICogZnVuY3Rpb24uIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG9cbiAgICAgKiByZWZlcmVuY2UgbWV0aG9kcyB0aGF0IHdpbGwgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICAgKiBTZWUgaHR0cDovL21pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICduYW1lJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMubmFtZSArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRLZXkob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMlxuICAgICAgICA/IGNyZWF0ZVdyYXBwZXIoa2V5LCAxOSwgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgb2JqZWN0KVxuICAgICAgICA6IGNyZWF0ZVdyYXBwZXIoa2V5LCAzLCBudWxsLCBudWxsLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zLFxuICAgICAqIHdoZXJlIGVhY2ggZnVuY3Rpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICAgICAqIEZvciBleGFtcGxlLCBjb21wb3NpbmcgdGhlIGZ1bmN0aW9ucyBgZigpYCwgYGcoKWAsIGFuZCBgaCgpYCBwcm9kdWNlcyBgZihnKGgoKSkpYC5cbiAgICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBbZnVuY10gRnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFsTmFtZU1hcCA9IHtcbiAgICAgKiAgICdwZWJibGVzJzogJ3BlbmVsb3BlJ1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZm9ybWF0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAqICAgbmFtZSA9IHJlYWxOYW1lTWFwW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgbmFtZTtcbiAgICAgKiAgIHJldHVybiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihmb3JtYXR0ZWQpIHtcbiAgICAgKiAgIHJldHVybiAnSGl5YSAnICsgZm9ybWF0dGVkICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgd2VsY29tZSA9IF8uY29tcG9zZShncmVldCwgZm9ybWF0KTtcbiAgICAgKiB3ZWxjb21lKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0hpeWEgUGVuZWxvcGUhJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmNzW2xlbmd0aF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzID0gW2Z1bmNzW2xlbmd0aF0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBvbmUgb3IgbW9yZSBhcmd1bWVudHMgb2YgYGZ1bmNgIHRoYXQgd2hlblxuICAgICAqIGludm9rZWQgZWl0aGVyIGV4ZWN1dGVzIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYWxsIGBmdW5jYCBhcmd1bWVudHNcbiAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG4gICAgICogcmVtYWluaW5nIGBmdW5jYCBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBjYW4gYmUgc3BlY2lmaWVkXG4gICAgICogaWYgYGZ1bmMubGVuZ3RoYCBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhhICsgYiArIGMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5KSB7XG4gICAgICBhcml0eSA9IHR5cGVvZiBhcml0eSA9PSAnbnVtYmVyJyA/IGFyaXR5IDogKCthcml0eSB8fCBmdW5jLmxlbmd0aCk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCA0LCBudWxsLCBudWxsLCBudWxsLCBhcml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIG9mIGBmdW5jYCB1bnRpbCBhZnRlclxuICAgICAqIGB3YWl0YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGludm9rZWQuXG4gICAgICogUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvblxuICAgICAqIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxsc1xuICAgICAqIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBjYWxsZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAgICAgKiB2YXIgbGF6eUxheW91dCA9IF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBsYXp5TGF5b3V0KTtcbiAgICAgKlxuICAgICAqIC8vIGV4ZWN1dGUgYHNlbmRNYWlsYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICogalF1ZXJ5KCcjcG9zdGJveCcpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGVuc3VyZSBgYmF0Y2hMb2dgIGlzIGV4ZWN1dGVkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzXG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7XG4gICAgICogICAnbWF4V2FpdCc6IDEwMDBcbiAgICAgKiB9LCBmYWxzZSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgbWF4VGltZW91dElkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB3YWl0ID0gbmF0aXZlTWF4KDAsIHdhaXQpIHx8IDA7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAobmF0aXZlTWF4KHdhaXQsIG9wdGlvbnMubWF4V2FpdCkgfHwgMCk7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGRlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNDYWxsZWQgPSB0cmFpbGluZ0NhbGw7XG4gICAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBtYXhEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN0YW1wID0gbm93KCk7XG4gICAgICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgICAgICBpZiAobWF4V2FpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtYXhUaW1lb3V0SWQgJiYgIWxlYWRpbmcpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IG1heFdhaXQgLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKSxcbiAgICAgICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMDtcblxuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmIHRpbWVvdXRJZCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgZXhlY3V0aW5nIHRoZSBgZnVuY2AgZnVuY3Rpb24gdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC5cbiAgICAgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHsgY29uc29sZS5sb2codGV4dCk7IH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZlcihmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZnVuY2AgZnVuY3Rpb24gYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgZXhlY3V0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7IGNvbnNvbGUubG9nKHRleHQpOyB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBsb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbGF5KGZ1bmMsIHdhaXQpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdFxuICAgICAqIGJhc2VkIG9uIHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGVcbiAgICAgKiBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgY2FjaGUga2V5LlxuICAgICAqIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIFRoZSByZXN1bHQgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gQSBmdW5jdGlvbiB1c2VkIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmaWJvbmFjY2kgPSBfLm1lbW9pemUoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAyID8gbiA6IGZpYm9uYWNjaShuIC0gMSkgKyBmaWJvbmFjY2kobiAtIDIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmlib25hY2NpKDkpXG4gICAgICogLy8gPT4gMzRcbiAgICAgKlxuICAgICAqIHZhciBkYXRhID0ge1xuICAgICAqICAgJ2ZyZWQnOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyBtb2RpZnlpbmcgdGhlIHJlc3VsdCBjYWNoZVxuICAgICAqIHZhciBnZXQgPSBfLm1lbW9pemUoZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gZGF0YVtuYW1lXTsgfSwgXy5pZGVudGl0eSk7XG4gICAgICogZ2V0KCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqXG4gICAgICogZ2V0LmNhY2hlLnBlYmJsZXMubmFtZSA9ICdwZW5lbG9wZSc7XG4gICAgICogZ2V0KCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdwZW5lbG9wZScsICdhZ2UnOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBtZW1vaXplZC5jYWNoZSxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleVByZWZpeCArIGFyZ3VtZW50c1swXTtcblxuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwga2V5KVxuICAgICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICAgIDogKGNhY2hlW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSB7fTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGV4ZWN1dGUgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxscyB0b1xuICAgICAqIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNhbGwuIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyBgaW5pdGlhbGl6ZWAgZXhlY3V0ZXMgYGNyZWF0ZUFwcGxpY2F0aW9uYCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICB2YXIgcmFuLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyYW4pIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgYGZ1bmNgIHZhcmlhYmxlIHNvIHRoZSBmdW5jdGlvbiBtYXkgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCBhbnkgYWRkaXRpb25hbFxuICAgICAqIGBwYXJ0aWFsYCBhcmd1bWVudHMgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uIFRoaXNcbiAgICAgKiBtZXRob2QgaXMgc2ltaWxhciB0byBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkgeyByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lOyB9O1xuICAgICAqIHZhciBoaSA9IF8ucGFydGlhbChncmVldCwgJ2hpJyk7XG4gICAgICogaGkoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDE2LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IGBwYXJ0aWFsYCBhcmd1bWVudHMgYXJlXG4gICAgICogYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHNEZWVwID0gXy5wYXJ0aWFsUmlnaHQoXy5tZXJnZSwgXy5kZWZhdWx0cyk7XG4gICAgICpcbiAgICAgKiB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICd2YXJpYWJsZSc6ICdkYXRhJyxcbiAgICAgKiAgICdpbXBvcnRzJzogeyAnanEnOiAkIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZGVmYXVsdHNEZWVwKG9wdGlvbnMsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG4gICAgICpcbiAgICAgKiBvcHRpb25zLnZhcmlhYmxlXG4gICAgICogLy8gPT4gJ2RhdGEnXG4gICAgICpcbiAgICAgKiBvcHRpb25zLmltcG9ydHNcbiAgICAgKiAvLyA9PiB7ICdfJzogXywgJ2pxJzogJCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbFJpZ2h0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDMyLCBudWxsLCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBleGVjdXRlZCwgd2lsbCBvbmx5IGNhbGwgdGhlIGBmdW5jYCBmdW5jdGlvblxuICAgICAqIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0b1xuICAgICAqIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlXG4gICAgICogb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbFxuICAgICAqIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGV4ZWN1dGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmdcbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIGV4ZWN1dGUgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlc1xuICAgICAqIGpRdWVyeSgnLmludGVyYWN0aXZlJykub24oJ2NsaWNrJywgXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHtcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZU9wdGlvbnMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICBkZWJvdW5jZU9wdGlvbnMubWF4V2FpdCA9IHdhaXQ7XG4gICAgICBkZWJvdW5jZU9wdGlvbnMudHJhaWxpbmcgPSB0cmFpbGluZztcblxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGRlYm91bmNlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLiBUaGUgd3JhcHBlciBpcyBleGVjdXRlZCB3aXRoXG4gICAgICogdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPkZyZWQsIFdpbG1hLCAmYW1wOyBQZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcih3cmFwcGVyLCAxNiwgW3ZhbHVlXSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICAgICAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBjYWxsYmFjayBib3VuZCB0byBhbiBvcHRpb25hbCBgdGhpc0FyZ2AuIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5XG4gICAgICogbmFtZSB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBJZiBgZnVuY2AgaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHNcbiAgICAgKiB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnQgb2JqZWN0IHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBjYWxsYmFjayBhY2NlcHRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogXy5jcmVhdGVDYWxsYmFjayA9IF8ud3JhcChfLmNyZWF0ZUNhbGxiYWNrLCBmdW5jdGlvbihmdW5jLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGNhbGxiYWNrKTtcbiAgICAgKiAgIHJldHVybiAhbWF0Y2ggPyBmdW5jKGNhbGxiYWNrLCB0aGlzQXJnKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0JyA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXSA6IG9iamVjdFttYXRjaFsxXV0gPCBtYXRjaFszXTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYWdlX19ndDM4Jyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICAgICAgaWYgKGZ1bmMgPT0gbnVsbCB8fCB0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgXCJfLnBsdWNrXCIgc3R5bGUgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAgaWYgKHR5cGUgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5KGZ1bmMpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0ga2V5cyhmdW5jKSxcbiAgICAgICAgICBrZXkgPSBwcm9wc1swXSxcbiAgICAgICAgICBhID0gZnVuY1trZXldO1xuXG4gICAgICAvLyBoYW5kbGUgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PSAxICYmIGEgPT09IGEgJiYgIWlzT2JqZWN0KGEpKSB7XG4gICAgICAgIC8vIGZhc3QgcGF0aCB0aGUgY29tbW9uIGNhc2Ugb2YgcHJvdmlkaW5nIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlXG4gICAgICAgIC8vIHByb3BlcnR5IGNvbnRhaW5pbmcgYSBwcmltaXRpdmUgdmFsdWVcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHZhciBiID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgcmV0dXJuIGEgPT09IGIgJiYgKGEgIT09IDAgfHwgKDEgLyBhID09IDEgLyBiKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBiYXNlSXNFcXVhbChvYmplY3RbcHJvcHNbbGVuZ3RoXV0sIGZ1bmNbcHJvcHNbbGVuZ3RoXV0sIG51bGwsIHRydWUpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIGAmYCwgYDxgLCBgPmAsIGBcImAsIGFuZCBgJ2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24gbWV0aG9kcyB3aWxsIGJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWQgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0pO1xuICAgICAqIF8uY2FwaXRhbGl6ZSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGFpbiA9IHRydWUsXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBzb3VyY2UgJiYgZnVuY3Rpb25zKHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlIHx8ICghb3B0aW9ucyAmJiAhbWV0aG9kTmFtZXMubGVuZ3RoKSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBjdG9yID0gbG9kYXNoV3JhcHBlcjtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSBsb2Rhc2g7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gZnVuY3Rpb25zKHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY2hhaW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNoYWluID0gb3B0aW9ucy5jaGFpbjtcbiAgICAgIH1cbiAgICAgIHZhciBjdG9yID0gb2JqZWN0LFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24oY3Rvcik7XG5cbiAgICAgIGZvckVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBvYmplY3RbbWV0aG9kTmFtZV0gPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdmFsdWVdO1xuXG4gICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcmVzdWx0ICYmIGlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgY3RvcihyZXN1bHQpO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlICdfJyB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBjb250ZXh0Ll8gPSBvbGREYXNoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogXy5ub29wKG9iamVjdCkgPT09IHVuZGVmaW5lZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIG5vIG9wZXJhdGlvbiBwZXJmb3JtZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzdGFtcCA9IF8ubm93KCk7XG4gICAgICogXy5kZWZlcihmdW5jdGlvbigpIHsgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTsgfSk7XG4gICAgICogLy8gPT4gbG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGlzTmF0aXZlKG5vdyA9IERhdGUubm93KSAmJiBub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICAgKiBJZiBgcmFkaXhgIGlzIGB1bmRlZmluZWRgIG9yIGAwYCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyB0aGVcbiAgICAgKiBgdmFsdWVgIGlzIGEgaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGF2b2lkcyBkaWZmZXJlbmNlcyBpbiBuYXRpdmUgRVMzIGFuZCBFUzUgYHBhcnNlSW50YFxuICAgICAqIGltcGxlbWVudGF0aW9ucy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyNFLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBuZXcgaW50ZWdlciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICovXG4gICAgdmFyIHBhcnNlSW50ID0gbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZSArICcwOCcpID09IDggPyBuYXRpdmVQYXJzZUludCA6IGZ1bmN0aW9uKHZhbHVlLCByYWRpeCkge1xuICAgICAgLy8gRmlyZWZveCA8IDIxIGFuZCBPcGVyYSA8IDE1IGZvbGxvdyB0aGUgRVMzIHNwZWNpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBgcGFyc2VJbnRgXG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZShyZUxlYWRpbmdTcGFjZXNBbmRaZXJvcywgJycpIDogdmFsdWUsIHJhZGl4IHx8IDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgXCJfLnBsdWNrXCIgc3R5bGUgZnVuY3Rpb24sIHdoaWNoIHJldHVybnMgdGhlIGBrZXlgIHZhbHVlIG9mIGFcbiAgICAgKiBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGdldE5hbWUgPSBfLnByb3BlcnR5KCduYW1lJyk7XG4gICAgICpcbiAgICAgKiBfLm1hcChjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KGtleSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCAoaW5jbHVzaXZlKS4gSWYgb25seSBvbmVcbiAgICAgKiBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlciB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgdHJ1ZXkgb3IgZWl0aGVyIGBtaW5gIG9yIGBtYXhgIGFyZSBmbG9hdHMgYVxuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlciB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZz1mYWxzZV0gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCBmbG9hdGluZykge1xuICAgICAgdmFyIG5vTWluID0gbWluID09IG51bGwsXG4gICAgICAgICAgbm9NYXggPSBtYXggPT0gbnVsbDtcblxuICAgICAgaWYgKGZsb2F0aW5nID09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gPT0gJ2Jvb2xlYW4nICYmIG5vTWF4KSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtaW47XG4gICAgICAgICAgbWluID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbm9NYXggJiYgdHlwZW9mIG1heCA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1heDtcbiAgICAgICAgICBub01heCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub01pbiAmJiBub01heCkge1xuICAgICAgICBtYXggPSAxO1xuICAgICAgfVxuICAgICAgbWluID0gK21pbiB8fCAwO1xuICAgICAgaWYgKG5vTWF4KSB7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9ICttYXggfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBtaW4gJSAxIHx8IG1heCAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihtaW4gKyAocmFuZCAqIChtYXggLSBtaW4gKyBwYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsnJykubGVuZ3RoIC0gMSkpKSksIG1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHZhbHVlIG9mIHByb3BlcnR5IGBrZXlgIG9uIGBvYmplY3RgLiBJZiBga2V5YCBpcyBhIGZ1bmN0aW9uXG4gICAgICogaXQgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBvYmplY3RgIGFuZCBpdHMgcmVzdWx0IHJldHVybmVkLFxuICAgICAqIGVsc2UgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJldHVybmVkLiBJZiBgb2JqZWN0YCBpcyBmYWxzZXkgdGhlbiBgdW5kZWZpbmVkYFxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2NoZWVzZSc6ICdjcnVtcGV0cycsXG4gICAgICogICAnc3R1ZmYnOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuICdub25zZW5zZSc7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2NoZWVzZScpO1xuICAgICAqIC8vID0+ICdjcnVtcGV0cydcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ3N0dWZmJyk7XG4gICAgICogLy8gPT4gJ25vbnNlbnNlJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gb2JqZWN0W2tleV0oKSA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbWljcm8tdGVtcGxhdGluZyBtZXRob2QgdGhhdCBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXNcbiAgICAgKiB3aGl0ZXNwYWNlLCBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCwgYF8udGVtcGxhdGVgIHV0aWxpemVzIHNvdXJjZVVSTHMgZm9yIGVhc2llclxuICAgICAqIGRlYnVnZ2luZy4gU2VlIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlOlxuICAgICAqIGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWU6XG4gICAgICogaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3N0YWJsZS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsLmh0bWxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBsb2NhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufHN0cmluZ30gUmV0dXJucyBhIGNvbXBpbGVkIGZ1bmN0aW9uIHdoZW4gbm8gYGRhdGFgIG9iamVjdFxuICAgICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIEhUTUwgaW4gZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyAkeyBuYW1lIH0nLCB7ICduYW1lJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgbmFtZSk7ICU+IScsIHsgJ25hbWUnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgICogICAnaW50ZXJwb2xhdGUnOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvIHt7IG5hbWUgfX0hJywgeyAnbmFtZSc6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBqUXVlcnlcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBqcS5lYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+JywgbnVsbCwgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IGZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3JcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLm5hbWUgJT4hJywgbnVsbCwgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgIHZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZTtcbiAgICAgKiAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLm5hbWUgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAgIHJldHVybiBfX3A7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgLy8gYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy9cbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0IHx8ICcnKTtcblxuICAgICAgLy8gYXZvaWQgbWlzc2luZyBkZXBlbmRlbmNpZXMgd2hlbiBgaXRlcmF0b3JUZW1wbGF0ZWAgaXMgbm90IGRlZmluZWRcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0dGluZ3MpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gdmFsdWVzKGltcG9ydHMpO1xuXG4gICAgICB2YXIgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gY29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICB0ZXh0LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyByZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0c1xuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gaWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkLCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpblxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZSxcbiAgICAgICAgICBoYXNWYXJpYWJsZSA9IHZhcmlhYmxlO1xuXG4gICAgICBpZiAoIWhhc1ZhcmlhYmxlKSB7XG4gICAgICAgIHZhcmlhYmxlID0gJ29iaic7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoICgnICsgdmFyaWFibGUgKyAnKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5nc1xuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBmcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArIHZhcmlhYmxlICsgJykge1xcbicgK1xuICAgICAgICAoaGFzVmFyaWFibGUgPyAnJyA6IHZhcmlhYmxlICsgJyB8fCAoJyArIHZhcmlhYmxlICsgJyA9IHt9KTtcXG4nKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlXCIgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICdcXG4vKlxcbi8vIyBzb3VyY2VVUkw9JyArIChvcHRpb25zLnNvdXJjZVVSTCB8fCAnL2xvZGFzaC90ZW1wbGF0ZS9zb3VyY2VbJyArICh0ZW1wbGF0ZUNvdW50ZXIrKykgKyAnXScpICsgJ1xcbiovJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uKGltcG9ydHNLZXlzLCAncmV0dXJuICcgKyBzb3VyY2UgKyBzb3VyY2VVUkwpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGRhdGEpO1xuICAgICAgfVxuICAgICAgLy8gcHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kLCBpblxuICAgICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyBtYWdlLmNhc3RTcGVsbChuKTsgfSk7XG4gICAgICogLy8gPT4gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcywgcGFzc2luZyBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgdGhpcy5jYXN0KG4pOyB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgbiA9IChuID0gK24pID4gLTEgPyBuIDogMDtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYCB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ0ZyZWQsIEJhcm5leSAmYW1wOyBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIEJhcm5leSAmIFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgd2lsbCBiZSBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBTdHJpbmcocHJlZml4ID09IG51bGwgPyAnJyA6IHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCBleHBsaWNpdFxuICAgICAqIG1ldGhvZCBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKGNoYXJhY3RlcnMpXG4gICAgICogICAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIubmFtZSArICcgaXMgJyArIGNoci5hZ2U7IH0pXG4gICAgICogICAgIC5maXJzdCgpXG4gICAgICogICAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBpbnRlcmNlcHRvcmAgd2l0aCB0aGUgYHZhbHVlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIGB2YWx1ZWAuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZFxuICAgICAqIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW5cbiAgICAgKiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzLCA0XSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkgeyBhcnJheS5wb3AoKTsgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygnYWdlJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nIHJlc3VsdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZU9mXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5kcm9wID0gcmVzdDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gemlwO1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgICBtaXhpbihsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIG1peGluKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9XG4gICAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCksIGZhbHNlKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLnRha2UgPSBmaXJzdDtcbiAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuXG4gICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNhbGxiYWNrYWJsZSA9IG1ldGhvZE5hbWUgIT09ICdzYW1wbGUnO1xuICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV09IGZ1bmN0aW9uKG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmModGhpcy5fX3dyYXBwZWRfXywgbiwgZ3VhcmQpO1xuXG4gICAgICAgICAgcmV0dXJuICFjaGFpbkFsbCAmJiAobiA9PSBudWxsIHx8IChndWFyZCAmJiAhKGNhbGxiYWNrYWJsZSAmJiB0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSkpXG4gICAgICAgICAgICA/IHJlc3VsdFxuICAgICAgICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSAnMi40LjInO1xuXG4gICAgLy8gYWRkIFwiQ2hhaW5pbmdcIiBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZU9mO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IHdyYXBwZXJWYWx1ZU9mO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnam9pbicsICdwb3AnLCAnc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYWluQWxsXG4gICAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgZXhpc3Rpbmcgd3JhcHBlZCB2YWx1ZVxuICAgIGZvckVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyksIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIExvLURhc2hcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCBpcyBsb2FkZWQgd2l0aCBhIFJlcXVpcmVKUyBzaGltIGNvbmZpZy5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbCNjb25maWctc2hpbVxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIGluIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmVcbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLypcblx0Y29zdHM6IHtcblx0XHRkZWxldGU6IG51bWJlciB8IGZ1bmN0aW9uICggY2hhciApXG5cdFx0aW5zZXJ0OiBudW1iZXIgfCBmdW5jdGlvbiAoIGNoYXIgKVxuXHRcdHJlcGxhY2U6IG51bWJlciB8IGZ1bmN0aW9uICggd2hhdCwgYnkgKVxuXHRcdHRyYW5zcG9zZTogbnVtYmVyIHwgZnVuY3Rpb24gKCBsZWZ0LCByaWdodCApXG5cdH1cbiovXG5cbmZ1bmN0aW9uIGdldENvc3QoIGNvc3RzLCBvcCwgYSwgYiApIHtcblx0bGV0IGNvc3QgPSB0eXBlb2YgY29zdHMgPT0gYG9iamVjdGAgPyBjb3N0c1sgb3AgXSA6IGNvc3RzXG5cdHJldHVybiB0eXBlb2YgY29zdCA9PSBgZnVuY3Rpb25gID8gY29zdC5jYWxsKCBjb3N0cywgYSwgYiApIDogY29zdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggczEsIHMyLCBjb3N0cyA9IDEgKSA9PiB7XG5cdGxldCBkID0gW11cblx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHMxLmxlbmd0aDsgKytpICkge1xuXHRcdGRbIGkgXSA9IGkgPCAzID8gW10gOiBkWyBpIC0gMyBdIC8vIHNvbWUgb3B0aW1pemF0aW9uXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHMyLmxlbmd0aDsgKytqIClcblx0XHRcdGRbIGkgXVsgaiBdID1cblx0XHRcdFx0aSA9PSAwICYmIGogPT0gMCA/XG5cdFx0XHRcdFx0MFxuXHRcdFx0XHQ6IGkgPT0gMCA/XG5cdFx0XHRcdFx0ZFsgaSBdWyBqIC0gMSBdICsgZ2V0Q29zdCggY29zdHMsIGBpbnNlcnRgLCBzMlsgaiAtIDEgXSApXG5cdFx0XHRcdDogaiA9PSAwID9cblx0XHRcdFx0XHRkWyBpIC0gMSBdWyBqIF0gKyBnZXRDb3N0KCBjb3N0cywgYGRlbGV0ZWAsIHMxWyBpIC0gMSBdIClcblx0XHRcdFx0OiBNYXRoLm1pbihcblx0XHRcdFx0XHRkWyBpIC0gMSBdWyBqIF0gKyBnZXRDb3N0KCBjb3N0cywgYGRlbGV0ZWAsIHMxWyBpIC0gMSBdICksXG5cdFx0XHRcdFx0ZFsgaSBdWyBqIC0gMSBdICsgZ2V0Q29zdCggY29zdHMsIGBpbnNlcnRgLCBzMlsgaiAtIDEgXSApLFxuXHRcdFx0XHRcdGRbIGkgLSAxIF1bIGogLSAxIF0gKyAoIHMxWyBpIC0gMSBdID09IHMyWyBqIC0gMSBdID8gMCA6IGdldENvc3QoIGNvc3RzLCBgcmVwbGFjZWAsIHMxWyBpIC0gMSBdLCBzMlsgaiAtIDEgXSApICksXG5cdFx0XHRcdFx0KCBpID4gMSAmJiBqID4gMSAmJiBzMVsgaSAtIDEgXSA9PSBzMlsgaiAtIDIgXSAmJiBzMVsgaSAtIDIgXSA9PSBzMlsgaiAtIDEgXSApXG5cdFx0XHRcdFx0XHQ/IGRbIGkgLSAyIF1bIGogLSAyIF0gKyBnZXRDb3N0KCBjb3N0cywgYHRyYW5zcG9zZWAsIHMxWyBpIC0gMiBdLCBzMVsgaSAtIDEgXSApIDogSW5maW5pdHlcblx0XHRcdFx0KVxuXHR9XG5cdHJldHVybiBkWyBzMS5sZW5ndGggXVsgczIubGVuZ3RoIF1cbn1cbiIsImxldCByYSA9IHJlcXVpcmUoIGByYWAgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgga2V5LCBkZWZhdWx0cyA9IG51bGwgKSB7XG5cdGxldCByZXQgPSByYS5jbGVhbiggZGVmYXVsdHMgKVxuXHQuc2V0Q29uc3QoIFwicmVzZXRcIiwgKCkgPT4ge1xuXHRcdFx0bG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oIGtleSApXG5cdFx0XHRyZXQuYXNzaWduKCBkZWZhdWx0cyApXG5cdFx0XHQvLyByZXQubG9hZGVkID0gdHJ1ZVxuXHRcdH1cblx0KVxuXHQuc2V0TmFtZSggXCJsb2NhbFN0b3JhZ2UuXCIgKyBrZXkgKVxuXHRsZXQgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oIGtleSApXG5cdGlmICggc3RvcmVkICE9IG51bGwgKVxuXHRcdHJldC5hc3NpZ24oIEpTT04ucGFyc2UoIHN0b3JlZCApIClcblx0cmEuY2xlYW4oICgpID0+IHtcblx0XHRpZiAoIHJldC52YWx1ZU9mKCkgIT0gZGVmYXVsdHMgKVxuXHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oIGtleSwgSlNPTi5zdHJpbmdpZnkoIHJldCApIClcblx0fSApXG5cdHJldHVybiByZXRcbn1cbiIsInJlcXVpcmUoIGBjb2xvcnNgIClcblxubGV0IExPRyA9ICggbXNnLCAuLi5kYXRhICkgPT4gY29uc29sZS5sb2coIGAkeyAoIG5ldyBEYXRlICkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCBgVGAsIGA9YCApLnJlcGxhY2UoIGBaYCwgYGAgKSB9ICR7IG1zZyB9YCwgLi4uZGF0YSApXG5MT0cuTE9HID0gTE9HXG5MT0cuSU5GTyA9IExPR1xuTE9HLlRSQUNFID0gTE9HXG5MT0cuRVJST1IgPSBMT0dcbkxPRy5XQVJOSU5HID0gTE9HXG5cbm1vZHVsZS5leHBvcnRzID0gTE9HXG4iLCJsZXQgbG9kYXNoID0gcmVxdWlyZSggYGxvZGFzaGAgKVxuXG5jbGFzcyBQb25nSlNPTiBleHRlbmRzIHJlcXVpcmUoIGBXZWJRdWV1ZWAgKSB7XG5cdGNvbnN0cnVjdG9yKCBxICkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLl9xID0gcVxuXHRcdHRoaXMucGlwZUZyb20oIHEgKVxuXHRcdHEub25tZXNzYWdlID0gbWVzc2FnZSA9PiB0aGlzLl9tZXNzYWdlKCBtZXNzYWdlIClcblx0fVxuXHR1bndpc2UoKSB7XG5cdFx0bGV0IHEgPSB0aGlzLl9xXG5cdFx0dGhpcy5fcSA9IG51bGxcblx0XHRxLm9ub3BlbiA9IG51bGxcblx0XHRxLm9uY2xvc2UgPSBudWxsXG5cdFx0cS5vbmVycm9yID0gbnVsbFxuXHRcdHEub25tZXNzYWdlID0gbnVsbFxuXHRcdHJldHVybiBxLnVud2lzZSA/IHEudW53aXNlKCkgOiBxXG5cdH1cblx0X21lc3NhZ2UoIG1lc3NhZ2UgKSB7XG5cdFx0aWYgKCBtZXNzYWdlLndoYXQgPT0gYHBpbmdgIClcblx0XHRcdHRoaXMuX3Euc2VuZCggeyB3aGF0OiBgcG9uZ2AsIHBvbmc6IG1lc3NhZ2UucGluZyB9IClcblx0XHRlbHNlXG5cdFx0XHR0aGlzLmRvbWVzc2FnZSggbWVzc2FnZSApXG5cdH1cblx0X3NlbmQoIG1lc3NhZ2UgKSB7XG5cdFx0dGhpcy5fcS5zZW5kKCBtZXNzYWdlIClcblx0fVxuXHRfY2xvc2UoKSB7XG5cdFx0dGhpcy5fcS5vbmNsb3NlID0gbnVsbFxuXHRcdHRoaXMuX3EuY2xvc2UoKVxuXHR9XG59XG5cbmNsYXNzIFBpbmdQb25nSlNPTiBleHRlbmRzIFBvbmdKU09OIHtcblx0Y29uc3RydWN0b3IoIHEsIHsgaW50ZXJ2YWwgPSA2MDAwMCwgdGltZW91dCA9IDE1MDAwLCBtYXhwaW5ncyA9IDEwMDAgfSA9IHt9ICkge1xuXHRcdHN1cGVyKCBxIClcblx0XHR0aGlzLl9waW5ncyA9IHt9XG5cdFx0dGhpcy5fY291bnQgPSAwXG5cdFx0dGhpcy5fcGludGVydmFsID0gaW50ZXJ2YWwgPT0gSW5maW5pdHkgPyBudWxsIDogc2V0SW50ZXJ2YWwoICgpID0+IHRoaXMucGluZygpLCBpbnRlcnZhbCApXG5cdFx0dGhpcy5fdGltZW91dCA9IHRpbWVvdXRcblx0XHR0aGlzLl9tYXhwaW5ncyA9IG1heHBpbmdzXG5cdH1cblx0X21lc3NhZ2UoIG1lc3NhZ2UgKSB7XG5cdFx0aWYgKCBtZXNzYWdlLndoYXQgPT0gYHBvbmdgICkge1xuXHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHRoaXMuX3BpbmdzLCBtZXNzYWdlLnBvbmcgKSApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLl9waW5nc1sgbWVzc2FnZS5wb25nIF0gKVxuXHRcdFx0XHRkZWxldGUgdGhpcy5fcGluZ3NbIG1lc3NhZ2UucG9uZyBdXG5cdFx0XHRcdC0tdGhpcy5fY291bnRcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0c3VwZXIuX21lc3NhZ2UoIG1lc3NhZ2UgKVxuXHR9XG5cdF9zZW5kKCBtZXNzYWdlICkge1xuXHRcdHN1cGVyLl9zZW5kKCBtZXNzYWdlIClcblx0XHR0aGlzLnBpbmcoKVxuXHR9XG5cdF9jbG9zZSgpIHtcblx0XHRjbGVhckludGVydmFsKCB0aGlzLl9waW50ZXJ2YWwgKVxuXHRcdHRoaXMuX3BpbnRlcnZhbCA9IG51bGxcblx0XHRsb2Rhc2guZm9yRWFjaCggdGhpcy5fcGluZ3MsIHQgPT4gY2xlYXJUaW1lb3V0KCB0ICkgKVxuXHRcdHRoaXMuX3BpbmdzID0gbnVsbFxuXHRcdHN1cGVyLl9jbG9zZSgpXG5cdH1cblx0cGluZygpIHtcblx0XHRpZiAoICF0aGlzLl9xIClcblx0XHRcdHJldHVyblxuXHRcdGlmICggdGhpcy5fY291bnQgPiB0aGlzLl9tYXhwaW5ncyApXG5cdFx0XHRyZXR1cm4gdGhpcy5fb250aW1lb3V0KClcblx0XHRsZXQgaWQgPSBgJHsgTWF0aC5yYW5kb20oKSB9YFxuXHRcdHRoaXMuX3Euc2VuZCggeyB3aGF0OiBgcGluZ2AsIHBpbmc6IGlkIH0gKVxuXHRcdHRoaXMuX3BpbmdzWyBpZCBdID0gc2V0VGltZW91dCggKCkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coIGlkLnJlZCApXG5cdFx0XHR0aGlzLl9vbnRpbWVvdXQoKVxuXHRcdH0sIHRoaXMuX3RpbWVvdXQgKVxuXHRcdCsrdGhpcy5fY291bnRcblx0fVxuXHRfb250aW1lb3V0KCkge1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLmRvZXJyb3IoIG5ldyBFcnJvciggYHRpbWVvdXRgICkgKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuY2xvc2UoKVxuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggcSwgb3B0aW9ucyApID0+IG5ldyBQaW5nUG9uZ0pTT04oIHEsIG9wdGlvbnMgKVxubW9kdWxlLmV4cG9ydHMuc2lsZW50ID0gcSA9PiBuZXcgUG9uZ0pTT04oIHEgKVxuIiwiY2xhc3MgV2ViUXVldWUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLm9ub3BlbiA9IG51bGxcblx0XHR0aGlzLm9uY2xvc2UgPSBudWxsXG5cdFx0dGhpcy5vbm1lc3NhZ2UgPSBudWxsXG5cdFx0dGhpcy5vbmVycm9yID0gbnVsbFxuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlXG5cdFx0dGhpcy5fb3BlbmVkID0gZmFsc2Vcblx0fVxuXHRkb29wZW4oKSB7XG5cdFx0aWYgKCAhdGhpcy5fY2xvc2VkICYmIHRoaXMub25vcGVuICYmICF0aGlzLl9vcGVuZWQgKSB7XG5cdFx0XHR0aGlzLl9vcGVuZWQgPSB0cnVlXG5cdFx0XHR0aGlzLm9ub3BlbigpXG5cdFx0fVxuXHR9XG5cdGRvY2xvc2UoKSB7XG5cdFx0aWYoIHRoaXMub25jbG9zZSApXG5cdFx0XHR0aGlzLm9uY2xvc2UoKVxuXHR9XG5cdGRvbWVzc2FnZSggbWVzc2FnZSApIHtcblx0XHRpZiAoICF0aGlzLl9jbG9zZWQgJiYgdGhpcy5vbm1lc3NhZ2UgKSB7XG5cdFx0XHRpZiAoICF0aGlzLl9vcGVuZWQgKVxuXHRcdFx0XHR0aGlzLmRvb3BlbigpXG5cdFx0XHR0aGlzLm9ubWVzc2FnZSggbWVzc2FnZSApXG5cdFx0fVxuXHR9XG5cdGRvZXJyb3IoIGVycm9yICkge1xuXHRcdGlmICggdGhpcy5vbmVycm9yIClcblx0XHRcdHRoaXMub25lcnJvciggZXJyb3IgKVxuXHRcdGVsc2Vcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soICgpID0+IHsgdGhyb3cgZXJyb3IgfSApXG5cdH1cblx0X3NlbmQoKSB7fVxuXHRzZW5kKCBtZXNzYWdlICkge1xuXHRcdGlmICggIXRoaXMuX2Nsb3NlZCApXG5cdFx0XHR0aGlzLl9zZW5kKCBtZXNzYWdlIClcblx0fVxuXHRfY2xvc2UoKSB7fVxuXHRjbG9zZSgpIHtcblx0XHRpZiAoIHRoaXMuX2Nsb3NlZCApXG5cdFx0XHRyZXR1cm5cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5fY2xvc2UoKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHRoaXMuX2Nsb3NlZCA9IHRydWVcblx0XHRcdHRoaXMuZG9jbG9zZSgpXG5cdFx0fVxuXHR9XG5cdHBpcGVGcm9tKCBxICkge1xuXHRcdHEub25vcGVuID0gKCkgPT4gdGhpcy5kb29wZW4oKVxuXHRcdHEub25jbG9zZSA9ICgpID0+IHRoaXMuY2xvc2UoKVxuXHRcdHEub25lcnJvciA9IGVycm9yID0+IHRoaXMuZG9lcnJvciggZXJyb3IgKVxuXHRcdHEub25tZXNzYWdlID0gbWVzc2FnZSA9PiB0aGlzLmRvbWVzc2FnZSggbWVzc2FnZSApXG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJRdWV1ZVxuIiwiY2xhc3MgV2ViU29ja2V0VG9KU09OIGV4dGVuZHMgcmVxdWlyZSggYFdlYlF1ZXVlYCApIHtcblx0Y29uc3RydWN0b3IoIHdzICkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLl93cyA9IHdzXG5cdFx0dGhpcy5waXBlRnJvbSggd3MgKVxuXHRcdHdzLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcblx0XHRcdGxldCBtZXNzYWdlXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRtZXNzYWdlID0gSlNPTi5wYXJzZSggU3RyaW5nKCBldmVudC5kYXRhICkgKVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9lcnJvciggZXJyb3IgKVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5kb21lc3NhZ2UoIG1lc3NhZ2UgKVxuXHRcdH1cblx0fVxuXHR1bndpc2UoKSB7XG5cdFx0bGV0IHdzID0gdGhpcy5fd3Ncblx0XHR0aGlzLl93cyA9IG51bGxcblx0XHR3cy5vbm9wZW4gPSBudWxsXG5cdFx0d3Mub25jbG9zZSA9IG51bGxcblx0XHR3cy5vbmVycm9yID0gbnVsbFxuXHRcdHdzLm9ubWVzc2FnZSA9IG51bGxcblx0XHRyZXR1cm4gd3Ncblx0fVxuXHRfc2VuZCggbWVzc2FnZSApIHsgdGhpcy5fd3Muc2VuZCggSlNPTi5zdHJpbmdpZnkoIG1lc3NhZ2UgKSApIH1cblx0X2Nsb3NlKCkge1xuXHRcdHRoaXMuX3dzLm9uY2xvc2UgPSBudWxsXG5cdFx0dGhpcy5fd3MuY2xvc2UoKVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3MgPT4gbmV3IFdlYlNvY2tldFRvSlNPTiggd3MgKVxuIiwiLypcblxuVE9ETyAyMDE1LjAzLjI1INCjINCi0Jcg0L3QtSDQsdGL0LvQvjog0KDRjdC00LDQs9Cw0LLQsNC90YzQvdC1INC80LXRgdGG0LDRniDQvNCw0LPRh9GL0LzQsCDQv9Cw0YLRgNGN0LHQvdCw0LUg0YLQvtC70YzQutGWINC70LDQutCw0LvRjNC90LAg0Lcg0LDRgdC+0LHQvdGL0LzRliDQutCw0LzQsNC90LTQsNC80ZYg0LzQtdC90Y4gXCLQt9Cw0YXQsNCy0LDRhtGMINC00LvRjyDQt9C80L7RntGH0LDQvdCw0LPQsFwiINGWIFwi0LfQsNCz0YDRg9C30ZbRhtGMINC90LAg0Z7RgdC1INC/0YDRi9C70LDQtNGLXCIuXG5cbiovXG5sZXQgSlNPTmxvY2FsID0gcmVxdWlyZSggYEpTT05sb2NhbGAgKVxubGV0IGx1ID0gcmVxdWlyZSggYGxvY2FsVXRpbHNgIClcbmxldCByYSA9IHJlcXVpcmUoIGByYWAgKVxubGV0IGxvZGFzaCA9IHJlcXVpcmUoIGBsb2Rhc2hgIClcbmxldCBVSUQgPSByZXF1aXJlKCBgdWlkYCApXG5sZXQgaHR0cENsaWVudCA9IHJlcXVpcmUoIGBodHRwQ2xpZW50YCApXG5sZXQgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSggYGV2ZW50c2AgKS5FdmVudEVtaXR0ZXIgfHwgcmVxdWlyZSggYGV2ZW50c2AgKVxuLy8gbGV0IGRldmljZUFjdGlvbnMgPSByZXF1aXJlKCBgbmV0cm8vZGV2aWNlQWN0aW9uc2AgKVxubGV0IFdlYlNvY2tldFRvSlNPTiA9IHJlcXVpcmUoIGBXZWJTb2NrZXRUb0pTT05gIClcbmxldCBQaW5nUG9uZ0pTT04gPSByZXF1aXJlKCBgUGluZ1BvbmdKU09OYCApXG5sZXQgZGV2ZGIgPSByZXF1aXJlKCBgZGV2ZGJgIClcblxubGV0IFdlYlNvY2tldFJldHJ5ID0gMTAwMFxubGV0IHNhdmVQbGFjZXNUaW1lb3V0ID0gMzAwMFxuXG5jbGFzcyBQZXJzaXN0ZW50V2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuXHRjb25zdHJ1Y3RvciAoIHVybCApIHtcblx0XHRzdXBlcigpXG5cdFx0dGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuXHRcdHRoaXMuY2xvc2VkID0gZmFsc2Vcblx0XHR0aGlzLl93cyA9IG51bGxcblx0XHR0aGlzLl9zaGVkdWxlZENyZWF0aW5nID0gbnVsbFxuXHRcdHRoaXMuX2ZpcnN0ID0gdHJ1ZVxuXHRcdHRoaXMuX2xhc3RDbG9zZSA9IC1JbmZpbml0eVxuXHRcdHRoaXMudXJsID0gdXJsXG5cdFx0dGhpcy51c2VyID0gdW5kZWZpbmVkXG5cdFx0dGhpcy5rZXkgPSB1bmRlZmluZWRcblx0XHQvLyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggYF9hcHBsaWNhdGlvbl9yZXN1bWVkYCApXG5cdH1cblxuXHRnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy5fdXJsIH1cblx0c2V0IHVybCggdXJsICkge1xuXHRcdHRoaXMuX3VybCA9IHVybFxuXHRcdHRoaXMuX2NyZWF0ZUhhbmRsZSgpXG5cdH1cblxuXHRfc2V0Q29ubmVjdGVkKCB2YWx1ZSApIHtcblx0XHR2YWx1ZSA9ICEhdmFsdWVcblx0XHRpZiAoIHRoaXMuY29ubmVjdGVkICE9IHZhbHVlICkge1xuXHRcdFx0dGhpcy5jb25uZWN0ZWQgPSB2YWx1ZVxuXHRcdFx0dGhpcy5lbWl0KCBgY2hhbmdlZGAsIHZhbHVlIClcblx0XHR9XG5cdH1cblxuXHRfY2xlYXJIYW5kbGUoKSB7XG5cdFx0aWYgKCB0aGlzLl93cyApIHtcblx0XHRcdHRoaXMuX3dzLm9uY2xvc2UgPSBudWxsXG5cdFx0XHR0aGlzLl93cy5jbG9zZSgpXG5cdFx0XHR0aGlzLl93cyA9IG51bGxcblx0XHRcdHRoaXMuX3NldENvbm5lY3RlZCggZmFsc2UgKVxuXHRcdH1cblx0XHRpZiAoIHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuX3NoZWR1bGVkQ3JlYXRpbmcgKVxuXHRcdFx0dGhpcy5fc2hlZHVsZWRDcmVhdGluZyA9IG51bGxcblx0XHR9XG5cdH1cblxuXHRfZW5zdXJlSGFuZGxlKCkge1xuXHRcdGlmICggIXRoaXMuX3dzIClcblx0XHRcdHRoaXMuX2NyZWF0ZUhhbmRsZSgpXG5cdH1cblxuXHRfY3JlYXRlSGFuZGxlKCkge1xuXHRcdHRoaXMuX2NsZWFySGFuZGxlKClcblx0XHRpZiAoICF0aGlzLl91cmwgKVxuXHRcdFx0cmV0dXJuXG5cdFx0dGhpcy5fd3MgPSBQaW5nUG9uZ0pTT04oIFdlYlNvY2tldFRvSlNPTiggbmV3IFdlYlNvY2tldCggdGhpcy5fdXJsICkgKSApXG5cdFx0dGhpcy5fd3Mub25jbG9zZSA9ICgpID0+IHtcblx0XHRcdHRoaXMuX3dzID0gbnVsbFxuXHRcdFx0dGhpcy5fc2V0Q29ubmVjdGVkKCBmYWxzZSApXG5cdFx0XHR0aGlzLmVtaXQoIGBwYXVzZWAgKVxuXHRcdFx0aWYgKCAhdGhpcy5jbG9zZWQgKSB7XG5cdFx0XHRcdGxldCB0ID0gdGhpcy5fbGFzdENsb3NlXG5cdFx0XHRcdHRoaXMuX2xhc3RDbG9zZSA9IERhdGUubm93KClcblx0XHRcdFx0dGhpcy5fc2hlZHVsZWRDcmVhdGluZyA9IHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLl9jcmVhdGVIYW5kbGUoKVxuXHRcdFx0XHR9LCBNYXRoLm1heCggMCwgV2ViU29ja2V0UmV0cnkgLSAoIHRoaXMuX2xhc3RDbG9zZSAtIHQgKSApIClcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fd3Mub25lcnJvciA9IGVycm9yID0+IHtcblx0XHRcdHRoaXMuZW1pdCggYGVycm9yYCwgZXJyb3IgKVxuXHRcdH1cblx0XHR0aGlzLl93cy5vbm9wZW4gPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9zZXRDb25uZWN0ZWQoIHRydWUgKVxuXHRcdFx0aWYgKCB0aGlzLl9maXJzdCApIHtcblx0XHRcdFx0dGhpcy5fZmlyc3QgPSBmYWxzZVxuXHRcdFx0XHR0aGlzLmVtaXQoIGBvcGVuYCApXG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVtaXQoIGByZXN1bWVgIClcblx0XHR9XG5cdFx0dGhpcy5fd3Mub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG5cdFx0XHR0aGlzLmVtaXQoIGBtZXNzYWdlYCwgbWVzc2FnZSApXG5cdFx0fVxuXHR9XG5cblx0cmVpbml0KCkge1xuXHRcdHRoaXMuX3dzICYmIHRoaXMuX3dzLmNsb3NlKClcblx0fVxuXG5cdHNlbmQoIGRhdGEgKSB7XG5cdFx0dGhpcy5fZW5zdXJlSGFuZGxlKClcblx0XHRpZiAoICEoIHRoaXMuX3dzICYmIHRoaXMuY29ubmVjdGVkICYmICF0aGlzLmNsb3NlZCApIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHNvY2tldCBpcyBub3Qgb3BlbmAgKVxuXHRcdHRoaXMuX3dzLnNlbmQoIGRhdGEgKVxuXHR9XG5cblx0ZGVsZXRlKCkge1xuXHRcdHRoaXMuY2xvc2UoKVxuXHR9XG5cblx0Y2xvc2UoKSB7XG5cdFx0dGhpcy5jbG9zZWQgPSB0cnVlXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGUoKVxuXHRcdHRoaXMuZW1pdCggYGNsb3NlYCApXG5cdH1cblxuXHRhc2soIHF1ZXN0aW9uICkgeyByZXR1cm4gY28uZ29jYWxsKCBmdW5jdGlvbiogKCkge1xuXHRcdGxldCBpZCA9IFVJRCgpXG5cdFx0dGhpcy5zZW5kKCB7IGlkLCBxdWVzdGlvbiB9IClcblx0XHRsZXQgbWVzc2FnZSA9IHlpZWxkIHRoaXMuZ2V0KCBpZCApXG5cdFx0aWYgKCBtZXNzYWdlLmVycm9yIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggbWVzc2FnZS5lcnJvciApXG5cdFx0cmV0dXJuIG1lc3NhZ2UuYW5zd2VyXG5cdH0sIHRoaXMgKSB9XG5cblx0Z2V0KCBwcmVkaWNhdGUsIHRpbWVvdXQgKSB7IHJldHVybiBjby5nb2NhbGwoIGZ1bmN0aW9uKiAoKSB7XG5cdFx0aWYgKCB0eXBlb2YgcHJlZGljYXRlID09IGBzdHJpbmdgIHx8IHR5cGVvZiBwcmVkaWNhdGUgPT0gYG51bWJlcmAgKSB7XG5cdFx0XHRsZXQgaWQgPSBwcmVkaWNhdGVcblx0XHRcdHByZWRpY2F0ZSA9IG1zZyA9PiBtc2cuaWQgPT0gaWRcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICEoIHR5cGVvZiBwcmVkaWNhdGUgPT0gYGZ1bmN0aW9uYCApICkge1xuXHRcdFx0bGV0IHAgPSBwcmVkaWNhdGVcblx0XHRcdHByZWRpY2F0ZSA9IG1zZyA9PiBsb2Rhc2guZXZlcnkoIHAsICggdmFsdWUsIGtleSApID0+IG1zZ1sga2V5IF0gPT0gdmFsdWUgKVxuXHRcdH1cblx0XHRsZXQgeyBldmVudCwgZGF0YSB9ID0geWllbGQgY28ucmVjZWl2ZSggdGhpcywgeyBjbG9zZTogdHJ1ZSwgbWVzc2FnZTogcHJlZGljYXRlLCB0aW1lb3V0OiB0aW1lb3V0IH0gKVxuXHRcdGlmICggZXZlbnQgPT0gYG1lc3NhZ2VgIClcblx0XHRcdHJldHVybiBkYXRhXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcInRpbWVvdXRcIiApXG5cdH0sIHRoaXMgKSB9XG59XG5cbmZ1bmN0aW9uIHdzQ2xpZW50KCBhcHAsIHVybCApIHtcblx0bGV0IHdzID0gbmV3IFBlcnNpc3RlbnRXZWJTb2NrZXQoKVxuXHRyYSggKCkgPT4gd3MudXJsID0gYXBwLmxvY2FsTW9kZW0gJiYgKCBhcHAubG9jYWxNb2RlbSArIHVybCApIClcblx0d3MuYWN0aXZlID0gcmEub24oIHdzLCBbIGBwYXVzZWAsIGByZXN1bWVgIF0sICgpID0+IHdzLmNvbm5lY3RlZCApXG5cdHJldHVybiB3c1xufVxuXG5mdW5jdGlvbiB3c0pTT05jbGllbnQoIGFwcCwgdXJsICkge1xuXG5cdGxldCBqc29uID0gSlNPTmxvY2FsKCB1cmwsIHsgdWlkOiBudWxsIH0gKVxuXHRsZXQgd3MgPSB3c0NsaWVudCggYXBwLCB1cmwgKVxuXHRsZXQgaW5pdCA9ICgpID0+IHdzLnNlbmQoIHsgd2hhdDogYGluaXRgLCBpZDoganNvbi51aWQgfSApXG5cdGxldCByZXNvbHZlcnMgPSB7fVxuXG5cdGxldCBkb0Vycm9yID0gKCBtZXNzYWdlLCBkYXRhICkgPT4geyB0aHJvdyBuZXcgRXJyb3IoIGB3c0pTT05jbGllbnQ6ICR7IG1lc3NhZ2UgfTogJHsgSlNPTi5zdHJpbmdpZnkoIGRhdGEgKSB9YCApIH1cblxuXHRsdS5vbiggd3MsIHtcblx0XHRyZXN1bWU6IGluaXQsXG5cdFx0bWVzc2FnZSggbWVzc2FnZSApIHsgc3dpdGNoICggbWVzc2FnZS53aGF0ICkge1xuXHRcdFx0Y2FzZSBgZXJyb3JgOlxuXHRcdFx0XHRkb0Vycm9yKCBgZXJyb3IgZnJvbSBzZXJ2ZXJgLCBtZXNzYWdlIClcblx0XHRcdGNhc2UgYHNhdmVkYDoge1xuXHRcdFx0XHRsZXQgcmVzb2x2ZSA9IHJlc29sdmVyc1sgbWVzc2FnZS5tZXNzYWdlSWQgXVxuXHRcdFx0XHRkZWxldGUgcmVzb2x2ZXJzWyBtZXNzYWdlLm1lc3NhZ2VJZCBdXG5cdFx0XHRcdHJlc29sdmUgJiYgcmVzb2x2ZSgpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Y2FzZSBgZGF0YWA6IHtcblx0XHRcdFx0aWYgKCBtZXNzYWdlLnBhcnRpYWwgJiYgbWVzc2FnZS5wcmV2aW91cyAhPSBqc29uLnVpZCApXG5cdFx0XHRcdFx0aW5pdCgpXG5cdFx0XHRcdGVsc2UgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIG1lc3NhZ2UsIGBkYXRhYCApIClcblx0XHRcdFx0XHRqc29uLmFzc2lnbiggbHUuYXBwbHlEaWZmKCBqc29uLnZhbHVlT2YoKSwgbWVzc2FnZS5kYXRhLCBtZXNzYWdlLnBhcnRpYWwgKSApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0ZG9FcnJvciggYHVua25vd24gbWVzc2FnZSBmcm9tIHNlcnZlcmAsIG1lc3NhZ2UgKVxuXHRcdH0gfSxcblx0XHRlcnJvcigpIHtcblx0XHRcdGFwcC5vbkNyZWRlbnRpYWxzKClcblx0XHR9LFxuXHR9IClcblxuXHRmdW5jdGlvbiBkb1JlamVjdCggbWVzc2FnZUlkLCByZWplY3QgKSB7XG5cdFx0ZGVsZXRlIHJlc29sdmVyc1sgbWVzc2FnZUlkIF1cblx0XHRyZWplY3QoKVxuXHR9XG5cblx0bGV0IHNhdmUgPSAoIHBhcnRpYWwsIGRhdGEgKSA9PiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cdFx0bGV0IG1lc3NhZ2VJZCA9IFVJRCgpXG5cdFx0cmVzb2x2ZXJzWyBtZXNzYWdlSWQgXSA9IHJlc29sdmVcblx0XHR3cy5zZW5kKCB7IHdoYXQ6IGBzYXZlYCwgZGF0YTogcGFydGlhbCA/IGRhdGEgOiBPYmplY3QuYXNzaWduKCB7IF9fcGFydGlhbF9fOiBmYWxzZSB9LCBkYXRhIHx8IHt9ICksIG1lc3NhZ2VJZCB9IClcblx0XHRzZXRUaW1lb3V0KCBkb1JlamVjdCwgc2F2ZVBsYWNlc1RpbWVvdXQsIG1lc3NhZ2VJZCwgcmVqZWN0IClcblx0fSApXG5cblx0cmV0dXJuIHtcblx0XHRkYXRhOiBqc29uLmdldFJlYWRPbmx5KCksXG5cdFx0YWN0aXZlOiB3cy5hY3RpdmUsXG5cdFx0c2VuZCggZGF0YSApIHsgcmV0dXJuIHNhdmUoIGZhbHNlLCBkYXRhICkgfSxcblx0XHR1cGRhdGUoIGRhdGEgKSB7IHJldHVybiBzYXZlKCB0cnVlLCBkYXRhICkgfSxcblx0XHRkZWxldGUoKSB7IHdzLmNsb3NlKCkgfSxcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGlkID0+IHtcblxubGV0IGxvY2FsRGVmYXVsdHMgPSB7XG5cdGFjdGl2ZURldmljZUlkOiBgYCxcblx0bGFuZ3VhZ2U6IGBydWAsXG5cdGljb25TaXplOiA0MCwgLy8gbWlsbGltZXRlcnNcblx0bGFiZWxzOiB0cnVlLFxuXHRwbGFjZXNQYWdlczoge1xuXHR9LFxufVxuXG5sZXQgbG9jYWwgPSBKU09ObG9jYWwoIGFwcGlkLCBsb2NhbERlZmF1bHRzIClcblxubGV0IGFwcCA9IHJhLmNsZWFuKCB7XG5cblx0Z2V0TWVzc2FnZSggZGF0YSApIHtcblx0XHRsZXQgbGFuZ3VhZ2UgPSBsb2NhbC5sYW5ndWFnZSB8fCBgcnVgXG5cdFx0cmV0dXJuIFsgbGFuZ3VhZ2UsIGBydWAsIGBlbmAsIGBieWAgXVxuXHRcdFx0LmZpbHRlciggbCA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRhdGEsIGwgKSApXG5cdFx0XHQubWFwKCBsID0+IGRhdGFbIGwgXSApXG5cdFx0XHRbIDAgXVxuXHR9LFxuXG5cdHBhZ2VXaWR0aDogMixcblx0cGFnZUhlaWdodDogMyxcblx0cGFnZVN0YXJ0aW5nOiBmYWxzZSxcblx0ZGlhbG9nOiBgYCxcblx0ZWRpdGluZzogZmFsc2UsXG5cdG1vdmluZzogMCxcblx0aGlzdG9yeTogW10sXG5cdG1lbnVFbGVtZW50OiBudWxsLCAvLyBkaXZcblxuXHRsb2dnZWRpbjogZmFsc2UsXG5cdC8vIGNyZWRlbnRpYWxzOiAxLFxuXHRvbkNyZWRlbnRpYWxzKCkge1xuXHRcdHRoaXMubG9nZ2VkaW4gPSBmYWxzZVxuXHR9LFxuXG5cdGdvKCB0bywgcGF0aCApIHtcblx0XHRpZiAoICF0byApXG5cdFx0XHRyZXR1cm5cblx0XHRsZXQgaCA9IHRoaXMuaGlzdG9yeVxuXHRcdGxldCBhID0gbG9jYWwuYWN0aXZlRGV2aWNlSWRcblx0XHRsZXQgbFxuXHRcdHdoaWxlICggaC5sZW5ndGggJiYgKCBsID0gaFsgaC5sZW5ndGggLSAxIF0sIGwgPT0gdG8gfHwgbCA9PSBhIHx8IHBhdGggJiYgcGF0aC5pbmRleE9mKCBsICkgPj0gMCApIClcblx0XHRcdGgucG9wKClcblx0XHRpZiAoIGEgIT0gdG8gKVxuXHRcdFx0aC5wdXNoKCBhIClcblx0XHRwYXRoICYmIGgucHVzaCggLi4ucGF0aC5maWx0ZXIoIGlkID0+IGlkICE9IHRoaXMubWFpbiApLnJldmVyc2UoKSApXG5cdFx0bG9jYWwuYWN0aXZlRGV2aWNlSWQgPSB0b1xuXHRcdHRoaXMuZGlhbG9nID0gYGBcblx0fSxcblxuXHRiYWNrKCkge1xuXHRcdHdoaWxlICggdGhpcy5oaXN0b3J5Lmxlbmd0aCApIHtcblx0XHRcdGxldCBkZXZpY2UgPSB0aGlzLmhpc3RvcnkucG9wKClcblx0XHRcdGlmICggdGhpcy5nZXREZXZpY2UoIGRldmljZSApIClcblx0XHRcdFx0cmV0dXJuIGxvY2FsLmFjdGl2ZURldmljZUlkID0gZGV2aWNlXG5cdFx0fVxuXHRcdGxvY2FsLmFjdGl2ZURldmljZUlkID0gdGhpcy5tYWluXG5cdH0sXG5cblx0d2luZG93U2l6ZTogcmVxdWlyZSggYHdpbmRvd1NpemVgICkuZ2V0UmVhZE9ubHkoKSxcblxuXHRwbGFjZXNTaGlmdHM6IHtcblx0fSxcblxuXHQvLyBUT0RPINCw0LHQvdCw0Z7Qu9GP0YbRjCEhINGW0L3RgtGN0YDRhNC10LnRgdGLINGP0Log0YLQvtC70YzQutGWINGP0L3RiyDRniDQvNCw0LTRjdC80LAg0LDQsdC90LDRntC70Y/RjtGG0YbQsCEhXG5cdGdldCBtb2RlbUxvY2F0aW9ucygpIHsgcmV0dXJuIGh0dHBDbGllbnQuZ2V0KCBgL21vZGVtX2xvY2F0aW9uc2AgKSB9LFxuXG5cdGdldCBsb2NhbE1vZGVtKCkgeyByZXR1cm4gdGhpcy5tb2RlbUxvY2F0aW9ucyA/IHRoaXMubW9kZW1Mb2NhdGlvbnNbIDAgXS51cmwucmVwbGFjZSggL15odHRwKD89cz9cXDpcXC9cXC8pLywgYHdzYCApIDogYGAgfSxcblxuXHRnZXQgZG9Mb2dpbigpIHsgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG5cdFx0d2hpbGUgKCAhdGhpcy5sb2dnZWRpbiAmJiB0aGlzLm1vZGVtTG9jYXRpb25zICkge1xuXHRcdFx0bGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGBzY3JpcHRgIClcblx0XHRcdHNjcmlwdC5zcmMgPSBgJHsgdGhpcy5tb2RlbUxvY2F0aW9uc1sgMCBdLnVybCB9L2xvZ2luPyR7IFVJRCgpIH1gXG5cdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBzY3JpcHQgKVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0eWllbGQgc2NyaXB0XG5cdFx0XHRcdC8vIHlpZWxkIFByb21pc2UucmFjZSggWyBjby5wcm9taXNlKCBzY3JpcHQgKSwgY28udGltZW91dCggMTUwMDAgKSBdIClcblx0XHRcdH1cblx0XHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdExPRyggYGVycm9yIHdoaWxlIHRyeWluZyB0byBsb2dpbjogJHsgZXJyb3IgJiYgZXJyb3IubWVzc2FnZSAmJiBlcnJvciB9YCApXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yIClcblx0XHRcdFx0eWllbGQgY28uc2xlZXAoIDMwMCApXG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggc2NyaXB0IClcblx0XHRcdH1cblx0XHRcdExPRyggYGxvZ2dlZCBpbmAgKVxuXHRcdFx0cmEuZGV0YWNoKCAoKSA9PiB0aGlzLmxvZ2dlZGluID0gdHJ1ZSApXG5cdFx0XHQvLyBUT0RPOiB0aGlzIGNvZGUgd2l0aCBhbiBYTUxIdHRwUmVxdWVzdCBkb2VzIG5vdCB3b3JrIG9uIGlQaG9uZSA6KCgoXG5cdFx0XHQvLyBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0XG5cdFx0XHQvLyB4aHIub3BlbiggYFBPU1RgLCB0aGlzLm1vZGVtTG9jYXRpb25zWyAwIF0udXJsICsgYC9sb2dpbmAsIHRydWUsIGBuZXJvYCwgYDEyM2AgKVxuXHRcdFx0Ly8geGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcblx0XHRcdC8vIHRyeSB7XG5cdFx0XHQvLyBcdHhoci5zZW5kKClcblx0XHRcdC8vIFx0eWllbGQgeGhyXG5cdFx0XHQvLyBcdC8vIGFsZXJ0KCB4aHIuc3RhdHVzIClcblx0XHRcdC8vIFx0TE9HKCAoIGBgICsgeGhyLnN0YXR1cyApLmJsdWUgKVxuXHRcdFx0Ly8gXHRpZiAoIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMjk5IClcblx0XHRcdC8vIFx0XHRyZXR1cm4gcmEuZGV0YWNoKCAoKSA9PiB0aGlzLmxvZ2dlZGluID0gdHJ1ZSApXG5cdFx0XHQvLyB9XG5cdFx0XHQvLyBjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0Ly8gXHQvLyBhbGVydCggYEVSUmAgKVxuXHRcdFx0Ly8gXHRjb25zb2xlLmxvZyggYGVycm9yIHdoaWxlIHRyeWluZyB0byBsb2dpbmAsIGVycm9yIClcblx0XHRcdC8vIH1cblx0XHRcdC8vIHlpZWxkIGNvLnNsZWVwKCAzMDAgKVxuXHRcdH1cblx0fS5jYWxsKCB0aGlzICkgfSxcblxuXHRsb2dpbiggbmFtZSwgcHdkICkge30sXG5cblx0Z2V0IHNlcnZlckRldmljZXMoKSB7IHJldHVybiB3c0pTT05jbGllbnQoIHRoaXMsIGAvZGF0YWJhc2VgICkgfSxcblx0Z2V0IGxvY2FsRGV2aWNlcygpIHsgcmV0dXJuIHJhLmRiKCB0aGlzLnNlcnZlckRldmljZXMuZGF0YSwgZGF0YSA9PiB0aGlzLnNlcnZlckRldmljZXMudXBkYXRlKCBkYXRhICkgKSB9LFxuXHRnZXQgZGV2aWNlcygpIHsgcmV0dXJuIHRoaXMubG9jYWxEZXZpY2VzLnZhbHVlT2YoKSB8fCB7fSB9LFxuXG5cdGdldCBjb21tYW5kcygpIHsgcmV0dXJuIHdzQ2xpZW50KCB0aGlzLCBgL2NvbW1hbmRzYCApIH0sXG5cdGdldCBjb25uZWN0ZWRUb1NlcnZlcigpIHsgcmV0dXJuIHRydWVcblx0XHQmJiB0aGlzLnNlcnZlckRldmljZXMuYWN0aXZlLnZhbHVlT2YoKVxuXHRcdCYmIHRoaXMuY29tbWFuZHMuYWN0aXZlLnZhbHVlT2YoKVxuXHR9LFxuXG5cdGdldCBtYWluKCkge1xuXHRcdHJldHVybiB0aGlzLmRldmljZXMubWFpblxuXHR9LFxuXG5cdGdldERldmljZSggZGV2aWNlSWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGV2aWNlcy5jb250ZW50ICYmIHRoaXMuZGV2aWNlcy5jb250ZW50WyBsdS52YWx1ZU9mKCBkZXZpY2VJZCApIF1cblx0fSxcblxuXHRnZXQgYWN0aXZlRGV2aWNlSWQoKSB7XG5cdFx0cmV0dXJuIGxvY2FsLmFjdGl2ZURldmljZUlkIHx8IHRoaXMubWFpblxuXHR9LFxuXG5cdGdldCBhY3RpdmVEZXZpY2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGV2aWNlKCB0aGlzLmFjdGl2ZURldmljZUlkIClcblx0fSxcblxuXHRnZXQgYWN0aXZlQ29udGVudElkcygpIHtcblx0XHRsZXQgZGV2aWNlID0gdGhpcy5hY3RpdmVEZXZpY2Vcblx0XHRyZXR1cm4gcmEuQXJyYXkoIGxvZGFzaC5rZXlzKCBkZXZpY2UgJiYgZGV2aWNlLmNvbnRlbnQgKS5zb3J0KCAoIGEsIGIgKSA9PiBkZXZpY2UuY29udGVudFsgYSBdLmluZGV4IC0gZGV2aWNlLmNvbnRlbnRbIGIgXS5pbmRleCApIClcblx0fSxcblxuXHRnZXQgYWN0aXZlQ29udGVudCgpIHtcblx0XHRyZXR1cm4gcmEuQXJyYXkoIHRoaXMuYWN0aXZlQ29udGVudElkcy5tYXAoIHRoaXMuZ2V0RGV2aWNlICkgKVxuXHR9LFxuXG5cdGxpbmtpbmdQbGFjZUlkOiBudWxsLFxuXHRnZXQgY2xlYXJMaW5raW5nUGxhY2VJZCgpIHtcblx0XHRpZiAoIHRoaXMuZGlhbG9nICE9IGBBc2tUb0xpbmtEZXZpY2VgICYmIHRoaXMuZGlhbG9nICE9IGBBc2tJZkRldmljZUhhc0JlZW5MaW5rZWRgIClcblx0XHRcdHRoaXMubGlua2luZ1BsYWNlSWQgPSBudWxsXG5cdH0sXG5cblx0Z2V0IGNoZWNrSWZUaW1lVG9Hb0JhY2soKSB7XG5cdFx0Ly8gbHUudmFsdWVPZiggdGhpcy5wbGFjZXMgKVxuXHRcdGlmICggIXRoaXMuZ2V0RGV2aWNlKCB0aGlzLmFjdGl2ZURldmljZUlkICkgKVxuXHRcdFx0dGhpcy5iYWNrKClcblx0fSxcblxuXHRnZXQgY2FwdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXNzYWdlKCB0aGlzLmdldERldmljZSggdGhpcy5hY3RpdmVEZXZpY2VJZCApICkgfHwgdGhpcy5tZXNzYWdlKCBgZmF2b3JpdGVzYCApXG5cdH0sXG5cblx0Z2V0IGRldmljZVR5cGUoKSB7XG5cdFx0bGV0IHJldCA9IHRoaXMuZ2V0RGV2aWNlKCB0aGlzLmFjdGl2ZURldmljZUlkIClcblx0XHRpZiAoICFyZXQgKVxuXHRcdFx0cmV0ID0gdGhpcy5nZXREZXZpY2UoIHRoaXMubWFpbiApXG5cdFx0cmV0dXJuICggcmV0ICYmIHJldC50eXBlICkgfHwgYHBsYWNlYFxuXHR9LFxuXG5cdGdldCBkZXZpY2VJZHMoKSB7XG5cdFx0cmV0dXJuIHJhLkFycmF5KCBsb2Rhc2gua2V5cyggdGhpcy5kZXZpY2VzLmNvbnRlbnQgKS5zb3J0KCkgKVxuXHR9LFxuXG5cdGdldCBpbml0aWFsTG9hZGluZygpIHtcblx0XHRyZXR1cm4gIXRoaXMuZGV2aWNlcy51aWRcblx0fSxcblxuXHRnZXQgaW5pdGlhbGl6ZWQoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmluaXRpYWxMb2FkaW5nICYmICEhdGhpcy5kZXZpY2VzLm1haW5cblx0fSxcblxuXHRzZXREYXRhYmFzZSggZGV2aWNlcyApIHtcblx0XHR0aGlzLnNlcnZlckRldmljZXMuc2VuZCggZGV2aWNlcyApXG5cdH0sXG5cblx0cmVzZXQoKSB7XG5cdFx0bG9jYWwucmVzZXQoKVxuXHRcdHRoaXMuc2V0RGF0YWJhc2UoIHsgdWlkOiBVSUQoKSB9IClcblx0XHR0aGlzLmRpYWxvZyA9IGBgXG5cdFx0dGhpcy5lZGl0aW5nID0gZmFsc2Vcblx0XHR0aGlzLmhpc3RvcnkubGVuZ3RoID0gMFxuXHR9LFxuXG5cdHNldFRlbXBsYXRlKCB0ZW1wbGF0ZSApIHtcblx0XHRjb25zb2xlLmxvZyggdGVtcGxhdGUgKVxuXHRcdGxldCBkZXZpY2VzID0ge1xuXHRcdFx0dWlkOiBVSUQoKSxcblx0XHRcdGNvbnRlbnQ6IHt9LFxuXHRcdH1cblx0XHRmdW5jdGlvbiBjb3B5KCB0ZW1wbGF0ZSwgZGV2aWNlICkge1xuXHRcdFx0T2JqZWN0LmtleXMoIHRlbXBsYXRlICkuZm9yRWFjaCgga2V5ID0+XG5cdFx0XHRcdGtleSAhPSBgaW1hZ2VgICYmIC8vIFRPRE86ICEhISEhISEhXG5cdFx0XHRcdGtleSAhPSBgY29udGVudGAgJiZcblx0XHRcdFx0a2V5ICE9IGB0eXBlYCAmJlxuXHRcdFx0XHQoIGRldmljZVsga2V5IF0gPSB0ZW1wbGF0ZVsga2V5IF0gKVxuXHRcdFx0KVxuXHRcdFx0cmV0dXJuIGRldmljZVxuXHRcdH1cblx0XHRmdW5jdGlvbiB3YWxrKCB0ZW1wbGF0ZSwgaWQgKSB7XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmNvbnRlbnQgfHwgdGVtcGxhdGUudHlwZSA9PSBgcGxhY2VgICkge1xuXHRcdFx0XHRsZXQgY29udGVudCA9IHt9XG5cdFx0XHRcdGRldmljZXMuY29udGVudFsgaWQgXSA9IGNvcHkoIHRlbXBsYXRlLCB7IHR5cGU6IGBwbGFjZWAsIGNvbnRlbnQ6IGNvbnRlbnQgfSApXG5cdFx0XHRcdGxldCBpbmRleCA9IDBcblx0XHRcdFx0dGVtcGxhdGUuY29udGVudCAmJiB0ZW1wbGF0ZS5jb250ZW50LmZvckVhY2goIHAgPT5cblx0XHRcdFx0XHRjb250ZW50WyB3YWxrKCBwLCBVSUQoKSApIF0gPSB7IGluZGV4OiBpbmRleCsrIH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGRldmljZXMuY29udGVudFsgaWQgXSA9IGNvcHkoIHRlbXBsYXRlLCB7IHR5cGU6IGBzaW5nbGVgIH0gKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlkXG5cdFx0fVxuXHRcdGRldmljZXMubWFpbiA9IHdhbGsoIHRlbXBsYXRlLCBVSUQoKSApXG5cdFx0dGhpcy5zZXREYXRhYmFzZSggZGV2aWNlcyApXG5cdH0sXG5cblx0Z2V0IHRlbXBsYXRlcygpIHsgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB5aWVsZCBodHRwQ2xpZW50LmdldCggYC90ZW1wbGF0ZXNgIClcblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdHJldHVybiBlcnJvclxuXHRcdH1cblx0fS5jYWxsKCB0aGlzICkgfSxcblxuXHRnZXQgYWxsTWVzc2FnZXMoKSB7IHJldHVybiBmdW5jdGlvbiogKCkge1xuXHRcdHJldHVybiB5aWVsZCBodHRwQ2xpZW50LmdldCggYC9tZXNzYWdlc2AgKVxuXHR9LmNhbGwoIHRoaXMgKSB9LFxuXG5cdGdldCBtZXNzYWdlcygpIHtcblx0XHRsZXQgYWxsTWVzc2FnZXMgPSB0aGlzLmFsbE1lc3NhZ2VzXG5cdFx0aWYgKCBhbGxNZXNzYWdlcyA9PSBudWxsIClcblx0XHRcdHJldHVyblxuXHRcdGxldCByZXQgPSB7fVxuXHRcdGxldCBsYW5ndWFnZSA9IGxvY2FsLmxhbmd1YWdlIHx8IGBydWBcblx0XHRsb2Rhc2guZm9yT3duKCBhbGxNZXNzYWdlcywgKCB2YWx1ZSwga2V5ICkgPT5cblx0XHRcdHJldFsga2V5IF0gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHZhbHVlLCBsYW5ndWFnZSApID8gdmFsdWVbIGxhbmd1YWdlIF0gOiBrZXkgKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRtZXNzYWdlKCBpZCApIHtcblx0XHRsZXQgcmV0ID0gdGhpcy5tZXNzYWdlcyAmJiB0aGlzLm1lc3NhZ2VzWyBpZCBdXG5cdFx0aWYgKCByZXQgPT0gbnVsbCApXG5cdFx0XHRyZXQgPSBpZFxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRub3RpZmljYXRpb24oIG1lc3NhZ2UgKSB7XG5cdFx0Ly8gYWxlcnQoIG1lc3NhZ2UgKVxuXHR9LFxuXG5cdHNhdmVEZXZpY2UoIGRldmljZUlkLCBkZXZpY2UgKSB7XG5cdFx0bGV0IGRpZmYgPSBsdS5tYWtlRGlmZiggdGhpcy5nZXREZXZpY2UoIGRldmljZUlkICksIGRldmljZSApXG5cdFx0cmV0dXJuIGRpZmYgPT0gbnVsbCA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5zZXJ2ZXJEZXZpY2VzLnVwZGF0ZSggeyBjb250ZW50OiB7IFsgZGV2aWNlSWQgXTogZGlmZiB9IH0gKVxuXHR9LFxuXG5cdG5ld0luZGV4KCBpY29uSWQgKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKCB0aGlzLmdldERldmljZSggaWNvbklkICkuY29udGVudCB8fCB7fSApLmxlbmd0aCArIDFcblx0fSxcblxuXHRsaW5rSXRlbSggaWNvbklkLCBpdGVtSWQsIGV4dHJhICkgeyByZXR1cm4gY28uZ29jYWxsKCBmdW5jdGlvbiogKCkge1xuXHRcdGlmICggaWNvbklkID09IGl0ZW1JZCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2Fubm90IGxpbmsgcGxhY2UgdG8gaXRzZWxmXCIgKVxuXHRcdGxldCBwbGFjZSA9IHRoaXMuZ2V0RGV2aWNlKCBpY29uSWQgKVxuXHRcdGxldCBkZXZpY2UgPSB0aGlzLmdldERldmljZSggaXRlbUlkIClcblx0XHRpZiAoIHBsYWNlLnR5cGUgPT0gYGdyb3VwYCApIHtcblx0XHRcdGlmICggIXBsYWNlLmdyb3VwIClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgaW50ZXJuYWwgZXJyb3I6IG5vIEdST1VQIG51bWJlciBmb3VuZGAgKVxuXHRcdFx0aWYgKCAhZGV2aWNlLmdyb3VwIClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgY2Fubm90IGFkZCB1bmxpbmtlZCBkZXZpY2UgdG8gYSBncm91cGAgKVxuXHRcdH1cblx0XHRsZXQgcmVjID0gdGhpcy5sb2NhbERldmljZXMuY3JlYXRlUmVjb3JkKClcblx0XHR0cnkge1xuXHRcdFx0bGV0IHBhY2tldCA9IHsgY29udGVudDogeyBbIGljb25JZCBdOiB7IGNvbnRlbnQ6IHsgWyBpdGVtSWQgXTogeyBpbmRleDogdGhpcy5uZXdJbmRleCggaWNvbklkICkgfSB9IH0gfSB9XG5cdFx0XHRsZXQgcmVzdWx0ID0gIWV4dHJhID8gcGFja2V0IDogbHUubWVyZ2VEaWZmcyggZXh0cmEsIHBhY2tldCApXG5cdFx0XHRkZWJ1Z2dlclxuXHRcdFx0cmVjLmFzc2lnbiggcmVzdWx0IClcblx0XHRcdGlmICggcGxhY2UudHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdFx0eWllbGQgdGhpcy5jb21tYW5kKCBpdGVtSWQsIGBBcHBlbmRUb2AsIHBsYWNlLmdyb3VwIClcblx0XHRcdHlpZWxkIHJlYy5zYXZlKClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRyZWMuY2xvc2UoKVxuXHRcdH1cblx0fSwgdGhpcyApIH0sXG5cblx0bGlua1RvRmF2b3VyaXRlcyggaXRlbUlkICkge1xuXHRcdHJldHVybiB0aGlzLmxpbmtJdGVtKCB0aGlzLm1haW4sIGl0ZW1JZCApXG5cdH0sXG5cblx0bGlua0FjdGl2ZVRvRmF2b3VyaXRlcyggaXRlbUlkICkge1xuXHRcdHJldHVybiB0aGlzLmxpbmtUb0Zhdm91cml0ZXMoIHRoaXMuYWN0aXZlRGV2aWNlSWQgKVxuXHR9LFxuXG5cdGFkZEl0ZW0oIGljb25JZCwgaXRlbSwgaWQgPSBVSUQoKSwgaW5kZXggPSBudWxsICkge1xuXHRcdHJldHVybiB0aGlzLnNlcnZlckRldmljZXMudXBkYXRlKCB7IGNvbnRlbnQ6IHtcblx0XHRcdFsgaWNvbklkIF06IHsgY29udGVudDogeyBbIGlkIF06IHsgaW5kZXg6IGluZGV4ICE9IG51bGwgPyBpbmRleCA6IHRoaXMubmV3SW5kZXgoIGljb25JZCApIH0gfSB9LFxuXHRcdFx0WyBpZCBdOiBpdGVtLFxuXHRcdH0gfSApXG5cdH0sXG5cblx0YWRkUGxhY2UoIGljb25JZCApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRJdGVtKCBpY29uSWQsIHtcblx0XHRcdHR5cGU6IGBwbGFjZWAsXG5cdFx0XHRydTogYNCf0L7QvNC10YnQtdC90LjQtWAsXG5cdFx0XHRlbjogYFJvb21gLFxuXHRcdH0gKVxuXHR9LFxuXG5cdGFkZERldmljZSggaWNvbklkICkge1xuXHRcdHJldHVybiB0aGlzLmFkZEl0ZW0oIGljb25JZCwge1xuXHRcdFx0dHlwZTogYHNpbmdsZWAsXG5cdFx0XHRydTogYNCj0YHRgtGA0L7QudGB0YLQstC+YCxcblx0XHRcdGVuOiBgRGV2aWNlYCxcblx0XHR9IClcblx0fSxcblxuXHRhZGRHcm91cCggaWNvbklkLCBpZCApIHsgcmV0dXJuIGNvLmdvY2FsbCggZnVuY3Rpb24qICgpIHtcblx0XHRpZiAoICFpZCApXG5cdFx0XHRpZCA9IFVJRCgpXG5cdFx0eWllbGQgdGhpcy5hZGRJdGVtKCBpY29uSWQsIHtcblx0XHRcdHR5cGU6IGBncm91cGAsXG5cdFx0XHRydTogYNCT0YDRg9C/0L/QsGAsXG5cdFx0XHRlbjogYEdyb3VwYCxcblx0XHR9LCBpZCApXG5cdFx0eWllbGQgdGhpcy5jb21tYW5kKCBpZCwgYFJlc2VydmVgIClcblx0XHRyZXR1cm4gaWRcblx0fSwgdGhpcyApIH0sXG5cblx0ZGVsZXRlSXRlbSggaWNvbklkLCBpdGVtSWQgKSB7IHJldHVybiBjby5nb2NhbGwoIGZ1bmN0aW9uKiAoKSB7XG5cdFx0bGV0IHBsYWNlID0gdGhpcy5nZXREZXZpY2UoIGljb25JZCApXG5cdFx0bGV0IHJlYyA9IHRoaXMubG9jYWxEZXZpY2VzLmNyZWF0ZVJlY29yZCgpXG5cdFx0dHJ5IHtcblx0XHRcdHJlYy5hc3NpZ24oIHsgY29udGVudDogeyBbIGljb25JZCBdOiB7IGNvbnRlbnQ6IHsgWyBpdGVtSWQgXTogbnVsbCB9IH0gfSB9IClcblx0XHRcdGlmICggcGxhY2UudHlwZSA9PSBgZ3JvdXBgICYmIHBsYWNlLmdyb3VwIClcblx0XHRcdFx0eWllbGQgdGhpcy5jb21tYW5kKCBpdGVtSWQsIGBSZW1vdmVGcm9tYCwgcGxhY2UuZ3JvdXAgKVxuXHRcdFx0eWllbGQgcmVjLnNhdmUoKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHJlYy5jbG9zZSgpXG5cdFx0fVxuXHR9LCB0aGlzICkgfSxcblxuXHRpbnNlcnRJbnRvKCBpY29uSWQsIGl0ZW1JZCwgZnJvbUlkICkge1xuXHRcdHJldHVybiB0aGlzLmxpbmtJdGVtKCBpY29uSWQsIGl0ZW1JZCwgeyBjb250ZW50OiB7IFsgZnJvbUlkIF06IHsgY29udGVudDogeyBbIGl0ZW1JZCBdOiBudWxsIH0gfSB9IH0gKVxuXHR9LFxuXG5cdGVycm9yczogbnVsbCxcblx0dGhyb3coIGRpYWxvZywgZGF0YSwgcmV0cnkgKSB7XG5cdFx0aWYgKCAhZGlhbG9nIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYGFuIGVycm9yIGhhcyB0byBoYXZlIGl0cyBvd24gZGlhbG9nYCApXG5cdFx0dGhpcy5lcnJvcnMgPSAoIHRoaXMuZXJyb3JzIHx8IFtdICkuY29uY2F0KCBbIHtcblx0XHRcdGRpYWxvZyxcblx0XHRcdGRhdGEsXG5cdFx0XHRyZXRyeSxcblx0XHR9IF0gKVxuXHR9LFxuXHRjbGVhckVycm9yKCkgeyByYS5kZXRhY2goICgpID0+IHtcblx0XHRpZiAoIHRoaXMuZXJyb3IgKSB7XG5cdFx0XHR0aGlzLmRpYWxvZyA9IGBgXG5cdFx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzICYmIHRoaXMuZXJyb3JzLnNsaWNlKCAxIClcblx0XHR9XG5cdH0gKSB9LFxuXHRnZXQgY2hlY2tFcnJvcigpIHtcblx0XHRpZiAoICF0aGlzLmRpYWxvZyApXG5cdFx0XHRpZiAoIHRoaXMuZXJyb3JzICYmIHRoaXMuZXJyb3JzLmxlbmd0aCApIHJhLmRldGFjaCggKCkgPT4ge1xuXHRcdFx0XHRsZXQgZXJyb3IgPSB0aGlzLmVycm9yc1sgMCBdXG5cdFx0XHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMgJiYgdGhpcy5lcnJvcnMuc2xpY2UoIDEgKVxuXHRcdFx0XHR0aGlzLmRpYWxvZyA9IGVycm9yLmRpYWxvZ1xuXHRcdFx0XHR0aGlzLmVycm9yID0gZXJyb3Jcblx0XHRcdH0gKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLmVycm9yID0gbnVsbFxuXHR9LFxuXHRlcnJvcjogbnVsbCxcblxuXHRwdXJnZUl0ZW0oIGRldmljZUlkLCBmb3JjZSApIHsgcmV0dXJuIGNvLmdvY2FsbCggZnVuY3Rpb24qICgpIHtcblx0XHQvLyBkZWJ1Z2dlclxuXHRcdGxldCBkZXZpY2UgPSB0aGlzLmdldERldmljZSggZGV2aWNlSWQgKVxuXHRcdGxldCByZWMgPSB0aGlzLmxvY2FsRGV2aWNlcy5jcmVhdGVSZWNvcmQoKVxuXHRcdHRyeSB7XG5cdFx0XHRyZWMuYXNzaWduKCBkZXZkYi5DbGVhciggdGhpcy5kZXZpY2VzLCBkZXZpY2VJZCApIClcblx0XHRcdGxldCBjbWRcblx0XHRcdGlmICggZGV2aWNlICYmIGRldmljZS5ncm91cCAhPSBudWxsIClcblx0XHRcdFx0aWYgKCBkZXZpY2UudHlwZSA9PSBgZ3JvdXBgIClcblx0XHRcdFx0XHRjbWQgPSBgQ2xlYXJgXG5cdFx0XHRcdGVsc2UgaWYgKCBkZXZpY2UudHlwZSA9PSBgc2luZ2xlYCApXG5cdFx0XHRcdFx0Y21kID0gYFVubGlua2Bcblx0XHRcdGlmICggY21kIClcblx0XHRcdFx0eWllbGQgdGhpcy5jb21tYW5kKCBkZXZpY2VJZCwgY21kIClcblx0XHRcdGVsc2Vcblx0XHRcdFx0eWllbGQgcmVjLnNhdmUoKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdGlmICggZm9yY2UgKVxuXHRcdFx0XHR5aWVsZCByZWMuc2F2ZSgpXG5cdFx0XHRyZWMuY2xvc2UoKVxuXHRcdFx0Ly8gc2VydmVyIE1VU1Qgc2VuZCB1cyBhY3R1YWwgc3RhdGUgQkVGT1JFIHJldHVybmluZyByZXN1bHQgb2YgY29tbWFuZCBleGVjdXRpb25cblx0XHRcdGlmICggKCBsdS52YWx1ZU9mKCB0aGlzLnNlcnZlckRldmljZXMuZGF0YSApIHx8IDEgKVsgZGV2aWNlSWQgXSApXG5cdFx0XHRcdHRoaXMudGhyb3coIGBFcnJvclVubGlua2luZ0RldmljZWAsIHsgZGV2aWNlSWQgfSwgKVxuXHRcdH1cblx0fSwgdGhpcyApIH0sXG5cblx0cmVuYW1lSXRlbSggaWNvbklkLCBuYW1lICkge1xuXHRcdGxldCByZXQgPSBsb2Rhc2gucmVkdWNlKCB0aGlzLmdldERldmljZSggaWNvbklkICksICggcmV0LCBfLCBrZXkgKSA9PiB7XG5cdFx0XHRpZiAoIGtleS5sZW5ndGggPT0gMiApXG5cdFx0XHRcdHJldFsga2V5IF0gPSBudWxsXG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fSwge30gKVxuXHRcdHJldFsgbG9jYWxEZWZhdWx0cy5sYW5ndWFnZSB8fCBgcnVgIF0gPSBuYW1lXG5cdFx0cmV0dXJuIHRoaXMuc2VydmVyRGV2aWNlcy51cGRhdGUoIHsgY29udGVudDogeyBbIGljb25JZCBdOiByZXQgfSB9IClcblx0fSxcblxuXHRjb21tYW5kKCBkZXZpY2VJZCwgY21kLCBkYXRhICkge1xuXG5cdFx0Ly8gZGVidWdnZXJcblxuXHRcdC8vIFRPRE86XG5cdFx0Ly8gbGV0IG5ld3N0YXRlID0gZGV2aWNlQWN0aW9ucy5nZXROZXdTdGF0ZSggdGhpcy5nZXREZXZpY2UoIGRldmljZUlkICksIGNtZCApXG5cdFx0Ly8gaWYgKCBuZXdzdGF0ZSAhPSBudWxsICkge1xuXHRcdC8vIH1cblxuXHRcdHJldHVybiB0aGlzLmNvbW1hbmRzLmFzayggeyBkZXZpY2U6IGRldmljZUlkLCBjb21tYW5kOiBjbWQsIGRhdGE6IGRhdGEgfSApXG5cdH0sXG5cblx0aWNvbkNvbW1hbmQoIGljb24sIGljb25JZCwgY21kLCBkYXRhICkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCBpY29uLCBpY29uSWQsIGNtZCApXG5cdFx0aWNvbiA9IGx1LnZhbHVlT2YoIGljb24gKVxuXHRcdGlmICggaWNvbi50eXBlID09IGBwbGFjZWAgPyBjbWQgPT0gYFNob3J0YCA6IGNtZCA9PSBgTG9uZ2AgKVxuXHRcdFx0cmV0dXJuIHRoaXMuZ28oIGljb25JZCApXG5cdFx0aWYgKCBpY29uLnR5cGUgIT0gYHBsYWNlYCAmJiAhaWNvbi5ncm91cCApIHtcblx0XHRcdHRoaXMuZGlhbG9nID0gYEFza1RvTGlua0RldmljZWBcblx0XHRcdHRoaXMubGlua2luZ1BsYWNlSWQgPSBpY29uSWRcblx0XHRcdC8vIHJldHVybiBQcm9taXNlLnJlamVjdCggbmV3IEVycm9yKCBgZGV2aWNlIG5vdCBjb25maWd1cmVkYCApIClcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdH1cblx0XHRpZiAoIGNtZCA9PSBgU2hvcnRgIHx8IGNtZCA9PSBgTG9uZ2AgKSB7XG5cdFx0XHRpZiAoIGljb24gJiYgaWNvbi5zdGF0ZSApIHtcblx0XHRcdFx0Y21kID0gYFNldGBcblx0XHRcdFx0ZGF0YSA9IDBcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjbWQgPSBgU2V0YFxuXHRcdFx0XHRkYXRhID0gMVxuXHRcdFx0fVxuXHRcdFx0Ly8gY21kID0gYENvbWZvcnRfMWBcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuY29tbWFuZCggaWNvbklkLCBjbWQsIGRhdGEgKVxuXHR9LFxuXG5cdGZvY3VzKCBub2RlICkge1xuXHRcdC8vIG1hZ2ljIGFjdGlvbnMgdG8gZm9yY2UgYWxsb3cgdG8gc2hvdyBrZXlib2FyZCBieSBpbnB1dC5mb2N1cygpIG9uIGlPUyAoIHNvIGZhciBjaGVja2VkIGlPUyA4IClcblx0XHRzZXRUaW1lb3V0KCAoKSA9PiBub2RlLmZvY3VzKCksIDQwMCApXG5cdH0sXG5cblx0c2VhcmNoQWN0aW9uOiBudWxsLFxuXHRzZWFyY2hGaWx0ZXI6IG51bGwsXG5cdGdldCBjaGVja1NlYXJjaERpYWxvZygpIHtcblx0XHRpZiAoIHRoaXMuZGlhbG9nICE9IGBTZWFyY2hJdGVtc2AgKSB7XG5cdFx0XHR0aGlzLnNlYXJjaEFjdGlvbiA9IG51bGxcblx0XHRcdHRoaXMuc2VhcmNoRmlsdGVyID0gbnVsbFxuXHRcdH1cblx0fSxcblxuXHRpY29uczogbnVsbCxcblxuXHRtb2R1bGVzOiBuZXcgV2Vha01hcCxcblx0bG9hZCggbW9kdWxlICkge1xuXHRcdGxldCByZXQgPSB0aGlzLm1vZHVsZXMuZ2V0KCBtb2R1bGUgKVxuXHRcdGlmICggcmV0ID09IG51bGwgKSB7XG5cdFx0XHRyZXQgPSBtb2R1bGUoIGFwcCwgbG9jYWwgKVxuXHRcdFx0dGhpcy5tb2R1bGVzLnNldCggbW9kdWxlLCByZXQgKVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH0sXG5cblx0aG92ZXI6IG51bGwsXG5cblx0ZGVidWdnZXIoKSB7IGRlYnVnZ2VyIH0sXG5cbn0gKS5zZXROYW1lKCBgYXBwYCApXG5cbnJldHVybiB7IGFwcCwgbG9jYWwgfVxuXG59XG4iLCJsZXQgTUFYX1RJQ0tTID0gMTAwMDAwXG5cbmxldCBzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXRcbi8vIGxldCBzZXRJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbFxuXG5wcm9jZXNzLm5leHRUaWNrID0gbmV4dFRpY2tcblxubGV0IHF1ZXVlID0gW11cbmxldCB0aW1lciA9IG51bGxcbmxldCBwcm9jZXNzaW5nID0gZmFsc2VcbmxldCBzZWNyZXQgPSBgcHJvY2Vzcy10aWNrLWAgKyBNYXRoLnJhbmRvbSgpXG5cbmxldCBpbnN0YWxsVGltZXIgPSBmdW5jdGlvbiAoKSB7IHRpbWVyID0gc2V0VGltZW91dCggb25UaW1lciwgMSApIH1cblxuaWYgKCB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBgbWVzc2FnZWAsIGZ1bmN0aW9uICggZXYgKSB7XG5cdFx0bGV0IHNvdXJjZSA9IGV2LnNvdXJjZTtcblx0XHRpZiAoICggc291cmNlID09IHdpbmRvdyB8fCBzb3VyY2UgPT0gbnVsbCApICYmIGV2LmRhdGEgPT0gc2VjcmV0ICkge1xuXHRcdFx0ZXYuc3RvcFByb3BhZ2F0aW9uKClcblx0XHRcdG9uVGltZXIoKVxuXHRcdH1cblx0fSApXG5cdGxldCBwb3N0TWVzc2FnZSA9IHdpbmRvdy5wb3N0TWVzc2FnZVxuXHRpbnN0YWxsVGltZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cG9zdE1lc3NhZ2UoIHNlY3JldCwgYCpgIClcblx0XHR0aW1lciA9IHRydWVcblx0fVxufVxuXG4hWyBgc2V0VGltZW91dGAsIGBzZXRJbnRlcnZhbGAsIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIF0uZm9yRWFjaCggbmFtZSA9PiB7XG5cdGxldCBwcm9jID0gaG9va01ldGhvZCggd2luZG93LCBuYW1lLCBmdW5jdGlvbiAoIGhhbmRsZXIsIHRpbWUgKSB7XG5cdFx0aWYgKCB0eXBlb2YgYXJndW1lbnRzWyAwIF0gPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRhcmd1bWVudHNbIDAgXSA9IGdldFByb3h5KCBhcmd1bWVudHNbIDAgXSApXG5cdFx0cmV0dXJuIHByb2MuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdH0gKVxufSApXG5cbiFbIHdpbmRvdywgZG9jdW1lbnQgXS5mb3JFYWNoKCBob29rRXZlbnRMaXN0ZW5lciApXG5cbmZ1bmN0aW9uIG9uVGltZXIoKSB7XG5cdHRpbWVyID0gbnVsbFxuXHRwcm9jZXNzUXVldWUoKVxufVxuXG5mdW5jdGlvbiBlbnN1cmVUaW1lcigpIHtcblx0aWYgKCAhdGltZXIgJiYgIXByb2Nlc3NpbmcgKVxuXHRcdGluc3RhbGxUaW1lcigpXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKCBmdW4gKSB7XG5cdHF1ZXVlLnB1c2goIGZ1biApXG5cdGVuc3VyZVRpbWVyKClcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuXHRpZiAoIHByb2Nlc3NpbmcgfHwgIXF1ZXVlLmxlbmd0aCApXG5cdFx0cmV0dXJuXG5cdGxldCBpbmRleCA9IDBcblx0cHJvY2Vzc2luZyA9IHRydWVcblx0dHJ5IHtcblx0XHR3aGlsZSAoIGluZGV4IDwgTUFYX1RJQ0tTICYmIGluZGV4IDwgcXVldWUubGVuZ3RoIClcblx0XHRcdHF1ZXVlWyBpbmRleCsrIF0oKVxuXHR9XG5cdGZpbmFsbHkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCBgdGlja3M6IGAgKyBpbmRleCApXG5cdFx0cHJvY2Vzc2luZyA9IGZhbHNlXG5cdFx0cXVldWUuc3BsaWNlKCAwLCBpbmRleCApXG5cdFx0aWYgKCBxdWV1ZS5sZW5ndGggKVxuXHRcdFx0ZW5zdXJlVGltZXIoKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGdldFByb3h5KCBoYW5kbGVyICkge1xuXHRmdW5jdGlvbiBwcm94eSgpIHtcblx0XHRsZXQgcmV0ID0gaGFuZGxlci5oYW5kbGVFdmVudCA/IGhhbmRsZXIuaGFuZGxlRXZlbnQuYXBwbHkoIGhhbmRsZXIsIGFyZ3VtZW50cyApIDogaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRwcm9jZXNzUXVldWUoKVxuXHRcdHJldHVybiByZXRcblx0fVxuXHRsZXQgcmV0XG5cdGlmICggKCByZXQgPSBoYW5kbGVyWyBzZWNyZXQgXSApICE9IG51bGwgKVxuXHRcdHJldHVybiByZXRcblx0ZWxzZSB7XG5cdFx0YXNzaWduUHJvcGVydHkoIHByb3h5LCBzZWNyZXQsIHByb3h5IClcblx0XHRyZXR1cm4gYXNzaWduUHJvcGVydHkoIGhhbmRsZXIsIHNlY3JldCwgcHJveHkgKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGhvb2tFdmVudExpc3RlbmVyKCBvYmogKSB7XG5cdGlmICggb2JqLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0bGV0IGFkZEV2ZW50TGlzdGVuZXIgPSBob29rTWV0aG9kKCBvYmosIGBhZGRFdmVudExpc3RlbmVyYCxcblx0XHRcdGZ1bmN0aW9uICggZXZlbnQsIGhhbmRsZXIgKSB7XG5cdFx0XHRcdGFyZ3VtZW50c1sgMSBdID0gZ2V0UHJveHkoIGFyZ3VtZW50c1sgMSBdIClcblx0XHRcdFx0cmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0XHR9IClcblx0XHRsZXQgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGhvb2tNZXRob2QoIG9iaiwgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLFxuXHRcdFx0ZnVuY3Rpb24gKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHNbIDEgXVsgc2VjcmV0IF0gKVxuXHRcdFx0XHRcdGFyZ3VtZW50c1sgMSBdID0gYXJndW1lbnRzWyAxIF1bIHNlY3JldCBdXG5cdFx0XHRcdHJldHVybiByZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHRcdFx0fSApXG5cdH1cbn1cblxuZnVuY3Rpb24gaG9va01ldGhvZCggb2JqLCBuYW1lLCBwcm94eSApIHtcblx0bGV0IHJldCA9IG9ialsgbmFtZSBdXG5cdGlmICggcmV0ICkge1xuXHRcdGFzc2lnblByb3BlcnR5KCBwcm94eSwgYHRvU3RyaW5nYCwgKCkgPT4gcmV0LnRvU3RyaW5nKCkgKVxuXHRcdG9ialsgbmFtZSBdID0gcHJveHlcblx0fVxuXHRyZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb3BlcnR5KCBvYmosIG5hbWUsIHZhbHVlICkge1xuXHRpZiAoIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSApXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIG5hbWUsIHsgdmFsdWUgfSApXG5cdGVsc2Vcblx0XHRvYmpbIG5hbWUgXSA9IHZhbHVlXG5cdHJldHVybiB2YWx1ZVxufVxuIiwibGV0IGxhdGVyID0gcmVxdWlyZSggYGxhdGVyYCApXG5sZXQgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSggYGV2ZW50c2AgKS5FdmVudEVtaXR0ZXJcblxubGV0IGNvID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlclxuXG5sZXQgdGhyZWFkQ2F0Y2hlciA9IG51bGxcblxuZXhwb3J0cy5jYiA9IG51bGxcbmV4cG9ydHMuZ2xvYmFsID0gbnVsbFxuXG5leHBvcnRzLmdvID0gKCBmdW4sIC4uLmFyZ3MgKSA9PiB7XG5cdGlmICggdHlwZW9mIGZ1biA9PSBgZnVuY3Rpb25gIClcblx0XHRmdW4gPSBmdW4uYXBwbHkoIG51bGwsIGFyZ3MgKVxuXHRpZiAoICFmdW4ubmV4dCApIHtcblx0XHRsZXQgdmFsdWUgPSBmdW5cblx0XHRmdW4gPSB7XG5cdFx0XHRuZXh0KCkge1xuXHRcdFx0XHRsZXQgcmV0ID0geyB2YWx1ZSwgZG9uZTogIXZhbHVlIH1cblx0XHRcdFx0dmFsdWUgPSBudWxsXG5cdFx0XHRcdHJldHVybiByZXRcblx0XHRcdH0sXG5cdFx0fVxuXHR9XG5cdHJldHVybiBuZXcgVGhyZWFkKCBmdW4gKVxufVxuXG5leHBvcnRzLmdvY2FsbCA9ICggZnVuLCBjb250ZXh0LCAuLi5hcmdzICkgPT5cblx0bmV3IFRocmVhZCggZnVuLmFwcGx5KCBjb250ZXh0LCBhcmdzICkgKVxuXG5leHBvcnRzLmZ1bmMgPSBmdW5jdGlvbiAoIGZ1biApIHtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID49IDIgKVxuXHRcdGZ1biA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodC5jYWxsKCBhcmd1bWVudHMsICggZywgZiApID0+IGYoIGcgKSApXG5cdHJldHVybiBmdW5jdGlvbiBwcm9jKCkge1xuXHRcdHJldHVybiBuZXcgVGhyZWFkKCBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIClcblx0fVxufVxuXG5leHBvcnRzLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICggZnVuICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gcHJvYygpIHtcblx0XHRsZXQgcmV0ID0gbmV3IFRocmVhZCggZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApXG5cdFx0cmV0LndhaXRGb3JJbnB1dCgpXG5cdFx0cmV0dXJuIHJldFxuXHR9XG59XG5cbi8vIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBlcnJvciwgdGhlIHNlY29uZCBvbmUgaXMgYSByZXN1bHRcbmV4cG9ydHMuY2JmdW5jID0gZnVuV2l0aENCID0+IGZ1bmN0aW9uICggLi4uYXJncyApIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+XG5cdFx0ZnVuV2l0aENCLmNhbGwoIHRoaXMsIC4uLmFyZ3MsICggZXJyb3IsIHZhbHVlICkgPT4ge1xuXHRcdFx0aWYgKCBlcnJvciAhPSBudWxsIClcblx0XHRcdFx0cmVqZWN0KCBlcnJvciApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlc29sdmUoIHZhbHVlIClcblx0XHR9IClcblx0KVxufVxuXG5leHBvcnRzLmNhdGNoVGhyZWFkcyA9ICggY2IsIG9uVGhyZWFkICkgPT4ge1xuXHRsZXQgb2xkQ2F0Y2hlciA9IHRocmVhZENhdGNoZXJcblx0dGhyZWFkQ2F0Y2hlciA9IG9uVGhyZWFkXG5cdHRyeSB7XG5cdFx0cmV0dXJuIGNiKClcblx0fVxuXHRmaW5hbGx5IHtcblx0XHR0aHJlYWRDYXRjaGVyID0gb2xkQ2F0Y2hlclxuXHR9XG59XG5cbmV4cG9ydHMucmVjZWl2ZSA9ICggZW1pdHRlciwgZXZlbnRzICkgPT4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRsZXQgaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0bGV0IHRpbWVyXG5cdGxldCByZWplY3RlciA9IGNvLmRlZmVyKCAoKSA9PiB7XG5cdFx0Y2xlYXIoKVxuXHRcdHJlamVjdCgpXG5cdH0gKVxuXHRmb3IgKCBsZXQgZXZlbnQgaW4gZXZlbnRzICkgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGV2ZW50cywgZXZlbnQgKSApIHtcblx0XHRsZXQgcHJlZGljYXRlID0gZXZlbnRzWyBldmVudCBdXG5cdFx0aWYgKCBwcmVkaWNhdGUgPT0gbnVsbCApXG5cdFx0XHQvL1xuXHRcdFx0Ly8gYWxsb3cgc2ltcGxlciBldmVudHMgZGVmaW5pbmcgbGlrZVxuXHRcdFx0Ly9cblx0XHRcdC8vIHlpZWxkIGNvLnJlY2VpdmUoIG9iaiwgeyBkYXRhOiB0cnVlLCB0aW1lb3V0OiBnZXRUaW1lb3V0KCAuLi4gKSB9IClcblx0XHRcdC8vXG5cdFx0XHQvLyBpbnN0ZWFkIG9mXG5cdFx0XHQvL1xuXHRcdFx0Ly8gbGV0IGV2ZW50cyA9IHsgZGF0YTogdHJ1ZSB9XG5cdFx0XHQvLyBpZiAoIGdldFRpbWVvdXQoIC4uLiApICE9IG51bGwgKSBldmVudHMudGltZW91dCA9IGdldFRpbWVvdXQoIC4uLiApXG5cdFx0XHQvLyB5aWVsZCBjby5yZWNlaXZlKCBvYmosIGV2ZW50cyApXG5cdFx0XHQvL1xuXHRcdFx0Y29udGludWVcblx0XHRpZiAoIGV2ZW50ID09IGB0aW1lb3V0YCApXG5cdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoICgpID0+IGRvbmUoIGB0aW1lb3V0YCwgbnVsbCApLCBwcmVkaWNhdGUgKVxuXHRcdGVsc2Vcblx0XHRcdGVtaXR0ZXIuYWRkTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyc1sgZXZlbnQgXSA9IGRhdGEgPT4ge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBwcmVkaWNhdGUgIT0gYGZ1bmN0aW9uYCB8fCBwcmVkaWNhdGUoIGRhdGEgKSApXG5cdFx0XHRcdFx0ZG9uZSggZXZlbnQsIGRhdGEgKVxuXHRcdFx0fSApXG5cdH1cblx0ZnVuY3Rpb24gY2xlYXIoKSB7XG5cdFx0aWYgKCAhaGFuZGxlcnMgKVxuXHRcdFx0cmV0dXJuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aW1lciApXG5cdFx0Zm9yICggbGV0IGV2ZW50IGluIGhhbmRsZXJzIClcblx0XHRcdGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIGV2ZW50LCBoYW5kbGVyc1sgZXZlbnQgXSApXG5cdFx0cmVqZWN0ZXIuY2xvc2UoKVxuXHRcdGhhbmRsZXJzID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGRvbmUoIGV2ZW50LCBkYXRhICkge1xuXHRcdGNsZWFyKClcblx0XHRyZXNvbHZlKCB7IGV2ZW50LCBkYXRhIH0gKVxuXHR9XG59IClcblxubGV0IG5vb3B0aGVuID0geyB0aGVuKCkge30gfVxuZXhwb3J0cy53YWl0ID0gKCkgPT4gbm9vcHRoZW5cblxuZXhwb3J0cy5zbGVlcCA9IG1pbGxpc2Vjb25kcyA9PiAoIHsgdGhlbjogcmVzb2x2ZSA9PiB7XG5cdGxldCB0aW1lciA9IHNldFRpbWVvdXQoIHJlc29sdmUsIG1pbGxpc2Vjb25kcyApXG5cdHJldHVybiB7IGtpbGwoKSB7IGNsZWFyVGltb3V0KCB0aW1lciApIH0gfVxufSB9IClcblxuZXhwb3J0cy50aWNrID0gZXhwb3J0cy5zbGVlcCggMSApXG5cbmV4cG9ydHMudGltZW91dCA9IG1pbGxpc2Vjb25kcyA9PiAoIHsgdGhlbjogKCBfLCByZWplY3QgKSA9PiB7XG5cdGxldCB0aW1lciA9IHNldFRpbWVvdXQoIHJlamVjdCwgbWlsbGlzZWNvbmRzIClcblx0cmV0dXJuIHsga2lsbCgpIHsgY2xlYXJUaW1vdXQoIHRpbWVyICkgfSB9XG59IH0gKVxuXG5leHBvcnRzLnByb21pc2UgPSB2YWx1ZSA9PiBQcm9taXNlLmFsbCggWyBjby5nbyggZnVuY3Rpb24qICgpIHtcblx0eWllbGQgdmFsdWVcbn0gKSBdIClcblxuZXhwb3J0cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB7IHRoZW46IHJlc29sdmUgPT4ge1xuXHRpZiAoIHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PSBgZnVuY3Rpb25gICkge1xuXHRcdGxldCBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggcmVzb2x2ZSApXG5cdFx0cmV0dXJuIHsga2lsbCgpIHsgY2FuY2VsQW5pbWF0aW9uRnJhbWUoIGZyYW1lICkgfSB9XG5cdH1cblx0ZWxzZVxuXHRcdHJldHVybiBleHBvcnRzLnNsZWVwKCAxICkudGhlbiggcmVzb2x2ZSApXG59IH1cblxubGV0IHJldGhyb3cgPSBlID0+IHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZSB9LCAxIClcblxuZnVuY3Rpb24gaXRlcmF0b3JGYWlsZWQoIGVycm9yICkge1xuXHRyZXR1cm4geyBkb25lOiB0cnVlLCBpdGVyYXRvckZhaWxlZDogdHJ1ZSwgdmFsdWU6IGVycm9yIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JOZXh0KCBpdGVyYXRvciwgcmVzdWx0ICkge1xuXHR0cnkge1xuXHRcdHJldHVybiBpdGVyYXRvci5uZXh0KCByZXN1bHQgKVxuXHR9XG5cdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0cmV0dXJuIGl0ZXJhdG9yRmFpbGVkKCBlcnJvciApXG5cdH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JUaHJvdyggaXRlcmF0b3IsIHJlc3VsdCApIHtcblx0aWYgKCAhaXRlcmF0b3IudGhyb3cgKVxuXHRcdHJldHVybiBpdGVyYXRvckZhaWxlZCggcmVzdWx0IClcblx0dHJ5IHtcblx0XHRyZXR1cm4gaXRlcmF0b3IudGhyb3coIHJlc3VsdCApXG5cdH1cblx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRyZXR1cm4gaXRlcmF0b3JGYWlsZWQoIGVycm9yIClcblx0fVxufVxuXG5jb25zdCBET05FID0geyBkb25lOiB0cnVlIH1cblxuY2xhc3MgRUtpbGwgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKCBtZXNzYWdlID0gYGtpbGxgICkge1xuXHRcdHN1cGVyKCBtZXNzYWdlIClcblx0fVxufVxuZXhwb3J0cy5FS2lsbCA9IEVLaWxsXG5cbmZ1bmN0aW9uIGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciApIHtcblx0aWYgKCBpdGVyYXRvci5yZXR1cm4gKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGl0ZXJhdG9yLnJldHVybigpXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gaXRlcmF0b3JGYWlsZWQoIGVycm9yIClcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIGl0ZXJhdG9yLnRocm93ICkge1xuXHRcdGxldCBlID0gbmV3IEVLaWxsXG5cdFx0bGV0IHYgPSBpdGVyYXRvclRocm93KCBpdGVyYXRvciwgZSApXG5cdFx0aWYgKCAhdi5kb25lIHx8ICF2Lml0ZXJhdG9yRmFpbGVkIClcblx0XHRcdHJldGhyb3coIG5ldyBFcnJvciggYHRocmVhZCBoYXMgZWF0ZW4gRUtpbGxgICkgKVxuXHRcdGVsc2UgaWYgKCB2LnZhbHVlICE9IGUgKVxuXHRcdFx0cmV0dXJuIHZcblx0fVxuXHRyZXR1cm4gRE9ORVxufVxuXG5mdW5jdGlvbiBpdGVyYXRvckNoZWNrKCByZXQgKSB7XG5cdGlmICggcmV0ICYmIHJldC5kb25lICYmIHJldC5pdGVyYXRvckZhaWxlZCApXG5cdFx0dGhyb3cgcmV0LnZhbHVlXG5cdGVsc2Vcblx0XHRyZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGtpbGxJdGVyYXRvciggaXRlcmF0b3IgKSB7XG5cdGlmICggaXRlcmF0b3IgKSB7XG5cdFx0bGV0IHJlcyA9IGl0ZXJhdG9yUmV0dXJuKCBpdGVyYXRvciApXG5cdFx0aWYgKCByZXMuZG9uZSAmJiByZXMuaXRlcmF0b3JGYWlsZWQgKVxuXHRcdFx0cmV0aHJvdyggcmVzLnZhbHVlIClcblx0fVxufVxuXG4vLyBUaHJlYWRcblxubGV0IGNhdGNoRGVmZXIgPSBmdW5jID0+IHtcblx0Ly8gb3B0aW1pemF0aW9uIC0tIHVzaW5nIHRyeS9jYXRjaCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uLlxuXHR0cnkge1xuXHRcdHJldHVybiBmdW5jKClcblx0fVxuXHRjYXRjaCAoIGVycm9yICkge1xuXHRcdHJldHVybiB7IG5leHQ6ICgpID0+IGl0ZXJhdG9yRmFpbGVkKCBlcnJvciApIH1cblx0fVxufVxuXG5jbGFzcyBJdGVyYXRvclByb3h5IHtcblx0Y29uc3RydWN0b3IoIGl0ZXJhdG9yICkge1xuXHRcdGlmICggaXRlcmF0b3IgaW5zdGFuY2VvZiBJdGVyYXRvclByb3h5IClcblx0XHRcdHJldHVybiBpdGVyYXRvclxuXHRcdHRoaXMuX2l0ZXJhdG9yID0gaXRlcmF0b3Jcblx0XHR0aGlzLl9kZWZlcnJlZCA9IG51bGxcblx0XHR0aGlzLl9yZXN1bHQgPSBudWxsXG5cdH1cblx0ZGVmZXIoIHByb2MgKSB7XG5cdFx0aWYgKCB0eXBlb2YgcHJvYyAhPSBgZnVuY3Rpb25gIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHR5cGUgZXJyb3I6IG9ubHkgZnVuY3Rpb25zIGNhbiBiZSBkZWZlcnJlZGAgKVxuXHRcdGlmICggIXRoaXMuX2RlZmVycmVkIClcblx0XHRcdHRoaXMuX2RlZmVycmVkID0gW11cblx0XHR0aGlzLl9kZWZlcnJlZC5wdXNoKCBwcm9jIClcblx0XHRyZXR1cm4geyBjbG9zZTogKCkgPT4ge1xuXHRcdFx0aWYgKCB0aGlzLl9kZWZlcnJlZCApXG5cdFx0XHRcdGZvciAoIGxldCBpID0gdGhpcy5fZGVmZXJyZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkgKVxuXHRcdFx0XHRcdGlmICggdGhpcy5fZGVmZXJyZWRbIGkgXSA9PSBwcm9jICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmZXJyZWQuc3BsaWNlKCBpLCAxIClcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHR9IH1cblx0fVxuXHRzYXZlKCByZXN1bHQgKSB7XG5cdFx0aWYgKCAhdGhpcy5fcmVzdWx0IClcblx0XHRcdHRoaXMuX3Jlc3VsdCA9IHJlc3VsdFxuXHRcdGVsc2UgaWYgKCByZXN1bHQuaXRlcmF0b3JGYWlsZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMuX3Jlc3VsdC5pdGVyYXRvckZhaWxlZCApXG5cdFx0XHRcdHJldGhyb3coIHRoaXMuX3Jlc3VsdC52YWx1ZSApXG5cdFx0XHR0aGlzLl9yZXN1bHQgPSByZXN1bHRcblx0XHR9XG5cdH1cblx0Y2FsbCggcHJvYywgdmFsdWUgKSB7XG5cdFx0bGV0IG9sZCA9IEl0ZXJhdG9yUHJveHkuX2l0ZXJhdG9yXG5cdFx0SXRlcmF0b3JQcm94eS5faXRlcmF0b3IgPSB0aGlzXG5cdFx0dHJ5IHtcblx0XHRcdHN0YXJ0OiBmb3IgKDs7KSB7XG5cdFx0XHRcdGxldCByZXQgPSBwcm9jKCB0aGlzLl9pdGVyYXRvciwgdmFsdWUgKVxuXHRcdFx0XHRpZiAoICFyZXQuZG9uZSApXG5cdFx0XHRcdFx0cmV0dXJuIHJldFxuXHRcdFx0XHR0aGlzLl9pdGVyYXRvciA9IG51bGxcblx0XHRcdFx0aWYgKCAhdGhpcy5fZGVmZXJyZWQgKVxuXHRcdFx0XHRcdHJldHVybiByZXRcblx0XHRcdFx0dGhpcy5zYXZlKCByZXQgKVxuXHRcdFx0XHR3aGlsZSAoIHRoaXMuX2RlZmVycmVkLmxlbmd0aCApIHtcblx0XHRcdFx0XHRsZXQgZGVmID0gY2F0Y2hEZWZlciggdGhpcy5fZGVmZXJyZWQucG9wKCkgKVxuXHRcdFx0XHRcdGlmICggZGVmID09IG51bGwgfHwgdHlwZW9mIGRlZi5uZXh0ICE9IGBmdW5jdGlvbmAgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHR0aGlzLl9pdGVyYXRvciA9IGRlZlxuXHRcdFx0XHRcdHZhbHVlID0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0cHJvYyA9IGl0ZXJhdG9yTmV4dFxuXHRcdFx0XHRcdGNvbnRpbnVlIHN0YXJ0XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0ID0gdGhpcy5fcmVzdWx0XG5cdFx0XHRcdHRoaXMuX3Jlc3VsdCA9IG51bGxcblx0XHRcdFx0cmV0dXJuIHJldFxuXHRcdFx0fVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdEl0ZXJhdG9yUHJveHkuX2l0ZXJhdG9yID0gb2xkXG5cdFx0fVxuXHR9XG5cdG5leHQoIHZhbHVlICkge1xuXHRcdHJldHVybiBpdGVyYXRvckNoZWNrKCB0aGlzLmNhbGwoIGl0ZXJhdG9yTmV4dCwgdmFsdWUgKSApXG5cdH1cblx0dGhyb3coIHZhbHVlICkge1xuXHRcdHJldHVybiBpdGVyYXRvckNoZWNrKCB0aGlzLmNhbGwoIGl0ZXJhdG9yVGhyb3csIHZhbHVlICkgKVxuXHR9XG5cdHJldHVybiggdmFsdWUgKSB7XG5cdFx0aWYgKCAhdGhpcy5faXRlcmF0b3IgKVxuXHRcdFx0cmV0dXJuXG5cdFx0dGhpcy5zYXZlKCB7IGRvbmU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9IClcblx0XHRsZXQgb2xkID0gSXRlcmF0b3JQcm94eS5faXRlcmF0b3Jcblx0XHRJdGVyYXRvclByb3h5Ll9pdGVyYXRvciA9IHRoaXNcblx0XHR0cnkge1xuXHRcdFx0bGV0IHJldCA9IGl0ZXJhdG9yUmV0dXJuKCB0aGlzLl9pdGVyYXRvciApXG5cdFx0XHR0aGlzLl9pdGVyYXRvciA9IG51bGxcblx0XHRcdGlmICggIXRoaXMuZGVmZXJyZWQgKSB7XG5cdFx0XHRcdGl0ZXJhdG9yQ2hlY2soIHJldCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dGhpcy5zYXZlKCByZXQgKVxuXHRcdFx0d2hpbGUgKCB0aGlzLl9kZWZlcnJlZC5sZW5ndGggKSB7XG5cdFx0XHRcdGxldCBkZWYgPSBjYXRjaERlZmVyKCB0aGlzLl9kZWZlcnJlZC5wb3AoKSApXG5cdFx0XHRcdGlmICggZGVmICE9IG51bGwgJiYgdHlwZW9mIGRlZi5uZXh0ID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRcdFx0bGV0IHJldCA9IGl0ZXJhdG9yTmV4dCggZGVmIClcblx0XHRcdFx0XHRpZiAoICFyZXQuZG9uZSApXG5cdFx0XHRcdFx0XHRyZXQgPSBpdGVyYXRvclJldHVybiggZGVmIClcblx0XHRcdFx0XHR0aGlzLnNhdmUoIHJldCApXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldCA9IHRoaXMuX3Jlc3VsdFxuXHRcdFx0dGhpcy5fcmVzdWx0ID0gbnVsbFxuXHRcdFx0aXRlcmF0b3JDaGVjayggcmV0IClcblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHRJdGVyYXRvclByb3h5Ll9pdGVyYXRvciA9IG9sZFxuXHRcdH1cblx0fVxufVxuSXRlcmF0b3JQcm94eS5faXRlcmF0b3IgPSBudWxsXG5cbi8vIGZ1bmN0aW9uKiBfSXRlcmF0b3JQcm94eSggaXRlcmF0b3IgKSB7XG4vLyBcdGxldCBkZWZmZXJlZCA9IFtdXG4vLyBcdGxldCByZXQgPSBudWxsXG4vLyBcdGZ1bmN0aW9uIHNhdmUoIGl0ICkge1xuLy8gXHRcdGlmICggcmV0ID09IG51bGwgfHwgaXQuaXRlcmF0b3JGYWlsZWQgKSB7XG4vLyBcdFx0XHRpZiAoIHJldCAmJiByZXQuaXRlcmF0b3JGYWlsZWQgKVxuLy8gXHRcdFx0XHRyZXRocm93KCByZXQudmFsdWUgKVxuLy8gXHRcdFx0cmV0ID0gaXRcbi8vIFx0XHR9XG4vLyBcdH1cbi8vIFx0bGV0IHN0ZXAgPSBpdGVyYXRvck5leHRcbi8vIFx0bGV0IGl0ID0gbnVsbFxuLy8gXHR0cnkge1xuLy8gXHRcdG1haW46IHdoaWxlICggdHJ1ZSApIHtcbi8vIFx0XHRcdGxldCB5aWVsZFJlc3VsdFxuLy8gXHRcdFx0c3RlcCA9IGl0ZXJhdG9yTmV4dFxuLy8gXHRcdFx0aWYgKCBpdCAhPSBudWxsICkge1xuLy8gXHRcdFx0XHR0cnkge1xuLy8gXHRcdFx0XHRcdHlpZWxkUmVzdWx0ID0geWllbGQgaXQudmFsdWVcbi8vIFx0XHRcdFx0fVxuLy8gXHRcdFx0XHRjYXRjaCAoIGVycm9yICkge1xuLy8gXHRcdFx0XHRcdHlpZWxkUmVzdWx0ID0gZXJyb3Jcbi8vIFx0XHRcdFx0XHRzdGVwID0gaXRlcmF0b3JUaHJvd1xuLy8gXHRcdFx0XHR9XG4vLyBcdFx0XHR9XG4vLyBcdFx0XHRlbHNlXG4vLyBcdFx0XHRcdHlpZWxkUmVzdWx0ID0gdW5kZWZpbmVkXG4vLyBcdFx0XHRfSXRlcmF0b3JQcm94eS5kZWZlcnJlZCA9IGRlZmVycmVkXG4vLyBcdFx0XHRpdCA9IHN0ZXAoIGl0ZXJhdG9yLCB5aWVsZFJlc3VsdCApXG4vLyBcdFx0XHRfSXRlcmF0b3JQcm94eS5kZWZlcnJlZCA9IG51bGxcbi8vIFx0XHRcdGlmICggIWl0LmRvbmUgKVxuLy8gXHRcdFx0XHRjb250aW51ZSBtYWluXG4vLyBcdFx0XHRzYXZlKCBpdCApXG4vLyBcdFx0XHRpdCA9IHVuZGVmaW5lZFxuLy8gXHRcdFx0d2hpbGUgKCBkZWZmZXJlZC5sZW5ndGggKSB7XG4vLyBcdFx0XHRcdGl0ZXJhdG9yID0gY2F0Y2hEZWZlciggZGVmZmVyZWQuc2hpZnQoKSApXG4vLyBcdFx0XHRcdGlmICggaXRlcmF0b3IgIT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IubmV4dCA9PSBgZnVuY3Rpb25gIClcbi8vIFx0XHRcdFx0XHRjb250aW51ZSBtYWluXG4vLyBcdFx0XHR9XG4vLyBcdFx0XHRpdGVyYXRvciA9IG51bGxcbi8vIFx0XHRcdGJyZWFrIG1haW5cbi8vIFx0XHR9XG4vLyBcdH1cbi8vIFx0ZmluYWxseSB7XG4vLyBcdFx0aWYgKCBpdGVyYXRvciApXG4vLyBcdFx0XHRzYXZlKCBpdGVyYXRvclJldHVybiggaXRlcmF0b3IgKSApXG4vLyBcdFx0d2hpbGUgKCBkZWZmZXJlZC5sZW5ndGggKSB7XG4vLyBcdFx0XHRpdGVyYXRvciA9IGNhdGNoRGVmZXIoIGRlZmZlcmVkLnNoaWZ0KCkgKVxuLy8gXHRcdFx0aWYgKCBpdGVyYXRvciAhPSBudWxsICYmIHR5cGVvZiBpdGVyYXRvci5uZXh0ID09IGBmdW5jdGlvbmAgKSB7XG4vLyBcdFx0XHRcdGl0ID0gaXRlcmF0b3JOZXh0KCBpdGVyYXRvciwgdW5kZWZpbmVkIClcbi8vIFx0XHRcdFx0aWYgKCAhaXQuZG9uZSApXG4vLyBcdFx0XHRcdFx0aXQgPSBpdGVyYXRvclJldHVybiggaXRlcmF0b3IgKVxuLy8gXHRcdFx0XHRzYXZlKCBpdCApXG4vLyBcdFx0XHR9XG4vLyBcdFx0fVxuLy8gXHRcdGlmICggcmV0IClcbi8vIFx0XHRcdGlmICggcmV0Lml0ZXJhdG9yRmFpbGVkIClcbi8vIFx0XHRcdFx0dGhyb3cgcmV0LnZhbHVlXG4vLyBcdFx0XHRlbHNlXG4vLyBcdFx0XHRcdHJldHVybiByZXQudmFsdWVcbi8vIFx0fVxuLy8gfVxuXG5leHBvcnRzLmRlZmVyID0gcHJvYyA9PiB7XG5cdGlmICggIUl0ZXJhdG9yUHJveHkuX2l0ZXJhdG9yIClcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGBkZWZlcjogbm90IGluIGEgY28tdGhyZWFkYCApXG5cdHJldHVybiBJdGVyYXRvclByb3h5Ll9pdGVyYXRvci5kZWZlciggcHJvYyApXG59XG5cbi8vIGV4cG9ydHMuX2RlZmVyID0gcHJvYyA9PiB7XG4vLyBcdGlmICggdHlwZW9mIHByb2MgIT0gYGZ1bmN0aW9uYCApXG4vLyBcdFx0dGhyb3cgbmV3IEVycm9yKCBgdHlwZSBlcnJvcjogb25seSBmdW5jdGlvbnMgY2FuIGJlIGRlZmVycmVkYCApXG4vLyBcdGxldCBkZWZlcnJlZCA9IF9JdGVyYXRvclByb3h5LmRlZmVycmVkXG4vLyBcdGlmICggZGVmZXJyZWQgKVxuLy8gXHRcdHRocm93IG5ldyBFcnJvciggYGRlZmVyOiBub3QgaW4gYSBjby10aHJlYWRgIClcbi8vIFx0ZGVmZXJyZWQucHVzaCggcHJvYyApXG4vLyBcdHJldHVybiB7IGNsb3NlOiAoKSA9PiB7XG4vLyBcdFx0aWYgKCBkZWZlcnJlZCApXG4vLyBcdFx0XHRmb3IgKCBsZXQgaSA9IGRlZmVycmVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pIClcbi8vIFx0XHRcdFx0aWYgKCBkZWZlcnJlZFsgaSBdID09IHByb2MgKSB7XG4vLyBcdFx0XHRcdFx0ZGVmZXJyZWQuc3BsaWNlKCBpLCAxIClcbi8vIFx0XHRcdFx0XHRyZXR1cm5cbi8vIFx0XHRcdFx0fVxuLy8gXHR9IH1cbi8vIH1cblxuY2xhc3MgVGhyZWFkIHtcblxuXHRjb25zdHJ1Y3RvciggaXRlcmF0b3IgKSB7XG5cdFx0dGhpcy5fYXR0YWNoZWRUb1N0YWNrID0gdHJ1ZVxuXHRcdHRoaXMuX2l0ZXJhdG9yID0gbmV3IEl0ZXJhdG9yUHJveHkoIGl0ZXJhdG9yIClcblx0XHR0aGlzLl9zdG9wQ291bnQgPSAwXG5cdFx0dGhpcy5fc3RhY2sgPSBbXVxuXHRcdHRoaXMuZ2xvYmFsID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0dGhpcy5fY3VycmVudFByb21pc2UgPSBudWxsXG5cdFx0dGhpcy5fcnVubmluZyA9IGZhbHNlXG5cdFx0dGhpcy5fa2lsbGluZyA9IG51bGxcblx0XHR0aGlzLl9jYiA9ICggZXJyb3IsIGRhdGEgKSA9PiB7XG5cdFx0XHRpZiAoIHRoaXMuX3N0ZXAgKVxuXHRcdFx0XHRpZiAoIGVycm9yIClcblx0XHRcdFx0XHR0aGlzLl9zdGVwLmZhaWwoIGVycm9yIClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRoaXMuX3N0ZXAubmV4dCggZGF0YSApXG5cdFx0fVxuXHRcdHRoaXMuJG5hbWUgPSB7IHRvU3RyaW5nOiAoKSA9PiBgPFRocmVhZD5gIH1cblxuXHRcdHRoaXMuX25ld1N0ZXAoKVxuXHRcdHRoaXMuX3N0YXJ0ID0gKCkgPT4ge1xuXHRcdFx0aWYgKCB0aGlzLl9zdGFydCAmJiB0aGlzLl9zdGVwICYmIHRoaXMuX3N0ZXAubmV4dCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLl9zdG9wQ291bnQgPiAwIClcblx0XHRcdFx0XHR0aGlzLl9zdGVwLnJlc3VtZSA9IHRoaXMuX3N0YXJ0XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0ID0gbnVsbFxuXHRcdFx0XHRcdHRoaXMuX3N0ZXAubmV4dCgpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdFx0dGhpcy5fcmVzb2x2ZSA9IHJlc29sdmVcblx0XHRcdHRoaXMuX3JlamVjdCA9IHJlamVjdFxuXHRcdH0gKVxuXHRcdGlmICggIXRoaXMuX3Jlc29sdmUgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgYXNzZXJ0aW9uIGZhaWx1cmU6IHdyb25nIGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VgIClcblxuXHRcdGxhdGVyLnRoZW4oIHRoaXMuX3N0YXJ0IClcblx0XHRpZiAoIHRocmVhZENhdGNoZXIgKVxuXHRcdFx0dGhyZWFkQ2F0Y2hlciggdGhpcyApXG5cblx0XHRleHBvcnRzLmVtaXQoIGBzdGFydGAsIHRoaXMgKVxuXHR9XG5cblx0bGlua05hbWUoIHZhbHVlLCBzdWZmaXggPSBgOnRocmVhZGAgKSB7XG5cdFx0aWYgKCB2YWx1ZS4kbmFtZSApXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLiRuYW1lXG5cdFx0dGhpcy4kbmFtZS50b1N0cmluZyA9ICgpID0+IGBgICsgdmFsdWUgKyBzdWZmaXhcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0d2FpdEZvcklucHV0KCkge1xuXHRcdHRoaXMuX2NoZWNrRmluaXNoZWQoKVxuXHRcdGlmICggdGhpcy5fc3RvcENvdW50ID4gMCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGB0aHJlYWQgaXMgcGF1c2VkYCApXG5cdFx0aWYgKCB0aGlzLl9zdGFydCApXG5cdFx0XHR0aGlzLl9zdGFydCgpXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdF9hdHRhY2hQcm9taXNlKCBwcm9taXNlICkge1xuXHRcdHByb21pc2Uua2lsbCA9IHRoaXMua2lsbC5iaW5kKCB0aGlzIClcblx0XHRyZXR1cm4gcHJvbWlzZVxuXHR9XG5cblx0dGhlbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQgKSB7XG5cdFx0dGhpcy5fYXR0YWNoZWRUb1N0YWNrID0gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fYXR0YWNoUHJvbWlzZSggdGhpcy5fcHJvbWlzZS50aGVuKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCApIClcblx0fVxuXG5cdGNhdGNoKCBvblJlamVjdGVkICkge1xuXHRcdHRoaXMuX2F0dGFjaGVkVG9TdGFjayA9IGZhbHNlXG5cdFx0cmV0dXJuIHRoaXMuX2F0dGFjaFByb21pc2UoIHRoaXMuX3Byb21pc2UuY2F0Y2goIG9uUmVqZWN0ZWQgKSApXG5cdH1cblxuXHRpc0ZpbmlzaGVkKCkge1xuXHRcdHJldHVybiAhdGhpcy5fc3RlcCB8fCB0aGlzLl9raWxsaW5nXG5cdH1cblxuXHRpc1BhdXNlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RvcENvdW50ID4gMFxuXHR9XG5cblx0dGhyb3coIGV4Y2VwdGlvbiApIHtcblx0XHRpZiAoIHRoaXMuZ2xvYmFsID09IGV4cG9ydHMuZ2xvYmFsIClcblx0XHRcdHRocm93IGV4Y2VwdGlvblxuXHRcdHRoaXMuX2NoZWNrRmluaXNoZWQoKVxuXHRcdHRoaXMuX25ld1N0ZXAoKVxuXHRcdGlmICggdGhpcy5fc3RvcENvdW50ID4gMCApXG5cdFx0XHR0aGlzLl9zdGVwLnJlc3VtZSA9IHRoaXMuX3N0ZXAuZmFpbC5iaW5kKCB0aGlzLl9zdGVwLCBleGNlcHRpb24gKVxuXHRcdGVsc2Vcblx0XHRcdHRoaXMuX3N0ZXAuZmFpbCggZXhjZXB0aW9uIClcblx0fVxuXG5cdGF0dGFjaFRvU3RhY2soKSB7XG5cdFx0dGhpcy5fYXR0YWNoZWRUb1N0YWNrID0gdHJ1ZVxuXHR9XG5cblx0a2lsbCggcmVhc29uICkge1xuXHRcdGlmICggdGhpcy5pc0ZpbmlzaGVkKCkgKVxuXHRcdFx0cmV0dXJuXG5cdFx0dGhpcy5fcmVqZWN0KCByZWFzb24gKVxuXHRcdGlmICggdGhpcy5fcnVubmluZyApIHtcblx0XHRcdHRoaXMuX2tpbGxpbmcgPSB7IHJlYXNvbiB9XG5cdFx0XHR0aHJvdyBuZXcgRUtpbGxcblx0XHR9XG5cdFx0bGV0IHByZXZpb3VzVGhyZWFkID0gZXhwb3J0cy5jdXJyZW50XG5cdFx0bGV0IHByZXZpb3NDQiA9IGV4cG9ydHMuY2Jcblx0XHRsZXQgcHJldmlvc0dsb2JhbCA9IGV4cG9ydHMuZ2xvYmFsXG5cdFx0ZXhwb3J0cy5jYiA9IHRoaXMuX2NiXG5cdFx0ZXhwb3J0cy5nbG9iYWwgPSB0aGlzLmdsb2JhbFxuXHRcdGV4cG9ydHMuY3VycmVudCA9IHRoaXNcblx0XHRraWxsSXRlcmF0b3IoIHRoaXMuX2l0ZXJhdG9yIClcblx0XHRmb3IgKCBsZXQgYSA9IHRoaXMuX3N0YWNrLCBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IC0taSApXG5cdFx0XHRraWxsSXRlcmF0b3IoIGFbIGkgXSApXG5cdFx0ZXhwb3J0cy5jYiA9IHByZXZpb3NDQlxuXHRcdGV4cG9ydHMuZ2xvYmFsID0gcHJldmlvc0dsb2JhbFxuXHRcdGV4cG9ydHMuY3VycmVudCA9IHByZXZpb3VzVGhyZWFkXG5cdFx0aWYgKCB0aGlzLl9jdXJyZW50UHJvbWlzZSApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRQcm9taXNlLmtpbGwoIHJlYXNvbiApXG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdHJldGhyb3coIGUgKVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9kb25lKClcblx0fVxuXG5cdHBhdXNlKCkge1xuXHRcdHRoaXMuX2NoZWNrRmluaXNoZWQoKVxuXHRcdCsrdGhpcy5fc3RvcENvdW50XG5cdH1cblxuXHRyZXN1bWUoKSB7XG5cdFx0aWYgKCB0aGlzLl9zdG9wQ291bnQgPT0gMCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGB0aHJlYWQgbm90IHBhdXNlZGAgKVxuXHRcdGlmICggMCA9PSAtLXRoaXMuX3N0b3BDb3VudCAmJiB0aGlzLl9zdGVwICYmIHRoaXMuX3N0ZXAucmVzdW1lICkge1xuXHRcdFx0bGF0ZXIudGhlbiggdGhpcy5fc3RlcC5yZXN1bWUgKVxuXHRcdFx0dGhpcy5fc3RlcC5yZXN1bWUgPSBudWxsXG5cdFx0fVxuXHR9XG5cblx0X3RpY2soIHN0ZXAsIGltZXRob2QsIHJlc3VsdCApIHtcblx0XHRpZiAoIHRoaXMuZGVidWdnZXIgfHwgc3RlcC5kZWJ1Z2dlciApXG5cdFx0XHRkZWJ1Z2dlclxuXHRcdGlmICggdGhpcy5fcnVubmluZyApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiRkFUQUw6IHJlZW50ZXJpbmcgdGhyZWFkIHRpY2tcIiApXG5cdFx0aWYgKCBzdGVwICE9PSB0aGlzLl9zdGVwIClcblx0XHRcdHJldHVyblxuXHRcdGlmICggdGhpcy5fc3RvcENvdW50ID4gMCApIHtcblx0XHRcdHN0ZXAucmVzdW1lID0gdGhpcy5fdGljay5iaW5kKCB0aGlzLCBzdGVwLCBpbWV0aG9kLCByZXN1bHQgKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGZvciAoOzspIHtcblx0XHRcdHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbnVsbFxuXHRcdFx0dGhpcy5fcnVubmluZyA9IHRydWVcblx0XHRcdGxldCBwcmV2aW91c1RocmVhZCA9IGV4cG9ydHMuY3VycmVudFxuXHRcdFx0bGV0IHByZXZpb3NDQiA9IGV4cG9ydHMuY2Jcblx0XHRcdGxldCBwcmV2aW9zR2xvYmFsID0gZXhwb3J0cy5nbG9iYWxcblx0XHRcdGV4cG9ydHMuY2IgPSB0aGlzLl9jYlxuXHRcdFx0ZXhwb3J0cy5nbG9iYWwgPSB0aGlzLmdsb2JhbFxuXHRcdFx0ZXhwb3J0cy5jdXJyZW50ID0gdGhpc1xuXHRcdFx0bGV0IHYgPSB0aGlzLl9pdGVyYXRvci5jYWxsKCBpbWV0aG9kLCByZXN1bHQgKVxuXHRcdFx0ZXhwb3J0cy5jYiA9IHByZXZpb3NDQlxuXHRcdFx0ZXhwb3J0cy5nbG9iYWwgPSBwcmV2aW9zR2xvYmFsXG5cdFx0XHRleHBvcnRzLmN1cnJlbnQgPSBwcmV2aW91c1RocmVhZFxuXHRcdFx0dGhpcy5fcnVubmluZyA9IGZhbHNlXG5cdFx0XHRpZiAoIHRoaXMuZGVidWdnZXIgfHwgc3RlcC5kZWJ1Z2dlciApXG5cdFx0XHRcdGRlYnVnZ2VyXG5cdFx0XHRpZiAoIHRoaXMuX2tpbGxpbmcgKSB7XG5cdFx0XHRcdGxldCByZWFzb24gPSB0aGlzLl9raWxsaW5nLnJlYXNvblxuXHRcdFx0XHR0aGlzLl9raWxsaW5nID0gbnVsbFxuXHRcdFx0XHR0aGlzLmtpbGwoIHJlYXNvbiApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKCB2LmRvbmUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5pc0ZpbmlzaGVkKCkgKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRpZiAoIHRoaXMuX2l0ZXJhdG9yID0gdGhpcy5fc3RhY2sucG9wKCkgKSB7XG5cdFx0XHRcdFx0aW1ldGhvZCA9IHYuaXRlcmF0b3JGYWlsZWQgPyBpdGVyYXRvclRocm93IDogaXRlcmF0b3JOZXh0XG5cdFx0XHRcdFx0cmVzdWx0ID0gdi52YWx1ZVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IHIgPSB2Lml0ZXJhdG9yRmFpbGVkID8gdGhpcy5fcmVqZWN0IDogdGhpcy5fcmVzb2x2ZVxuXHRcdFx0XHR0aGlzLl9kb25lKClcblx0XHRcdFx0aWYgKCB2Lml0ZXJhdG9yRmFpbGVkICYmIHRoaXMuX2F0dGFjaGVkVG9TdGFjayApXG5cdFx0XHRcdFx0cmV0aHJvdyggdi52YWx1ZSApXG5cdFx0XHRcdHIoIHYudmFsdWUgKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICF2LnZhbHVlICkgLy8gYW55IGZhbHN5IHZhbHVlXG5cdFx0XHRcdGV4cG9ydHMudGljay50aGVuKCBzdGVwLm5leHQgKVxuXHRcdFx0ZWxzZSBpZiAoIHYudmFsdWUudGhlbiApIHtcblx0XHRcdFx0bGV0IHAgPSB2LnZhbHVlLnRoZW4oIHN0ZXAubmV4dCwgc3RlcC5mYWlsIClcblx0XHRcdFx0aWYgKCBwICYmIHAua2lsbCApXG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudFByb21pc2UgPSBwXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdi52YWx1ZS5uZXh0ICkge1xuXHRcdFx0XHR0aGlzLl9zdGFjay5wdXNoKCB0aGlzLl9pdGVyYXRvciApXG5cdFx0XHRcdHRoaXMuX2l0ZXJhdG9yID0gbmV3IEl0ZXJhdG9yUHJveHkoIHYudmFsdWUgKVxuXHRcdFx0XHRpbWV0aG9kID0gaXRlcmF0b3JOZXh0XG5cdFx0XHRcdHJlc3VsdCA9IHVuZGVmaW5lZFxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGBvbmxvYWRgIGluIHYudmFsdWUgJiYgIXYudmFsdWUub25sb2FkICYmIGBvbmVycm9yYCBpbiB2LnZhbHVlICYmICF2LnZhbHVlLm9uZXJyb3IgKSB7XG5cdFx0XHRcdHYudmFsdWUub25sb2FkID0gc3RlcC5uZXh0XG5cdFx0XHRcdHYudmFsdWUub25lcnJvciA9IHN0ZXAuZmFpbFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGBvbnN1Y2Nlc3NgIGluIHYudmFsdWUgJiYgIXYudmFsdWUub25sb2FkICYmIGBvbmVycm9yYCBpbiB2LnZhbHVlICYmICF2LnZhbHVlLm9uZXJyb3IgKSB7XG5cdFx0XHRcdGlmICggIXN0ZXAuc3VjY2Vzc19lcnJvciApXG5cdFx0XHRcdFx0c3RlcC5zdWNjZXNzX2Vycm9yID0ge1xuXHRcdFx0XHRcdFx0b25zdWNjZXNzKCBldmVudCApIHsgc3RlcC5uZXh0KCBldmVudC50YXJnZXQucmVzdWx0ICkgfSxcblx0XHRcdFx0XHRcdG9uZXJyb3IoIGV2ZW50ICkgeyBzdGVwLmZhaWwoIGV2ZW50LnRhcmdldC5lcnJvciB8fCBldmVudCApIH0sXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR2LnZhbHVlLm9uc3VjY2VzcyA9IHN0ZXAuc3VjY2Vzc19lcnJvci5vbnN1Y2Nlc3Ncblx0XHRcdFx0di52YWx1ZS5vbmVycm9yID0gc3RlcC5zdWNjZXNzX2Vycm9yLm9uZXJyb3Jcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgdGhyZWFkIHR5cGUgZXJyb3JgIClcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cblx0X2RvbmUoKSB7XG5cdFx0dGhpcy5fc3RlcCA9IG51bGxcblx0XHR0aGlzLl9pdGVyYXRvciA9IG51bGxcblx0XHR0aGlzLl9zdGFjayA9IG51bGxcblx0XHR0aGlzLl9yZXNvbHZlID0gbnVsbFxuXHRcdHRoaXMuX3JlamVjdCA9IG51bGxcblx0XHR0aGlzLl9jdXJyZW50UHJvbWlzZSA9IG51bGxcblx0XHR0aGlzLl9raWxsaW5nID0gbnVsbFxuXHR9XG5cblx0X25ld1N0ZXAoKSB7XG5cdFx0bGV0IHN0ZXAgPSB0aGlzLl9zdGVwID0geyByZXN1bWU6IG51bGwgfVxuXHRcdHN0ZXAubmV4dCA9IHRoaXMuX3RpY2suYmluZCggdGhpcywgc3RlcCwgaXRlcmF0b3JOZXh0IClcblx0XHRzdGVwLmZhaWwgPSB0aGlzLl90aWNrLmJpbmQoIHRoaXMsIHN0ZXAsIGl0ZXJhdG9yVGhyb3cgKVxuXHRcdGxldCAkbmFtZSA9IHRoaXMuJG5hbWVcblx0XHRzdGVwLm5leHQuJG5hbWUgPSB7IHRvU3RyaW5nOiAoKSA9PiAkbmFtZSArIGA6bmV4dGAgfVxuXHRcdHN0ZXAuZmFpbC4kbmFtZSA9IHsgdG9TdHJpbmc6ICgpID0+ICRuYW1lICsgYDpmYWlsYCB9XG5cdH1cblxuXHRfb25Qcm9taXNlKCByZXNvbHZlLCByZWplY3QgKSB7XG5cdFx0dGhpcy5fcmVzb2x2ZSA9IHJlc29sdmVcblx0XHR0aGlzLl9yZWplY3QgPSByZWplY3Rcblx0XHR0aGlzLnJlc3VtZSgpXG5cdH1cblxuXHRfY2hlY2tGaW5pc2hlZCgpIHtcblx0XHRpZiAoIHRoaXMuaXNGaW5pc2hlZCgpIClcblx0XHRcdHRocm93IG5ldyBFcnJvciggYHRocmVhZCBpcyBhbHJlYWR5IGZpbmlzaGVkYCApXG5cdH1cblxufVxuZXhwb3J0cy5UaHJlYWQgPSBUaHJlYWRcblxue1xuXHRsZXQgbm90RW51bWVyYWJsZSA9IHsgZW51bWVyYWJsZTogZmFsc2UgfVxuXHRPYmplY3Qua2V5cyggVGhyZWFkLnByb3RvdHlwZSApLmZvckVhY2goIGsgPT4gay5tYXRjaCggL15fLyApICYmXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBUaHJlYWQucHJvdG90eXBlLCBrLCBub3RFbnVtZXJhYmxlICkgKVxuXG5cdGxldCBtYWluVGhyZWFkID0gKCBuZXcgVGhyZWFkKCB7IG5leHQoKSB7IHJldHVybiB7IHZhbHVlOiB7IHRoZW4oKSB7fSB9IH0gfSB9ICkgKS53YWl0Rm9ySW5wdXQoKVxuXHRleHBvcnRzLmN1cnJlbnQgPSBudWxsXG5cdGV4cG9ydHMuZ2xvYmFsID0gbWFpblRocmVhZC5nbG9iYWxcblx0ZXhwb3J0cy5jYiA9IG51bGxcbn1cbiIsImxldCBjbyA9IHJlcXVpcmUoIGBjb2AgKVxubGV0IHJhID0gcmVxdWlyZSggYHJhYCApXG5sZXQgbG9kYXNoID0gcmVxdWlyZSggYGxvZGFzaGAgKVxuXG5mdW5jdGlvbiB0b05vZGUoIGNoaWxkLCBub2RlICkge1xuXHRyZXN0YXJ0OiBmb3IgKDs7KSB7XG5cdFx0Y2hpbGQgPSBjaGlsZCAmJiB0eXBlb2YgY2hpbGQudmFsdWVPZiA9PSBgZnVuY3Rpb25gID8gY2hpbGQudmFsdWVPZigpIDogY2hpbGRcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGNoaWxkICkgKSB7XG5cdFx0XHRpZiAoIGNoaWxkLmxlbmd0aCA9PSAwIClcblx0XHRcdFx0cmV0dXJuIG51bGxcblx0XHRcdGlmICggY2hpbGQubGVuZ3RoID09IDEgKSB7XG5cdFx0XHRcdGNoaWxkID0gY2hpbGRbIDAgXVxuXHRcdFx0XHRjb250aW51ZSByZXN0YXJ0XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFub2RlIClcblx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdFx0Y2hpbGQuZm9yRWFjaCggY2hpbGQgPT4gdG9Ob2RlKCBjaGlsZCwgbm9kZSApIClcblx0XHRcdGNoaWxkID0gbm9kZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICggdHlwZW9mIGNoaWxkID09IGBzdHJpbmdgIClcblx0XHRcdFx0Y2hpbGQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggY2hpbGQgKVxuXHRcdFx0aWYgKCBub2RlICkge1xuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKCBjaGlsZCApXG5cdFx0XHRcdGNoaWxkID0gbm9kZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2hpbGRcblx0fVxufVxuXG5mdW5jdGlvbiBmY2FsYyggZiwgY2IgKSB7XG5cdGlmICggdHlwZW9mIGYgIT0gYGZ1bmN0aW9uYCApXG5cdFx0Y2IoIGYgKVxuXHRlbHNlIHtcblx0XHRsZXQgZmlyc3QgPSB0cnVlXG5cdFx0cmEoIGZhbHNlLCBmdW5jdGlvbiogKCkge1xuXHRcdFx0aWYgKCBmaXJzdCApXG5cdFx0XHRcdGZpcnN0ID0gZmFsc2Vcblx0XHRcdGVsc2Vcblx0XHRcdFx0eWllbGQgY28ucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0XHRsZXQgcmV0ID0gZigpXG5cdFx0XHRpZiAoIHJldCAmJiByZXQubmV4dCAmJiByZXQudGhyb3cgKVxuXHRcdFx0XHRyZXQgPSB5aWVsZCByZXRcblx0XHRcdGNiKCByZXQgKVxuXHRcdH0gKVxuXHR9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRE9NQ29udHJvbCggY29udHJvbCApIHtcblx0bGV0IHEgPSBbXG5cdFx0Y29udHJvbC5vd25lckRvY3VtZW50ICYmIGNvbnRyb2wub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdGNvbnRyb2wub3duZXJEb2N1bWVudCAmJiBjb250cm9sLm93bmVyRG9jdW1lbnQuYm9keSxcblx0XHRkb2N1bWVudC5ib2R5LFxuXHRdLmZpbHRlciggQm9vbGVhbiApXG5cdGxldCBwID0gY29udHJvbFxuXHR3aGlsZSAoIHAgKSB7XG5cdFx0aWYgKCBxLmluZGV4T2YoIHAgKSA+PSAwICkge1xuXHRcdFx0cmEuZm9yY2VDYWxjdWxhdGlvbnMoKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHAgPSBwLnBhcmVudE5vZGVcblx0fVxufVxuXG5mdW5jdGlvbiBzZXRDb250ZW50KCBjb250cm9sLCBjb250ZW50LCBjYiA9IG51bGwgKSB7IGZjYWxjKCBjb250ZW50LCBjb250ZW50ID0+IHtcblx0Y2hlY2tET01Db250cm9sKCBjb250cm9sIClcblx0bGV0IGMgPSB0b05vZGUoIGNvbnRlbnQgKVxuXHRpZiAoIGMgKSB7XG5cdFx0Y2hlY2tET01Db250cm9sKCBjb250cm9sIClcblx0XHRjb250cm9sLmlubmVySFRNTCA9IGBgXG5cdFx0Y29udHJvbC5hcHBlbmRDaGlsZCggYyApXG5cdH1cblx0ZWxzZVxuXHRcdGNvbnRyb2wuaW5uZXJIVE1MID0gYGBcblx0Y2IgJiYgY2IoKVxufSApIH1cblxuZnVuY3Rpb24gdG9BdHRyU3RyaW5nKCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApIClcblx0XHRyZXR1cm4gdmFsdWUubWFwKCB0b0F0dHJTdHJpbmcgKS5qb2luKCBgIGAgKVxuXHRlbHNlIGlmICggdmFsdWUgKVxuXHRcdHJldHVybiBgJHsgdmFsdWUgfWBcblx0ZWxzZVxuXHRcdHJldHVybiBgYFxufVxuXG5mdW5jdGlvbiBhcHBlbmRDb250ZW50KCBjb250ZW50LCBmICkge1xuXHRpZiAoICFmIClcblx0XHRmID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdGZvciAoIGxldCBjIG9mIGNvbnRlbnQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgYyA9PSBgZnVuY3Rpb25gICkge1xuXHRcdFx0bGV0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgc3BhbmAgKVxuXHRcdFx0c2V0Q29udGVudCggcCwgYyApXG5cdFx0XHRmLmFwcGVuZENoaWxkKCBwIClcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGMgaW5zdGFuY2VvZiBOb2RlIClcblx0XHRcdGYuYXBwZW5kQ2hpbGQoIGMgKVxuXHRcdGVsc2UgaWYgKCBjICE9IG51bGwgJiYgdHlwZW9mIGMgIT0gYHN0cmluZ2AgJiYgY1sgU3ltYm9sLml0ZXJhdG9yIF0gKVxuXHRcdFx0Zm9yICggbGV0IGNjIG9mIGMgKVxuXHRcdFx0XHRhcHBlbmRDb250ZW50KCBjYywgZiApXG5cdFx0ZWxzZVxuXHRcdFx0Zi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIGMgKSApXG5cdH1cblx0cmV0dXJuIGZcbn1cblxubGV0IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBmdW5jdGlvbiogKCkge30gKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlRWxlbWVudCggbmFtZSwgYXR0cmlidXRlcywgLi4uY29udGVudCApIHtcblx0XHRpZiAoIHR5cGVvZiBuYW1lID09IGBmdW5jdGlvbmAgKVxuXHRcdFx0cmV0dXJuIG5hbWUoIGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5fID8gT2JqZWN0LmFzc2lnbigge30sIGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMuXywgeyBfOiBudWxsIH0gKSA6ICggYXR0cmlidXRlcyB8fCAwICksIGFwcGVuZENvbnRlbnQoIGNvbnRlbnQgKSApXG5cdFx0bGV0IG9uQ3JlYXRlXG5cdFx0bGV0IHJldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIG5hbWUgKVxuXHRcdGxldCBjbGFzc2VzID0gW11cblx0XHRmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMgPT0gbnVsbCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0bG9kYXNoLmZvckVhY2goIGF0dHJpYnV0ZXMsICggdmFsdWUsIG5hbWUgKSA9PiB7XG5cdFx0XHRcdGlmICggbmFtZSA9PSBgX2AgKSB7IC8vIG5vb3Bcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggbmFtZSA9PSBgY2xhc3NgIClcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goIHZhbHVlIClcblx0XHRcdFx0ZWxzZSBpZiAoIG5hbWUgPT0gYHN0eWxlYCApXG5cdFx0XHRcdFx0Ly8gVE9ETzogc210aCBsaWtlIHRvIFwiY2xhc3NcIiBhdHRyaWJ1dGUgLSBwYXJzZSBwYXJlbnQgc3R5bGUgYW5kIHVwZGF0ZSBpdFxuXHRcdFx0XHRcdGZjYWxjKCB2YWx1ZSwgdmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT0gYHN0cmluZ2AgKVxuXHRcdFx0XHRcdFx0XHRyZXQuc2V0QXR0cmlidXRlKCBgc3R5bGVgLCB2YWx1ZSApXG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdGxvZGFzaC5mb3JFYWNoKCB2YWx1ZSwgKCB2YWx1ZSwgbmFtZSApID0+IGZjYWxjKCB2YWx1ZSwgdmFsdWUgPT4gcmV0LnN0eWxlWyBuYW1lIF0gPSB2YWx1ZSApIClcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0ZWxzZSBpZiAoIG5hbWUgPT0gYG9uY3JlYXRlYCApXG5cdFx0XHRcdFx0b25DcmVhdGUgPSB2YWx1ZVxuXHRcdFx0XHRlbHNlIGlmICggbmFtZS5tYXRjaCggL15vbi8gKSApIHtcblx0XHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PSBgZnVuY3Rpb25gIClcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBbIHZhbHVlIF1cblx0XHRcdFx0XHRcdGZvciAoIGxldCBoYW5kbGVyIG9mIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIE9iamVjdC5nZXRQcm90b3R5cGVPZiggaGFuZGxlciApID09IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIClcblx0XHRcdFx0XHRcdFx0XHRoYW5kbGVyID0gY28uZXZlbnRIYW5kbGVyKCBoYW5kbGVyIClcblx0XHRcdFx0XHRcdFx0XHRyZXQuYWRkRXZlbnRMaXN0ZW5lciggbmFtZS5zbGljZSggYG9uYC5sZW5ndGggKSwgaGFuZGxlciApXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRmY2FsYyggdmFsdWUsIHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdG9BdHRyU3RyaW5nKCB2YWx1ZSApXG5cdFx0XHRcdFx0XHRpZiAoIHJldC5nZXRBdHRyaWJ1dGUoIG5hbWUgKSAhPSB2YWx1ZSApXG5cdFx0XHRcdFx0XHRcdHJldC5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlIClcblx0XHRcdFx0XHR9IClcblx0XHRcdH0gKVxuXHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGF0dHJpYnV0ZXMsIGBfYCApIClcblx0XHRcdFx0YXBwbHlBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzLl8gKVxuXHRcdH1cblx0XHRhcHBseUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMgKVxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHRsZXQgY29weSA9IGNsYXNzZXMubWFwKCAoKSA9PiBudWxsIClcblx0XHRcdGNsYXNzZXMuZm9yRWFjaCggKCBjLCBpICkgPT4gZmNhbGMoIGMsIGMgPT4ge1xuXHRcdFx0XHRjb3B5WyBpIF0gPSBjXG5cdFx0XHRcdGxldCBjbGFzc05hbWUgPSB0b0F0dHJTdHJpbmcoIGNvcHkgKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCAvKF58XFxzfFxccnxcXG4pKG51bGx8dW5kZWZpbmVkfGZhbHNlfDB8XFwtMHxOYU4pKD89JHxcXHN8XFxyfFxcbikvZywgYGAgKVxuXHRcdFx0XHRpZiAoIHJldC5jbGFzc05hbWUgIT0gY2xhc3NOYW1lIClcblx0XHRcdFx0XHRyZXQuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG5cdFx0XHR9ICkgKVxuXHRcdH1cblx0XHRzd2l0Y2ggKCBjb250ZW50Lmxlbmd0aCApIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMTpcblx0XHRcdHNldENvbnRlbnQoIHJldCwgY29udGVudFsgMCBdIClcblx0XHRcdGJyZWFrXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldC5hcHBlbmRDaGlsZCggYXBwZW5kQ29udGVudCggY29udGVudCApIClcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIG9uQ3JlYXRlID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRvbkNyZWF0ZS5jYWxsKCByZXQsIHtcblx0XHRcdFx0dHlwZTogYGNyZWF0ZWAsXG5cdFx0XHRcdHRhcmdldDogcmV0LFxuXHRcdFx0XHRzcmNFbGVtZW50OiByZXQsXG5cdFx0XHRcdGN1cnJlbnRUYXJnZXQ6IHJldCxcblx0XHRcdH0gKVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH0sXG59XG5cbmxldCB1cGRhdGVJbnB1dFZhbHVlID0gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KCAoKSA9PiB0aGlzLl9yYVZhbHVlLmFzc2lnbiggdGhpcy52YWx1ZSApICkgfVxubGV0IHJhVmFsdWUgPSB7XG5cdGdldCgpIHtcblx0XHRpZiAoICF0aGlzLl9yYVZhbHVlICkgcmEuZGV0YWNoKCAoKSA9PiB7XG5cdFx0XHR0aGlzLl9yYVZhbHVlID0gcmEoKVxuXHRcdFx0dGhpcy5fcmFWYWx1ZS5hc3NpZ24oIHRoaXMudmFsdWUgKVxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBgY2hhbmdlYCwgdXBkYXRlSW5wdXRWYWx1ZSApXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGBrZXlwcmVzc2AsIHVwZGF0ZUlucHV0VmFsdWUgKVxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBga2V5ZG93bmAsIHVwZGF0ZUlucHV0VmFsdWUgKVxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBga2V5dXBgLCB1cGRhdGVJbnB1dFZhbHVlIClcblx0XHR9IClcblx0XHRyZXR1cm4gdGhpcy5fcmFWYWx1ZS52YWx1ZU9mKClcblx0fSxcblx0c2V0KCB2YWx1ZSApIHtcblx0XHRpZiAoIHRoaXMudmFsdWUgIT0gdmFsdWUgKSB7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWVcblx0XHRcdGlmICggdGhpcy5fcmFWYWx1ZSApXG5cdFx0XHRcdHRoaXMuX3JhVmFsdWUuYXNzaWduKCB0aGlzLnZhbHVlIClcblx0XHR9XG5cdH0sXG59XG5cbmZvciAoIGxldCBDIG9mIFsgSFRNTElucHV0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCBdIClcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBDLnByb3RvdHlwZSwgYHJhVmFsdWVgLCByYVZhbHVlIClcbiIsImxldCBsb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5sZXQgVUlEID0gcmVxdWlyZSggYHVpZGAgKVxubGV0IGx1ID0gcmVxdWlyZSggYGxvY2FsVXRpbHNgIClcblxuZXhwb3J0cy5DbGVhciA9IGV4cG9ydHMuVW5saW5rID0gKCBkZXZpY2VzLCBkZXZpY2VJZCApID0+IGxvZGFzaC5yZWR1Y2UoIGRldmljZXMuY29udGVudCwgKCByZXQsIHEsIGluZGV4ICkgPT4ge1xuXHRpZiAoIHEgKVxuXHRcdGlmICggaW5kZXggPT0gZGV2aWNlSWQgKVxuXHRcdFx0cmV0LmNvbnRlbnRbIGluZGV4IF0gPSBudWxsXG5cdFx0ZWxzZSBpZiAoIHEuY29udGVudCAmJiBxLmNvbnRlbnRbIGRldmljZUlkIF0gKVxuXHRcdFx0cmV0LmNvbnRlbnRbIGluZGV4IF0gPSB7IGNvbnRlbnQ6IHsgWyBkZXZpY2VJZCBdOiBudWxsIH0gfVxuXHRyZXR1cm4gcmV0XG59LCB7IGNvbnRlbnQ6IHt9IH0gKVxuXG5leHBvcnRzLlNldCA9ICggZGV2aWNlcywgZGV2aWNlSWQsIGRhdGEgKSA9PiB7XG5cdGxldCBkZXZpY2UgPSBkZXZpY2VzLmNvbnRlbnRbIGRldmljZUlkIF1cblx0aWYgKCAhZGV2aWNlIHx8ICFkZXZpY2UuZ3JvdXAgKVxuXHRcdHJldHVyblxuXHRsZXQgcmV0ID0geyBjb250ZW50OiB7IFsgZGV2aWNlSWQgXTogZGF0YSB9IH1cblx0aWYgKCBkZXZpY2UudHlwZSA9PSBgZ3JvdXBgIClcblx0XHRyZXQgPSBsb2Rhc2gucmVkdWNlKCBkZXZpY2UuY29udGVudCwgKCByZXQsIHEsIGluZGV4ICkgPT4ge1xuXHRcdFx0aWYgKCBxIClcblx0XHRcdFx0cmV0LmNvbnRlbnRbIGluZGV4IF0gPSBkYXRhXG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fSwgcmV0IClcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnRzLmZpbmRGcmVlR3JvdXAgPSBkZXZpY2VzID0+IHtcblx0bGV0IGdyb3VwcyA9IFtdXG5cdGZvciAoIGxldCBpID0gMTsgaSA8PSAxMDIyOyArK2kgKVxuXHRcdGdyb3Vwc1sgaSBdID0gaVxuXHRsb2Rhc2guZm9yRWFjaCggZGV2aWNlcy5jb250ZW50LCBkZXZpY2UgPT4gZGV2aWNlICYmIE51bWJlci5pc0Zpbml0ZSggZGV2aWNlLmdyb3VwICkgJiYgKCBncm91cHNbIGRldmljZS5ncm91cCBdID0gZmFsc2UgKSApXG5cdGdyb3VwcyA9IGdyb3Vwcy5maWx0ZXIoIEJvb2xlYW4gKVxuXHRyZXR1cm4gIWdyb3Vwcy5sZW5ndGggPyBudWxsIDogZ3JvdXBzWyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogZ3JvdXBzLmxlbmd0aCApICUgZ3JvdXBzLmxlbmd0aCBdXG59XG5cbmV4cG9ydHMuY2xlYW5EYXRhYmFzZSA9IGRldmljZXMgPT4ge1xuXHRsZXQgcmV0ID0gZGV2aWNlcyB8fCB7fVxuXHRmdW5jdGlvbiBfc2F2ZSggZGlmZiApIHtcblx0XHRyZXQgPSBsdS5hcHBseURpZmYoIHJldCwgZGlmZiApXG5cdH1cblx0ZnVuY3Rpb24gX2NoYW5nZSggcGF0aCwgdmFsdWUgKSB7XG5cdFx0X3NhdmUoIHBhdGgucmVkdWNlUmlnaHQoICggcmV0LCBrZXkgKSA9PiAoIHsgWyBrZXkgXTogcmV0IH0gKSwgdmFsdWUgKSApXG5cdH1cblx0ZnVuY3Rpb24gYXNzaWduKCAuLi5wYXRoICkge1xuXHRcdF9jaGFuZ2UoIHBhdGgsIHBhdGgucG9wKCkgKVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZSggLi4ucGF0aCApIHtcblx0XHRfY2hhbmdlKCBwYXRoLCBudWxsIClcblx0fVxuXG5cdC8vIG1vdmUgcm9vdCBpdGVtcyB0byBjb250ZW50XG5cdGlmICggIXJldC5jb250ZW50IClcblx0XHRsb2Rhc2guZm9yRWFjaCggcmV0LCAoIHBsYWNlLCBwbGFjZUlkICkgPT4ge1xuXHRcdFx0aWYgKCBwbGFjZSAhPSBudWxsICYmIHR5cGVvZiBwbGFjZSAhPSBgb2JqZWN0YCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0cmVtb3ZlKCBwbGFjZUlkIClcblx0XHRcdGFzc2lnbiggYGNvbnRlbnRgLCBwbGFjZUlkLCBwbGFjZSApXG5cdFx0fSApXG5cdGVsc2UgLy8gVE9ETyBkZWxldGUgbGF0ZXJcblx0XHRsb2Rhc2guZm9yRWFjaCggcmV0LCAoIHBsYWNlLCBwbGFjZUlkICkgPT4ge1xuXHRcdFx0aWYgKCBwbGFjZSAhPSBudWxsICYmIHR5cGVvZiBwbGFjZSAhPSBgb2JqZWN0YCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0aWYgKCBwbGFjZUlkID09IGBjb250ZW50YCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0cmVtb3ZlKCBwbGFjZUlkIClcblx0XHR9IClcblxuXHQvLyByZW1vdmUgaXRlbXMgd2l0aCB3cm9uZyB0eXBlICYgcmVtb3ZlIGdyb3VwIGZyb20gcGxhY2VzXG5cdGxvZGFzaC5mb3JFYWNoKCByZXQuY29udGVudCwgKCBwbGFjZSwgcGxhY2VJZCApID0+IHtcblx0XHRpZiAoIHBsYWNlID09IG51bGwgfHwgdHlwZW9mIHBsYWNlICE9IGBvYmplY3RgIClcblx0XHRcdHJldHVybiByZW1vdmUoIGBjb250ZW50YCwgcGxhY2VJZCAgKVxuXHRcdGlmICggcGxhY2UudHlwZSA9PSBgZGV2aWNlYCApIC8vIFRPRE86IHJlbW92ZSBsYXRlclxuXHRcdFx0YXNzaWduKCBgY29udGVudGAsIHBsYWNlSWQsIGB0eXBlYCwgYHNpbmdsZWAgKVxuXHRcdGlmICggcGxhY2UuZGV2aWNlID09IHBsYWNlSWQgKVxuXHRcdFx0cmVtb3ZlKCBgY29udGVudGAsIHBsYWNlSWQsIGBkZXZpY2VgIClcblx0XHRlbHNlIGlmICggISggcGxhY2UudHlwZSB8fCBgYCApLm1hdGNoKCAvXihwbGFjZXxncm91cHxzaW5nbGUpJC8gKSApXG5cdFx0XHRyZXR1cm4gcmVtb3ZlKCBgY29udGVudGAsIHBsYWNlSWQgKVxuXHRcdGlmICggcGxhY2UuZ3JvdXAgIT0gbnVsbCAmJiAoICFOdW1iZXIuaXNGaW5pdGUoIHBsYWNlLmdyb3VwICkgfHwgcGxhY2UudHlwZSA9PSBgcGxhY2VgICkgKVxuXHRcdFx0cmVtb3ZlKCBgY29udGVudGAsIHBsYWNlSWQsIGBncm91cGAgKVxuXHR9IClcblxuXHQvLyBjcmVhdGUgbWFpblxuXHRpZiAoIHJldCAmJiB0eXBlb2YgcmV0Lm1haW4gIT0gYHN0cmluZ2AgKSB7XG5cdFx0bGV0IG1haW4gPSBVSUQoKVxuXHRcdGxldCBpID0gMFxuXHRcdGxvZGFzaC5mb3JFYWNoKCByZXQuY29udGVudCwgKCBwbGFjZSwga2V5ICkgPT4gYXNzaWduKCBgY29udGVudGAsIG1haW4sIGBjb250ZW50YCwga2V5LCArK2kgKSApXG5cdFx0aWYgKCByZXQuY29udGVudCAmJiByZXQuY29udGVudFsgbWFpbiBdIClcblx0XHRcdGFzc2lnbiggYG1haW5gLCBtYWluIClcblx0fVxuXG5cdC8vIHJlbW92ZSBpdGVtcyB3aXRoIGR1cGxpY2F0ZSBncm91cFxuXHRsZXQgcmVhY2hhYmxlXG5cdGZ1bmN0aW9uIGdyb3VwSW5kZXgoIGtleSApIHtcblx0XHRpZiAoICFyZWFjaGFibGUgKSB7XG5cdFx0XHRyZWFjaGFibGUgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGxldCByZWFjaGFibGVLZXlzID0gW11cblx0XHRcdGZ1bmN0aW9uIHB1c2goIGtleSApIHtcblx0XHRcdFx0aWYgKCAhKCBrZXkgaW4gcmVhY2hhYmxlICkgJiYgcmV0LmNvbnRlbnQuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHJlYWNoYWJsZVsga2V5IF0gPSB0cnVlXG5cdFx0XHRcdFx0cmVhY2hhYmxlS2V5cy5wdXNoKCBrZXkgKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBrZXlcblx0XHRcdH1cblx0XHRcdHB1c2goIHJldC5tYWluIClcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJlYWNoYWJsZUtleXMubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdGxldCBwbGFjZSA9IHJldC5jb250ZW50WyByZWFjaGFibGVLZXlzWyBpIF0gXVxuXHRcdFx0XHRpZiAoIHBsYWNlICYmIHBsYWNlLmNvbnRlbnQgKVxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKCBwbGFjZS5jb250ZW50ICkuZm9yRWFjaCggcHVzaCApXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxldCBpID0gMFxuXHRcdGlmICggcmV0LmNvbnRlbnRbIGtleSBdLnR5cGUgPT0gYGdyb3VwYCApXG5cdFx0XHRpICs9IDJcblx0XHRpZiAoIGtleSBpbiByZWFjaGFibGUgKVxuXHRcdFx0aSArPSAxXG5cdH1cblxuXHRsZXQgZ3JvdXBzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdGxvZGFzaC5mb3JFYWNoKCByZXQuY29udGVudCwgKCBwbGFjZSwga2V5ICkgPT4ge1xuXHRcdGlmICggIXBsYWNlIHx8IHBsYWNlLmdyb3VwID09IG51bGwgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCAhZ3JvdXBzWyBwbGFjZS5ncm91cCBdIClcblx0XHRcdGdyb3Vwc1sgcGxhY2UuZ3JvdXAgXSA9IGtleVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKCBncm91cEluZGV4KCBncm91cHNbIHBsYWNlLmdyb3VwIF0gKSA8IGdyb3VwSW5kZXgoIGtleSApICkge1xuXHRcdFx0XHRyZW1vdmUoIGBjb250ZW50YCwgZ3JvdXBzWyBwbGFjZS5ncm91cCBdIClcblx0XHRcdFx0Z3JvdXBzWyBwbGFjZS5ncm91cCBdID0ga2V5XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlbW92ZSggYGNvbnRlbnRgLCBrZXkgKVxuXHRcdH1cblx0fSApXG5cblx0Ly8gY2hlY2sgY29udGVudFxuXHRsb2Rhc2guZm9yRWFjaCggcmV0LmNvbnRlbnQsICggcGxhY2UsIGtleSApID0+IHtcblx0XHRpZiAoICFwbGFjZSB8fCBwbGFjZS5jb250ZW50ID09IG51bGwgKVxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCB0eXBlb2YgcGxhY2UuY29udGVudCAhPSBgb2JqZWN0YCApXG5cdFx0XHRyZXR1cm4gcmVtb3ZlKCBgY29udGVudGAsIGtleSwgYGNvbnRlbnRgIClcblx0XHRsb2Rhc2guZm9yRWFjaCggcGxhY2UuY29udGVudCwgKCBfLCBja2V5ICkgPT4ge1xuXHRcdFx0aWYgKCAhcmV0LmNvbnRlbnRbIGNrZXkgXSB8fCB0eXBlb2YgcmV0LmNvbnRlbnRbIGNrZXkgXSAhPSBgb2JqZWN0YCApXG5cdFx0XHRcdHJlbW92ZSggYGNvbnRlbnRgLCBrZXksIGBjb250ZW50YCwgY2tleSApXG5cdFx0fSApXG5cdFx0cGxhY2UgPSByZXQuY29udGVudFsga2V5IF0gLy8gcmVhc3NpZ24gcGxhY2UgY2F1c2UgaXQgY291bGQgY2hhbmdlIGluIHByZXZpb3VzIGZvckVhY2hcblx0XHRsb2Rhc2gua2V5cyggcGxhY2UuY29udGVudCApXG5cdFx0LnNvcnQoICggYSwgYiApID0+ICggcGxhY2UuY29udGVudFsgYSBdLmluZGV4IHx8IDAgKSAtICggcGxhY2UuY29udGVudFsgYiBdLmluZGV4IHx8IDAgKSApXG5cdFx0LmZvckVhY2goICggY2tleSwgaW5kZXggKSA9PiB7XG5cdFx0XHRpZiAoIHBsYWNlLmNvbnRlbnRbIGNrZXkgXS5pbmRleCAhPSBpbmRleCApXG5cdFx0XHRcdGFzc2lnbiggYGNvbnRlbnRgLCBrZXksIGBjb250ZW50YCwgY2tleSwgYGluZGV4YCwgaW5kZXggKVxuXHRcdH0gKVxuXHR9IClcblxuXHRyZXR1cm4gbHUubWFrZURpZmYoIGRldmljZXMsIHJldCApXG59XG4iLCIvKlxuXG4yMDE0LjA5LjIyXG5cbml0IHNob3VsZCBiZSBiZXR0ZXIgdG8gdXNlIGhhbW1lci5qcywgYnV0IGkgY2Fubm90IHVzZSBpdCB3aXRob3V0IHByb2JsZW1zIC1cbmhhbW1lci5qcyBvZnRlbiBkcm9wcyBldmVudHMsIHdoaWxlIGRpcmVjdCBhZGRFdmVudExpc3RlbmVyIGRvZXMgbm90LlxuXG4qL1xuXG5sZXQgY28gPSByZXF1aXJlKCBgY29gIClcbmxldCBzcGFyc2VxdWV1ZSA9IHJlcXVpcmUoIGBzcGFyc2VxdWV1ZWAgKVxuXG5sZXQgVFJBQ0Vcbi8vIGxldCBUQyA9IDBcbi8vIFRSQUNFID0gKCAuLi5pbmZvICkgPT4gTE9HKCBgJHsgKytUQyB9IGcgJHsgSlNPTi5zdHJpbmdpZnkoIGluZm8gKS5zbGljZSggMCwgMTAwICkgfWAuZ3JlZW4gKVxuXG5sZXQgU1dJUEVfVElNRU9VVCA9IDQwMCAvLyBtc1xubGV0IFBSRVNTX1RJTUVPVVQgPSA1MDAgLy8gbXNcbmxldCBQUkVTU19NT1ZFX09VVCA9IDIgLyogfm1tICovICogKCA5NiAvIDI1LjQgKVxuXG5mdW5jdGlvbiBzcXVhcmVEaXN0YW5jZSggcDEsIHAyICkge1xuXHRyZXR1cm4gKCBwMS5wYWdlWCAtIHAyLnBhZ2VYICkgKiAoIHAxLnBhZ2VYIC0gcDIucGFnZVggKSArICggcDEucGFnZVkgLSBwMi5wYWdlWSApICogKCBwMS5wYWdlWSAtIHAyLnBhZ2VZIClcbn1cblxuZnVuY3Rpb24gZ2V0WCggcCApIHsgcmV0dXJuIHAucGFnZVggfVxuZnVuY3Rpb24gZ2V0WSggcCApIHsgcmV0dXJuIHAucGFnZVkgfVxuZnVuY3Rpb24gaW5jcmVhc2luZyggdiwgaSwgcCApIHsgcmV0dXJuIGkgPT0gMCB8fCB2ID49IHBbIGkgLSAxIF0gfVxuZnVuY3Rpb24gZGVjcmVhc2luZyggdiwgaSwgcCApIHsgcmV0dXJuIGkgPT0gMCB8fCB2IDw9IHBbIGkgLSAxIF0gfVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBgdG91Y2hgLCBjby5ldmVudEhhbmRsZXIoIGZ1bmN0aW9uKiAoIGV2ZW50ICkge1xuXG5cdGxldCBhbGxcblx0bGV0IHRyYWNlID0gWyBldmVudCBdXG5cdGxldCBsYXN0ID0gZXZlbnRcblx0bGV0IHByZXNzZWQgPSBudWxsXG5cdGxldCBzd2lwZWQgPSBmYWxzZVxuXG5cdGxldCBwYW4gPSBudWxsXG5cdGxldCBwYW5sb2NrID0gbnVsbFxuXHRsZXQgc2VudCA9IGV2ZW50XG5cblx0Y28uZGVmZXIoICgpID0+IHtcblx0XHRwYW5sb2NrICYmIHBhbmxvY2suZm9yRWFjaCggbG9jayA9PiBsb2NrLnF1ZXVlLmNsb3NlKCkgKVxuXHRcdHBhbiAmJiBwYW4ucXVldWUuY2xvc2UoKVxuXHR9IClcblxuXHRmdW5jdGlvbiBzZW5kKCB0eXBlLCBkaXJlY3Rpb24sIHB0LCBkZXRhaWwsIHR5cGVEaXJlY3Rpb24gKSB7XG5cdFx0VFJBQ0UgJiYgVFJBQ0UoIHR5cGUsIGFsbCApXG5cdFx0aWYgKCB0eXBlRGlyZWN0aW9uID09IG51bGwgKVxuXHRcdFx0dHlwZURpcmVjdGlvbiA9IGRpcmVjdGlvblxuXHRcdGlmICggIWRldGFpbCApXG5cdFx0XHRkZXRhaWwgPSB7fVxuXHRcdGRldGFpbC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25cblx0XHRkZXRhaWwucHJlc3NlZCA9IHByZXNzZWRcblx0XHRkZXRhaWwudHlwZSA9IHR5cGVcblx0XHRkZXRhaWwuc3RhcnQgPSBldmVudFxuXHRcdGRldGFpbC5vcmlnaW5hbCA9IHB0IHx8IGV2ZW50XG5cdFx0bGV0IHJldCA9IG5ldyBDdXN0b21FdmVudCggdHlwZSArICggdHlwZURpcmVjdGlvbiB8fCBgYCApLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbCB9IClcblx0XHRyZXQucGFnZVggPSBsYXN0LnBhZ2VYXG5cdFx0cmV0LnBhZ2VZID0gbGFzdC5wYWdlWVxuXHRcdHJldC5jbGllbnRYID0gbGFzdC5jbGllbnRYXG5cdFx0cmV0LmNsaWVudFkgPSBsYXN0LmNsaWVudFlcblx0XHRyZXQuc2NyZWVuWCA9IGxhc3Quc2NyZWVuWFxuXHRcdHJldC5zY3JlZW5ZID0gbGFzdC5zY3JlZW5ZXG5cdFx0cmV0LmRlbHRhWCA9IGxhc3QucGFnZVggLSBldmVudC5wYWdlWFxuXHRcdHJldC5kZWx0YVkgPSBsYXN0LnBhZ2VZIC0gZXZlbnQucGFnZVlcblx0XHRyZXQubGFzdERlbHRhWCA9IGxhc3QucGFnZVggLSBzZW50LnBhZ2VYXG5cdFx0cmV0Lmxhc3REZWx0YVkgPSBsYXN0LnBhZ2VZIC0gc2VudC5wYWdlWVxuXHRcdHNlbnQgPSBsYXN0XG5cdFx0cmV0LnByZXZlbnREZWZhdWx0ID0gKCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdGV2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KCByZXQgKVxuXHRcdHJldHVybiByZXRcblx0fVxuXG5cdGZ1bmN0aW9uIGVuc3VyZXBhbiggZGlyZWN0aW9uICkge1xuXHRcdGlmICggcGFuIClcblx0XHRcdHJldHVyblxuXHRcdHBhbiA9IHsgcXVldWU6IG5ldyBzcGFyc2VxdWV1ZSB9XG5cdFx0c2VuZCggYHBhbmAsIGRpcmVjdGlvbiwgbGFzdCwge1xuXHRcdFx0bmV4dDogcGFuLnF1ZXVlLFxuXHRcdFx0bG9jaygpIHtcblx0XHRcdFx0aWYgKCAhcGFubG9jayApXG5cdFx0XHRcdFx0cGFubG9jayA9IFtdXG5cdFx0XHRcdGxldCByZXQgPSB7IHF1ZXVlOiBuZXcgc3BhcnNlcXVldWUgfVxuXHRcdFx0XHRwYW5sb2NrLnB1c2goIHJldCApXG5cdFx0XHRcdHJldHVybiByZXQucXVldWVcblx0XHRcdH0sXG5cdFx0XHR1bmxvY2soIGxvY2sgKSB7XG5cdFx0XHRcdHBhbmxvY2sgPSBwYW5sb2NrLmZpbHRlciggbCA9PiBsICE9IGxvY2sgKVxuXHRcdFx0XHRsZXQgcCA9IHBhbmxvY2tbIDAgXSB8fCBwYW5cblx0XHRcdFx0aWYgKCBwLmRpcnR5ICkge1xuXHRcdFx0XHRcdHAuZGlydHkgPSBmYWxzZVxuXHRcdFx0XHRcdHNlbmRwYW4oIGBwYW5gLCBgdW5sb2NrZWRgIClcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9LCBgYCApXG5cdH1cblxuXHRmdW5jdGlvbiBzZW5kcGFuKCB0eXBlLCBkaXJlY3Rpb24sIHB0LCBkZXRhaWwgKSB7XG5cdFx0bGV0IGRhdGEgPSBzZW5kKCB0eXBlLCBkaXJlY3Rpb24sIHB0LCBkZXRhaWwgKVxuXHRcdGlmICggcGFuICkge1xuXHRcdFx0aWYgKCBwYW5sb2NrICYmIHBhbmxvY2subGVuZ3RoICkge1xuXHRcdFx0XHRwYW5sb2NrWyAwIF0ucXVldWUucHVzaCggZGF0YSApXG5cdFx0XHRcdHBhbmxvY2suZm9yRWFjaCggKCBwLCBpICkgPT4gaSA+IDAgJiYgKCBwLmRpcnR5ID0gdHJ1ZSApIClcblx0XHRcdFx0cGFuLmRpcnR5ID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwYW4ucXVldWUucHVzaCggZGF0YSApXG5cdFx0fVxuXHR9XG5cblx0bGV0IHByZXNzVGltZW91dFxuXHRsZXQgc3RvcHBlZFRpbWVvdXRcblx0Y28uZGVmZXIoICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQoIHByZXNzVGltZW91dCApXG5cdFx0Y2xlYXJUaW1lb3V0KCBzdG9wcGVkVGltZW91dCApXG5cdH0gKVxuXG5cdHByZXNzVGltZW91dCA9IHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRwcmVzc2VkID0gdHJ1ZVxuXHRcdHNlbmQoIGBwcmVzc2AgKVxuXHR9LCBQUkVTU19USU1FT1VUIClcblxuXHRmdW5jdGlvbiBzdGFydFN0b3BwZWRUaW1lb3V0KCkge1xuXHRcdGNsZWFyVGltZW91dCggc3RvcHBlZFRpbWVvdXQgKVxuXHRcdHN0b3BwZWRUaW1lb3V0ID0gc2V0VGltZW91dCggKCkgPT4ge1xuXHRcdFx0ZW5zdXJlcGFuKClcblx0XHRcdHNlbmRwYW4oIGBzdG9wYCApXG5cdFx0XHRzdGFydFN0b3BwZWRUaW1lb3V0KClcblx0XHR9LCBQUkVTU19USU1FT1VUIClcblx0fVxuXG5cdHN0YXJ0U3RvcHBlZFRpbWVvdXQoKVxuXG5cdFRSQUNFICYmIFRSQUNFKCBgZW50ZXJgLCB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSwgdDogZXZlbnQudGltZVN0YW1wIH0gKVxuXG5cdGxldCBzdG9wUG9pbnQgPSBldmVudFxuXG5cdGZvciAoIGxldCBwdDsgcHQgPSB5aWVsZCBldmVudC5kZXRhaWwubmV4dDsgKSB7XG5cdFx0aWYgKCBUUkFDRSApIHtcblx0XHRcdCggYWxsIHx8ICggYWxsID0gW10gKSApLnB1c2goIHsgeDogcHQucGFnZVgsIHk6IHB0LnBhZ2VZLCB0OiBwdC50aW1lU3RhbXAgLSBldmVudC50aW1lU3RhbXAgfSApXG5cdFx0XHRUUkFDRSggYG5leHRgLCBhbGwgKVxuXHRcdH1cblx0XHRpZiAoIGxhc3QudGltZVN0YW1wIC0gZXZlbnQudGltZVN0YW1wID4gU1dJUEVfVElNRU9VVCApXG5cdFx0XHR0cmFjZSA9IG51bGxcblxuXHRcdGxldCBsb25nbW92ZSA9IHNxdWFyZURpc3RhbmNlKCBwdCwgc3RvcFBvaW50ICkgPiBQUkVTU19NT1ZFX09VVCAqIFBSRVNTX01PVkVfT1VUXG5cdFx0aWYgKCBsb25nbW92ZSApIHtcblx0XHRcdHN0b3BQb2ludCA9IHB0XG5cdFx0XHRzdGFydFN0b3BwZWRUaW1lb3V0KClcblx0XHR9XG5cblx0XHRpZiAoIGxvbmdtb3ZlIHx8ICF0cmFjZSB8fCB0cmFjZS5sZW5ndGggPiAxICkge1xuXHRcdFx0aWYgKCBwcmVzc2VkID09IG51bGwgKSB7XG5cdFx0XHRcdHByZXNzZWQgPSBmYWxzZVxuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHByZXNzVGltZW91dCApXG5cdFx0XHR9XG5cdFx0XHRsZXQgZHggPSBwdC5wYWdlWCAtIGxhc3QucGFnZVhcblx0XHRcdGxldCBkeSA9IHB0LnBhZ2VZIC0gbGFzdC5wYWdlWVxuXHRcdFx0aWYgKCBkeCB8fCBkeSApIHtcblx0XHRcdFx0bGV0IHNpemV4ID0gTWF0aC5hYnMoIGR4IClcblx0XHRcdFx0bGV0IHNpemV5ID0gTWF0aC5hYnMoIGR5IClcblx0XHRcdFx0bGV0IHByZXYgPSBsYXN0XG5cdFx0XHRcdGlmICggdHJhY2UgKVxuXHRcdFx0XHRcdHRyYWNlLnB1c2goIGxhc3QgKVxuXHRcdFx0XHRsYXN0ID0gcHRcblx0XHRcdFx0bGV0IGRpcmVjdGlvbiA9IGBgXG5cdFx0XHRcdGlmICggc2l6ZXggPj0gc2l6ZXkgJiYgZHggPiAwIClcblx0XHRcdFx0XHRkaXJlY3Rpb24gPSBgcmlnaHRgXG5cdFx0XHRcdGVsc2UgaWYgKCBzaXpleCA+PSBzaXpleSAmJiBkeCA8IDAgKVxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9IGBsZWZ0YFxuXHRcdFx0XHRlbHNlIGlmICggc2l6ZXggPCBzaXpleSAmJiBkeSA+IDAgKVxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9IGBkb3duYFxuXHRcdFx0XHRlbHNlIGlmICggc2l6ZXggPCBzaXpleSAmJiBkeSA8IDAgKVxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9IGB1cGBcblx0XHRcdFx0ZW5zdXJlcGFuKCBkaXJlY3Rpb24gKVxuXHRcdFx0XHRzZW5kcGFuKCBgcGFuYCwgZGlyZWN0aW9uLCBsYXN0IClcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y2xlYXJUaW1lb3V0KCBwcmVzc1RpbWVvdXQgKVxuXHRpZiAoIGxhc3QudGltZVN0YW1wIC0gZXZlbnQudGltZVN0YW1wIDwgU1dJUEVfVElNRU9VVCAmJiB0cmFjZSAmJiB0cmFjZS5sZW5ndGggPiAyICkge1xuXHRcdC8vIHJlbW92ZSBmaXJzdCBwb2ludCB0byBlbGltaW5hdGUgdG91Y2ggYm91bmNpbmcgZWZmZWN0XG5cdFx0dHJhY2Uuc2hpZnQoKVxuXHRcdGxldCB0cmFjZVggPSB0cmFjZS5tYXAoIGdldFggKVxuXHRcdGxldCB0cmFjZVkgPSB0cmFjZS5tYXAoIGdldFkgKVxuXHRcdGxldCBib3VuZHMgPSB7XG5cdFx0XHR4OiBNYXRoLm1heCggLi4udHJhY2VYICkgLSBNYXRoLm1pbiggLi4udHJhY2VYICksXG5cdFx0XHR5OiBNYXRoLm1heCggLi4udHJhY2VZICkgLSBNYXRoLm1pbiggLi4udHJhY2VZICksXG5cdFx0fVxuXHRcdGxldCBkaXJlY3Rpb24gPSBgYFxuXHRcdGlmICggYm91bmRzLnggPiBib3VuZHMueSAmJiB0cmFjZVguZXZlcnkoIGluY3JlYXNpbmcgKSApXG5cdFx0XHRkaXJlY3Rpb24gPSBgcmlnaHRgXG5cdFx0ZWxzZSBpZiAoIGJvdW5kcy54ID4gYm91bmRzLnkgJiYgdHJhY2VYLmV2ZXJ5KCBkZWNyZWFzaW5nICkgKVxuXHRcdFx0ZGlyZWN0aW9uID0gYGxlZnRgXG5cdFx0ZWxzZSBpZiAoIGJvdW5kcy54IDwgYm91bmRzLnkgJiYgdHJhY2VZLmV2ZXJ5KCBpbmNyZWFzaW5nICkgKVxuXHRcdFx0ZGlyZWN0aW9uID0gYGRvd25gXG5cdFx0ZWxzZSBpZiAoIGJvdW5kcy54IDwgYm91bmRzLnkgJiYgdHJhY2VZLmV2ZXJ5KCBkZWNyZWFzaW5nICkgKVxuXHRcdFx0ZGlyZWN0aW9uID0gYHVwYFxuXHRcdGlmICggZGlyZWN0aW9uICkge1xuXHRcdFx0c3dpcGVkID0gdHJ1ZVxuXHRcdFx0c2VuZHBhbiggYHN3aXBlYCwgZGlyZWN0aW9uLCBsYXN0IClcblx0XHR9XG5cdH1cblx0aWYgKCAhcHJlc3NlZCAmJiAhc3dpcGVkICYmICFwYW4gKVxuXHRcdHNlbmRwYW4oIGB0YXBgIClcblx0VFJBQ0UgJiYgVFJBQ0UoIGBkb25lYCwgYWxsIClcbn0gKSApXG4iLCJsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgZGl2YCApLnN0eWxlXG5pZiAoICEoIGB0cmFuc2Zvcm1gIGluIHN0eWxlICkgJiYgKCBgd2Via2l0VHJhbnNmb3JtYCBpbiBzdHlsZSApICkge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIENTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLCBgdHJhbnNmb3JtYCwge1xuXHRcdGdldCgpIHsgcmV0dXJuIHRoaXMud2Via2l0VHJhbnNmb3JtIH0sXG5cdFx0c2V0KCB2YWx1ZSApIHsgdGhpcy53ZWJraXRUcmFuc2Zvcm0gPSB2YWx1ZSB9LFxuXHR9IClcbn1cblxuLy8gbGV0IHNsaWNlID0gW10uc2xpY2VcblxuaWYgKCAhTm9kZUxpc3QucHJvdG90eXBlWyBTeW1ib2wuaXRlcmF0b3IgXSApXG5cdE5vZGVMaXN0LnByb3RvdHlwZVsgU3ltYm9sLml0ZXJhdG9yIF0gPSBmdW5jdGlvbiogKCkge1xuXHRcdC8vIHJldHVybiBzbGljZS5jYWxsKCB0aGlzIClbIFN5bWJvbC5pdGVyYXRvciBdXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyArK2kgKVxuXHRcdFx0eWllbGQgdGhpcy5pdGVtKCBpIClcblx0fVxuXG4iLCJleHBvcnRzLnByZXZlbnREZWZhdWx0ID0gZXZlbnQgPT4gZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG5leHBvcnRzLlN1Ym1pdCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdGV2ZW50ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0bGV0IGMgPSB0aGlzXG5cdHdoaWxlICggYyAmJiAhKCBjIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50ICkgKVxuXHRcdGMgPSBjLnBhcmVudE5vZGVcblx0aWYgKCBjIClcblx0XHRjLmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudCggYHN1Ym1pdGAsIG51bGwgKSApXG5cdHJldHVybiBmYWxzZVxufVxuXG5sZXQgY2VudGVyZWQgPSBgXG5cdHdpZHRoOiAxMDAlO1xuXHRoZWlnaHQ6IDEwMCU7XG5cdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdHRleHQtYWxpZ246IGNlbnRlcjtcbmBcblxuZXhwb3J0cy5DZW50ZXJlZCA9ICggXywgY29udGVudCApID0+XG5cdDx0YWJsZSBzdHlsZSA9IHsgY2VudGVyZWQgfSA+XG5cdFx0PHRyIHN0eWxlID0geyBjZW50ZXJlZCB9ID5cblx0XHRcdDx0ZCBzdHlsZSA9IHsgY2VudGVyZWQgfSA+e1xuXHRcdFx0XHRjb250ZW50XG5cdFx0XHR9PC90ZD5cblx0XHQ8L3RyPlxuXHQ8L3RhYmxlPlxuXG5leHBvcnRzLmlzRW1wdHlOb2RlID0gbm9kZSA9PlxuXHRub2RlIGluc3RhbmNlb2YgQ29tbWVudCB8fCBub2RlIGluc3RhbmNlb2YgUHJvY2Vzc2luZ0luc3RydWN0aW9uIHx8IG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmICFub2RlLm5vZGVWYWx1ZS50cmltKClcblxuZXhwb3J0cy5pbXBvcnRUZW1wbGF0ZSA9IHRlbXBsYXRlID0+IGRvY3VtZW50LmltcG9ydE5vZGUoIHRlbXBsYXRlLmNvbnRlbnQsIHRydWUgKVxuXG5leHBvcnRzLmltcG9ydEVsZW1lbnQgPSB0ZW1wbGF0ZSA9PiB7XG5cdGxldCByZXQgPSBleHBvcnRzLmltcG9ydFRlbXBsYXRlKCB0ZW1wbGF0ZSApXG5cdGlmICggIXJldCApXG5cdFx0cmV0dXJuIG51bGxcblx0d2hpbGUgKCByZXQubGFzdENoaWxkICYmIGV4cG9ydHMuaXNFbXB0eU5vZGUoIHJldC5sYXN0Q2hpbGQgKSApXG5cdFx0cmV0LnJlbW92ZUNoaWxkKCByZXQubGFzdENoaWxkIClcblx0d2hpbGUgKCByZXQuZmlyc3RDaGlsZCAmJiBleHBvcnRzLmlzRW1wdHlOb2RlKCByZXQuZmlyc3RDaGlsZCApIClcblx0XHRyZXQucmVtb3ZlQ2hpbGQoIHJldC5maXJzdENoaWxkIClcblx0aWYgKCAhcmV0LmZpcnN0Q2hpbGQgKVxuXHRcdHJldHVybiBudWxsXG5cdGlmICggcmV0LmNoaWxkTm9kZXMubGVuZ3RoID09IDEgKVxuXHRcdHJldHVybiByZXQuY2hpbGROb2Rlcy5pdGVtKCAwIClcblx0bGV0IHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgc3BhbmAgKVxuXHRyb290LmFwcGVuZENoaWxkKCByZXQgKVxuXHRyZXR1cm4gcm9vdFxufVxuXG5leHBvcnRzLmltcG9ydENvbXBvbmVudCA9IHRlbXBsYXRlID0+IHtcblx0bGV0IGRhdGEgPSBleHBvcnRzLmltcG9ydEVsZW1lbnQoIHRlbXBsYXRlIClcblx0aWYgKCBkYXRhICkge1xuXHRcdGxldCBpbml0ID0gZGF0YS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBgaW5pdGAgKVsgMCBdXG5cdFx0aWYgKCBpbml0ICYmIGluaXQudHlwZSA9PSBgaW5pdGAgKSB7XG5cdFx0XHRsZXQgZmluaXQgPSBuZXcgRnVuY3Rpb24oIGBjb21wb25lbnRgLCBbXS5zbGljZS5jYWxsKCBpbml0LmNoaWxkTm9kZXMgKS5tYXAoIHggPT4geC5kYXRhIHx8IGBgICkuam9pbiggYGAgKSApXG5cdFx0XHRmaW5pdCggZGF0YSApXG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhXG59XG5cbmV4cG9ydHMudGlja0NhY2hlID0gZnVuID0+IHtcblx0bGV0IGNhY2hlZFJlc3VsdFxuXHRsZXQgY2FjaGVkID0gZmFsc2VcblxuXHRsZXQgY2xlYXJDYWNoZSA9ICgpID0+IHtcblx0XHRjYWNoZWRSZXN1bHQgPSBudWxsXG5cdFx0Y2FjaGVkID0gZmFsc2Vcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCAhY2FjaGVkICkge1xuXHRcdFx0Y2FjaGVkUmVzdWx0ID0gZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuXHRcdFx0Y2FjaGVkID0gdHJ1ZVxuXHRcdFx0c2V0SW1tZWRpYXRlKCBjbGVhckNhY2hlIClcblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlZFJlc3VsdFxuXHR9XG59XG5cbmV4cG9ydHMuY3JlYXRlRXZlbnQgPSAoIHR5cGUsIGRldGFpbCwgb24gKSA9PiB7XG5cdGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCggdHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSApXG5cdGlmICggb24gKSB7XG5cdFx0ZXZlbnQucGFnZVggPSBvbi5wYWdlWFxuXHRcdGV2ZW50LnBhZ2VZID0gb24ucGFnZVlcblx0XHRldmVudC5jbGllbnRYID0gb24uY2xpZW50WFxuXHRcdGV2ZW50LmNsaWVudFkgPSBvbi5jbGllbnRZXG5cdFx0ZXZlbnQuc2NyZWVuWCA9IG9uLnNjcmVlblhcblx0XHRldmVudC5zY3JlZW5ZID0gb24uc2NyZWVuWVxuXHR9XG5cdHJldHVybiBldmVudFxufVxuXG5leHBvcnRzLnNlbmRFdmVudCA9ICggdHlwZSwgZGV0YWlsLCBvbiApID0+IG9uLnRhcmdldC5kaXNwYXRjaEV2ZW50KCBleHBvcnRzLmNyZWF0ZUV2ZW50KCB0eXBlLCBkZXRhaWwsIG9uICkgKVxuIiwibGV0IGh0dHBDbGllbnQgPSB7XG5cdGdldCggdXJsLCBlbmNvZGluZyApIHtcblx0XHRyZXR1cm4gaHR0cENsaWVudC54aHIoIHsgbWV0aG9kOiBgR0VUYCwgdXJsLCBlbmNvZGluZyB9IClcblx0fSxcblxuXHRwb3N0KCB1cmwsIGRhdGEsIGVuY29kaW5nICkge1xuXHRcdHJldHVybiBodHRwQ2xpZW50LnhociggeyBtZXRob2Q6IGBQT1NUYCwgdXJsLCBkYXRhLCBlbmNvZGluZyB9IClcblx0fSxcblxuXHR4aHIoIG9wdGlvbnMgKSB7XG5cdFx0bGV0IHsgbWV0aG9kLCB1cmwsIGVuY29kaW5nLCBkYXRhIH0gPSBvcHRpb25zXG5cdFx0bGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cdFx0aWYgKCBlbmNvZGluZyA9PSBgYmluYXJ5YCApXG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gYGFycmF5YnVmZmVyYFxuXHRcdGVsc2Vcblx0XHRcdHhoci5yZXNwb25zZVR5cGUgPSBgdGV4dGBcblx0XHRsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcblx0XHRcdGxldCBvbmVycm9yID0gZXJyb3IgPT4ge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBlcnJvciA9PSBgc3RyaW5nYCApIHtcblx0XHRcdFx0XHRlcnJvciA9IG5ldyBFcnJvciggZXJyb3IgKVxuXHRcdFx0XHRcdGVycm9yLm1ldGhvZCA9IG1ldGhvZFxuXHRcdFx0XHRcdGVycm9yLnVybCA9IHVybFxuXHRcdFx0XHR9XG5cdFx0XHRcdGdsb2JhbC5fQUxFUlQgJiYgZ2xvYmFsLl9BTEVSVCggYHRyeSBgICsgZXJyb3IgKyB1cmwgKVxuXHRcdFx0XHRyZWplY3QoIGVycm9yIClcblx0XHRcdH1cblx0XHRcdHhoci5vbnRpbWVvdXQgPSAoKSA9PiBvbmVycm9yKCBuZXcgRXJyb3IoIGBUSU1FT1VUICR7IHVybCB9YCApIClcblx0XHRcdHhoci5vbmVycm9yID0gZSA9PiBvbmVycm9yKCBlIHx8IGBFUlJPUmAgKVxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcblx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PSB4aHIuRE9ORSAmJiB4aHIuc3RhdHVzID09IDAgKVxuXHRcdFx0XHRcdHhoci5vbnRpbWVvdXQoKVxuXHRcdFx0fVxuXHRcdFx0eGhyLm9ubG9hZCA9ICgpID0+IHtcblx0XHRcdFx0Ly8gYWxlcnQoIHhoci5zdGF0dXMgKVxuXHRcdFx0XHRpZiAoIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMjk5IClcblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZSggeGhyLnJlc3BvbnNlID09IG51bGwgPyBudWxsIDogeGhyLnJlc3BvbnNlIClcblx0XHRcdFx0aWYgKCB4aHIuc3RhdHVzID09IDQwMSApIHtcblx0XHRcdFx0XHQvLyBhcHBlbmQgc29tZSB0aGluZyB0byB0aGUgcGFnZSB0byBmb3JjZSBzdGFuZGFsb25lIGJyb3dzZXIgdG8gc2hvdyBsb2dpbiBkaWFsb2dcblx0XHRcdFx0XHRsZXQgc3VybCA9IHJlcXVpcmUoIGB1cmxgICkucGFyc2UoIHVybCApXG5cdFx0XHRcdFx0aWYgKCBzdXJsLmhvc3QgKSB7XG5cdFx0XHRcdFx0XHRzdXJsID0gYCR7IHN1cmwucHJvdG9jb2wgfS8vJHsgc3VybC5ob3N0IH0vZHVtbXkuJHsgTWF0aC5yYW5kb20oKSB9LmpzYFxuXHRcdFx0XHRcdFx0bGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGBzY3JpcHRgIClcblx0XHRcdFx0XHRcdHNjcmlwdC5zcmMgPSBzdXJsXG5cdFx0XHRcdFx0XHQvLyBhbGVydCggc3VybCApXG5cdFx0XHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBzY3JpcHQgKVxuXHRcdFx0XHRcdFx0c2V0VGltZW91dCggKCkgPT4gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggc2NyaXB0ICksIDEwMDAgKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRvbmVycm9yKCBgJHsgeGhyLnN0YXR1cyB9ICR7IHhoci5zdGF0dXNUZXh0IH1gIClcblx0XHRcdH1cblx0XHR9IClcblx0XHRzd2l0Y2ggKCBlbmNvZGluZyApIHtcblx0XHRjYXNlIGBpbW11dGFibGVgOlxuXHRcdFx0cHJvbWlzZSA9IHByb21pc2UudGhlbiggZGF0YSA9PiBJbW11dGFibGUuZnJvbUpTKCBKU09OLnBhcnNlKCBkYXRhICkgKSApXG5cdFx0XHRicmVha1xuXHRcdGNhc2UgYGJpbmFyeWA6XG5cdFx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKCBkYXRhID0+IG5ldyBVaW50OEFycmF5KCBkYXRhICkgKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlIGB0ZXh0YDpcblx0XHRcdGJyZWFrXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oIGRhdGEgPT4ge1xuXHRcdFx0XHRsZXQgYWN0dWFsRW5jb2RpbmcgPSBlbmNvZGluZ1xuXHRcdFx0XHRpZiAoICFhY3R1YWxFbmNvZGluZyApIHtcblx0XHRcdFx0XHRsZXQgY3QgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoIGBjb250ZW50LXR5cGVgICkgfHwgYGBcblx0XHRcdFx0XHRpZiAoIGN0Lm1hdGNoKCAvXmFwcGxpY2F0aW9uXFwvanNvbi8gKSApXG5cdFx0XHRcdFx0XHRhY3R1YWxFbmNvZGluZyA9IGBqc29uYFxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAoIGFjdHVhbEVuY29kaW5nICkge1xuXHRcdFx0XHRjYXNlIGBqc29uYDpcblx0XHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRhdGFcblx0XHRcdH0gKVxuXHRcdH1cblx0XHR4aHIub3BlbiggbWV0aG9kIHx8IGBHRVRgLCB1cmwgKVxuXHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG5cdFx0eGhyLnNlbmQoIGRhdGEgKVxuXHRcdHhoci50aGVuID0gcHJvbWlzZS50aGVuLmJpbmQoIHByb21pc2UgKVxuXHRcdHhoci5jYXRjaCA9IHByb21pc2UuY2F0Y2guYmluZCggcHJvbWlzZSApXG5cdFx0cmV0dXJuIHhoclxuXHR9LFxuXG5cdHVybCggdXJsLCBwYXJhbXMgKSB7XG5cdFx0cGFyYW1zICYmIE9iamVjdC5rZXlzKCBwYXJhbXMgKS5mb3JFYWNoKCAoIGssIGkgKSA9PiB1cmwgPSB1cmxcblx0XHRcdCsgKCBpID4gMCA/IGAmYCA6IGA/YCApXG5cdFx0XHQrIGVuY29kZVVSSUNvbXBvbmVudCggayApXG5cdFx0XHQrIGA9YFxuXHRcdFx0KyBlbmNvZGVVUklDb21wb25lbnQoIHBhcmFtc1sgayBdIClcblx0XHQpXG5cdFx0cmV0dXJuIHVybFxuXHR9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh0dHBDbGllbnRcbiIsIi8qXG5cbnZhZHppbSB6aWVua2FcblxuMjAxNS4wNS4xMVxuYWRkZWQgdGhpcy5zdG9wcGVkVHJhbnNpdGlvbiB0byBub3QgdG8gZmlyZSB0YXAgd2hlbiBzY3JvbGxpbmcgaXMgc3RvcHBlZCBieSB0aGF0IHRhcC5cblxuICovXG5cbi8qISBpU2Nyb2xsIHY1LjEuMyB+IChjKSAyMDA4LTIwMTQgTWF0dGVvIFNwaW5lbGxpIH4gaHR0cDovL2N1YmlxLm9yZy9saWNlbnNlICovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIE1hdGgpIHtcbnZhciByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXHR8fFxuXHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHR8fFxuXHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVx0XHR8fFxuXHRmdW5jdGlvbiAoY2FsbGJhY2spIHsgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7IH07XG5cbnZhciB1dGlscyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBtZSA9IHt9O1xuXG5cdHZhciBfZWxlbWVudFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cdHZhciBfdmVuZG9yID0gKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmVuZG9ycyA9IFsndCcsICd3ZWJraXRUJywgJ01velQnLCAnbXNUJywgJ09UJ10sXG5cdFx0XHR0cmFuc2Zvcm0sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB2ZW5kb3JzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdHRyYW5zZm9ybSA9IHZlbmRvcnNbaV0gKyAncmFuc2Zvcm0nO1xuXHRcdFx0aWYgKCB0cmFuc2Zvcm0gaW4gX2VsZW1lbnRTdHlsZSApIHJldHVybiB2ZW5kb3JzW2ldLnN1YnN0cigwLCB2ZW5kb3JzW2ldLmxlbmd0aC0xKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pKCk7XG5cblx0ZnVuY3Rpb24gX3ByZWZpeFN0eWxlIChzdHlsZSkge1xuXHRcdGlmICggX3ZlbmRvciA9PT0gZmFsc2UgKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKCBfdmVuZG9yID09PSAnJyApIHJldHVybiBzdHlsZTtcblx0XHRyZXR1cm4gX3ZlbmRvciArIHN0eWxlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3R5bGUuc3Vic3RyKDEpO1xuXHR9XG5cblx0bWUuZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uIGdldFRpbWUgKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG5cblx0bWUuZXh0ZW5kID0gZnVuY3Rpb24gKHRhcmdldCwgb2JqKSB7XG5cdFx0Zm9yICggdmFyIGkgaW4gb2JqICkge1xuXHRcdFx0dGFyZ2V0W2ldID0gb2JqW2ldO1xuXHRcdH1cblx0fTtcblxuXHRtZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChlbCwgdHlwZSwgZm4sIGNhcHR1cmUpIHtcblx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCAhIWNhcHR1cmUpO1xuXHR9O1xuXG5cdG1lLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuXHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sICEhY2FwdHVyZSk7XG5cdH07XG5cblx0bWUucHJlZml4UG9pbnRlckV2ZW50ID0gZnVuY3Rpb24gKHBvaW50ZXJFdmVudCkge1xuXHRcdHJldHVybiB3aW5kb3cuTVNQb2ludGVyRXZlbnQgPyBcblx0XHRcdCdNU1BvaW50ZXInICsgcG9pbnRlckV2ZW50LmNoYXJBdCg5KS50b1VwcGVyQ2FzZSgpICsgcG9pbnRlckV2ZW50LnN1YnN0cigxMCk6XG5cdFx0XHRwb2ludGVyRXZlbnQ7XG5cdH07XG5cblx0bWUubW9tZW50dW0gPSBmdW5jdGlvbiAoY3VycmVudCwgc3RhcnQsIHRpbWUsIGxvd2VyTWFyZ2luLCB3cmFwcGVyU2l6ZSwgZGVjZWxlcmF0aW9uKSB7XG5cdFx0dmFyIGRpc3RhbmNlID0gY3VycmVudCAtIHN0YXJ0LFxuXHRcdFx0c3BlZWQgPSBNYXRoLmFicyhkaXN0YW5jZSkgLyB0aW1lLFxuXHRcdFx0ZGVzdGluYXRpb24sXG5cdFx0XHRkdXJhdGlvbjtcblxuXHRcdGRlY2VsZXJhdGlvbiA9IGRlY2VsZXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gMC4wMDA2IDogZGVjZWxlcmF0aW9uO1xuXG5cdFx0ZGVzdGluYXRpb24gPSBjdXJyZW50ICsgKCBzcGVlZCAqIHNwZWVkICkgLyAoIDIgKiBkZWNlbGVyYXRpb24gKSAqICggZGlzdGFuY2UgPCAwID8gLTEgOiAxICk7XG5cdFx0ZHVyYXRpb24gPSBzcGVlZCAvIGRlY2VsZXJhdGlvbjtcblxuXHRcdGlmICggZGVzdGluYXRpb24gPCBsb3dlck1hcmdpbiApIHtcblx0XHRcdGRlc3RpbmF0aW9uID0gd3JhcHBlclNpemUgPyBsb3dlck1hcmdpbiAtICggd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApICkgOiBsb3dlck1hcmdpbjtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoZGVzdGluYXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9IGVsc2UgaWYgKCBkZXN0aW5hdGlvbiA+IDAgKSB7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IHdyYXBwZXJTaXplID8gd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApIDogMDtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoY3VycmVudCkgKyBkZXN0aW5hdGlvbjtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVzdGluYXRpb246IE1hdGgucm91bmQoZGVzdGluYXRpb24pLFxuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0fTtcblx0fTtcblxuXHR2YXIgX3RyYW5zZm9ybSA9IF9wcmVmaXhTdHlsZSgndHJhbnNmb3JtJyk7XG5cblx0bWUuZXh0ZW5kKG1lLCB7XG5cdFx0aGFzVHJhbnNmb3JtOiBfdHJhbnNmb3JtICE9PSBmYWxzZSxcblx0XHRoYXNQZXJzcGVjdGl2ZTogX3ByZWZpeFN0eWxlKCdwZXJzcGVjdGl2ZScpIGluIF9lbGVtZW50U3R5bGUsXG5cdFx0aGFzVG91Y2g6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyxcblx0XHRoYXNQb2ludGVyOiB3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudCwgLy8gSUUxMCBpcyBwcmVmaXhlZFxuXHRcdGhhc1RyYW5zaXRpb246IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvbicpIGluIF9lbGVtZW50U3R5bGVcblx0fSk7XG5cblx0Ly8gVGhpcyBzaG91bGQgZmluZCBhbGwgQW5kcm9pZCBicm93c2VycyBsb3dlciB0aGFuIGJ1aWxkIDUzNS4xOSAoYm90aCBzdG9jayBicm93c2VyIGFuZCB3ZWJ2aWV3KVxuXHRtZS5pc0JhZEFuZHJvaWQgPSAvQW5kcm9pZCAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uKSAmJiAhKC9DaHJvbWVcXC9cXGQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uKSk7XG5cblx0bWUuZXh0ZW5kKG1lLnN0eWxlID0ge30sIHtcblx0XHR0cmFuc2Zvcm06IF90cmFuc2Zvcm0sXG5cdFx0dHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbicpLFxuXHRcdHRyYW5zaXRpb25EdXJhdGlvbjogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uRHVyYXRpb24nKSxcblx0XHR0cmFuc2l0aW9uRGVsYXk6IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvbkRlbGF5JyksXG5cdFx0dHJhbnNmb3JtT3JpZ2luOiBfcHJlZml4U3R5bGUoJ3RyYW5zZm9ybU9yaWdpbicpXG5cdH0pO1xuXG5cdG1lLmhhc0NsYXNzID0gZnVuY3Rpb24gKGUsIGMpIHtcblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjICsgXCIoXFxcXHN8JClcIik7XG5cdFx0cmV0dXJuIHJlLnRlc3QoZS5jbGFzc05hbWUpO1xuXHR9O1xuXG5cdG1lLmFkZENsYXNzID0gZnVuY3Rpb24gKGUsIGMpIHtcblx0XHRpZiAoIG1lLmhhc0NsYXNzKGUsIGMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBuZXdjbGFzcyA9IGUuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG5cdFx0bmV3Y2xhc3MucHVzaChjKTtcblx0XHRlLmNsYXNzTmFtZSA9IG5ld2NsYXNzLmpvaW4oJyAnKTtcblx0fTtcblxuXHRtZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlLCBjKSB7XG5cdFx0aWYgKCAhbWUuaGFzQ2xhc3MoZSwgYykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgYyArIFwiKFxcXFxzfCQpXCIsICdnJyk7XG5cdFx0ZS5jbGFzc05hbWUgPSBlLmNsYXNzTmFtZS5yZXBsYWNlKHJlLCAnICcpO1xuXHR9O1xuXG5cdG1lLm9mZnNldCA9IGZ1bmN0aW9uIChlbCkge1xuXHRcdHZhciBsZWZ0ID0gLWVsLm9mZnNldExlZnQsXG5cdFx0XHR0b3AgPSAtZWwub2Zmc2V0VG9wO1xuXG5cdFx0Ly8ganNoaW50IC1XMDg0XG5cdFx0d2hpbGUgKGVsID0gZWwub2Zmc2V0UGFyZW50KSB7XG5cdFx0XHRsZWZ0IC09IGVsLm9mZnNldExlZnQ7XG5cdFx0XHR0b3AgLT0gZWwub2Zmc2V0VG9wO1xuXHRcdH1cblx0XHQvLyBqc2hpbnQgK1cwODRcblxuXHRcdHJldHVybiB7XG5cdFx0XHRsZWZ0OiBsZWZ0LFxuXHRcdFx0dG9wOiB0b3Bcblx0XHR9O1xuXHR9O1xuXG5cdG1lLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uID0gZnVuY3Rpb24gKGVsLCBleGNlcHRpb25zKSB7XG5cdFx0Zm9yICggdmFyIGkgaW4gZXhjZXB0aW9ucyApIHtcblx0XHRcdGlmICggZXhjZXB0aW9uc1tpXS50ZXN0KGVsW2ldKSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdG1lLmV4dGVuZChtZS5ldmVudFR5cGUgPSB7fSwge1xuXHRcdHRvdWNoc3RhcnQ6IDEsXG5cdFx0dG91Y2htb3ZlOiAxLFxuXHRcdHRvdWNoZW5kOiAxLFxuXG5cdFx0bW91c2Vkb3duOiAyLFxuXHRcdG1vdXNlbW92ZTogMixcblx0XHRtb3VzZXVwOiAyLFxuXG5cdFx0cG9pbnRlcmRvd246IDMsXG5cdFx0cG9pbnRlcm1vdmU6IDMsXG5cdFx0cG9pbnRlcnVwOiAzLFxuXG5cdFx0TVNQb2ludGVyRG93bjogMyxcblx0XHRNU1BvaW50ZXJNb3ZlOiAzLFxuXHRcdE1TUG9pbnRlclVwOiAzXG5cdH0pO1xuXG5cdG1lLmV4dGVuZChtZS5lYXNlID0ge30sIHtcblx0XHRxdWFkcmF0aWM6IHtcblx0XHRcdHN0eWxlOiAnY3ViaWMtYmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRyZXR1cm4gayAqICggMiAtIGsgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNpcmN1bGFyOiB7XG5cdFx0XHRzdHlsZTogJ2N1YmljLWJlemllcigwLjEsIDAuNTcsIDAuMSwgMSknLFx0Ly8gTm90IHByb3Blcmx5IFwiY2lyY3VsYXJcIiBidXQgdGhpcyBsb29rcyBiZXR0ZXIsIGl0IHNob3VsZCBiZSAoMC4wNzUsIDAuODIsIDAuMTY1LCAxKVxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoIDEgLSAoIC0tayAqIGsgKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YmFjazoge1xuXHRcdFx0c3R5bGU6ICdjdWJpYy1iZXppZXIoMC4xNzUsIDAuODg1LCAwLjMyLCAxLjI3NSknLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHZhciBiID0gNDtcblx0XHRcdFx0cmV0dXJuICggayA9IGsgLSAxICkgKiBrICogKCAoIGIgKyAxICkgKiBrICsgYiApICsgMTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGJvdW5jZToge1xuXHRcdFx0c3R5bGU6ICcnLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdGlmICggKCBrIC89IDEgKSA8ICggMSAvIDIuNzUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogayAqIGs7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGsgPCAoIDIgLyAyLjc1ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDEuNSAvIDIuNzUgKSApICogayArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGsgPCAoIDIuNSAvIDIuNzUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMi4yNSAvIDIuNzUgKSApICogayArIDAuOTM3NTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMi42MjUgLyAyLjc1ICkgKSAqIGsgKyAwLjk4NDM3NTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZWxhc3RpYzoge1xuXHRcdFx0c3R5bGU6ICcnLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHZhciBmID0gMC4yMixcblx0XHRcdFx0XHRlID0gMC40O1xuXG5cdFx0XHRcdGlmICggayA9PT0gMCApIHsgcmV0dXJuIDA7IH1cblx0XHRcdFx0aWYgKCBrID09IDEgKSB7IHJldHVybiAxOyB9XG5cblx0XHRcdFx0cmV0dXJuICggZSAqIE1hdGgucG93KCAyLCAtIDEwICogayApICogTWF0aC5zaW4oICggayAtIGYgLyA0ICkgKiAoIDIgKiBNYXRoLlBJICkgLyBmICkgKyAxICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRtZS50YXAgPSBmdW5jdGlvbiAoZSwgZXZlbnROYW1lKSB7XG5cdFx0dmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG5cdFx0ZXYuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0ZXYucGFnZVggPSBlLnBhZ2VYO1xuXHRcdGV2LnBhZ2VZID0gZS5wYWdlWTtcblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcblx0fTtcblxuXHRtZS5jbGljayA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0LFxuXHRcdFx0ZXY7XG5cblx0XHRpZiAoICEoLyhTRUxFQ1R8SU5QVVR8VEVYVEFSRUEpL2kpLnRlc3QodGFyZ2V0LnRhZ05hbWUpICkge1xuXHRcdFx0ZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblx0XHRcdGV2LmluaXRNb3VzZUV2ZW50KCdjbGljaycsIHRydWUsIHRydWUsIGUudmlldywgMSxcblx0XHRcdFx0dGFyZ2V0LnNjcmVlblgsIHRhcmdldC5zY3JlZW5ZLCB0YXJnZXQuY2xpZW50WCwgdGFyZ2V0LmNsaWVudFksXG5cdFx0XHRcdGUuY3RybEtleSwgZS5hbHRLZXksIGUuc2hpZnRLZXksIGUubWV0YUtleSxcblx0XHRcdFx0MCwgbnVsbCk7XG5cblx0XHRcdGV2Ll9jb25zdHJ1Y3RlZCA9IHRydWU7XG5cdFx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBtZTtcbn0pKCk7XG5cbmZ1bmN0aW9uIElTY3JvbGwgKGVsLCBvcHRpb25zKSB7XG5cdHRoaXMud3JhcHBlciA9IHR5cGVvZiBlbCA9PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpIDogZWw7XG5cdHRoaXMuc2Nyb2xsZXIgPSB0aGlzLndyYXBwZXIuY2hpbGRyZW5bMF07XG5cdHRoaXMuc2Nyb2xsZXJTdHlsZSA9IHRoaXMuc2Nyb2xsZXIuc3R5bGU7XHRcdC8vIGNhY2hlIHN0eWxlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcblxuXHR0aGlzLm9wdGlvbnMgPSB7XG5cblx0XHRyZXNpemVTY3JvbGxiYXJzOiB0cnVlLFxuXG5cdFx0bW91c2VXaGVlbFNwZWVkOiAyMCxcblxuXHRcdHNuYXBUaHJlc2hvbGQ6IDAuMzM0LFxuXG4vLyBJTlNFUlQgUE9JTlQ6IE9QVElPTlMgXG5cblx0XHRzdGFydFg6IDAsXG5cdFx0c3RhcnRZOiAwLFxuXHRcdHNjcm9sbFk6IHRydWUsXG5cdFx0ZGlyZWN0aW9uTG9ja1RocmVzaG9sZDogNSxcblx0XHRtb21lbnR1bTogdHJ1ZSxcblxuXHRcdGJvdW5jZTogdHJ1ZSxcblx0XHRib3VuY2VUaW1lOiA2MDAsXG5cdFx0Ym91bmNlRWFzaW5nOiAnJyxcblxuXHRcdHByZXZlbnREZWZhdWx0OiB0cnVlLFxuXHRcdHByZXZlbnREZWZhdWx0RXhjZXB0aW9uOiB7IHRhZ05hbWU6IC9eKElOUFVUfFRFWFRBUkVBfEJVVFRPTnxTRUxFQ1QpJC8gfSxcblxuXHRcdEhXQ29tcG9zaXRpbmc6IHRydWUsXG5cdFx0dXNlVHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1c2VUcmFuc2Zvcm06IHRydWVcblx0fTtcblxuXHRmb3IgKCB2YXIgaSBpbiBvcHRpb25zICkge1xuXHRcdHRoaXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0aW9uc1xuXHR0aGlzLnRyYW5zbGF0ZVogPSB0aGlzLm9wdGlvbnMuSFdDb21wb3NpdGluZyAmJiB1dGlscy5oYXNQZXJzcGVjdGl2ZSA/ICcgdHJhbnNsYXRlWigwKScgOiAnJztcblxuXHR0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiA9IHV0aWxzLmhhc1RyYW5zaXRpb24gJiYgdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb247XG5cdHRoaXMub3B0aW9ucy51c2VUcmFuc2Zvcm0gPSB1dGlscy5oYXNUcmFuc2Zvcm0gJiYgdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybTtcblxuXHR0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09PSB0cnVlID8gJ3ZlcnRpY2FsJyA6IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoO1xuXHR0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgPSAhdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggJiYgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0O1xuXG5cdC8vIElmIHlvdSB3YW50IGV2ZW50UGFzc3Rocm91Z2ggSSBoYXZlIHRvIGxvY2sgb25lIG9mIHRoZSBheGVzXG5cdHRoaXMub3B0aW9ucy5zY3JvbGxZID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ3ZlcnRpY2FsJyA/IGZhbHNlIDogdGhpcy5vcHRpb25zLnNjcm9sbFk7XG5cdHRoaXMub3B0aW9ucy5zY3JvbGxYID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ2hvcml6b250YWwnID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2Nyb2xsWDtcblxuXHQvLyBXaXRoIGV2ZW50UGFzc3Rocm91Z2ggd2UgYWxzbyBuZWVkIGxvY2tEaXJlY3Rpb24gbWVjaGFuaXNtXG5cdHRoaXMub3B0aW9ucy5mcmVlU2Nyb2xsID0gdGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgJiYgIXRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoO1xuXHR0aGlzLm9wdGlvbnMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID8gMCA6IHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkO1xuXG5cdHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmcgPSB0eXBlb2YgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyA9PSAnc3RyaW5nJyA/IHV0aWxzLmVhc2VbdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZ10gfHwgdXRpbHMuZWFzZS5jaXJjdWxhciA6IHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmc7XG5cblx0dGhpcy5vcHRpb25zLnJlc2l6ZVBvbGxpbmcgPSB0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyA9PT0gdW5kZWZpbmVkID8gNjAgOiB0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZztcblxuXHRpZiAoIHRoaXMub3B0aW9ucy50YXAgPT09IHRydWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnRhcCA9ICd0YXAnO1xuXHR9XG5cblx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rU2Nyb2xsYmFycyA9PSAnc2NhbGUnICkge1xuXHRcdHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uID0gZmFsc2U7XG5cdH1cblxuXHR0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb24gPyAtMSA6IDE7XG5cblx0aWYgKCB0aGlzLm9wdGlvbnMucHJvYmVUeXBlID09IDMgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gPSBmYWxzZTtcdH1cblxuLy8gSU5TRVJUIFBPSU5UOiBOT1JNQUxJWkFUSU9OXG5cblx0Ly8gU29tZSBkZWZhdWx0c1x0XG5cdHRoaXMueCA9IDA7XG5cdHRoaXMueSA9IDA7XG5cdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cdHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4vLyBJTlNFUlQgUE9JTlQ6IERFRkFVTFRTXG5cblx0dGhpcy5faW5pdCgpO1xuXHR0aGlzLnJlZnJlc2goKTtcblxuXHR0aGlzLnNjcm9sbFRvKHRoaXMub3B0aW9ucy5zdGFydFgsIHRoaXMub3B0aW9ucy5zdGFydFkpO1xuXHR0aGlzLmVuYWJsZSgpO1xufVxuXG5JU2Nyb2xsLnByb3RvdHlwZSA9IHtcblx0dmVyc2lvbjogJzUuMS4zJyxcblxuXHRfaW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMgfHwgdGhpcy5vcHRpb25zLmluZGljYXRvcnMgKSB7XG5cdFx0XHR0aGlzLl9pbml0SW5kaWNhdG9ycygpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLm1vdXNlV2hlZWwgKSB7XG5cdFx0XHR0aGlzLl9pbml0V2hlZWwoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dGhpcy5faW5pdFNuYXAoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyApIHtcblx0XHRcdHRoaXMuX2luaXRLZXlzKCk7XG5cdFx0fVxuXG4vLyBJTlNFUlQgUE9JTlQ6IF9pbml0XG5cblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcblxuXHRcdHRoaXMuX2V4ZWNFdmVudCgnZGVzdHJveScpO1xuXHR9LFxuXG5cdF90cmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggZS50YXJnZXQgIT0gdGhpcy5zY3JvbGxlciB8fCAhdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSgpO1xuXHRcdGlmICggIXRoaXMucmVzZXRQb3NpdGlvbih0aGlzLm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gUmVhY3QgdG8gbGVmdCBtb3VzZSBidXR0b24gb25seVxuXHRcdGlmICggdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT0gMSApIHtcblx0XHRcdGlmICggZS5idXR0b24gIT09IDAgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgKHRoaXMuaW5pdGlhdGVkICYmIHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdICE9PSB0aGlzLmluaXRpYXRlZCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgJiYgIXV0aWxzLmlzQmFkQW5kcm9pZCAmJiAhdXRpbHMucHJldmVudERlZmF1bHRFeGNlcHRpb24oZS50YXJnZXQsIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbikgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvaW50ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcblx0XHRcdHBvcztcblxuXHRcdHRoaXMuaW5pdGlhdGVkXHQ9IHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdO1xuXHRcdHRoaXMubW92ZWRcdFx0PSBmYWxzZTtcblx0XHR0aGlzLmRpc3RYXHRcdD0gMDtcblx0XHR0aGlzLmRpc3RZXHRcdD0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAwO1xuXG5cdFx0dGhpcy5fdHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdHRoaXMuc3RhcnRUaW1lID0gdXRpbHMuZ2V0VGltZSgpO1xuXG5cdFx0dGhpcy5zdG9wcGVkVHJhbnNpdGlvbiA9IGZhbHNlXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiB0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0dGhpcy5zdG9wcGVkVHJhbnNpdGlvbiA9IHRydWVcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHRcdHBvcyA9IHRoaXMuZ2V0Q29tcHV0ZWRQb3NpdGlvbigpO1xuXHRcdFx0dGhpcy5fdHJhbnNsYXRlKE1hdGgucm91bmQocG9zLngpLCBNYXRoLnJvdW5kKHBvcy55KSk7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH0gZWxzZSBpZiAoICF0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiB0aGlzLmlzQW5pbWF0aW5nICkge1xuXHRcdFx0dGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0YXJ0WCAgICA9IHRoaXMueDtcblx0XHR0aGlzLnN0YXJ0WSAgICA9IHRoaXMueTtcblx0XHR0aGlzLmFic1N0YXJ0WCA9IHRoaXMueDtcblx0XHR0aGlzLmFic1N0YXJ0WSA9IHRoaXMueTtcblx0XHR0aGlzLnBvaW50WCAgICA9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMucG9pbnRZICAgID0gcG9pbnQucGFnZVk7XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ2JlZm9yZVNjcm9sbFN0YXJ0Jyk7XG5cdH0sXG5cblx0X21vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkIHx8IHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdICE9PSB0aGlzLmluaXRpYXRlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCApIHtcdC8vIGluY3JlYXNlcyBwZXJmb3JtYW5jZSBvbiBBbmRyb2lkPyBUT0RPOiBjaGVjayFcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnRcdFx0PSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0ZGVsdGFYXHRcdD0gcG9pbnQucGFnZVggLSB0aGlzLnBvaW50WCxcblx0XHRcdGRlbHRhWVx0XHQ9IHBvaW50LnBhZ2VZIC0gdGhpcy5wb2ludFksXG5cdFx0XHR0aW1lc3RhbXBcdD0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0bmV3WCwgbmV3WSxcblx0XHRcdGFic0Rpc3RYLCBhYnNEaXN0WTtcblxuXHRcdHRoaXMucG9pbnRYXHRcdD0gcG9pbnQucGFnZVg7XG5cdFx0dGhpcy5wb2ludFlcdFx0PSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuZGlzdFhcdFx0Kz0gZGVsdGFYO1xuXHRcdHRoaXMuZGlzdFlcdFx0Kz0gZGVsdGFZO1xuXHRcdGFic0Rpc3RYXHRcdD0gTWF0aC5hYnModGhpcy5kaXN0WCk7XG5cdFx0YWJzRGlzdFlcdFx0PSBNYXRoLmFicyh0aGlzLmRpc3RZKTtcblxuXHRcdC8vIFdlIG5lZWQgdG8gbW92ZSBhdCBsZWFzdCAxMCBwaXhlbHMgZm9yIHRoZSBzY3JvbGxpbmcgdG8gaW5pdGlhdGVcblx0XHRpZiAoIHRpbWVzdGFtcCAtIHRoaXMuZW5kVGltZSA+IDMwMCAmJiAoYWJzRGlzdFggPCAxMCAmJiBhYnNEaXN0WSA8IDEwKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB5b3UgYXJlIHNjcm9sbGluZyBpbiBvbmUgZGlyZWN0aW9uIGxvY2sgdGhlIG90aGVyXG5cdFx0aWYgKCAhdGhpcy5kaXJlY3Rpb25Mb2NrZWQgJiYgIXRoaXMub3B0aW9ucy5mcmVlU2Nyb2xsICkge1xuXHRcdFx0aWYgKCBhYnNEaXN0WCA+IGFic0Rpc3RZICsgdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQgKSB7XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uTG9ja2VkID0gJ2gnO1x0XHQvLyBsb2NrIGhvcml6b250YWxseVxuXHRcdFx0fSBlbHNlIGlmICggYWJzRGlzdFkgPj0gYWJzRGlzdFggKyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZCApIHtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAndic7XHRcdC8vIGxvY2sgdmVydGljYWxseVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAnbic7XHRcdC8vIG5vIGxvY2tcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZGlyZWN0aW9uTG9ja2VkID09ICdoJyApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ3ZlcnRpY2FsJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ2hvcml6b250YWwnICkge1xuXHRcdFx0XHR0aGlzLmluaXRpYXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhWSA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5kaXJlY3Rpb25Mb2NrZWQgPT0gJ3YnICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICd2ZXJ0aWNhbCcgKSB7XG5cdFx0XHRcdHRoaXMuaW5pdGlhdGVkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGFYID0gMDtcblx0XHR9XG5cblx0XHRkZWx0YVggPSB0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgPyBkZWx0YVggOiAwO1xuXHRcdGRlbHRhWSA9IHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyBkZWx0YVkgOiAwO1xuXG5cdFx0bmV3WCA9IHRoaXMueCArIGRlbHRhWDtcblx0XHRuZXdZID0gdGhpcy55ICsgZGVsdGFZO1xuXG5cdFx0Ly8gU2xvdyBkb3duIGlmIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJpZXNcblx0XHRpZiAoIG5ld1ggPiAwIHx8IG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5vcHRpb25zLmJvdW5jZSA/IHRoaXMueCArIGRlbHRhWCAvIDMgOiBuZXdYID4gMCA/IDAgOiB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXHRcdGlmICggbmV3WSA+IDAgfHwgbmV3WSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdG5ld1kgPSB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy55ICsgZGVsdGFZIC8gMyA6IG5ld1kgPiAwID8gMCA6IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHR0aGlzLmRpcmVjdGlvblggPSBkZWx0YVggPiAwID8gLTEgOiBkZWx0YVggPCAwID8gMSA6IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gZGVsdGFZID4gMCA/IC0xIDogZGVsdGFZIDwgMCA/IDEgOiAwO1xuXG5cdFx0aWYgKCAhdGhpcy5tb3ZlZCApIHtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdmVkID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3RyYW5zbGF0ZShuZXdYLCBuZXdZKTtcblxuLyogUkVQTEFDRSBTVEFSVDogX21vdmUgKi9cblx0XHRpZiAoIHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gMzAwICkge1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSB0aW1lc3RhbXA7XG5cdFx0XHR0aGlzLnN0YXJ0WCA9IHRoaXMueDtcblx0XHRcdHRoaXMuc3RhcnRZID0gdGhpcy55O1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcm9iZVR5cGUgPT0gMSApIHtcblx0XHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcm9iZVR5cGUgPiAxICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHR9XG4vKiBSRVBMQUNFIEVORDogX21vdmUgKi9cblxuXHR9LFxuXG5cdF9lbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkIHx8IHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdICE9PSB0aGlzLmluaXRpYXRlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAmJiAhdXRpbHMucHJldmVudERlZmF1bHRFeGNlcHRpb24oZS50YXJnZXQsIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbikgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvaW50ID0gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0bW9tZW50dW1YLFxuXHRcdFx0bW9tZW50dW1ZLFxuXHRcdFx0ZHVyYXRpb24gPSB1dGlscy5nZXRUaW1lKCkgLSB0aGlzLnN0YXJ0VGltZSxcblx0XHRcdG5ld1ggPSBNYXRoLnJvdW5kKHRoaXMueCksXG5cdFx0XHRuZXdZID0gTWF0aC5yb3VuZCh0aGlzLnkpLFxuXHRcdFx0ZGlzdGFuY2VYID0gTWF0aC5hYnMobmV3WCAtIHRoaXMuc3RhcnRYKSxcblx0XHRcdGRpc3RhbmNlWSA9IE1hdGguYWJzKG5ld1kgLSB0aGlzLnN0YXJ0WSksXG5cdFx0XHR0aW1lID0gMCxcblx0XHRcdGVhc2luZyA9ICcnO1xuXG5cdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IDA7XG5cdFx0dGhpcy5pbml0aWF0ZWQgPSAwO1xuXHRcdHRoaXMuZW5kVGltZSA9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdC8vIHJlc2V0IGlmIHdlIGFyZSBvdXRzaWRlIG9mIHRoZSBib3VuZGFyaWVzXG5cdFx0aWYgKCB0aGlzLnJlc2V0UG9zaXRpb24odGhpcy5vcHRpb25zLmJvdW5jZVRpbWUpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8obmV3WCwgbmV3WSk7XHQvLyBlbnN1cmVzIHRoYXQgdGhlIGxhc3QgcG9zaXRpb24gaXMgcm91bmRlZFxuXG5cdFx0Ly8gd2Ugc2Nyb2xsZWQgbGVzcyB0aGFuIDEwIHBpeGVsc1xuXHRcdGlmICggIXRoaXMubW92ZWQgKSB7XG5cdFx0XHRpZiAoICF0aGlzLnN0b3BwZWRUcmFuc2l0aW9uICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy50YXAgKSB7XG5cdFx0XHRcdFx0dXRpbHMudGFwKGUsIHRoaXMub3B0aW9ucy50YXApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuY2xpY2sgKSB7XG5cdFx0XHRcdFx0dXRpbHMuY2xpY2soZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxDYW5jZWwnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2V2ZW50cy5mbGljayAmJiBkdXJhdGlvbiA8IDIwMCAmJiBkaXN0YW5jZVggPCAxMDAgJiYgZGlzdGFuY2VZIDwgMTAwICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdmbGljaycpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHN0YXJ0IG1vbWVudHVtIGFuaW1hdGlvbiBpZiBuZWVkZWRcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb21lbnR1bSAmJiBkdXJhdGlvbiA8IDMwMCApIHtcblx0XHRcdG1vbWVudHVtWCA9IHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IHV0aWxzLm1vbWVudHVtKHRoaXMueCwgdGhpcy5zdGFydFgsIGR1cmF0aW9uLCB0aGlzLm1heFNjcm9sbFgsIHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLndyYXBwZXJXaWR0aCA6IDAsIHRoaXMub3B0aW9ucy5kZWNlbGVyYXRpb24pIDogeyBkZXN0aW5hdGlvbjogbmV3WCwgZHVyYXRpb246IDAgfTtcblx0XHRcdG1vbWVudHVtWSA9IHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB1dGlscy5tb21lbnR1bSh0aGlzLnksIHRoaXMuc3RhcnRZLCBkdXJhdGlvbiwgdGhpcy5tYXhTY3JvbGxZLCB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy53cmFwcGVySGVpZ2h0IDogMCwgdGhpcy5vcHRpb25zLmRlY2VsZXJhdGlvbikgOiB7IGRlc3RpbmF0aW9uOiBuZXdZLCBkdXJhdGlvbjogMCB9O1xuXHRcdFx0bmV3WCA9IG1vbWVudHVtWC5kZXN0aW5hdGlvbjtcblx0XHRcdG5ld1kgPSBtb21lbnR1bVkuZGVzdGluYXRpb247XG5cdFx0XHR0aW1lID0gTWF0aC5tYXgobW9tZW50dW1YLmR1cmF0aW9uLCBtb21lbnR1bVkuZHVyYXRpb24pO1xuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IDE7XG5cdFx0fVxuXG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dmFyIHNuYXAgPSB0aGlzLl9uZWFyZXN0U25hcChuZXdYLCBuZXdZKTtcblx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0dGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdYIC0gc25hcC54KSwgMTAwMCksXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdZIC0gc25hcC55KSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXHRcdFx0bmV3WCA9IHNuYXAueDtcblx0XHRcdG5ld1kgPSBzbmFwLnk7XG5cblx0XHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXHRcdFx0ZWFzaW5nID0gdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX2VuZFxuXG5cdFx0aWYgKCBuZXdYICE9IHRoaXMueCB8fCBuZXdZICE9IHRoaXMueSApIHtcblx0XHRcdC8vIGNoYW5nZSBlYXNpbmcgZnVuY3Rpb24gd2hlbiBzY3JvbGxlciBnb2VzIG91dCBvZiB0aGUgYm91bmRhcmllc1xuXHRcdFx0aWYgKCBuZXdYID4gMCB8fCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYIHx8IG5ld1kgPiAwIHx8IG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRcdGVhc2luZyA9IHV0aWxzLmVhc2UucXVhZHJhdGljO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIHRpbWUsIGVhc2luZyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG5cblx0XHR0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQucmVmcmVzaCgpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nKTtcblx0fSxcblxuXHRyZXNldFBvc2l0aW9uOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHZhciB4ID0gdGhpcy54LFxuXHRcdFx0eSA9IHRoaXMueTtcblxuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgfHwgdGhpcy54ID4gMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCB8fCB0aGlzLnkgPiAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy55IDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHRpZiAoIHggPT0gdGhpcy54ICYmIHkgPT0gdGhpcy55ICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJmID0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodDtcdFx0Ly8gRm9yY2UgcmVmbG93XG5cblx0XHR0aGlzLndyYXBwZXJXaWR0aFx0PSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cdFx0dGhpcy53cmFwcGVySGVpZ2h0XHQ9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IHJlZnJlc2ggKi9cblxuXHRcdHRoaXMuc2Nyb2xsZXJXaWR0aFx0PSB0aGlzLnNjcm9sbGVyLm9mZnNldFdpZHRoO1xuXHRcdHRoaXMuc2Nyb2xsZXJIZWlnaHRcdD0gdGhpcy5zY3JvbGxlci5vZmZzZXRIZWlnaHQ7XG5cblx0XHR0aGlzLm1heFNjcm9sbFhcdFx0PSB0aGlzLndyYXBwZXJXaWR0aCAtIHRoaXMuc2Nyb2xsZXJXaWR0aDtcblx0XHR0aGlzLm1heFNjcm9sbFlcdFx0PSB0aGlzLndyYXBwZXJIZWlnaHQgLSB0aGlzLnNjcm9sbGVySGVpZ2h0O1xuXG4vKiBSRVBMQUNFIEVORDogcmVmcmVzaCAqL1xuXG5cdFx0dGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsXHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxYICYmIHRoaXMubWF4U2Nyb2xsWCA8IDA7XG5cdFx0dGhpcy5oYXNWZXJ0aWNhbFNjcm9sbFx0XHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxZICYmIHRoaXMubWF4U2Nyb2xsWSA8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgKSB7XG5cdFx0XHR0aGlzLm1heFNjcm9sbFggPSAwO1xuXHRcdFx0dGhpcy5zY3JvbGxlcldpZHRoID0gdGhpcy53cmFwcGVyV2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHRoaXMubWF4U2Nyb2xsWSA9IDA7XG5cdFx0XHR0aGlzLnNjcm9sbGVySGVpZ2h0ID0gdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdH1cblxuXHRcdHRoaXMuZW5kVGltZSA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXG5cdFx0dGhpcy53cmFwcGVyT2Zmc2V0ID0gdXRpbHMub2Zmc2V0KHRoaXMud3JhcHBlcik7XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ3JlZnJlc2gnKTtcblxuXHRcdHRoaXMucmVzZXRQb3NpdGlvbigpO1xuXG4vLyBJTlNFUlQgUE9JTlQ6IF9yZWZyZXNoXG5cblx0fSxcblxuXHRvbjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2goZm4pO1xuXHR9LFxuXG5cdG9mZjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5pbmRleE9mKGZuKTtcblxuXHRcdGlmICggaW5kZXggPiAtMSApIHtcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSxcblxuXHRfZXhlY0V2ZW50OiBmdW5jdGlvbiAodHlwZSkge1xuXHRcdGlmICggIXRoaXMuX2V2ZW50c1t0eXBlXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsID0gdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcblxuXHRcdGlmICggIWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdW2ldLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0eCA9IHRoaXMueCArIHg7XG5cdFx0eSA9IHRoaXMueSArIHk7XG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRzY3JvbGxUbzogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB1dGlscy5lYXNlLmNpcmN1bGFyO1xuXG5cdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRpbWUgPiAwO1xuXG5cdFx0aWYgKCAhdGltZSB8fCAodGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgZWFzaW5nLnN0eWxlKSApIHtcblx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbihlYXNpbmcuc3R5bGUpO1xuXHRcdFx0dGhpcy5fdHJhbnNpdGlvblRpbWUodGltZSk7XG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FuaW1hdGUoeCwgeSwgdGltZSwgZWFzaW5nLmZuKTtcblx0XHR9XG5cdH0sXG5cblx0c2Nyb2xsVG9FbGVtZW50OiBmdW5jdGlvbiAoZWwsIHRpbWUsIG9mZnNldFgsIG9mZnNldFksIGVhc2luZykge1xuXHRcdGVsID0gZWwubm9kZVR5cGUgPyBlbCA6IHRoaXMuc2Nyb2xsZXIucXVlcnlTZWxlY3RvcihlbCk7XG5cblx0XHRpZiAoICFlbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcG9zID0gdXRpbHMub2Zmc2V0KGVsKTtcblxuXHRcdHBvcy5sZWZ0IC09IHRoaXMud3JhcHBlck9mZnNldC5sZWZ0O1xuXHRcdHBvcy50b3AgIC09IHRoaXMud3JhcHBlck9mZnNldC50b3A7XG5cblx0XHQvLyBpZiBvZmZzZXRYL1kgYXJlIHRydWUgd2UgY2VudGVyIHRoZSBlbGVtZW50IHRvIHRoZSBzY3JlZW5cblx0XHRpZiAoIG9mZnNldFggPT09IHRydWUgKSB7XG5cdFx0XHRvZmZzZXRYID0gTWF0aC5yb3VuZChlbC5vZmZzZXRXaWR0aCAvIDIgLSB0aGlzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyKTtcblx0XHR9XG5cdFx0aWYgKCBvZmZzZXRZID09PSB0cnVlICkge1xuXHRcdFx0b2Zmc2V0WSA9IE1hdGgucm91bmQoZWwub2Zmc2V0SGVpZ2h0IC8gMiAtIHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRwb3MubGVmdCAtPSBvZmZzZXRYIHx8IDA7XG5cdFx0cG9zLnRvcCAgLT0gb2Zmc2V0WSB8fCAwO1xuXG5cdFx0cG9zLmxlZnQgPSBwb3MubGVmdCA+IDAgPyAwIDogcG9zLmxlZnQgPCB0aGlzLm1heFNjcm9sbFggPyB0aGlzLm1heFNjcm9sbFggOiBwb3MubGVmdDtcblx0XHRwb3MudG9wICA9IHBvcy50b3AgID4gMCA/IDAgOiBwb3MudG9wICA8IHRoaXMubWF4U2Nyb2xsWSA/IHRoaXMubWF4U2Nyb2xsWSA6IHBvcy50b3A7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkIHx8IHRpbWUgPT09IG51bGwgfHwgdGltZSA9PT0gJ2F1dG8nID8gTWF0aC5tYXgoTWF0aC5hYnModGhpcy54LXBvcy5sZWZ0KSwgTWF0aC5hYnModGhpcy55LXBvcy50b3ApKSA6IHRpbWU7XG5cblx0XHR0aGlzLnNjcm9sbFRvKHBvcy5sZWZ0LCBwb3MudG9wLCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXG5cdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSB0aW1lICsgJ21zJztcblxuXHRcdGlmICggIXRpbWUgJiYgdXRpbHMuaXNCYWRBbmRyb2lkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSAnMC4wMDFzJztcblx0XHR9XG5cblxuXHRcdGlmICggdGhpcy5pbmRpY2F0b3JzICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udHJhbnNpdGlvblRpbWUodGltZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cbi8vIElOU0VSVCBQT0lOVDogX3RyYW5zaXRpb25UaW1lXG5cblx0fSxcblxuXHRfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbl0gPSBlYXNpbmc7XG5cblxuXHRcdGlmICggdGhpcy5pbmRpY2F0b3JzICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKGVhc2luZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cbi8vIElOU0VSVCBQT0lOVDogX3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvblxuXG5cdH0sXG5cblx0X3RyYW5zbGF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy51c2VUcmFuc2Zvcm0gKSB7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IF90cmFuc2xhdGUgKi9cblxuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0gPSAndHJhbnNsYXRlKCcgKyB4ICsgJ3B4LCcgKyB5ICsgJ3B4KScgKyB0aGlzLnRyYW5zbGF0ZVo7XG5cbi8qIFJFUExBQ0UgRU5EOiBfdHJhbnNsYXRlICovXG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IE1hdGgucm91bmQoeCk7XG5cdFx0XHR5ID0gTWF0aC5yb3VuZCh5KTtcblx0XHRcdHRoaXMuc2Nyb2xsZXJTdHlsZS5sZWZ0ID0geCArICdweCc7XG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGUudG9wID0geSArICdweCc7XG5cdFx0fVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cblx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JzW2ldLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0fVxuXHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNsYXRlXG5cblx0fSxcblxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdHZhciBldmVudFR5cGUgPSByZW1vdmUgPyB1dGlscy5yZW1vdmVFdmVudCA6IHV0aWxzLmFkZEV2ZW50LFxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5vcHRpb25zLmJpbmRUb1dyYXBwZXIgPyB0aGlzLndyYXBwZXIgOiB3aW5kb3c7XG5cblx0XHRldmVudFR5cGUod2luZG93LCAnb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzKTtcblx0XHRldmVudFR5cGUod2luZG93LCAncmVzaXplJywgdGhpcyk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5jbGljayApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICdjbGljaycsIHRoaXMsIHRydWUpO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlTW91c2UgKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCAnbW91c2Vkb3duJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAnbW91c2VjYW5jZWwnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZXVwJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCB1dGlscy5oYXNQb2ludGVyICYmICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBvaW50ZXIgKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJkb3duJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmNhbmNlbCcpLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmICggdXRpbHMuaGFzVG91Y2ggJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlVG91Y2ggKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2hlbmQnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ3RyYW5zaXRpb25lbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ29UcmFuc2l0aW9uRW5kJywgdGhpcyk7XG5cdFx0ZXZlbnRUeXBlKHRoaXMuc2Nyb2xsZXIsICdNU1RyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0fSxcblxuXHRnZXRDb21wdXRlZFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuc2Nyb2xsZXIsIG51bGwpLFxuXHRcdFx0eCwgeTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeFt1dGlscy5zdHlsZS50cmFuc2Zvcm1dLnNwbGl0KCcpJylbMF0uc3BsaXQoJywgJyk7XG5cdFx0XHR4ID0gKyhtYXRyaXhbMTJdIHx8IG1hdHJpeFs0XSk7XG5cdFx0XHR5ID0gKyhtYXRyaXhbMTNdIHx8IG1hdHJpeFs1XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSArbWF0cml4LmxlZnQucmVwbGFjZSgvW14tXFxkLl0vZywgJycpO1xuXHRcdFx0eSA9ICttYXRyaXgudG9wLnJlcGxhY2UoL1teLVxcZC5dL2csICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyB4OiB4LCB5OiB5IH07XG5cdH0sXG5cblx0X2luaXRJbmRpY2F0b3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGludGVyYWN0aXZlID0gdGhpcy5vcHRpb25zLmludGVyYWN0aXZlU2Nyb2xsYmFycyxcblx0XHRcdGN1c3RvbVN0eWxlID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICE9ICdzdHJpbmcnLFxuXHRcdFx0aW5kaWNhdG9ycyA9IFtdLFxuXHRcdFx0aW5kaWNhdG9yO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5pbmRpY2F0b3JzID0gW107XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICkge1xuXHRcdFx0Ly8gVmVydGljYWwgc2Nyb2xsYmFyXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxZICkge1xuXHRcdFx0XHRpbmRpY2F0b3IgPSB7XG5cdFx0XHRcdFx0ZWw6IGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIoJ3YnLCBpbnRlcmFjdGl2ZSwgdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMpLFxuXHRcdFx0XHRcdGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZSxcblx0XHRcdFx0XHRkZWZhdWx0U2Nyb2xsYmFyczogdHJ1ZSxcblx0XHRcdFx0XHRjdXN0b21TdHlsZTogY3VzdG9tU3R5bGUsXG5cdFx0XHRcdFx0cmVzaXplOiB0aGlzLm9wdGlvbnMucmVzaXplU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRzaHJpbms6IHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGZhZGU6IHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRsaXN0ZW5YOiBmYWxzZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IuZWwpO1xuXHRcdFx0XHRpbmRpY2F0b3JzLnB1c2goaW5kaWNhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9yaXpvbnRhbCBzY3JvbGxiYXJcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbFggKSB7XG5cdFx0XHRcdGluZGljYXRvciA9IHtcblx0XHRcdFx0XHRlbDogY3JlYXRlRGVmYXVsdFNjcm9sbGJhcignaCcsIGludGVyYWN0aXZlLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyksXG5cdFx0XHRcdFx0aW50ZXJhY3RpdmU6IGludGVyYWN0aXZlLFxuXHRcdFx0XHRcdGRlZmF1bHRTY3JvbGxiYXJzOiB0cnVlLFxuXHRcdFx0XHRcdGN1c3RvbVN0eWxlOiBjdXN0b21TdHlsZSxcblx0XHRcdFx0XHRyZXNpemU6IHRoaXMub3B0aW9ucy5yZXNpemVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdHNocmluazogdGhpcy5vcHRpb25zLnNocmlua1Njcm9sbGJhcnMsXG5cdFx0XHRcdFx0ZmFkZTogdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGxpc3Rlblk6IGZhbHNlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvci5lbCk7XG5cdFx0XHRcdGluZGljYXRvcnMucHVzaChpbmRpY2F0b3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmluZGljYXRvcnMgKSB7XG5cdFx0XHQvLyBUT0RPOiBjaGVjayBjb25jYXQgY29tcGF0aWJpbGl0eVxuXHRcdFx0aW5kaWNhdG9ycyA9IGluZGljYXRvcnMuY29uY2F0KHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzKTtcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IGluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JzLnB1c2goIG5ldyBJbmRpY2F0b3IodGhpcywgaW5kaWNhdG9yc1tpXSkgKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBjaGVjayBpZiB3ZSBjYW4gdXNlIGFycmF5Lm1hcCAod2lkZSBjb21wYXRpYmlsaXR5IGFuZCBwZXJmb3JtYW5jZSBpc3N1ZXMpXG5cdFx0ZnVuY3Rpb24gX2luZGljYXRvcnNNYXAgKGZuKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoYXQuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdGZuLmNhbGwodGhhdC5pbmRpY2F0b3JzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyApIHtcblx0XHRcdHRoaXMub24oJ3Njcm9sbEVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLm9uKCdzY3JvbGxDYW5jZWwnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbignc2Nyb2xsU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMub24oJ2JlZm9yZVNjcm9sbFN0YXJ0JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKDEsIHRydWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGRlbGV0ZSB0aGlzLmluZGljYXRvcnM7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRXaGVlbDogZnVuY3Rpb24gKCkge1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ3doZWVsJywgdGhpcyk7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnbW91c2V3aGVlbCcsIHRoaXMpO1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy53cmFwcGVyLCAnd2hlZWwnLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMud3JhcHBlciwgJ21vdXNld2hlZWwnLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMud3JhcHBlciwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X3doZWVsOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHZhciB3aGVlbERlbHRhWCwgd2hlZWxEZWx0YVksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHRpZiAoIHRoaXMud2hlZWxUaW1lb3V0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGF0Ll9leGVjRXZlbnQoJ3Njcm9sbFN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gRXhlY3V0ZSB0aGUgc2Nyb2xsRW5kIGV2ZW50IGFmdGVyIDQwMG1zIHRoZSB3aGVlbCBzdG9wcGVkIHNjcm9sbGluZ1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLndoZWVsVGltZW91dCk7XG5cdFx0dGhpcy53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0XHR0aGF0LndoZWVsVGltZW91dCA9IHVuZGVmaW5lZDtcblx0XHR9LCA0MDApO1xuXG5cdFx0aWYgKCAnZGVsdGFYJyBpbiBlICkge1xuXHRcdFx0aWYgKGUuZGVsdGFNb2RlID09PSAxKSB7XG5cdFx0XHRcdHdoZWVsRGVsdGFYID0gLWUuZGVsdGFYICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHRcdFx0d2hlZWxEZWx0YVkgPSAtZS5kZWx0YVkgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hlZWxEZWx0YVggPSAtZS5kZWx0YVg7XG5cdFx0XHRcdHdoZWVsRGVsdGFZID0gLWUuZGVsdGFZO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhWCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gZS53aGVlbERlbHRhWCAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0XHR3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YVkgLyAxMjAgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YSAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0fSBlbHNlIGlmICggJ2RldGFpbCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gd2hlZWxEZWx0YVkgPSAtZS5kZXRhaWwgLyAzICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHdoZWVsRGVsdGFYICo9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbjtcblx0XHR3aGVlbERlbHRhWSAqPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb247XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWTtcblx0XHRcdHdoZWVsRGVsdGFZID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0bmV3WCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVg7XG5cdFx0XHRuZXdZID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdFx0aWYgKCB3aGVlbERlbHRhWCA+IDAgKSB7XG5cdFx0XHRcdG5ld1gtLTtcblx0XHRcdH0gZWxzZSBpZiAoIHdoZWVsRGVsdGFYIDwgMCApIHtcblx0XHRcdFx0bmV3WCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdoZWVsRGVsdGFZID4gMCApIHtcblx0XHRcdFx0bmV3WS0tO1xuXHRcdFx0fSBlbHNlIGlmICggd2hlZWxEZWx0YVkgPCAwICkge1xuXHRcdFx0XHRuZXdZKys7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRuZXdYID0gdGhpcy54ICsgTWF0aC5yb3VuZCh0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgPyB3aGVlbERlbHRhWCA6IDApO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBNYXRoLnJvdW5kKHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB3aGVlbERlbHRhWSA6IDApO1xuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJvYmVUeXBlID4gMSApIHtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsJyk7XG5cdFx0fVxuXG4vLyBJTlNFUlQgUE9JTlQ6IF93aGVlbFxuXHR9LFxuXG5cdF9pbml0U25hcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY3VycmVudFBhZ2UgPSB7fTtcblxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5zbmFwID09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnNuYXAgPSB0aGlzLnNjcm9sbGVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNuYXApO1xuXHRcdH1cblxuXHRcdHRoaXMub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSA9IDAsIGwsXG5cdFx0XHRcdG0gPSAwLCBuLFxuXHRcdFx0XHRjeCwgY3ksXG5cdFx0XHRcdHggPSAwLCB5LFxuXHRcdFx0XHRzdGVwWCA9IHRoaXMub3B0aW9ucy5zbmFwU3RlcFggfHwgdGhpcy53cmFwcGVyV2lkdGgsXG5cdFx0XHRcdHN0ZXBZID0gdGhpcy5vcHRpb25zLnNuYXBTdGVwWSB8fCB0aGlzLndyYXBwZXJIZWlnaHQsXG5cdFx0XHRcdGVsO1xuXG5cdFx0XHR0aGlzLnBhZ2VzID0gW107XG5cblx0XHRcdGlmICggIXRoaXMud3JhcHBlcldpZHRoIHx8ICF0aGlzLndyYXBwZXJIZWlnaHQgfHwgIXRoaXMuc2Nyb2xsZXJXaWR0aCB8fCAhdGhpcy5zY3JvbGxlckhlaWdodCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwID09PSB0cnVlICkge1xuXHRcdFx0XHRjeCA9IE1hdGgucm91bmQoIHN0ZXBYIC8gMiApO1xuXHRcdFx0XHRjeSA9IE1hdGgucm91bmQoIHN0ZXBZIC8gMiApO1xuXG5cdFx0XHRcdHdoaWxlICggeCA+IC10aGlzLnNjcm9sbGVyV2lkdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5wYWdlc1tpXSA9IFtdO1xuXHRcdFx0XHRcdGwgPSAwO1xuXHRcdFx0XHRcdHkgPSAwO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCB5ID4gLXRoaXMuc2Nyb2xsZXJIZWlnaHQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBhZ2VzW2ldW2xdID0ge1xuXHRcdFx0XHRcdFx0XHR4OiBNYXRoLm1heCh4LCB0aGlzLm1heFNjcm9sbFgpLFxuXHRcdFx0XHRcdFx0XHR5OiBNYXRoLm1heCh5LCB0aGlzLm1heFNjcm9sbFkpLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogc3RlcFgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogc3RlcFksXG5cdFx0XHRcdFx0XHRcdGN4OiB4IC0gY3gsXG5cdFx0XHRcdFx0XHRcdGN5OiB5IC0gY3lcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHkgLT0gc3RlcFk7XG5cdFx0XHRcdFx0XHRsKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eCAtPSBzdGVwWDtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsID0gdGhpcy5vcHRpb25zLnNuYXA7XG5cdFx0XHRcdGwgPSBlbC5sZW5ndGg7XG5cdFx0XHRcdG4gPSAtMTtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBpID09PSAwIHx8IGVsW2ldLm9mZnNldExlZnQgPD0gZWxbaS0xXS5vZmZzZXRMZWZ0ICkge1xuXHRcdFx0XHRcdFx0bSA9IDA7XG5cdFx0XHRcdFx0XHRuKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5wYWdlc1ttXSApIHtcblx0XHRcdFx0XHRcdHRoaXMucGFnZXNbbV0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR4ID0gTWF0aC5tYXgoLWVsW2ldLm9mZnNldExlZnQsIHRoaXMubWF4U2Nyb2xsWCk7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWF4KC1lbFtpXS5vZmZzZXRUb3AsIHRoaXMubWF4U2Nyb2xsWSk7XG5cdFx0XHRcdFx0Y3ggPSB4IC0gTWF0aC5yb3VuZChlbFtpXS5vZmZzZXRXaWR0aCAvIDIpO1xuXHRcdFx0XHRcdGN5ID0geSAtIE1hdGgucm91bmQoZWxbaV0ub2Zmc2V0SGVpZ2h0IC8gMik7XG5cblx0XHRcdFx0XHR0aGlzLnBhZ2VzW21dW25dID0ge1xuXHRcdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0XHR3aWR0aDogZWxbaV0ub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGVsW2ldLm9mZnNldEhlaWdodCxcblx0XHRcdFx0XHRcdGN4OiBjeCxcblx0XHRcdFx0XHRcdGN5OiBjeVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIHggPiB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRcdFx0XHRtKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UodGhpcy5jdXJyZW50UGFnZS5wYWdlWCB8fCAwLCB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZIHx8IDAsIDApO1xuXG5cdFx0XHQvLyBVcGRhdGUgc25hcCB0aHJlc2hvbGQgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkICUgMSA9PT0gMCApIHtcblx0XHRcdFx0dGhpcy5zbmFwVGhyZXNob2xkWCA9IHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRYID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLndpZHRoICogdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQpO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLmhlaWdodCAqIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2ZsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy54IC0gdGhpcy5zdGFydFgpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMueSAtIHRoaXMuc3RhcnRZKSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXG5cdFx0XHR0aGlzLmdvVG9QYWdlKFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYICsgdGhpcy5kaXJlY3Rpb25YLFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICsgdGhpcy5kaXJlY3Rpb25ZLFxuXHRcdFx0XHR0aW1lXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9uZWFyZXN0U25hcDogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAoICF0aGlzLnBhZ2VzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHg6IDAsIHk6IDAsIHBhZ2VYOiAwLCBwYWdlWTogMCB9O1xuXHRcdH1cblxuXHRcdHZhciBpID0gMCxcblx0XHRcdGwgPSB0aGlzLnBhZ2VzLmxlbmd0aCxcblx0XHRcdG0gPSAwO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZXhjZWVkZWQgdGhlIHNuYXAgdGhyZXNob2xkXG5cdFx0aWYgKCBNYXRoLmFicyh4IC0gdGhpcy5hYnNTdGFydFgpIDwgdGhpcy5zbmFwVGhyZXNob2xkWCAmJlxuXHRcdFx0TWF0aC5hYnMoeSAtIHRoaXMuYWJzU3RhcnRZKSA8IHRoaXMuc25hcFRocmVzaG9sZFkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50UGFnZTtcblx0XHR9XG5cblx0XHRpZiAoIHggPiAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fSBlbHNlIGlmICggeCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCB5ID4gMCApIHtcblx0XHRcdHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHkgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHR5ID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggeCA+PSB0aGlzLnBhZ2VzW2ldWzBdLmN4ICkge1xuXHRcdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsID0gdGhpcy5wYWdlc1tpXS5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IG0gPCBsOyBtKysgKSB7XG5cdFx0XHRpZiAoIHkgPj0gdGhpcy5wYWdlc1swXVttXS5jeSApIHtcblx0XHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpID09IHRoaXMuY3VycmVudFBhZ2UucGFnZVggKSB7XG5cdFx0XHRpICs9IHRoaXMuZGlyZWN0aW9uWDtcblxuXHRcdFx0aWYgKCBpIDwgMCApIHtcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCBpID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0XHRpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXG5cdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdH1cblxuXHRcdGlmICggbSA9PSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICkge1xuXHRcdFx0bSArPSB0aGlzLmRpcmVjdGlvblk7XG5cblx0XHRcdGlmICggbSA8IDAgKSB7XG5cdFx0XHRcdG0gPSAwO1xuXHRcdFx0fSBlbHNlIGlmICggbSA+PSB0aGlzLnBhZ2VzWzBdLmxlbmd0aCApIHtcblx0XHRcdFx0bSA9IHRoaXMucGFnZXNbMF0ubGVuZ3RoIC0gMTtcblx0XHRcdH1cblxuXHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHksXG5cdFx0XHRwYWdlWDogaSxcblx0XHRcdHBhZ2VZOiBtXG5cdFx0fTtcblx0fSxcblxuXHRnb1RvUGFnZTogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nO1xuXG5cdFx0aWYgKCB4ID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0eCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblxuXHRcdGlmICggeSA+PSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCApIHtcblx0XHRcdHkgPSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9XG5cblx0XHR2YXIgcG9zWCA9IHRoaXMucGFnZXNbeF1beV0ueCxcblx0XHRcdHBvc1kgPSB0aGlzLnBhZ2VzW3hdW3ldLnk7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhwb3NYIC0gdGhpcy54KSwgMTAwMCksXG5cdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHBvc1kgLSB0aGlzLnkpLCAxMDAwKVxuXHRcdFx0KSwgMzAwKSA6IHRpbWU7XG5cblx0XHR0aGlzLmN1cnJlbnRQYWdlID0ge1xuXHRcdFx0eDogcG9zWCxcblx0XHRcdHk6IHBvc1ksXG5cdFx0XHRwYWdlWDogeCxcblx0XHRcdHBhZ2VZOiB5XG5cdFx0fTtcblxuXHRcdHRoaXMuc2Nyb2xsVG8ocG9zWCwgcG9zWSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRuZXh0OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4Kys7XG5cblx0XHRpZiAoIHggPj0gdGhpcy5wYWdlcy5sZW5ndGggJiYgdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eSsrO1xuXHRcdH1cblxuXHRcdHRoaXMuZ29Ub1BhZ2UoeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRwcmV2OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4LS07XG5cblx0XHRpZiAoIHggPCAwICYmIHRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHRcdHktLTtcblx0XHR9XG5cblx0XHR0aGlzLmdvVG9QYWdlKHgsIHksIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0X2luaXRLZXlzOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRlZmF1bHQga2V5IGJpbmRpbmdzXG5cdFx0dmFyIGtleXMgPSB7XG5cdFx0XHRwYWdlVXA6IDMzLFxuXHRcdFx0cGFnZURvd246IDM0LFxuXHRcdFx0ZW5kOiAzNSxcblx0XHRcdGhvbWU6IDM2LFxuXHRcdFx0bGVmdDogMzcsXG5cdFx0XHR1cDogMzgsXG5cdFx0XHRyaWdodDogMzksXG5cdFx0XHRkb3duOiA0MFxuXHRcdH07XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBpZiB5b3UgZ2l2ZSBtZSBjaGFyYWN0ZXJzIEkgZ2l2ZSB5b3Uga2V5Y29kZVxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyA9PSAnb2JqZWN0JyApIHtcblx0XHRcdGZvciAoIGkgaW4gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldID0gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgPSB7fTtcblx0XHR9XG5cblx0XHRmb3IgKCBpIGluIGtleXMgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gfHwga2V5c1tpXTtcblx0XHR9XG5cblx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICdrZXlkb3duJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAna2V5ZG93bicsIHRoaXMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9rZXk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAsXHQvLyB3ZSBhcmUgdXNpbmcgdGhpcyBhbG90LCBiZXR0ZXIgdG8gY2FjaGUgaXRcblx0XHRcdG5ld1ggPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCA6IHRoaXMueCxcblx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWSA6IHRoaXMueSxcblx0XHRcdG5vdyA9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdHByZXZUaW1lID0gdGhpcy5rZXlUaW1lIHx8IDAsXG5cdFx0XHRhY2NlbGVyYXRpb24gPSAwLjI1MCxcblx0XHRcdHBvcztcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHBvcyA9IHRoaXMuZ2V0Q29tcHV0ZWRQb3NpdGlvbigpO1xuXG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoTWF0aC5yb3VuZChwb3MueCksIE1hdGgucm91bmQocG9zLnkpKTtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IG5vdyAtIHByZXZUaW1lIDwgMjAwID8gTWF0aC5taW4odGhpcy5rZXlBY2NlbGVyYXRpb24gKyBhY2NlbGVyYXRpb24sIDUwKSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBlLmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5wYWdlVXA6XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggKz0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZICs9IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucGFnZURvd246XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggLT0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZIC09IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MuZW5kOlxuXHRcdFx0XHRuZXdYID0gc25hcCA/IHRoaXMucGFnZXMubGVuZ3RoLTEgOiB0aGlzLm1heFNjcm9sbFg7XG5cdFx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5wYWdlc1swXS5sZW5ndGgtMSA6IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5ob21lOlxuXHRcdFx0XHRuZXdYID0gMDtcblx0XHRcdFx0bmV3WSA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MubGVmdDpcblx0XHRcdFx0bmV3WCArPSBzbmFwID8gLTEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MudXA6XG5cdFx0XHRcdG5ld1kgKz0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucmlnaHQ6XG5cdFx0XHRcdG5ld1ggLT0gc25hcCA/IC0xIDogNSArIHRoaXMua2V5QWNjZWxlcmF0aW9uPj4wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmRvd246XG5cdFx0XHRcdG5ld1kgLT0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggc25hcCApIHtcblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG5cdFx0dGhpcy5rZXlUaW1lID0gbm93O1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoZGVzdFgsIGRlc3RZLCBkdXJhdGlvbiwgZWFzaW5nRm4pIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdGFydFggPSB0aGlzLngsXG5cdFx0XHRzdGFydFkgPSB0aGlzLnksXG5cdFx0XHRzdGFydFRpbWUgPSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRkZXN0VGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuXG5cdFx0ZnVuY3Rpb24gc3RlcCAoKSB7XG5cdFx0XHR2YXIgbm93ID0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0XHRlYXNpbmc7XG5cblx0XHRcdGlmICggbm93ID49IGRlc3RUaW1lICkge1xuXHRcdFx0XHR0aGF0LmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQuX3RyYW5zbGF0ZShkZXN0WCwgZGVzdFkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCAhdGhhdC5yZXNldFBvc2l0aW9uKHRoYXQub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdFx0XHR0aGF0Ll9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRub3cgPSAoIG5vdyAtIHN0YXJ0VGltZSApIC8gZHVyYXRpb247XG5cdFx0XHRlYXNpbmcgPSBlYXNpbmdGbihub3cpO1xuXHRcdFx0bmV3WCA9ICggZGVzdFggLSBzdGFydFggKSAqIGVhc2luZyArIHN0YXJ0WDtcblx0XHRcdG5ld1kgPSAoIGRlc3RZIC0gc3RhcnRZICkgKiBlYXNpbmcgKyBzdGFydFk7XG5cdFx0XHR0aGF0Ll90cmFuc2xhdGUobmV3WCwgbmV3WSk7XG5cblx0XHRcdGlmICggdGhhdC5pc0FuaW1hdGluZyApIHtcblx0XHRcdFx0ckFGKHN0ZXApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoYXQub3B0aW9ucy5wcm9iZVR5cGUgPT0gMyApIHtcblx0XHRcdFx0dGhhdC5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRzdGVwKCk7XG5cdH0sXG5cblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0c3dpdGNoICggZS50eXBlICkge1xuXHRcdFx0Y2FzZSAndG91Y2hzdGFydCc6XG5cdFx0XHRjYXNlICdwb2ludGVyZG93bic6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJEb3duJzpcblx0XHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHRcdHRoaXMuX3N0YXJ0KGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNobW92ZSc6XG5cdFx0XHRjYXNlICdwb2ludGVybW92ZSc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJNb3ZlJzpcblx0XHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHRcdHRoaXMuX21vdmUoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndG91Y2hlbmQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcnVwJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlclVwJzpcblx0XHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0Y2FzZSAndG91Y2hjYW5jZWwnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmNhbmNlbCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJDYW5jZWwnOlxuXHRcdFx0Y2FzZSAnbW91c2VjYW5jZWwnOlxuXHRcdFx0XHR0aGlzLl9lbmQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnb3JpZW50YXRpb25jaGFuZ2UnOlxuXHRcdFx0Y2FzZSAncmVzaXplJzpcblx0XHRcdFx0dGhpcy5fcmVzaXplKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndHJhbnNpdGlvbmVuZCc6XG5cdFx0XHRjYXNlICd3ZWJraXRUcmFuc2l0aW9uRW5kJzpcblx0XHRcdGNhc2UgJ29UcmFuc2l0aW9uRW5kJzpcblx0XHRcdGNhc2UgJ01TVHJhbnNpdGlvbkVuZCc6XG5cdFx0XHRcdHRoaXMuX3RyYW5zaXRpb25FbmQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnd2hlZWwnOlxuXHRcdFx0Y2FzZSAnRE9NTW91c2VTY3JvbGwnOlxuXHRcdFx0Y2FzZSAnbW91c2V3aGVlbCc6XG5cdFx0XHRcdHRoaXMuX3doZWVsKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2tleWRvd24nOlxuXHRcdFx0XHR0aGlzLl9rZXkoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnY2xpY2snOlxuXHRcdFx0XHRpZiAoICFlLl9jb25zdHJ1Y3RlZCApIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0U2Nyb2xsYmFyIChkaXJlY3Rpb24sIGludGVyYWN0aXZlLCB0eXBlKSB7XG5cdHZhciBzY3JvbGxiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHRpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuXHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5Jztcblx0XHRpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9ICctd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDAuNSk7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuOSk7Ym9yZGVyLXJhZGl1czozcHgnO1xuXHR9XG5cblx0aW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdpU2Nyb2xsSW5kaWNhdG9yJztcblxuXHRpZiAoIGRpcmVjdGlvbiA9PSAnaCcgKSB7XG5cdFx0aWYgKCB0eXBlID09PSB0cnVlICkge1xuXHRcdFx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgKz0gJztoZWlnaHQ6N3B4O2xlZnQ6MnB4O3JpZ2h0OjJweDtib3R0b206MCc7XG5cdFx0XHRpbmRpY2F0b3Iuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHRcdH1cblx0XHRzY3JvbGxiYXIuY2xhc3NOYW1lID0gJ2lTY3JvbGxIb3Jpem9udGFsU2Nyb2xsYmFyJztcblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO3dpZHRoOjdweDtib3R0b206MnB4O3RvcDoycHg7cmlnaHQ6MXB4Jztcblx0XHRcdGluZGljYXRvci5zdHlsZS53aWR0aCA9ICcxMDAlJztcblx0XHR9XG5cdFx0c2Nyb2xsYmFyLmNsYXNzTmFtZSA9ICdpU2Nyb2xsVmVydGljYWxTY3JvbGxiYXInO1xuXHR9XG5cblx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgKz0gJztvdmVyZmxvdzpoaWRkZW4nO1xuXG5cdGlmICggIWludGVyYWN0aXZlICkge1xuXHRcdHNjcm9sbGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXHR9XG5cblx0c2Nyb2xsYmFyLmFwcGVuZENoaWxkKGluZGljYXRvcik7XG5cblx0cmV0dXJuIHNjcm9sbGJhcjtcbn1cblxuZnVuY3Rpb24gSW5kaWNhdG9yIChzY3JvbGxlciwgb3B0aW9ucykge1xuXHR0aGlzLndyYXBwZXIgPSB0eXBlb2Ygb3B0aW9ucy5lbCA9PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5lbCkgOiBvcHRpb25zLmVsO1xuXHR0aGlzLndyYXBwZXJTdHlsZSA9IHRoaXMud3JhcHBlci5zdHlsZTtcblx0dGhpcy5pbmRpY2F0b3IgPSB0aGlzLndyYXBwZXIuY2hpbGRyZW5bMF07XG5cdHRoaXMuaW5kaWNhdG9yU3R5bGUgPSB0aGlzLmluZGljYXRvci5zdHlsZTtcblx0dGhpcy5zY3JvbGxlciA9IHNjcm9sbGVyO1xuXG5cdHRoaXMub3B0aW9ucyA9IHtcblx0XHRsaXN0ZW5YOiB0cnVlLFxuXHRcdGxpc3Rlblk6IHRydWUsXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXHRcdHJlc2l6ZTogdHJ1ZSxcblx0XHRkZWZhdWx0U2Nyb2xsYmFyczogZmFsc2UsXG5cdFx0c2hyaW5rOiBmYWxzZSxcblx0XHRmYWRlOiBmYWxzZSxcblx0XHRzcGVlZFJhdGlvWDogMCxcblx0XHRzcGVlZFJhdGlvWTogMFxuXHR9O1xuXG5cdGZvciAoIHZhciBpIGluIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0fVxuXG5cdHRoaXMuc2l6ZVJhdGlvWCA9IDE7XG5cdHRoaXMuc2l6ZVJhdGlvWSA9IDE7XG5cdHRoaXMubWF4UG9zWCA9IDA7XG5cdHRoaXMubWF4UG9zWSA9IDA7XG5cblx0aWYgKCB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUgKSB7XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVUb3VjaCApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMuaW5kaWNhdG9yLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAndG91Y2hlbmQnLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVQb2ludGVyICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZU1vdXNlICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsICdtb3VzZWRvd24nLCB0aGlzKTtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlICkge1xuXHRcdHRoaXMud3JhcHBlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0gPSB0aGlzLnNjcm9sbGVyLnRyYW5zbGF0ZVo7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9IHV0aWxzLmlzQmFkQW5kcm9pZCA/ICcwLjAwMXMnIDogJzBtcyc7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGUub3BhY2l0eSA9ICcwJztcblx0fVxufVxuXG5JbmRpY2F0b3IucHJvdG90eXBlID0ge1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRzd2l0Y2ggKCBlLnR5cGUgKSB7XG5cdFx0XHRjYXNlICd0b3VjaHN0YXJ0Jzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJkb3duJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckRvd24nOlxuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0dGhpcy5fc3RhcnQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJtb3ZlJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlck1vdmUnOlxuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0dGhpcy5fbW92ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRjYXNlICdwb2ludGVydXAnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyVXAnOlxuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRjYXNlICd0b3VjaGNhbmNlbCc6XG5cdFx0XHRjYXNlICdwb2ludGVyY2FuY2VsJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckNhbmNlbCc6XG5cdFx0XHRjYXNlICdtb3VzZWNhbmNlbCc6XG5cdFx0XHRcdHRoaXMuX2VuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSApIHtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMuaW5kaWNhdG9yLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy5pbmRpY2F0b3IsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLmluZGljYXRvciwgJ21vdXNlZG93bicsIHRoaXMpO1xuXG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJ1cCcpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kZWZhdWx0U2Nyb2xsYmFycyApIHtcblx0XHRcdHRoaXMud3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lKCk7XG5cblx0XHR0aGlzLmluaXRpYXRlZCA9IHRydWU7XG5cdFx0dGhpcy5tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMubGFzdFBvaW50WFx0PSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLmxhc3RQb2ludFlcdD0gcG9pbnQucGFnZVk7XG5cblx0XHR0aGlzLnN0YXJ0VGltZVx0PSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVRvdWNoICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlUG9pbnRlciApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVNb3VzZSApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnYmVmb3JlU2Nyb2xsU3RhcnQnKTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0ZGVsdGFYLCBkZWx0YVksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0dGltZXN0YW1wID0gdXRpbHMuZ2V0VGltZSgpO1xuXG5cdFx0aWYgKCAhdGhpcy5tb3ZlZCApIHtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdmVkID0gdHJ1ZTtcblxuXHRcdGRlbHRhWCA9IHBvaW50LnBhZ2VYIC0gdGhpcy5sYXN0UG9pbnRYO1xuXHRcdHRoaXMubGFzdFBvaW50WCA9IHBvaW50LnBhZ2VYO1xuXG5cdFx0ZGVsdGFZID0gcG9pbnQucGFnZVkgLSB0aGlzLmxhc3RQb2ludFk7XG5cdFx0dGhpcy5sYXN0UG9pbnRZID0gcG9pbnQucGFnZVk7XG5cblx0XHRuZXdYID0gdGhpcy54ICsgZGVsdGFYO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBkZWx0YVk7XG5cblx0XHR0aGlzLl9wb3MobmV3WCwgbmV3WSk7XG5cblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5vcHRpb25zLnByb2JlVHlwZSA9PSAxICYmIHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gMzAwICkge1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSB0aW1lc3RhbXA7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbCcpO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuc2Nyb2xsZXIub3B0aW9ucy5wcm9iZVR5cGUgPiAxICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdzY3JvbGwnKTtcblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBpbmRpY2F0b3IuX21vdmVcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdF9lbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHZhciBzbmFwID0gdGhpcy5zY3JvbGxlci5fbmVhcmVzdFNuYXAodGhpcy5zY3JvbGxlci54LCB0aGlzLnNjcm9sbGVyLnkpO1xuXG5cdFx0XHR2YXIgdGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnNjcm9sbGVyLnggLSBzbmFwLngpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMuc2Nyb2xsZXIueSAtIHNuYXAueSksIDEwMDApXG5cdFx0XHRcdFx0KSwgMzAwKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNjcm9sbGVyLnggIT0gc25hcC54IHx8IHRoaXMuc2Nyb2xsZXIueSAhPSBzbmFwLnkgKSB7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWSA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHNuYXAueCwgc25hcC55LCB0aW1lLCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuYm91bmNlRWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubW92ZWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblx0fSxcblxuXHR0cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXSA9IHRpbWUgKyAnbXMnO1xuXG5cdFx0aWYgKCAhdGltZSAmJiB1dGlscy5pc0JhZEFuZHJvaWQgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSAnMC4wMDFzJztcblx0XHR9XG5cdH0sXG5cblx0dHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb25dID0gZWFzaW5nO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICYmICF0aGlzLm9wdGlvbnMubGlzdGVuWSApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuZGlzcGxheSA9IHRoaXMuc2Nyb2xsZXIuaGFzSG9yaXpvbnRhbFNjcm9sbCA/ICdibG9jaycgOiAnbm9uZSc7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLmxpc3RlblkgJiYgIXRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5kaXNwbGF5ID0gdGhpcy5zY3JvbGxlci5oYXNWZXJ0aWNhbFNjcm9sbCA/ICdibG9jaycgOiAnbm9uZSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuZGlzcGxheSA9IHRoaXMuc2Nyb2xsZXIuaGFzSG9yaXpvbnRhbFNjcm9sbCB8fCB0aGlzLnNjcm9sbGVyLmhhc1ZlcnRpY2FsU2Nyb2xsID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuc2Nyb2xsZXIuaGFzSG9yaXpvbnRhbFNjcm9sbCAmJiB0aGlzLnNjcm9sbGVyLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0dXRpbHMuYWRkQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbEJvdGhTY3JvbGxiYXJzJyk7XG5cdFx0XHR1dGlscy5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsTG9uZVNjcm9sbGJhcicpO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5kZWZhdWx0U2Nyb2xsYmFycyAmJiB0aGlzLm9wdGlvbnMuY3VzdG9tU3R5bGUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLnJpZ2h0ID0gJzhweCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLmJvdHRvbSA9ICc4cHgnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHV0aWxzLnJlbW92ZUNsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxCb3RoU2Nyb2xsYmFycycpO1xuXHRcdFx0dXRpbHMuYWRkQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbExvbmVTY3JvbGxiYXInKTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjcm9sbGJhcnMgJiYgdGhpcy5vcHRpb25zLmN1c3RvbVN0eWxlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5yaWdodCA9ICcycHgnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5ib3R0b20gPSAnMnB4Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciByID0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodDtcdC8vIGZvcmNlIHJlZnJlc2hcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJXaWR0aCA9IHRoaXMud3JhcHBlci5jbGllbnRXaWR0aDtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnJlc2l6ZSApIHtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JXaWR0aCA9IE1hdGgubWF4KE1hdGgucm91bmQodGhpcy53cmFwcGVyV2lkdGggKiB0aGlzLndyYXBwZXJXaWR0aCAvICh0aGlzLnNjcm9sbGVyLnNjcm9sbGVyV2lkdGggfHwgdGhpcy53cmFwcGVyV2lkdGggfHwgMSkpLCA4KTtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMuaW5kaWNhdG9yV2lkdGggKyAncHgnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JXaWR0aCA9IHRoaXMuaW5kaWNhdG9yLmNsaWVudFdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1heFBvc1ggPSB0aGlzLndyYXBwZXJXaWR0aCAtIHRoaXMuaW5kaWNhdG9yV2lkdGg7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnY2xpcCcgKSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlYID0gLXRoaXMuaW5kaWNhdG9yV2lkdGggKyA4O1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WCA9IHRoaXMud3JhcHBlcldpZHRoIC0gODtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlYID0gMDtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVggPSB0aGlzLm1heFBvc1g7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2l6ZVJhdGlvWCA9IHRoaXMub3B0aW9ucy5zcGVlZFJhdGlvWCB8fCAodGhpcy5zY3JvbGxlci5tYXhTY3JvbGxYICYmICh0aGlzLm1heFBvc1ggLyB0aGlzLnNjcm9sbGVyLm1heFNjcm9sbFgpKTtcdFxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblkgKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJIZWlnaHQgPSB0aGlzLndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMucmVzaXplICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvckhlaWdodCA9IE1hdGgubWF4KE1hdGgucm91bmQodGhpcy53cmFwcGVySGVpZ2h0ICogdGhpcy53cmFwcGVySGVpZ2h0IC8gKHRoaXMuc2Nyb2xsZXIuc2Nyb2xsZXJIZWlnaHQgfHwgdGhpcy53cmFwcGVySGVpZ2h0IHx8IDEpKSwgOCk7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuaGVpZ2h0ID0gdGhpcy5pbmRpY2F0b3JIZWlnaHQgKyAncHgnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JIZWlnaHQgPSB0aGlzLmluZGljYXRvci5jbGllbnRIZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWSA9IHRoaXMud3JhcHBlckhlaWdodCAtIHRoaXMuaW5kaWNhdG9ySGVpZ2h0O1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ2NsaXAnICkge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WSA9IC10aGlzLmluZGljYXRvckhlaWdodCArIDg7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gODtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlZID0gMDtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVkgPSB0aGlzLm1heFBvc1k7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWSA9IHRoaXMud3JhcHBlckhlaWdodCAtIHRoaXMuaW5kaWNhdG9ySGVpZ2h0O1xuXHRcdFx0dGhpcy5zaXplUmF0aW9ZID0gdGhpcy5vcHRpb25zLnNwZWVkUmF0aW9ZIHx8ICh0aGlzLnNjcm9sbGVyLm1heFNjcm9sbFkgJiYgKHRoaXMubWF4UG9zWSAvIHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWSkpO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlUG9zaXRpb24oKTtcblx0fSxcblxuXHR1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB4ID0gdGhpcy5vcHRpb25zLmxpc3RlblggJiYgTWF0aC5yb3VuZCh0aGlzLnNpemVSYXRpb1ggKiB0aGlzLnNjcm9sbGVyLngpIHx8IDAsXG5cdFx0XHR5ID0gdGhpcy5vcHRpb25zLmxpc3RlblkgJiYgTWF0aC5yb3VuZCh0aGlzLnNpemVSYXRpb1kgKiB0aGlzLnNjcm9sbGVyLnkpIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuaWdub3JlQm91bmRhcmllcyApIHtcblx0XHRcdGlmICggeCA8IHRoaXMubWluQm91bmRhcnlYICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyApIHtcblx0XHRcdFx0XHR0aGlzLndpZHRoID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JXaWR0aCArIHgsIDgpO1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR4ID0gdGhpcy5taW5Cb3VuZGFyeVg7XG5cdFx0XHR9IGVsc2UgaWYgKCB4ID4gdGhpcy5tYXhCb3VuZGFyeVggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLmluZGljYXRvcldpZHRoIC0gKHggLSB0aGlzLm1heFBvc1gpLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG5cdFx0XHRcdFx0eCA9IHRoaXMubWF4UG9zWCArIHRoaXMuaW5kaWNhdG9yV2lkdGggLSB0aGlzLndpZHRoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHggPSB0aGlzLm1heEJvdW5kYXJ5WDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICYmIHRoaXMud2lkdGggIT0gdGhpcy5pbmRpY2F0b3JXaWR0aCApIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuaW5kaWNhdG9yV2lkdGg7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB5IDwgdGhpcy5taW5Cb3VuZGFyeVkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JIZWlnaHQgKyB5ICogMywgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0eSA9IHRoaXMubWluQm91bmRhcnlZO1xuXHRcdFx0fSBlbHNlIGlmICggeSA+IHRoaXMubWF4Qm91bmRhcnlZICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyApIHtcblx0XHRcdFx0XHR0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaW5kaWNhdG9ySGVpZ2h0IC0gKHkgLSB0aGlzLm1heFBvc1kpICogMywgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHRcdFx0eSA9IHRoaXMubWF4UG9zWSArIHRoaXMuaW5kaWNhdG9ySGVpZ2h0IC0gdGhpcy5oZWlnaHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSA9IHRoaXMubWF4Qm91bmRhcnlZO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgJiYgdGhpcy5oZWlnaHQgIT0gdGhpcy5pbmRpY2F0b3JIZWlnaHQgKSB7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyArIHRoaXMuc2Nyb2xsZXIudHJhbnNsYXRlWjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5sZWZ0ID0geCArICdweCc7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLnRvcCA9IHkgKyAncHgnO1xuXHRcdH1cblx0fSxcblxuXHRfcG9zOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggeCA8IDAgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB4ID4gdGhpcy5tYXhQb3NYICkge1xuXHRcdFx0eCA9IHRoaXMubWF4UG9zWDtcblx0XHR9XG5cblx0XHRpZiAoIHkgPCAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggeSA+IHRoaXMubWF4UG9zWSApIHtcblx0XHRcdHkgPSB0aGlzLm1heFBvc1k7XG5cdFx0fVxuXG5cdFx0eCA9IHRoaXMub3B0aW9ucy5saXN0ZW5YID8gTWF0aC5yb3VuZCh4IC8gdGhpcy5zaXplUmF0aW9YKSA6IHRoaXMuc2Nyb2xsZXIueDtcblx0XHR5ID0gdGhpcy5vcHRpb25zLmxpc3RlblkgPyBNYXRoLnJvdW5kKHkgLyB0aGlzLnNpemVSYXRpb1kpIDogdGhpcy5zY3JvbGxlci55O1xuXG5cdFx0dGhpcy5zY3JvbGxlci5zY3JvbGxUbyh4LCB5KTtcblx0fSxcblxuXHRmYWRlOiBmdW5jdGlvbiAodmFsLCBob2xkKSB7XG5cdFx0aWYgKCBob2xkICYmICF0aGlzLnZpc2libGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZmFkZVRpbWVvdXQpO1xuXHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBudWxsO1xuXG5cdFx0dmFyIHRpbWUgPSB2YWwgPyAyNTAgOiA1MDAsXG5cdFx0XHRkZWxheSA9IHZhbCA/IDAgOiAzMDA7XG5cblx0XHR2YWwgPSB2YWwgPyAnMScgOiAnMCc7XG5cblx0XHR0aGlzLndyYXBwZXJTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dID0gdGltZSArICdtcyc7XG5cblx0XHR0aGlzLmZhZGVUaW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0dGhpcy53cmFwcGVyU3R5bGUub3BhY2l0eSA9IHZhbDtcblx0XHRcdHRoaXMudmlzaWJsZSA9ICt2YWw7XG5cdFx0fSkuYmluZCh0aGlzLCB2YWwpLCBkZWxheSk7XG5cdH1cbn07XG5cbklTY3JvbGwudXRpbHMgPSB1dGlscztcblxuaWYgKCB0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IElTY3JvbGw7XG59IGVsc2Uge1xuXHR3aW5kb3cuSVNjcm9sbCA9IElTY3JvbGw7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsIE1hdGgpOyIsIm1vZHVsZS5leHBvcnRzID0gbmV3ICggcmVxdWlyZSggXCJzY2hlZHVsZXJcIiApICkoKVxuIiwibGV0IGxvZGFzaCA9IHJlcXVpcmUoIGBsb2Rhc2hgIClcbmxldCBjbyA9IHJlcXVpcmUoIGBjb2AgKVxuXG5sZXQgTk9OX1BBUlRJQUwgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcbk5PTl9QQVJUSUFMLl9fcGFydGlhbF9fID0gZmFsc2VcblxubGV0IFBBUlRJQUwgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblxuZnVuY3Rpb24gYXNzZXJ0KCB2YWx1ZSwgbWVzc2FnZSApIHtcblx0aWYgKCAhdmFsdWUgKVxuXHRcdHRocm93IG5ldyBFcnJvciggYGAgKyBtZXNzYWdlIClcbn1cblxubGV0IExpdGVyYWxQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIHt9IClcblxubGV0IGx1ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0ZHVtcFByb21pc2U6IHAgPT4gcC50aGVuKFxuXHRcdHJlc3VsdCA9PiBsdS5sb2coIGByZXN1bHQ6YCwgcmVzdWx0ICksXG5cdFx0ZXJyb3IgPT4gbHUuZXJyb3IoIGBlcnJvcjpgLCBlcnJvciApXG5cdCksXG5cblx0ZHVtcCggbXNnLCB2YWx1ZSApIHtcblx0XHRjb25zb2xlLmxvZyggbXNnLCB2YWx1ZSApXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0sXG5cblx0bG9nOiBjb25zb2xlLmxvZy5iaW5kKCBjb25zb2xlICksXG5cdGluZm86ICggY29uc29sZS5pbmZvIHx8IGNvbnNvbGUubG9nICkuYmluZCggY29uc29sZSApLFxuXHR3YXJuOiAoIGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZyApLmJpbmQoIGNvbnNvbGUgKSxcblx0ZXJyb3I6ICggY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZyApLmJpbmQoIGNvbnNvbGUgKSxcblx0dHJhY2U6ICggY29uc29sZS50cmFjZSB8fCBjb25zb2xlLmxvZyApLmJpbmQoIGNvbnNvbGUgKSxcblxuXHRtYXBPYmooIG9iaiwgcHJvcHMgKSB7XG5cdFx0bGV0IHJldCA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdC5nZXRQcm90b3R5cGVPZiggb2JqICkgKSwgb2JqIClcblx0XHRsb2Rhc2guZm9yRWFjaCggcHJvcHMsICggZnVuLCBrZXkgKSA9PiByZXRbIGtleSBdID0gdHlwZW9mIGZ1biA9PSBgZnVuY3Rpb25gID8gZnVuKCBvYmpbIGtleSBdICkgOiBmdW4gKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRyZXN0cyggbnVtLCAuLi5yZXN0cyApIHtcblx0XHRsZXQgcmV0ID0gW11cblx0XHRmb3IgKCBsZXQgciBvZiByZXN0cyApIHtcblx0XHRcdGxldCBuID0gbnVtICUgclxuXHRcdFx0bnVtID0gKCBudW0gLSBuICkgLyByXG5cdFx0XHRyZXQucHVzaCggbiApXG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRwYWQoIHMsIG4sIHAgKSB7XG5cdFx0cyA9IFN0cmluZyggcyApXG5cdFx0bGV0IHggPSBgYFxuXHRcdG4gLT0gcy5sZW5ndGhcblx0XHR3aGlsZSAoIG4gPiAwICkge1xuXHRcdFx0eCArPSBwXG5cdFx0XHQtLW5cblx0XHR9XG5cdFx0cmV0dXJuIHggKyBzXG5cdH0sXG5cblx0dGltZSgpIHtcblx0XHRsZXQgZCA9IG5ldyBEYXRlKClcblx0XHRyZXR1cm4gYCR7IGQuZ2V0SG91cnMoKSB9OiR7IGx1LnBhZCggZC5nZXRNaW51dGVzKCksIDIsIDAgKSB9OiR7IGx1LnBhZCggZC5nZXRTZWNvbmRzKCksIDIsIDAgKSB9LiR7IGx1LnBhZCggZC5nZXRNaWxsaXNlY29uZHMoKSwgMywgMCApIH1gXG5cdH0sXG5cblx0c3RhY2s6ICgpID0+ICggbmV3IEVycm9yICkuc3RhY2ssXG5cblx0b3B0aW9ucyggb3B0aW9ucywgZGVmICkge1xuXHRcdGxldCByZXQgPSB7fVxuXHRcdGZvciAoIGxldCBpIGluIGRlZiApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkZWYsIGkgKSApXG5cdFx0XHRpZiAoIG9wdGlvbnMgPT0gbnVsbCApXG5cdFx0XHRcdHJldFsgaSBdID0gZGVmWyBpIF1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgb3AgPSBvcHRpb25zWyBpIF1cblx0XHRcdFx0aWYgKCBvcCA9PSBudWxsIClcblx0XHRcdFx0XHRvcCA9IGRlZlsgaSBdXG5cdFx0XHRcdHJldFsgaSBdID0gb3Bcblx0XHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH0sXG5cblx0c3RyOiAoIG9iaiwgZGVwdGggKSA9PiB7XG5cdFx0aWYgKCBkZXB0aCA9PSBudWxsIClcblx0XHRcdGRlcHRoID0gMVxuXHRcdGlmICggIW9iaiB8fCAhZGVwdGggfHwgZGVwdGggPCAxIClcblx0XHRcdHJldHVybiBgYCArIG9ialxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKVxuXHRcdFx0cmV0dXJuICggYFsgYCArIG9iai5tYXAoIHggPT4gbHUuc3RyKCB4LCBkZXB0aCAtIDEgKSApLmpvaW4oIGAgYCApICsgYCBdYCApXG5cdFx0aWYgKCAhb2JqLmNvbnN0cnVjdG9yIHx8IG9iai5jb25zdHJ1Y3RvciA9PSBPYmplY3QgKVxuXHRcdFx0cmV0dXJuICggYHsgYCArIE9iamVjdC5rZXlzKCBvYmogKS5tYXAoIHggPT4geCArIGA9YCArIGx1LnN0ciggb2JqWyB4IF0sIGRlcHRoIC0gMSApICkuam9pbiggYCBgICkgKyBgIH1gIClcblx0XHRyZXR1cm4gU3RyaW5nKCBvYmogKVxuXHR9LFxuXG5cdHRvT25lTGluZSggb2JqICkge1xuXHRcdGxldCByZXQgPSBKU09OLnN0cmluZ2lmeSggb2JqIClcblx0XHRyZXQgKz0gXCJcXG5cIlxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRieUxpbmVzKCBjYWxsYmFjayApIHtcblx0XHRsZXQgYnVmZmVyID0gYGBcblx0XHRyZXR1cm4gY2h1bmsgPT4ge1xuXHRcdFx0YnVmZmVyICs9IFN0cmluZyggY2h1bmsgKVxuXHRcdFx0bGV0IHJldCA9IGJ1ZmZlci5zcGxpdCggYFxcbmAgKVxuXHRcdFx0YnVmZmVyID0gcmV0LnBvcCgpXG5cdFx0XHRyZXQuZm9yRWFjaCggY2FsbGJhY2sgKVxuXHRcdH1cblx0fSxcblxuXHRieUpTT04oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBieUxpbmVzKCBsaW5lID0+IGNhbGxiYWNrKCBKU09OLnBhcnNlKCBsaW5lLnRyaW0oKSApICkgKVxuXHR9LFxuXG5cdHZhbHVlT2Y6IHZhbCA9PiB2YWwgPT0gbnVsbCA/IG51bGwgOiB2YWwudmFsdWVPZiA9PSBudWxsID8gdmFsIDogdmFsLnZhbHVlT2YoKSxcblxuXHRyZXR1cm5UaGlzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzIH0sXG5cdHJldHVybk51bGw6ICgpID0+IG51bGwsXG5cdHJldHVyblRydWU6ICgpID0+IHRydWUsXG5cdHJldHVybkZhbHNlOiAoKSA9PiBmYWxzZSxcblx0cmV0dXJuWmVybzogKCkgPT4gMCxcblx0cmV0dXJuT25lOiAoKSA9PiAxLFxuXG5cdHByb21pc2VTdWNjZWVkZWQ6IFByb21pc2UucmVzb2x2ZSgpLFxuXHRwcm9taXNlTnVsbDogUHJvbWlzZS5yZXNvbHZlKCBudWxsICksXG5cdHByb21pc2VUcnVlOiBQcm9taXNlLnJlc29sdmUoIHRydWUgKSxcblx0cHJvbWlzZUZhbHNlOiBQcm9taXNlLnJlc29sdmUoIGZhbHNlICksXG5cdHByb21pc2VaZXJvOiBQcm9taXNlLnJlc29sdmUoIDAgKSxcblx0cHJvbWlzZU9uZTogUHJvbWlzZS5yZXNvbHZlKCAxICksXG5cblx0cmV0dXJuTnVsbFByb21pc2U6ICgpID0+IGx1LnByb21pc2VOdWxsLFxuXHRyZXR1cm5UcnVlUHJvbWlzZTogKCkgPT4gbHUucHJvbWlzZVRydWUsXG5cdHJldHVybkZhbHNlUHJvbWlzZTogKCkgPT4gbHUucHJvbWlzZUZhbHNlLFxuXHRyZXR1cm5aZXJvUHJvbWlzZTogKCkgPT4gbHUucHJvbWlzZVplcm8sXG5cdHJldHVybk9uZVByb21pc2U6ICgpID0+IGx1LnByb21pc2VPbmUsXG5cblx0d2hlbiggcHJvbWlzZSwgY2IgKSB7XG5cdFx0aWYgKCBwcm9taXNlICE9IG51bGwgKVxuXHRcdFx0cHJvbWlzZS50aGVuKCBjYiwgY2IgKVxuXHRcdGVsc2Vcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soIGNiIClcblx0XHRyZXR1cm4gcHJvbWlzZVxuXHR9LFxuXG5cdHdhaXRGb3IoIHRpbWVvdXQsIGludGVydmFsLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiB0aW1lb3V0ID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRpbnRlcnZhbCA9IHRpbWVvdXRcblx0XHRcdHRpbWVvdXQgPSA1MDAwXG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGludGVydmFsID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRjYWxsYmFjayA9IGludGVydmFsXG5cdFx0XHRpbnRlcnZhbCA9IDIwMFxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXHRcdFx0bGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gY2hlY2soKSB7XG5cdFx0XHRcdGxldCByZXRcblx0XHRcdFx0aWYgKCByZXQgPSBjYWxsYmFjaygpIClcblx0XHRcdFx0XHRyZXNvbHZlKCByZXQgKVxuXHRcdFx0XHRlbHNlIGlmICggRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCApXG5cdFx0XHRcdFx0cmVqZWN0KCBuZXcgRXJyb3IoIGB0aW1lb3V0YCApIClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGNoZWNrLCBpbnRlcnZhbCApXG5cdFx0XHR9LCBpbnRlcnZhbCApXG5cdFx0fSApXG5cdH0sXG5cblx0ZW1wdHk6IE9iamVjdC5mcmVlemUoIE9iamVjdC5jcmVhdGUoIG51bGwgKSApLFxuXG5cdEpTT05FcXVhbCggYSwgYiApIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoIGEgKSA9PSBKU09OLnN0cmluZ2lmeSggYiApXG5cdH0sXG5cblx0bmV3KCAuLi5kZXNjZWRlbnRzICkge1xuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKCB7fSwgLi4uZGVzY2VkZW50cyApXG5cdH0sXG5cblx0Y2FsbCggZnVuLCAuLi5hcmdzICkge1xuXHRcdHJldHVybiBmdW4oIC4uLmFyZ3MgKVxuXHR9LFxuXG5cdHJldGhyb3coIGUgKSB7IHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZSB9LCAxICkgfSxcblxuXHQvLyBvcHRpbWl6YXRpb24gLS0gdXNpbmcgdHJ5L2NhdGNoIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uXG5cdGNhdGNoKCBjYiwgcmV0ICkgeyB0cnkgeyByZXR1cm4gY2IoKSB9IGNhdGNoICggZSApIHsgcmV0dXJuIHJldCggZSApIH0gfSxcblxuXHRjYXRjaE1hcCggY2IsIG1hcFJlc3VsdCwgbWFwRXJyb3IgKSB7XG5cdFx0bGV0IHJlc3VsdFxuXHRcdHRyeSB7XG5cdFx0XHRyZXN1bHQgPSBjYigpXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gbWFwRXJyb3IoIGVycm9yIClcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFJlc3VsdCggcmVzdWx0IClcblx0fSxcblxuXHRjYXRjaENhbGwoIGNiICkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4geyBvazogdHJ1ZSwgcmVzdWx0OiBjYigpIH1cblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGVycm9yIH1cblx0XHR9XG5cdH0sXG5cblx0KnRyeSggZnVuLCBzdGFydFRpbWVUb1dhaXQgPSAxMDAsIG1heFRpbWVUb1dhaXQgPSAzMDAwLCBtdWx0aXBseSA9IDEuNSApIHtcblx0XHRsZXQgdGltZVRvV2FpdCA9IHN0YXJ0VGltZVRvV2FpdFxuXHRcdGZvciAoOzspIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiB5aWVsZCBmdW4oKVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlICkge1xuXHRcdFx0XHRsdS5yZXRocm93KCBlIClcblx0XHRcdFx0eWllbGQgY28uc2xlZXAoIHRpbWVUb1dhaXQgKVxuXHRcdFx0XHR0aW1lVG9XYWl0ID0gTWF0aC5taW4oIHRpbWVUb1dhaXQgKiBtdWx0aXBseSwgbWF4VGltZVRvV2FpdCApXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHVuaXF1ZSggdmFsdWUsIGluZGV4LCBhcnJheSApIHtcblx0XHRyZXR1cm4gaW5kZXggPT0gMCB8fCB2YWx1ZSAhPSBhcnJheVsgaW5kZXggLSAxIF1cblx0fSxcblxuXHRqb2luRGF0YSggYXJyYXkgKSB7XG5cdFx0cmV0dXJuIGFycmF5Lmxlbmd0aCA9PSAwID9cblx0XHRcdGBgXG5cdFx0OiB0eXBlb2YgYXJyYXlbIDAgXSA9PSBgc3RyaW5nYCA/XG5cdFx0XHRhcnJheS5qb2luKCBgYCApXG5cdFx0OiBCdWZmZXIuaXNCdWZmZXIoIGFycmF5WyAwIF0gKSA/XG5cdFx0XHRCdWZmZXIuY29uY2F0KCBhcnJheSApXG5cdFx0OlxuXHRcdFx0YXJyYXkuam9pbiggYGAgKVxuXHR9LFxuXG5cdG9uKCBlbWl0dGVyLCBldmVudHMgKSB7XG5cdFx0bG9kYXNoLmZvckVhY2goIGV2ZW50cywgKCBoYW5kbGVyLCBldmVudCApID0+IGVtaXR0ZXIub24oIGV2ZW50LCBoYW5kbGVyICkgKVxuXHR9LFxuXG5cdG9mZiggZW1pdHRlciwgZXZlbnRzICkge1xuXHRcdGxvZGFzaC5mb3JFYWNoKCBldmVudHMsICggaGFuZGxlciwgZXZlbnQgKSA9PiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCBldmVudCwgaGFuZGxlciApIClcblx0fSxcblxuXHQqcmVhZFN0cmVhbSggc3RyZWFtICkge1xuXHRcdHJldHVybiB5aWVsZCB7IHRoZW4oIHJlc29sdmUsIHJlamVjdCApIHtcblx0XHRcdGxldCBjb250ZW50ID0gW11cblx0XHRcdHN0cmVhbS5vbiggYGRhdGFgLCBjaHVuayA9PiBjb250ZW50LnB1c2goIGNodW5rICkgKVxuXHRcdFx0c3RyZWFtLm9uKCBgZW5kYCwgKCkgPT4gcmVzb2x2ZSggbHUuam9pbkRhdGEoIGNvbnRlbnQgKSApIClcblx0XHRcdHN0cmVhbS5vbiggYGVycm9yYCwgcmVqZWN0IClcblx0XHR9IH1cblx0fSxcblxuXHQqcmVhZEpTT04oIHN0cmVhbSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggeWllbGQgbHUucmVhZFN0cmVhbSggc3RyZWFtICkgKVxuXHR9LFxuXG5cdCpyZWFkQ2h1bmsoIHN0cmVhbSApIHtcblx0XHRyZXR1cm4geWllbGQgeyB0aGVuKCByZXNvbHZlLCByZWplY3QgKSB7XG5cdFx0XHRzdHJlYW0ub24oIGBkYXRhYCwgb25EYXRhIClcblx0XHRcdHN0cmVhbS5vbiggYGVuZGAsIG9uRW5kIClcblx0XHRcdHN0cmVhbS5vbiggYGVycm9yYCwgb25FcnJvciApXG5cdFx0XHRmdW5jdGlvbiBkb25lKCkge1xuXHRcdFx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoIGBkYXRhYCwgb25EYXRhIClcblx0XHRcdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCBgZW5kYCwgb25FbmQgKVxuXHRcdFx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoIGBlcnJvcmAsIG9uRXJyb3IgKVxuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gb25EYXRhKCBjaHVuayApIHtcblx0XHRcdFx0ZG9uZSgpXG5cdFx0XHRcdHJlc29sdmUoIGNodW5rIClcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIG9uRW5kKCkge1xuXHRcdFx0XHRkb25lKClcblx0XHRcdFx0cmVzb2x2ZSggbnVsbCApXG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBvbkVycm9yKCBlcnJvciApIHtcblx0XHRcdFx0ZG9uZSgpXG5cdFx0XHRcdHJlamVjdCggZXJyb3IgKVxuXHRcdFx0fVxuXHRcdH0gfVxuXHR9LFxuXG5cdHN0YXRpYyggZnVuICkge1xuXHRcdHJldHVybiBjby5mdW5jKCBmdW5jdGlvbiogKCByZXF1ZXN0LCByZXNwb25zZSApIHtcblx0XHRcdGxldCBoZWFkV3JpdHRlbiA9IGZhbHNlLCByZXNwb25zZUVuZGVkID0gZmFsc2Vcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGxldCBib2R5ID0geWllbGQgZnVuKClcblx0XHRcdFx0cmVzcG9uc2Uud3JpdGVIZWFkKCAyMDAsIHsgWyBgQ29udGVudC1UeXBlYCBdOiBgdGV4dC9odG1sOyBjaGFyc2V0PVVURi04YCB9IClcblx0XHRcdFx0aGVhZFdyaXR0ZW4gPSB0cnVlXG5cdFx0XHRcdGlmICggdHlwZW9mIGJvZHkgIT0gYHN0cmluZ2AgKVxuXHRcdFx0XHRcdGJvZHkgPSBSZWFjdC5yZW5kZXJDb21wb25lbnRUb1N0cmluZyggYm9keSApXG5cdFx0XHRcdHJlc3BvbnNlLmVuZCggYm9keSApXG5cdFx0XHRcdHJlc3BvbnNlRW5kZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0aWYgKCAhaGVhZFdyaXR0ZW4gKVxuXHRcdFx0XHRcdHJlc3BvbnNlLndyaXRlSGVhZCggNTAwLCB7IFsgYENvbnRlbnQtVHlwZWAgXTogYHRleHQvcGxhaW5gIH0gKVxuXHRcdFx0XHRpZiAoICFyZXNwb25zZUVuZGVkIClcblx0XHRcdFx0XHRyZXNwb25zZS5lbmQoIGA8PDwgRVJST1IgPj4+YCApXG5cdFx0XHR9XG5cdFx0fSApXG5cdH0sXG5cblx0cHJvcGVydHkoIG9iaiwgbmFtZSwgZGVmYXVsdFZhbHVlICkge1xuXHRcdGxldCBwcml2YXRlTmFtZSA9IGBfYCArIG5hbWVcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAyIClcblx0XHRcdG9ialsgcHJpdmF0ZU5hbWUgXSA9IGRlZmF1bHRWYWx1ZVxuXHRcdG9ialsgbmFtZSBdID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PSAwIClcblx0XHRcdFx0cmV0dXJuIG9ialsgcHJpdmF0ZU5hbWUgXVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG9ialsgcHJpdmF0ZU5hbWUgXSA9IHZhbHVlXG5cdFx0XHRcdHJldHVybiBvYmpcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG9ialxuXHR9LFxuXG5cdHBvbGxpbmcoIHN0cmVhbSApIHtcblx0XHRsZXQgcmV0ID0ge1xuXHRcdFx0c3RvcCgpIHtcblx0XHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0aWYgKCByZXQuX3BvbGxpbmcgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHJldC5fcG9sbGluZyApXG5cdFx0XHRcdFx0cmV0Ll9wb2xsaW5nID0gbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldCA9IG51bGxcblx0XHRcdH0sXG5cdFx0XHRfcG9sbGluZzogbnVsbCxcblx0XHRcdF90cnlUb1NlbmRDaHVuaygpIHtcblx0XHRcdFx0aWYgKCAhcmV0IClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0cmV0Ll9wb2xsaW5nID0gbnVsbFxuXHRcdFx0XHRpZiAoICFzdHJlYW0ud3JpdGUoIHJldC5fY2h1bmsgKSApXG5cdFx0XHRcdFx0c3RyZWFtLm9uY2UoIGBkcmFpbmAsIHJldC5fdHJ5VG9TZW5kQ2h1bmsgKVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBzdHJlYW0uZmx1c2ggPT0gYGZ1bmN0aW9uYCApXG5cdFx0XHRcdFx0XHRzdHJlYW0uZmx1c2goKVxuXHRcdFx0XHRcdHJldC5fcG9sbGluZyA9IHNldFRpbWVvdXQoIHJldC5fdHJ5VG9TZW5kQ2h1bmssIHJldC5faW50ZXJ2YWwgKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH1cblxuXHRcdGx1LnByb3BlcnR5KCByZXQsIGBjaHVua2AsIGBcXG5gIClcblx0XHRsdS5wcm9wZXJ0eSggcmV0LCBgaW50ZXJ2YWxgLCA2MDAwMCApXG5cblx0XHQvLyBUT0RPOiB0aGlzIGV2ZW50IG5ldmVyIGZpcmVzISB3aGF0J3MgdGhlIHNoaXQ/IGNoZWNrIGl0ISBtYXkgYmUgdGhlIHJlYXNvbiBpcyAudXNlKCByZXF1aXJlKCBgY29tcHJlc3Npb25gICkoIHsgdGhyZXNob2xkOiAwIH0gKSApP1xuXHRcdHN0cmVhbS5vbmNlKCBgZW5kYCwgcmV0LnN0b3AgKVxuXHRcdC8vIFRPRE86IHRoaXMgZXZlbnQgbmV2ZXIgZmlyZXMhIHdoYXQncyB0aGUgc2hpdD8gY2hlY2sgaXQhIG1heSBiZSB0aGUgcmVhc29uIGlzIC51c2UoIHJlcXVpcmUoIGBjb21wcmVzc2lvbmAgKSggeyB0aHJlc2hvbGQ6IDAgfSApICk/XG5cdFx0c3RyZWFtLm9uY2UoIGBjbG9zZWAsIHJldC5zdG9wIClcblx0XHQvLyBUT0RPOiB0aGlzIGV2ZW50IG5ldmVyIGZpcmVzISB3aGF0J3MgdGhlIHNoaXQ/IGNoZWNrIGl0ISBtYXkgYmUgdGhlIHJlYXNvbiBpcyAudXNlKCByZXF1aXJlKCBgY29tcHJlc3Npb25gICkoIHsgdGhyZXNob2xkOiAwIH0gKSApP1xuXHRcdHN0cmVhbS5vbmNlKCBgZXJyb3JgLCByZXQuc3RvcCApXG5cblx0XHRwcm9jZXNzLm5leHRUaWNrKCByZXQuX3RyeVRvU2VuZENodW5rIClcblxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHR0ZXN0RGlmZigpIHtcblx0XHRsZXQgcCA9IHsgYTogMSwgeDogeyB1OiA5IH0gfVxuXHRcdGxldCBxID0geyB4OiB7IGM6IDIgfSB9XG5cdFx0YXNzZXJ0KCBKU09OLnN0cmluZ2lmeSggcSApID09IEpTT04uc3RyaW5naWZ5KCBsdS5hcHBseURpZmYoIHAsIGx1Lm1ha2VEaWZmKCBwLCBxICkgKSApIClcblx0fSxcblxuXHRpc1NldDogb2JqID0+IHtcblx0XHRpZiAoIG9iaiA9PSBudWxsIClcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiggb2JqIClcblx0XHRyZXR1cm4gcHJvdG8gPT09IExpdGVyYWxQcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGxcblx0fSxcblxuXHRhcHBseURpZmYoIGRlc3QsIGRpZmYsIHBhcnRpYWwgKSB7XG5cdFx0bGV0IHJldCA9IGRlc3Rcblx0XHRsZXQgY250ID0gMFxuXG5cdFx0ZnVuY3Rpb24gY29weURlc3QoKSB7XG5cdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGZvciAoIGxldCBrZXkgaW4gZGVzdCApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBkZXN0LCBrZXkgKSApIHtcblx0XHRcdFx0bGV0IHZhbHVlID0gZGVzdFsga2V5IF1cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRyZXRbIGtleSBdID0gZGVzdFsga2V5IF1cblx0XHRcdFx0KytjbnRcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGRpZmYgJiYgZGlmZi5fX3BhcnRpYWxfXyA9PT0gZmFsc2UgKVxuXHRcdFx0cGFydGlhbCA9IGZhbHNlXG5cblx0XHRmb3IgKCBsZXQga2V5IGluIGRpZmYgKSBpZiAoIGtleSAhPSBgX19wYXJ0aWFsX19gICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggZGlmZiwga2V5ICkgKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBkaWZmWyBrZXkgXVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0Y29udGludWVcblx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gYG9iamVjdGAgKVxuXHRcdFx0XHR2YWx1ZSA9IGx1LmFwcGx5RGlmZiggcmV0ICYmIHJldFsga2V5IF0sIHZhbHVlLCBwYXJ0aWFsIClcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCApIHtcblx0XHRcdFx0aWYgKCByZXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHJldCwga2V5ICkgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXQgPT09IGRlc3QgKVxuXHRcdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRcdGRlbGV0ZSByZXRbIGtleSBdXG5cdFx0XHRcdFx0LS1jbnRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICggcmV0ID09IG51bGwgfHwgcmV0WyBrZXkgXSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXQgPT09IGRlc3QgKVxuXHRcdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRcdHJldFsga2V5IF0gPSB2YWx1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNudCA9IEluZmluaXR5XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBwYXJ0aWFsID09PSBmYWxzZSApXG5cdFx0XHRmb3IgKCBsZXQga2V5IGluIHJldCApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCByZXQsIGtleSApICkge1xuXHRcdFx0XHRpZiAoICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRpZmYsIGtleSApIHx8IGRpZmZbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXQgPT09IGRlc3QgKVxuXHRcdFx0XHRcdFx0Y29weURlc3QoKVxuXHRcdFx0XHRcdGRlbGV0ZSByZXRbIGtleSBdXG5cdFx0XHRcdFx0LS1jbnRcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y250ID0gSW5maW5pdHlcblx0XHRcdH1cblxuXHRcdGlmICggcmV0ICE9PSBkZXN0ICYmIGNudCA9PSAwIClcblx0XHRcdHJldCA9IG51bGxcblxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRtZXJnZURpZmZzKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhID09IG51bGwgKVxuXHRcdFx0YSA9IE5PTl9QQVJUSUFMXG5cdFx0aWYgKCBiID09IG51bGwgKVxuXHRcdFx0YiA9IE5PTl9QQVJUSUFMXG5cblx0XHRpZiAoIGIuX19wYXJ0aWFsX18gPT09IGZhbHNlIClcblx0XHRcdHJldHVybiBiXG5cblx0XHRsZXQgcmV0ID0gYVxuXG5cdFx0ZnVuY3Rpb24gY29weURlc3QoKSB7XG5cdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGZvciAoIGxldCBrZXkgaW4gYSApIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBhLCBrZXkgKSApIHtcblx0XHRcdFx0bGV0IHZhbHVlID0gYVsga2V5IF1cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRyZXRbIGtleSBdID0gYVsga2V5IF1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQga2V5IGluIGIgKSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggYiwga2V5ICkgKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBiWyBrZXkgXVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0Y29udGludWVcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCApXG5cdFx0XHRcdHZhbHVlID0gTk9OX1BBUlRJQUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09IGBvYmplY3RgICkge1xuXHRcdFx0XHRsZXQgciA9IHJldCA/IHJldFsga2V5IF0gOiB1bmRlZmluZWRcblx0XHRcdFx0aWYgKCByID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRcdHIgPSBQQVJUSUFMXG5cdFx0XHRcdHZhbHVlID0gbHUubWVyZ2VEaWZmcyggciwgdmFsdWUgKVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByZXQgPT0gbnVsbCB8fCByZXRbIGtleSBdICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCByZXQgPT09IGEgKVxuXHRcdFx0XHRcdGNvcHlEZXN0KClcblx0XHRcdFx0cmV0WyBrZXkgXSA9IHZhbHVlXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCByZXQgIT09IGEgJiYgdHlwZW9mIGEgIT0gYG9iamVjdGAgKVxuXHRcdFx0cmV0Ll9fcGFydGlhbF9fID0gZmFsc2VcblxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRtYWtlRGlmZiggcHJldmlvdXMsIG5leHQgKSB7XG5cdFx0aWYgKCBwcmV2aW91cyA9PT0gbmV4dCApXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0bGV0IHJldCA9IHVuZGVmaW5lZFxuXHRcdGZ1bmN0aW9uIHRvQXJyYXkoIG9iaiApIHtcblx0XHRcdGxldCByZXQgPSBbXVxuXHRcdFx0bG9kYXNoLmZvckVhY2goIG9iaiwgKCB2YWx1ZSwga2V5ICkgPT4gcmV0LnB1c2goIHsgdmFsdWUsIGtleSB9ICkgKVxuXHRcdFx0cmV0dXJuIHJldC5zb3J0KCAoIHYxLCB2MiApID0+XG5cdFx0XHRcdHYxLmtleSA8IHYyLmtleSA/IC0xIDogdjEua2V5ID4gdjIua2V5ID8gMSA6IDAgKVxuXHRcdH1cblx0XHRsZXQgcGEgPSB0b0FycmF5KCBwcmV2aW91cyApXG5cdFx0bGV0IG5hID0gdG9BcnJheSggbmV4dCApXG5cdFx0bGV0IHAgPSBwYS5wb3AoKVxuXHRcdGxldCBuID0gbmEucG9wKClcblx0XHR3aGlsZSAoIHAgfHwgbiApIHtcblx0XHRcdGlmICggIW4gfHwgcCAmJiBwLmtleSA+IG4ua2V5ICkge1xuXHRcdFx0XHRpZiAoICFyZXQgKVxuXHRcdFx0XHRcdHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHRyZXRbIHAua2V5IF0gPSBudWxsIC8vIGRlbGV0aW5nXG5cdFx0XHRcdHAgPSBwYS5wb3AoKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICFwIHx8IHAua2V5IDwgbi5rZXkgKSB7XG5cdFx0XHRcdGlmICggIXJldCApXG5cdFx0XHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdHJldFsgbi5rZXkgXSA9IG4udmFsdWVcblx0XHRcdFx0biA9IG5hLnBvcCgpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCBwLnZhbHVlICE9PSBuLnZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggbHUuaXNTZXQoIHAudmFsdWUgKSAmJiBsdS5pc1NldCggbi52YWx1ZSApICkge1xuXHRcdFx0XHRcdFx0bGV0IGRpZmYgPSBsdS5tYWtlRGlmZiggcC52YWx1ZSwgbi52YWx1ZSApXG5cdFx0XHRcdFx0XHRpZiAoIGRpZmYgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggIXJldCApXG5cdFx0XHRcdFx0XHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdFx0XHRcdHJldFsgbi5rZXkgXSA9IGRpZmZcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXQgKVxuXHRcdFx0XHRcdFx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdFx0XHRcdHJldFsgbi5rZXkgXSA9IG4udmFsdWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cCA9IHBhLnBvcCgpXG5cdFx0XHRcdG4gPSBuYS5wb3AoKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0ID8gcmV0IDogdW5kZWZpbmVkXG5cdH0sXG5cblx0Y29uY2F0U3RyaW5nOiBhcnJheSA9PiB7XG5cdFx0bGV0IHJldCA9IGBgXG5cdFx0IWZ1bmN0aW9uIHdhbGsoIGFycmF5ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgYXJyYXkgIT0gYG9iamVjdGAgKVxuXHRcdFx0XHRyZXQgKz0gYXJyYXlcblx0XHRcdGVsc2UgaWYgKCBhcnJheS5sZW5ndGggIT0gbnVsbCApXG5cdFx0XHRcdGFycmF5LmZvckVhY2goIHdhbGsgKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmb3IgKCBsZXQgcyBvZiBhcnJheSApXG5cdFx0XHRcdFx0d2FsayggcyApXG5cdFx0fSggYXJyYXkgKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRzb3J0ZWREaWZmKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdGxldCBmaSA9IGZpcnN0WyBTeW1ib2wuaXRlcmF0b3IgXSgpXG5cdFx0bGV0IHNpID0gc2Vjb25kWyBTeW1ib2wuaXRlcmF0b3IgXSgpXG5cdFx0bGV0IHJldCA9IHtcblx0XHRcdGNvbW1vbjogW10sXG5cdFx0XHRmaXJzdDogW10sXG5cdFx0XHRzZWNvbmQ6IFtdLFxuXHRcdH1cblx0XHRsZXQgZnYgPSBmaS5uZXh0KCksIHN2ID0gc2kubmV4dCgpXG5cdFx0d2hpbGUgKCAhZnYuZG9uZSB8fCAhc3YuZG9uZSApIHtcblx0XHRcdGlmICggc3YuZG9uZSB8fCBmdi52YWx1ZSA8IHN2LnZhbHVlICkge1xuXHRcdFx0XHRyZXQuZmlyc3QucHVzaCggZnYudmFsdWUgKVxuXHRcdFx0XHRmdiA9IGZpLm5leHQoKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGZ2LmRvbmUgfHwgZnYudmFsdWUgPiBzdi52YWx1ZSApIHtcblx0XHRcdFx0cmV0LnNlY29uZC5wdXNoKCBzdi52YWx1ZSApXG5cdFx0XHRcdHN2ID0gc2kubmV4dCgpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0LmNvbW1vbi5wdXNoKCBmdi52YWx1ZSApXG5cdFx0XHRcdGZ2ID0gZmkubmV4dCgpXG5cdFx0XHRcdHN2ID0gc2kubmV4dCgpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRtZWFzdXJlKCBmdW4gKSB7XG5cdFx0bGV0IG5vdyA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCBnbG9iYWwuRGF0ZVxuXHRcdGxldCB0ID0gbm93Lm5vdygpXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBmdW4oKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdHQgPSAoIG5vdy5ub3coKSAtIHQgKSAvIDEwMDBcblx0XHRcdGlmICggdCA+IDAgKSB7XG5cdFx0XHRcdGxldCBpID0gMVxuXHRcdFx0XHR3aGlsZSAoIHQgPCAxMDAwICkge1xuXHRcdFx0XHRcdGkgKj0gMTBcblx0XHRcdFx0XHR0ICo9IDEwXG5cdFx0XHRcdH1cblx0XHRcdFx0dCA9IE1hdGgucm91bmQoIHQgKSAvIGlcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKCB0IClcblx0XHR9XG5cdH0sXG5cblx0KnNraXAoIGMsIGJ1ZiApIHtcblx0XHRmb3IgKCBsZXQgYiBvZiBidWYgKSB7XG5cdFx0XHRpZiAoIGMgPiAwIClcblx0XHRcdFx0LS1jXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHlpZWxkIGJcblx0XHR9XG5cdH0sXG5cblx0KnRha2UoIGMsIGJ1ZiApIHtcblx0XHRmb3IgKCBsZXQgYiBvZiBidWYgKSB7XG5cdFx0XHRpZiAoIGMgPiAwICkge1xuXHRcdFx0XHQtLWNcblx0XHRcdFx0eWllbGQgYlxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRicmVha1xuXHRcdH1cblx0fSxcblxuXHRjb3B5KCBidWYgKSB7XG5cdFx0bGV0IHJldCA9IGx1LmFycmF5KCBidWYgKVxuXHRcdGlmICggcmV0ID09IGJ1ZiApXG5cdFx0XHRyZXQgPSBidWYuc2xpY2UoKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRhcnJheTEoIHZhbHVlICkge1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApXG5cdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gWyB2YWx1ZSBdXG5cdH0sXG5cblx0YXJyYXkoIGJ1ZiApIHtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGJ1ZiApIClcblx0XHRcdHJldHVybiBidWZcblx0XHRsZXQgcmV0ID0gW11cblx0XHRpZiAoICFidWZbIFN5bWJvbC5pdGVyYXRvciBdIClcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSApXG5cdFx0XHRcdHJldC5wdXNoKCBidWZbIGkgXSApXG5cdFx0ZWxzZVxuXHRcdFx0Zm9yICggbGV0IGIgb2YgYnVmIClcblx0XHRcdFx0cmV0LnB1c2goIGIgKVxuXHRcdHJldHVybiByZXRcblx0fSxcblxuXHRidWZmZXIoIGJ1ZiApIHtcblx0XHRpZiAoIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlciApXG5cdFx0XHRyZXR1cm4gYnVmXG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXIoIGx1LmFycmF5KCBidWYgKSApXG5cdH0sXG5cblx0dmVjdG9yKCBidWYgKSB7XG5cdFx0cmV0dXJuIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlciA/IGJ1ZiA6IGx1LmFycmF5KCBidWYgKVxuXHR9LFxuXG5cdCpjb25jYXQoIGxpc3QgKSB7XG5cdFx0Zm9yICggbGV0IGwgb2YgbGlzdCApIGZvciAoIGxldCB4IG9mIGwgKSB5aWVsZCB4XG5cdH0sXG5cblx0d29yZCggdyApIHtcblx0XHRyZXR1cm4gWyB3ICYgMHhmZiwgKCB3ID4+IDggKSAmIDB4ZmYgXVxuXHR9LFxuXG5cdGR3b3JkKCB3ICkge1xuXHRcdHJldHVybiBbIHcgJiAweGZmLCAoIHcgPj4gOCApICYgMHhmZiwgKCB3ID4+IDE2ICkgJiAweGZmLCAoIHcgPj4gMjQgKSAmIDB4ZmYgXVxuXHR9LFxuXG5cdG1ha2VXb3JkKCBsbywgaGkgKSB7XG5cdFx0cmV0dXJuICggbG8gJiAweGZmICkgKyAoIGhpICYgMHhmZiApIDw8IDhcblx0fSxcblxuXHRhcnJheUVxdWFsKCBhLCBiICkge1xuXHRcdHJldHVybiBhICYmIGIgJiYgYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSggKCBhaSwgaSApID0+IGFpID09IGJbIGkgXSApXG5cdH0sXG5cblx0Y29tcGFyZSggYSwgYiApIHtcblx0XHRpZiAoIGEgPT0gYiApXG5cdFx0XHRyZXR1cm4gMFxuXHRcdGlmICggYSA8IGIgKVxuXHRcdFx0cmV0dXJuIC0xXG5cdFx0cmV0dXJuIDFcblx0fSxcblxuXHRmb3JtYXRtcyggdmFsdWUgKSB7XG5cdFx0bGV0IHJldCA9IGBgXG5cdFx0dmFsdWUgPSBNYXRoLnJvdW5kKCB2YWx1ZSApXG5cdFx0bGV0IG1zID0gdmFsdWUgJSAxMDAwXG5cdFx0dmFsdWUgLT0gbXNcblx0XHR2YWx1ZSAvPSAxMDAwXG5cdFx0bGV0IHMgPSB2YWx1ZSAlIDYwXG5cdFx0dmFsdWUgLT0gc1xuXHRcdHZhbHVlIC89IDYwXG5cdFx0bGV0IG0gPSB2YWx1ZSAlIDYwXG5cdFx0dmFsdWUgLT0gbVxuXHRcdHZhbHVlIC89IDYwXG5cdFx0bGV0IGggPSB2YWx1ZVxuXHRcdHJldCArPSBoID8gaCA6IGBgXG5cdFx0cmV0ICs9IHJldCA/IGA6YCArIHooIG0sIDIgKSA6IG0gPyBtIDogYGBcblx0XHRyZXQgKz0gcmV0ID8gYDpgICsgeiggcywgMiApIDogc1xuXHRcdHJldCArPSBgLmAgKyB6KCBtcywgMyApXG5cdFx0cmV0dXJuIHJldFxuXHRcdGZ1bmN0aW9uIHooIHZhbHVlLCBsZW4gKSB7XG5cdFx0XHRsZXQgc3RyID0gU3RyaW5nKCB2YWx1ZSApXG5cdFx0XHRsZXQgcmV0ID0gYGBcblx0XHRcdGZvciAoIGxldCBpID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpIClcblx0XHRcdFx0cmV0ICs9IGAwYFxuXHRcdFx0cmV0ICs9IHN0clxuXHRcdFx0cmV0dXJuIHJldFxuXHRcdH1cblx0fSxcblxuXHRnZXQoIG9iaiwgLi4ucGF0aCApIHtcblx0XHRmb3IgKCBsZXQgcCBvZiBwYXRoIClcblx0XHRcdGlmICggb2JqID09IG51bGwgKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvYmogPSBvYmpbIHAgXVxuXHRcdHJldHVybiBvYmpcblx0fSxcblxuXHRsaW1pdENhbGxzKCBsaW1pdCwgcGVyaW9kLCBtZXNzYWdlICkge1xuXHRcdGxldCBjYWxscyA9IDBcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0aWYgKCBjYWxscyA+PSBsaW1pdCApXG5cdFx0XHRcdGlmICggbWVzc2FnZSApXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yLmNyZWF0ZSggbWVzc2FnZSApXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdCsrY2FsbHNcblx0XHRcdHNldFRpbWVvdXQoICgpID0+IC0tY2FsbHMsIHBlcmlvZCApXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0fSxcblxufVxuIiwiXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoIE9iamVjdC5wcm90b3R5cGUsIGBfTE9HX2AsIHsgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0Y29uc29sZS5sb2coIHRoaXMgKVxuXHRyZXR1cm4gdGhpc1xufSwgY29uZmlndXJhYmxlOiB0cnVlIH0gKVxuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT0gYGZ1bmN0aW9uYCAmJiBTeW1ib2wuaXRlcmF0b3IgKSB7XG5cdGxldCB4ID0gbnVsbFxuXHR0cnkge1xuXHRcdHggPSBldmFsLmNhbGwoIG51bGwsIGAoZnVuY3Rpb24qKCl7fSgpLmNvbnN0cnVjdG9yLnByb3RvdHlwZSlgIClcblx0fSBjYXRjaCAoIF8gKSB7fVxuXHRpZiAoIHggJiYgIXhbIFN5bWJvbC5pdGVyYXRvciBdIClcblx0XHR4WyBTeW1ib2wuaXRlcmF0b3IgXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMgfVxufVxuIiwiLypcblxuVE9ETzpcblxuKiBXYXJuaW5nIGlmIGEgbGl2ZSBwcm9wZXJ0eSBoYXMgbm90IGJlZW4gcmVhZCBkdXJpbmcgdGhlIGxpZmUgdGltZSBvZiBvYnNlcnZhYmxlIHZhbHVlIG9yIGR1cmluZyBzb21lIHBlcmlvZCBvZiB0aW1lIChlLmcuIDEtMzAgbWludXRlcykgc2luY2UgY3JlYXRpbmcgdGhhdCBvYnNlcnZhYmxlIHZhbHVlLlxuXG4qIGNoZWNrIGZvciBjaGFuZ2VzIGR1cmluZyBleGVjdXRpb24gb2YgKGZ1bmN0aW9uKikgYW5kIHJlc3RhcnQgY2FsY3VsdXMuXG5cblxuVE9ETyBCVUc6XG5sZXQgYXBwID0gcmEuY2xlYW4oIHtcblx0bW92aW5nMToge1xuXHRcdGE6IDEsXG5cdFx0YjogMixcblx0XHRjOiB7XG5cdFx0XHRkOiAzLFxuXHRcdH0sXG5cdH0sXG59XG5fYXBwLm1vdmluZzEuYVxuMVxuX2FwcC5tb3ZpbmcxLmMuZFxuM1xuX2FwcC5tb3ZpbmcxPXthOjR9XG5PYmplY3Qge2E6IDR9XG5fYXBwLm1vdmluZzEuYy5kXG4zICAgICAgICAgICAgICAgICAgICAgICA8LS0tLS0tLS0tLS0gISEhICBNVVNUIEJFIE5VTEwgISEhIVxuX2FwcC5tb3ZpbmcxLmNcbkNlbGwge19pZDogXCJqODd5cWtvcXBwdXZcIiwgX3ZhbHVlOiBudWxsLCBfZXJyb3I6IG51bGwsIF9pc1ZhbHVlRXF1YWw6IGZ1bmN0aW9uLCBfaW5pdGlhbGl6ZWQ6IHRydWXigKZ9XG5fYXBwLm1vdmluZzEuYy52YWx1ZU9mKClcbm51bGxcblxuXG4qL1xuXG5sZXQgbGF0ZXIgPSByZXF1aXJlKCBgbGF0ZXJgICkucHVzaFxubGV0IGNvID0gcmVxdWlyZSggYGNvYCApXG5sZXQgVUlEID0gcmVxdWlyZSggYHVpZGAgKVxubGV0IGxvZGFzaCA9IHJlcXVpcmUoIGBsb2Rhc2hgIClcbmxldCB7IExPRyB9ID0gcmVxdWlyZSggYExPR2AgKVxuXG5sZXQgYWN0aW9uS2V5ID0gYF9SQV9BQ1RJT05fJHsgVUlEKCkgfWBcbmxldCByYVZhbHVlID0gYF9SQV9WQUxVRV8keyBVSUQoKSB9YFxuXG4vLyBsZXQgZGVidWdMb2cgPSBmYWxzZVxuXG5sZXQgdXBkYXRlcyA9IHt9XG51cGRhdGVzLnNjaGVkdWxlZCA9IGZhbHNlXG51cGRhdGVzLnByb2NzID0gW11cbnVwZGF0ZXMuaW5kZXggPSAwXG51cGRhdGVzLm1heEluZGV4ID0gMzI3NjhcbnVwZGF0ZXMucHJvY2Vzc2luZyA9IGZhbHNlXG51cGRhdGVzLnRvdGFsVGltZSA9IDBcbnVwZGF0ZXMubWF4VGltZSA9IDBcbnVwZGF0ZXMubWF4VGltZTEgPSAwXG51cGRhdGVzLm1pblRpbWUgPSBJbmZpbml0eVxudXBkYXRlcy5ydW5Db3VudCA9IDBcbnVwZGF0ZXMucnVuQWxsQ291bnQgPSAwXG5cbmdsb2JhbC51cGRhdGVzID0gdXBkYXRlcyAvLyBkZWJ1Z2dlclxuXG5sZXQgcGVyZm9ybWFuY2UgPSBnbG9iYWwucGVyZm9ybWFuY2UgfHwgZ2xvYmFsLkRhdGVcbnVwZGF0ZXMuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG51cGRhdGVzLmxvZyA9ICgpID0+IGNvbnNvbGUubG9nKCBgOjogJHsgdXBkYXRlcy50b3RhbFRpbWUgLyAxMDAwIH0gLyAkeyAoIHBlcmZvcm1hbmNlLm5vdygpIC0gdXBkYXRlcy5zdGFydCApIC8gMTAwMCB9ICgkeyB1cGRhdGVzLm1heFRpbWUgLyAxMDAwIH0sICR7IHVwZGF0ZXMubWF4VGltZTEgLyAxMDAwIH0sICR7IHVwZGF0ZXMubWluVGltZSAvIDEwMDAgfSwgJHsgQWN0aW9uLm1heENvdW50IH0sICR7IHVwZGF0ZXMucnVuQ291bnQgfSwgJHsgdXBkYXRlcy5ydW5BbGxDb3VudCB9KWAgKVxuXG4vLyBjby5nbyggZnVuY3Rpb24qICgpIHsgLy8gZGVidWdnZXJcbi8vIFx0bGV0IHNsZWVwNTAwMCA9IGNvLnNsZWVwKCA1MDAwIClcbi8vIFx0Zm9yICg7Oykge1xuLy8gXHRcdGxldCB0b3RhbFRpbWUgPSB1cGRhdGVzLnRvdGFsVGltZVxuLy8gXHRcdHlpZWxkIHNsZWVwNTAwMFxuLy8gXHRcdGlmICggdG90YWxUaW1lICE9IHVwZGF0ZXMudG90YWxUaW1lIClcbi8vIFx0XHRcdHVwZGF0ZXMubG9nKClcbi8vIFx0fVxuLy8gfSApXG5cbnVwZGF0ZXMuY2hlY2tTY2hlZHVsZSA9ICgpID0+IHtcblx0aWYgKCAhdXBkYXRlcy5zY2hlZHVsZWQgJiYgdXBkYXRlcy5wcm9jcy5sZW5ndGggPiAwICkge1xuXHRcdHVwZGF0ZXMuc2NoZWR1bGVkID0gdHJ1ZVxuXHRcdGxhdGVyKCB1cGRhdGVzLnRpY2sgKVxuXHR9XG59XG5cbnVwZGF0ZXMudGljayA9ICgpID0+IHtcblx0dXBkYXRlcy5zY2hlZHVsZWQgPSBmYWxzZVxuXHRmb3IgKCBsZXQgX3RyeSA9IDA7IF90cnkgPCAxMDAwOyArK190cnkgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHVwZGF0ZXMucnVuQWxsKClcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHRcdGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCAoKSA9PiB7IHRocm93IGVycm9yIH0sIDEgKVxuXHRcdH1cblx0fVxuXHR1cGRhdGVzLmNoZWNrU2NoZWR1bGUoKVxufVxuXG51cGRhdGVzLnJ1bkFsbCA9ICgpID0+IHtcblx0Ly8gaWYgKCB1cGRhdGVzLnByb2Nlc3NpbmcgKVxuXHQvLyBcdHJldHVyblxuXG5cdGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cdGxldCBzdDEgPSBzdGFydFxuXHRsZXQgcnVuQ291bnQgPSB1cGRhdGVzLnJ1bkNvdW50XG5cblx0bGV0IHByb2Nlc3NpbmcgPSB1cGRhdGVzLnByb2Nlc3Npbmdcblx0dXBkYXRlcy5wcm9jZXNzaW5nID0gdHJ1ZVxuXHRsZXQgYWN0aW9uID0gY28uZ2xvYmFsWyBhY3Rpb25LZXkgXVxuXHRpZiAoIGFjdGlvbiAhPSBudWxsIClcblx0XHRjby5nbG9iYWxbIGFjdGlvbktleSBdID0gbnVsbFxuXHR0cnkge1xuXHRcdHdoaWxlICggdXBkYXRlcy5pbmRleCA8IHVwZGF0ZXMucHJvY3MubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBnbG9iYWwuQVBQX1RJTUVPVVQgJiYgZ2xvYmFsLkFQUF9USU1FT1VUIDwgRGF0ZS5ub3cgKSB7XG5cdFx0XHRcdGFsZXJ0KCBgQXBwbGljYXRpb24gaXMgcnVubmluZyB0b28gbG9uZ2AgKVxuXHRcdFx0fVxuXHRcdFx0bGV0IHByb2MgPSB1cGRhdGVzLnByb2NzWyB1cGRhdGVzLmluZGV4IF1cblx0XHRcdCsrdXBkYXRlcy5pbmRleFxuXHRcdFx0Kyt1cGRhdGVzLnJ1bkNvdW50XG5cdFx0XHRpZiAoIHVwZGF0ZXMuaW5kZXggPj0gdXBkYXRlcy5tYXhJbmRleCAmJiB1cGRhdGVzLmluZGV4ICogMyA+IHVwZGF0ZXMucHJvY3MubGVuZ3RoICkge1xuXHRcdFx0XHR1cGRhdGVzLnByb2NzLnNwbGljZSggMCwgdXBkYXRlcy5pbmRleCApXG5cdFx0XHRcdHVwZGF0ZXMuaW5kZXggPSAwXG5cdFx0XHR9XG5cdFx0XHRwcm9jKClcblx0XHRcdGxldCB0MSA9IHBlcmZvcm1hbmNlLm5vdygpXG5cdFx0XHRpZiAoIHVwZGF0ZXMubWF4VGltZTEgPCB0MSAtIHN0MSApXG5cdFx0XHRcdHVwZGF0ZXMubWF4VGltZTEgPSB0MSAtIHN0MVxuXHRcdFx0Ly8gaWYgKCB0MSAtIHN0MSA+IDEwIClcblx0XHRcdC8vIFx0Y29uc29sZS5sb2coIHQxIC0gc3QxLCBgYCArIHByb2MuJG5hbWUgKSAvLyBkZWJ1Z2dlclxuXHRcdFx0c3QxID0gdDFcblx0XHR9XG5cdFx0dXBkYXRlcy5pbmRleCA9IHVwZGF0ZXMucHJvY3MubGVuZ3RoID0gMFxuXHR9XG5cdGZpbmFsbHkge1xuXHRcdGlmICggYWN0aW9uICE9IG51bGwgKVxuXHRcdFx0Y28uZ2xvYmFsWyBhY3Rpb25LZXkgXSA9IGFjdGlvblxuXHRcdHVwZGF0ZXMucHJvY2Vzc2luZyA9IHByb2Nlc3Npbmdcblx0XHRpZiAoICFwcm9jZXNzaW5nICkge1xuXHRcdFx0bGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0XG5cdFx0XHR1cGRhdGVzLnRvdGFsVGltZSArPSB0aW1lXG5cdFx0XHRpZiAoIHVwZGF0ZXMubWF4VGltZSA8IHRpbWUgKVxuXHRcdFx0XHR1cGRhdGVzLm1heFRpbWUgPSB0aW1lXG5cdFx0XHRydW5Db3VudCA9IHVwZGF0ZXMucnVuQ291bnQgLSBydW5Db3VudFxuXHRcdFx0aWYgKCBydW5Db3VudCAgKSB7XG5cdFx0XHRcdCsrdXBkYXRlcy5ydW5BbGxDb3VudFxuXHRcdFx0XHRpZiAoIHVwZGF0ZXMubWluVGltZSA+IHRpbWUgKVxuXHRcdFx0XHRcdHVwZGF0ZXMubWluVGltZSA9IHRpbWVcblx0XHRcdH1cblx0XHRcdGlmICggdGltZSA+IDMwMCApXG5cdFx0XHRcdExPRyggYHVwZGF0ZXMgaGF2ZSBiZWVuIHJ1biBmb3IgJHsgdGltZS50b1N0cmluZygpLnJlZCB9IG1zYCApXG5cdFx0fVxuXHR9XG59XG5cbnVwZGF0ZXMubGF0ZXIgPSBwcm9jID0+IHtcblx0dXBkYXRlcy5wcm9jcy5wdXNoKCBwcm9jIClcblx0dXBkYXRlcy5jaGVja1NjaGVkdWxlKClcbn1cblxudXBkYXRlcy5sYXRlci50aGVuID0gdXBkYXRlcy5sYXRlclxuXG5sZXQgY2hlY2tOdWxsID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZVxubGV0IHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzIH1cblxubGV0IGlzTGl0ZXJhbCA9IHZhbHVlID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBgb2JqZWN0YCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PSBPYmplY3RcbmxldCBnZXRWYWx1ZSA9IHZhbHVlID0+IHZhbHVlID09IG51bGwgfHwgdmFsdWUudmFsdWVPZiA9PSBudWxsID8gdmFsdWUgOiB2YWx1ZS52YWx1ZU9mKClcblxuZnVuY3Rpb24gQWJzdHJhY3RHdWFyZCgpIHt9XG5cbmxldCBpbnZhbGlkS2V5Q2FsbCA9IGZ1bmN0aW9uICgga2V5ICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIGBhY2Nlc3MgdG8gYW4gdW5kZWNsYXJlZCBwcm9wZXJ0eSBcIiR7IHRoaXMuJG5hbWUgfS4keyBrZXkgfVwiYCApXG59XG5cbmxldCB1c2VkUHJvcHMgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcbmxldCB1c2VkUHJvcHNQcm90byA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxubGV0IGd1YXJkUHJvcCA9IGtleSA9PiB7XG5cdGlmICggIXVzZWRQcm9wc1sga2V5IF0gKSB7XG5cdFx0dXNlZFByb3BzWyBrZXkgXSA9IHRydWVcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVzZWRQcm9wc1Byb3RvLCBrZXksIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG5cdFx0fSApXG5cdH1cbn1cbkFic3RyYWN0R3VhcmQucHJvdG90eXBlID0gdXNlZFByb3BzUHJvdG9cblxuLy8g0J3QtSDQt9GA0LDQt9GD0LzQtdC70LAg0YLQvtC70LrQsNC8LCDRj9C6INCz0Y3RgtGLIFByb3h5INC/0YDQsNGG0YPQtSDRniDRj9C60LDRgdGM0YbRliDQv9GA0LDRgtCw0YLRi9C/0YMuXG4vLyDQn9Cw0LrRg9C70Ywg0YjRgtC+LCDQt9C00LDQtdGG0YbQsCwg0L/QsNCy0L7QtNC30ZbQvdGLINC90LUg0LDQtNC/0LDQstGP0LTQsNGO0YbRjCDRgdGM0L/QtdGG0YvRhNGW0LrQsNGG0YvRliAoMjAxNC4xMS4yNSlcblxuLy8gaWYgKCB0eXBlb2YgUHJveHkgPT0gXCJmdW5jdGlvblwiICkge1xuLy8gXHRBYnN0cmFjdEd1YXJkLnByb3RvdHlwZSA9IG5ldyBQcm94eSggQWJzdHJhY3RHdWFyZC5wcm90b3R5cGUsIHtcbi8vIFx0XHRnZXQ6IGZ1bmN0aW9uICggXywga2V5ICkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuLy8gXHRcdHNldDogZnVuY3Rpb24gKCBfLCBrZXkgKSB7IGludmFsaWRLZXlDYWxsLmNhbGwoIHRoaXMsIGtleSApIH0sXG4vLyBcdH0gKVxuLy8gfVxuXG5pZiAoIGdsb2JhbC5BUFBfREVCVUcgKSB7XG5cdC8vXG5cdC8vINCw0LEn0Y/RntC70LXQvdGM0L3QtSDQsNCxJ9C10LrRgtCwINC3IH43MDAtODAwINGD0LvQsNGB0YzRhtGW0LLQsNGB0YzRhtGP0Z4g0Lcg0YTRg9C90LrRhtGL0Y/QvNGWINGH0YvRgtCw0L3RjNC90Y8v0LfQsNC/0ZbRgdGDXG5cdC8vINC30LDQudC80LDQtSDRniBHb29nbGUgQ2hyb21lJ9C1INC60LDQu9GPINGC0YDQsNGG0ZbQvdGLINGB0LXQutGD0L3QtNGLLlxuXHQvLyDQn9GA0LDQstC10YDQsNC90YvRjyDRgdC/0L7RgdCw0LHRizpcblx0Ly8gLSDQtNCw0LHQsNGe0LvQtdC90YzQvdC1INC/0LAg0LDQtNC90YvQvCDQv9GA0LDQtyBPYmplY3QuZGVmaW5lUHJvcGVydHlcblx0Ly8gLSDQtNCw0LHQsNGe0LvQtdC90YzQvdC1INCz0YPRgNGC0LDQvCDQv9GA0LDQtyBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuXHQvLyAtINC60LDQvNC/0ZbQu9GP0YbRi9GPINC30YvRhdC+0LTQvdGW0LrQsCDQv9GA0LDQtyDQu9Cw0LrQsNC70YzQvdGLIGV2YWxcblx0Ly8gLSDQutCw0LzQv9GW0LvRj9GG0YvRjyDQt9GL0YXQvtC00L3RltC60LAg0L/RgNCw0Lcg0LPQu9Cw0LHQsNC70YzQvdGLIGV2YWxcblx0Ly8gLSDQutCw0LzQv9GW0LvRj9GG0YvRjyDQt9GL0YXQvtC00L3RltC60LAg0L/RgNCw0Lcg0LTQsNCx0LDRntC70LXQvdGM0L3QtSDRgtGN0LPRgyBzY3JpcHQg0Lcg0LfRi9GF0L7QtNC90ZbQutCw0Lxcblx0Ly8g0J3QtSDQv9GA0LDQstC10YDQsNC90YvRjyDRgdC/0L7RgdCw0LHRizpcblx0Ly8gLSDQtNCw0LHQsNGe0LvQtdC90YzQvdC1INGC0Y3Qs9GDIHNjcmlwdCDQtyDQv9Cw0LfQvdCw0LrQsNC5IHNyY1xuXHQvLyDQn9Cw0LvRj9C/0YjQsNC1INGB0ZbRgtGD0LDRhtGL0Y4gKNC90LDQv9Cw0LvQvtCy0YMpOlxuXHQvLyAtINGB0YLQstCw0YDRjdC90YzQvdC1INC00LvRjyDQutC+0LbQvdCw0Lkg0YPQu9Cw0YHRjNGG0ZbQstCw0YHRjNGG0ZYg0L3QvtCy0LDQs9CwINCw0LEn0LXQutGC0LAg0YHQsCDRgdGC0LDRgNGL0Lwg0LDQsSfQtdC60YLQsNC8XG5cdC8vINGDINGP0LrQsNGB0YzRhtGWINC/0YDQsNGC0LDRgtGL0L/Rgy4g0J/RgNGLINCz0Y3RgtGL0Lwg0LTQvtGB0YLRg9C/INC00LAg0L3QtdCw0LEn0Y/RntC70LXQvdGL0YUg0YPQu9Cw0YHRjNGG0ZbQstCw0YHRjNGG0Y/RniDQvNC+0LbQsFxuXHQvLyDRgdGC0LDRhtGMINCw0LTQvdC+0YHQvdCwINC00L7RntCz0ZbQvCDQv9CwINGH0LDRgdC1LCDQsNC70LUg0LYg0LPRjdGC0LAg0L3RjyDRgtCw0Log0LLQsNC20L3QsCwg0LHQviDRniDQstGL0L3RltC60YMg0Z7RgdGRINCw0LTQvdC+XG5cdC8vINC60ZbQtNCw0LXRhtGG0LAg0L/QsNC80YvQu9C60LAuXG5cdC8vXG5cdC8vINCT0LXQvdC10YDQsNGG0YvRjyDRgtGN0LrRgdGC0YMg0LfRi9GF0L7QtNC90ZbQutCwINCw0LTQsdGL0LLQsNC10YbRhtCwINGW0LzQs9C90LXQvdC90LAuXG5cdC8vXG5cdC8vINCX0YvRhdC+0LTQt9GP0YfRiyDQtyDQs9GN0YLQsNCz0LAg0YPQu9GD0YfQsNGG0Ywg0YHRgtGA0LDQttC90ZbQutCw0Z4g0LTQvtGB0YLRg9C/0YMg0LTQsCDQvdC10LDQsSfRj9Ge0LvQtdC90YvRhSDRg9C70LDRgdGM0YbRltCy0LDRgdGM0YbRj9GeXG5cdC8vINGC0YDRjdCx0LAg0YLQvtC70YzQutGWINC/0YDRiyDQsNC00LvQsNC00YbRiy5cblx0Ly9cblx0QWJzdHJhY3RHdWFyZC5wcm90b3R5cGUgPVxuXHRcdCggZ2xvYmFsLl9fVXNlZFNjcmlwdElkZW50aWZpZXJzX18gKyBgYCApXG5cdFx0LnNwbGl0KCAvW1xccyxdKy8gKVxuXHRcdC5yZWR1Y2UoICggcHJvdG8sIGtleSApID0+XG5cdFx0XHRPYmplY3QuY3JlYXRlKCBwcm90bywgeyBbIGtleSBdOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyBpbnZhbGlkS2V5Q2FsbC5jYWxsKCB0aGlzLCBrZXkgKSB9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggXyApIHsgaW52YWxpZEtleUNhbGwuY2FsbCggdGhpcywga2V5ICkgfSxcblx0XHRcdH0gfSApLFxuXHRcdFx0QWJzdHJhY3RHdWFyZC5wcm90b3R5cGUgKVxufVxuXG5BYnN0cmFjdEd1YXJkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFic3RyYWN0R3VhcmQucHJvdG90eXBlLCB7XG5cdHRvU3RyaW5nOiB7IHZhbHVlOiB7fS50b1N0cmluZyB9LFxuXHR2YWx1ZU9mOiB7IHZhbHVlOiB7fS52YWx1ZU9mIH0sXG5cdHRvTG9jYWxlU3RyaW5nOiB7IHZhbHVlOiB7fS50b0xvY2FsZVN0cmluZyB9LFxuXHRoYXNPd25Qcm9wZXJ0eTogeyB2YWx1ZToge30uaGFzT3duUHJvcGVydHkgfSxcblx0aXNQcm90b3R5cGVPZjogeyB2YWx1ZToge30uaXNQcm90b3R5cGVPZiB9LFxuXHRwcm9wZXJ0eUlzRW51bWVyYWJsZTogeyB2YWx1ZToge30ucHJvcGVydHlJc0VudW1lcmFibGUgfSxcblx0JG5hbWU6IHsgdmFsdWU6IGA8Li4uPmAsIHdyaXRhYmxlOiAxIH0sXG59IClcblxubGV0IEVNUFRZX0FSUkFZID0gW11cbk9iamVjdC5mcmVlemUoIEVNUFRZX0FSUkFZIClcblxuY2xhc3MgSW1tdXRhYmxlSW50ZXJmYWNlIGV4dGVuZHMgQWJzdHJhY3RHdWFyZCB7XG5cblx0Ly8gZGVidWdnZXJcblx0Z2V0IHByb3BzKCkgeyB0aHJvdyBuZXcgRXJyb3IoIGBhY2Nlc3MgdG8gZGVwcmVjYXRlZCAncHJvcHMnIHByb3BlcnR5IGRldGVjdGVkYCApIH1cblxuXHRnZXQgZGVjbGFyZWRQcm9wZXJ0aWVzKCkgeyByZXR1cm4gdGhpcy5saXZlIH1cblxuXHRnZXQgbGVuZ3RoKCkgeyBsZXQgbSA9IHRoaXMudmFsdWVPZigpOyByZXR1cm4gbSA9PSBudWxsID8gMCA6IE9iamVjdC5rZXlzKCBtICkubGVuZ3RoIH1cblxuXHRnZXQoIGtleSApIHtcblx0XHRpZiAoIGtleSAhPSBudWxsICkge1xuXHRcdFx0bGV0IG0gPSB0aGlzLnZhbHVlT2YoKVxuXHRcdFx0aWYgKCBtICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBtLCBrZXkgKSApXG5cdFx0XHRcdHJldHVybiBtWyBrZXkgXVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbFxuXHR9XG5cblx0bWFwKCBmdW4gKSB7XG5cdFx0bGV0IG0gPSB0aGlzLnZhbHVlT2YoKVxuXHRcdHJldHVybiBtICYmICggQXJyYXkuaXNBcnJheSggbSApID8gbG9kYXNoLm1hcCggbSwgZnVuICkgOiBsb2Rhc2gubWFwVmFsdWVzKCBtLCBmdW4gKSApXG5cdH1cblxuXHRrZXlzKCkge1xuXHRcdGxldCBtID0gdGhpcy52YWx1ZU9mKClcblx0XHRyZXR1cm4gbSA9PSBudWxsID8gRU1QVFlfQVJSQVkgOiBPYmplY3Qua2V5cyggbSApXG5cdH1cbn1cblxuY2xhc3MgUmVhZE9ubHlDZWxsIGV4dGVuZHMgSW1tdXRhYmxlSW50ZXJmYWNlIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50ICkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLl9wYXJlbnQgPSBwYXJlbnRcblx0fVxuXG5cdGdldFJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcyB9XG5cdGdldCBsaXZlKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LmxpdmUgfVxuXHRnZXQgJG5hbWUoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuJG5hbWUgfVxuXG5cdHZhbHVlT2YoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQudmFsdWVPZi5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cdG5vVG91Y2goKSB7IHJldHVybiB0aGlzLl9wYXJlbnQubm9Ub3VjaC5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cdHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LnRvU3RyaW5nLmFwcGx5KCB0aGlzLl9wYXJlbnQsIGFyZ3VtZW50cyApIH1cblx0dG9KU09OKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LnRvSlNPTi5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cdGdldE5hbWUoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuZ2V0TmFtZS5hcHBseSggdGhpcy5fcGFyZW50LCBhcmd1bWVudHMgKSB9XG5cbn1cblxubGV0IEdldHRlciA9ICggZnVuLCBpc1ZhbHVlRXF1YWwgKSA9PiB7XG5cdGxldCBsYXN0XG5cdGxldCByZXQgPSAhaXNWYWx1ZUVxdWFsID9cblx0XHRmdW5jdGlvbiAoKSB7IHJldHVybiBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIH1cblx0OlxuXHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdGxldCByZXQgPSBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0XHRpZiAoICFpcyggbGFzdCwgcmV0LCBpc1ZhbHVlRXF1YWwgKSApXG5cdFx0XHRcdGxhc3QgPSByZXRcblx0XHRcdHJldHVybiBsYXN0XG5cdFx0fVxuXHRyZXQuaXNHZXR0ZXIgPSB0cnVlXG5cdHJldHVybiByZXRcbn1cblxubGV0IFR5cGUgPSAoIGYgKSA9PiB7XG5cdGcudHlwZURlc2NyaXB0b3IgPSB0cnVlXG5cdHJldHVybiBnXG5cdGZ1bmN0aW9uIGcoKSB7IHJldHVybiBmLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSB9XG59XG5cbmxldCBydW5HZXR0ZXIgPSAoIGNlbGwsIGdldHRlciwgc3RpY2t5ICkgPT4gKCBuZXcgQWN0aW9uKCBnZXR0ZXIsIGNlbGwsIHN0aWNreSApICkubGlua05hbWUoIGNlbGwsIGA6Z2V0dGVyYCApXG5cbmxldCBydW5TZXR0ZXIgPSAoIGNlbGwsIHNldHRlciwgc3RpY2t5ICkgPT4gKCBuZXcgQWN0aW9uKCAoKSA9PiBzZXR0ZXIoIGNlbGwudmFsdWVPZigpICksIG51bGwsIHN0aWNreSApICkubGlua05hbWUoIGNlbGwsIGA6c2V0dGVyYCApXG5cbmZ1bmN0aW9uIGlzKCBhLCBiLCBpc0VxdWFsICkge1xuXHRyZXR1cm4gT2JqZWN0LmlzKCBhLCBiICkgfHwgYiAmJiB0eXBlb2YgYi5pc0VxdWFsVG8gPT0gYGZ1bmN0aW9uYCAmJiBiLmlzRXF1YWxUbyggYSApIHx8IGEgJiYgdHlwZW9mIGEuaXNFcXVhbFRvID09IGBmdW5jdGlvbmAgJiYgYS5pc0VxdWFsVG8oIGIgKSB8fCB0eXBlb2YgaXNFcXVhbCA9PSBgZnVuY3Rpb25gICYmIGlzRXF1YWwoIGEsIGIgKVxufVxuXG5jbGFzcyBUaGlzIHtcblx0c3RhdGljIGNyZWF0ZSggcGFyZW50LCB0aGF0ICkge1xuXHRcdGxldCByZXQgPSBudWxsXG5cdFx0aWYgKCAhcGFyZW50IClcblx0XHRcdHJldCA9IG5ldyBUaGlzXG5cdFx0ZWxzZVxuXHRcdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZSggcGFyZW50IClcblx0XHRyZXQudmFsdWVPZiA9ICgpID0+IHRoYXQudmFsdWVPZigpXG5cdFx0cmV0LnRvU3RyaW5nID0gKCkgPT4gdGhhdC50b1N0cmluZygpXG5cdFx0cmV0LnRvSlNPTiA9ICgpID0+IHRoYXQudG9KU09OKClcblx0XHRyZXQuYXNzaWduID0gdmFsdWUgPT4gdGhhdC5hc3NpZ24oIHZhbHVlIClcblx0XHRyZXQudGhyb3cgPSB2YWx1ZSA9PiB0aGF0LnRocm93KCB2YWx1ZSApXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCByZXQsIGBsaXZlYCwgeyBnZXQ6ICgpID0+IHRoYXQubGl2ZSB9IClcblx0XHRyZXR1cm4gcmV0XG5cdH1cblx0X2RlZmluZVRoYXRQcm9wZXJ0eSgga2V5LCB0aGF0ICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywga2V5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0KCkgeyByZXR1cm4gdGhhdFsga2V5IF0gfSxcblx0XHRcdHNldCggdmFsdWUgKSB7IHRoYXRbIGtleSBdID0gdmFsdWUgfSxcblx0XHR9IClcblx0fVxufVxuXG5jbGFzcyBDZWxsIGV4dGVuZHMgSW1tdXRhYmxlSW50ZXJmYWNlIHtcblxuXHRjb25zdHJ1Y3Rvciggc3RpY2t5ICkge1xuXHRcdHN1cGVyKClcblx0XHR0aGlzLl9pZCA9IFVJRCgpXG5cdFx0dGhpcy5fdGhhdCA9IG51bGxcblx0XHR0aGlzLl92YWx1ZSA9IG51bGxcblx0XHR0aGlzLl9lcnJvciA9IG51bGxcblx0XHR0aGlzLl9pc1ZhbHVlRXF1YWwgPSBpc1xuXHRcdHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2Vcblx0XHR0aGlzLl9mcm96ZW4gPSBmYWxzZVxuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlXG5cdFx0dGhpcy5fZGlydHkgPSBmYWxzZVxuXHRcdHRoaXMuX2xpdmUgPSBudWxsXG5cdFx0dGhpcy5fbGl2ZUFycmF5ID0gbnVsbFxuXHRcdHRoaXMuX2FjdGlvbnNBcnIgPSBbXVxuXHRcdHRoaXMuX3BhcmVudCA9IG51bGxcblx0XHR0aGlzLl9vbmNoYW5nZSA9IFtdXG5cdFx0dGhpcy4kbmFtZSA9IHsgdG9TdHJpbmc6ICgpID0+IHRoaXMuZ2V0TmFtZSgpIH1cblx0XHR0aGlzLl9ub3RpZnlXcml0dGVuKClcblx0XHR0aGlzLl9zdGlja3kgPSAhIXN0aWNreVxuXHR9XG5cblx0dmFsdWVPZigpIHsgcmV0dXJuIHRoaXMuX3JlYWQoKSB9XG5cdGFzc2lnbiggdmFsdWUgKSB7IHJldHVybiB0aGlzLl93cml0ZSggdmFsdWUsIGZhbHNlLCBudWxsICkgfVxuXHR1cGRhdGUoIGRpZmYgKSB7IHJldHVybiB0aGlzLmFzc2lnbiggbHUuYXBwbHlEaWZmKCB0aGlzLm5vVG91Y2goKSwgZGlmZiApICkgfVxuXHR0aHJvdyggdmFsdWUgKSB7IHJldHVybiB0aGlzLl93cml0ZSggbnVsbCwgZmFsc2UsIHZhbHVlICkgfVxuXHR0b3VjaCgpIHsgdGhpcy5fZmlyZSgpIH1cblxuXHRub1RvdWNoKCkge1xuXHRcdGlmICggdGhpcy5fZGlydHkgKVxuXHRcdFx0dGhpcy5fdXBkYXRlU2VsZigpXG5cdFx0aWYgKCB0aGlzLl9lcnJvciApXG5cdFx0XHR0aHJvdyB0aGlzLl9lcnJvclxuXHRcdHJldHVybiB0aGlzLl92YWx1ZVxuXHR9XG5cblx0dGhlbiggcHJvYyApIHtcblx0XHR0aGlzLl9vbmNoYW5nZS5wdXNoKCBwcm9jIClcblx0fVxuXG5cdGNsb3NlKCkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkIClcblx0XHRcdHJldHVyblxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWVcblx0XHR0aGlzLl9maXJlKClcblx0XHRpZiAoIHRoaXMuX3BhcmVudCApXG5cdFx0XHR0aGlzLl9wYXJlbnQuY2xvc2UoKVxuXHRcdGlmICggdGhpcy5fbGl2ZUFycmF5ICkge1xuXHRcdFx0Zm9yICggbGV0IHAgb2YgdGhpcy5fbGl2ZUFycmF5IClcblx0XHRcdFx0cC5jbG9zZSgpXG5cdFx0XHR0aGlzLl9saXZlQXJyYXkgPSBudWxsXG5cdFx0fVxuXHRcdHRoaXMuX3ZhbHVlID0gbnVsbFxuXHRcdHRoaXMuX2Vycm9yID0gbnVsbFxuXHRcdHRoaXMuX2FjdGlvbnNBcnIgPSBudWxsXG5cdFx0dGhpcy5fcGFyZW50ID0gbnVsbFxuXHR9XG5cblx0ZnJlZXplKCkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkIHx8IHRoaXMuX2Zyb3plbiApXG5cdFx0XHRyZXR1cm5cblx0XHR0aGlzLl9mcm96ZW4gPSB0cnVlXG5cdFx0dGhpcy5fZmlyZSgpIC8vIFRPRE8g0LTQu9GPINCy0YvQtNCw0LvQtdC90YzQvdGPINGB0L/QsNGB0YvQu9Cw0Log0LDQsdGL0YHRjNGG0ZbRgdGPINCx0LXQtyBfZmlyZSDRliDQsNC00L/QsNCy0LXQtNC90LAg0LHQtdC3INC70ZbRiNC90Y/Qs9CwINC/0YDQsNCz0L7QvdGDXG5cdFx0aWYgKCB0aGlzLl9wYXJlbnQgKVxuXHRcdFx0dGhpcy5fcGFyZW50LmZyZWV6ZSgpXG5cdFx0aWYgKCB0aGlzLl9saXZlQXJyYXkgKSB7XG5cdFx0XHRmb3IgKCBsZXQgcCBvZiB0aGlzLl9saXZlQXJyYXkgKVxuXHRcdFx0XHRwLmZyZWV6ZSgpXG5cdFx0fVxuXHR9XG5cblx0Z2V0IGxpdmUoKSB7IHJldHVybiB0aGlzLl9saXZlIH1cblxuXHRnZXRSZWFkT25seSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVhZE9ubHkgfHwgKCB0aGlzLl9yZWFkT25seSA9IG5ldyBSZWFkT25seUNlbGwoIHRoaXMgKSApXG5cdH1cblxuXHR0b1N0cmluZyggLi4uYXJncyApIHtcblx0XHRsZXQgdiA9IHRoaXMuX3JlYWQoKVxuXHRcdHJldHVybiAoIHYgPT0gbnVsbCApIHx8ICF2LnRvU3RyaW5nID8gYGAgKyB2IDogdi50b1N0cmluZyggLi4uYXJncyApXG5cdH1cblxuXHR0b0pTT04oIC4uLmFyZ3MgKSB7XG5cdFx0bGV0IHYgPSB0aGlzLl9yZWFkKClcblx0XHRyZXR1cm4gKCB2ID09IG51bGwgKSB8fCAhdi50b0pTT04gPyB2IDogdi50b0pTT04oIC4uLmFyZ3MgKVxuXHR9XG5cblx0d2l0aCggY2IgKSB7IHJldHVybiBjYi5jYWxsKCB0aGlzLl9nZXRUaGF0KCkgKSB9XG5cblx0c2V0TmFtZSggbmFtZSApIHtcblx0XHR0aGlzLl9uYW1lID0gbmFtZVxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRnZXROYW1lKCkge1xuXHRcdGxldCByZXQgPSB0aGlzLl9uYW1lIHx8IHRoaXMuX2tleVxuXHRcdGxldCBwID0gdGhpcy5fcGFyZW50XG5cdFx0d2hpbGUgKCBwICkge1xuXHRcdFx0cmV0ID0gKCBwLl9uYW1lIHx8IHAuX2tleSApICsgYC5gICsgcmV0XG5cdFx0XHRwID0gcC5fcGFyZW50XG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fVxuXG5cdF9nZXRUaGF0KCkge1xuXHRcdGlmICggIXRoaXMuX3RoYXQgKSB7XG5cdFx0XHR0aGlzLl90aGF0ID0gVGhpcy5jcmVhdGUoIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2dldFRoYXQoKSwgdGhpcyApXG5cdFx0XHRpZiAoIHRoaXMuX2xpdmUgKVxuXHRcdFx0XHRmb3IgKCBsZXQgaSBpbiB0aGlzLl9saXZlIClcblx0XHRcdFx0XHR0aGlzLl90aGF0Ll9kZWZpbmVUaGF0UHJvcGVydHkoIGksIHRoaXMgKVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fdGhhdFxuXHR9XG5cblx0ZGVmaW5lUHJvcGVydHkoIGtleSApIHtcblx0XHQvLyBwYXNzIGtleSA9PSBgYCB0byBtYWtlIENlbGwgb2JqZWN0LCBub3QgdmFsdWVcblx0XHRpZiAoICF0aGlzLl9saXZlICkge1xuXHRcdFx0dGhpcy5fbGl2ZSA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0dGhpcy5fbGl2ZUFycmF5ID0gW11cblx0XHR9XG5cdFx0aWYgKCAha2V5IClcblx0XHRcdHJldHVyblxuXHRcdGd1YXJkUHJvcCgga2V5IClcblx0XHRsZXQgYyA9IHRoaXMuX2xpdmVbIGtleSBdXG5cdFx0aWYgKCBjIClcblx0XHRcdHJldHVybiBjXG5cdFx0YyA9IG5ldyBDZWxsKCB0aGlzLl9zdGlja3kgKVxuXHRcdHRoaXMuX2xpdmVbIGtleSBdID0gY1xuXHRcdHRoaXMuX2xpdmVBcnJheS5wdXNoKCBjIClcblx0XHRjLl9rZXkgPSBrZXlcblx0XHRjLl9wYXJlbnQgPSB0aGlzXG5cdFx0Yy5fbGV2ZWwgPSAoIHRoaXMuX2xldmVsIHx8IDAgKSArIDFcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIGtleSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoIGMuX2xpdmUgKVxuXHRcdFx0XHRcdHJldHVybiBjXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gYy5fcmVhZCgpXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2YWx1ZSA9PiB7XG5cdFx0XHRcdGlmICggYy5fbGl2ZSApXG5cdFx0XHRcdFx0dmFsdWUgPSBnZXRWYWx1ZSggdmFsdWUgKVxuXHRcdFx0XHRjLl93cml0ZSggdmFsdWUsIGZhbHNlIClcblx0XHRcdH0sXG5cdFx0fSApXG5cdFx0aWYgKCB0aGlzLl90aGF0IClcblx0XHRcdHRoaXMuX3RoYXQuX2RlZmluZVRoYXRQcm9wZXJ0eSgga2V5LCB0aGlzIClcblx0XHRpZiAoIHRoaXMuX3ZhbHVlICE9IG51bGwgKVxuXHRcdFx0Yy5fd3JpdGUoIHRoaXMuX3ZhbHVlWyBrZXkgXSwgdHJ1ZSApXG5cdFx0cmV0dXJuIGNcblx0fVxuXG5cdGluaXQoIHZhbHVlICkge1xuXHRcdHRoaXMuX2luaXQoIHZhbHVlLCBmYWxzZSwgZmFsc2UgKVxuXHR9XG5cblx0c2V0Q29uc3QoIHByb3AsIHZhbHVlICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgcHJvcCwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6ICgpID0+IHZhbHVlIH0gKVxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRzZXRWYXIoIHByb3AsIHZhbHVlICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgcHJvcCwgeyBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSApXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGdldCBbIHJhVmFsdWUgXSgpIHsgcmV0dXJuIHRydWUgfVxuXG5cdF9pbml0KCB2YWx1ZSwgcmVjdXJzaXZlLCBpc0dldHRlciwgaXNWYWx1ZUVxdWFsICkge1xuXHRcdGxldCBjZWxsID0gdGhpc1xuXHRcdGlmICggIXJlY3Vyc2l2ZSAmJiBjZWxsLl9pbml0aWFsaXplZCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBhbHJlYWR5IGluaXRpYWxpemVkYCApXG5cdFx0aWYgKCB0aGlzLl9wYXJlbnQgKVxuXHRcdFx0dGhpcy5fcGFyZW50Ll9kaXJ0eSA9IHRydWVcblx0XHRjZWxsLl9pbml0aWFsaXplZCA9IHRydWVcblx0XHRpZiAoIGlzVmFsdWVFcXVhbCApXG5cdFx0XHR0aGlzLl9pc1ZhbHVlRXF1YWwgPSBpc1ZhbHVlRXF1YWxcblx0XHR2YWx1ZSA9IGNoZWNrTnVsbCggdmFsdWUgKVxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09IGBmdW5jdGlvbmAgJiYgdmFsdWUudHlwZURlc2NyaXB0b3IgKVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSggY2VsbC5fa2V5IClcblx0XHRpZiAoIHZhbHVlID09IG51bGwgKSAvLyB3ZSBhcmUgYWxyZWFkeSBudWxsIGF0IHRoZSBwb2ludCBvZiBiaXJ0aFxuXHRcdFx0cmV0dXJuXG5cdFx0aWYgKCB2YWx1ZVsgcmFWYWx1ZSBdICkgLy8gZm9yY2UganVzdCBhIHZhbHVlXG5cdFx0XHRyZXR1cm4gY2VsbC5fdmFsdWUgPSB2YWx1ZVxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09IGBmdW5jdGlvbmAgKSB7XG5cdFx0XHRpZiAoIGlzR2V0dGVyIHx8IHZhbHVlLmlzR2V0dGVyICkgLy8gZ2V0dGVyXG5cdFx0XHRcdHJ1bkdldHRlciggY2VsbCwgKCkgPT4gdmFsdWUuY2FsbCggY2VsbC5fcGFyZW50ICYmIGNlbGwuX3BhcmVudC5fZ2V0VGhhdCgpICksIHRoaXMuX3N0aWNreSApXG5cdFx0XHRlbHNlIC8vIG1ldGhvZFxuXHRcdFx0XHRjZWxsLl92YWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLmFwcGx5KCBjZWxsLl9wYXJlbnQgJiYgY2VsbC5fcGFyZW50Ll9nZXRUaGF0KCksIGFyZ3VtZW50cyApIH1cblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAoICFpc0xpdGVyYWwoIHZhbHVlICkgKSAvLyBqdXN0IGEgdmFsdWVcblx0XHRcdHJldHVybiBjZWxsLl92YWx1ZSA9IHZhbHVlXG5cdFx0Ly8gc3VicmVjb3JkIGRlc2NyaXB0aW9uXG5cdFx0aWYgKCByZWN1cnNpdmUgKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgd3JvbmcgcGFyYW1ldGVyc2AgKVxuXHRcdGNlbGwuZGVmaW5lUHJvcGVydHkoKVxuXHRcdGZvciAoIGxldCBrZXkgaW4gdmFsdWUgKSB7XG5cdFx0XHRsZXQgZGVzY3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB2YWx1ZSwga2V5IClcblx0XHRcdGlmICggIWRlc2NyIClcblx0XHRcdFx0Y29udGludWVcblx0XHRcdGxldCBnZXQgPSBkZXNjci5nZXRcblx0XHRcdGxldCBzdWJWYWx1ZSA9IGRlc2NyLnZhbHVlXG5cdFx0XHRpZiAoIGRlc2NyLnNldCApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYHdyb25nIHBhcmFtZXRlcnNgIClcblx0XHRcdGVsc2UgaWYgKCBnZXQgKVxuXHRcdFx0XHRzdWJWYWx1ZSA9IGdldFxuXHRcdFx0aWYgKCBrZXkgPT0gYCRgIClcblx0XHRcdFx0Y2VsbC5faW5pdCggc3ViVmFsdWUsIHRydWUsICEhZ2V0IClcblx0XHRcdGVsc2Vcblx0XHRcdFx0Y2VsbC5kZWZpbmVQcm9wZXJ0eSgga2V5LCB0cnVlICkuX2luaXQoIHN1YlZhbHVlLCBmYWxzZSwgISFnZXQgKVxuXHRcdH1cblx0fVxuXG5cdF9yZWFkKCkge1xuXHRcdGlmICggdGhpcy5fZGlydHkgKVxuXHRcdFx0dGhpcy5fdXBkYXRlU2VsZigpXG5cdFx0bGV0IGFjdGlvbiA9IGNvLmdsb2JhbFsgYWN0aW9uS2V5IF1cblx0XHRpZiAoIGFjdGlvbiApIHtcblx0XHRcdGlmICggdGhpcy5fY2xvc2VkIClcblx0XHRcdFx0YWN0aW9uLmNsb3NlKClcblx0XHRcdGVsc2UgaWYgKCAhdGhpcy5fZnJvemVuIClcblx0XHRcdFx0YWN0aW9uLm9ucmVhZCggdGhpcyApXG5cdFx0fVxuXHRcdGlmICggdGhpcy5fZXJyb3IgKVxuXHRcdFx0dGhyb3cgdGhpcy5fZXJyb3Jcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWVcblx0fVxuXG5cdF93cml0ZSggbmV3VmFsdWUsIGRvd24sIG5ld0Vycm9yICkge1xuXHRcdGlmICggbmV3RXJyb3IgPT0gbnVsbCApXG5cdFx0XHRuZXdFcnJvciA9IG51bGxcblx0XHRpZiAoIHRoaXMuX2Zyb3plbiApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiVHJ5IHRvIGNoYW5nZSBhIGZyb3plbiB2YWx1ZVwiIClcblx0XHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWVcblx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlXG5cdFx0bmV3VmFsdWUgPSBjaGVja051bGwoIG5ld1ZhbHVlIClcblx0XHRpZiAoIHRoaXMuX2Nsb3NlZCApIHtcblx0XHRcdGxldCBhY3Rpb24gPSBjby5nbG9iYWxbIGFjdGlvbktleSBdXG5cdFx0XHRpZiAoIGFjdGlvbiApXG5cdFx0XHRcdGFjdGlvbi5jbG9zZSgpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhdGhpcy5faXNWYWx1ZUVxdWFsKCB0aGlzLl92YWx1ZSwgbmV3VmFsdWUgKSB8fCB0aGlzLl9lcnJvciAhPSBuZXdFcnJvciApIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKGA+YCt0aGlzLiRuYW1lKS8vZGVidWdnZXJcblx0XHRcdHRoaXMuX3ZhbHVlID0gbmV3VmFsdWVcblx0XHRcdHRoaXMuX2Vycm9yID0gbmV3RXJyb3Jcblx0XHRcdGlmICggdGhpcy5fbGl2ZSApXG5cdFx0XHRcdGZvciAoIGxldCBwIG9mIHRoaXMuX2xpdmVBcnJheSApXG5cdFx0XHRcdFx0cC5fd3JpdGUoIG5ld1ZhbHVlICYmIG5ld1ZhbHVlWyBwLl9rZXkgXSwgdHJ1ZSApXG5cdFx0XHR0aGlzLl9maXJlKClcblx0XHRcdGlmICggIWRvd24gKSB7XG5cdFx0XHRcdGxldCBwID0gdGhpcy5fcGFyZW50XG5cdFx0XHRcdHdoaWxlICggcCAmJiAhcC5fZGlydHkgKSB7XG5cdFx0XHRcdFx0cC5fZGlydHkgPSB0cnVlXG5cdFx0XHRcdFx0cC5fZmlyZSgpXG5cdFx0XHRcdFx0cCA9IHAuX3BhcmVudFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggIWRvd24gKVxuXHRcdFx0dGhpcy5fbm90aWZ5V3JpdHRlbigpXG5cdFx0cmV0dXJuIG5ld1ZhbHVlXG5cdH1cblxuXHRfdXBkYXRlU2VsZigpIHtcblx0XHRsZXQgY250ID0gMFxuXHRcdGxldCByZXQgPSB7fVxuXHRcdGZvciAoIGxldCBrZXkgaW4gdGhpcy5fdmFsdWUgKSBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggdGhpcy5fdmFsdWUsIGtleSApICkge1xuXHRcdFx0cmV0WyBrZXkgXSA9IHRoaXMuX3ZhbHVlWyBrZXkgXVxuXHRcdFx0KytjbnRcblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgcCBvZiB0aGlzLl9saXZlQXJyYXkgKSB7XG5cdFx0XHRpZiAoIHAuX2RpcnR5IClcblx0XHRcdFx0cC5fdXBkYXRlU2VsZigpXG5cdFx0XHRpZiAoIHAuX2Vycm9yICkge1xuXHRcdFx0XHR0aGlzLl9lcnJvciA9IHAuX2Vycm9yXG5cdFx0XHRcdHRoaXMuX3ZhbHVlID0gbnVsbFxuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0bGV0IHZhbHVlID0gcC5fdmFsdWVcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCApIHtcblx0XHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHJldCwgcC5fa2V5ICkgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHJldFsgcC5fa2V5IF1cblx0XHRcdFx0XHQtLWNudFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0WyBwLl9rZXkgXSA9IHZhbHVlXG5cdFx0XHRcdGNudCA9IEluZmluaXR5XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBjbnQgPT0gMCApXG5cdFx0XHRyZXQgPSBudWxsXG5cblx0XHR0aGlzLl92YWx1ZSA9IHJldFxuXHRcdHRoaXMuX2RpcnR5ID0gZmFsc2Vcblx0fVxuXG5cdGRlYnVnKCBjYiApIHtcblx0XHR0aGlzLl9hY3Rpb25zQXJyLnB1c2goIHsgYWN0aW9uOiB7IF9maXJlOiBjYiB9IH0gKVxuXHR9XG5cblx0ZGVidWdnZXIoKSB7XG5cdFx0dGhpcy5kZWJ1ZyggKCkgPT4geyBkZWJ1Z2dlciB9IClcblx0fVxuXG5cdF9maXJlKCkge1xuXHRcdGxldCBhXG5cdFx0YSA9IHRoaXMuX2FjdGlvbnNBcnJcblx0XHRpZiAoIGEubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0bGV0IGMgPSBhWyBpIF1cblx0XHRcdFx0aWYgKCBjLmFjdGlvbiApXG5cdFx0XHRcdFx0Yy5hY3Rpb24uX2ZpcmUoKVxuXHRcdFx0XHRjLnB1c2hlZEMgPSBmYWxzZVxuXHRcdFx0fVxuXHRcdFx0YS5sZW5ndGggPSAwXG5cdFx0fVxuXHRcdGEgPSB0aGlzLl9vbmNoYW5nZVxuXHRcdGlmICggYS5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrIClcblx0XHRcdFx0dXBkYXRlcy5sYXRlciggYVsgaSBdIClcblx0XHRcdGEubGVuZ3RoID0gMFxuXHRcdH1cblx0fVxuXG5cdF9ub3RpZnlXcml0dGVuKCkge1xuXHRcdGxldCBhY3Rpb24gPSBjby5nbG9iYWxbIGFjdGlvbktleSBdXG5cdFx0aWYgKCBhY3Rpb24gKVxuXHRcdFx0YWN0aW9uLm9ud3JpdHRlbiggdGhpcyApXG5cdH1cblxufVxuXG5sZXQgcmV0aHJvdyA9IGVycm9yID0+IHNldFRpbWVvdXQoICgpID0+IHsgdGhyb3cgZXJyb3IgfSwgMSApXG5cbmNsYXNzIEFjdGlvbiB7XG5cblx0Y29uc3RydWN0b3IoIGZ1biwgZGVzdCwgc3RpY2t5ICkge1xuXHRcdHRoaXMuX2lkID0gVUlEKClcblx0XHR0aGlzLl9mdW4gPSBmdW5cblx0XHR0aGlzLl9kZXN0ID0gZGVzdFxuXHRcdHRoaXMuX2NlbGxTZXQgPSB7fVxuXHRcdHRoaXMuX2NlbGxTZXRTaXplID0gMFxuXHRcdHRoaXMuX2NlbGxBcnIgPSBbXVxuXHRcdHRoaXMuJG5hbWUgPSB7IHRvU3RyaW5nOiAoKSA9PiBgPEFjdGlvbj5gIH1cblx0XHR0aGlzLl90aHJlYWQgPSBjby5nb2NhbGwoIHRoaXMuX2xvb3AsIHRoaXMgKS5saW5rTmFtZSggdGhpcyApLndhaXRGb3JJbnB1dCgpXG5cdFx0dGhpcy5fcnVuQ291bnQgPSAwXG5cdFx0bGV0IG93bmVyXG5cdFx0aWYgKCAoIG93bmVyID0gY28uZ2xvYmFsWyBhY3Rpb25LZXkgXSApICYmIG93bmVyLl9jaGlsZHJlbiApXG5cdFx0XHRvd25lci5fY2hpbGRyZW4ucHVzaCggdGhpcyApXG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBudWxsXG5cdFx0dGhpcy5fdGhyZWFkcyA9IG51bGxcblx0XHR0aGlzLl9vbnRocmVhZCA9IG51bGxcblx0XHR0aGlzLl9nZW5lcmF0b3JQcm94eSA9IG51bGxcblx0XHR0aGlzLl9nZW5lcmF0b3IgPSBudWxsXG5cdFx0aWYgKCBzdGlja3kgKSB7XG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdXG5cdFx0XHR0aGlzLl90aHJlYWRzID0gW11cblx0XHRcdHRoaXMuX29udGhyZWFkID0gdGhyZWFkID0+IHRoaXMuX3RocmVhZHMucHVzaCggdGhyZWFkIClcblx0XHR9XG5cdH1cblxuXHRsaW5rTmFtZSggdmFsdWUsIHN1ZmZpeCA9IGA6YWN0aW9uYCApIHtcblx0XHRpZiAoIHZhbHVlLiRuYW1lIClcblx0XHRcdHZhbHVlID0gdmFsdWUuJG5hbWVcblx0XHR0aGlzLiRuYW1lLnRvU3RyaW5nID0gKCkgPT4gYGAgKyB2YWx1ZSArIHN1ZmZpeFxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRfaW5pdEdlbmVyYXRvclByb3h5KCkge1xuXHRcdGxldCBfdmFsdWVcblx0XHRsZXQgX25leHQgPSAoKSA9PiB0aGlzLl9nZW5lcmF0b3IubmV4dCggX3ZhbHVlIClcblx0XHRsZXQgX3Rocm93ID0gKCkgPT4gdGhpcy5fZ2VuZXJhdG9yLnRocm93KCBfdmFsdWUgKVxuXHRcdGxldCBfcmV0dXJuID0gKCkgPT4gdGhpcy5fZ2VuZXJhdG9yLnJldHVybiggX3ZhbHVlIClcblx0XHR0aGlzLl9nZW5lcmF0b3JQcm94eSA9IHtcblx0XHRcdFsgU3ltYm9sLml0ZXJhdG9yIF06IHJldHVyblRoaXMsXG5cdFx0XHRuZXh0OiB2ID0+IHtcblx0XHRcdFx0X3ZhbHVlID0gdlxuXHRcdFx0XHR0cnkgeyByZXR1cm4gY28uY2F0Y2hUaHJlYWRzKCBfbmV4dCwgdGhpcy5fb250aHJlYWQgKSB9XG5cdFx0XHRcdGZpbmFsbHkgeyBfdmFsdWUgPSBudWxsIH1cblx0XHRcdH0sXG5cdFx0XHR0aHJvdzogdiA9PiB7XG5cdFx0XHRcdF92YWx1ZSA9IHZcblx0XHRcdFx0dHJ5IHsgcmV0dXJuIGNvLmNhdGNoVGhyZWFkcyggX3Rocm93LCB0aGlzLl9vbnRocmVhZCApIH1cblx0XHRcdFx0ZmluYWxseSB7IF92YWx1ZSA9IG51bGwgfVxuXHRcdFx0fSxcblx0XHRcdHJldHVybjogdiA9PiB7XG5cdFx0XHRcdF92YWx1ZSA9IHZcblx0XHRcdFx0dHJ5IHsgcmV0dXJuIGNvLmNhdGNoVGhyZWFkcyggX3JldHVybiwgdGhpcy5fb250aHJlYWQgKSB9XG5cdFx0XHRcdGZpbmFsbHkgeyBfdmFsdWUgPSBudWxsIH1cblx0XHRcdH0sXG5cdFx0fVxuXHR9XG5cblx0Kl9sb29wKCkge1xuXHRcdHlpZWxkIHVwZGF0ZXMubGF0ZXJcblx0XHRsZXQgbmV4dCA9IHsgdGhlbjogbmV4dCA9PiB7IHRoaXMuX29uY2hhbmdlID0gbmV4dCB9IH1cblx0XHRjby5nbG9iYWxbIGFjdGlvbktleSBdID0gdGhpc1xuXHRcdGxldCBlcnJvckNhdGNoZWQgPSBmYWxzZVxuXHRcdGV4dGVybmFsOiBmb3IgKDs7KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKDs7KSB7XG5cdFx0XHRcdFx0aWYgKCAhZXJyb3JDYXRjaGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmlzQ2xvc2VkKCkgKVxuXHRcdFx0XHRcdFx0XHRicmVhayBleHRlcm5hbFxuXHRcdFx0XHRcdFx0dGhpcy5fYmVnaW4oKVxuXHRcdFx0XHRcdFx0ZXJyb3JDYXRjaGVkID0gdHJ1ZVxuXHRcdFx0XHRcdFx0bGV0IHJldFxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLl9jaGlsZHJlbiApIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gY28uY2F0Y2hUaHJlYWRzKCB0aGlzLl9mdW4sIHRoaXMuX29udGhyZWFkIClcblx0XHRcdFx0XHRcdFx0aWYgKCAhcmV0IHx8IHJldFsgcmFWYWx1ZSBdICkgeyAvLyBub29wXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoIHJldC5uZXh0ICYmIHJldC50aHJvdyApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICF0aGlzLl9nZW5lcmF0b3JQcm94eSApXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0R2VuZXJhdG9yUHJveHkoKVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2dlbmVyYXRvciA9IHJldFxuXHRcdFx0XHRcdFx0XHRcdHRyeSB7IHJldCA9IHlpZWxkKiB0aGlzLl9nZW5lcmF0b3JQcm94eSB9XG5cdFx0XHRcdFx0XHRcdFx0ZmluYWxseSB7IHRoaXMuX2dlbmVyYXRvciA9IG51bGwgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKCByZXQudGhlbiApXG5cdFx0XHRcdFx0XHRcdFx0cmV0ID0geWllbGQgcmV0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gKCAwLCB0aGlzLl9mdW4gKSgpXG5cdFx0XHRcdFx0XHRcdGlmICggIXJldCB8fCByZXRbIHJhVmFsdWUgXSApIHsgLy8gbm9vcFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKCByZXQubmV4dCAmJiByZXQudGhyb3cgKVxuXHRcdFx0XHRcdFx0XHRcdHJldCA9IHlpZWxkKiByZXRcblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoIHJldC50aGVuIClcblx0XHRcdFx0XHRcdFx0XHRyZXQgPSB5aWVsZCByZXRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggdGhpcy5fZGVzdCApXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2Rlc3QuYXNzaWduKCByZXQgKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlcnJvckNhdGNoZWQgPSBmYWxzZVxuXHRcdFx0XHRcdGlmICggdGhpcy5pc0Nsb3NlZCgpIClcblx0XHRcdFx0XHRcdGJyZWFrIGV4dGVybmFsXG5cdFx0XHRcdFx0c3dpdGNoICggdGhpcy5fZW5kKCkgKSB7XG5cdFx0XHRcdFx0Y2FzZSBmYWxzZTpcblx0XHRcdFx0XHRcdGJyZWFrIGV4dGVybmFsXG5cdFx0XHRcdFx0Y2FzZSB0cnVlOlxuXHRcdFx0XHRcdFx0eWllbGQgbmV4dFxuXHRcdFx0XHRcdC8vIGNhc2UgbnVsbDpcblx0XHRcdFx0XHRcdC8qIGltbWVkaWF0ZSByZWNhbGN1bGF0aW9uICovXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0XHRpZiAoIGVycm9yQ2F0Y2hlZCApXG5cdFx0XHRcdFx0dGhpcy5fZGVzdC50aHJvdyggZXJyb3IgKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cmV0aHJvdyggZXJyb3IgKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjby5nbG9iYWxbIGFjdGlvbktleSBdID0gbnVsbFxuXHRcdHRoaXMuX2ZpbmFsaXplKClcblx0fVxuXG5cdGlzQ2xvc2VkKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY2VsbFNldFxuXHR9XG5cblx0Y2xvc2UoKSB7XG5cdFx0bGV0IHRocmVhZCA9IHRoaXMuX3RocmVhZFxuXHRcdHRoaXMuX2ZpcmUoKVxuXHRcdHRoaXMuX2ZpbmFsaXplKClcblx0XHR0aHJlYWQgJiYgdGhyZWFkLmtpbGwoKVxuXHR9XG5cblx0X2Nsb3NlQ2hpbGRyZW4oKSB7XG5cdFx0bGV0IGNcblx0XHRpZiAoIGMgPSB0aGlzLl9jaGlsZHJlbiApIHtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGMubGVuZ3RoOyBpIDwgbDsgKytpIClcblx0XHRcdFx0Y1sgaSBdLmNsb3NlKClcblx0XHRcdGMubGVuZ3RoID0gMFxuXHRcdH1cblx0XHRpZiAoIGMgPSB0aGlzLl90aHJlYWRzICkge1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYy5sZW5ndGg7IGkgPCBsOyArK2kgKVxuXHRcdFx0XHRjWyBpIF0ua2lsbCgpXG5cdFx0XHRjLmxlbmd0aCA9IDBcblx0XHR9XG5cdH1cblxuXHRfZmluYWxpemUoKSB7XG5cdFx0dGhpcy5fdW5zdWJzY3JpYmUoKVxuXHRcdHRoaXMuX2NlbGxTZXQgPSBudWxsXG5cdFx0dGhpcy5fY2VsbEFyciA9IG51bGxcblx0XHR0aGlzLl9mdW4gPSBudWxsXG5cdFx0dGhpcy5fZGVzdCA9IG51bGxcblx0XHR0aGlzLl90aHJlYWQgPSBudWxsXG5cdH1cblxuXHRfYmVnaW4oKSB7XG5cdFx0dGhpcy5fdW5zdWJzY3JpYmUoKVxuXHRcdCsrdGhpcy5fcnVuQ291bnRcblx0XHRpZiAoIEFjdGlvbi5tYXhDb3VudCA8IHRoaXMuX3J1bkNvdW50ICkge1xuXHRcdFx0QWN0aW9uLm1heENvdW50ID0gdGhpcy5fcnVuQ291bnRcblx0XHR9XG5cdH1cblxuXHRfdW5zdWJzY3JpYmUoKSB7XG5cdFx0dGhpcy5fb25jaGFuZ2UgPSBudWxsXG5cdFx0bGV0IGEgPSB0aGlzLl9jZWxsQXJyXG5cdFx0aWYgKCBhICkge1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSApIHtcblx0XHRcdFx0bGV0IGMgPSBhWyBpIF1cblx0XHRcdFx0Yy5jZWxsID0gbnVsbFxuXHRcdFx0XHRjLnZhbHVlID0gbnVsbFxuXHRcdFx0XHRjLmFjdGlvbiA9IG51bGxcblx0XHRcdFx0Yy5yZWFkID0gZmFsc2Vcblx0XHRcdFx0Yy53cml0dGVuID0gZmFsc2Vcblx0XHRcdFx0Yy5wdXNoZWRBID0gZmFsc2Vcblx0XHRcdFx0Ly8gZG8gbm90IGNoYW5nZSBjLnB1c2hlZEMgaGVyZSEhXG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuX2NlbGxTZXRTaXplID4gMzIgJiYgYS5sZW5ndGggPCB0aGlzLl9jZWxsU2V0U2l6ZSAvIDQgKSB7XG5cdFx0XHRcdHRoaXMuX2NlbGxTZXQgPSB7fVxuXHRcdFx0XHR0aGlzLl9jZWxsU2V0U2l6ZSA9IDBcblx0XHRcdH1cblx0XHRcdGEubGVuZ3RoID0gMFxuXHRcdH1cblx0XHR0aGlzLl9jbG9zZUNoaWxkcmVuKClcblx0fVxuXG5cdF9lbmQoKSB7XG5cdFx0bGV0IHJldCA9IGZhbHNlXG5cdFx0bGV0IGEgPSB0aGlzLl9jZWxsQXJyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSApIHtcblx0XHRcdGxldCBjID0gYVsgaSBdXG5cdFx0XHRpZiAoIGMud3JpdHRlbiApXG5cdFx0XHRcdGMuYWN0aW9uID0gbnVsbFxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICggIWMucHVzaGVkQyApIHtcblx0XHRcdFx0XHRjLmNlbGwuX2FjdGlvbnNBcnIucHVzaCggYyApXG5cdFx0XHRcdFx0Yy5wdXNoZWRDID0gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWlzKCBjLnZhbHVlLCBjLmNlbGwuX3ZhbHVlICkgfHwgYy5lcnJvciAhPSBjLmNlbGwuX2Vycm9yIClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0XHRjLmFjdGlvbiA9IHRoaXNcblx0XHRcdFx0cmV0ID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0Yy52YWx1ZSA9IG51bGxcblx0XHRcdGMuY2VsbCA9IG51bGxcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cblx0X2xpbmtDZWxsKCBjZWxsICkge1xuXHRcdGxldCBjID0gdGhpcy5fY2VsbFNldFsgY2VsbC5faWQgXVxuXHRcdGlmICggYyA9PSBudWxsICkge1xuXHRcdFx0YyA9IHRoaXMuX2NlbGxTZXRbIGNlbGwuX2lkIF0gPSB7XG5cdFx0XHRcdGNlbGw6IG51bGwsXG5cdFx0XHRcdHZhbHVlOiBudWxsLFxuXHRcdFx0XHRlcnJvcjogbnVsbCxcblx0XHRcdFx0YWN0aW9uOiBudWxsLFxuXHRcdFx0XHRyZWFkOiBmYWxzZSxcblx0XHRcdFx0d3JpdHRlbjogZmFsc2UsXG5cdFx0XHRcdHB1c2hlZEE6IGZhbHNlLFxuXHRcdFx0XHRwdXNoZWRDOiBmYWxzZSxcblx0XHRcdH1cblx0XHRcdCsrdGhpcy5fY2VsbFNldFNpemVcblx0XHR9XG5cdFx0aWYgKCAhYy5wdXNoZWRBICkge1xuXHRcdFx0dGhpcy5fY2VsbEFyci5wdXNoKCBjIClcblx0XHRcdGMuY2VsbCA9IGNlbGxcblx0XHRcdGMucHVzaGVkQSA9IHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGNcblx0fVxuXG5cdG9ucmVhZCggY2VsbCApIHtcblx0XHRsZXQgYyA9IHRoaXMuX2xpbmtDZWxsKCBjZWxsIClcblx0XHRjLnJlYWQgPSB0cnVlXG5cdFx0Yy52YWx1ZSA9IGNlbGwuX3ZhbHVlXG5cdFx0Yy5lcnJvciA9IGNlbGwuX2Vycm9yXG5cdH1cblxuXHRvbndyaXR0ZW4oIGNlbGwgKSB7XG5cdFx0dGhpcy5fbGlua0NlbGwoIGNlbGwgKS53cml0dGVuID0gdHJ1ZVxuXHR9XG5cblx0X2ZpcmUoKSB7XG5cdFx0aWYgKCB0aGlzLl9vbmNoYW5nZSApXG5cdFx0XHR1cGRhdGVzLmxhdGVyKCB0aGlzLl9vbmNoYW5nZSApXG5cdFx0dGhpcy5fdW5zdWJzY3JpYmUoKVxuXHR9XG5cbn1cblxuQWN0aW9uLm1heENvdW50ID0gMFxuXG5sZXQgbmV3UmVhY3RpdmUgPSAoIGdldHRlciwgaGFuZGxlcnMsIHN0aWNreSwgaXNWYWx1ZUVxdWFsICkgPT4ge1xuXHRmb3IgKCBsZXQgaCBvZiBoYW5kbGVycyApXG5cdFx0aWYgKCBoICE9IG51bGwgJiYgdHlwZW9mIGggIT0gYGZ1bmN0aW9uYCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGB3cm9uZyBwYXJhbWV0ZXJzYCApXG5cdGxldCBjZWxsID0gbmV3IENlbGwoIHN0aWNreSApXG5cdGlmICggZ2V0dGVyICE9PSB1bmRlZmluZWQgKVxuXHRcdGNlbGwuX2luaXQoIGdldHRlciwgZmFsc2UsIHRydWUsIGlzVmFsdWVFcXVhbCApXG5cdGZvciAoIGxldCBoIG9mIGhhbmRsZXJzIClcblx0XHRoICYmICggaC5sZW5ndGggPyBydW5TZXR0ZXIgOiBydW5HZXR0ZXIgKSggY2VsbCwgaCwgc3RpY2t5IClcblx0cmV0dXJuIGNlbGxcbn1cblxubGV0IHJhID0gZnVuY3Rpb24gKCkge1xuXHRsZXQgbmFtZSwgZnVuLCBzdGlja3ksIGlzVmFsdWVFcXVhbCwgaW5kZXggPSAwXG5cdGlmICggdHlwZW9mIGFyZ3VtZW50c1sgaW5kZXggXSA9PSBcInN0cmluZ1wiIClcblx0XHRuYW1lID0gYXJndW1lbnRzWyBpbmRleCsrIF1cblx0aWYgKCB0eXBlb2YgYXJndW1lbnRzWyBpbmRleCBdID09IFwiYm9vbGVhblwiIClcblx0XHRzdGlja3kgPSBhcmd1bWVudHNbIGluZGV4KysgXVxuXHRmdW4gPSBhcmd1bWVudHNbIGluZGV4KysgXVxuXHRpZiAoIHR5cGVvZiBhcmd1bWVudHNbIGluZGV4IF0gPT0gXCJmdW5jdGlvblwiIClcblx0XHRpc1ZhbHVlRXF1YWwgPSBhcmd1bWVudHNbIGluZGV4KysgXVxuXHRyZXR1cm4gbmV3UmVhY3RpdmUoIGZ1biwgW10sIHN0aWNreSwgaXNWYWx1ZUVxdWFsIClcbn1cblxuZnVuY3Rpb24gQXJyYXlJc0VxdWFsVG8oIGEgKSB7XG5cdHJldHVybiAoIHRoaXMgPT0gYSApIHx8IEFycmF5LmlzQXJyYXkoIGEgKSAmJiB0aGlzLmxlbmd0aCA9PSBhLmxlbmd0aCAmJiB0aGlzLmV2ZXJ5KCAoIGUsIGkgKSA9PiBpcyggZSwgYVsgaSBdICkgKVxufVxuXG5mdW5jdGlvbiBKc29uSXNFcXVhbFRvKCBhICkge1xuXHRyZXR1cm4gKCB0aGlzID09IGEgKSB8fCBKU09OLnN0cmluZ2lmeSggdGhpcyApID09IEpTT04uc3RyaW5naWZ5KCBhIClcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmFcblxuZXhwb3J0cy5yYSA9IHJhXG5cbmV4cG9ydHMuaXMgPSBpc1xuXG5leHBvcnRzLkFycmF5ID0gYXJyYXkgPT4ge1xuXHRhcnJheS5pc0VxdWFsVG8gPSBBcnJheUlzRXF1YWxUb1xuXHRyZXR1cm4gYXJyYXlcbn1cblxuZXhwb3J0cy5KU09OID0gb2JqID0+IHtcblx0b2JqLmlzRXF1YWxUbyA9IEpzb25Jc0VxdWFsVG9cblx0cmV0dXJuIG9ialxufVxuXG5leHBvcnRzLlZhbHVlID0gb2JqID0+IHtcblx0b2JqICYmIG9iai5kZWZpbmVQcm9wZXJ0eSggcmFWYWx1ZSwgeyB2YWx1ZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlIH0gKVxuXHRyZXR1cm4gb2JqXG59XG5cbmV4cG9ydHMuY2xlYW4gPSAoIGdldHRlciwgLi4uaGFuZGVycyApID0+IG5ld1JlYWN0aXZlKCBnZXR0ZXIsIGhhbmRlcnMsIGZhbHNlIClcblxuZXhwb3J0cy5kZXRhY2ggPSBmdW4gPT4ge1xuXHRsZXQgb2xkXG5cdGlmICggb2xkID0gY28uZ2xvYmFsWyBhY3Rpb25LZXkgXSApIHtcblx0XHRjby5nbG9iYWxbIGFjdGlvbktleSBdID0gbnVsbFxuXHRcdHRyeSB7IHJldHVybiBmdW4oKSB9IGZpbmFsbHkgeyBjby5nbG9iYWxbIGFjdGlvbktleSBdID0gb2xkIH1cblx0fVxuXHRlbHNlXG5cdFx0cmV0dXJuIGZ1bigpXG59XG5cbmV4cG9ydHMuZGV0YWNoZWQgPSBmdW4gPT4gZnVuY3Rpb24gKCkge1xuXHRsZXQgb2xkXG5cdGlmICggb2xkID0gY28uZ2xvYmFsWyBhY3Rpb25LZXkgXSApIHtcblx0XHRjby5nbG9iYWxbIGFjdGlvbktleSBdID0gbnVsbFxuXHRcdHRyeSB7IHJldHVybiBmdW4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIH0gZmluYWxseSB7IGNvLmdsb2JhbFsgYWN0aW9uS2V5IF0gPSBvbGQgfVxuXHR9XG5cdGVsc2Vcblx0XHRyZXR1cm4gZnVuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxufVxuXG5leHBvcnRzLm9uID0gKCBlbWl0dGVyLCBldmVudCwgZ2V0dGVyICkgPT4ge1xuXHRsZXQgcmV0ID0gcmEoKVxuXHRsZXQgaGFuZGxlciA9IGRhdGEgPT4gcmV0LmFzc2lnbiggZ2V0dGVyKCBkYXRhICkgKVxuXHRpZiAoIGV2ZW50ID09IGBzdHJpbmdgIClcblx0XHRlbWl0dGVyLm9uKCBldmVudCwgaGFuZGxlciApXG5cdGVsc2UgZm9yICggbGV0IGUgb2YgZXZlbnQgKVxuXHRcdGVtaXR0ZXIub24oIGUsIGhhbmRsZXIgKVxuXHRoYW5kbGVyKClcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnRzLkNlbGwgPSBDZWxsXG5leHBvcnRzLkltbXV0YWJsZUludGVyZmFjZSA9IEltbXV0YWJsZUludGVyZmFjZVxuZXhwb3J0cy5BYnN0cmFjdEd1YXJkID0gQWJzdHJhY3RHdWFyZFxuZXhwb3J0cy5HZXR0ZXIgPSBHZXR0ZXJcbmV4cG9ydHMuVHlwZSA9IFR5cGVcbmV4cG9ydHMuaW1wb3J0RnJvbSA9IG9ic2VydmFibGUgPT4gVHlwZSggbmFtZSA9PiBHZXR0ZXIoICgpID0+IG9ic2VydmFibGUubGl2ZVsgbmFtZSBdLnZhbHVlT2YoKSApIClcbmV4cG9ydHMuZm9yY2VDYWxjdWxhdGlvbnMgPSAoKSA9PiB1cGRhdGVzLnJ1bkFsbCgpXG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdHVhbCgpIHtcblx0bGV0IHJldCA9IHJhKClcblx0cmV0LmFzc2lnbiggcmV0IClcblx0cmEoICgpID0+IHtcblx0XHRsZXQgdmFsdWUgPSByZXQudmFsdWVPZigpXG5cdFx0cmEuZGV0YWNoKCAoKSA9PiByZXQuYXNzaWduKCB2YWx1ZSApIClcblx0fSApXG5cdHJldHVybiByZXRcbn1cblxubGV0IF9EQkNodW5rX0dldHRlciA9IFVJRCgpXG5cbmNsYXNzIERCQ2h1bmsge1xuXHRjb25zdHJ1Y3RvciggZ2V0dGVyLCBzYXZlLCBpbml0aWFsLCBwcmV2aW91cyApIHtcblx0XHR0aGlzLl9wcmV2aW91cyA9IHByZXZpb3VzXG5cdFx0dGhpcy5fZ2V0dGVyID0gZ2V0dGVyXG5cdFx0dGhpcy5fc2F2ZSA9IHNhdmVcblx0XHRsZXQgY2h1bmsgPSB0aGlzLl9jaHVuayA9IHJhKClcblx0XHRjaHVuay5hc3NpZ24oIGluaXRpYWwgKVxuXHRcdGxldCBhY3R1YWwgPSB0aGlzLl9hY3R1YWwgPSBjcmVhdGVBY3R1YWwoKVxuXHRcdGFjdHVhbFsgX0RCQ2h1bmtfR2V0dGVyIF0gPSByYSggKCkgPT4gbHUuYXBwbHlEaWZmKCBnZXR0ZXIudmFsdWVPZigpLCBjaHVuay52YWx1ZU9mKCkgKSApXG5cdFx0dGhpcy5fc3VtbWFyeSA9IHJhKCAoKSA9PiBhY3R1YWwudmFsdWVPZigpWyBfREJDaHVua19HZXR0ZXIgXS52YWx1ZU9mKCkgKVxuXHR9XG5cdGNyZWF0ZU5leHQoIGluaXRpYWwgPSBudWxsICkgeyByZXR1cm4gbmV3IERCQ2h1bmsoIHRoaXMuX3N1bW1hcnksIHRoaXMuX3NhdmUsIGluaXRpYWwsIHRoaXMuX2FjdHVhbCApIH1cblx0Z2V0IGJlZm9yZSgpIHsgcmV0dXJuIHRoaXMuX2dldHRlci52YWx1ZU9mKCkgfVxuXHRnZXQgc3VtbWFyeSgpIHsgcmV0dXJuIHRoaXMuX3N1bW1hcnkudmFsdWVPZigpIH1cblx0Z2V0IGNodW5rKCkgeyByZXR1cm4gdGhpcy5fY2h1bmsudmFsdWVPZigpIH1cblx0c2V0IGNodW5rKCB2YWx1ZSApIHsgdGhpcy5fY2h1bmsuYXNzaWduKCB2YWx1ZSApIH1cblx0dmFsdWVPZigpIHsgcmV0dXJuIHRoaXMuY2h1bmsgfVxuXHRhc3NpZ24oIHZhbHVlICkgeyB0aGlzLmNodW5rID0gdmFsdWUgfVxuXHRzYXZlKCkgeyByZXR1cm4gdGhpcy5fc2F2ZSggdGhpcy5jaHVuayApIH1cblx0dXBkYXRlKCBkaWZmICkgeyByZXR1cm4gdGhpcy5fY2h1bmsudXBkYXRlKCBkaWZmICkgfVxuXHRzZXQoIG5hbWUsIHZhbHVlICkgeyByZXR1cm4gdGhpcy5fY2h1bmsuc2V0KCBuYW1lLCB2YWx1ZSApIH1cblx0Z2V0KCBuYW1lICkgeyByZXR1cm4gdGhpcy5fY2h1bmsuZ2V0KCBuYW1lICkgfVxuXHRjbG9zZSgpIHtcblx0XHR0aGlzLl9jaHVuay5hc3NpZ24oIG51bGwgKVxuXHRcdGlmICggdGhpcy5fcHJldmlvdXMgKSB7XG5cdFx0XHR0aGlzLl9hY3R1YWwuYXNzaWduKCB0aGlzLl9wcmV2aW91cyApXG5cdFx0XHR0aGlzLl9wcmV2aW91cyA9IG51bGxcblx0XHR9XG5cdH1cbn1cblxuY2xhc3MgREIge1xuXHRjb25zdHJ1Y3RvciggZ2V0dGVyLCBzYXZlICkge1xuXHRcdHRoaXMuX2hlYWQgPSByYSgpXG5cdFx0dGhpcy5faGVhZC5hc3NpZ24oIG5ldyBEQkNodW5rKCBnZXR0ZXIsIHNhdmUgKSApXG5cdFx0dGhpcy5fdmFsdWUgPSByYSggKCkgPT4gdGhpcy5faGVhZC52YWx1ZU9mKCkuc3VtbWFyeSApXG5cdH1cblx0Z2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLnZhbHVlT2YoKSB9XG5cdHZhbHVlT2YoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLnZhbHVlT2YoKVxuXHR9XG5cdGNyZWF0ZVJlY29yZCgpIHsgLy8gbm90IGRldGFjaGVkXG5cdFx0bGV0IHJldCA9IHRoaXMuX2hlYWQudmFsdWVPZigpLmNyZWF0ZU5leHQoKVxuXHRcdHRoaXMuX2hlYWQuYXNzaWduKCByZXQgKVxuXHRcdHJldHVybiByZXRcblx0fVxufVxuXG5leHBvcnRzLmRiID0gKCBnZXR0ZXIsIHNhdmUgKSA9PiBuZXcgREIoIGdldHRlciwgc2F2ZSApXG5cbmZ1bmN0aW9uIHRvS2V5KCBvYmogKSB7XG5cdGlmICggIXRvS2V5LktleXMgKVxuXHRcdHRvS2V5LktleXMgPSB0eXBlb2YgV2Vha01hcCAhPSBgdW5kZWZpbmVkYCA/IG5ldyBXZWFrTWFwIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0bGV0IGlkID0gYF90b19rZXlfJHsgVUlEKCkgfWBcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNldCggb2JqLCB2YWx1ZSApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIGlkLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdH0gKSB9LFxuXHRcdFx0XHRnZXQoIG9iaiApIHsgcmV0dXJuIG9ialsgaWQgXSB9LFxuXHRcdFx0XHRoYXMoIG9iaiApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggb2JqLCBpZCApIH0sXG5cdFx0XHRcdC8vIGRlbGV0ZSggb2JqICkgeyBkZWxldGUgb2JqWyBpZCBdIH0sXG5cdFx0XHR9XG5cdFx0fSgpXG5cdGlmICggb2JqICYmICggdHlwZW9mIG9iaiA9PSBgb2JqZWN0YCB8fCB0eXBlb2Ygb2JqID09IGBmdW5jdGlvbmAgKSApIHtcblx0XHRpZiAoICF0b0tleS5LZXlzLmhhcyggb2JqICkgKVxuXHRcdFx0dG9LZXkuS2V5cy5zZXQoIG9iaiwgVUlEKCkgKVxuXHRcdHJldHVybiB0b0tleS5LZXlzLmdldCggb2JqIClcblx0fVxuXHRyZXR1cm4gdHlwZW9mIG9iaiArIG9ialxufVxuXG5leHBvcnRzLm1ha2VLZXkgPSAoIG9iaiwga2V5ICkgPT4gcmEoICgpID0+IG9iai5nZXQoIGtleSApIClcblxuZXhwb3J0cy5tYXAgPSAoIGFycmF5LCBtYXBwZXIgKSA9PiB7XG5cdGlmICggISggYXJyYXkgaW5zdGFuY2VvZiBDZWxsICkgKVxuXHRcdHRocm93IG5ldyBFcnJvciggXCJyYS5tYXA6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjZWxsXCIgKVxuXHRsZXQgY2FjaGUgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0bGV0IHJldCA9IHJhKClcblx0cmEuZGV0YWNoKCAoKSA9PiByYSggKCkgPT4ge1xuXHRcdC8vIFRPRE8g0L/RgNCw0LLQtdGA0YvRhtGMLCDRiNGC0L4g0L/RgNGLIGFycmF5LmNsb3NlKCkg0LPRjdGC0LAg0YTRg9C90LrRhtGL0Y8g0LDQtNC/0YDQsNGG0L7RntCy0LDQtSDRliDQv9GA0YvQsdGW0LLQsNC1INGe0YHQtSBjYWNoZVtdLmluZGV4INGWIGNhY2hlW10ucHJvY1xuXHRcdGxldCBhID0gYXJyYXkudmFsdWVPZigpXG5cdFx0cmEuZGV0YWNoKCAoKSA9PiB7XG5cdFx0XHRsZXQgcmV0YXJyID0gW11cblx0XHRcdGxldCBpbmRleCA9IDBcblx0XHRcdGxvZGFzaC5mb3JFYWNoKCBjYWNoZSwgYyA9PiBjLmFiYW5kb25lZCA9IHRydWUgKVxuXHRcdFx0YSAmJiBhLmZvckVhY2goIHZhbHVlID0+IHtcblx0XHRcdFx0bGV0IGtleSA9IHRvS2V5KCB2YWx1ZSApXG5cdFx0XHRcdGxldCBjXG5cdFx0XHRcdGlmICggISggYyA9IGNhY2hlWyBrZXkgXSApIClcblx0XHRcdFx0XHRjID0gY2FjaGVbIGtleSBdID0ge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0aW5kZXg6IHJhKCksXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjLmFiYW5kb25lZCA9IGZhbHNlXG5cdFx0XHRcdGMuaW5kZXguYXNzaWduKCBpbmRleCsrIClcblx0XHRcdFx0aWYgKCAhYy5wcm9jIClcblx0XHRcdFx0XHRjLnByb2MgPSByYSggKCkgPT4gbWFwcGVyKCB2YWx1ZSwgYy5pbmRleCApIClcblx0XHRcdFx0cmV0YXJyLnB1c2goIGMucHJvYyApXG5cdFx0XHR9IClcblx0XHRcdGxvZGFzaC5rZXlzKCBjYWNoZSApLmZvckVhY2goIGtleSA9PiB7XG5cdFx0XHRcdGxldCBjID0gY2FjaGVbIGtleSBdXG5cdFx0XHRcdGlmICggYy5hYmFuZG9uZWQgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXkgXVxuXHRcdFx0XHRcdGMuaW5kZXguY2xvc2UoKVxuXHRcdFx0XHRcdGMucHJvYy5jbG9zZSgpXG5cdFx0XHRcdH1cblx0XHRcdH0gKVxuXHRcdFx0cmV0LmFzc2lnbiggcmEuQXJyYXkoIHJldGFyciApIClcblx0XHR9IClcblx0fSApIClcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnRzLmtleW1hcCA9ICggYXJyYXksIG1hcHBlciApID0+IHtcblx0bGV0IG1hcHBlZCA9IHJhLm1hcCggYXJyYXksIG1hcHBlciApXG5cdHJldHVybiByYSggKCkgPT4gbG9kYXNoLnppcE9iamVjdCggYXJyYXkudmFsdWVPZigpLCBtYXBwZWQudmFsdWVPZigpICkgKVxufVxuXG4vLyBleHBvcnRzLnNsaWNlID0gKCBkZXN0LCBzb3VyY2UsIGtleXNWYXIgKSA9PiB7XG4vLyBcdHRocm93IG5ldyBFcnJvciggXCJtZXNzYWdlXCIgKVxuLy8gXHQvLyBUT0RPOiBvcHRpbWl6YXRpb25cbi8vIFx0aWYgKCAhKCBkZXN0IGluc3RhbmNlb2YgQ2VsbCApIClcbi8vIFx0XHRkZXN0ID0gcmEuY2xlYW4oIGRlc3QgKVxuLy8gXHRsZXQgY2FjaGVIb2xkZXIgPSByYS5jbGVhbigpXG4vLyBcdHJhLmNsZWFuKCAoKSA9PiB7XG4vLyBcdFx0bGV0IGtleXMgPSBnZXRWYWx1ZSgga2V5c1ZhciApXG4vLyBcdFx0aWYgKCBrZXlzIClcbi8vIFx0XHRcdGtleXMuc29ydCgpXG4vLyBcdFx0dXBkYXRlcy5sYXRlciggKCkgPT4ge1xuLy8gXHRcdFx0bGV0IGMgPSByYS5jbGVhbigpXG4vLyBcdFx0XHRsZXQgcyA9IGMuZGVmaW5lUHJvcGVydHkoIGBzb3VyY2VgIClcbi8vIFx0XHRcdGxldCBkID0gYy5kZWZpbmVQcm9wZXJ0eSggYGRlc3RgIClcbi8vIFx0XHRcdGtleXMgJiYga2V5cy5mb3JFYWNoKCBrID0+IHtcbi8vIFx0XHRcdFx0bGV0IHNrID0gcy5kZWZpbmVQcm9wZXJ0eSggayApXG4vLyBcdFx0XHRcdGxldCBkayA9IGQuZGVmaW5lUHJvcGVydHkoIGsgKVxuLy8gXHRcdFx0XHRyYS5jbGVhbiggKCkgPT4gZGsuYXNzaWduKCBzay52YWx1ZU9mKCkgKSApXG4vLyBcdFx0XHR9IClcbi8vIFx0XHRcdGxldCB0ID0gY2FjaGVIb2xkZXIudmFsdWVPZigpXG4vLyBcdFx0XHRjYWNoZUhvbGRlci5hc3NpZ24oIGMgKVxuLy8gXHRcdFx0dCAmJiB0LmNsb3NlKClcbi8vIFx0XHR9IClcbi8vIFx0fSApXG4vLyBcdHJhLmNsZWFuKCAoKSA9PiB7XG4vLyBcdFx0bGV0IGMgPSBjYWNoZUhvbGRlci52YWx1ZU9mKClcbi8vIFx0XHRjICYmIGMuc291cmNlICYmIGMuc291cmNlLmFzc2lnbiggc291cmNlLnZhbHVlT2YoKSApXG4vLyBcdH0gKVxuLy8gXHRyYS5jbGVhbiggKCkgPT4ge1xuLy8gXHRcdGxldCBjID0gY2FjaGVIb2xkZXIudmFsdWVPZigpXG4vLyBcdFx0ZGVzdC5hc3NpZ24oIGMgJiYgYy5kZXN0ICYmIGMuZGVzdC52YWx1ZU9mKCkgKVxuLy8gXHR9IClcbi8vIFx0cmV0dXJuIGRlc3Rcbi8vIH1cbiIsImNvbnN0IG1heEluZGV4ID0gMzI3NjhcblxuY2xhc3MgU2NoZWR1bGVyIHtcblx0Y29uc3RydWN0b3IoIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5zZXRJbW1lZGlhdGUgPSAoIG9wdGlvbnMgJiYgb3B0aW9ucy5zZXRJbW1lZGlhdGUgKSB8fCBwcm9jZXNzLm5leHRUaWNrXG5cdFx0dGhpcy5tYXhUaWNrcyA9ICggb3B0aW9ucyAmJiBvcHRpb25zLm1heFRpY2tzICkgfHwgSW5maW5pdHlcblx0XHR0aGlzLl9wcm9jcyA9IFtdXG5cdFx0dGhpcy5faW5kZXggPSAwXG5cdFx0dGhpcy5fc2NoZWR1bGVkID0gZmFsc2Vcblx0XHR0aGlzLl9wcm9jZXNzaW5nID0gZmFsc2Vcblx0XHR0aGlzLl9oYW5kbGVyID0gdGhpcy5faGFuZGxlci5iaW5kKCB0aGlzIClcblx0XHR0aGlzLnB1c2ggPSB0aGlzLnRoZW4uYmluZCggdGhpcyApXG5cdH1cblxuXHR0aGVuKCBwcm9jICkge1xuXHRcdHRoaXMuX3Byb2NzLnB1c2goIHByb2MgKVxuXHRcdGlmICggIXRoaXMuX3Byb2Nlc3NpbmcgKVxuXHRcdFx0dGhpcy5fc2NoZWR1bGUoKVxuXHR9XG5cblx0X3NjaGVkdWxlKCkge1xuXHRcdGlmICggIXRoaXMuX3NjaGVkdWxlZCApIHtcblx0XHRcdHRoaXMuc2V0SW1tZWRpYXRlKCB0aGlzLl9oYW5kbGVyIClcblx0XHRcdHRoaXMuX3NjaGVkdWxlZCA9IHRydWVcblx0XHR9XG5cdH1cblxuXHRfaGFuZGxlcigpIHtcblx0XHR0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZVxuXHRcdHdoaWxlICggdGhpcy5fcHJvY3MubGVuZ3RoICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5faGFuZGxlcjEoKVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdFx0c2V0VGltZW91dCggKCkgPT4geyB0aHJvdyBlcnJvciB9LCAwIClcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRfaGFuZGxlcjEoKSB7XG5cdFx0dGhpcy5fcHJvY2Vzc2luZyA9IHRydWVcblx0XHR0cnkge1xuXHRcdFx0bGV0IHQgPSAwXG5cdFx0XHR3aGlsZSAoIHRoaXMuX2luZGV4IDwgdGhpcy5fcHJvY3MubGVuZ3RoICYmICggKyt0IDw9IHRoaXMubWF4VGlja3MgKSApIHtcblx0XHRcdFx0bGV0IHByb2MgPSB0aGlzLl9wcm9jc1sgdGhpcy5faW5kZXggXVxuXHRcdFx0XHR0aGlzLl9wcm9jc1sgdGhpcy5faW5kZXggXSA9IG51bGxcblx0XHRcdFx0Kyt0aGlzLl9pbmRleFxuXHRcdFx0XHRpZiAoIHRoaXMuX2luZGV4ID49IG1heEluZGV4ICYmIHRoaXMuX2luZGV4ICogMyA+IHRoaXMuX3Byb2NzLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLl9wcm9jcy5zcGxpY2UoIDAsIHRoaXMuX2luZGV4IClcblx0XHRcdFx0XHR0aGlzLl9pbmRleCA9IDBcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9jKClcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmluYWxseSB7XG5cdFx0XHR0aGlzLl9wcm9jZXNzaW5nID0gZmFsc2Vcblx0XHRcdGlmICggdGhpcy5fcHJvY3MubGVuZ3RoICYmIHRoaXMuX2luZGV4ID49IHRoaXMuX3Byb2NzLmxlbmd0aCApXG5cdFx0XHRcdHRoaXMuX3Byb2NzLmxlbmd0aCA9IHRoaXMuX2luZGV4ID0gMFxuXHRcdFx0aWYgKCB0aGlzLl9pbmRleCApXG5cdFx0XHRcdHRoaXMuX3NjaGVkdWxlKClcblx0XHR9XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlZHVsZXJcbiIsImZ1bmN0aW9uIHJldGhyb3coIGVycm9yICkge1xuXHRzZXRUaW1lb3V0KCAoKSA9PiB7IHRocm93IGVycm9yIH0gKVxufVxuXG5mdW5jdGlvbiBzYWZlRWFjaCggYXJyYXksIGNiICkge1xuXHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArK2kgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNiKCBhcnJheS5zaGlmdCgpIClcblx0XHR9XG5cdFx0Y2F0Y2ggKCBlcnJvciApIHtcblx0XHRcdHJldGhyb3coIGVycm9yIClcblx0XHR9XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTcGFyc2VRdWV1ZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2NicyA9IFtdXG5cdH1cblx0dGhlbiggY2IgKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgKVxuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayggKCkgPT4gY2IoIHVuZGVmaW5lZCApIClcblx0XHRlbHNlXG5cdFx0XHR0aGlzLl9jYnMucHVzaCggY2IgKVxuXHR9XG5cdGlzQ2xvc2VkKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZWRcblx0fVxuXHRjbG9zZSgpIHtcblx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlXG5cdFx0c2FmZUVhY2goIHRoaXMuX2NicywgaGFuZGxlciA9PiBoYW5kbGVyKCB1bmRlZmluZWQgKSApXG5cdH1cblx0cHVzaCggZGF0YSApIHtcblx0XHRpZiAoIHRoaXMuX2Nsb3NlZCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBxdWV1ZSBpcyBhcmVhZHkgY2xvc2VkYCApXG5cdFx0c2FmZUVhY2goIHRoaXMuX2NicywgaGFuZGxlciA9PiBoYW5kbGVyKCBkYXRhICkgKVxuXHR9XG5cdHB1c2hjYiggZGF0YSApIHtcblx0XHRpZiAoIHRoaXMuX2Nsb3NlZCApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBxdWV1ZSBpcyBhcmVhZHkgY2xvc2VkYCApXG5cdFx0c2FmZUVhY2goIHRoaXMuX2NicywgaGFuZGxlciA9PiBoYW5kbGVyKCBkYXRhKCkgKSApXG5cdH1cbn1cbiIsIi8qXG5ieSBkZXNpZ246XG7QndC1INGB0YLQstCw0YDQsNC10Lwg0L3RltGP0LrRltGFINCx0YPRhNC10YDQsNGeINC00LvRjyDQv9Cw0LTQt9C10LkgKNC90LDQutGI0YLQsNC70YIgdG91Y2htb3ZlINGG0ZYgbW91c2Vtb3ZlKSAtINC/0LDQtNC30LXRliDRntGB0ZEg0LDQtNC90L4g0LDQu9GM0LHQviDQsNC/0YDQsNGG0L7RntCy0LDRjtGG0YbQsCDRhdGD0YLQutCwLCDQsNC70YzQsdC+INGC0L7Qu9GM0LrRliDQt9Cw0LnQvNCw0Y7RhtGMINC80LXRgdGG0LAg0Z4g0LHRg9GE0LXRgNCw0YUg0ZYg0LfQsNGC0LDRgNC80L7QttCy0LDRjtGG0Ywg0LDQv9GA0LDRhtC+0Z7QutGDLCDQutCw0LvRliDQsNC/0YDQsNGG0L7RntGI0YfRi9C60ZYg0Z7RgdGRINC2INC/0YDQsNGH0L3Rg9GG0YbQsC5cbiovXG5cbmxldCBzcGFyc2VxdWV1ZSA9IHJlcXVpcmUoIGBzcGFyc2VxdWV1ZWAgKVxuXG5sZXQgdHJhY2tzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cbnNldEludGVydmFsKCAoKSA9PiB7XG5cdGZvciAoIGxldCBpZGVudGlmaWVyIGluIHRyYWNrcyApIHtcblx0XHRsZXQgdHJhY2sgPSB0cmFja3NbIGlkZW50aWZpZXIgXVxuXHRcdGlmICggdHJhY2suYWJhbmRvbmVkICkge1xuXHRcdFx0Ly8gaWYgKCB0cmFjay5oYW5kbGVyLnJldHVybiApXG5cdFx0XHQvLyBcdHRyYWNrLmhhbmRsZXIucmV0dXJuKClcblx0XHRcdC8vIGRlbGV0ZSB0cmFja3NbIGlkZW50aWZpZXIgXVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHR0cmFjay5hYmFuZG9uZWQgPSB0cnVlXG5cdH1cbn0sIDcwMDAgKVxuXG5mdW5jdGlvbiBwdXNoRXZlbnQoIHRyYWNrLCBldmVudCApIHtcblx0dHJhY2sucG9pbnRzLnB1c2goIGV2ZW50IClcblx0aWYgKCB0cmFjay5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCApXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKVxufVxuXG5mdW5jdGlvbiBzdG9wRXZlbnRzKCB0cmFjayApIHtcblx0dHJhY2sucG9pbnRzLmNsb3NlKClcbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFjayggaWRlbnRpZmllciwgZXZlbnQgKSB7XG5cdGxldCBwb2ludHMgPSBuZXcgc3BhcnNlcXVldWUoKVxuXHRsZXQgZGV0YWlsID0ge1xuXHRcdGNhbmNlbEV2ZW50OiBudWxsLFxuXHRcdG5leHQ6IHBvaW50cyxcblx0fVxuXHRsZXQgdHJhY2sgPSB7XG5cdFx0YWJhbmRvbmVkOiBmYWxzZSxcblx0XHRjbG9zZWQ6IGZhbHNlLFxuXHRcdGRldGFpbCxcblx0XHRwb2ludHMsXG5cdFx0cHJldmVudERlZmF1bHQ6IGZhbHNlLFxuXHR9XG5cdHRyYWNrc1sgaWRlbnRpZmllciBdID0gdHJhY2tcblx0bGV0IHJldCA9IG5ldyBDdXN0b21FdmVudCggYHRvdWNoYCwgeyBkZXRhaWwsIGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSApXG5cdHJldC5wYWdlWCA9IGV2ZW50LnBhZ2VYXG5cdHJldC5wYWdlWSA9IGV2ZW50LnBhZ2VZXG5cdHJldC5jbGllbnRYID0gZXZlbnQuY2xpZW50WFxuXHRyZXQuY2xpZW50WSA9IGV2ZW50LmNsaWVudFlcblx0cmV0LnNjcmVlblggPSBldmVudC5zY3JlZW5YXG5cdHJldC5zY3JlZW5ZID0gZXZlbnQuc2NyZWVuWVxuXHRyZXQucHJldmVudERlZmF1bHQgPSAoKSA9PiB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdHRyYWNrLnByZXZlbnREZWZhdWx0ID0gdHJ1ZVxuXHR9XG5cdGV2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KCByZXQgKVxuXHRwdXNoRXZlbnQoIHRyYWNrLCBldmVudCApXG59XG5cbmZ1bmN0aW9uIG9uRXhpc3RpbmdUcmFjayggZnVuICkgeyByZXR1cm4gKCBpZGVudGlmaWVyLCBhcmcgKSA9PiB7XG5cdGxldCB0cmFjayA9IHRyYWNrc1sgaWRlbnRpZmllciBdXG5cdGlmICggIXRyYWNrIClcblx0XHRyZXR1cm5cblx0dHJhY2suYWJhbmRvbmVkID0gZmFsc2Vcblx0ZnVuKCB0cmFjaywgYXJnIClcbn0gfVxuXG5sZXQgY29udGludWVUcmFjayA9IG9uRXhpc3RpbmdUcmFjayggcHVzaEV2ZW50IClcblxubGV0IHN0b3BUcmFjayA9IG9uRXhpc3RpbmdUcmFjayggKCB0cmFjaywgZXZlbnQgKSA9PiB7XG5cdHB1c2hFdmVudCggdHJhY2ssIGV2ZW50IClcblx0c3RvcEV2ZW50cyggdHJhY2sgKVxufSApXG5cbmxldCByZW1vdmVUcmFjayA9IG9uRXhpc3RpbmdUcmFjayggc3RvcEV2ZW50cyApXG5cbmxldCBjYW5jZWxUcmFjayA9IG9uRXhpc3RpbmdUcmFjayggKCB0cmFjaywgZXZlbnQgKSA9PiB7XG5cdHRyYWNrLmRldGFpbC5jYW5jZWxFdmVudCA9IGV2ZW50XG5cdHN0b3BFdmVudHMoIHRyYWNrIClcbn0gKVxuXG5mdW5jdGlvbiBmb3JUb3VjaGVzKCBldmVudCwgY2IgKSB7XG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgKytpICkge1xuXHRcdGxldCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLml0ZW0oIGkgKVxuXHRcdGNiKCB0b3VjaC5pZGVudGlmaWVyLCB7XG5cdFx0XHR0eXBlOiBgdG91Y2htb3ZlYCxcblx0XHRcdGlkZW50aWZpZXI6IHRvdWNoLmlkZW50aWZpZXIsXG5cdFx0XHR0YXJnZXQ6IHRvdWNoLnRhcmdldCxcblx0XHRcdHNjcmVlblg6IHRvdWNoLnNjcmVlblgsXG5cdFx0XHRzY3JlZW5ZOiB0b3VjaC5zY3JlZW5ZLFxuXHRcdFx0Y2xpZW50WDogdG91Y2guY2xpZW50WCxcblx0XHRcdGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG5cdFx0XHRwYWdlWDogdG91Y2gucGFnZVgsXG5cdFx0XHRwYWdlWTogdG91Y2gucGFnZVksXG5cdFx0XHRyYWRpdXNYOiB0b3VjaC5yYWRpdXNYLFxuXHRcdFx0cmFkaXVzWTogdG91Y2gucmFkaXVzWSxcblx0XHRcdHJvdGF0aW9uQW5nbGU6IHRvdWNoLnJvdGF0aW9uQW5nbGUsXG5cdFx0XHRmb3JjZTogdG91Y2guZm9yY2UsXG5cdFx0XHR0aW1lU3RhbXA6IGV2ZW50LnRpbWVTdGFtcCxcblx0XHRcdHByZXZlbnREZWZhdWx0OiA6OmV2ZW50LnByZXZlbnREZWZhdWx0LFxuXHRcdH0gKVxuXHR9XG5cdGxldCBjdXJyZW50ID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyArK2kgKVxuXHRcdGN1cnJlbnRbIGV2ZW50LnRvdWNoZXMuaXRlbSggaSApLmlkZW50aWZpZXIgXSA9IHRydWVcblx0Zm9yICggbGV0IGlkZW50aWZpZXIgaW4gdHJhY2tzIClcblx0XHRpZiAoICEoIGlkZW50aWZpZXIgaW4gY3VycmVudCApIClcblx0XHRcdHJlbW92ZVRyYWNrKCBpZGVudGlmaWVyIClcblx0XHRlbHNlXG5cdFx0XHR0cmFja3NbIGlkZW50aWZpZXIgXS5hYmFuZG9uZWQgPSBmYWxzZVxufVxuXG5sZXQgY29udGFpbmVyID0gZG9jdW1lbnRcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGBtb3VzZWRvd25gLCBldmVudCA9PiB7XG5cdGlmICggZXZlbnQuYnV0dG9uID09IDAgKVxuXHRcdHN0YXJ0VHJhY2soIGBtb3VzZWAsIGV2ZW50IClcblx0ZWxzZSBpZiAoICEoIGV2ZW50LmJ1dHRvbnMgJiAxICkgKVxuXHRcdHJlbW92ZVRyYWNrKCBgbW91c2VgIClcbn0gKVxuXG5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lciggYG1vdXNlbW92ZWAsIGV2ZW50ID0+IHtcblx0aWYgKCBldmVudC5idXR0b25zICYgMSApXG5cdFx0Y29udGludWVUcmFjayggYG1vdXNlYCwgZXZlbnQgKVxuXHRlbHNlXG5cdFx0cmVtb3ZlVHJhY2soIGBtb3VzZWAgKVxufSApXG5cbmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCBgbW91c2V1cGAsIGV2ZW50ID0+IHtcblx0aWYgKCBldmVudC5idXR0b24gPT0gMCApXG5cdFx0c3RvcFRyYWNrKCBgbW91c2VgLCBldmVudCApXG5cdGVsc2UgaWYgKCAhKCBldmVudC5idXR0b25zICYgMSApIClcblx0XHRyZW1vdmVUcmFjayggYG1vdXNlYCApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGB0b3VjaHN0YXJ0YCwgZXZlbnQgPT4ge1xuXHRmb3JUb3VjaGVzKCBldmVudCwgc3RhcnRUcmFjayApXG59IClcblxuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoIGB0b3VjaG1vdmVgLCBldmVudCA9PiB7XG5cdGZvclRvdWNoZXMoIGV2ZW50LCBjb250aW51ZVRyYWNrIClcbn0gKVxuXG5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lciggYHRvdWNoZW5kYCwgZXZlbnQgPT4ge1xuXHRmb3JUb3VjaGVzKCBldmVudCwgc3RvcFRyYWNrIClcbn0gKVxuXG5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lciggYHRvdWNoY2FuY2VsYCwgZXZlbnQgPT4ge1xuXHRmb3JUb3VjaGVzKCBldmVudCwgY2FuY2VsVHJhY2sgKVxufSApXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiB7XG5cdGxldCBDb21tYW5kID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9Db21tYW5kYCApIClcblx0cmV0dXJuIGF0dHIgPT4gPENvbW1hbmRcblx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkRXhpc3RpbmdJdGVtXCJcblx0XHRvbmNsaWNrID0geyAoKSA9PiB7XG5cdFx0XHRhcHAuZGlhbG9nID0gYFNlYXJjaEl0ZW1zYFxuXHRcdFx0YXBwLnNlYXJjaEFjdGlvbiA9IGl0ZW1JZCA9PiB7XG5cdFx0XHRcdGFwcC5saW5rSXRlbSggYXBwLmFjdGl2ZURldmljZUlkLCBpdGVtSWQgKVxuXHRcdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdH1cblx0XHRcdGFwcC5zZWFyY2hGaWx0ZXIgPSBudWxsXG5cdFx0XHRpZiAoIGFwcC5kZXZpY2VUeXBlID09IGBncm91cGAgKVxuXHRcdFx0XHRhcHAuc2VhcmNoRmlsdGVyID0gaXRlbUlkID0+IHtcblx0XHRcdFx0XHRsZXQgZGV2aWNlID0gYXBwLmdldERldmljZSggaXRlbUlkIClcblx0XHRcdFx0XHRyZXR1cm4gZGV2aWNlICYmIGRldmljZS50eXBlID09IGBzaW5nbGVgXG5cdFx0XHRcdH1cblx0XHR9IH1cblx0XHRfID0geyBhdHRyIH1cblx0Lz5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXBwID0+IHtcblx0bGV0IENvbW1hbmQgPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL0NvbW1hbmRgICkgKVxuXHRsZXQgQWRkRXhpc3RpbmdJdGVtID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9BZGRFeGlzdGluZ0l0ZW1gICkgKVxuXHRyZXR1cm4gPGRpdj5cblx0XHQ8QWRkRXhpc3RpbmdJdGVtIC8+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRDcmVhdGVOZXdHcm91cFwiXG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiB7IGFwcC5hZGRHcm91cCggYXBwLmFjdGl2ZURldmljZUlkICkgfSB9XG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZEFkZE5ld0RldmljZVwiXG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiBhcHAuYWRkRGV2aWNlKCBhcHAuYWN0aXZlRGV2aWNlSWQgKSB9XG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZEFkZFBsYWNlXCJcblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IHtcblx0XHRcdFx0Ly8gYXBwLmRpYWxvZyA9IGBBZGRQbGFjZWBcblx0XHRcdFx0YXBwLmFkZFBsYWNlKCBhcHAuYWN0aXZlRGV2aWNlSWQgKVxuXHRcdFx0fSB9XG5cdFx0Lz5cblx0PC9kaXY+XG59XG4iLCIvLyBsZXQgaHR0cENsaWVudCA9IHJlcXVpcmUoIGBodHRwQ2xpZW50YCApXG4vLyBsZXQgY29va2llcyA9IHJlcXVpcmUoIGBjb29raWVzYCApXG5cbm1vZHVsZS5leHBvcnRzID0gKCB7IGFwcGlkLCBJY29uVGVtcGxhdGVzIH0gKSA9PiB7XG5cblx0bGV0IHsgYXBwLCBsb2NhbCB9ID0gcmVxdWlyZSggYGFwcGAgKSggYXBwaWQgKVxuXHRhcHAucGFnZVN0YXJ0aW5nID0gdHJ1ZVxuXG5cdHdpbmRvdy5fYXBwID0gYXBwXG5cdHdpbmRvdy5fbG9jYWwgPSBsb2NhbFxuXHR3aW5kb3cuX2RldmRiID0gcmVxdWlyZSggYGRldmRiYCApXG5cblx0aWYgKCBuYXZpZ2F0b3Iuc3RhbmRhbG9uZSApIHtcblx0XHQvLyBjb29raWVzLnNldEl0ZW0oIGBzdGFuZGFsb25lYCwgMSwgSW5maW5pdHkgKSAtLSDRg9GB0ZEg0LDQtNC90L4g0L3QtSDQv9Cw0YHRjNC/0Y/QstCw0LXQvCDQv9Cw0YHRgtCw0LLRltGG0Ywg0LrRg9C60YMg0L/QtdGA0LDQtCDQv9C10YDRiNGL0Lwg0LfQstCw0YDQvtGC0LDQvCDQtNCwINGB0LXRgNCy0LXRgNCwXG5cdH1cblx0ZWxzZSB7XG5cdFx0cmEoICgpID0+IHtcblx0XHRcdGlmICggbG9jYWwuYWN0aXZlRGV2aWNlSWQgJiYgbG9jYWwuYWN0aXZlRGV2aWNlSWQudmFsdWVPZigpICkge1xuXHRcdFx0XHRsZXQgdGl0bGUgPSBgVElUTEVfJHsgbG9jYWwuYWN0aXZlRGV2aWNlSWQgfWBcblx0XHRcdFx0bGV0IGljb24gPSBgSUNPTl8keyBsb2NhbC5hY3RpdmVEZXZpY2VJZCB9YFxuXHRcdFx0XHRzY3JlZW5UaXRsZS5zZXRBdHRyaWJ1dGUoIGBjb250ZW50YCwgdGl0bGUgKVxuXHRcdFx0XHRpZiAoIGxvY2FsLmFjdGl2ZURldmljZUlkICYmIGxvY2FsLmFjdGl2ZURldmljZUlkICE9IGBtYWluYCApXG5cdFx0XHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUoIG51bGwsIHRpdGxlLCBgP2FwcGljb249JHsgaWNvbiB9YClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGhpc3RvcnkucmVwbGFjZVN0YXRlKCBudWxsLCB0aXRsZSwgYD9gKVxuXHRcdFx0XHQvLyBodHRwQ2xpZW50LnBvc3QoIGAvY29va2llP2FwcGljb249JHsgaWNvbiB9YCwgYGAgKVxuXHRcdFx0XHQvLyBjb29raWVzLnNldEl0ZW0oIGBhcHBpY29uYCwgaWNvbiwgSW5maW5pdHkgKVxuXHRcdFx0XHQvLyBMT0coIGxvY2FsLmFjdGl2ZURldmljZUlkLmJsdWUgKVxuXHRcdFx0fVxuXHRcdH0gKVxuXHR9XG5cblx0bGV0IE1haW5TY3JlZW4gPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL01haW5TY3JlZW5gICkgKVxuXHRsZXQgU3RhcnR1cFNjcmVlbiA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvU3RhcnR1cFNjcmVlbmAgKSApXG5cdGxldCBMb2FkaW5nU2NyZWVuID0gKCkgPT4gPGRpdiBjbGFzcyA9IFwibG9hZGluZ1NjcmVlblwiID48L2Rpdj5cblxuXHRsZXQgYXBwbGljYXRpb24gPSA8ZGl2IGNsYXNzID0geyAoKSA9PiBgXG5cdFx0YXBwbGljYXRpb25cblx0XHQkeyBhcHAucGFnZVN0YXJ0aW5nID8gYHBhZ2VTdGFydGluZ2AgOiBgcGFnZVJ1bm5pbmdgIH1cblx0XHQkeyBhcHAuaW5pdGlhbExvYWRpbmcgPyBgSlNPTmxvYWRpbmdgIDogYEpTT05sb2FkZWRgIH1cblx0XHQkeyBhcHAuaW5pdGlhbGl6ZWQgPyBgYWxyZWFkeVJ1bmAgOiBgZmlyc3RSdW5gIH1cblx0XHQkeyBhcHAuY29ubmVjdGVkVG9TZXJ2ZXIgPyBgYXBwQ29ubmVjdGVkYCA6IGBhcHBEaXNjb25uZWN0ZWRgIH1cblx0XHQkeyBgYCAvKiBhcHAuY3JlZGVudGlhbHMgPT0gbnVsbCA/IGBzaG93TG9naW5gIDogYGhpZGVMb2dpbmAgKi8gfVxuXHRcdCR7IGFwcC50ZW1wbGF0ZXMgPyBgdGVtcGxhdGVzTG9hZGVkYCA6IGB0ZW1wbGF0ZXNMb2FkaW5nYCB9XG5cdFx0JHsgYXBwLmRpYWxvZyAmJiBgZGlhbG9nJHsgYXBwLmRpYWxvZyB9YCB9XG5cdFx0JHsgYXBwLmRpYWxvZyA/IGBkaWFsb2dJc1ByZXNlbnRgIDogYGRpYWxvZ0lzQWJzZW50YCB9XG5cdFx0YXBwX2xhYmVsc18keyAhIWxvY2FsLmxhYmVscyB9XG5cdFx0YXBwX2VkaXRpbmdfJHsgISFhcHAuZWRpdGluZyB9XG5cdGAgfSA+XG5cdFx0PE1haW5TY3JlZW4gLz5cblx0XHQ8U3RhcnR1cFNjcmVlbiAvPlxuXHRcdDxMb2FkaW5nU2NyZWVuIC8+XG5cdDwvZGl2PlxuXG5cdGFwcC5pY29ucyA9IEljb25UZW1wbGF0ZXMucmVkdWNlKCAoIGljb25zLCB0ZW1wbGF0ZSApID0+IHtcblx0XHRpY29uc1sgdGVtcGxhdGUuZGF0YXNldC5uYW1lIF0gPSB0ZW1wbGF0ZVxuXHRcdHJldHVybiBpY29uc1xuXHR9LCBPYmplY3QuY3JlYXRlKCBudWxsICkgKVxuXG5cdGxldCBCdXR0b24gPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL0J1dHRvbmAgKSApXG5cblx0bGV0IENsb3NlRXJyb3IgPSAoIGF0dHIsIHRleHQgKSA9PiB7XG5cdFx0cmV0dXJuIDxwXG5cdFx0XHRvbnRvdWNoID0geyAoKSA9PiB7XG5cdFx0XHRcdGxldCBlcnJvciA9IGFwcC5lcnJvclxuXHRcdFx0XHRhcHAuZGlhbG9nID0gYGBcblx0XHRcdFx0YXBwLmVycm9yID0gbnVsbFxuXHRcdFx0XHRhdHRyLm9uY2xpY2sgJiYgYXR0ci5vbmNsaWNrKCBlcnJvciApXG5cdFx0XHR9IH1cblx0XHRcdF8gPSB7IE9iamVjdC5hc3NpZ24oIHt9LCBhdHRyLCB7IG9uY2xpY2s6IG51bGwgfSApIH1cblx0XHQ+eyB0ZXh0IH08L3A+XG5cdH1cblxuXHRsZXQgQ2xvc2VEaWFsb2cgPSAoIGF0dHIsIHRleHQgKSA9PiB7XG5cdFx0cmV0dXJuIDxwXG5cdFx0XHRvbnRvdWNoID0geyAoKSA9PiB7XG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0XHRhdHRyLm9uY2xpY2sgJiYgYXR0ci5vbmNsaWNrKClcblx0XHRcdH0gfVxuXHRcdFx0XyA9IHsgT2JqZWN0LmFzc2lnbigge30sIGF0dHIsIHsgb25jbGljazogbnVsbCB9ICkgfVxuXHRcdD57IHRleHQgfTwvcD5cblx0fVxuXG5cdC8vIGRpYWxvZ3Ncblx0bGV0IGRpYWxvZ1RlbXBsYXRlcyA9IHtcblxuXHRcdFNlcnZpY2VEaWFsb2c6ICgpID0+IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvU2VydmljZURpYWxvZ2AgKSApLFxuXHRcdENvbnRleHRNZW51OiAoKSA9PiBhcHAubG9hZCggcmVxdWlyZSggYHVpL0NvbnRleHRNZW51YCApICksXG5cdFx0QWRkTWVudTogKCkgPT4gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9BZGRNZW51YCApICksXG5cdFx0U2VhcmNoSXRlbXM6ICgpID0+IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvU2VhcmNoSXRlbXNgICkgKSxcblx0XHRBc2tOZXdOYW1lOiAoKSA9PiBhcHAubG9hZCggcmVxdWlyZSggYHVpL0Fza05ld05hbWVgICkgKSxcblx0XHRBc2tUb0xpbmtEZXZpY2U6ICgpID0+IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQXNrVG9MaW5rRGV2aWNlYCApICksXG5cblx0XHRBc2tJZkRldmljZUhhc0JlZW5MaW5rZWQ6ICgpID0+IDxkaXY+XG5cdFx0XHQ8cD7Qo9GB0YLRgNC+0LnRgdGC0LLQviDQsdGL0LvQviDRg9GB0L/QtdGI0L3QviDQv9GA0LjQstGP0LfQsNC90L4/PC9wPlxuXHRcdFx0PEJ1dHRvbiBvbmNsaWNrID0gXCJTdG9wRGV2aWNlTm90aWZpY2F0aW9uXCIgPtC00LA8L0J1dHRvbj5cblx0XHRcdDxCdXR0b24gb25jbGljayA9IFwiQXNrVG9MaW5rRGV2aWNlXCIgPtC90LXRgjwvQnV0dG9uPlxuXHRcdDwvZGl2PixcblxuXHRcdFN0b3BEZXZpY2VOb3RpZmljYXRpb246ICgpID0+IDxkaXY+XG5cdFx0XHQ8cD7Qn9C+0LbQsNC70YPQudGB0YLQsCw8YnIvPtC/0LXRgNC10LLQtdC00LjRgtC1INGD0YHRgtGA0L7QudGB0YLQstC+INCyINGA0LDQsdC+0YfQuNC5INGA0LXQttC40LwuPC9wPlxuXHRcdFx0PEJ1dHRvbj7Ql9Cw0LrRgNGL0YLRjDwvQnV0dG9uPlxuXHRcdDwvZGl2PixcblxuXHRcdEVycm9yTm9DYXJyaWVyOiAoKSA9PiA8ZGl2IGNsYXNzID0gXCJlcnJvckRpYWxvZ1wiID5cblx0XHRcdDxwPtCe0YjQuNCx0LrQsDwvcD5cblx0XHRcdDxwPtCf0YDQvtC40LfQvtGI0LvQsCDQvtGI0LjQsdC60LAg0L/RgNC4INC/0L7Qv9GL0YLQutC1INGB0LLRj9C30LDRgtGM0YHRjyDRgSDQvNC+0LTQtdC80L7QvC48L3A+XG5cdFx0XHQ8QnV0dG9uPtCX0LDQutGA0YvRgtGMPC9CdXR0b24+XG5cdFx0PC9kaXY+LFxuXG5cdFx0RXJyb3JVbmxpbmtpbmdEZXZpY2U6ICgpID0+IDxkaXYgY2xhc3MgPSBcImVycm9yRGlhbG9nXCIgPlxuXHRcdFx0PHA+0J7RiNC40LHQutCwPC9wPlxuXHRcdFx0PHA+0J3QtSDRg9C00LDQu9C+0YHRjCDRgdCy0Y/Qt9Cw0YLRjNGB0Y8g0YEg0YPRgdGC0YDQvtC50YHRgtCy0L7QvCDQuCDQvtGC0LLRj9C30LDRgtGMINC10LPQvi48L3A+XG5cdFx0XHQ8cD7Qp9GC0L4g0YHQu9C10LTRg9C10YIg0YHQtNC10LvQsNGC0Yw/PC9wPlxuXHRcdFx0PHVsPlxuXHRcdFx0PENsb3NlRXJyb3Igb25jbGljayA9IHsgZXJyb3IgPT4gYXBwLnB1cmdlSXRlbSggZXJyb3IuZGF0YS5kZXZpY2VJZCApIH1cblx0XHRcdFx0PjxsaT7Qn9C+0L/Ri9GC0LDRgtGM0YHRjyDQvtGC0LLRj9C30LDRgtGMINGD0YHRgtGA0L7QudGB0YLQstC+INC10YnRkSDRgNCw0Lc8L2xpPjwvQ2xvc2VFcnJvcj5cblx0XHRcdDxDbG9zZUVycm9yXG5cdFx0XHRcdD48bGk+0J7RgtC80LXQvdC40YLRjCDRg9C00LDQu9C10L3QuNC1PC9saT48L0Nsb3NlRXJyb3I+XG5cdFx0XHQ8Q2xvc2VFcnJvciBvbmNsaWNrID0geyBlcnJvciA9PiBhcHAucHVyZ2VJdGVtKCBlcnJvci5kYXRhLmRldmljZUlkLCB0cnVlICkgfVxuXHRcdFx0XHQ+PGxpPtCX0LDQsdGL0YLRjCDQuNC90YTQvtGA0LzQsNGG0LjRjiDQvtCxINGD0YHRgtGA0L7QudGB0YLQstC1PC9saT48L0Nsb3NlRXJyb3I+XG5cdFx0XHQ8L3VsPlxuXHRcdDwvZGl2PixcblxuXHRcdERlbGV0ZURldmljZTogKCkgPT4gPGRpdj5cblx0XHRcdDxwPnsgKCB7XG5cdFx0XHRcdHBsYWNlOiA8c3Bhbj7Qn9C+0LzQtdGJ0LXQvdC40LUgKNC80LXRgdGC0L4pIFwieyBhcHAuY2FwdGlvbiB9XCIg0LHRg9C00LXRgiDRg9C00LDQu9C10L3QviDQuNC3INC/0YDQvtCz0YDQsNC80LzRiy48L3NwYW4+LFxuXHRcdFx0XHRzaW5nbGU6IDxzcGFuPtCj0YHRgtGA0L7QudGB0YLQstC+IFwieyBhcHAuY2FwdGlvbiB9XCIg0LHRg9C00LXRgiDRg9C00LDQu9C10L3QviDQuNC3INC/0YDQvtCz0YDQsNC80LzRiy48L3NwYW4+LFxuXHRcdFx0XHRncm91cDogPHNwYW4+0JPRgNGD0L/Qv9CwIFwieyBhcHAuY2FwdGlvbiB9XCIg0LHRg9C00LXRgiDRg9C00LDQu9C10L3QsCDQuNC3INC/0YDQvtCz0YDQsNC80LzRiy48L3NwYW4+LFxuXHRcdFx0fSApWyBhcHAuZGV2aWNlVHlwZSBdIH08L3A+XG5cdFx0XHQ8dWw+XG5cdFx0XHQ8Q2xvc2VEaWFsb2cgY2xhc3MgPSBcImRhbmdlcm91c0FjdGlvblwiIG9uY2xpY2sgPSB7ICgpID0+IGFwcC5wdXJnZUl0ZW0oIGFwcC5hY3RpdmVEZXZpY2VJZCApIH1cblx0XHRcdFx0PjxsaT7Qo9C00LDQu9C40YLRjDwvbGk+PC9DbG9zZURpYWxvZz5cblx0XHRcdDxDbG9zZURpYWxvZ1xuXHRcdFx0XHQ+PGxpPtCd0LUg0YPQtNCw0LvRj9GC0Yw8L2xpPjwvQ2xvc2VEaWFsb2c+XG5cdFx0XHQ8L3VsPlxuXHRcdDwvZGl2PixcblxuXHRcdFN0YXRlV2FpdDogKCkgPT4gPGRpdj5cblx0XHRcdDxwPtCf0L7QtNC+0LbQtNC40YLQtS4uLjwvcD5cblx0XHQ8L2Rpdj4sXG5cblx0XHRBc2tUb1Jlc2V0OiAoKSA9PiA8ZGl2PlxuXHRcdFx0PHA+0J/QsNC80Y/RgtGMINC60L7QvdGC0YDQvtC70LvQtdGA0LAg0LHRg9C00LXRgiDQvtGH0LjRidC10L3QsCw8YnIvPtC90L4g0L/QsNC80Y/RgtGMINGD0YHRgtGA0L7QudGB0YLQsiDQvtGH0LjRidCw0YLRjNGB0Y8g0L3QtSDQsdGD0LTQtdGCLjwvcD5cblx0XHRcdDxCdXR0b24gY2xhc3MgPSBcImRhbmdlcm91c0FjdGlvblwiIG9uY2xpY2sgPSB7IGFwcC5yZXNldCB9ID7QntGH0LjRgdGC0LjRgtGMPGJyLz7Qv9Cw0LzRj9GC0Yw8L0J1dHRvbj5cblx0XHQ8L2Rpdj4sXG5cblx0XHQvLyBBZGRQbGFjZSxcblx0XHQvLyBBZGREZXZpY2UsXG5cdH1cblxuXHRyYSggKCkgPT4ge1xuXHRcdGxldCBkaWFsb2dOYW1lID0gYXBwLmRpYWxvZ1xuXHRcdGlmICggIWRpYWxvZ05hbWUgKVxuXHRcdFx0cmV0dXJuXG5cblx0XHRpZiAoICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIGRpYWxvZ1RlbXBsYXRlcywgZGlhbG9nTmFtZSApICkge1xuXHRcdFx0YWxlcnQoIGBFcnJvcjogQ291bGQgbm90IGZpbmQgZGlhbG9nIG5hbWVkXFxuXCIkeyBkaWFsb2dOYW1lIH1cImAgKVxuXHRcdFx0cmEuZGV0YWNoKCAoKSA9PiBhcHAuZGlhbG9nID0gYGAgKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGxldCBUZW1wbGF0ZSA9IGRpYWxvZ1RlbXBsYXRlc1sgZGlhbG9nTmFtZSBdXG5cdFx0aWYgKCAhVGVtcGxhdGUgKVxuXHRcdFx0cmV0dXJuXG5cdFx0ZGlhbG9nVGVtcGxhdGVzWyBkaWFsb2dOYW1lIF0gPSBudWxsXG5cblx0XHRsZXQgZGlhbG9nID0gVGVtcGxhdGUoKVxuXHRcdGRpYWxvZy5jbGFzc0xpc3QuYWRkKCBkaWFsb2dOYW1lIClcblx0XHRkaWFsb2cuY2xhc3NMaXN0LmFkZCggYG1vZGFsRGlhbG9nYCApXG5cdFx0cmEoIHtcblx0XHRcdGdldCBpc0FjdGl2ZSgpIHsgcmV0dXJuIGRpYWxvZ05hbWUgPT0gYXBwLmRpYWxvZyB9LFxuXHRcdFx0Z2V0IHVwZGF0ZUNsYXNzKCkge1xuXHRcdFx0XHRsZXQgZXZlbnRcblx0XHRcdFx0aWYgKCB0aGlzLmlzQWN0aXZlICkge1xuXHRcdFx0XHRcdGV2ZW50ID0gYGRpYWxvZ3Nob3dgXG5cdFx0XHRcdFx0ZGlhbG9nLmNsYXNzTGlzdC5hZGQoIGBkaWFsb2dTaG93bmAgKVxuXHRcdFx0XHRcdGRpYWxvZy5jbGFzc0xpc3QucmVtb3ZlKCBgZGlhbG9nSGlkZGVuYCApXG5cdFx0XHRcdFx0bGV0IGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoIGAqWyBhdXRvZm9jdXMgXWAgKVxuXHRcdFx0XHRcdGlmICggaW5wdXQgKVxuXHRcdFx0XHRcdFx0YXBwLmZvY3VzKCBpbnB1dCApXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZXZlbnQgPSBgZGlhbG9naGlkZWBcblx0XHRcdFx0XHRkaWFsb2cuY2xhc3NMaXN0LnJlbW92ZSggYGRpYWxvZ1Nob3duYCApXG5cdFx0XHRcdFx0ZGlhbG9nLmNsYXNzTGlzdC5hZGQoIGBkaWFsb2dIaWRkZW5gIClcblx0XHRcdFx0XHRmb3IgKCBsZXQgZWxlbSBvZiBkaWFsb2cucXVlcnlTZWxlY3RvckFsbCggYCo6Zm9jdXNgICkgKVxuXHRcdFx0XHRcdFx0ZWxlbS5ibHVyKClcblx0XHRcdFx0XHRkaWFsb2cuYmx1cigpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlhbG9nLmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudCggZXZlbnQsIHsgZGV0YWlsOiBudWxsIH0gKSApXG5cdFx0XHR9LFxuXHRcdH0gKVxuXHRcdGFwcGxpY2F0aW9uLmFwcGVuZENoaWxkKCBkaWFsb2cgKVxuXHR9IClcblxuXHRzZXRUaW1lb3V0KCAoKSA9PiBhcHAucGFnZVN0YXJ0aW5nID0gZmFsc2UsIDEgKVxuXG5cdHJldHVybiBhcHBsaWNhdGlvblxufVxuIiwibGV0IGh0bWx1dGlscyA9IHJlcXVpcmUoIGBodG1sdXRpbHNgIClcblxubW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4ge1xuXHRsZXQgJCA9IHt9XG5cdHJldHVybiA8ZGl2IG9uZGlhbG9nc2hvdyA9IHsgKCkgPT4ge1xuXHRcdCQuc3RyaW5nLnZhbHVlID0gYXBwLmdldE1lc3NhZ2UoIGFwcC5nZXREZXZpY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCApIClcblx0XHQkLnN0cmluZy5zZXRTZWxlY3Rpb25SYW5nZSggMCwgJC5zdHJpbmcudmFsdWUubGVuZ3RoIClcblx0fSB9ID5cblx0XHQ8cD7QndCw0LfQstCw0L3QuNC1OjwvcD5cblx0XHQ8Zm9ybSBvbnN1Ym1pdCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0ZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0bGV0IG5hbWUgPSAkLnN0cmluZy52YWx1ZS50cmltKClcblx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0aWYgKCBuYW1lIClcblx0XHRcdFx0YXBwLnJlbmFtZUl0ZW0oIGFwcC5hY3RpdmVEZXZpY2VJZCwgbmFtZSApXG5cdFx0fSB9ID5cblx0XHRcdHsgJC5zdHJpbmcgPSA8dGV4dGFyZWEgbmFtZSA9IFwic3RyaW5nXCIgY29scyA9IFwiMzVcIiByb3dzID0gXCIyXCIgYXV0b2ZvY3VzID0gXCJhdXRvZm9jdXNcIiAvPiB9XG5cdFx0XHQ8cD48YSBjbGFzcyA9IFwiYnV0dG9uXCIgaHJlZiA9IFwiamF2YXNjcmlwdDp2b2lkKDApXCIgdGFyZ2V0ID0gXCJfc2VsZlwiIG9udG91Y2ggPSB7IGh0bWx1dGlscy5TdWJtaXQgfSA+0JfQsNC60YDRi9GC0Yw8L2E+PC9wPlxuXHRcdDwvZm9ybT5cblx0PC9kaXY+XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiB7XG5cdGxldCBCdXR0b24gPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL0J1dHRvbmAgKSApXG5cdHJldHVybiA8ZGl2PlxuXHRcdDxwPtCf0L7QttCw0LvRg9C50YHRgtCwLDxici8+0L/QtdGA0LXQstC10LTQuNGC0LUg0YPRgdGC0YDQvtC50YHRgtCy0L4g0LIg0YDQtdC20LjQvDxici8+0L/RgNC+0LPRgNCw0LzQvNC40YDQvtCy0LDQvdC40Y8g0Lgg0L3QsNC20LzQuNGC0LU8L3A+XG5cdFx0PEJ1dHRvbiBvbmNsaWNrID0geyAoKSA9PiB7XG5cdFx0XHRsZXQgcGxhY2VJZCA9IGFwcC5saW5raW5nUGxhY2VJZCB8fCBhcHAuYWN0aXZlRGV2aWNlSWRcblx0XHRcdGFwcC5kaWFsb2cgPSBgU3RhdGVXYWl0YFxuXHRcdFx0Y28uZ28oIGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHRcdHlpZWxkIGFwcC5jb21tYW5kKCBwbGFjZUlkLCBgTGlua2AgKVxuXHRcdFx0XHRhcHAuZGlhbG9nID0gYEFza0lmRGV2aWNlSGFzQmVlbkxpbmtlZGBcblx0XHRcdFx0YXBwLmxpbmtpbmdQbGFjZUlkID0gcGxhY2VJZFxuXHRcdFx0fSApLmNhdGNoKCBlcnJvciA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCBlcnJvciApXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgRXJyb3JOb0NhcnJpZXJgXG5cdFx0XHR9IClcblx0XHR9IH1cblx0XHQ+0LfQtNC10YHRjDwvQnV0dG9uPlxuXHQ8L2Rpdj5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXBwID0+ICggYXR0ciwgY29udGVudCApID0+XG5cdDxhIGNsYXNzID0gXCJidXR0b25cIiBocmVmID0gXCJqYXZhc2NyaXB0OnZvaWQoMClcIiB0YXJnZXQgPSBcIl9zZWxmXCIgb250b3VjaCA9IHsgZXZlbnQgPT4ge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHRpZiAoIHR5cGVvZiBhdHRyLm9uY2xpY2sgPT0gYHN0cmluZ2AgKVxuXHRcdFx0YXBwLmRpYWxvZyA9IGF0dHIub25jbGlja1xuXHRcdGVsc2Uge1xuXHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRhdHRyLm9uY2xpY2sgJiYgYXR0ci5vbmNsaWNrKClcblx0XHR9XG5cdH0gfVxuXHRfID0geyBPYmplY3QuYXNzaWduKCB7fSwgYXR0ciwgeyBvbmNsaWNrOiBudWxsIH0gKSB9XG5cdD57XG5cdFx0Y29udGVudFxuXHR9PC9hPlxuIiwibW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4gKCB7IG9uY2xpY2ssIHVybCwgdmlzaWJsZSwgZW5hYmxlZCwgbWVzc2FnZSB9ICkgPT4ge1xuXHRsZXQgY29udGVudCA9IGFwcC5tZXNzYWdlKCBtZXNzYWdlIClcblx0bGV0IGlzRW5hYmxlZCA9ICgpID0+ICggdXJsIHx8IG9uY2xpY2sgKSAmJiAoICFlbmFibGVkIHx8IGVuYWJsZWQoKSApXG5cdGlmICggdHlwZW9mIHZpc2libGUgPT0gYHN0cmluZ2AgKSB7XG5cdFx0bGV0IGRldmljZVR5cGUgPSB2aXNpYmxlXG5cdFx0dmlzaWJsZSA9ICgpID0+IGFwcC5kZXZpY2VUeXBlID09IGRldmljZVR5cGVcblx0fVxuXHRsZXQgY2xhc3NOYW1lID0gKCkgPT4gYGNvbW1hbmQgJHsgbWVzc2FnZSB9ICR7IGlzRW5hYmxlZCgpID8gYGVuYWJsZWRgIDogYGRpc2FibGVkYCB9ICR7IHZpc2libGUgPT0gbnVsbCB8fCB2aXNpYmxlKCkgPyBgaXRlbVZpc2libGVgIDogYGl0ZW1IaWRkZW5gIH1gXG5cdGlmICggdXJsICYmICFvbmNsaWNrIClcblx0XHRyZXR1cm4gPGEgY2xhc3MgPSB7IGNsYXNzTmFtZSB9IGhyZWYgPSB7IHVybCB9IHJlbCA9IFwiZXh0ZXJuYWxcIiB0YXJnZXQgPSBcIl9ibGFua1wiID57IGNvbnRlbnQgfTwvYT5cblx0ZWxzZVxuXHRcdHJldHVybiA8YSBjbGFzcyA9IHsgY2xhc3NOYW1lIH0gaHJlZiA9IFwiamF2YXNjcmlwdDp2b2lkKDApXCIgdGFyZ2V0ID0gXCJfc2VsZlwiIG9udG91Y2ggPSB7IGV2ZW50ID0+IHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHRcdGlmICggb25jbGljayAmJiBpc0VuYWJsZWQoKSApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2Ygb25jbGljayA9PSBgc3RyaW5nYCApXG5cdFx0XHRcdFx0YXBwLmRpYWxvZyA9IG9uY2xpY2tcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YXBwLmRpYWxvZyA9IGBgXG5cdFx0XHRcdFx0b25jbGljaygpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IH0gPnsgY29udGVudCB9PC9hPlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSAoIGFwcCwgbG9jYWwgKSA9PiB7XG5cdGxldCBDb21tYW5kID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9Db21tYW5kYCApIClcblx0bGV0IEFkZEV4aXN0aW5nSXRlbSA9IGFwcC5sb2FkKCByZXF1aXJlKCBgdWkvQWRkRXhpc3RpbmdJdGVtYCApIClcblx0cmV0dXJuIDxkaXY+XG5cdFx0PENvbW1hbmRcblx0XHRcdG1lc3NhZ2UgPSBcImNvbW1hbmRTZWFyY2hEZXZpY2VzXCJcblx0XHRcdG9uY2xpY2sgPSBcIlNlYXJjaEl0ZW1zXCJcblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kVG9GYXZvdXJpdGVzXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuYWN0aXZlRGV2aWNlSWQgIT0gYXBwLm1haW4gfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4ge1xuXHRcdFx0XHRhcHAubGlua0FjdGl2ZVRvRmF2b3VyaXRlcygpXG5cdFx0XHRcdGFwcC5ub3RpZmljYXRpb24oIGDQlNC+0LHQsNCy0LvQtdC90L4g0LIg0LjQt9Cx0YDQsNC90L3QvtC1YCApXG5cdFx0XHR9IH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kTGlua0RldmljZVwiXG5cdFx0XHR2aXNpYmxlID0gXCJkZXZpY2VcIlxuXHRcdFx0b25jbGljayA9IFwiQXNrVG9MaW5rRGV2aWNlXCJcblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kQWRkXCJcblx0XHRcdHZpc2libGUgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBhcHAuZGV2aWNlVHlwZSA9PSBgcGxhY2VgIH1cblx0XHRcdG9uY2xpY2sgPSBcIkFkZE1lbnVcIlxuXHRcdC8+XG5cdFx0PEFkZEV4aXN0aW5nSXRlbVxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZEFkZFwiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgYXBwLmRldmljZVR5cGUgPT0gYGdyb3VwYCB9XG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZE1vdmVJY29uc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgYXBwLmRldmljZVR5cGUgIT0gYHNpbmdsZWAgfVxuXHRcdFx0b25jbGljayA9IHsgKCkgPT4gYXBwLmVkaXRpbmcgPSB0cnVlIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kUmVuYW1lSXRlbVwiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgfVxuXHRcdFx0b25jbGljayA9IFwiQXNrTmV3TmFtZVwiXG5cdFx0Lz5cblx0XHQ8Q29tbWFuZFxuXHRcdFx0bWVzc2FnZSA9IFwiY29tbWFuZFB1cmdlSXRlbVwiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgYXBwLmFjdGl2ZURldmljZUlkICE9IGFwcC5tYWluIH1cblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IHtcblx0XHRcdFx0YXBwLmRpYWxvZyA9IGBEZWxldGVEZXZpY2VgXG5cdFx0XHRcdC8vIGFwcC5wdXJnZUl0ZW0oIGFwcC5hY3RpdmVEZXZpY2VJZCApXG5cdFx0XHR9IH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kU2hvd0xhYmVsc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiAhbG9jYWwubGFiZWxzICYmIGFwcC5hY3RpdmVEZXZpY2VJZCA9PSBhcHAubWFpbiB9XG5cdFx0XHRvbmNsaWNrID0geyAoKSA9PiBsb2NhbC5sYWJlbHMgPSB0cnVlIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kSGlkZUxhYmVsc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiBsb2NhbC5sYWJlbHMgJiYgYXBwLmFjdGl2ZURldmljZUlkID09IGFwcC5tYWluIH1cblx0XHRcdG9uY2xpY2sgPSB7ICgpID0+IGxvY2FsLmxhYmVscyA9IGZhbHNlIH1cblx0XHQvPlxuXHRcdDxDb21tYW5kXG5cdFx0XHRtZXNzYWdlID0gXCJjb21tYW5kUmVzZXRUb0ZhY3RvcnlTZXR0aW5nc1wiXG5cdFx0XHR2aXNpYmxlID0geyAoKSA9PiBhcHAuYWN0aXZlRGV2aWNlSWQgPT0gYXBwLm1haW4gfVxuXHRcdFx0ZW5hYmxlZCA9IHsgKCkgPT4gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICE9IGB0ZXN0LnNoLm5lcm9lbGVjdHJvbmljcy5ieWAgfVxuXHRcdFx0b25jbGljayA9IFwiQXNrVG9SZXNldFwiXG5cdFx0Lz5cblx0PC9kaXY+XG59XG4iLCJsZXQgbG9kYXNoID0gcmVxdWlyZSggYGxvZGFzaGAgKVxubGV0IGh0bWx1dGlscyA9IHJlcXVpcmUoIGBodG1sdXRpbHNgIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGFwcCwgbG9jYWwgKSA9PiAoIHsgcGxhY2VJZCwgaWNvbklkLCBpY29uRGVzY3IsIHBvc2l0aW9uIH0gKSA9PiB7XG5cdC8vIFRPRE86IHJlZmFjdG9yaW5nOiBtb3ZlIHRvIG1vcmUgSlNYICg/KVxuXHQvLyBUT0RPOiBvblRhcCwgb25QcmVzcywgb25DbGljayBoYW5kbGVycyBtdXN0IHJlbW92ZSB0aGVtc2VsZiB3aGVuIHRocmVhZCBpcyBiZWluZyBraWxsZWRcblx0bGV0IGljb24sIG9mZiwgb24sIGFic2VudCwgaW1hZ2Vcblx0bGV0IGlzTW91c2UgPSBmYWxzZVxuXG5cdGxldCBwbGFjZVJlY3QgPSBodG1sdXRpbHMudGlja0NhY2hlKCAoKSA9PiB7XG5cdFx0bGV0IHggPSBpY29uLnBhcmVudE5vZGVcblx0XHRsZXQgclxuXHRcdHdoaWxlICggciA9IHguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksICFyLndpZHRoIHx8ICFyLmhlaWdodCApXG5cdFx0XHR4ID0geC5wYXJlbnROb2RlXG5cdFx0cmV0dXJuIHJcblx0fSApXG5cblx0bGV0IHJlbFBvaW50ID0gcCA9PiB7XG5cdFx0bGV0IHIgPSBwbGFjZVJlY3QoKVxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiAoIHAueCAtIHIubGVmdCApIC8gci53aWR0aCAqIDEwMCxcblx0XHRcdHk6ICggcC55IC0gci50b3AgKSAvIHIuaGVpZ2h0ICogMTAwLFxuXHRcdH1cblx0fVxuXG5cdGxldCBnZXRQb2ludCA9IGRhdGEgPT4ge1xuXHRcdHJldHVybiByZWxQb2ludCggeyB4OiBkYXRhLnBhZ2VYLCB5OiBkYXRhLnBhZ2VZIH0gKVxuXHR9XG5cblx0bGV0IGdldExlZnRUb3AgPSBkYXRhID0+IHtcblx0XHRsZXQgcCA9IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblx0XHRyZXR1cm4gcmVsUG9pbnQoIHsgeDogcC5sZWZ0LCB5OiBwLnRvcCB9IClcblx0fVxuXG5cdC8vIGxldCBpY29uc0NvdW50ID0gKCkgPT4ge1xuXHQvLyBcdGxldCBwbGFjZSA9IGFwcC5nZXREZXZpY2UoIHBsYWNlSWQgKVxuXHQvLyBcdHJldHVybiBsb2Rhc2gua2V5cyggcGxhY2UgJiYgcGxhY2UuY29udGVudCApLmxlbmd0aFxuXHQvLyB9XG5cblx0bGV0IGltYWdlSGVpZ2h0ID0gaHRtbHV0aWxzLnRpY2tDYWNoZSggKCkgPT4ge1xuXHRcdGlmICggIWlzTW91c2UgKVxuXHRcdFx0cmV0dXJuIGljb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG5cdFx0aWYgKCBvcHRzLmljb25EYXRhICkge1xuXHRcdFx0aWYgKCBvcHRzLmljb25EYXRhLmRldmljZUltYWdlR2V0SGVpZ2h0ICkge1xuXHRcdFx0XHRsZXQgciA9IG9wdHMuaWNvbkRhdGEuZGV2aWNlSW1hZ2VHZXRIZWlnaHQoKVxuXHRcdFx0XHRpZiAoIHIgKVxuXHRcdFx0XHRcdHJldHVybiByXG5cdFx0XHR9XG5cdFx0XHRsZXQgaCA9IG9wdHMuaWNvbkRhdGEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggYGRldmljZV9pbWFnZV9oZWlnaHRgIClbIDAgXVxuXHRcdFx0aWYgKCBoICE9IG51bGwgJiYgaC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgKSB7XG5cdFx0XHRcdGxldCByID0gaC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblx0XHRcdFx0aWYgKCByIClcblx0XHRcdFx0XHRyZXR1cm4gclxuXHRcdFx0fVxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb3B0cy5pY29uRGF0YS5jaGlsZE5vZGVzLmxlbmd0aDsgKytpICkge1xuXHRcdFx0XHRsZXQgciA9IG9wdHMuaWNvbkRhdGEuY2hpbGROb2Rlcy5pdGVtKCBpIClcblx0XHRcdFx0aWYgKCByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCApIHtcblx0XHRcdFx0XHRyID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblx0XHRcdFx0XHRpZiAoIHIgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaW1hZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG5cdH0gKVxuXG5cdGxldCBvcHRzID0gcmEoIHtcblxuXHRcdGdldCBpY29uTmFtZSgpIHsgcmV0dXJuIGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpICYmIGljb25EZXNjci52YWx1ZU9mKCkuaWNvbiB8fCBudWxsIH0sXG5cdFx0Z2V0IGljb25UZW1wbGF0ZSgpIHsgcmV0dXJuIHRoaXMuaWNvbk5hbWUgJiYgYXBwLmljb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggYXBwLmljb25zLCB0aGlzLmljb25OYW1lICkgJiYgYXBwLmljb25zWyB0aGlzLmljb25OYW1lIF0gfHwgbnVsbCB9LFxuXHRcdGljb25EYXRhOiBudWxsLFxuXHRcdGdldCB1cGRhdGVJY29uRGF0YVN0YXRlKCkge1xuXHRcdFx0bGV0IGRhdGEgPSB0aGlzLmljb25EYXRhXG5cdFx0XHRpZiAoIGRhdGEgJiYgZGF0YS5kZXZpY2VTZXRTdGF0ZSApXG5cdFx0XHRcdGRhdGEuZGV2aWNlU2V0U3RhdGUoIHRoaXMuc3RhdGUgKVxuXHRcdH0sXG5cblx0XHRnZXQgZGltbWVyaW5nKCkge1xuXHRcdFx0bGV0IGkgPSBpY29uRGVzY3IgPT0gbnVsbCA/IG51bGwgOiBpY29uRGVzY3IudmFsdWVPZigpXG5cdFx0XHRsZXQgaWQgPSBpID09IG51bGwgPyBudWxsIDogaS5kaW1tZXJpbmcgPT0gbnVsbCA/IG51bGwgOiAhIWkuZGltbWVyaW5nXG5cdFx0XHRpZiAoIGlkICE9IG51bGwgKVxuXHRcdFx0XHRyZXR1cm4gaWRcblx0XHRcdGlmICggaSAhPSBudWxsICYmIGkudHlwZSA9PT0gYHBsYWNlYCApXG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9LFxuXHRcdGdldCBpbWFnZV9vbigpIHtcblx0XHRcdGxldCBpID0gaWNvbkRlc2NyICYmIGljb25EZXNjci52YWx1ZU9mKClcblx0XHRcdGxldCBmaWxlID0gYGBcblx0XHRcdFx0fHwgaSAmJiBpLmltYWdlX29uXG5cdFx0XHRcdHx8IGkgJiYgaS5pbWFnZVxuXHRcdFx0cmV0dXJuIGZpbGUgJiYgYC9pbWFnZXMvJHsgZmlsZSB9YFxuXHRcdH0sXG5cdFx0Z2V0IHVwZGF0ZV9pbWFnZV9vbigpIHtcblx0XHRcdGlmICggb3B0cy5pbWFnZV9vbiApXG5cdFx0XHRcdG9uLnNyYyA9IG9wdHMuaW1hZ2Vfb25cblx0XHR9LFxuXHRcdGdldCBpbWFnZV9vZmYoKSB7XG5cdFx0XHRsZXQgaSA9IGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpXG5cdFx0XHRsZXQgZmlsZSA9IGBgXG5cdFx0XHRcdHx8IGkgJiYgaS5pbWFnZV9vZmZcblx0XHRcdFx0fHwgaSAmJiBpLmltYWdlXG5cdFx0XHRyZXR1cm4gZmlsZSAmJiBgL2ltYWdlcy8keyBmaWxlIH1gXG5cdFx0fSxcblx0XHRnZXQgdXBkYXRlX2ltYWdlX29mZigpIHtcblx0XHRcdGlmICggb3B0cy5pbWFnZV9vZmYgKVxuXHRcdFx0XHRvZmYuc3JjID0gb3B0cy5pbWFnZV9vZmZcblx0XHR9LFxuXG5cdFx0aWNvbkNvbW1hbmQoIGNtZCwgZGF0YSApIHsgcmV0dXJuIGFwcC5pY29uQ29tbWFuZCggaWNvbkRlc2NyLCBpY29uSWQsIGNtZCwgZGF0YSApIH0sXG5cblx0XHRpc0RpbW1lcmluZzogZmFsc2UsXG5cdFx0bW92aW5nOiBmYWxzZSxcblx0XHRtb3ZlZDogZmFsc2UsXG5cdFx0eDogbnVsbCxcblx0XHR5OiBudWxsLFxuXG5cdFx0Z2V0IHByZXNlbnQoKSB7IHJldHVybiAhISggaWNvbkRlc2NyLmdldCggYGNvbnRlbnRgICkgfHwgaWNvbkRlc2NyLmdldCggYGdyb3VwYCApICkgfSxcblx0XHRzdGF0ZTogMCxcblx0XHRvbm5pbmc6IGZhbHNlLFxuXHRcdG9mZmluZzogZmFsc2UsXG5cdFx0ZmluYWw6IHRydWUsXG5cdFx0ZXJyb3JuZW91czogZmFsc2UsXG5cdFx0Z2V0IHVwZGF0ZVN0YXRlKCkge1xuXHRcdFx0bGV0IGQgPSBpY29uRGVzY3IgJiYgaWNvbkRlc2NyLnZhbHVlT2YoKVxuXHRcdFx0aWYgKCAhZCApXG5cdFx0XHRcdHJldHVybiAwXG5cdFx0XHRpZiAoIGQubmV3c3RhdGVfdGltZXN0YW1wICYmICggIWQuc3RhdGVfdGltZXN0YW1wIHx8IGQubmV3c3RhdGVfdGltZXN0YW1wID4gZC5zdGF0ZV90aW1lc3RhbXAgKSApIHtcblx0XHRcdFx0bGV0IGZvbm5pbmcgPSBkLm5ld3N0YXRlID49IGQuc3RhdGVcblx0XHRcdFx0dGhpcy5vbm5pbmcgPSBmb25uaW5nXG5cdFx0XHRcdHRoaXMub2ZmaW5nID0gIWZvbm5pbmdcblx0XHRcdFx0dGhpcy5maW5hbCA9IGZhbHNlXG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBkLm5ld3N0YXRlXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5vbm5pbmcgPSBmYWxzZVxuXHRcdFx0XHR0aGlzLm9mZmluZyA9IGZhbHNlXG5cdFx0XHRcdHRoaXMuZmluYWwgPSB0cnVlXG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBkLnN0YXRlXG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVycm9ybmVvdXMgPSAhIWQuZXJyb3JuZW91c1xuXHRcdH0sXG5cblx0XHRzZXRPcGFjaXR5KCBub2RlLCBvcGFjaXR5ICkge1xuXHRcdFx0aWYgKCBvcGFjaXR5ID09IG51bGwgKSB7XG5cdFx0XHRcdGRlbGV0ZSBub2RlLnN0eWxlLm9wYWNpdHlcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRub2RlLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXQgdXBkYXRlT3BhY2l0eSgpIHtcblx0XHRcdGlmICggdGhpcy5pY29uVGVtcGxhdGUgKSB7XG5cdFx0XHRcdG9uLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiXG5cdFx0XHRcdG9mZi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIlxuXHRcdFx0XHRhYnNlbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCJcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhdGhpcy5wcmVzZW50ICkge1xuXHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9uLCAwIClcblx0XHRcdFx0dGhpcy5zZXRPcGFjaXR5KCBvZmYsIDAgKVxuXHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIGFic2VudCwgMC43IClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIGFic2VudCwgMCApXG5cdFx0XHRcdGlmICggdGhpcy5kaW1tZXJpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRPcGFjaXR5KCBvbiwgdGhpcy5zdGF0ZSApXG5cdFx0XHRcdFx0dGhpcy5zZXRPcGFjaXR5KCBvZmYsICggMSAtIHRoaXMuc3RhdGUgKSAqIDAuMzMzIClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9uLCArISF0aGlzLnN0YXRlIClcblx0XHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoIG9mZiwgKyF0aGlzLnN0YXRlIClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH0gKVxuXG5cdGNvbnN0IE1PVkVfUEFHRV9ESVNUID0gMC4xXG5cdGNvbnN0IE1PVkVfU0lERV9ESVNUID0gMC4yNVxuXG5cdGZ1bmN0aW9uIGNvbXBhcmVJbmRleCggYSwgYiApIHtcblx0XHRyZXR1cm4gYS5pbmRleCAtIGIuaW5kZXhcblx0fVxuXG5cdGxldCBtb3ZlID0gZnVuY3Rpb24qICggc3RhcnQsIG5leHQgKSB7XG5cdFx0aWYgKCBvcHRzLm1vdmluZyApXG5cdFx0XHRvcHRzLm1vdmluZy5raWxsKCBgcmVzdGFydGluZyBieSBhbm90aGVyIGZpbmdlcmAgKVxuXG5cdFx0bGV0IGNoYW5nZXMgPSBhcHAubG9jYWxEZXZpY2VzLmNyZWF0ZVJlY29yZCgpXG5cdFx0bGV0IGN1cnJlbnRQb3NpdGlvbiA9IHBvc2l0aW9uLnZhbHVlT2YoKVxuXHRcdGxldCBkb25lID0gZmFsc2VcblxuXHRcdC8vIFRPRE86IGFsbCByYSBzdHJ1Y3R1cmVzIG11c3QgYmUgbGlua2VkIHRvIHRoZSBjdXJyZW50IHRocmVhZCBhbmQgbXVzdCBsaW5rIGFsbCB0aGVyZSB0aWNrIHByb2NzIHRvIHRoZSBjdXJyZW50IHRocmVhZCBhbmQgc28gdXBkYXRlIGFsbCB0aGVyZSB0aWNrcyBvbiBzdWJzZXF1ZW50IHlpZWxkIGFuZCBhbHNvIHVwZGF0ZSB0aGVtIGFsbCB3aGlsZSBmaW5pc2hpbmcgdGhyZWFkIGVpdGhlciBub3JtYWwgb3IgYWJub3JtYWwgYW5kIHRoZW4gc3VjaCByYSBzdHJ1Y3R1cmVzIG11c3QgYmUgZGVzdHJveWVkIHRvIHVubGluayBmcm9tIGFueSBleHRlcm5hbCBkZXBlbmRlbmN5LiBUaGlzIG11c3QgYmUgZG9uZSB2aWEgaW1wbGVtZW50aW5nIGNvLm5leHRUaWNrIGluIHRlcm1zIGxpa2UgaW9qcy5wcm9jZXNzLm5leHRUaWNrIC0gbmV4dFRpY2sgY2FsbGJhY2tzIG11c3QgYmUgcHJvY2Vzc2VkIGJlZm9yZSB5aWVsZGluZyBzdWJzZXF1ZW50IHJlc3VsdC4gU28gaXQgaXMgcG9zc2libGUgdG8gbGV0IGV4Y2VwdGlvbnMgYmUgcmFpc2VkIGluIHByb3BlciB3YXkuIEFuZCBpdCBtZWFucyB0aGF0IGlmIHBvc3NpYmxlIG5leHRUaWNrIGNhbGxiYWNrcyB3aWxsIGZpcmUganVzdCBhZnRlciByZXF1ZXN0IGZvciBuZXh0IHlpZWxkLlxuXG5cdFx0bGV0IGhvdmVyID0gcmEoIHtcblx0XHRcdHNhdmVkSWQ6IG51bGwsXG5cdFx0XHRjYWNoZWRJZDogbnVsbCxcblx0XHRcdGlkOiBudWxsLFxuXHRcdFx0cG9zaXRpb246IG51bGwsXG5cblx0XHRcdHVwZGF0ZUFwcCggdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zYXZlZElkIClcblx0XHRcdFx0XHRhcHAuaG92ZXIgPSBsdS5hcHBseURpZmYoIGFwcC5ob3ZlciwgeyBbIHRoaXMuc2F2ZWRJZCBdOiB7IFsgcGxhY2VJZCBdOiB7IFsgaWNvbklkIF06IHZhbHVlIH0gfSB9IClcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRPRE86IGluc2VydCBkZWJvdW5jZSBtZWNoYW5pc20ganVzdCBpbnRvIHJhXG5cdFx0XHRnZXQgdXBkYXRlQ2FjaGUoKSB7IC8vIGRlYm91bmNlIGlkIGNoYW5naW5nXG5cdFx0XHRcdHRoaXMuY2FjaGVkSWQgPSB0aGlzLmlkXG5cdFx0XHR9LFxuXG5cdFx0XHRnZXQgc2F2ZUlkKCkge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZUFwcCggbnVsbCApXG5cdFx0XHRcdHRoaXMuc2F2ZWRJZCA9IHRoaXMuY2FjaGVkSWRcblx0XHRcdFx0dGhpcy51cGRhdGVBcHAoIHRydWUgKVxuXHRcdFx0fSxcblx0XHR9IClcblxuXHRcdHRyeSB7XG5cdFx0XHRsZXQgc2VsZiA9IGNvLmN1cnJlbnRcblx0XHRcdHJhKCAoKSA9PiAhZG9uZSAmJiAhYXBwLmVkaXRpbmcgJiYgc2VsZi5raWxsKCkgKVxuXG5cdFx0XHRsZXQgcCA9IGdldFBvaW50KCBzdGFydCApXG5cdFx0XHRsZXQgciA9IGdldExlZnRUb3AoIGljb24gKVxuXHRcdFx0b3B0cy5tb3ZpbmcgPSBjby5jdXJyZW50XG5cdFx0XHRvcHRzLm1vdmVkID0gZmFsc2Vcblx0XHRcdGxldCBmaW5nZXJTaGlmdCA9IHtcblx0XHRcdFx0eDogci54IC0gcC54LFxuXHRcdFx0XHR5OiByLnkgLSBwLnksXG5cdFx0XHR9XG5cdFx0XHRvcHRzLnggPSByLnhcblx0XHRcdG9wdHMueSA9IHIueVxuXG5cdFx0XHRmb3IgKCBsZXQgcHQ7IHB0ID0geWllbGQgbmV4dDsgKSB7XG5cdFx0XHRcdGxldCBmaW5nZXIgPSBnZXRQb2ludCggcHQgKVxuXHRcdFx0XHRsZXQgY29ybmVyID0ge1xuXHRcdFx0XHRcdHg6IGZpbmdlci54ICsgZmluZ2VyU2hpZnQueCxcblx0XHRcdFx0XHR5OiBmaW5nZXIueSArIGZpbmdlclNoaWZ0LnksXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcHRzLnggIT0gY29ybmVyLnggfHwgb3B0cy55ICE9IGNvcm5lci55IClcblx0XHRcdFx0XHRvcHRzLm1vdmVkID0gdHJ1ZVxuXHRcdFx0XHRvcHRzLnggPSBjb3JuZXIueFxuXHRcdFx0XHRvcHRzLnkgPSBjb3JuZXIueVxuXG5cdFx0XHRcdGxldCBwYWdlU2l6ZSA9IHtcblx0XHRcdFx0XHR4OiBhcHAucGFnZVdpZHRoLFxuXHRcdFx0XHRcdHk6IGFwcC5wYWdlSGVpZ2h0LFxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBjZWxsU2l6ZSA9IHtcblx0XHRcdFx0XHR4OiAxMDAgLyBwYWdlU2l6ZS54LFxuXHRcdFx0XHRcdHk6IDEwMCAvIHBhZ2VTaXplLnksXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGluZGV4ID0ge1xuXHRcdFx0XHRcdHg6IE1hdGgubWluKCBwYWdlU2l6ZS54IC0gMSwgTWF0aC5tYXgoIDAsIE1hdGguZmxvb3IoIGZpbmdlci54IC8gY2VsbFNpemUueCApICkgKSxcblx0XHRcdFx0XHR5OiBNYXRoLm1pbiggcGFnZVNpemUueSAtIDEsIE1hdGgubWF4KCAwLCBNYXRoLmZsb29yKCBmaW5nZXIueSAvIGNlbGxTaXplLnkgKSApICksXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGluQ2VsbCA9IHtcblx0XHRcdFx0XHR4OiBmaW5nZXIueCAvIGNlbGxTaXplLnggLSBpbmRleC54LFxuXHRcdFx0XHRcdHk6IGZpbmdlci55IC8gY2VsbFNpemUueSAtIGluZGV4LnksXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgcGxhY2VQb3NpdGlvbiA9IGluZGV4LnggKyBpbmRleC55ICogcGFnZVNpemUueCArICggbG9jYWwucGxhY2VzUGFnZXNbIHBsYWNlSWQgXSB8fCAwICkgKiBwYWdlU2l6ZS54ICogcGFnZVNpemUueVxuXG5cdFx0XHRcdGxldCBpc0luQ2VudGVyID0gaW5DZWxsLnggPiBNT1ZFX1NJREVfRElTVCAmJiBpbkNlbGwueCA8IDEgLSBNT1ZFX1NJREVfRElTVCAmJiBpbkNlbGwueSA+IE1PVkVfU0lERV9ESVNUICYmIGluQ2VsbC55IDwgMSAtIE1PVkVfU0lERV9ESVNUXG5cblx0XHRcdFx0aWYgKCAhaXNJbkNlbnRlciB8fCBob3Zlci5wb3NpdGlvbiAhPSBwbGFjZVBvc2l0aW9uIClcblx0XHRcdFx0XHRob3Zlci5pZCA9IG51bGxcblx0XHRcdFx0aG92ZXIucG9zaXRpb24gPSBwbGFjZVBvc2l0aW9uXG5cblx0XHRcdFx0aWYgKCBwdC50eXBlICE9IGBzdG9wYCApXG5cdFx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0XHRob3Zlci5pZCA9IG51bGxcblxuXHRcdFx0XHRpZiAoIGluQ2VsbCA+IDEgLSBNT1ZFX1BBR0VfRElTVCAmJiBjZWxsU2l6ZS54ID09IHBhZ2VTaXplLnggLSAxICkge1xuXHRcdFx0XHRcdC8vIFRPRE86IHNjcm9sbCBwYWdlIHJpZ2h0XG5cdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGluQ2VsbCA8IE1PVkVfUEFHRV9ESVNUICYmIGNlbGxTaXplLnggPT0gcGFnZVNpemUueCAtIDEgKSB7XG5cdFx0XHRcdFx0Ly8gVE9ETzogc2Nyb2xsIHBhZ2UgbGVmdFxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgcGxhY2UgPSBsdS5nZXQoIGNoYW5nZXMsIGBzdW1tYXJ5YCwgYGNvbnRlbnRgLCBwbGFjZUlkLCBgY29udGVudGAgKVxuXHRcdFx0XHRpZiAoICFwbGFjZSB8fCAhcGxhY2VbIGljb25JZCBdIClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0bGV0IGtleXMgPSBsb2Rhc2gua2V5cyggcGxhY2UgKVxuXHRcdFx0XHRcdC5tYXAoIGtleSA9PiAoIHsga2V5LCBpbmRleDogcGxhY2VbIGtleSBdLmluZGV4IH0gKSApXG5cdFx0XHRcdFx0LnNvcnQoIGNvbXBhcmVJbmRleCApXG5cblx0XHRcdFx0bGV0IG5ld0luZGV4XG5cblx0XHRcdFx0aWYgKCBwbGFjZVBvc2l0aW9uIDwgMCApIHtcblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRQb3NpdGlvbiA8PSAwIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyAwIF0uaW5kZXggLSAxXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBsYWNlUG9zaXRpb24gPiBrZXlzLmxlbmd0aCAtIDEgKSB7XG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50UG9zaXRpb24gPj0ga2V5cy5sZW5ndGggLSAxIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXS5pbmRleCArIDFcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRQb3NpdGlvbiA9PSBwbGFjZVBvc2l0aW9uIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0aWYgKCBpc0luQ2VudGVyICkge1xuXHRcdFx0XHRcdFx0Ly8gVE9ET1xuXHRcdFx0XHRcdFx0aG92ZXIuaWQgPSBrZXlzWyBwbGFjZVBvc2l0aW9uIF0ua2V5XG5cdFx0XHRcdFx0XHRsZXQgc3JjVHlwZSA9IGljb25EZXNjciAmJiBpY29uRGVzY3IudmFsdWVPZigpICYmIGljb25EZXNjci52YWx1ZU9mKCkudHlwZVxuXHRcdFx0XHRcdFx0bGV0IGRzdERldmljZSA9IGFwcC5nZXREZXZpY2UoIGhvdmVyLmlkIClcblx0XHRcdFx0XHRcdGxldCBkc3RUeXBlID0gZHN0RGV2aWNlICYmIGRzdERldmljZS50eXBlXG5cdFx0XHRcdFx0XHRpZiAoIGRzdFR5cGUgPT0gYHBsYWNlYCApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRpZiAoIGRzdFR5cGUgPT0gYGdyb3VwYCAmJiBzcmNUeXBlID09IGBzaW5nbGVgIClcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdC8vIFRPRE86IGFsbG93IGRzdFR5cGUgPT0gYHNpbmdsZWAgJiYgc3JjVHlwZSA9PSBgc2luZ2xlYFxuXHRcdFx0XHRcdFx0aG92ZXIuaWQgPSBudWxsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggaW5DZWxsLnggPiAwLjUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnRQb3NpdGlvbiA9PSBwbGFjZVBvc2l0aW9uICsgMSApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4LnggPT0gcGFnZVNpemUueCAtIDEgJiYgY3VycmVudFBvc2l0aW9uID4gcGxhY2VQb3NpdGlvbiApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRpZiAoIHBsYWNlUG9zaXRpb24gPj0ga2V5cy5sZW5ndGggLSAxIClcblx0XHRcdFx0XHRcdFx0bmV3SW5kZXggPSBrZXlzWyBwbGFjZVBvc2l0aW9uIF0uaW5kZXggKyAxXG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdG5ld0luZGV4ID0gKCBrZXlzWyBwbGFjZVBvc2l0aW9uIF0uaW5kZXggKyBrZXlzWyBwbGFjZVBvc2l0aW9uICsgMSBdLmluZGV4ICkgLyAyXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50UG9zaXRpb24gPT0gcGxhY2VQb3NpdGlvbiAtIDEgKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0aWYgKCBpbmRleC54ID09IDAgJiYgY3VycmVudFBvc2l0aW9uIDwgcGxhY2VQb3NpdGlvbiApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRpZiAoIHBsYWNlUG9zaXRpb24gPD0gMCApXG5cdFx0XHRcdFx0XHRcdG5ld0luZGV4ID0ga2V5c1sgcGxhY2VQb3NpdGlvbiBdLmluZGV4IC0gMVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRuZXdJbmRleCA9ICgga2V5c1sgcGxhY2VQb3NpdGlvbiBdLmluZGV4ICsga2V5c1sgcGxhY2VQb3NpdGlvbiAtIDEgXS5pbmRleCApIC8gMlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBuZXdQb3NpdGlvbiA9IGtleXMubWFwKCBrID0+IGsua2V5ICE9IGljb25JZCA/IGsgOiB7IGtleTogay5rZXksIGluZGV4OiBuZXdJbmRleCB9ICkuc29ydCggY29tcGFyZUluZGV4ICkuZmluZEluZGV4KCBrID0+IGsua2V5ID09IGljb25JZCApXG5cblx0XHRcdFx0aWYgKCBjdXJyZW50UG9zaXRpb24gPT0gbmV3UG9zaXRpb24gKVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdFx0Y3VycmVudFBvc2l0aW9uID0gbmV3UG9zaXRpb25cblx0XHRcdFx0Y2hhbmdlcy5hc3NpZ24oIHsgY29udGVudDogeyBbIHBsYWNlSWQgXTogeyBjb250ZW50OiB7IFsgaWNvbklkIF06IHsgaW5kZXg6IG5ld0luZGV4IH0gfSB9IH0gfSApXG5cdFx0XHR9XG5cdFx0XHRkb25lID0gdHJ1ZVxuXHRcdFx0aWYgKCBob3Zlci5pZCApIHtcblx0XHRcdFx0Y2hhbmdlcy5jbG9zZSgpXG5cdFx0XHRcdC8vIFRPRE9cblx0XHRcdFx0Ly8gbGV0IG5ld1BsYWNlID0gYXBwLmdldERldmljZSggaG92ZXIuaWQgKVxuXHRcdFx0XHQvLyBpZiAoIG5ld1BsYWNlICYmIG5ld1BsYWNlLnR5cGUgPT0gYHNpbmdsZWAgKSB7XG5cdFx0XHRcdC8vIFx0YXBwLmxpbmtpbmdEZXZpY2VzID0gWyBob3Zlci5pZCwgaWNvbklkIF1cblx0XHRcdFx0Ly8gXHRhcHAuZGlhbG9nID0gYENyZWF0ZVBsYWNlT3JHcm91cGBcblx0XHRcdFx0Ly8gfVxuXHRcdFx0XHQvLyBlbHNlXG5cdFx0XHRcdGFwcC5pbnNlcnRJbnRvKCBob3Zlci5pZCwgaWNvbklkLCBwbGFjZUlkIClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR5aWVsZCBjby5zbGVlcCgpXG5cdFx0XHRcdGx1LndoZW4oIGNoYW5nZXMuc2F2ZSgpLCAoKSA9PiBjaGFuZ2VzLmNsb3NlKCkgKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdGhvdmVyLmlkID0gbnVsbFxuXHRcdFx0aWYgKCAhZG9uZSApIHtcblx0XHRcdFx0ZG9uZSA9IHRydWVcblx0XHRcdFx0Y2hhbmdlcy5jbG9zZSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdHMubW92aW5nID09IGNvLmN1cnJlbnQgKSB7XG5cdFx0XHRcdG9wdHMubW92aW5nID0gbnVsbFxuXHRcdFx0XHRvcHRzLm1vdmVkID0gZmFsc2Vcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRsZXQgZGltbSA9IGZ1bmN0aW9uKiAoIG5leHQgKSB7XG5cdFx0bGV0IGNoYW5nZXMgPSBhcHAubG9jYWxEZXZpY2VzLmNyZWF0ZVJlY29yZCgpXG5cdFx0dHJ5IHtcblx0XHRcdGxldCBzdGF0ZVxuXHRcdFx0b3B0cy5pc0RpbW1lcmluZyA9IHRydWVcblx0XHRcdGxldCBpbml0aWFsRGltbWVyaW5nU3RhdGUgPSBpY29uRGVzY3IgJiYgaWNvbkRlc2NyLmdldCggYHN0YXRlYCApXG5cdFx0XHRmb3IgKCBsZXQgcHQ7IHB0ID0geWllbGQgbmV4dDsgKSB7XG5cdFx0XHRcdGlmICggcHQuZGV0YWlsLnR5cGUgPT0gYHN3aXBlYCApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZGV0YWlsLmRpcmVjdGlvbiA9PSBgdXBgIClcblx0XHRcdFx0XHRcdHN0YXRlID0gMVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHN0YXRlID0gMFxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGxldCBkZWx0YSA9IC1wdC5kZWx0YVkgLyAoIGltYWdlSGVpZ2h0KCkgKiAxLjAgLyogbW92ZSBtdWx0aXBseWVyICovIClcblx0XHRcdFx0XHRzdGF0ZSA9IE1hdGgubWluKCAxLCBNYXRoLm1heCggMCwgaW5pdGlhbERpbW1lcmluZ1N0YXRlICsgZGVsdGEgKSApXG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PSAwIHx8IHN0YXRlID09IDEgKVxuXHRcdFx0XHRcdFx0aW5pdGlhbERpbW1lcmluZ1N0YXRlID0gc3RhdGUgLSBkZWx0YVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNoYW5nZXMudXBkYXRlKCB7IGNvbnRlbnQ6IHsgWyBpY29uSWQgXTogeyBzdGF0ZSB9IH0gfSApXG5cdFx0XHR9XG5cdFx0XHRpZiAoIHN0YXRlICE9IG51bGwgKVxuXHRcdFx0XHRvcHRzLmljb25Db21tYW5kKCBgU2V0YCwgc3RhdGUgKVxuXHRcdH1cblx0XHRmaW5hbGx5IHtcblx0XHRcdGNoYW5nZXMuY2xvc2UoKVxuXHRcdFx0b3B0cy5pc0RpbW1lcmluZyA9IGZhbHNlXG5cdFx0fVxuXHR9XG5cblx0bGV0IFBpY3R1cmUgPSBhdHRyaWJ1dGVzID0+IDxpbWdcblx0XHRjbGFzcyA9IFwiZXJyb3JcIlxuXHRcdG9uZXJyb3IgPSB7IGZ1bmN0aW9uICgpIHsgdGhpcy5jbGFzc0xpc3QuYWRkKCBgZXJyb3JgICkgfSB9XG5cdFx0b25sb2FkID0geyBmdW5jdGlvbiAoKSB7IHRoaXMuY2xhc3NMaXN0LnJlbW92ZSggYGVycm9yYCApIH0gfVxuXHRcdF8gPSB7IGF0dHJpYnV0ZXMgfVxuXHQvPlxuXG5cdHJldHVybiA8ZGl2XG5cdFx0b25jcmVhdGUgPSB7IGUgPT4gaWNvbiA9IGUudGFyZ2V0IH1cblx0XHRvbm1vdXNlZG93biA9IHsgKCkgPT4gaXNNb3VzZSA9IHRydWUgfVxuXHRcdG9ud2hlZWwgPSB7IGUgPT4gY29uc29sZS5sb2coIGUuZGVsdGFZLCBlLmRlbHRhTW9kZSwgZSApIH1cblx0XHRjbGFzcyA9IHsgKCkgPT4gYFxuXHRcdFx0aWNvblxuXHRcdFx0JHsgb3B0cy5vbm5pbmcgJiYgYG9ubmluZ2AgfVxuXHRcdFx0JHsgb3B0cy5vZmZpbmcgJiYgYG9mZmluZ2AgfVxuXHRcdFx0JHsgb3B0cy5maW5hbCAmJiBgZmluYWxgIH1cblx0XHRcdCR7IG9wdHMuZXJyb3JuZW91cyAmJiBgZXJyb3JuZW91c2AgfVxuXHRcdFx0JHsgb3B0cy5kaW1tZXJpbmcudmFsdWVPZigpID8gYGRpbW1lcmluZ2AgOiBgc3dpdGNoaW5nYCB9XG5cdFx0XHQkeyBpY29uSWQgfVxuXHRcdFx0aWNvbl9tb3ZpbmdfJHsgISFvcHRzLm1vdmluZyB9XG5cdFx0XHRpY29uX21vdmVkXyR7ICEhb3B0cy5tb3ZpbmcgJiYgISFvcHRzLm1vdmVkIH1cblx0XHRcdGljb25fZGVzdGluYXRpb25fJHsgISEoIGFwcC5ob3ZlciAmJiBhcHAuaG92ZXJbIGljb25JZCBdICkgfVxuXHRcdGAgfVxuXHRcdHN0eWxlID0geyBmdW5jdGlvbiogYmxvY2soKSB7XG5cdFx0XHQvLyDQutCw0LvRliDQsNC00YDQsNC30YMg0L/RgNGL0YHQstC+0ZbRhtGMIGxlZnQg0ZYgdG9wINGC0L4g0YfQsNC80YPRgdGM0YbRliDQvdC1INC/0YDQsNGG0YPQtSB0cmFuc2l0aW9uXG5cdFx0XHQvLyBUT0RPOiDRgNCw0LfQsNCx0YDQsNGG0YbQsCwg0YbRliDRkdGB0YzRhtGMINGP0LrRliDQtyDQs9GN0YLRi9GFINC00LLRg9GFINGA0LDQtNC60L7RniDQu9GW0YjQvdGWP1xuXHRcdFx0YXBwLmVkaXRpbmcgJiYgKCB5aWVsZCBjby5zbGVlcCgpIClcblx0XHRcdCFibG9jay5ydW4gPyBibG9jay5ydW4gPSB0cnVlIDogKCB5aWVsZCBjby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKVxuXHRcdFx0Ly9cblxuXHRcdFx0bGV0IHB0XG5cdFx0XHRpZiAoIG9wdHMubW92aW5nIClcblx0XHRcdFx0cHQgPSB7IHg6IG9wdHMueCwgeTogb3B0cy55IH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgaSA9IGx1LnZhbHVlT2YoIHBvc2l0aW9uIClcblx0XHRcdFx0bGV0IHBoID0gYXBwLnBhZ2VIZWlnaHQgfHwgMVxuXHRcdFx0XHRsZXQgcHcgPSBhcHAucGFnZVdpZHRoIHx8IDFcblx0XHRcdFx0bGV0IHBzID0gcHcgKiBwaFxuXHRcdFx0XHRsZXQgcGkgPSBpICUgcHNcblx0XHRcdFx0bGV0IHAgPSAoIGkgLSBwaSApIC8gcHNcblx0XHRcdFx0bGV0IHcgPSBwaSAlIHB3XG5cdFx0XHRcdGxldCBoID0gKCBwaSAtIHcgKSAvIHB3XG5cdFx0XHRcdHcgKz0gcHcgKiBwXG5cdFx0XHRcdHB0ID0geyB4OiB3ICogMTAwIC8gcHcsIHk6IGggKiAxMDAgLyBwaCB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRsZWZ0OiBgJHsgcHQueCB9JWAsXG5cdFx0XHRcdHRvcDogYCR7IHB0LnkgfSVgLFxuXHRcdFx0fVxuXHRcdH0gfVxuXHQ+XG5cdFx0PGRpdiBjbGFzcyA9IFwiaWNvbkNvbnRyb2xcIlxuXHRcdFx0b250b3VjaCA9IHsgaHRtbHV0aWxzLnByZXZlbnREZWZhdWx0IH1cblx0XHRcdG9udGFwID0geyAoKSA9PiAhYXBwLmVkaXRpbmcgJiYgb3B0cy5pY29uQ29tbWFuZCggYFNob3J0YCApIH1cblx0XHRcdG9ucHJlc3MgPSB7ICgpID0+ICFhcHAuZWRpdGluZyAmJiBvcHRzLmljb25Db21tYW5kKCBgTG9uZ2AgKSB9XG5cdFx0XHRvbnBhbiA9IHsgZnVuY3Rpb24qICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCBhcHAuZWRpdGluZyApIHtcblx0XHRcdFx0XHQvLyBtb3Zpbmdcblx0XHRcdFx0XHRsZXQgbmV4dCA9IGRhdGEuZGV0YWlsLmxvY2soKVxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgcHQ7IHB0ID0geWllbGQgbmV4dDsgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggcHQuZGV0YWlsLnByZXNzZWQgPT09IGZhbHNlIClcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0aWYgKCBwdC5kZXRhaWwucHJlc3NlZCA9PSBudWxsIClcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0XHR5aWVsZCogbW92ZSggcHQsIG5leHQgKVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsLnVubG9jayggbmV4dCApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBkYXRhLmRldGFpbC5kaXJlY3Rpb24gPT0gYHVwYCB8fCBkYXRhLmRldGFpbC5kaXJlY3Rpb24gPT0gYGRvd25gICkge1xuXHRcdFx0XHRcdC8vIGRpbW1lcmluZ1xuXHRcdFx0XHRcdGRhdGEuc3RvcFByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHR5aWVsZCogZGltbSggZGF0YS5kZXRhaWwubmV4dCApXG5cdFx0XHRcdH1cblx0XHRcdH0gfVxuXHRcdD5cblx0XHRcdDxkaXYgY2xhc3MgPSBcImltYWdlXCIgb25jcmVhdGUgPSB7IGUgPT4gaW1hZ2UgPSBlLnRhcmdldCB9ID5cblx0XHRcdFx0PFBpY3R1cmUgY2xhc3MgPSBcIndhaXRcIiBzcmMgPSBcIi9pbWFnZXMvd2FpdC5zdmdcIiBzdHlsZSA9IHt7XG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogKCkgPT4gdGhpcy5maW5hbCA/IGBoaWRkZW5gIDogbnVsbCxcblx0XHRcdFx0fX0gLz5cblx0XHRcdFx0PFBpY3R1cmUgY2xhc3MgPSBcIm9mZlwiIHNyYyA9IFwiL2ltYWdlcy9yb29tLnN2Z1wiIG9uY3JlYXRlID0geyBlID0+IG9mZiA9IGUudGFyZ2V0IH0gLz5cblx0XHRcdFx0PFBpY3R1cmUgY2xhc3MgPSBcIm9uXCIgc3JjID0gXCIvaW1hZ2VzL3Jvb21fb24uc3ZnXCIgb25jcmVhdGUgPSB7IGUgPT4gb24gPSBlLnRhcmdldCB9IC8+XG5cdFx0XHRcdDxQaWN0dXJlIGNsYXNzID0gXCJhYnNlbnRcIiBzcmMgPSBcIi9pbWFnZXMvcm9vbV9hYnNlbnQuc3ZnXCIgb25jcmVhdGUgPSB7IGUgPT4gYWJzZW50ID0gZS50YXJnZXQgfSAvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzID0geyAoKSA9PiBgXG5cdFx0XHRcdFx0c3ZnXG5cdFx0XHRcdFx0JHsgYHN0YXRlYCArICggIW9wdHMucHJlc2VudCA/IGBBYnNlbnRgIDogKCBNYXRoLnJvdW5kKCBvcHRzLnN0YXRlICogMTAwICkgKyAxMDAwICkudG9TdHJpbmcoKS5zbGljZSggMSApICkgfVxuXHRcdFx0XHRcdCR7ICFvcHRzLmlzRGltbWVyaW5nID8gYHNtb290aGluZ2AgOiBgYCB9XG5cdFx0XHRcdGAgfSA+e1xuXHRcdFx0XHRcdCgpID0+IG9wdHMuaWNvbkRhdGEgPSBvcHRzLmljb25UZW1wbGF0ZSAmJiBodG1sdXRpbHMuaW1wb3J0Q29tcG9uZW50KCBvcHRzLmljb25UZW1wbGF0ZSApIHx8IG51bGxcblx0XHRcdFx0fTwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8c3BhbiBjbGFzcyA9IFwiaWNvbkxhYmVsXCIgPnsgKCkgPT5cblx0XHRcdFx0aWNvbkRlc2NyLmdldCggbG9jYWwubGFuZ3VhZ2UgKSB8fCBpY29uRGVzY3IuZ2V0KCBgcnVgICkgfHwgaWNvbkRlc2NyLmdldCggYGVuYCApXG5cdFx0XHR9PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImljb25QZXJjZW50YWdlXCIgPnsgKCkgPT5cblx0XHRcdFx0b3B0cy5wcmVzZW50ICYmIG9wdHMuZGltbWVyaW5nICYmIGAkeyBNYXRoLnJvdW5kKCBvcHRzLnN0YXRlICogMTAwICkgfSVgXG5cdFx0XHR9PC9zcGFuPlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3MgPSBcImRlbGV0ZVNpZ25cIiBvbnRvdWNoc3RhcnQgPSB7ICgpID0+IGFwcC5kZWxldGVJdGVtKCBwbGFjZUlkLCBpY29uSWQgKSB9IG9ubW91c2Vkb3duID0geyAoKSA9PiBhcHAuZGVsZXRlSXRlbSggcGxhY2VJZCwgaWNvbklkICkgfSAvPlxuXHQ8L2Rpdj5cbn1cbiIsImxldCBodG1sdXRpbHMgPSByZXF1aXJlKCBgaHRtbHV0aWxzYCApXG5sZXQgVUlEID0gcmVxdWlyZSggYHVpZGAgKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggYXBwLCBsb2NhbCApID0+IHtcblxuXHRsZXQgUGxhY2UgPSBhcHAubG9hZCggcmVxdWlyZSggYHVpL1BsYWNlYCApIClcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGxldCBpZCA9IFVJRCgpXG5cblx0XHRmdW5jdGlvbiogcGFuKCBuZXh0ICkge1xuXHRcdFx0Ly8gVE9ETzogbm8gdHJhbnNpdGlvbiB3aGlsZSBwYW5uaW5nXG5cdFx0XHRsZXQgbGFzdERlbHRhWCwgcGFnZSwgc2l6ZVxuXHRcdFx0bGV0IGRldmljZWlkID0gYXBwLmFjdGl2ZURldmljZUlkXG5cdFx0XHRhcHAucGxhY2VzU2hpZnRzLmRlZmluZVByb3BlcnR5KCBkZXZpY2VpZCApXG5cdFx0XHRsb2NhbC5wbGFjZXNQYWdlcy5kZWZpbmVQcm9wZXJ0eSggZGV2aWNlaWQgKVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICggbGV0IGRhdGE7IGRhdGEgPSB5aWVsZCBuZXh0OyApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEubGFzdERlbHRhWCApXG5cdFx0XHRcdFx0XHRsYXN0RGVsdGFYID0gZGF0YS5sYXN0RGVsdGFYXG5cdFx0XHRcdFx0bGV0IGRlbHRhWCA9IGRhdGEuZGVsdGFYXG5cdFx0XHRcdFx0bGV0IHJlY3QgPSBhcHAubWVudUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblx0XHRcdFx0XHRsZXQgZGV2aWNlID0gYXBwLmdldERldmljZSggZGV2aWNlaWQgKVxuXHRcdFx0XHRcdGlmICggIWRldmljZSB8fCAhZGV2aWNlLmNvbnRlbnQgKVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0c2l6ZSA9IE1hdGguY2VpbCggT2JqZWN0LmtleXMoIGRldmljZS5jb250ZW50ICkubGVuZ3RoIC8gKCBhcHAucGFnZVdpZHRoICogYXBwLnBhZ2VIZWlnaHQgKSApXG5cdFx0XHRcdFx0aWYgKCBzaXplID09IDAgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRwYWdlID0gbG9jYWwucGxhY2VzUGFnZXNbIGRldmljZWlkIF0gfHwgMFxuXHRcdFx0XHRcdGxldCBpbml0aWFsU2hpZnQgPSAtcGFnZSAqIHJlY3Qud2lkdGhcblx0XHRcdFx0XHRsZXQgc2hpZnQgPSBkYXRhLmRlbHRhWFxuXHRcdFx0XHRcdGlmICggc2hpZnQgPiAwICYmIHBhZ2UgPT0gMCB8fCBzaGlmdCA8IDAgJiYgcGFnZSA9PSBzaXplIC0gMSApXG5cdFx0XHRcdFx0XHRzaGlmdCAvPSAzXG5cdFx0XHRcdFx0YXBwLnBsYWNlc1NoaWZ0c1sgZGV2aWNlaWQgXSA9IHNoaWZ0XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBsYXN0RGVsdGFYICkge1xuXHRcdFx0XHRcdGlmICggbGFzdERlbHRhWCA+IDAgJiYgcGFnZSA+IDAgKVxuXHRcdFx0XHRcdFx0bG9jYWwucGxhY2VzUGFnZXNbIGRldmljZWlkIF0gPSBwYWdlIC0gMVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBsYXN0RGVsdGFYIDwgMCAmJiBwYWdlIDwgc2l6ZSAtIDEgKVxuXHRcdFx0XHRcdFx0bG9jYWwucGxhY2VzUGFnZXNbIGRldmljZWlkIF0gPSBwYWdlICsgMVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0YXBwLnBsYWNlc1NoaWZ0c1sgZGV2aWNlaWQgXSA9IDBcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gPGRpdiA+XG5cdFx0XHQ8c3R5bGUgY2xhc3MgPSBcInN0eWxlXCIgPnsgKCkgPT4gYFxuXHRcdFx0XHQuJHsgaWQgfSAuaWNvbiB7XG5cdFx0XHRcdFx0d2lkdGg6ICR7IDEwMCAvIGFwcC5wYWdlV2lkdGggfSU7XG5cdFx0XHRcdFx0aGVpZ2h0OiAkeyAxMDAgLyBhcHAucGFnZUhlaWdodCB9JTtcblx0XHRcdFx0fVxuXHRcdFx0YCB9PC9zdHlsZT5cblx0XHRcdDxkaXYgY2xhc3MgPSBcInRvcFwiID5cblx0XHRcdFx0PHNwYW4gY2xhc3MgPSBcInRvcF9zZWxmXCIgPlxuXHRcdFx0XHRcdDxodG1sdXRpbHMuQ2VudGVyZWQ+eyAoKSA9PiBhcHAuY2FwdGlvbiB9PC9odG1sdXRpbHMuQ2VudGVyZWQ+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcyA9IHsgKCkgPT4gYG1lbnUgJHsgaWQgfSAkeyBhcHAuYWN0aXZlRGV2aWNlSWQgfWAgfVxuXHRcdFx0XHRvbnBhbiA9IHsgZnVuY3Rpb24qICggZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZGV0YWlsLmRpcmVjdGlvbiA9PSBgbGVmdGAgfHwgZGF0YS5kZXRhaWwuZGlyZWN0aW9uID09IGByaWdodGAgKSB7XG5cdFx0XHRcdFx0XHRkYXRhLnN0b3BQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHR5aWVsZCogcGFuKCBldmVudC5kZXRhaWwubmV4dCApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IH1cblx0XHRcdFx0b25jcmVhdGUgPSB7IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRhcHAubWVudUVsZW1lbnQgPSB0aGlzXG5cdFx0XHRcdFx0bGV0IHNob3duID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdFx0cmEoICgpID0+IHtcblx0XHRcdFx0XHRcdGxldCBpZCA9IGFwcC5hY3RpdmVEZXZpY2VJZFxuXHRcdFx0XHRcdFx0aWYgKCAhaWQgfHwgc2hvd25bIGlkIF0gKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdGFwcC5wbGFjZXNTaGlmdHMuZGVmaW5lUHJvcGVydHkoIGlkIClcblx0XHRcdFx0XHRcdGxvY2FsLnBsYWNlc1BhZ2VzLmRlZmluZVByb3BlcnR5KCBpZCApXG5cdFx0XHRcdFx0XHRzaG93blsgaWQgXSA9IHRydWVcblx0XHRcdFx0XHRcdC8vIFRPRE86IHJlbW92ZSA8UGxhY2UvPiB3aGVuIHN1Y2ggYSBwbGFjZSBpcyBhY3R1YWxseSByZW1vdmVkIGZyb20gZGF0YWJhc2Vcblx0XHRcdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQoIDxQbGFjZSBwbGFjZUlkID0geyBpZCB9IHBsYWNlRGVzY3IgPSB7IHJhKCAoKSA9PiBhcHAuZ2V0RGV2aWNlKCBpZCApICkgfSAvPiApXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdH0gfVxuXHRcdFx0Lz5cblx0XHRcdDxkaXYgY2xhc3MgPSBcImJvdHRvbVwiID5cblx0XHRcdFx0PGRpdiBjbGFzcyA9IFwiaGVscFwiXG5cdFx0XHRcdFx0b25wcmVzcyA9IHsgKCkgPT4gYXBwLmRpYWxvZyA9IGBTZXJ2aWNlRGlhbG9nYCB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxkaXYgY2xhc3MgPSBcImxvZ29cIlxuXHRcdFx0XHRcdG9ucHJlc3MgPSB7ICgpID0+IGFwcC5kaWFsb2cgPSBgQ29udGV4dE1lbnVgIH1cblx0XHRcdFx0XHRvbnRhcCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5zaGlmdEtleSB8fCBldmVudC5zcmNFdmVudCAmJiBldmVudC5zcmNFdmVudC5zaGlmdEtleSApXG5cdFx0XHRcdFx0XHRcdHJldHVybiBhcHAuZGlhbG9nID0gYENvbnRleHRNZW51YFxuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNyY0V2ZW50ICYmIGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYXBwLmRpYWxvZyA9IGBTZWFyY2hJdGVtc2Bcblx0XHRcdFx0XHRcdGFwcC5lZGl0aW5nID0gZmFsc2Vcblx0XHRcdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0XHRcdFx0YXBwLmdvKCBhcHAubWFpbiApXG5cdFx0XHRcdFx0fSB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxkaXYgY2xhc3MgPSBcImJhY2tcIlxuXHRcdFx0XHRcdG9udG91Y2ggPSB7ICgpID0+IHtcblx0XHRcdFx0XHRcdGlmICggYXBwLmVkaXRpbmcgKVxuXHRcdFx0XHRcdFx0XHRhcHAuZWRpdGluZyA9IGZhbHNlXG5cdFx0XHRcdFx0XHRlbHNlIGlmICggYXBwLmRpYWxvZyApXG5cdFx0XHRcdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRhcHAuYmFjaygpXG5cdFx0XHRcdFx0fSB9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0fVxufVxuIiwibGV0IEFwcGxpY2F0aW9uID0gcmVxdWlyZSggYHVpL0FwcGxpY2F0aW9uYCApXG5cbm1vZHVsZS5leHBvcnRzID0gKCB7IEljb25UZW1wbGF0ZXMgfSApID0+IDxzcGFuPlxuXHQ8c3R5bGU+IHsgYC5hcHBsaWNhdGlvbiB7IHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50OyB9IH0gYCB9IDwvc3R5bGU+XG5cdDxBcHBsaWNhdGlvbiBJY29uVGVtcGxhdGVzID0geyBJY29uVGVtcGxhdGVzIH0gLz5cbjwvc3Bhbj5cbiIsIm1vZHVsZS5leHBvcnRzID0gKCBhcHAsIGxvY2FsICkgPT4ge1xuXG5cdGxldCBJY29uID0gYXBwLmxvYWQoIHJlcXVpcmUoIGB1aS9JY29uYCApIClcblxuXHRyZXR1cm4gKCB7IHBsYWNlSWQsIHBsYWNlRGVzY3IgfSApID0+IHtcblx0XHRsZXQgaWRzID0gcmEoICgpID0+IHtcblx0XHRcdGxldCBjb250ZW50ID0gcGxhY2VEZXNjci5nZXQoIGBjb250ZW50YCApXG5cdFx0XHRyZXR1cm4gcmEuQXJyYXkoIGxvZGFzaC5rZXlzKCBjb250ZW50ICkuc29ydCggKCBhLCBiICkgPT4gbHUuY29tcGFyZSggY29udGVudFsgYSBdLmluZGV4LCBjb250ZW50WyBiIF0uaW5kZXggKSApIClcblx0XHR9IClcblx0XHRsZXQgY29udGVudCA9IHJhLm1hcCggaWRzLCAoIGljb25JZCwgcG9zaXRpb24gKSA9PiA8SWNvblxuXHRcdFx0cGxhY2VJZCA9IHsgcGxhY2VJZCB9XG5cdFx0XHRpY29uSWQgPSB7IGljb25JZCB9XG5cdFx0XHRwb3NpdGlvbiA9IHsgcG9zaXRpb24gfVxuXHRcdFx0aWNvbkRlc2NyID0geyByYSggKCkgPT4gYXBwLmdldERldmljZSggaWNvbklkICkgKSB9XG5cdFx0Lz4gKVxuXHRcdHJldHVybiA8ZGl2PlxuXHRcdFx0PHN0eWxlPnsgYFxuXHRcdFx0XHQuJHsgcGxhY2VJZCB9IC5wbGFjZS4keyBwbGFjZUlkIH0ge1xuXHRcdFx0XHRcdGRpc3BsYXk6IGluaXRpYWw7XG5cdFx0XHRcdH1cblx0XHRcdGAgfTwvc3R5bGU+XG5cdFx0XHQ8ZGl2IGNsYXNzID0geyBgcGxhY2UgJHsgcGxhY2VJZCB9YCB9IHN0eWxlID0ge3tcblx0XHRcdFx0dHJhbnNmb3JtOiAoKSA9PiBgdHJhbnNsYXRlWCggJHtcblx0XHRcdFx0XHQtKCBsb2NhbC5wbGFjZXNQYWdlc1sgcGxhY2VJZCBdIHx8IDAgKSAqIGFwcC5tZW51RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIGFwcC5wbGFjZXNTaGlmdHNbIHBsYWNlSWQgXSB8fCAwXG5cdFx0XHRcdH1weCApYCxcblx0XHRcdH19ID57XG5cdFx0XHRcdCgpID0+IGNvbnRlbnRcblx0XHRcdH08L2Rpdj5cblx0XHQ8L2Rpdj5cblx0fVxufVxuIiwibGV0IERMID0gcmVxdWlyZSggYERhbWVyYXVMZXZlbnNodGVpbmAgKVxuXG5sZXQgbm90QUNoYXIgPSBjaGFyID0+IGNoYXIgPD0gYCBgIHx8IGNoYXIgPT0gYC1gXG5cbmxldCBmdXp6eSA9ICggbWFzaywgdGV4dCApID0+IERMKCBtYXNrLnRvVXBwZXJDYXNlKCksIHRleHQudG9VcHBlckNhc2UoKSwge1xuXHRyZXBsYWNlOiBJbmZpbml0eSxcblx0ZGVsZXRlOiBjaGFyID0+IG5vdEFDaGFyKCBjaGFyICkgPyAxZS0yIDogSW5maW5pdHksXG5cdGluc2VydDogY2hhciA9PiBub3RBQ2hhciggY2hhciApID8gMWUtMiA6IDEsXG5cdHRyYW5zcG9zZTogMSxcbn0gKVxuXG5mdW5jdGlvbiB3YXRjaCggZGF0YSwgY2IgKSB7XG5cdGxldCB2XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCB2ID09IG51bGwgKSByYS5kZXRhY2goICgpID0+IHtcblx0XHRcdHYgPSByYSggZGF0YSApXG5cdFx0XHRyYSggKCkgPT4ge1xuXHRcdFx0XHR2LnZhbHVlT2YoKVxuXHRcdFx0XHRjYigpXG5cdFx0XHR9IClcblx0XHR9IClcblx0XHRyZXR1cm4gdi52YWx1ZU9mKClcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcCA9PiB7XG5cdGxldCBvcHRzLCAkID0ge31cblxuXHRsZXQgU2VhcmNoSXRlbSA9ICggeyBwbGFjZUlkIH0gKSA9PlxuXHRcdDxkaXYgY2xhc3MgPSB7IGBzZWFyY2hJdGVtICR7IHBsYWNlSWQgfWAgfSBvbnNjcm9sbHRhcCA9IHsgKCkgPT4gb3B0cy5nb3RvKCBwbGFjZUlkICkgfSA+XG5cdFx0XHQ8c3BhbiBjbGFzcyA9IFwiY2FwdGlvblwiID57ICgpID0+IG9wdHMucGxhY2VJbmZvc1sgcGxhY2VJZCBdLmNhcHRpb24gfTwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzID0gXCJwbGFjZXNcIiA+eyAoKSA9PiBvcHRzLnBsYWNlSW5mb3NbIHBsYWNlSWQgXS5wdGV4dCB9PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImNtZERlbGV0ZUZyb21Qcm9ncmFtXCI+PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3MgPSBcImNtZEFwcGVuZFwiPjwvc3Bhbj5cblx0XHQ8L2Rpdj5cblxuXHRvcHRzID0gcmEoIHtcblx0XHRnb3RvKCBpZCApIHtcblx0XHRcdGlmICggIWlkIClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRsZXQgcGxhY2VJbmZvID0gb3B0cy5wbGFjZUluZm9zWyBpZCBdXG5cdFx0XHR+KCBhcHAuc2VhcmNoQWN0aW9uIHx8IGFwcC5nbyApKCBpZCwgcGxhY2VJbmZvICYmIHBsYWNlSW5mby5wbGFjZXMgKVxuXHRcdH0sXG5cdFx0Z2V0IGRldmljZUlkcygpIHsgcmV0dXJuIHJhLkFycmF5KCBhcHAuZGV2aWNlSWRzLmZpbHRlciggaWQgPT4gaWQgIT0gYXBwLm1haW4gKSApIH0sXG5cdFx0Z2V0IHBsYWNlSW5mb3MoKSB7XG5cdFx0XHRsZXQgY2FjaGUgPSBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdGZvciAoIGxldCBpZCBvZiB0aGlzLmRldmljZUlkcyApIHtcblx0XHRcdFx0bGV0IGluZm8gPSBhcHAuZ2V0RGV2aWNlKCBpZCApXG5cdFx0XHRcdGNhY2hlWyBpZCBdID0ge1xuXHRcdFx0XHRcdGluZm8sXG5cdFx0XHRcdFx0Y2FwdGlvbjogYXBwLmdldE1lc3NhZ2UoIGluZm8gKSxcblx0XHRcdFx0XHRwbGFjZXM6IFtdLFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCBsZXQgaWQgb2YgdGhpcy5kZXZpY2VJZHMgKVxuXHRcdFx0XHRsb2Rhc2guZm9yRWFjaCggY2FjaGVbIGlkIF0uaW5mby5jb250ZW50LCAoIF8sIGtleSApID0+XG5cdFx0XHRcdFx0Y2FjaGVbIGtleSBdICYmICggY2FjaGVbIGtleSBdLnBsYWNlcy5wdXNoKCBpZCApIClcblx0XHRcdFx0KVxuXHRcdFx0bGV0IHJldCA9IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0Zm9yICggbGV0IGlkIG9mIHRoaXMuZGV2aWNlSWRzICkge1xuXHRcdFx0XHRsZXQgYyA9IGNhY2hlWyBpZCBdXG5cdFx0XHRcdGxldCBwdGV4dCA9IGMucGxhY2VzLm1hcCggaWQgPT4gY2FjaGVbIGlkIF0uY2FwdGlvbiApLmpvaW4oIGAsIGAgKVxuXHRcdFx0XHRpZiAoIHB0ZXh0IClcblx0XHRcdFx0XHRwdGV4dCA9IGAoJHsgcHRleHQgfSlgXG5cdFx0XHRcdHJldFsgaWQgXSA9IHsgaWQsIGNhcHRpb246IGMuY2FwdGlvbiB8fCBgPCoqKj5gLCBwbGFjZXM6IGMucGxhY2VzLCBwdGV4dCB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmEuSlNPTiggcmV0IClcblx0XHR9LFxuXHRcdGdldCBsYWJlbHMoKSB7IHJldHVybiByYS5rZXltYXAoIG9wdHMubGl2ZS5kZXZpY2VJZHMsIHBsYWNlSWQgPT4gPFNlYXJjaEl0ZW0gcGxhY2VJZCA9IHsgcGxhY2VJZCB9IC8+ICkgfSxcblx0XHRnZXQgZmlsdGVyZWQoKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSAkLm1hc2sucmFWYWx1ZVxuXHRcdFx0bGV0IGFyciA9IFtdXG5cdFx0XHRmb3IgKCBsZXQgaWQgb2YgdGhpcy5kZXZpY2VJZHMuZmlsdGVyKCBhcHAuc2VhcmNoRmlsdGVyIHx8IEJvb2xlYW4gKSApIHtcblx0XHRcdFx0bGV0IGkgPSBvcHRzLnBsYWNlSW5mb3NbIGlkIF1cblx0XHRcdFx0bGV0IGtleSA9IFtdXG5cdFx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdFx0a2V5LnB1c2goXG5cdFx0XHRcdFx0XHRmdXp6eSggdmFsdWUsIGkuY2FwdGlvbiApLFxuXHRcdFx0XHRcdFx0Ly8gPz8/IE1hdGgubWF4KCAuLi5pLnBsYWNlcy5tYXAoIGlkID0+IGZ1enp5KCB2YWx1ZSwgb3B0cy5wbGFjZUluZm9zWyBpZCBdLmNhcHRpb24gKSApICksXG5cdFx0XHRcdFx0XHRmdXp6eSggdmFsdWUsIGkuY2FwdGlvbiArIGAgYCArIGkucHRleHQgKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRpZiAoIGtleS5ldmVyeSggayA9PiBNYXRoLmFicyggayApID09IEluZmluaXR5ICkgKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkucHVzaCggaS5jYXB0aW9uLnRvVXBwZXJDYXNlKCkgKVxuXHRcdFx0XHRhcnIucHVzaCggeyBpZCwga2V5IH0gKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJhLkFycmF5KCBhcnJcblx0XHRcdFx0LnNvcnQoICggYSwgYiApID0+IGxvZGFzaFxuXHRcdFx0XHRcdC56aXAoIGEua2V5LCBiLmtleSApXG5cdFx0XHRcdFx0Lm1hcCggcGFpciA9PiBsdS5jb21wYXJlKCAuLi5wYWlyICkgKVxuXHRcdFx0XHRcdC5yZWR1Y2UoICggYSwgYiApID0+IGEgfHwgYiApXG5cdFx0XHRcdClcblx0XHRcdFx0Lm1hcCggYSA9PiBhLmlkIClcblx0XHRcdClcblx0XHR9LFxuXHRcdGdldCBpdGVtcygpIHtcblx0XHRcdHJldHVybiByYS5BcnJheSggdGhpcy5maWx0ZXJlZC5tYXAoIGlkID0+IHRoaXMubGFiZWxzLmdldCggaWQgKSApIClcblx0XHR9LFxuXHR9IClcblx0d2luZG93Ll9zZWFyY2ggPSBvcHRzXG5cdHJldHVybiA8ZGl2XG5cdFx0b25kaWFsb2dzaG93ID0geyAoKSA9PiB7XG5cdFx0XHQkLnNjcm9sbGVyICYmICQuc2Nyb2xsZXIucmVmcmVzaCgpXG5cdFx0XHQvLyBUT0RPOiDRgNCw0LfQsNCx0YDQsNGG0YbQsCwg0LAg0YbRliDRgtGA0Y3QsdCwINC30LDRhtGW0YDQsNGG0Ywg0L/QvtGI0YPQuj9cblx0XHRcdCQubWFzay5yYVZhbHVlID0gYGBcblx0XHR9IH1cblx0PlxuXHRcdDxmb3JtXG5cdFx0XHRvbnN1Ym1pdCA9IHsgZXZlbnQgPT4ge1xuXHRcdFx0XHRldmVudCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRcdG9wdHMuZ290byggb3B0cy5maWx0ZXJlZFsgMCBdIClcblx0XHRcdH0gfVxuXHRcdD5cblx0XHRcdDxpbnB1dCBuYW1lID0gXCJtYXNrXCIgdHlwZSA9IFwidGV4dFwiIGF1dG9mb2N1cyA9IFwiYXV0b2ZvY3VzXCIgb25jcmVhdGUgPSB7IGV2ZW50ID0+ICQubWFzayA9IGV2ZW50LnRhcmdldCB9IC8+XG5cdFx0XHQ8ZGl2IGNsYXNzID0gXCJzY3JvbGxcIiBvbmNyZWF0ZSA9IHsgZXZlbnQgPT4gJC5zY3JvbGwgPSBldmVudC50YXJnZXQgfSA+XG5cdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcyA9IFwiaXRlbXNcIiA+e1xuXHRcdFx0XHRcdFx0d2F0Y2goICgpID0+IG9wdHMuaXRlbXMsICgpID0+IHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhJC5zY3JvbGxlciApXG5cdFx0XHRcdFx0XHRcdFx0JC5zY3JvbGxlciA9IG5ldyAoIHJlcXVpcmUoIGBpc2Nyb2xsYCApICkoICQuc2Nyb2xsLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb3VzZVdoZWVsOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0c2Nyb2xsYmFyczogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcDogYHNjcm9sbHRhcGAsXG5cdFx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHQkLnNjcm9sbGVyLnJlZnJlc2goKVxuXHRcdFx0XHRcdFx0fSwgMTAwICkgKVxuXHRcdFx0XHRcdH08L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzID0gXCJzY3JvbGxBcmVhQm90dG9tRmlsbGVyXCIgLz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Zvcm0+XG5cdDwvZGl2PlxufVxuIiwibGV0IGh0bWx1dGlscyA9IHJlcXVpcmUoIGBodG1sdXRpbHNgIClcblxubW9kdWxlLmV4cG9ydHMgPSBhcHAgPT4ge1xuXHRsZXQganNvblxuXHRyZXR1cm4gPGRpdiBvbmRpYWxvZ3Nob3cgPSB7ICgpID0+IGpzb24udmFsdWUgPSBKU09OLnN0cmluZ2lmeSggYXBwLmdldERldmljZSggYXBwLmFjdGl2ZURldmljZUlkICksIG51bGwsIDMgKSB9ID5cblx0XHQ8Zm9ybVxuXHRcdFx0b25zdWJtaXQgPSB7IGV2ZW50ID0+IHtcblx0XHRcdFx0ZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0XHRsZXQgdGV4dCA9IGpzb24udmFsdWUudHJpbSgpIHx8IG51bGxcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dCAmJiBKU09OLnBhcnNlKCB0ZXh0IClcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0XHRcdHJldHVybiBhbGVydCggZXJyb3IgKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRlYnVnZ2VyXG5cdFx0XHRcdGlmICggdGV4dCApXG5cdFx0XHRcdFx0YXBwLnNhdmVEZXZpY2UoIGFwcC5hY3RpdmVEZXZpY2VJZCwgdGV4dCApXG5cdFx0XHRcdGFwcC5kaWFsb2cgPSBgYFxuXHRcdFx0fSB9XG5cdFx0PlxuXHRcdFx0PHRleHRhcmVhXG5cdFx0XHRcdG5hbWUgPSBcImpzb25cIlxuXHRcdFx0XHRhdXRvZm9jdXMgPSBcImF1dG9mb2N1c1wiXG5cdFx0XHRcdG9uY3JlYXRlID0geyBldmVudCA9PiBqc29uID0gZXZlbnQudGFyZ2V0IH1cblx0XHRcdFx0c3R5bGUgPSB7e1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBgYWJzb2x1dGVgLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdFx0dG9wOiBgMTBtbWAsXG5cdFx0XHRcdFx0Ym90dG9tOiBgMTVtbWAsXG5cdFx0XHRcdFx0Zm9udFNpemU6IGA1MCVgLFxuXHRcdFx0XHR9fVxuXHRcdFx0Lz5cblx0XHRcdDxhXG5cdFx0XHRcdGNsYXNzID0gXCJzYXZlXCJcblx0XHRcdFx0aHJlZiA9IFwiamF2YXNjcmlwdDp2b2lkKDApXCJcblx0XHRcdFx0dGFyZ2V0ID0gXCJfc2VsZlwiXG5cdFx0XHRcdG9udG91Y2ggPSB7IGh0bWx1dGlscy5TdWJtaXQgfVxuXHRcdFx0XHRzdHlsZSA9IHt7XG5cdFx0XHRcdFx0cG9zaXRpb246IGBhYnNvbHV0ZWAsXG5cdFx0XHRcdFx0ZGlzcGxheTogYGJsb2NrYCxcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdGhlaWdodDogYDEwbW1gLFxuXHRcdFx0XHRcdGJvdHRvbTogYDBgLFxuXHRcdFx0XHR9fVxuXHRcdFx0PlNhdmU8L2E+XG5cdFx0PC9mb3JtPlxuXHQ8L2Rpdj5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXBwID0+ICgpID0+IDxkaXYgY2xhc3MgPSBcInN0YXJ0dXBTY3JlZW5cIiA+XG5cdDxwPtCU0L7QsdGA0L4g0L/QvtC20LDQu9C+0LLQsNGC0Ywg0LIg0JLQsNGIPGJyLz7Qo9C80L3Ri9C5INCU0L7QvCE8L3A+XG5cdDxkaXYgY2xhc3MgPSBcInRlbXBsYXRlc1wiID5cblx0XHQ8cD7Qn9C+0LbQsNC70YPQudGB0YLQsCwg0LLRi9Cx0LXRgNC40YLQtSDQvNC10YHRgtC+LCDQs9C00LUg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINGN0YLQvtGCINC/0YPQu9GM0YI6PC9wPlxuXHRcdDx1bCBjbGFzcyA9IFwiaG91c2VUZW1wbGF0ZXNcIiA+eyAoKSA9PiAoIGFwcC50ZW1wbGF0ZXMgfHwgW10gKS5jb25jYXQoIFsge1xuXHRcdFx0bWVudTogYNC90LDRh9Cw0YLRjCDRgSDRh9C40YHRgtC+0LPQviDQu9C40YHRgtCwYCxcblx0XHRcdHJ1OiBg0JzQvtC5INC00L7QvGAsXG5cdFx0XHRlbjogYEhvbWVgLFxuXHRcdFx0dHlwZTogYHBsYWNlYCxcblx0XHR9IF0gKS5tYXAoIGhvdXNlVGVtcGxhdGUgPT5cblx0XHRcdDxsaSBjbGFzcyA9IFwiaG91c2VUZW1wbGF0ZVwiIG9udG91Y2ggPSB7ICgpID0+IGFwcC5zZXRUZW1wbGF0ZSggaG91c2VUZW1wbGF0ZSApIH0gPntcblx0XHRcdFx0aG91c2VUZW1wbGF0ZS5tZW51IHx8IGFwcC5nZXRNZXNzYWdlKCBob3VzZVRlbXBsYXRlIClcblx0XHRcdH08L2xpPlxuXHRcdCkgfTwvdWw+XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzID0gXCJsb2FkaW5nXCIgPjwvZGl2PlxuPC9kaXY+XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5sZXQgY291bnRlciA9IDBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1aWQoIG9iaiApIHtcblx0bGV0IGkgPSAoICsrY291bnRlciApLnRvU3RyaW5nKCAzNiApXG5cdGxldCByID0gcGFyc2VJbnQoIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSggMiwgMTcgKSApLnRvU3RyaW5nKCAzNiApXG5cdGxldCBpZCA9ICggci5sZW5ndGggKyA5ICkudG9TdHJpbmcoIDM2ICkgKyByICsgaVxuXHRpZiAoIG9iaiA9PSBudWxsIClcblx0XHRyZXR1cm4gaWRcblx0ZWxzZSB7XG5cdFx0b2JqLnVpZCA9IGlkXG5cdFx0cmV0dXJuIG9ialxuXHR9XG59XG4iLCIvKlxucG9zdCAvZGV2aWNlcyB7XCJQXCI6MX1cbiovXG5cbmZ1bmN0aW9uIGNoZWNrQnJvd3NlckZ1bmN0aW9ucygpIHtcblx0bGV0IHJldCA9IHRydWVcblx0XHQmJiB0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCAhPSBgdW5kZWZpbmVkYCAmJiBIVE1MVGVtcGxhdGVFbGVtZW50XG5cdHJldHVybiAhIXJldFxufVxuXG5pZiAoICFjaGVja0Jyb3dzZXJGdW5jdGlvbnMoKSApIHtcblx0d2luZG93Ll9fVU5TVVBQT1JURURfXygpXG5cdHRocm93IG5ldyBFcnJvciggXCJ1bnN1cHBvcnRlZFwiIClcbn1cblxucmVxdWlyZSggYGJyb3dzZXItbmV4dHRpY2tgIClcbnJlcXVpcmUoIGBwbGF0Zm9ybWAgKVxucmVxdWlyZSggYGh0bWxwb2x5ZmlsbGAgKVxucmVxdWlyZSggYHRyYWNrYCApXG5yZXF1aXJlKCBgZ2VzdHVyZWAgKVxuXG5nbG9iYWwubHUgPSByZXF1aXJlKCBgbG9jYWxVdGlsc2AgKVxuZ2xvYmFsLnJhID0gcmVxdWlyZSggYHJhYCApXG5nbG9iYWwuY28gPSByZXF1aXJlKCBgY29gIClcbmdsb2JhbC5sb2Rhc2ggPSByZXF1aXJlKCBgbG9kYXNoYCApXG5yZXF1aXJlKCBgY29sb3JzYCApXG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCBldmVudCApIHtcblx0aWYgKCBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSggYHJlbGAgKSA9PSBgZXh0ZXJuYWxgIClcblx0XHRyZXR1cm5cblx0Zm9yICggbGV0IEMgb2YgWyBIVE1MSW5wdXRFbGVtZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50LCBIVE1MT3B0aW9uRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQgXSApXG5cdFx0aWYgKCBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBDIClcblx0XHRcdHJldHVyblxuXHQvLyBhdHRlbXB0IHRvIHVzZSBuYXRpdmUgc2Nyb2xsaW5nIC0gdW5zdWNjZXNzZnVsbFxuXHQvLyBsZXQgQyA9IGV2ZW50LnRhcmdldFxuXHQvLyB3aGlsZSAoIEMgJiYgQy5jbGFzc0xpc3QgKSB7XG5cdC8vIFx0aWYgKCBDLmNsYXNzTGlzdC5jb250YWlucyggYHNjcm9sbGAgKSApXG5cdC8vIFx0XHRyZXR1cm5cblx0Ly8gXHRDID0gQy5wYXJlbnROb2RlXG5cdC8vIH1cblx0ZXZlbnQucHJldmVudERlZmF1bHQoKVxufVxuXG5mb3IgKCBsZXQgdHlwZSBvZiBbIGB0b3VjaHN0YXJ0YCwgYHRvdWNobW92ZWAsIGB0b3VjaGVuZGAsIGB0b3VjaGNhbmNlbGAgXSApXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBwcmV2ZW50RGVmYXVsdCApXG5cbmdsb2JhbC5MT0cgPSBmdW5jdGlvbiAoIHN0ciApIHtcblx0Ly8gaWYgKCBTdHJpbmcoIHN0ciApID09IGB1bmRlZmluZWRgIClcblx0Ly8gXHRkZWJ1Z2dlclxuXHRjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzIClcblx0Z2xvYmFsLl9BTEVSVCAmJiBnbG9iYWwuX0FMRVJUKCBzdHIgKVxuXHRsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblx0eGhyLm9wZW4oIGBQT1NUYCwgYC9sb2c/JHsgZW5jb2RlVVJJQ29tcG9uZW50KCBzdHIgKSB9YCApXG5cdHhoci5vbmVycm9yID0gbG9kYXNoLm5vb3Bcblx0eGhyLnNlbmQoKVxuXHRyZXR1cm4gc3RyXG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBgZXJyb3JgLCBmdW5jdGlvbiBvbkVycm9yKCBlICkge1xuXHRpZiAoICFlLm1lc3NhZ2UubWF0Y2goIDQwNCApICYmICFvbkVycm9yLnByb2Nlc3NpbmcgKSB7XG5cdFx0b25FcnJvci5wcm9jZXNzaW5nID0gdHJ1ZVxuXHRcdHRyeSB7XG5cdFx0XHRMT0coIGAkeyBlLm1lc3NhZ2UucmVkIH0gYXQgJHsgZS5saW5lbm8gfTokeyBlLmNvbG5vIH0gaW4gJHsgZS5maWxlbmFtZSB9YCApXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0b25FcnJvci5wcm9jZXNzaW5nID0gZmFsc2Vcblx0XHR9XG5cdH1cbn0gKVxuXG5sZXQgb25lcnJvciA9IHdpbmRvdy5vbmVycm9yXG53aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uICggbWVzc2FnZSwgdXJsLCBsaW5lLCBjb2x1bW4sIGVycm9yICkge1xuXHRsZXQgcmV0XG5cdGlmICggZXJyb3IgKSB7XG5cdFx0TE9HKCBgc3RhY2s6IGAgKyBlcnJvci5zdGFjayApXG5cdH1cblx0aWYgKCBvbmVycm9yICkge1xuXHRcdHRyeSB7XG5cdFx0XHR3aW5kb3cub25lcnJvciA9IG9uZXJyb3Jcblx0XHRcdHJldCA9IG9uZXJyb3IuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG5cdFx0fVxuXHRcdGZpbmFsbHkge1xuXHRcdFx0b25lcnJvciA9IHdpbmRvdy5vbmVycm9yXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXRcbn1cblxuLy8gcmVxdWlyZSggYHRvdWNoTG9nYCApXG4vLyByZXF1aXJlKCBgdG91Y2hTaG93YCApXG4vLyByZXF1aXJlKCBgdG91Y2hlc2AgKVxuXG5nbG9iYWwuUmVhY3QgPSByZXF1aXJlKCBgY29tcG9uZW50c2AgKVxuXG5mdW5jdGlvbiBzY3JpcHQoIHRleHQgKSB7XG5cdGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBgc2NyaXB0YCApXG5cdHNjcmlwdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRleHQgKSApXG5cdHJldHVybiBzY3JpcHRcbn1cblxuY28uZ28oIGZ1bmN0aW9uKiAoKSB7XG5cdGxldCBodG1sID0gY2FjaGVVcmxSZXNvdXJjZSggYC4vbWFpbi5odG1sYCApXG5cdGh0bWwgPSB5aWVsZCBodG1sXG5cblx0bGV0IGRhdGEgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblxuXHRsZXQgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYGRpdmAgKVxuXHR0bXAuaW5uZXJIVE1MID0gaHRtbFxuXHR0bXAgPSB0bXAuY2hpbGRyZW5bIDAgXVxuXHRsZXQgY2hpbGRyZW4gPSBbXVxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0bXAuY2hpbGROb2Rlcy5sZW5ndGg7ICsraSApXG5cdFx0Y2hpbGRyZW4ucHVzaCggdG1wLmNoaWxkTm9kZXNbIGkgXSApXG5cdGNoaWxkcmVuLmZvckVhY2goIGMgPT4gdG1wLnJlbW92ZUNoaWxkKCBjICkgKVxuXHRjaGlsZHJlbi5mb3JFYWNoKCBjID0+IHtcblx0XHRpZiAoIGMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCApXG5cdFx0XHRjID0gc2NyaXB0KCBjLmlubmVySFRNTCApXG5cdFx0ZGF0YS5hcHBlbmRDaGlsZCggYyApXG5cdH0gKVxuXG5cdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGRhdGEgKVxufSApXG5cbi8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAvLyBUT0RPOiDQstGL0LTQsNC70ZbRhtGMINC/0LDRgdGM0LvRjyDQstGL0YHRgtCw0LLRiy4g0J3QsNC00YLQsCDRgdGC0YDQsNGI0L3QsCDRj9C90L4g0LTQt9GR0YDQs9Cw0LXRhtGG0LAg0L/RgNGLINC/0LXRgNCw0LfQsNCz0YDRg9C30YbRi1xuLy8gXHRgbWVzc2FnZWAsXG4vLyBcdGV2ZW50ID0+IHtcbi8vIFx0XHRpZiAoIGV2ZW50ICYmIGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS53aGF0ID09IGB1cmxSZXNvdXJjZVVwZGF0ZWRgIClcbi8vIFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KFxuLy8gXHRcdFx0XHQoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCksXG4vLyBcdFx0XHRcdDEwMDBcbi8vIFx0XHRcdClcbi8vIFx0fSxcbi8vIFx0ZmFsc2Vcbi8vIClcbiIsImxldCByYSA9IHJlcXVpcmUoIGByYWAgKVxuXG5sZXQgd2luZG93U2l6ZSA9IHJhLmNsZWFuKCB7XG5cdHdpZHRoOiAxLFxuXHRoZWlnaHQ6IDEsXG5cdHBwbW06IDEsXG5cdHdpZHRobW06IDEsXG5cdGhlaWdodG1tOiAxLFxuXHRwaXhlbFJhdGlvOiAxLFxuXHRvcmllbnRhdGlvbjogMCxcblx0bGF5b3V0OiBgdmVydGljYWxgLFxuXHR3aW5kb3c6IGBicm93c2VyYCxcbn0gKS5zZXROYW1lKCBgd2luZG93U2l6ZWAgKVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggYHJlc2l6ZWAsIHVwZGF0ZVNpemUgKVxuXG4vLyBsZXQgb3JpZW50YXRpb25zID0ge31cblxubGV0IGNtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYGRpdmAgKVxuY20uc3R5bGUubGVmdCA9IGAwYFxuY20uc3R5bGUudG9wID0gYDBgXG5jbS5zdHlsZS53aWR0aCA9IGAxMGNtYFxuY20uc3R5bGUuaGVpZ2h0ID0gYDEwY21gXG5jbS5zdHlsZS5wb3NpdGlvbiA9IGBmaXhlZGBcbmNtLnN0eWxlLnpJbmRleCA9IGAtOTk5OWBcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGNtIClcbmxldCBwcG1tID0gY20uY2xpZW50V2lkdGggLyAxMDBcbmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIGNtIClcblxudXBkYXRlU2l6ZSgpXG5cbmZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG5cblx0bGV0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGhcblx0bGV0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuXG5cdGxldCBvcmllbnRhdGlvbiA9ICggd2luZG93Lm9yaWVudGF0aW9uIHx8IDAgKSAlIDM2MFxuXHRpZiAoIG9yaWVudGF0aW9uIDwgMCApIG9yaWVudGF0aW9uICs9IDM2MFxuXG5cdHdpbmRvd1NpemUud2lkdGggPSB3aWR0aFxuXHR3aW5kb3dTaXplLmhlaWdodCA9IGhlaWdodFxuXHR3aW5kb3dTaXplLnBwbW0gPSBwcG1tXG5cdHdpbmRvd1NpemUud2lkdGhtbSA9IHdpZHRoIC8gcHBtbVxuXHR3aW5kb3dTaXplLmhlaWdodG1tID0gaGVpZ2h0IC8gcHBtbVxuXHR3aW5kb3dTaXplLnBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxXG5cdHdpbmRvd1NpemUub3JpZW50YXRpb24gPSBvcmllbnRhdGlvblxuXHR3aW5kb3dTaXplLmxheW91dCA9IHdpZHRoIDw9IGhlaWdodCA/IGB2ZXJ0aWNhbGAgOiBgaG9yaXpvbnRhbGBcblx0d2luZG93U2l6ZS53aW5kb3cgPSB3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgPyBgYXBwYCA6IGBicm93c2VyYFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1NpemVcbiIsInJlcXVpcmUoIFwid2VicGFnZVwiIClcbnJlcXVpcmUoIFwidWkvT25lQXBwXCIgKVxuZ2xvYmFsLnJlcXVpcmUgPSBmdW5jdGlvbiByKCBuYW1lICkge1xuXHRcdFx0XHRcdGdsb2JhbC5yZXF1aXJlID0gbnVsbFxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVxdWlyZS5hcHBseSggdGhpcywgYXJndW1lbnRzIClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdFx0XHRnbG9iYWwucmVxdWlyZSA9IHJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cbiJdfQ==
